/**
 * Pipe action context type.
 */
interface PipeActionContext {
    type: string;
    expects: string | null;
    message: ErrorMessage | undefined;
    requirement: unknown;
}
/**
 * Valid action result type.
 */
interface ValidActionResult<TOutput> {
    /**
     * The pipe output.
     */
    output: TOutput;
    /**
     * The pipe issues.
     */
    issues?: undefined;
}
/**
 * Invalid action result type.
 */
interface InvalidActionResult {
    /**
     * The pipe output.
     */
    output?: undefined;
    /**
     * The pipe issues.
     */
    issues: PipeActionIssues;
}
/**
 * Pipe action result type.
 */
type PipeActionResult<TOutput> = ValidActionResult<TOutput> | InvalidActionResult;
/**
 * Base validation type.
 */
interface BaseValidation<TInput = any> {
    /**
     * The validation type.
     */
    type: string;
    /**
     * The expected property.
     */
    expects: string | null;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * Whether it's async.
     */
    async: false;
    /**
     * The validation requirement.
     */
    requirement: unknown;
    /**
     * Parses unknown input based on its requirement.
     *
     * @param input The input to be parsed.
     *
     * @returns The pipe action result.
     *
     * @internal
     */
    _parse(input: TInput): PipeActionResult<TInput>;
}
/**
 * Base validation async type.
 */
interface BaseValidationAsync<TInput = any> {
    /**
     * The validation type.
     */
    type: string;
    /**
     * The expected property.
     */
    expects: string | null;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * Whether it's async.
     */
    async: true;
    /**
     * The validation requirement.
     */
    requirement: unknown;
    /**
     * Parses unknown input based on its requirement.
     *
     * @param input The input to be parsed.
     *
     * @returns The pipe action result.
     *
     * @internal
     */
    _parse(input: TInput): Promise<PipeActionResult<TInput>>;
}
/**
 * Base transformation type.
 */
interface BaseTransformation<TInput = any> {
    /**
     * The transformation type.
     */
    type: string;
    /**
     * Whether it's async.
     */
    async: false;
    /**
     * Parses unknown input based on its requirement.
     *
     * @param input The input to be parsed.
     *
     * @returns The pipe action result.
     *
     * @internal
     */
    _parse(input: TInput): PipeActionResult<TInput>;
}
/**
 * Base transformation async type.
 */
interface BaseTransformationAsync<TInput = any> {
    /**
     * The transformation type.
     */
    type: string;
    /**
     * Whether it's async.
     */
    async: true;
    /**
     * Parses unknown input based on its requirement.
     *
     * @param input The input to be parsed.
     *
     * @returns The pipe action result.
     *
     * @internal
     */
    _parse(input: TInput): Promise<PipeActionResult<TInput>>;
}
/**
 * Pipe type.
 */
type Pipe<TInput> = (BaseValidation<TInput> | BaseTransformation<TInput>)[];
/**
 * Pipe async type.
 */
type PipeAsync<TInput> = (BaseValidation<TInput> | BaseValidationAsync<TInput> | BaseTransformation<TInput> | BaseTransformationAsync<TInput>)[];

/**
 * Issue reason type.
 */
type IssueReason = 'any' | 'array' | 'bigint' | 'blob' | 'boolean' | 'date' | 'intersect' | 'function' | 'instance' | 'map' | 'number' | 'object' | 'record' | 'set' | 'special' | 'string' | 'symbol' | 'tuple' | 'undefined' | 'union' | 'unknown' | 'variant' | 'type';
/**
 * Unknown path item type.
 */
interface UnknownPathItem {
    type: 'unknown';
    origin: 'key' | 'value';
    input: unknown;
    key: unknown;
    value: unknown;
}
/**
 * Path item type.
 */
type PathItem = ArrayPathItem | MapPathItem | ObjectPathItem | RecordPathItem | SetPathItem | TuplePathItem | UnknownPathItem;
/**
 * Issue path type.
 */
type IssuePath = [PathItem, ...PathItem[]];
/**
 * Schema issue type.
 */
interface SchemaIssue extends Omit<SchemaConfig, 'message'> {
    /**
     * The issue reason.
     */
    reason: IssueReason;
    /**
     * The context name.
     */
    context: string;
    /**
     * The raw input data.
     */
    input: unknown;
    /**
     * The expected input.
     */
    expected: string | null;
    /**
     * The received input.
     */
    received: string;
    /**
     * The error message.
     */
    message: string;
    /**
     * The validation requirement
     */
    requirement?: unknown;
    /**
     * The issue path.
     */
    path?: IssuePath;
    /**
     * The sub issues.
     */
    issues?: SchemaIssues;
}
/**
 * Schema issues type.
 */
type SchemaIssues = [SchemaIssue, ...SchemaIssue[]];
/**
 * Pipe action issue type.
 */
interface PipeActionIssue {
    context: PipeActionContext;
    reference: Function;
    input: unknown;
    label: string;
    received?: string;
    path?: IssuePath;
}
/**
 * Pipe action issues type.
 */
type PipeActionIssues = [PipeActionIssue, ...PipeActionIssue[]];

/**
 * Error message type.
 */
type ErrorMessage = string | ((issue: SchemaIssue) => string);
/**
 * The schema config type.
 */
interface SchemaConfig {
    /**
     * The selected language.
     */
    lang?: string;
    /**
     * The error message.
     */
    message?: ErrorMessage;
    /**
     * Whether it was abort early.
     */
    abortEarly?: boolean;
    /**
     * Whether the pipe was abort early.
     */
    abortPipeEarly?: boolean;
    /**
     * Whether the pipe was skipped.
     */
    skipPipe?: boolean;
}

/**
 * Typed schema result type.
 */
interface TypedSchemaResult<TOutput> {
    /**
     * Whether is's typed.
     */
    typed: true;
    /**
     * The parse output.
     */
    output: TOutput;
    /**
     * The parse issues.
     */
    issues?: SchemaIssues;
}
/**
 * Untyped schema result type.
 */
interface UntypedSchemaResult {
    /**
     * Whether is's typed.
     */
    typed: false;
    /**
     * The parse output.
     */
    output: unknown;
    /**
     * The parse issues.
     */
    issues: SchemaIssues;
}
/**
 * Schema result type.
 */
type SchemaResult<TOutput> = TypedSchemaResult<TOutput> | UntypedSchemaResult;
/**
 * Base schema type.
 */
interface BaseSchema<TInput = any, TOutput = TInput> {
    /**
     * The schema type.
     */
    type: string;
    /**
     * The expected property.
     */
    expects: string;
    /**
     * Whether it's async.
     */
    async: false;
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param config The parse configuration.
     *
     * @returns The schema result.
     *
     * @internal
     */
    _parse(input: unknown, config?: SchemaConfig): SchemaResult<TOutput>;
    /**
     * Input and output type.
     *
     * @internal
     */
    _types?: {
        input: TInput;
        output: TOutput;
    };
}
/**
 * Base schema async type.
 */
interface BaseSchemaAsync<TInput = any, TOutput = TInput> {
    /**
     * The schema type.
     */
    type: string;
    /**
     * The expected property.
     */
    expects: string;
    /**
     * Whether it's async.
     */
    async: true;
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param config The parse configuration.
     *
     * @returns The schema result.
     *
     * @internal
     */
    _parse(input: unknown, config?: SchemaConfig): Promise<SchemaResult<TOutput>>;
    /**
     * Input and output type.
     *
     * @internal
     */
    _types?: {
        input: TInput;
        output: TOutput;
    };
}
/**
 * Input inference type.
 */
type Input<TSchema extends BaseSchema | BaseSchemaAsync> = NonNullable<TSchema['_types']>['input'];
/**
 * Output inference type.
 */
type Output<TSchema extends BaseSchema | BaseSchemaAsync> = NonNullable<TSchema['_types']>['output'];

/**
 * Default type.
 */
type Default<TSchema extends BaseSchema> = Input<TSchema> | (() => Input<TSchema> | undefined) | undefined;
/**
 * Default async type.
 */
type DefaultAsync<TSchema extends BaseSchema | BaseSchemaAsync> = Input<TSchema> | (() => Input<TSchema> | Promise<Input<TSchema> | undefined> | undefined) | undefined;
/**
 * Object keys type.
 */
type ObjectKeys<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>> = MaybeReadonly<[keyof TSchema['entries'], ...(keyof TSchema['entries'])[]]>;
/**
 * Maybe readonly type.
 */
type MaybeReadonly<T> = T | Readonly<T>;
/**
 * Maybe promise type.
 *
 * TODO: Refactor library with this type.
 */
type MaybePromise<T> = T | Promise<T>;
/**
 * Resolve type.
 *
 * Hint: This type has no effect and is only used so that TypeScript displays
 * the final type in the preview instead of the utility types used.
 */
type Resolve<T> = T;
/**
 * Resolve object type.
 *
 * Hint: This type has no effect and is only used so that TypeScript displays
 * the final type in the preview instead of the utility types used.
 */
type ResolveObject<T> = Resolve<{
    [k in keyof T]: T[k];
}>;

/**
 * Any schema type.
 */
interface AnySchema<TOutput = any> extends BaseSchema<any, TOutput> {
    /**
     * The schema type.
     */
    type: 'any';
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<any> | undefined;
}
/**
 * Creates an any schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An any schema.
 */
declare function any(pipe?: Pipe<any>): AnySchema;

/**
 * Any schema type.
 */
interface AnySchemaAsync<TOutput = any> extends BaseSchemaAsync<any, TOutput> {
    /**
     * The schema type.
     */
    type: 'any';
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<any> | undefined;
}
/**
 * Creates an async any schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async any schema.
 */
declare function anyAsync(pipe?: PipeAsync<any>): AnySchemaAsync;

/**
 * Array schema type.
 */
interface ArraySchema<TItem extends BaseSchema, TOutput = Output<TItem>[]> extends BaseSchema<Input<TItem>[], TOutput> {
    /**
     * The schema type.
     */
    type: 'array';
    /**
     * The array item schema.
     */
    item: TItem;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<Output<TItem>[]> | undefined;
}
/**
 * Creates a array schema.
 *
 * @param item The item schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A array schema.
 */
declare function array<TItem extends BaseSchema>(item: TItem, pipe?: Pipe<Output<TItem>[]>): ArraySchema<TItem>;
/**
 * Creates a array schema.
 *
 * @param item The item schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A array schema.
 */
declare function array<TItem extends BaseSchema>(item: TItem, message?: ErrorMessage, pipe?: Pipe<Output<TItem>[]>): ArraySchema<TItem>;

/**
 * Array schema async type.
 */
interface ArraySchemaAsync<TItem extends BaseSchema | BaseSchemaAsync, TOutput = Output<TItem>[]> extends BaseSchemaAsync<Input<TItem>[], TOutput> {
    /**
     * The schema type.
     */
    type: 'array';
    /**
     * The array item schema.
     */
    item: TItem;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<Output<TItem>[]> | undefined;
}
/**
 * Creates an async array schema.
 *
 * @param item The item schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async array schema.
 */
declare function arrayAsync<TItem extends BaseSchema | BaseSchemaAsync>(item: TItem, pipe?: PipeAsync<Output<TItem>[]>): ArraySchemaAsync<TItem>;
/**
 * Creates an async array schema.
 *
 * @param item The item schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async array schema.
 */
declare function arrayAsync<TItem extends BaseSchema | BaseSchemaAsync>(item: TItem, message?: ErrorMessage, pipe?: PipeAsync<Output<TItem>[]>): ArraySchemaAsync<TItem>;

/**
 * Array path item type.
 */
interface ArrayPathItem {
    type: 'array';
    origin: 'value';
    input: unknown[];
    key: number;
    value: unknown;
}

/**
 * Bigint schema type.
 */
interface BigintSchema<TOutput = bigint> extends BaseSchema<bigint, TOutput> {
    /**
     * The schema type.
     */
    type: 'bigint';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<bigint> | undefined;
}
/**
 * Creates a bigint schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns A bigint schema.
 */
declare function bigint(pipe?: Pipe<bigint>): BigintSchema;
/**
 * Creates a bigint schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A bigint schema.
 */
declare function bigint(message?: ErrorMessage, pipe?: Pipe<bigint>): BigintSchema;

/**
 * Bigint schema async type.
 */
interface BigintSchemaAsync<TOutput = bigint> extends BaseSchemaAsync<bigint, TOutput> {
    /**
     * The schema type.
     */
    type: 'bigint';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<bigint> | undefined;
}
/**
 * Creates an async bigint schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async bigint schema.
 */
declare function bigintAsync(pipe?: PipeAsync<bigint>): BigintSchemaAsync;
/**
 * Creates an async bigint schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async bigint schema.
 */
declare function bigintAsync(message?: ErrorMessage, pipe?: PipeAsync<bigint>): BigintSchemaAsync;

/**
 * Blob schema type.
 */
interface BlobSchema<TOutput = Blob> extends BaseSchema<Blob, TOutput> {
    /**
     * The schema type.
     */
    type: 'blob';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<Blob> | undefined;
}
/**
 * Creates a blob schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns A blob schema.
 */
declare function blob(pipe?: Pipe<Blob>): BlobSchema;
/**
 * Creates a blob schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A blob schema.
 */
declare function blob(message?: ErrorMessage, pipe?: Pipe<Blob>): BlobSchema;

/**
 * Blob schema async type.
 */
interface BlobSchemaAsync<TOutput = Blob> extends BaseSchemaAsync<Blob, TOutput> {
    /**
     * The schema type.
     */
    type: 'blob';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<Blob> | undefined;
}
/**
 * Creates an async blob schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async blob schema.
 */
declare function blobAsync(pipe?: PipeAsync<Blob>): BlobSchemaAsync;
/**
 * Creates an async blob schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async blob schema.
 */
declare function blobAsync(message?: ErrorMessage, pipe?: PipeAsync<Blob>): BlobSchemaAsync;

/**
 * Boolean schema type.
 */
interface BooleanSchema<TOutput = boolean> extends BaseSchema<boolean, TOutput> {
    /**
     * The schema type.
     */
    type: 'boolean';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<boolean> | undefined;
}
/**
 * Creates a boolean schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns A boolean schema.
 */
declare function boolean(pipe?: Pipe<boolean>): BooleanSchema;
/**
 * Creates a boolean schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A boolean schema.
 */
declare function boolean(message?: ErrorMessage, pipe?: Pipe<boolean>): BooleanSchema;

/**
 * Boolean schema async type.
 */
interface BooleanSchemaAsync<TOutput = boolean> extends BaseSchemaAsync<boolean, TOutput> {
    /**
     * The schema type.
     */
    type: 'boolean';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<boolean> | undefined;
}
/**
 * Creates an async boolean schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async boolean schema.
 */
declare function booleanAsync(pipe?: PipeAsync<boolean>): BooleanSchemaAsync;
/**
 * Creates an async boolean schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async boolean schema.
 */
declare function booleanAsync(message?: ErrorMessage, pipe?: PipeAsync<boolean>): BooleanSchemaAsync;

/**
 * Date schema type.
 */
interface DateSchema<TOutput = Date> extends BaseSchema<Date, TOutput> {
    /**
     * The schema type.
     */
    type: 'date';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<Date> | undefined;
}
/**
 * Creates a date schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns A date schema.
 */
declare function date(pipe?: Pipe<Date>): DateSchema;
/**
 * Creates a date schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A date schema.
 */
declare function date(message?: ErrorMessage, pipe?: Pipe<Date>): DateSchema;

/**
 * Date schema async type.
 */
interface DateSchemaAsync<TOutput = Date> extends BaseSchemaAsync<Date, TOutput> {
    /**
     * The schema type.
     */
    type: 'date';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<Date> | undefined;
}
/**
 * Creates an async date schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async date schema.
 */
declare function dateAsync(pipe?: PipeAsync<Date>): DateSchemaAsync;
/**
 * Creates an async date schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async date schema.
 */
declare function dateAsync(message?: ErrorMessage, pipe?: PipeAsync<Date>): DateSchemaAsync;

/**
 * Enum type.
 */
interface Enum {
    [key: string]: string | number;
    [key: number]: string;
}
/**
 * Native enum schema type.
 */
interface EnumSchema<TEnum extends Enum, TOutput = TEnum[keyof TEnum]> extends BaseSchema<TEnum[keyof TEnum], TOutput> {
    /**
     * The schema type.
     */
    type: 'enum';
    /**
     * The enum value.
     */
    enum: TEnum;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an enum schema.
 *
 * @param enum__ The enum value.
 * @param message The error message.
 *
 * @returns An enum schema.
 */
declare function enum_<TEnum extends Enum>(enum__: TEnum, message?: ErrorMessage): EnumSchema<TEnum>;

/**
 * Native enum schema async type.
 */
interface EnumSchemaAsync<TEnum extends Enum, TOutput = TEnum[keyof TEnum]> extends BaseSchemaAsync<TEnum[keyof TEnum], TOutput> {
    /**
     * The schema type.
     */
    type: 'enum';
    /**
     * The enum value.
     */
    enum: TEnum;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async enum schema.
 *
 * @param enum_ The enum value.
 * @param message The error message.
 *
 * @returns An async enum schema.
 */
declare function enumAsync<TEnum extends Enum>(enum_: TEnum, message?: ErrorMessage): EnumSchemaAsync<TEnum>;

/**
 * Class type.
 */
type Class = abstract new (...args: any) => any;

/**
 * Instance schema type.
 */
interface InstanceSchema<TClass extends Class, TOutput = InstanceType<TClass>> extends BaseSchema<InstanceType<TClass>, TOutput> {
    /**
     * The schema type.
     */
    type: 'instance';
    /**
     * The class of the instance.
     */
    class: TClass;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<InstanceType<TClass>> | undefined;
}
/**
 * Creates an instance schema.
 *
 * @param class_ The class of the instance.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An instance schema.
 */
declare function instance<TClass extends Class>(class_: TClass, pipe?: Pipe<InstanceType<TClass>>): InstanceSchema<TClass>;
/**
 * Creates an instance schema.
 *
 * @param class_ The class of the instance.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An instance schema.
 */
declare function instance<TClass extends Class>(class_: TClass, message?: ErrorMessage, pipe?: Pipe<InstanceType<TClass>>): InstanceSchema<TClass>;

/**
 * Instance schema type.
 */
interface InstanceSchemaAsync<TClass extends Class, TOutput = InstanceType<TClass>> extends BaseSchemaAsync<InstanceType<TClass>, TOutput> {
    /**
     * The schema type.
     */
    type: 'instance';
    /**
     * The class of the instance.
     */
    class: TClass;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<InstanceType<TClass>> | undefined;
}
/**
 * Creates an async instance schema.
 *
 * @param class_ The class of the instance.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async instance schema.
 */
declare function instanceAsync<TClass extends Class>(class_: TClass, pipe?: PipeAsync<InstanceType<TClass>>): InstanceSchemaAsync<TClass>;
/**
 * Creates an async instance schema.
 *
 * @param class_ The class of the instance.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async instance schema.
 */
declare function instanceAsync<TClass extends Class>(class_: TClass, message?: ErrorMessage, pipe?: PipeAsync<InstanceType<TClass>>): InstanceSchemaAsync<TClass>;

/**
 * Intersect options async type.
 */
type IntersectOptionsAsync = MaybeReadonly<[
    BaseSchema | BaseSchemaAsync,
    BaseSchema | BaseSchemaAsync,
    ...(BaseSchema[] | BaseSchemaAsync[])
]>;
/**
 * Intersect schema async type.
 */
interface IntersectSchemaAsync<TOptions extends IntersectOptionsAsync, TOutput = IntersectOutput<TOptions>> extends BaseSchemaAsync<IntersectInput<TOptions>, TOutput> {
    /**
     * The schema type.
     */
    type: 'intersect';
    /**
     * The intersect options.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<IntersectInput<TOptions>> | undefined;
}
/**
 * Creates an async intersect schema.
 *
 * @param options The intersect options.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async intersect schema.
 */
declare function intersectAsync<TOptions extends IntersectOptionsAsync>(options: TOptions, pipe?: PipeAsync<IntersectInput<TOptions>>): IntersectSchemaAsync<TOptions>;
/**
 * Creates an async intersect schema.
 *
 * @param options The intersect options.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async intersect schema.
 */
declare function intersectAsync<TOptions extends IntersectOptionsAsync>(options: TOptions, message?: ErrorMessage, pipe?: PipeAsync<IntersectInput<TOptions>>): IntersectSchemaAsync<TOptions>;

/**
 * Intersect input inference type.
 */
type IntersectInput<TIntersectOptions extends IntersectOptions | IntersectOptionsAsync> = TIntersectOptions extends [
    BaseSchema<infer TInput1, any> | BaseSchemaAsync<infer TInput1, any>,
    ...infer TRest
] ? TRest extends IntersectOptions ? TInput1 & IntersectOutput<TRest> : TRest extends [
    BaseSchema<infer TInput2, any> | BaseSchemaAsync<infer TInput2, any>
] ? TInput1 & TInput2 : never : never;
/**
 * Intersect output inference type.
 */
type IntersectOutput<TIntersectOptions extends IntersectOptions | IntersectOptionsAsync> = TIntersectOptions extends [
    BaseSchema<any, infer TOutput1> | BaseSchemaAsync<any, infer TOutput1>,
    ...infer TRest
] ? TRest extends IntersectOptions ? TOutput1 & IntersectOutput<TRest> : TRest extends [
    BaseSchema<any, infer TOutput2> | BaseSchemaAsync<any, infer TOutput2>
] ? TOutput1 & TOutput2 : never : never;

/**
 * Intersect options type.
 */
type IntersectOptions = MaybeReadonly<[
    BaseSchema,
    BaseSchema,
    ...BaseSchema[]
]>;
/**
 * Intersect schema type.
 */
interface IntersectSchema<TOptions extends IntersectOptions, TOutput = IntersectOutput<TOptions>> extends BaseSchema<IntersectInput<TOptions>, TOutput> {
    /**
     * The schema type.
     */
    type: 'intersect';
    /**
     * The intersect options.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<IntersectOutput<TOptions>> | undefined;
}
/**
 * Creates an intersect schema.
 *
 * @param options The intersect options.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An intersect schema.
 */
declare function intersect<TOptions extends IntersectOptions>(options: TOptions, pipe?: Pipe<IntersectOutput<TOptions>>): IntersectSchema<TOptions>;
/**
 * Creates an intersect schema.
 *
 * @param options The intersect options.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An intersect schema.
 */
declare function intersect<TOptions extends IntersectOptions>(options: TOptions, message?: ErrorMessage, pipe?: Pipe<IntersectOutput<TOptions>>): IntersectSchema<TOptions>;

/**
 * Lazy schema type.
 */
interface LazySchema<TGetter extends (input: unknown) => BaseSchema, TOutput = Output<ReturnType<TGetter>>> extends BaseSchema<Input<ReturnType<TGetter>>, TOutput> {
    /**
     * The schema type.
     */
    type: 'lazy';
    /**
     * The schema getter.
     */
    getter: TGetter;
}
/**
 * Creates a lazy schema.
 *
 * @param getter The schema getter.
 *
 * @returns A lazy schema.
 */
declare function lazy<TGetter extends (input: unknown) => BaseSchema>(getter: TGetter): LazySchema<TGetter>;

/**
 * Lazy schema async type.
 */
interface LazySchemaAsync<TGetter extends (input: unknown) => MaybePromise<BaseSchema | BaseSchemaAsync>, TOutput = Output<Awaited<ReturnType<TGetter>>>> extends BaseSchemaAsync<Input<Awaited<ReturnType<TGetter>>>, TOutput> {
    /**
     * The schema type.
     */
    type: 'lazy';
    /**
     * The schema getter.
     */
    getter: TGetter;
}
/**
 * Creates an async lazy schema.
 *
 * @param getter The schema getter.
 *
 * @returns An async lazy schema.
 */
declare function lazyAsync<TGetter extends (input: unknown) => MaybePromise<BaseSchema | BaseSchemaAsync>>(getter: TGetter): LazySchemaAsync<TGetter>;

/**
 * Literal type.
 */
type Literal = number | string | boolean | symbol | bigint;

/**
 * Literal schema type.
 */
interface LiteralSchema<TLiteral extends Literal, TOutput = TLiteral> extends BaseSchema<TLiteral, TOutput> {
    /**
     * The schema type.
     */
    type: 'literal';
    /**
     * The literal value.
     */
    literal: TLiteral;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a literal schema.
 *
 * @param literal_ The literal value.
 * @param message The error message.
 *
 * @returns A literal schema.
 */
declare function literal<TLiteral extends Literal>(literal_: TLiteral, message?: ErrorMessage): LiteralSchema<TLiteral>;

/**
 * Literal schema async type.
 */
interface LiteralSchemaAsync<TLiteral extends Literal, TOutput = TLiteral> extends BaseSchemaAsync<TLiteral, TOutput> {
    /**
     * The schema type.
     */
    type: 'literal';
    /**
     * The literal value.
     */
    literal: TLiteral;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async literal schema.
 *
 * @param literal The literal value.
 * @param message The error message.
 *
 * @returns An async literal schema.
 */
declare function literalAsync<TLiteral extends Literal>(literal: TLiteral, message?: ErrorMessage): LiteralSchemaAsync<TLiteral>;

/**
 * Map path item type.
 */
interface MapPathItem {
    type: 'map';
    origin: 'key' | 'value';
    input: Map<unknown, unknown>;
    key: unknown;
    value: unknown;
}
/**
 * Map input inference type.
 */
type MapInput<TKey extends BaseSchema | BaseSchemaAsync, TValue extends BaseSchema | BaseSchemaAsync> = Map<Input<TKey>, Input<TValue>>;
/**
 * Map output inference type.
 */
type MapOutput<TKey extends BaseSchema | BaseSchemaAsync, TValue extends BaseSchema | BaseSchemaAsync> = Map<Output<TKey>, Output<TValue>>;

/**
 * Map schema type.
 */
interface MapSchema<TKey extends BaseSchema, TValue extends BaseSchema, TOutput = MapOutput<TKey, TValue>> extends BaseSchema<MapInput<TKey, TValue>, TOutput> {
    /**
     * The schema type.
     */
    type: 'map';
    /**
     * The map key schema.
     */
    key: TKey;
    /**
     * The map value schema.
     */
    value: TValue;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<MapOutput<TKey, TValue>> | undefined;
}
/**
 * Creates a map schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A map schema.
 */
declare function map<TKey extends BaseSchema, TValue extends BaseSchema>(key: TKey, value: TValue, pipe?: Pipe<MapOutput<TKey, TValue>>): MapSchema<TKey, TValue>;
/**
 * Creates a map schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A map schema.
 */
declare function map<TKey extends BaseSchema, TValue extends BaseSchema>(key: TKey, value: TValue, message?: ErrorMessage, pipe?: Pipe<MapOutput<TKey, TValue>>): MapSchema<TKey, TValue>;

/**
 * Map schema async type.
 */
interface MapSchemaAsync<TKey extends BaseSchema | BaseSchemaAsync, TValue extends BaseSchema | BaseSchemaAsync, TOutput = MapOutput<TKey, TValue>> extends BaseSchemaAsync<MapInput<TKey, TValue>, TOutput> {
    /**
     * The schema type.
     */
    type: 'map';
    /**
     * The map key schema.
     */
    key: TKey;
    /**
     * The map value schema.
     */
    value: TValue;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<MapOutput<TKey, TValue>> | undefined;
}
/**
 * Creates an async map schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async map schema.
 */
declare function mapAsync<TKey extends BaseSchema | BaseSchemaAsync, TValue extends BaseSchema | BaseSchemaAsync>(key: TKey, value: TValue, pipe?: PipeAsync<MapOutput<TKey, TValue>>): MapSchemaAsync<TKey, TValue>;
/**
 * Creates an async map schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async map schema.
 */
declare function mapAsync<TKey extends BaseSchema | BaseSchemaAsync, TValue extends BaseSchema | BaseSchemaAsync>(key: TKey, value: TValue, message?: ErrorMessage, pipe?: PipeAsync<MapOutput<TKey, TValue>>): MapSchemaAsync<TKey, TValue>;

/**
 * NaN schema type.
 */
interface NanSchema<TOutput = number> extends BaseSchema<number, TOutput> {
    /**
     * The schema type.
     */
    type: 'nan';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a NaN schema.
 *
 * @param message The error message.
 *
 * @returns A NaN schema.
 */
declare function nan(message?: ErrorMessage): NanSchema;

/**
 * NaN schema async type.
 */
interface NanSchemaAsync<TOutput = number> extends BaseSchemaAsync<number, TOutput> {
    /**
     * The schema type.
     */
    type: 'nan';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async NaN schema.
 *
 * @param message The error message.
 *
 * @returns An async NaN schema.
 */
declare function nanAsync(message?: ErrorMessage): NanSchemaAsync;

/**
 * Never schema type.
 */
interface NeverSchema extends BaseSchema<never> {
    /**
     * The schema type.
     */
    type: 'never';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a never schema.
 *
 * @param message The error message.
 *
 * @returns A never schema.
 */
declare function never(message?: ErrorMessage): NeverSchema;

/**
 * Never schema async type.
 */
interface NeverSchemaAsync extends BaseSchemaAsync<never> {
    /**
     * The schema type.
     */
    type: 'never';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async never schema.
 *
 * @param message The error message.
 *
 * @returns An async never schema.
 */
declare function neverAsync(message?: ErrorMessage): NeverSchemaAsync;

/**
 * Non nullable type.
 */
type NonNullable$1<T> = T extends null ? never : T;
/**
 * Non nullable input inference type.
 */
type NonNullableInput<TWrapped extends BaseSchema | BaseSchemaAsync> = NonNullable$1<Input<TWrapped>>;
/**
 * Non nullable output inference type.
 */
type NonNullableOutput<TWrapped extends BaseSchema | BaseSchemaAsync> = NonNullable$1<Output<TWrapped>>;

/**
 * Non nullable schema type.
 */
interface NonNullableSchema<TWrapped extends BaseSchema, TOutput = NonNullableOutput<TWrapped>> extends BaseSchema<NonNullableInput<TWrapped>, TOutput> {
    /**
     * The schema type.
     */
    type: 'non_nullable';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a non nullable schema.
 *
 * @param wrapped The wrapped schema.
 * @param message The error message.
 *
 * @returns A non nullable schema.
 */
declare function nonNullable<TWrapped extends BaseSchema>(wrapped: TWrapped, message?: ErrorMessage): NonNullableSchema<TWrapped>;

/**
 * Non nullable schema async type.
 */
interface NonNullableSchemaAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TOutput = NonNullableOutput<TWrapped>> extends BaseSchemaAsync<NonNullableInput<TWrapped>, TOutput> {
    /**
     * The schema type.
     */
    type: 'non_nullable';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async non nullable schema.
 *
 * @param wrapped The wrapped schema.
 * @param message The error message.
 *
 * @returns An async non nullable schema.
 */
declare function nonNullableAsync<TWrapped extends BaseSchema | BaseSchemaAsync>(wrapped: TWrapped, message?: ErrorMessage): NonNullableSchemaAsync<TWrapped>;

/**
 * Non nullish type.
 */
type NonNullish<T> = T extends null | undefined ? never : T;
/**
 * Non nullish input inference type.
 */
type NonNullishInput<TWrapped extends BaseSchema | BaseSchemaAsync> = NonNullish<Input<TWrapped>>;
/**
 * Non nullish output inference type.
 */
type NonNullishOutput<TWrapped extends BaseSchema | BaseSchemaAsync> = NonNullish<Output<TWrapped>>;

/**
 * Non nullish schema type.
 */
interface NonNullishSchema<TWrapped extends BaseSchema, TOutput = NonNullishOutput<TWrapped>> extends BaseSchema<NonNullishInput<TWrapped>, TOutput> {
    /**
     * The schema type.
     */
    type: 'non_nullish';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a non nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param message The error message.
 *
 * @returns A non nullish schema.
 */
declare function nonNullish<TWrapped extends BaseSchema>(wrapped: TWrapped, message?: ErrorMessage): NonNullishSchema<TWrapped>;

/**
 * Non nullish schema async type.
 */
interface NonNullishSchemaAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TOutput = NonNullishOutput<TWrapped>> extends BaseSchemaAsync<NonNullishInput<TWrapped>, TOutput> {
    /**
     * The schema type.
     */
    type: 'non_nullish';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async non nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param message The error message.
 *
 * @returns An async non nullish schema.
 */
declare function nonNullishAsync<TWrapped extends BaseSchema | BaseSchemaAsync>(wrapped: TWrapped, message?: ErrorMessage): NonNullishSchemaAsync<TWrapped>;

/**
 * Non optional type.
 */
type NonOptional<T> = T extends undefined ? never : T;
/**
 * Non optional input inference type.
 */
type NonOptionalInput<TWrapped extends BaseSchema | BaseSchemaAsync> = NonOptional<Input<TWrapped>>;
/**
 * Non optional output inference type.
 */
type NonOptionalOutput<TWrapped extends BaseSchema | BaseSchemaAsync> = NonOptional<Output<TWrapped>>;

/**
 * Non optional schema type.
 */
interface NonOptionalSchema<TWrapped extends BaseSchema, TOutput = NonOptionalOutput<TWrapped>> extends BaseSchema<NonOptionalInput<TWrapped>, TOutput> {
    /**
     * The schema type.
     */
    type: 'non_optional';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a non optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param message The error message.
 *
 * @returns A non optional schema.
 */
declare function nonOptional<TWrapped extends BaseSchema>(wrapped: TWrapped, message?: ErrorMessage): NonOptionalSchema<TWrapped>;

/**
 * Non optional schema async type.
 */
interface NonOptionalSchemaAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TOutput = NonOptionalOutput<TWrapped>> extends BaseSchemaAsync<NonOptionalInput<TWrapped>, TOutput> {
    /**
     * The schema type.
     */
    type: 'non_optional';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async non optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param message The error message.
 *
 * @returns An async non optional schema.
 */
declare function nonOptionalAsync<TWrapped extends BaseSchema | BaseSchemaAsync>(wrapped: TWrapped, message?: ErrorMessage): NonOptionalSchemaAsync<TWrapped>;

/**
 * Nullable schema type.
 */
interface NullableSchema<TWrapped extends BaseSchema, TDefault extends Default<TWrapped> = undefined, TOutput = TDefault extends Input<TWrapped> | (() => Input<TWrapped>) ? Output<TWrapped> : Output<TWrapped> | null> extends BaseSchema<Input<TWrapped> | null, TOutput> {
    /**
     * The schema type.
     */
    type: 'nullable';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * The default value.
     */
    default: TDefault;
}
/**
 * Creates a nullable schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullable schema.
 */
declare function nullable<TWrapped extends BaseSchema>(wrapped: TWrapped): NullableSchema<TWrapped>;
/**
 * Creates a nullable schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullable schema.
 */
declare function nullable<TWrapped extends BaseSchema, TDefault extends Default<TWrapped>>(wrapped: TWrapped, default_: TDefault): NullableSchema<TWrapped, TDefault>;

/**
 * Nullable schema async type.
 */
interface NullableSchemaAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TDefault extends DefaultAsync<TWrapped> = undefined, TOutput = TDefault extends Input<TWrapped> | (() => Input<TWrapped> | Promise<Input<TWrapped>>) ? Output<TWrapped> : Output<TWrapped> | null> extends BaseSchemaAsync<Input<TWrapped> | null, TOutput> {
    /**
     * The schema type.
     */
    type: 'nullable';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * Returns the default value.
     */
    default: TDefault;
}
/**
 * Creates an async nullable schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An async nullable schema.
 */
declare function nullableAsync<TWrapped extends BaseSchema | BaseSchemaAsync>(wrapped: TWrapped): NullableSchemaAsync<TWrapped>;
/**
 * Creates an async nullable schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An async nullable schema.
 */
declare function nullableAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TDefault extends DefaultAsync<TWrapped>>(wrapped: TWrapped, default_: TDefault): NullableSchemaAsync<TWrapped, TDefault>;

/**
 * Nullish schema type.
 */
interface NullishSchema<TWrapped extends BaseSchema, TDefault extends Default<TWrapped> = undefined, TOutput = TDefault extends Input<TWrapped> | (() => Input<TWrapped>) ? Output<TWrapped> : Output<TWrapped> | null | undefined> extends BaseSchema<Input<TWrapped> | null | undefined, TOutput> {
    /**
     * The schema type.
     */
    type: 'nullish';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * Returns the default value.
     */
    default: TDefault;
}
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullish schema.
 */
declare function nullish<TWrapped extends BaseSchema>(wrapped: TWrapped): NullishSchema<TWrapped>;
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullish schema.
 */
declare function nullish<TWrapped extends BaseSchema, TDefault extends Default<TWrapped>>(wrapped: TWrapped, default_: TDefault): NullishSchema<TWrapped, TDefault>;

/**
 * Nullish schema async type.
 */
interface NullishSchemaAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TDefault extends DefaultAsync<TWrapped> = undefined, TOutput = TDefault extends Input<TWrapped> | (() => Input<TWrapped> | Promise<Input<TWrapped>>) ? Output<TWrapped> : Output<TWrapped> | null | undefined> extends BaseSchemaAsync<Input<TWrapped> | null | undefined, TOutput> {
    /**
     * The schema type.
     */
    type: 'nullish';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * Retutns the default value.
     */
    default: TDefault;
}
/**
 * Creates an async nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An async nullish schema.
 */
declare function nullishAsync<TWrapped extends BaseSchema | BaseSchemaAsync>(wrapped: TWrapped): NullishSchemaAsync<TWrapped>;
/**
 * Creates an async nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An async nullish schema.
 */
declare function nullishAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TDefault extends DefaultAsync<TWrapped>>(wrapped: TWrapped, default_: TDefault): NullishSchemaAsync<TWrapped, TDefault>;

/**
 * Null schema type.
 */
interface NullSchema<TOutput = null> extends BaseSchema<null, TOutput> {
    /**
     * The schema type.
     */
    type: 'null';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a null schema.
 *
 * @param message The error message.
 *
 * @returns A null schema.
 */
declare function null_(message?: ErrorMessage): NullSchema;

/**
 * Null schema async type.
 */
interface NullSchemaAsync<TOutput = null> extends BaseSchemaAsync<null, TOutput> {
    /**
     * The schema type.
     */
    type: 'null';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async null schema.
 *
 * @param message The error message.
 *
 * @returns An async null schema.
 */
declare function nullAsync(message?: ErrorMessage): NullSchemaAsync;

/**
 * Number schema type.
 */
interface NumberSchema<TOutput = number> extends BaseSchema<number, TOutput> {
    /**
     * The schema type.
     */
    type: 'number';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<number> | undefined;
}
/**
 * Creates a number schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns A number schema.
 */
declare function number(pipe?: Pipe<number>): NumberSchema;
/**
 * Creates a number schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A number schema.
 */
declare function number(message?: ErrorMessage, pipe?: Pipe<number>): NumberSchema;

/**
 * Number schema async type.
 */
interface NumberSchemaAsync<TOutput = number> extends BaseSchemaAsync<number, TOutput> {
    /**
     * The schema type.
     */
    type: 'number';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<number> | undefined;
}
/**
 * Creates an async number schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async number schema.
 */
declare function numberAsync(pipe?: PipeAsync<number>): NumberSchemaAsync;
/**
 * Creates an async number schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async number schema.
 */
declare function numberAsync(message?: ErrorMessage, pipe?: PipeAsync<number>): NumberSchemaAsync;

/**
 * Optional schema type.
 */
interface OptionalSchema<TWrapped extends BaseSchema, TDefault extends Default<TWrapped> = undefined, TOutput = TDefault extends Input<TWrapped> | (() => Input<TWrapped>) ? Output<TWrapped> : Output<TWrapped> | undefined> extends BaseSchema<Input<TWrapped> | undefined, TOutput> {
    /**
     * The schema type.
     */
    type: 'optional';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * Returns the default value.
     */
    default: TDefault;
}
/**
 * Creates a optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A optional schema.
 */
declare function optional<TWrapped extends BaseSchema>(wrapped: TWrapped): OptionalSchema<TWrapped>;
/**
 * Creates a optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A optional schema.
 */
declare function optional<TWrapped extends BaseSchema, TDefault extends Default<TWrapped>>(wrapped: TWrapped, default_: TDefault): OptionalSchema<TWrapped, TDefault>;

/**
 * Optional schema async type.
 */
interface OptionalSchemaAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TDefault extends DefaultAsync<TWrapped> = undefined, TOutput = TDefault extends Input<TWrapped> | (() => Input<TWrapped> | Promise<Input<TWrapped>>) ? Output<TWrapped> : Output<TWrapped> | undefined> extends BaseSchemaAsync<Input<TWrapped> | undefined, TOutput> {
    /**
     * The schema type.
     */
    type: 'optional';
    /**
     * The wrapped schema.
     */
    wrapped: TWrapped;
    /**
     * Returns the default value.
     */
    default: TDefault;
}
/**
 * Creates an async optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An async optional schema.
 */
declare function optionalAsync<TWrapped extends BaseSchema | BaseSchemaAsync>(wrapped: TWrapped): OptionalSchemaAsync<TWrapped>;
/**
 * Creates an async optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An async optional schema.
 */
declare function optionalAsync<TWrapped extends BaseSchema | BaseSchemaAsync, TDefault extends DefaultAsync<TWrapped>>(wrapped: TWrapped, default_: TDefault): OptionalSchemaAsync<TWrapped, TDefault>;

/**
 * Object entries async type.
 */
interface ObjectEntriesAsync {
    [key: string]: BaseSchema | BaseSchemaAsync;
}
/**
 * Object schema async type.
 */
interface ObjectSchemaAsync<TEntries extends ObjectEntriesAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined = undefined, TOutput = ObjectOutput<TEntries, TRest>> extends BaseSchemaAsync<ObjectInput<TEntries, TRest>, TOutput> {
    /**
     * The schema type.
     */
    type: 'object';
    /**
     * The object entries schema.
     */
    entries: TEntries;
    /**
     * The object rest schema.
     */
    rest: TRest;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<ObjectOutput<TEntries, TRest>> | undefined;
}
/**
 * Creates an async object schema.
 *
 * @param entries The object entries.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function objectAsync<TEntries extends ObjectEntriesAsync>(entries: TEntries, pipe?: PipeAsync<ObjectOutput<TEntries, undefined>>): ObjectSchemaAsync<TEntries>;
/**
 * Creates an async object schema.
 *
 * @param entries The object entries.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function objectAsync<TEntries extends ObjectEntriesAsync>(entries: TEntries, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<TEntries, undefined>>): ObjectSchemaAsync<TEntries>;
/**
 * Creates an async object schema.
 *
 * @param entries The object entries.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function objectAsync<TEntries extends ObjectEntriesAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined>(entries: TEntries, rest: TRest, pipe?: PipeAsync<ObjectOutput<TEntries, TRest>>): ObjectSchemaAsync<TEntries, TRest>;
/**
 * Creates an async object schema.
 *
 * @param entries The object entries.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function objectAsync<TEntries extends ObjectEntriesAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined>(entries: TEntries, rest: TRest, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<TEntries, TRest>>): ObjectSchemaAsync<TEntries, TRest>;

/**
 * Object path item type.
 */
interface ObjectPathItem {
    type: 'object';
    origin: 'value';
    input: Record<string, unknown>;
    key: string;
    value: unknown;
}
/**
 * Required object keys type.
 */
type RequiredKeys<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends EntriesInput<TEntries> | EntriesOutput<TEntries>> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends OptionalSchema<any, any> | OptionalSchemaAsync<any, any> ? undefined extends TObject[TKey] ? never : TKey : TKey;
}[keyof TEntries];
/**
 * Optional object keys type.
 */
type OptionalKeys<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends EntriesInput<TEntries> | EntriesOutput<TEntries>> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends OptionalSchema<any, any> | OptionalSchemaAsync<any, any> ? undefined extends TObject[TKey] ? TKey : never : never;
}[keyof TEntries];
/**
 * Entries input inference type.
 */
type EntriesInput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: Input<TEntries[TKey]>;
};
/**
 * Entries output inference type.
 */
type EntriesOutput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: Output<TEntries[TKey]>;
};
/**
 * Object with question marks type.
 */
type WithQuestionMarks<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends EntriesInput<TEntries> | EntriesOutput<TEntries>> = Pick<TObject, RequiredKeys<TEntries, TObject>> & Partial<Pick<TObject, OptionalKeys<TEntries, TObject>>>;
/**
 * Object input inference type.
 */
type ObjectInput<TEntries extends ObjectEntries | ObjectEntriesAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined> = TRest extends undefined | NeverSchema | NeverSchemaAsync ? ResolveObject<WithQuestionMarks<TEntries, EntriesInput<TEntries>>> : TRest extends BaseSchema | BaseSchemaAsync ? ResolveObject<WithQuestionMarks<TEntries, EntriesInput<TEntries>>> & Record<string, Input<TRest>> : never;
/**
 * Object output inference type.
 */
type ObjectOutput<TEntries extends ObjectEntries | ObjectEntriesAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined> = TRest extends undefined | NeverSchema | NeverSchemaAsync ? ResolveObject<WithQuestionMarks<TEntries, EntriesOutput<TEntries>>> : TRest extends BaseSchema | BaseSchemaAsync ? ResolveObject<WithQuestionMarks<TEntries, EntriesOutput<TEntries>>> & Record<string, Output<TRest>> : never;

/**
 * Object entries type.
 */
interface ObjectEntries {
    [key: string]: BaseSchema;
}
/**
 * Object schema type.
 */
interface ObjectSchema<TEntries extends ObjectEntries, TRest extends BaseSchema | undefined = undefined, TOutput = ObjectOutput<TEntries, TRest>> extends BaseSchema<ObjectInput<TEntries, TRest>, TOutput> {
    /**
     * The schema type.
     */
    type: 'object';
    /**
     * The object entries schema.
     */
    entries: TEntries;
    /**
     * The object rest schema.
     */
    rest: TRest;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<ObjectOutput<TEntries, TRest>> | undefined;
}
/**
 * Creates an object schema.
 *
 * @param entries The object entries.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function object<TEntries extends ObjectEntries>(entries: TEntries, pipe?: Pipe<ObjectOutput<TEntries, undefined>>): ObjectSchema<TEntries>;
/**
 * Creates an object schema.
 *
 * @param entries The object entries.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function object<TEntries extends ObjectEntries>(entries: TEntries, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<TEntries, undefined>>): ObjectSchema<TEntries>;
/**
 * Creates an object schema.
 *
 * @param entries The object entries.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function object<TEntries extends ObjectEntries, TRest extends BaseSchema | undefined>(entries: TEntries, rest: TRest, pipe?: Pipe<ObjectOutput<TEntries, TRest>>): ObjectSchema<TEntries, TRest>;
/**
 * Creates an object schema.
 *
 * @param entries The object entries.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function object<TEntries extends ObjectEntries, TRest extends BaseSchema | undefined>(entries: TEntries, rest: TRest, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<TEntries, TRest>>): ObjectSchema<TEntries, TRest>;

/**
 * Picklist options type.
 */
type PicklistOptions = MaybeReadonly<(string | number | bigint)[]>;

/**
 * Picklist schema type.
 */
interface PicklistSchema<TOptions extends PicklistOptions, TOutput = TOptions[number]> extends BaseSchema<TOptions[number], TOutput> {
    /**
     * The schema type.
     */
    type: 'picklist';
    /**
     * The picklist options.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a picklist schema.
 *
 * @param options The picklist value.
 * @param message The error message.
 *
 * @returns A picklist schema.
 */
declare function picklist<const TOptions extends PicklistOptions>(options: TOptions, message?: ErrorMessage): PicklistSchema<TOptions>;

/**
 * Picklist schema async type.
 */
interface PicklistSchemaAsync<TOptions extends PicklistOptions, TOutput = TOptions[number]> extends BaseSchemaAsync<TOptions[number], TOutput> {
    /**
     * The schema type.
     */
    type: 'picklist';
    /**
     * The picklist value.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async picklist schema.
 *
 * @param options The picklist options.
 * @param message The error message.
 *
 * @returns An async picklist schema.
 */
declare function picklistAsync<const TOptions extends PicklistOptions>(options: TOptions, message?: ErrorMessage): PicklistSchemaAsync<TOptions>;

/**
 * Special schema type.
 */
interface SpecialSchema<TInput, TOutput = TInput> extends BaseSchema<TInput, TOutput> {
    /**
     * The schema type.
     */
    type: 'special';
    /**
     * The type check function.
     */
    check: (input: unknown) => boolean;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<TInput> | undefined;
}
/**
 * Creates a special schema.
 *
 * @param check The type check function.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A special schema.
 */
declare function special<TInput>(check: (input: unknown) => boolean, pipe?: Pipe<TInput>): SpecialSchema<TInput>;
/**
 * Creates a special schema.
 *
 * @param check The type check function.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A special schema.
 */
declare function special<TInput>(check: (input: unknown) => boolean, message?: ErrorMessage, pipe?: Pipe<TInput>): SpecialSchema<TInput>;

/**
 * Special schema async type.
 */
interface SpecialSchemaAsync<TInput, TOutput = TInput> extends BaseSchemaAsync<TInput, TOutput> {
    /**
     * The schema type.
     */
    type: 'special';
    /**
     * The type check function.
     */
    check: (input: unknown) => boolean | Promise<boolean>;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<TInput> | undefined;
}
/**
 * Creates an async special schema.
 *
 * @param check The type check function.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async special schema.
 */
declare function specialAsync<TInput>(check: (input: unknown) => boolean | Promise<boolean>, pipe?: PipeAsync<TInput>): SpecialSchemaAsync<TInput>;
/**
 * Creates a special schema.
 *
 * @param check The type check function.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A special schema.
 */
declare function specialAsync<TInput>(check: (input: unknown) => boolean | Promise<boolean>, message?: ErrorMessage, pipe?: PipeAsync<TInput>): SpecialSchemaAsync<TInput>;

/**
 * String schema type.
 */
interface StringSchema<TOutput = string> extends BaseSchema<string, TOutput> {
    /**
     * The schema type.
     */
    type: 'string';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<string> | undefined;
}
/**
 * Creates a string schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns A string schema.
 */
declare function string(pipe?: Pipe<string>): StringSchema;
/**
 * Creates a string schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A string schema.
 */
declare function string(message?: ErrorMessage, pipe?: Pipe<string>): StringSchema;

/**
 * String schema async type.
 */
interface StringSchemaAsync<TOutput = string> extends BaseSchemaAsync<string, TOutput> {
    /**
     * The schema type.
     */
    type: 'string';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<string> | undefined;
}
/**
 * Creates an async string schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async string schema.
 */
declare function stringAsync(pipe?: PipeAsync<string>): StringSchemaAsync;
/**
 * Creates an async string schema.
 *
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async string schema.
 */
declare function stringAsync(message?: ErrorMessage, pipe?: PipeAsync<string>): StringSchemaAsync;

/**
 * Union options type.
 */
type UnionOptions = MaybeReadonly<BaseSchema[]>;
/**
 * Union schema type.
 */
interface UnionSchema<TOptions extends UnionOptions, TOutput = Output<TOptions[number]>> extends BaseSchema<Input<TOptions[number]>, TOutput> {
    /**
     * The schema type.
     */
    type: 'union';
    /**
     * The union options.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<Output<TOptions[number]>> | undefined;
}
/**
 * Creates a union schema.
 *
 * @param options The union options.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A union schema.
 */
declare function union<TOptions extends UnionOptions>(options: TOptions, pipe?: Pipe<Output<TOptions[number]>>): UnionSchema<TOptions>;
/**
 * Creates a union schema.
 *
 * @param options The union options.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A union schema.
 */
declare function union<TOptions extends UnionOptions>(options: TOptions, message?: ErrorMessage, pipe?: Pipe<Output<TOptions[number]>>): UnionSchema<TOptions>;

/**
 * Union options async type.
 */
type UnionOptionsAsync = MaybeReadonly<(BaseSchema | BaseSchemaAsync)[]>;
/**
 * Union schema async type.
 */
interface UnionSchemaAsync<TOptions extends UnionOptionsAsync, TOutput = Output<TOptions[number]>> extends BaseSchemaAsync<Input<TOptions[number]>, TOutput> {
    /**
     * The schema type.
     */
    type: 'union';
    /**
     * The union options.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<Input<TOptions[number]>> | undefined;
}
/**
 * Creates an async union schema.
 *
 * @param options The union options.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async union schema.
 */
declare function unionAsync<TOptions extends UnionOptionsAsync>(options: TOptions, pipe?: PipeAsync<Input<TOptions[number]>>): UnionSchemaAsync<TOptions>;
/**
 * Creates an async union schema.
 *
 * @param options The union options.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async union schema.
 */
declare function unionAsync<TOptions extends UnionOptionsAsync>(options: TOptions, message?: ErrorMessage, pipe?: PipeAsync<Input<TOptions[number]>>): UnionSchemaAsync<TOptions>;

/**
 * Record key async type.
 */
type RecordKeyAsync = EnumSchema<any, string | number | symbol> | EnumSchemaAsync<any, string | number | symbol> | PicklistSchema<any, string | number | symbol> | PicklistSchemaAsync<any, string | number | symbol> | SpecialSchema<any, string | number | symbol> | SpecialSchemaAsync<any, string | number | symbol> | StringSchema<string | number | symbol> | StringSchemaAsync<string | number | symbol> | UnionSchema<any, string | number | symbol> | UnionSchemaAsync<any, string | number | symbol>;
/**
 * Record schema async type.
 */
interface RecordSchemaAsync<TKey extends RecordKeyAsync, TValue extends BaseSchema | BaseSchemaAsync, TOutput = RecordOutput<TKey, TValue>> extends BaseSchemaAsync<RecordInput<TKey, TValue>, TOutput> {
    /**
     * The schema type.
     */
    type: 'record';
    /**
     * The key schema.
     */
    key: TKey;
    /**
     * The value schema.
     */
    value: TValue;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<RecordOutput<TKey, TValue>> | undefined;
}
/**
 * Creates an async record schema.
 *
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async record schema.
 */
declare function recordAsync<TValue extends BaseSchema | BaseSchemaAsync>(value: TValue, pipe?: PipeAsync<RecordOutput<StringSchema, TValue>>): RecordSchemaAsync<StringSchema, TValue>;
/**
 * Creates an async record schema.
 *
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async record schema.
 */
declare function recordAsync<TValue extends BaseSchema | BaseSchemaAsync>(value: TValue, message?: ErrorMessage, pipe?: PipeAsync<RecordOutput<StringSchema, TValue>>): RecordSchemaAsync<StringSchema, TValue>;
/**
 * Creates an async record schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async record schema.
 */
declare function recordAsync<TKey extends RecordKeyAsync, TValue extends BaseSchema | BaseSchemaAsync>(key: TKey, value: TValue, pipe?: PipeAsync<RecordOutput<TKey, TValue>>): RecordSchemaAsync<TKey, TValue>;
/**
 * Creates an async record schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async record schema.
 */
declare function recordAsync<TKey extends RecordKeyAsync, TValue extends BaseSchema | BaseSchemaAsync>(key: TKey, value: TValue, message?: ErrorMessage, pipe?: PipeAsync<RecordOutput<TKey, TValue>>): RecordSchemaAsync<TKey, TValue>;

/**
 * Record path item type.
 */
interface RecordPathItem {
    type: 'record';
    origin: 'key' | 'value';
    input: Record<string | number | symbol, unknown>;
    key: string | number | symbol;
    value: unknown;
}
/**
 * Partial key schema type.
 */
type PartialKeySchema = PicklistSchema<any> | PicklistSchemaAsync<any> | EnumSchema<any> | EnumSchemaAsync<any> | UnionSchema<any> | UnionSchemaAsync<any>;
/**
 * Record input inference type.
 */
type RecordInput<TKey extends RecordKey | RecordKeyAsync, TValue extends BaseSchema | BaseSchemaAsync> = ResolveObject<TKey extends PartialKeySchema ? Partial<Record<Input<TKey>, Input<TValue>>> : Record<Input<TKey>, Input<TValue>>>;
/**
 * Record output inference type.
 */
type RecordOutput<TKey extends RecordKey | RecordKeyAsync, TValue extends BaseSchema | BaseSchemaAsync> = ResolveObject<TKey extends PartialKeySchema ? Partial<Record<Output<TKey>, Output<TValue>>> : Record<Output<TKey>, Output<TValue>>>;

/**
 * Record key type.
 */
type RecordKey = EnumSchema<any, string | number | symbol> | PicklistSchema<any, string | number | symbol> | SpecialSchema<any, string | number | symbol> | StringSchema<string | number | symbol> | UnionSchema<any, string | number | symbol>;
/**
 * Record schema type.
 */
interface RecordSchema<TKey extends RecordKey, TValue extends BaseSchema, TOutput = RecordOutput<TKey, TValue>> extends BaseSchema<RecordInput<TKey, TValue>, TOutput> {
    /**
     * The schema type.
     */
    type: 'record';
    /**
     * The record key schema.
     */
    key: TKey;
    /**
     * The record value schema.
     */
    value: TValue;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<RecordOutput<TKey, TValue>> | undefined;
}
/**
 * Creates a record schema.
 *
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A record schema.
 */
declare function record<TValue extends BaseSchema>(value: TValue, pipe?: Pipe<RecordOutput<StringSchema, TValue>>): RecordSchema<StringSchema, TValue>;
/**
 * Creates a record schema.
 *
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A record schema.
 */
declare function record<TValue extends BaseSchema>(value: TValue, message?: ErrorMessage, pipe?: Pipe<RecordOutput<StringSchema, TValue>>): RecordSchema<StringSchema, TValue>;
/**
 * Creates a record schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A record schema.
 */
declare function record<TKey extends RecordKey, TValue extends BaseSchema>(key: TKey, value: TValue, pipe?: Pipe<RecordOutput<TKey, TValue>>): RecordSchema<TKey, TValue>;
/**
 * Creates a record schema.
 *
 * @param key The key schema.
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A record schema.
 */
declare function record<TKey extends RecordKey, TValue extends BaseSchema>(key: TKey, value: TValue, message?: ErrorMessage, pipe?: Pipe<RecordOutput<TKey, TValue>>): RecordSchema<TKey, TValue>;

/**
 * Set path item type.
 */
interface SetPathItem {
    type: 'set';
    origin: 'value';
    input: Set<unknown>;
    key: number;
    value: unknown;
}
/**
 * Set output inference type.
 */
type SetInput<TValue extends BaseSchema | BaseSchemaAsync> = Set<Input<TValue>>;
/**
 * Set output inference type.
 */
type SetOutput<TValue extends BaseSchema | BaseSchemaAsync> = Set<Output<TValue>>;

/**
 * Set schema type.
 */
interface SetSchema<TValue extends BaseSchema, TOutput = SetOutput<TValue>> extends BaseSchema<SetInput<TValue>, TOutput> {
    /**
     * The schema type.
     */
    type: 'set';
    /**
     * The set value schema.
     */
    value: TValue;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<SetOutput<TValue>> | undefined;
}
/**
 * Creates a set schema.
 *
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A set schema.
 */
declare function set<TValue extends BaseSchema>(value: TValue, pipe?: Pipe<SetOutput<TValue>>): SetSchema<TValue>;
/**
 * Creates a set schema.
 *
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A set schema.
 */
declare function set<TValue extends BaseSchema>(value: TValue, message?: ErrorMessage, pipe?: Pipe<SetOutput<TValue>>): SetSchema<TValue>;

/**
 * Set schema async type.
 */
interface SetSchemaAsync<TValue extends BaseSchema | BaseSchemaAsync, TOutput = SetOutput<TValue>> extends BaseSchemaAsync<SetInput<TValue>, TOutput> {
    /**
     * The schema type.
     */
    type: 'set';
    /**
     * The set value schema.
     */
    value: TValue;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<SetOutput<TValue>> | undefined;
}
/**
 * Creates an async set schema.
 *
 * @param value The value schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async set schema.
 */
declare function setAsync<TValue extends BaseSchema | BaseSchemaAsync>(value: TValue, pipe?: PipeAsync<SetOutput<TValue>>): SetSchemaAsync<TValue>;
/**
 * Creates an async set schema.
 *
 * @param value The value schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async set schema.
 */
declare function setAsync<TValue extends BaseSchema | BaseSchemaAsync>(value: TValue, message?: ErrorMessage, pipe?: PipeAsync<SetOutput<TValue>>): SetSchemaAsync<TValue>;

/**
 * Symbol schema type.
 */
interface SymbolSchema<TOutput = symbol> extends BaseSchema<symbol, TOutput> {
    /**
     * The schema type.
     */
    type: 'symbol';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a symbol schema.
 *
 * @param message The error message.
 *
 * @returns A symbol schema.
 */
declare function symbol(message?: ErrorMessage): SymbolSchema;

/**
 * Symbol schema async type.
 */
interface SymbolSchemaAsync<TOutput = symbol> extends BaseSchemaAsync<symbol, TOutput> {
    /**
     * The schema type.
     */
    type: 'symbol';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async symbol schema.
 *
 * @param message The error message.
 *
 * @returns An async symbol schema.
 */
declare function symbolAsync(message?: ErrorMessage): SymbolSchemaAsync;

/**
 * Tuple shape async type.
 */
type TupleItemsAsync = [
    BaseSchema | BaseSchemaAsync,
    ...(BaseSchema | BaseSchemaAsync)[]
];
/**
 * Tuple schema async type.
 */
interface TupleSchemaAsync<TItems extends TupleItemsAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined = undefined, TOutput = TupleOutput<TItems, TRest>> extends BaseSchemaAsync<TupleInput<TItems, TRest>, TOutput> {
    /**
     * The schema type.
     */
    type: 'tuple';
    /**
     * The tuple items schema.
     */
    items: TItems;
    /**
     * The tuple rest schema.
     */
    rest: TRest;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<TupleOutput<TItems, TRest>> | undefined;
}
/**
 * Creates an async tuple schema.
 *
 * @param items The items schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async tuple schema.
 */
declare function tupleAsync<TItems extends TupleItemsAsync>(items: TItems, pipe?: PipeAsync<TupleOutput<TItems, undefined>>): TupleSchemaAsync<TItems>;
/**
 * Creates an async tuple schema.
 *
 * @param items The items schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async tuple schema.
 */
declare function tupleAsync<TItems extends TupleItemsAsync>(items: TItems, message?: ErrorMessage, pipe?: PipeAsync<TupleOutput<TItems, undefined>>): TupleSchemaAsync<TItems>;
/**
 * Creates an async tuple schema.
 *
 * @param items The items schema.
 * @param rest The rest schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async tuple schema.
 */
declare function tupleAsync<TItems extends TupleItemsAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined>(items: TItems, rest: TRest, pipe?: PipeAsync<TupleOutput<TItems, TRest>>): TupleSchemaAsync<TItems, TRest>;
/**
 * Creates an async tuple schema.
 *
 * @param items The items schema.
 * @param rest The rest schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async tuple schema.
 */
declare function tupleAsync<TItems extends TupleItemsAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined>(items: TItems, rest: TRest, message?: ErrorMessage, pipe?: PipeAsync<TupleOutput<TItems, TRest>>): TupleSchemaAsync<TItems, TRest>;

/**
 * Tuple path item type.
 */
interface TuplePathItem {
    type: 'tuple';
    origin: 'value';
    input: [unknown, ...unknown[]];
    key: number;
    value: unknown;
}
/**
 * Tuple input inference type.
 */
type TupleInput<TItems extends TupleItems | TupleItemsAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined> = TRest extends undefined | NeverSchema | NeverSchemaAsync ? {
    [TKey in keyof TItems]: Input<TItems[TKey]>;
} : TRest extends BaseSchema | BaseSchemaAsync ? [
    ...{
        [TKey in keyof TItems]: Input<TItems[TKey]>;
    },
    ...Input<TRest>[]
] : never;
/**
 * Tuple with rest output inference type.
 */
type TupleOutput<TItems extends TupleItems | TupleItemsAsync, TRest extends BaseSchema | BaseSchemaAsync | undefined> = TRest extends undefined | NeverSchema | NeverSchemaAsync ? {
    [TKey in keyof TItems]: Output<TItems[TKey]>;
} : TRest extends BaseSchema | BaseSchemaAsync ? [
    ...{
        [TKey in keyof TItems]: Output<TItems[TKey]>;
    },
    ...Output<TRest>[]
] : never;

/**
 * Tuple shape type.
 */
type TupleItems = [BaseSchema, ...BaseSchema[]];
/**
 * Tuple schema type.
 */
interface TupleSchema<TItems extends TupleItems, TRest extends BaseSchema | undefined = undefined, TOutput = TupleOutput<TItems, TRest>> extends BaseSchema<TupleInput<TItems, TRest>, TOutput> {
    /**
     * The schema type.
     */
    type: 'tuple';
    /**
     * The tuple items schema.
     */
    items: TItems;
    /**
     * The tuple rest schema.
     */
    rest: TRest;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<TupleOutput<TItems, TRest>> | undefined;
}
/**
 * Creates a tuple schema.
 *
 * @param items The items schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A tuple schema.
 */
declare function tuple<TItems extends TupleItems>(items: TItems, pipe?: Pipe<TupleOutput<TItems, undefined>>): TupleSchema<TItems>;
/**
 * Creates a tuple schema.
 *
 * @param items The items schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A tuple schema.
 */
declare function tuple<TItems extends TupleItems>(items: TItems, message?: ErrorMessage, pipe?: Pipe<TupleOutput<TItems, undefined>>): TupleSchema<TItems>;
/**
 * Creates a tuple schema.
 *
 * @param items The items schema.
 * @param rest The rest schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A tuple schema.
 */
declare function tuple<TItems extends TupleItems, TRest extends BaseSchema | undefined>(items: TItems, rest: TRest, pipe?: Pipe<TupleOutput<TItems, TRest>>): TupleSchema<TItems, TRest>;
/**
 * Creates a tuple schema.
 *
 * @param items The items schema.
 * @param rest The rest schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A tuple schema.
 */
declare function tuple<TItems extends TupleItems, TRest extends BaseSchema | undefined>(items: TItems, rest: TRest, message?: ErrorMessage, pipe?: Pipe<TupleOutput<TItems, TRest>>): TupleSchema<TItems, TRest>;

/**
 * Undefined schema type.
 */
interface UndefinedSchema<TOutput = undefined> extends BaseSchema<undefined, TOutput> {
    /**
     * The schema type.
     */
    type: 'undefined';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a undefined schema.
 *
 * @param message The error message.
 *
 * @returns A undefined schema.
 */
declare function undefined_(message?: ErrorMessage): UndefinedSchema;

/**
 * Undefined schema async type.
 */
interface UndefinedSchemaAsync<TOutput = undefined> extends BaseSchemaAsync<undefined, TOutput> {
    /**
     * The schema type.
     */
    type: 'undefined';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async undefined schema.
 *
 * @param message The error message.
 *
 * @returns An async undefined schema.
 */
declare function undefinedAsync(message?: ErrorMessage): UndefinedSchemaAsync;

/**
 * Unknown schema type.
 */
interface UnknownSchema<TOutput = unknown> extends BaseSchema<unknown, TOutput> {
    /**
     * The schema type.
     */
    type: 'unknown';
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<unknown> | undefined;
}
/**
 * Creates a unknown schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns A unknown schema.
 */
declare function unknown(pipe?: Pipe<unknown>): UnknownSchema;

/**
 * Unknown schema async type.
 */
interface UnknownSchemaAsync<TOutput = unknown> extends BaseSchemaAsync<unknown, TOutput> {
    /**
     * The schema type.
     */
    type: 'unknown';
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<unknown> | undefined;
}
/**
 * Creates an async unknown schema.
 *
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async unknown schema.
 */
declare function unknownAsync(pipe?: PipeAsync<unknown>): UnknownSchemaAsync;

/**
 * Variant option schema type.
 */
interface VariantOptionSchema$1<TKey extends string> extends BaseSchema {
    type: 'variant';
    options: VariantOptions<TKey>;
}
/**
 * Variant option type.
 */
type VariantOption<TKey extends string> = ObjectSchema<Record<TKey, BaseSchema>, any> | VariantOptionSchema$1<TKey>;
/**
 * Variant options type.
 */
type VariantOptions<TKey extends string> = [
    VariantOption<TKey>,
    VariantOption<TKey>,
    ...VariantOption<TKey>[]
];
/**
 * Variant schema type.
 */
interface VariantSchema<TKey extends string, TOptions extends VariantOptions<TKey>, TOutput = Output<TOptions[number]>> extends BaseSchema<Input<TOptions[number]>, TOutput> {
    /**
     * The schema type.
     */
    type: 'variant';
    /**
     * The discriminator key.
     */
    key: TKey;
    /**
     * The variant options.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: Pipe<Output<TOptions[number]>> | undefined;
}
/**
 * Creates a variant (aka discriminated union) schema.
 *
 * @param key The discriminator key.
 * @param options The variant options.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A variant schema.
 */
declare function variant<TKey extends string, TOptions extends VariantOptions<TKey>>(key: TKey, options: TOptions, pipe?: Pipe<Output<TOptions[number]>>): VariantSchema<TKey, TOptions>;
/**
 * Creates a variant (aka discriminated union) schema.
 *
 * @param key The discriminator key.
 * @param options The variant options.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns A variant schema.
 */
declare function variant<TKey extends string, TOptions extends VariantOptions<TKey>>(key: TKey, options: TOptions, message?: ErrorMessage, pipe?: Pipe<Output<TOptions[number]>>): VariantSchema<TKey, TOptions>;

/**
 * Variant option schema type.
 */
interface VariantOptionSchema<TKey extends string> extends BaseSchema {
    type: 'variant';
    options: VariantOptionsAsync<TKey>;
}
/**
 * Variant option schema async type.
 */
interface VariantOptionSchemaAsync<TKey extends string> extends BaseSchemaAsync {
    type: 'variant';
    options: VariantOptionsAsync<TKey>;
}
/**
 * Variant option async type.
 */
type VariantOptionAsync<TKey extends string> = ObjectSchema<Record<TKey, BaseSchema>, any> | ObjectSchemaAsync<Record<TKey, BaseSchema | BaseSchemaAsync>, any> | VariantOptionSchema<TKey> | VariantOptionSchemaAsync<TKey>;
/**
 * Variant options async type.
 */
type VariantOptionsAsync<TKey extends string> = [
    VariantOptionAsync<TKey>,
    VariantOptionAsync<TKey>,
    ...VariantOptionAsync<TKey>[]
];
/**
 * Variant schema async type.
 */
interface VariantSchemaAsync<TKey extends string, TOptions extends VariantOptionsAsync<TKey>, TOutput = Output<TOptions[number]>> extends BaseSchemaAsync<Input<TOptions[number]>, TOutput> {
    /**
     * The schema type.
     */
    type: 'variant';
    /**
     * The discriminator key.
     */
    key: TKey;
    /**
     * The variant options.
     */
    options: TOptions;
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
    /**
     * The validation and transformation pipeline.
     */
    pipe: PipeAsync<Input<TOptions[number]>> | undefined;
}
/**
 * Creates an async variant (aka discriminated union) schema.
 *
 * @param key The discriminator key.
 * @param options The variant options.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async variant schema.
 */
declare function variantAsync<TKey extends string, TOptions extends VariantOptionsAsync<TKey>>(key: TKey, options: TOptions, pipe?: PipeAsync<Input<TOptions[number]>>): VariantSchemaAsync<TKey, TOptions>;
/**
 * Creates an async variant (aka discriminated union) schema.
 *
 * @param key The discriminator key.
 * @param options The variant options.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async variant schema.
 */
declare function variantAsync<TKey extends string, TOptions extends VariantOptionsAsync<TKey>>(key: TKey, options: TOptions, message?: ErrorMessage, pipe?: PipeAsync<Input<TOptions[number]>>): VariantSchemaAsync<TKey, TOptions>;

/**
 * Void schema type.
 */
interface VoidSchema<TOutput = void> extends BaseSchema<void, TOutput> {
    /**
     * The schema type.
     */
    type: 'void';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates a void schema.
 *
 * @param message The error message.
 *
 * @returns A void schema.
 */
declare function void_(message?: ErrorMessage): VoidSchema;

/**
 * Void schema async type.
 */
interface VoidSchemaAsync<TOutput = void> extends BaseSchemaAsync<void, TOutput> {
    /**
     * The schema type.
     */
    type: 'void';
    /**
     * The error message.
     */
    message: ErrorMessage | undefined;
}
/**
 * Creates an async void schema.
 *
 * @param message The error message.
 *
 * @returns An async void schema.
 */
declare function voidAsync(message?: ErrorMessage): VoidSchemaAsync;

/**
 * A Valibot error with useful information.
 */
declare class ValiError extends Error {
    issues: SchemaIssues;
    /**
     * Creates a Valibot error with useful information.
     *
     * @param issues The error issues.
     */
    constructor(issues: SchemaIssues);
}

/**
 * Dot path type.
 */
type DotPath<TKey, TSchema> = TKey extends string | number ? `${TKey}` | `${TKey}.${NestedPath<TSchema>}` : never;
/**
 * Object path type.
 */
type ObjectPath<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: DotPath<TKey, TEntries[TKey]>;
}[keyof TEntries];
/**
 * Tuple key type.
 */
type TupleKey<T extends any[]> = Exclude<keyof T, keyof any[]>;
/**
 * Tuple path type.
 */
type TuplePath<TItems extends TupleItems | TupleItemsAsync> = {
    [TKey in TupleKey<TItems>]: DotPath<TKey, TItems[TKey]>;
}[TupleKey<TItems>];
/**
 * Nested path type.
 */
type NestedPath<TSchema> = TSchema extends {
    item: infer TItem extends BaseSchema | BaseSchemaAsync;
} ? DotPath<number, TItem> : TSchema extends {
    key: infer TKey extends BaseSchema | BaseSchemaAsync;
    value: infer TValue extends BaseSchema | BaseSchemaAsync;
} ? DotPath<Input<TKey>, TValue> : TSchema extends {
    entries: infer TEntries extends ObjectEntries | ObjectEntriesAsync;
    rest: infer TRest extends BaseSchema | BaseSchemaAsync | undefined;
} ? TRest extends undefined ? ObjectPath<TEntries> : string : TSchema extends {
    getter: infer TSchemaGetter extends () => BaseSchema | BaseSchemaAsync;
} ? NestedPath<ReturnType<TSchemaGetter>> : TSchema extends {
    value: infer TValue extends BaseSchema | BaseSchemaAsync;
} ? DotPath<number, TValue> : TSchema extends {
    items: infer TItems extends TupleItems | TupleItemsAsync;
    rest: infer TRest extends BaseSchema | BaseSchemaAsync | undefined;
} ? TRest extends undefined ? TuplePath<TItems> : TuplePath<TItems> | DotPath<number, TRest> : TSchema extends {
    options: infer TUnionOptions extends UnionOptions | UnionOptionsAsync;
} ? NestedPath<TUnionOptions[number]> : never;
/**
 * Flat errors type.
 */
interface FlatErrors<TSchema extends BaseSchema | BaseSchemaAsync = any> {
    root?: [string, ...string[]];
    nested: Partial<Record<NestedPath<TSchema>, [string, ...string[]]>>;
}
/**
 * Flatten the error messages of a Vali error.
 *
 * @param error A Vali error.
 *
 * @returns Flat errors.
 */
declare function flatten<TSchema extends BaseSchema | BaseSchemaAsync = any>(error: ValiError): FlatErrors<TSchema>;
/**
 * Flatten the error messages of issues.
 *
 * @param issues The issues.
 *
 * @returns Flat errors.
 */
declare function flatten<TSchema extends BaseSchema | BaseSchemaAsync = any>(issues: SchemaIssues): FlatErrors<TSchema>;

/**
 * Brand symbol.
 */
declare const BrandSymbol: unique symbol;
/**
 * Brand name type.
 */
type BrandName = string | number | symbol;
/**
 * Brand type.
 */
interface Brand<TName extends BrandName> {
    [BrandSymbol]: {
        [TValue in TName]: TValue;
    };
}
/**
 * Schema with brand type.
 */
type SchemaWithBrand<TSchema extends BaseSchema | BaseSchemaAsync, TName extends BrandName> = Omit<TSchema, '_types'> & {
    _types?: {
        input: Input<TSchema>;
        output: Output<TSchema> & Brand<TName>;
    };
};
/**
 * Brands the output type of a schema.
 *
 * @param schema The scheme to be branded.
 * @param name The brand name.
 *
 * @returns The branded schema.
 */
declare function brand<TSchema extends BaseSchema | BaseSchemaAsync, TName extends BrandName>(schema: TSchema, name: TName): SchemaWithBrand<TSchema, TName>;

/**
 * Coerces the input of a schema to match the required type.
 *
 * @param schema The affected schema.
 * @param action The coerceation action.
 *
 * @returns The passed schema.
 */
declare function coerce<TSchema extends BaseSchema>(schema: TSchema, action: (input: unknown) => unknown): TSchema;

/**
 * Coerces the input of a async schema to match the required type.
 *
 * @param schema The affected schema.
 * @param action The coerceation action.
 *
 * @returns The passed schema.
 */
declare function coerceAsync<TSchema extends BaseSchemaAsync>(schema: TSchema, action: (input: unknown) => unknown): TSchema;

/**
 * Fallback info type.
 */
interface FallbackInfo {
    input: unknown;
    issues: SchemaIssues;
}

/**
 * Fallback type.
 */
type Fallback<TSchema extends BaseSchema> = Output<TSchema> | ((info?: FallbackInfo) => Output<TSchema>);
/**
 * Schema with fallback type.
 */
type SchemaWithFallback<TSchema extends BaseSchema = BaseSchema, TFallback extends Fallback<TSchema> = Fallback<TSchema>> = TSchema & {
    /**
     * The fallback value.
     */
    fallback: TFallback;
};
/**
 * Returns a fallback output value when validating the passed schema failed.
 *
 * @param schema The schema to catch.
 * @param fallback The fallback value.
 *
 * @returns The passed schema.
 */
declare function fallback<TSchema extends BaseSchema, const TFallback extends Fallback<TSchema>>(schema: TSchema, fallback: TFallback): SchemaWithFallback<TSchema, TFallback>;

/**
 * Fallback async type.
 */
type FallbackAsync<TSchema extends BaseSchemaAsync> = Output<TSchema> | ((info?: FallbackInfo) => Output<TSchema> | Promise<Output<TSchema>>);
/**
 * Schema with fallback async type.
 */
type SchemaWithFallbackAsync<TSchema extends BaseSchemaAsync = BaseSchemaAsync, TFallback extends FallbackAsync<TSchema> = FallbackAsync<TSchema>> = TSchema & {
    /**
     * The fallback value.
     */
    fallback: TFallback;
};
/**
 * Returns a fallback output value when validating the passed schema failed.
 *
 * @param schema The schema to catch.
 * @param fallback The fallback value.
 *
 * @returns The passed schema.
 */
declare function fallbackAsync<TSchema extends BaseSchemaAsync, const TFallback extends FallbackAsync<TSchema>>(schema: TSchema, fallback: TFallback): SchemaWithFallbackAsync<TSchema, TFallback>;

/**
 * Path tuple type.
 */
type PathTuple<TValue, TKey extends keyof TValue> = TKey extends TKey ? [
    TKey,
    ...{
        0: [];
        1: [] | PathTuple<TValue[TKey], keyof TValue[TKey] & number>;
        2: [] | PathTuple<TValue[TKey], keyof TValue[TKey]>;
    }[TValue[TKey] extends Blob | Date | Map<any, any> | Set<any> ? 0 : TValue[TKey] extends any[] ? 1 : TValue[TKey] extends Record<string, any> ? 2 : 0]
] : never;
/**
 * Path list type.
 */
type PathList<TInput extends unknown[] | Record<string, unknown>> = TInput extends any[] ? PathTuple<TInput, number> : PathTuple<TInput, keyof TInput>;

/**
 * Forwards the issues of the passed validation action.
 *
 * @param validation The validation.
 * @param pathList The path list.
 *
 * @returns The passed validation.
 */
declare function forward<TInput extends unknown[] | Record<string, unknown>>(validation: BaseValidation<TInput>, pathList: PathList<TInput>): BaseValidation<TInput>;

/**
 * Forwards the issues of the passed validation action.
 *
 * @param validation The validation.
 * @param pathList The path list.
 *
 * @returns The passed validation.
 */
declare function forwardAsync<TInput extends unknown[] | Record<string, unknown>>(validation: BaseValidationAsync<TInput>, pathList: PathList<TInput>): BaseValidationAsync<TInput>;

/**
 * Schema with maybe default async type.
 */
type SchemaWithMaybeDefaultAsync<TSchema extends BaseSchemaAsync = BaseSchemaAsync, TDefault extends DefaultAsync<TSchema> = DefaultAsync<TSchema>> = TSchema & {
    /**
     * The optional default value.
     */
    default?: TDefault;
};
/**
 * Returns the default value of the schema.
 *
 * @param schema The schema to get the default value from.
 *
 * @returns The default value.
 */
declare function getDefaultAsync<TSchema extends SchemaWithMaybeDefault | SchemaWithMaybeDefaultAsync>(schema: TSchema): Promise<DefaultValue<TSchema>>;

/**
 * Default value inference type.
 */
type DefaultValue<TSchema extends SchemaWithMaybeDefault | SchemaWithMaybeDefaultAsync> = TSchema['default'] extends Input<TSchema> | undefined ? TSchema['default'] : TSchema['default'] extends () => Input<TSchema> | undefined ? ReturnType<TSchema['default']> : TSchema['default'] extends () => Promise<Input<TSchema> | undefined> ? Awaited<ReturnType<TSchema['default']>> : undefined;

/**
 * Schema with maybe default type.
 */
type SchemaWithMaybeDefault<TSchema extends BaseSchema = BaseSchema, TDefault extends Default<TSchema> = Default<TSchema>> = TSchema & {
    /**
     * The optional default value.
     */
    default?: TDefault;
};
/**
 * Returns the default value of the schema.
 *
 * @param schema The schema to get the default value from.
 *
 * @returns The default value.
 */
declare function getDefault<TSchema extends SchemaWithMaybeDefault>(schema: TSchema): DefaultValue<TSchema>;

/**
 * Default values inference type.
 */
type DefaultValues<TSchema extends BaseSchema | BaseSchemaAsync> = TSchema extends ObjectSchema<infer TEntries extends ObjectEntries> ? {
    [TKey in keyof TEntries]: DefaultValues<TEntries[TKey]>;
} : TSchema extends ObjectSchemaAsync<infer TEntries extends ObjectEntriesAsync> ? {
    [TKey in keyof TEntries]: DefaultValues<TEntries[TKey]>;
} : TSchema extends TupleSchema<infer TItems> ? {
    [TKey in keyof TItems]: DefaultValues<TItems[TKey]>;
} : TSchema extends TupleSchemaAsync<infer TItems> ? {
    [TKey in keyof TItems]: DefaultValues<TItems[TKey]>;
} : DefaultValue<TSchema>;

/**
 * Returns the default values of the schema.
 *
 * Hint: The difference to `getDefault` is that for objects and tuples without
 * an explicit default value, this function recursively returns the default
 * values of the subschemas instead of `undefined`.
 *
 * @param schema The schema to get the default values from.
 *
 * @returns The default values.
 */
declare function getDefaults<TSchema extends SchemaWithMaybeDefault<BaseSchema | ObjectSchema<ObjectEntries, any> | TupleSchema<TupleItems, any>>>(schema: TSchema): DefaultValues<TSchema> | undefined;

/**
 * Returns the default values of the schema.
 *
 * The difference to `getDefaultAsync` is that for objects and tuples without
 * an explicit default value, this function recursively returns the default
 * values of the subschemas instead of `undefined`.
 *
 * @param schema The schema to get the default values from.
 *
 * @returns The default values.
 */
declare function getDefaultsAsync<TSchema extends SchemaWithMaybeDefault<BaseSchema | ObjectSchema<ObjectEntries, any> | TupleSchema<TupleItems, any>> | SchemaWithMaybeDefaultAsync<BaseSchemaAsync | ObjectSchemaAsync<ObjectEntriesAsync, any> | TupleSchemaAsync<TupleItemsAsync, any>>>(schema: TSchema): Promise<DefaultValues<TSchema> | undefined>;

/**
 * Schema with maybe fallback async type.
 */
type SchemaWithMaybeFallbackAsync<TSchema extends BaseSchemaAsync = BaseSchemaAsync, TFallback extends FallbackAsync<TSchema> = FallbackAsync<TSchema>> = TSchema & {
    /**
     * The optional fallback value.
     */
    fallback?: TFallback;
};
/**
 * Returns the fallback value of the schema.
 *
 * @param schema The schema to get the fallback value from.
 * @param info The fallback info.
 *
 * @returns The fallback value.
 */
declare function getFallbackAsync<TSchema extends SchemaWithMaybeFallback | SchemaWithMaybeFallbackAsync>(schema: TSchema, info?: FallbackInfo): Promise<FallbackValue<TSchema>>;

/**
 * Fallback value inference type.
 */
type FallbackValue<TSchema extends SchemaWithMaybeFallback | SchemaWithMaybeFallbackAsync> = TSchema['fallback'] extends Output<TSchema> ? TSchema['fallback'] : TSchema['fallback'] extends () => Output<TSchema> ? ReturnType<TSchema['fallback']> : TSchema['fallback'] extends () => Promise<Output<TSchema>> ? Awaited<ReturnType<TSchema['fallback']>> : undefined;

/**
 * Schema with maybe fallback type.
 */
type SchemaWithMaybeFallback<TSchema extends BaseSchema = BaseSchema, TFallback extends Fallback<TSchema> = Fallback<TSchema>> = TSchema & {
    /**
     * The optional fallback value.
     */
    fallback?: TFallback;
};
/**
 * Returns the fallback value of the schema.
 *
 * @param schema The schema to get the fallback value from.
 * @param info The fallback info.
 *
 * @returns The fallback value.
 */
declare function getFallback<TSchema extends SchemaWithMaybeFallback>(schema: TSchema, info?: FallbackInfo): FallbackValue<TSchema>;

/**
 * Fallback values inference type.
 */
type FallbackValues<TSchema extends SchemaWithMaybeFallback<BaseSchema | ObjectSchema<ObjectEntries, any> | TupleSchema<TupleItems, any>> | SchemaWithMaybeFallbackAsync<BaseSchemaAsync | ObjectSchemaAsync<ObjectEntriesAsync, any> | TupleSchemaAsync<TupleItemsAsync, any>>> = TSchema extends ObjectSchema<infer TEntries extends ObjectEntries> ? {
    [TKey in keyof TEntries]: FallbackValues<TEntries[TKey]>;
} : TSchema extends ObjectSchemaAsync<infer TEntries extends ObjectEntriesAsync> ? {
    [TKey in keyof TEntries]: FallbackValues<TEntries[TKey]>;
} : TSchema extends TupleSchema<infer TItems> ? {
    [TKey in keyof TItems]: FallbackValues<TItems[TKey]>;
} : TSchema extends TupleSchemaAsync<infer TItems> ? {
    [TKey in keyof TItems]: FallbackValues<TItems[TKey]>;
} : FallbackValue<TSchema>;

/**
 * Returns the fallback values of the schema.
 *
 * Hint: The difference to `getFallback` is that for objects and tuples without
 * an explicit fallback value, this function recursively returns the fallback
 * values of the subschemas instead of `undefined`.
 *
 * @param schema The schema to get the fallback values from.
 *
 * @returns The fallback values.
 */
declare function getFallbacks<TSchema extends SchemaWithMaybeFallback<BaseSchema | ObjectSchema<ObjectEntries, any> | TupleSchema<TupleItems, any>>>(schema: TSchema): FallbackValues<TSchema> | undefined;

/**
 * Returns the fallback values of the schema.
 *
 * Hint: The difference to `getFallbackAsync` is that for objects and tuples
 * without an explicit fallback value, this function recursively returns the
 * fallback values of the subschemas instead of `undefined`.
 *
 * @param schema The schema to get the fallback values from.
 *
 * @returns The fallback values.
 */
declare function getFallbacksAsync<TSchema extends SchemaWithMaybeFallback<BaseSchema | ObjectSchema<ObjectEntries, any> | TupleSchema<TupleItems, any>> | SchemaWithMaybeFallbackAsync<BaseSchemaAsync | ObjectSchemaAsync<ObjectEntriesAsync, any> | TupleSchemaAsync<TupleItemsAsync, any>>>(schema: TSchema): Promise<FallbackValues<TSchema> | undefined>;

/**
 * Checks if the input matches the scheme. By using a type predicate, this
 * function can be used as a type guard.
 *
 * @param schema The schema to be used.
 * @param input The input to be tested.
 * @param config The parse configuration.
 *
 * @returns Whether the input matches the scheme.
 */
declare function is<TSchema extends BaseSchema>(schema: TSchema, input: unknown, config?: Pick<SchemaConfig, 'skipPipe'>): input is Input<TSchema>;

/**
 * Converts union to intersection types.
 */
type UnionToIntersection<T> = (T extends never ? never : (arg: T) => never) extends (arg: infer U) => never ? U : never;
/**
 * Converts union to tuple types.
 */
type UnionToTuple<T> = UnionToIntersection<T extends never ? never : () => T> extends () => infer W ? [...UnionToTuple<Exclude<T, W>>, W] : [];
/**
 * Returns a tuple or never type.
 */
type TupleOrNever<T> = T extends [string, ...string[]] ? T : never;
/**
 * Creates a picklist schema of object keys.
 *
 * @param schema The object schema.
 *
 * @returns A picklist schema.
 */
declare function keyof<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>>(schema: TSchema): PicklistSchema<TupleOrNever<UnionToTuple<keyof TSchema['entries']>>>;

/**
 * Merges objects types.
 */
type MergeObjects<TSchemas extends (ObjectSchema<any, any> | ObjectSchemaAsync<any, any>)[]> = TSchemas extends [infer TFirstSchema] ? TFirstSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any> ? TFirstSchema['entries'] : never : TSchemas extends [infer TFirstSchema, ...infer TRestSchemas] ? TFirstSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any> ? TRestSchemas extends (ObjectSchema<any, any> | ObjectSchemaAsync<any, any>)[] ? {
    [TKey in Exclude<keyof TFirstSchema['entries'], keyof MergeObjects<TRestSchemas>>]: TFirstSchema['entries'][TKey];
} & MergeObjects<TRestSchemas> : never : never : never;

/**
 * Object schemas type.
 */
type ObjectSchemas$1 = [
    ObjectSchema<any, any>,
    ObjectSchema<any, any>,
    ...ObjectSchema<any, any>[]
];
/**
 * Merges the entries of multiple object schemas. Subsequent object entries
 * overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function merge<TSchemas extends ObjectSchemas$1>(schemas: TSchemas, pipe?: Pipe<ObjectOutput<MergeObjects<TSchemas>, undefined>>): ObjectSchema<MergeObjects<TSchemas>>;
/**
 * Merges the entries of multiple object schemas. Subsequent object entries
 * overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function merge<TSchemas extends ObjectSchemas$1>(schemas: TSchemas, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<MergeObjects<TSchemas>, undefined>>): ObjectSchema<MergeObjects<TSchemas>>;
/**
 * Merges the entries of multiple object schemas. Subsequent object entries
 * overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function merge<TSchemas extends ObjectSchemas$1, TRest extends BaseSchema | undefined>(schemas: TSchemas, rest: TRest, pipe?: Pipe<ObjectOutput<MergeObjects<TSchemas>, TRest>>): ObjectSchema<MergeObjects<TSchemas>, TRest>;
/**
 * Merges the entries of multiple object schemas. Subsequent object entries
 * overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function merge<TSchemas extends ObjectSchemas$1, TRest extends BaseSchema | undefined>(schemas: TSchemas, rest: TRest, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<MergeObjects<TSchemas>, TRest>>): ObjectSchema<MergeObjects<TSchemas>, TRest>;

/**
 * Object schemas type.
 */
type ObjectSchemas = [
    ObjectSchema<any, any> | ObjectSchemaAsync<any, any>,
    ObjectSchema<any, any> | ObjectSchemaAsync<any, any>,
    ...(ObjectSchema<any, any> | ObjectSchemaAsync<any, any>)[]
];
/**
 * Merges the entries of multiple async object schemas. Subsequent object
 * entries overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function mergeAsync<TSchemas extends ObjectSchemas>(schemas: TSchemas, pipe?: PipeAsync<ObjectOutput<MergeObjects<TSchemas>, undefined>>): ObjectSchemaAsync<MergeObjects<TSchemas>>;
/**
 * Merges the entries of multiple async object schemas. Subsequent object
 * entries overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function mergeAsync<TSchemas extends ObjectSchemas>(schemas: TSchemas, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<MergeObjects<TSchemas>, undefined>>): ObjectSchemaAsync<MergeObjects<TSchemas>>;
/**
 * Merges the entries of multiple async object schemas. Subsequent object
 * entries overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function mergeAsync<TSchemas extends ObjectSchemas, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schemas: TSchemas, rest: TRest, pipe?: PipeAsync<ObjectOutput<MergeObjects<TSchemas>, TRest>>): ObjectSchemaAsync<MergeObjects<TSchemas>, TRest>;
/**
 * Merges the entries of multiple async object schemas. Subsequent object
 * entries overwrite the previous ones.
 *
 * @param schemas The schemas to be merged.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function mergeAsync<TSchemas extends ObjectSchemas, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schemas: TSchemas, rest: TRest, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<MergeObjects<TSchemas>, TRest>>): ObjectSchemaAsync<MergeObjects<TSchemas>, TRest>;

/**
 * Creates an object schema that contains not the selected keys of an existing
 * schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function omit<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, pipe?: Pipe<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchema<Omit<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an object schema that contains not the selected keys of an existing
 * schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function omit<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchema<Omit<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an object schema that contains not the selected keys of an existing
 * schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function omit<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | undefined>(schema: TSchema, keys: TKeys, rest: TRest, pipe?: Pipe<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchema<Omit<TSchema['entries'], TKeys[number]>, TRest>;
/**
 * Creates an object schema that contains not the selected keys of an existing
 * schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function omit<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | undefined>(schema: TSchema, keys: TKeys, rest: TRest, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchema<Omit<TSchema['entries'], TKeys[number]>, TRest>;

/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function omitAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, pipe?: PipeAsync<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchemaAsync<Omit<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function omitAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchemaAsync<Omit<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function omitAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schema: TSchema, keys: TKeys, rest: TRest, pipe?: PipeAsync<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchemaAsync<Omit<TSchema['entries'], TKeys[number]>, TRest>;
/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to omit from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function omitAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schema: TSchema, keys: TKeys, rest: TRest, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<Omit<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchemaAsync<Omit<TSchema['entries'], TKeys[number]>, TRest>;

/**
 * Parses an unknown input based on a schema.
 *
 * @param schema The schema to be used.
 * @param input The input to be parsed.
 * @param config The parse configuration.
 *
 * @returns The parsed output.
 */
declare function parse<TSchema extends BaseSchema>(schema: TSchema, input: unknown, config?: SchemaConfig): Output<TSchema>;

/**
 * Parses an unknown input based on a schema.
 *
 * @param schema The schema to be used.
 * @param input The input to be parsed.
 * @param config The parse configuration.
 *
 * @returns The parsed output.
 */
declare function parseAsync<TSchema extends BaseSchema | BaseSchemaAsync>(schema: TSchema, input: unknown, config?: SchemaConfig): Promise<Output<TSchema>>;

/**
 * Partial object entries type.
 */
type PartialObjectEntries<TEntries extends ObjectEntries> = {
    [TKey in keyof TEntries]: OptionalSchema<TEntries[TKey]>;
};
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to optional.
 *
 * @param schema The affected schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function partial<TSchema extends ObjectSchema<any, any>>(schema: TSchema, pipe?: Pipe<ObjectOutput<PartialObjectEntries<TSchema['entries']>, undefined>>): ObjectSchema<PartialObjectEntries<TSchema['entries']>>;
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to optional.
 *
 * @param schema The affected schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function partial<TSchema extends ObjectSchema<any, any>>(schema: TSchema, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<PartialObjectEntries<TSchema['entries']>, undefined>>): ObjectSchema<PartialObjectEntries<TSchema['entries']>>;
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function partial<TSchema extends ObjectSchema<any, any>, TRest extends BaseSchema | undefined>(schema: TSchema, rest: TRest, pipe?: Pipe<ObjectOutput<PartialObjectEntries<TSchema['entries']>, TRest>>): ObjectSchema<PartialObjectEntries<TSchema['entries']>, TRest>;
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function partial<TSchema extends ObjectSchema<any, any>, TRest extends BaseSchema | undefined>(schema: TSchema, rest: TRest, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<PartialObjectEntries<TSchema['entries']>, TRest>>): ObjectSchema<PartialObjectEntries<TSchema['entries']>, TRest>;

/**
 * Partial object entries async type.
 */
type PartialObjectEntriesAsync<TEntries extends ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: OptionalSchemaAsync<TEntries[TKey]>;
};
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to optional.
 *
 * @param schema The affected schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function partialAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>>(schema: TSchema, pipe?: PipeAsync<ObjectOutput<PartialObjectEntriesAsync<TSchema['entries']>, undefined>>): ObjectSchemaAsync<PartialObjectEntriesAsync<TSchema['entries']>>;
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to optional.
 *
 * @param schema The affected schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function partialAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>>(schema: TSchema, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<PartialObjectEntriesAsync<TSchema['entries']>, undefined>>): ObjectSchemaAsync<PartialObjectEntriesAsync<TSchema['entries']>>;
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function partialAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TRest extends BaseSchema | undefined>(schema: TSchema, rest: TRest, pipe?: PipeAsync<ObjectOutput<PartialObjectEntriesAsync<TSchema['entries']>, TRest>>): ObjectSchemaAsync<PartialObjectEntriesAsync<TSchema['entries']>, TRest>;
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function partialAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TRest extends BaseSchema | undefined>(schema: TSchema, rest: TRest, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<PartialObjectEntriesAsync<TSchema['entries']>, TRest>>): ObjectSchemaAsync<PartialObjectEntriesAsync<TSchema['entries']>, TRest>;

/**
 * Creates an object schema that contains only the selected keys of an existing
 * schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function pick<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, pipe?: Pipe<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchema<Pick<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an object schema that contains only the selected keys of an existing
 * schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function pick<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchema<Pick<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an object schema that contains only the selected keys of an existing
 * schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function pick<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | undefined>(schema: TSchema, keys: TKeys, rest: TRest, pipe?: Pipe<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchema<Pick<TSchema['entries'], TKeys[number]>, TRest>;
/**
 * Creates an object schema that contains only the selected keys of an existing
 * schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function pick<TSchema extends ObjectSchema<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | undefined>(schema: TSchema, keys: TKeys, rest: TRest, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchema<Pick<TSchema['entries'], TKeys[number]>, TRest>;

/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function pickAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, pipe?: PipeAsync<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchemaAsync<Pick<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function pickAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>>(schema: TSchema, keys: TKeys, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, undefined>>): ObjectSchemaAsync<Pick<TSchema['entries'], TKeys[number]>>;
/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function pickAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schema: TSchema, keys: TKeys, rest: TRest, pipe?: PipeAsync<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchemaAsync<Pick<TSchema['entries'], TKeys[number]>, TRest>;
/**
 * Creates an async object schema that contains only the selected keys of an
 * existing schema.
 *
 * @param schema The schema to pick from.
 * @param keys The selected keys
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function pickAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TKeys extends ObjectKeys<TSchema>, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schema: TSchema, keys: TKeys, rest: TRest, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<Pick<TSchema['entries'], TKeys[number]>, TRest>>): ObjectSchemaAsync<Pick<TSchema['entries'], TKeys[number]>, TRest>;

/**
 * Required object schema type.
 */
type Required$1<TEntries extends ObjectEntries> = {
    [TKey in keyof TEntries]: NonOptionalSchema<TEntries[TKey]>;
};
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to non optional.
 *
 * @param schema The affected schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function required<TSchema extends ObjectSchema<any, any>>(schema: TSchema, pipe?: Pipe<ObjectOutput<Required$1<TSchema['entries']>, undefined>>): ObjectSchema<Required$1<TSchema['entries']>>;
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to non optional.
 *
 * @param schema The affected schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function required<TSchema extends ObjectSchema<any, any>>(schema: TSchema, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<Required$1<TSchema['entries']>, undefined>>): ObjectSchema<Required$1<TSchema['entries']>>;
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to non optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function required<TSchema extends ObjectSchema<any, any>, TRest extends BaseSchema | undefined>(schema: TSchema, rest: TRest, pipe?: Pipe<ObjectOutput<Required$1<TSchema['entries']>, TRest>>): ObjectSchema<Required$1<TSchema['entries']>, TRest>;
/**
 * Creates an object schema consisting of all properties of an existing object
 * schema set to non optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An object schema.
 */
declare function required<TSchema extends ObjectSchema<any, any>, TRest extends BaseSchema | undefined>(schema: TSchema, rest: TRest, message?: ErrorMessage, pipe?: Pipe<ObjectOutput<Required$1<TSchema['entries']>, TRest>>): ObjectSchema<Required$1<TSchema['entries']>, TRest>;

/**
 * Required object schema type.
 */
type Required<TEntries extends ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: NonOptionalSchemaAsync<TEntries[TKey]>;
};
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to non optional.
 *
 * @param schema The affected schema.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function requiredAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>>(schema: TSchema, pipe?: PipeAsync<ObjectOutput<Required<TSchema['entries']>, undefined>>): ObjectSchemaAsync<Required<TSchema['entries']>>;
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to non optional.
 *
 * @param schema The affected schema.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function requiredAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>>(schema: TSchema, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<Required<TSchema['entries']>, undefined>>): ObjectSchemaAsync<Required<TSchema['entries']>>;
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to non optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function requiredAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schema: TSchema, rest: TRest, pipe?: PipeAsync<ObjectOutput<Required<TSchema['entries']>, TRest>>): ObjectSchemaAsync<Required<TSchema['entries']>, TRest>;
/**
 * Creates an async object schema consisting of all properties of an existing
 * object schema set to non optional.
 *
 * @param schema The affected schema.
 * @param rest The object rest.
 * @param message The error message.
 * @param pipe A validation and transformation pipe.
 *
 * @returns An async object schema.
 */
declare function requiredAsync<TSchema extends ObjectSchema<any, any> | ObjectSchemaAsync<any, any>, TRest extends BaseSchema | BaseSchemaAsync | undefined>(schema: TSchema, rest: TRest, message?: ErrorMessage, pipe?: PipeAsync<ObjectOutput<Required<TSchema['entries']>, TRest>>): ObjectSchemaAsync<Required<TSchema['entries']>, TRest>;

/**
 * Safe parse result type.
 */
type SafeParseResult<TSchema extends BaseSchema | BaseSchemaAsync> = {
    typed: true;
    success: true;
    output: Output<TSchema>;
    issues: undefined;
} | {
    typed: true;
    success: false;
    output: Output<TSchema>;
    issues: SchemaIssues;
} | {
    typed: false;
    success: false;
    output: unknown;
    issues: SchemaIssues;
};

/**
 * Parses an unknown input based on a schema.
 *
 * @param schema The schema to be used.
 * @param input The input to be parsed.
 * @param config The parse configuration.
 *
 * @returns The parsed output.
 */
declare function safeParse<TSchema extends BaseSchema>(schema: TSchema, input: unknown, config?: SchemaConfig): SafeParseResult<TSchema>;

/**
 * Parses an unknown input based on a schema.
 *
 * @param schema The schema to be used.
 * @param input The input to be parsed.
 * @param config The parse configuration.
 *
 * @returns The parsed output.
 */
declare function safeParseAsync<TSchema extends BaseSchema | BaseSchemaAsync>(schema: TSchema, input: unknown, config?: SchemaConfig): Promise<SafeParseResult<TSchema>>;

interface TransformInfo {
    issues: SchemaIssues | undefined;
}

/**
 * Schema with transform type.
 */
type SchemaWithTransform<TSchema extends BaseSchema, TOutput> = Omit<TSchema, '_types'> & {
    _types?: {
        input: Input<TSchema>;
        output: TOutput;
    };
};
/**
 * Adds a transformation step to a schema, which is executed at the end of
 * parsing and can change the output type.
 *
 * @param schema The schema to be used.
 * @param action The transformation action.
 * @param pipe A validation pipe.
 *
 * @returns A transformed schema.
 */
declare function transform<TSchema extends BaseSchema, TOutput>(schema: TSchema, action: (input: Output<TSchema>, info: TransformInfo) => TOutput, pipe?: Pipe<TOutput>): SchemaWithTransform<TSchema, TOutput>;
/**
 * Adds a transformation step to a schema, which is executed at the end of
 * parsing and can change the output type.
 *
 * @param schema The schema to be used.
 * @param action The transformation action.
 * @param validation A validation schema.
 *
 * @returns A transformed schema.
 */
declare function transform<TSchema extends BaseSchema, TOutput>(schema: TSchema, action: (input: Output<TSchema>, info: TransformInfo) => TOutput, validation?: BaseSchema<TOutput>): SchemaWithTransform<TSchema, TOutput>;

/**
 * Schema with transform async type.
 */
type SchemaWithTransformAsync<TSchema extends BaseSchema | BaseSchemaAsync, TOutput> = Omit<TSchema, 'async' | '_parse' | '_types'> & {
    async: true;
    _parse(input: unknown, config?: SchemaConfig): Promise<SchemaResult<TOutput>>;
    _types?: {
        input: Input<TSchema>;
        output: TOutput;
    };
};
/**
 * Adds an async transformation step to a schema, which is executed at the end
 * of parsing and can change the output type.
 *
 * @param schema The schema to be used.
 * @param action The transformation action.
 * @param pipe A validation pipe.
 *
 * @returns A transformed schema.
 */
declare function transformAsync<TSchema extends BaseSchema | BaseSchemaAsync, TOutput>(schema: TSchema, action: (input: Output<TSchema>, info: TransformInfo) => TOutput | Promise<TOutput>, pipe?: PipeAsync<TOutput>): SchemaWithTransformAsync<TSchema, TOutput>;
/**
 * Adds an async transformation step to a schema, which is executed at the end
 * of parsing and can change the output type.
 *
 * @param schema The schema to be used.
 * @param action The transformation action.
 * @param validation A validation schema.
 *
 * @returns A transformed schema.
 */
declare function transformAsync<TSchema extends BaseSchema | BaseSchemaAsync, TOutput>(schema: TSchema, action: (input: Output<TSchema>, info: TransformInfo) => TOutput | Promise<TOutput>, validation?: BaseSchema<TOutput> | BaseSchemaAsync<TOutput>): SchemaWithTransformAsync<TSchema, TOutput>;

/**
 * Unwraps the wrapped schema.
 *
 * @param schema The schema to be unwrapped.
 *
 * @returns The unwrapped schema.
 */
declare function unwrap<TSchema extends OptionalSchema<any, any> | OptionalSchemaAsync<any, any> | NullableSchema<any, any> | NullableSchemaAsync<any, any> | NullishSchema<any, any> | NullishSchemaAsync<any, any> | NonOptionalSchema<any> | NonOptionalSchemaAsync<any> | NonNullableSchema<any> | NonNullableSchemaAsync<any> | NonNullishSchema<any> | NonNullishSchemaAsync<any>>(schema: TSchema): TSchema['wrapped'];

/**
 * [BIC] (https://en.wikipedia.org/wiki/ISO_9362) regex.
 */
declare const BIC_REGEX: RegExp;
/**
 * [Cuid2](https://github.com/paralleldrive/cuid2) regex.
 */
declare const CUID2_REGEX: RegExp;
/**
 * [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.
 */
declare const DECIMAL_REGEX: RegExp;
/**
 * Email regex.
 */
declare const EMAIL_REGEX: RegExp;
/**
 * Emoji regex.
 */
declare const EMOJI_REGEX: RegExp;
/**
 * [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.
 */
declare const HEXADECIMAL_REGEX: RegExp;
/**
 * [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.
 */
declare const HEX_COLOR_REGEX: RegExp;
/**
 * [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.
 */
declare const IMEI_REGEX: RegExp;
/**
 * [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.
 */
declare const IPV4_REGEX: RegExp;
/**
 * [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.
 */
declare const IPV6_REGEX: RegExp;
/**
 * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.
 */
declare const ISO_DATE_REGEX: RegExp;
/**
 * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.
 */
declare const ISO_DATE_TIME_REGEX: RegExp;
/**
 * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.
 */
declare const ISO_TIME_REGEX: RegExp;
/**
 * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.
 */
declare const ISO_TIME_SECOND_REGEX: RegExp;
/**
 * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.
 */
declare const ISO_TIMESTAMP_REGEX: RegExp;
/**
 * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.
 */
declare const ISO_WEEK_REGEX: RegExp;
/**
 * [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.
 */
declare const MAC48_REGEX: RegExp;
/**
 * [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.
 */
declare const MAC64_REGEX: RegExp;
/**
 * [Octal](https://en.wikipedia.org/wiki/Octal) regex.
 */
declare const OCTAL_REGEX: RegExp;
/**
 * [ULID](https://github.com/ulid/spec) regex.
 */
declare const ULID_REGEX: RegExp;
/**
 * [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.
 */
declare const UUID_REGEX: RegExp;

/**
 * The global config type.
 */
type GlobalConfig = Omit<SchemaConfig, 'message'>;
/**
 * Sets the global configuration.
 *
 * @param config The configuration.
 */
declare function setGlobalConfig(config: GlobalConfig): void;
/**
 * Returns the global configuration.
 *
 * @param config The config to merge.
 *
 * @returns The configuration.
 */
declare function getGlobalConfig(config?: SchemaConfig): SchemaConfig;
/**
 * Deletes the global configuration.
 */
declare function deleteGlobalConfig(): void;

/**
 * Sets a global error message.
 *
 * @param message The error message.
 * @param lang The language of the message.
 */
declare function setGlobalMessage(message: ErrorMessage, lang?: string): void;
/**
 * Returns a global error message.
 *
 * @param lang The language of the message.
 *
 * @returns The error message.
 */
declare function getGlobalMessage(lang?: string): ErrorMessage | undefined;
/**
 * Deletes a global error message.
 *
 * @param lang The language of the message.
 */
declare function deleteGlobalMessage(lang?: string): void;

/**
 * Sets a schema error message.
 *
 * @param message The error message.
 * @param lang The language of the message.
 */
declare function setSchemaMessage(message: ErrorMessage, lang?: string): void;
/**
 * Returns a schema error message.
 *
 * @param lang The language of the message.
 *
 * @returns The error message.
 */
declare function getSchemaMessage(lang?: string): ErrorMessage | undefined;
/**
 * Deletes a schema error message.
 *
 * @param lang The language of the message.
 */
declare function deleteSchemaMessage(lang?: string): void;

/**
 * Sets a specific error message.
 *
 * @param reference The identifier reference.
 * @param message The error message.
 * @param lang The language of the message.
 */
declare function setSpecificMessage(reference: Function, message: ErrorMessage, lang?: string): void;
/**
 * Returns a specific error message.
 *
 * @param reference The identifier reference.
 * @param lang The language of the message.
 *
 * @returns The error message.
 */
declare function getSpecificMessage(reference: Function, lang?: string): ErrorMessage | undefined;
/**
 * Deletes a specific error message.
 *
 * @param reference The identifier reference.
 * @param lang The language of the message.
 */
declare function deleteSpecificMessage(reference: Function, lang?: string): void;

/**
 * To custom transformation type.
 */
interface ToCustomTransformation<TInput> extends BaseTransformation<TInput> {
    /**
     * The transformation type.
     */
    type: 'to_custom';
}
/**
 * Creates a custom pipeline transformation action.
 *
 * @param action The transform action.
 *
 * @returns A transformation action.
 */
declare function toCustom<TInput>(action: (input: TInput) => TInput): ToCustomTransformation<TInput>;

/**
 * To custom transformation async type.
 */
interface ToCustomTransformationAsync<TInput> extends BaseTransformationAsync<TInput> {
    /**
     * The transformation type.
     */
    type: 'to_custom';
}
/**
 * Creates a async custom transformation function.
 *
 * @param action The transform action.
 *
 * @returns A async transformation function.
 */
declare function toCustomAsync<TInput>(action: (input: TInput) => TInput | Promise<TInput>): ToCustomTransformationAsync<TInput>;

/**
 * To lower case transformation type.
 */
interface ToLowerCaseTransformation extends BaseTransformation<string> {
    /**
     * The transformation type.
     */
    type: 'to_lower_case';
}
/**
 * Creates a pipeline transformation action that converts all the alphabetic
 * characters in a string to lowercase.
 *
 * @returns A transformation action.
 */
declare function toLowerCase(): ToLowerCaseTransformation;

/**
 * To max value transformation type.
 */
interface ToMaxValueTransformation<TInput extends string | number | bigint | Date, TRequirement extends TInput> extends BaseTransformation<TInput> {
    /**
     * The transformation type.
     */
    type: 'to_max_value';
    /**
     * The maximum value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline transformation action that sets a string, number or date
 * to a maximum value.
 *
 * @param requirement The maximum value.
 *
 * @returns A transformation action.
 */
declare function toMaxValue<TInput extends string | number | bigint | Date, TRequirement extends TInput>(requirement: TRequirement): ToMaxValueTransformation<TInput, TRequirement>;

/**
 * To min value transformation type.
 */
interface ToMinValueTransformation<TInput extends string | number | bigint | Date, TRequirement extends TInput> extends BaseTransformation<TInput> {
    /**
     * The transformation type.
     */
    type: 'to_min_value';
    /**
     * The minium value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline transformation action that sets a string, number or date
 * to a minimum value.
 *
 * @param requirement The minimum value.
 *
 * @returns A transformation action.
 */
declare function toMinValue<TInput extends string | number | bigint | Date, TRequirement extends TInput>(requirement: TRequirement): ToMinValueTransformation<TInput, TRequirement>;

/**
 * To trimmed transformation type.
 */
interface ToTrimmedTransformation extends BaseTransformation<string> {
    /**
     * The transformation type.
     */
    type: 'to_trimmed';
}
/**
 * Creates a pipeline transformation action that removes the leading and
 * trailing white space and line terminator characters from a string.
 *
 * @returns A transformation action.
 */
declare function toTrimmed(): ToTrimmedTransformation;

/**
 * To trimmed end transformation type.
 */
interface ToTrimmedEndTransformation extends BaseTransformation<string> {
    /**
     * The transformation type.
     */
    type: 'to_trimmed_end';
}
/**
 * Creates a pipeline transformation action that removes the trailing white
 * space and line terminator characters from a string.
 *
 * @returns A transformation action.
 */
declare function toTrimmedEnd(): ToTrimmedEndTransformation;

/**
 * To trimmed start transformation type.
 */
interface ToTrimmedStartTransformation extends BaseTransformation<string> {
    /**
     * The transformation type.
     */
    type: 'to_trimmed_start';
}
/**
 * Creates a pipeline transformation action that removes the leading white
 * space and line terminator characters from a string.
 *
 * @returns A transformation action.
 */
declare function toTrimmedStart(): ToTrimmedStartTransformation;

/**
 * To upper case transformation type.
 */
interface ToUpperCaseTransformation extends BaseTransformation<string> {
    /**
     * The transformation type.
     */
    type: 'to_upper_case';
}
/**
 * Creates a pipeline transformation action that converts all the alphabetic
 * characters in a string to uppercase.
 *
 * @returns A transformation action.
 */
declare function toUpperCase(): ToUpperCaseTransformation;

/**
 * Returns the pipeline result object with issues.
 *
 * @param context The action context.
 * @param reference The action reference.
 * @param input The raw input data.
 * @param label The issue label.
 * @param received The received input.
 *
 * @returns The pipeline result object.
 */
declare function actionIssue(context: PipeActionContext, reference: Function, input: unknown, label: string, received?: string): InvalidActionResult;

/**
 * Returns the pipeline action output.
 *
 * @param output The output value.
 *
 * @returns The result object.
 */
declare function actionOutput<TOutput>(output: TOutput): ValidActionResult<TOutput>;

/**
 * Returns message and pipe from dynamic arguments.
 *
 * @param arg1 First argument.
 * @param arg2 Second argument.
 *
 * @returns The default arguments.
 */
declare function defaultArgs<TPipe extends Pipe<any> | PipeAsync<any>>(arg1: ErrorMessage | TPipe | undefined, arg2: TPipe | undefined): [ErrorMessage | undefined, TPipe | undefined];

/**
 * The i18n context type.
 */
interface I18nContext {
    message: ErrorMessage | undefined;
}
/**
 * Creates the i18n error message.
 *
 * @param schema Whether its a schema.
 * @param context The message context.
 * @param reference The identifier reference.
 * @param config The parse configuration.
 * @param issue The issue.
 *
 * @returns The error message.
 */
declare function i18n(schema: boolean, context: I18nContext, reference: Function, config: SchemaConfig | undefined, issue: SchemaIssue): string;

/**
 * Checks whether a string with numbers corresponds to the luhn algorithm.
 *
 * @param input The input to be checked.
 *
 * @returns Whether input is valid.
 */
declare function isLuhnAlgo(input: string): boolean;

/**
 * A generic type guard to check the type of an object.
 *
 * @param type The type to check for.
 * @param object The object to check.
 *
 * @returns Whether it matches.
 */
declare function isOfType<TType extends string, TObject extends {
    type: string;
}>(type: TType, object: TObject): object is Extract<TObject, {
    type: TType;
}>;

/**
 * The schema context type.
 */
interface SchemaContext$2<TValue> {
    type: IssueReason;
    pipe: Pipe<TValue> | undefined;
}
/**
 * Executes the validation and transformation pipe.
 *
 * @param context The schema context.
 * @param input The input value.
 * @param config The parse configuration.
 * @param issues The issues if any.
 *
 * @returns The pipe result.
 */
declare function pipeResult<TValue>(context: SchemaContext$2<TValue>, input: TValue, config: SchemaConfig | undefined, issues?: SchemaIssues): TypedSchemaResult<TValue>;

/**
 * The schema context type.
 */
interface SchemaContext$1<TValue> {
    type: IssueReason;
    pipe: PipeAsync<TValue> | undefined;
}
/**
 * Executes the async validation and transformation pipe.
 *
 * @param context The schema context.
 * @param input The input value.
 * @param config The parse configuration.
 * @param issues The issues if any.
 *
 * @returns The pipe result.
 */
declare function pipeResultAsync<TValue>(context: SchemaContext$1<TValue>, input: TValue, config: SchemaConfig | undefined, issues?: SchemaIssues): Promise<SchemaResult<TValue>>;

/**
 * Returns rest, error and pipe from dynamic arguments.
 *
 * @param arg1 First argument.
 * @param arg2 Second argument.
 * @param arg3 Third argument.
 *
 * @returns The tuple arguments.
 */
declare function restAndDefaultArgs<TRest extends BaseSchema | BaseSchemaAsync | undefined, TPipe extends Pipe<any> | PipeAsync<any>>(arg1: TPipe | ErrorMessage | TRest | undefined, arg2: TPipe | ErrorMessage | undefined, arg3: TPipe | undefined): [TRest, ErrorMessage | undefined, TPipe | undefined];

/**
 * The schema context type.
 */
interface SchemaContext {
    type: string;
    expects: string;
    message: ErrorMessage | undefined;
}
/**
 * The other info type.
 */
interface OtherInfo {
    reason?: IssueReason;
    expected?: string;
    path?: IssuePath;
    issues?: SchemaIssues;
}
/**
 * Returns the schema result object with issues.
 *
 * @param context The schema context.
 * @param reference The schema reference.
 * @param input The raw input data.
 * @param config The parse configuration.
 * @param other The other info.
 *
 * @returns The schema result object.
 */
declare function schemaIssue(context: SchemaContext, reference: Function, input: unknown, config: SchemaConfig | undefined, other?: OtherInfo): UntypedSchemaResult;

/**
 * Returns the schema result object.
 *
 * @param typed Whether it's typed.
 * @param output The output value.
 * @param issues The issues if any.
 *
 * @returns The result object.
 */
declare function schemaResult<TOutput>(typed: true, output: TOutput, issues?: SchemaIssues): TypedSchemaResult<TOutput>;
/**
 * Returns the schema result object.
 *
 * @param typed Whether it's typed.
 * @param output The output value.
 * @param issues The issues.
 *
 * @returns The result object.
 */
declare function schemaResult(typed: false, output: unknown, issues: SchemaIssues): UntypedSchemaResult;

/**
 * Stringifies an unknown input to a literal or type string.
 *
 * @param input The unknown input.
 *
 * @returns A literal or type string.
 */
declare function stringify(input: unknown): string;

/**
 * Bic validation type.
 */
interface BicValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'bic';
    /**
     * The BIC regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a [BIC](https://en.wikipedia.org/wiki/ISO_9362).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function bic<TInput extends string>(message?: ErrorMessage): BicValidation<TInput>;

/**
 * Bytes validation type.
 */
interface BytesValidation<TInput extends string, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'bytes';
    /**
     * The byte length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the bytes of a string.
 *
 * @param requirement The bytes.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function bytes<TInput extends string, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): BytesValidation<TInput, TRequirement>;

/**
 * Credit card validation type.
 */
interface CreditCardValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'credit_card';
    /**
     * The validation function.
     */
    requirement: (input: TInput) => boolean;
}
/**
 * Creates a pipeline validation action that validates a [credit card](https://en.wikipedia.org/wiki/Payment_card_number).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function creditCard<TInput extends string>(message?: ErrorMessage): CreditCardValidation<TInput>;

/**
 * Cuid2 validation type.
 */
interface Cuid2Validation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'cuid2';
    /**
     * The Cuid2 regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a [Cuid2](https://github.com/paralleldrive/cuid2).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function cuid2<TInput extends string>(message?: ErrorMessage): Cuid2Validation<TInput>;

/**
 * Custom validation type.
 */
interface CustomValidation<TInput> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'custom';
    /**
     * The validation function.
     */
    requirement: (input: TInput) => boolean;
}
/**
 * Creates a custom pipeline validation action.
 *
 * @param requirement The validation function.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function custom<TInput>(requirement: (input: TInput) => boolean, message?: ErrorMessage): CustomValidation<TInput>;

/**
 * Custom validation async type.
 */
interface CustomValidationAsync<TInput> extends BaseValidationAsync<TInput> {
    /**
     * The validation type.
     */
    type: 'custom';
    /**
     * The validation function.
     */
    requirement: (input: TInput) => Promise<boolean>;
}
/**
 * Creates a async custom validation function.
 *
 * @param requirement The async validation function.
 * @param message The error message.
 *
 * @returns A async validation action.
 */
declare function customAsync<TInput>(requirement: (input: TInput) => Promise<boolean>, message?: ErrorMessage): CustomValidationAsync<TInput>;

/**
 * Decimal validation type.
 */
interface DecimalValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'decimal';
    /**
     * The decimal regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a [decimal](https://en.wikipedia.org/wiki/Decimal).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function decimal<TInput extends string>(message?: ErrorMessage): DecimalValidation<TInput>;

/**
 * Email validation type.
 */
interface EmailValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'email';
    /**
     * The email regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates an email.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function email<TInput extends string>(message?: ErrorMessage): EmailValidation<TInput>;

/**
 * Emoji validation type.
 */
interface EmojiValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'emoji';
    /**
     * The emoji regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates an emoji.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function emoji<TInput extends string>(message?: ErrorMessage): EmojiValidation<TInput>;

/**
 * Ends with validation type.
 */
interface EndsWithValidation<TInput extends string, TRequirement extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'ends_with';
    /**
     * The end string.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the end of a string.
 *
 * @param requirement The end string.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function endsWith<TInput extends string, TRequirement extends string>(requirement: TRequirement, message?: ErrorMessage): EndsWithValidation<TInput, TRequirement>;

/**
 * Every validation type.
 */
interface EveryValidation<TInput extends any[]> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'every';
    /**
     * The validation function.
     */
    requirement: (element: TInput[number], index: number, array: TInput[number][]) => boolean;
}
/**
 * Creates a pipeline validation action that validates the items of an array.
 *
 * @param requirement The validation function.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function every<TInput extends any[]>(requirement: (element: TInput[number], index: number, array: TInput[number][]) => boolean, message?: ErrorMessage): EveryValidation<TInput>;

/**
 * Excludes validation type.
 */
interface ExcludesValidation<TInput extends string | any[], TRequirement extends TInput extends any[] ? TInput[number] : TInput> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'excludes';
    /**
     * The required value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the content of a string
 * or array.
 *
 * @param requirement The content to be excluded.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function excludes<TInput extends string | any[], const TRequirement extends TInput extends any[] ? TInput[number] : TInput>(requirement: TRequirement, message?: ErrorMessage): ExcludesValidation<TInput, TRequirement>;

/**
 * Finite validation type.
 */
interface FiniteValidation<TInput extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'finite';
    /**
     * The validation function.
     */
    requirement: (input: TInput) => boolean;
}
/**
 * Creates a pipeline validation action that validates whether a number is finite.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function finite<TInput extends number>(message?: ErrorMessage): FiniteValidation<TInput>;

/**
 * Hash lengths object.
 */
declare const HASH_LENGTHS: {
    readonly md4: 32;
    readonly md5: 32;
    readonly sha1: 40;
    readonly sha256: 64;
    readonly sha384: 96;
    readonly sha512: 128;
    readonly ripemd128: 32;
    readonly ripemd160: 40;
    readonly tiger128: 32;
    readonly tiger160: 40;
    readonly tiger192: 48;
    readonly crc32: 8;
    readonly crc32b: 8;
    readonly adler32: 8;
};
/**
 * Hash type type.
 */
type HashType = keyof typeof HASH_LENGTHS;
/**
 * Hash validation type.
 */
interface HashValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'hash';
    /**
     * The hash regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a hash.
 *
 * @param types The hash types.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function hash<TInput extends string>(types: [HashType, ...HashType[]], message?: ErrorMessage): HashValidation<TInput>;

/**
 * Hexadecimal validation type.
 */
interface HexadecimalValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'hexadecimal';
    /**
     * The hexadecimal regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function hexadecimal<TInput extends string>(message?: ErrorMessage): HexadecimalValidation<TInput>;

/**
 * Hex color validation type.
 */
interface HexColorValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'hex_color';
    /**
     * The hex color regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates hex color.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function hexColor<TInput extends string>(message?: ErrorMessage): HexColorValidation<TInput>;

/**
 * IMEI validation type.
 */
interface ImeiValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'imei';
    /**
     * The IMEI regex and luhn algorithm.
     */
    requirement: [RegExp, typeof isLuhnAlgo];
}
/**
 * Creates a pipeline validation action that validates an [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity).
 *
 * Format: AA-BBBBBB-CCCCCC-D
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function imei<TInput extends string>(message?: ErrorMessage): ImeiValidation<TInput>;

/**
 * Includes validation type.
 */
interface IncludesValidation<TInput extends string | any[], TRequirement extends TInput extends any[] ? TInput[number] : TInput> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'includes';
    /**
     * The required value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the content of a string
 * or array.
 *
 * @param requirement The content to be included.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function includes<TInput extends string | any[], const TRequirement extends TInput extends any[] ? TInput[number] : TInput>(requirement: TRequirement, message?: ErrorMessage): IncludesValidation<TInput, TRequirement>;

/**
 * Integer validation type.
 */
interface IntegerValidation<TInput extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'integer';
    /**
     * The validation function.
     */
    requirement: (input: TInput) => boolean;
}
/**
 * Creates a pipeline validation action that validates whether a number is an
 * integer.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function integer<TInput extends number>(message?: ErrorMessage): IntegerValidation<TInput>;

/**
 * IP validation type.
 */
interface IpValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'ip';
    /**
     * The IPv4 and IPv6 regex.
     */
    requirement: [RegExp, RegExp];
}
/**
 * Creates a pipeline validation action that validates an [IPv4](https://en.wikipedia.org/wiki/IPv4)
 * or [IPv6](https://en.wikipedia.org/wiki/IPv6) address.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function ip<TInput extends string>(message?: ErrorMessage): IpValidation<TInput>;

/**
 * IPv4 validation type.
 */
interface Ipv4Validation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'ipv4';
    /**
     * The IPv4 regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates an [IPv4](https://en.wikipedia.org/wiki/IPv4) address.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function ipv4<TInput extends string>(message?: ErrorMessage): Ipv4Validation<TInput>;

/**
 * IPv6 validation type.
 */
interface Ipv6Validation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'ipv6';
    /**
     * The IPv6 regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates an [IPv6](https://en.wikipedia.org/wiki/IPv6) address.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function ipv6<TInput extends string>(message?: ErrorMessage): Ipv6Validation<TInput>;

/**
 * ISO date validation type.
 */
interface IsoDateValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'iso_date';
    /**
     * The ISO date regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a date.
 *
 * Format: yyyy-mm-dd
 *
 * Hint: The regex used cannot validate the maximum number of days based on
 * year and month. For example, "2023-06-31" is valid although June has only
 * 30 days.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function isoDate<TInput extends string>(message?: ErrorMessage): IsoDateValidation<TInput>;

/**
 * ISO date time validation type.
 */
interface IsoDateTimeValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'iso_date_time';
    /**
     * The ISO date time regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a datetime.
 *
 * Format: yyyy-mm-ddThh:mm
 *
 * Hint: The regex used cannot validate the maximum number of days based on
 * year and month. For example, "2023-06-31T00:00" is valid although June has only
 * 30 days.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function isoDateTime<TInput extends string>(message?: ErrorMessage): IsoDateTimeValidation<TInput>;

/**
 * ISO time validation type.
 */
interface IsoTimeValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'iso_time';
    /**
     * The ISO time regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a time.
 *
 * Format: hh:mm
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function isoTime<TInput extends string>(message?: ErrorMessage): IsoTimeValidation<TInput>;

/**
 * ISO time second validation type.
 */
interface IsoTimeSecondValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'iso_time_second';
    /**
     * The ISO time second regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a time with seconds.
 *
 * Format: hh:mm:ss
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function isoTimeSecond<TInput extends string>(message?: ErrorMessage): IsoTimeSecondValidation<TInput>;

/**
 * ISO timestamp validation type.
 */
interface IsoTimestampValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'iso_timestamp';
    /**
     * The ISO timestamp regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a timestamp.
 *
 * Format: yyyy-mm-ddThh:mm:ss.sssZ
 *
 * Hint: To support timestamps with lower or higher accuracy, the millisecond
 * specification can be removed or contain up to 9 digits.
 *
 * Hint: The regex used cannot validate the maximum number of days based on
 * year and month. For example, "2023-06-31T00:00:00.000Z" is valid although
 * June has only 30 days.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function isoTimestamp<TInput extends string>(message?: ErrorMessage): IsoTimestampValidation<TInput>;

/**
 * ISO week validation type.
 */
interface IsoWeekValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'iso_week';
    /**
     * The ISO week regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a week.
 *
 * Format: yyyy-Www
 *
 * Hint: The regex used cannot validate the maximum number of weeks based on
 * the year. For example, "2021W53" is valid even though the year 2021 has only
 * 52 weeks.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function isoWeek<TInput extends string>(message?: ErrorMessage): IsoWeekValidation<TInput>;

/**
 * Length validation type.
 */
interface LengthValidation<TInput extends string | any[], TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'length';
    /**
     * The length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the length of a string
 * or array.
 *
 * @param requirement The length.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function length<TInput extends string | any[], TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): LengthValidation<TInput, TRequirement>;

/**
 * MAC validation type.
 */
interface MacValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'mac';
    /**
     * The 48-bit and 64-bit MAC regex.
     */
    requirement: [RegExp, RegExp];
}
/**
 * Creates a pipeline validation action that validates a [MAC address](https://en.wikipedia.org/wiki/MAC_address).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function mac<TInput extends string>(message?: ErrorMessage): MacValidation<TInput>;

/**
 * 48-bit MAC validation type.
 */
interface Mac48Validation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'mac48';
    /**
     * The 48-bit MAC regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a 48-bit [MAC address](https://en.wikipedia.org/wiki/MAC_address).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function mac48<TInput extends string>(message?: ErrorMessage): Mac48Validation<TInput>;

/**
 * 64-bit MAC validation type.
 */
interface Mac64Validation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'mac64';
    /**
     * The 64-bit MAC regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a 64-bit [MAC address](https://en.wikipedia.org/wiki/MAC_address).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function mac64<TInput extends string>(message?: ErrorMessage): Mac64Validation<TInput>;

/**
 * Max bytes validation type.
 */
interface MaxBytesValidation<TInput extends string, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'max_bytes';
    /**
     * The maximum byte length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the bytes of a string.
 *
 * @param requirement The maximum bytes.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function maxBytes<TInput extends string, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): MaxBytesValidation<TInput, TRequirement>;

/**
 * Max length validation type.
 */
interface MaxLengthValidation<TInput extends string | any[], TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'max_length';
    /**
     * The maximum length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the length of a string
 * or array.
 *
 * @param requirement The maximum length.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function maxLength<TInput extends string | any[], TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): MaxLengthValidation<TInput, TRequirement>;

/**
 * Max size validation type.
 */
interface MaxSizeValidation<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'max_size';
    /**
     * The maximum size.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the size of a map, set
 * or blob.
 *
 * @param requirement The maximum size.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function maxSize<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): MaxSizeValidation<TInput, TRequirement>;

/**
 * Max value validation type.
 */
interface MaxValueValidation<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'max_value';
    /**
     * The maximum value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the value of a string,
 * number, boolean or date.
 *
 * @param requirement The maximum value.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function maxValue<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput>(requirement: TRequirement, message?: ErrorMessage): MaxValueValidation<TInput, TRequirement>;

/**
 * Min bytes validation type.
 */
interface MinBytesValidation<TInput extends string, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'min_bytes';
    /**
     * The minimum byte length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the bytes of a string.
 *
 * @param requirement The minimum bytes.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function minBytes<TInput extends string, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): MinBytesValidation<TInput, TRequirement>;

/**
 * MIME type validation type.
 */
interface MimeTypeValidation<TInput extends Blob, TRequirement extends `${string}/${string}`[]> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'mime_type';
    /**
     * The MIME types.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the MIME type of a blob.
 *
 * @param requirement The MIME types.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function mimeType<TInput extends Blob, TRequirement extends `${string}/${string}`[]>(requirement: TRequirement, message?: ErrorMessage): MimeTypeValidation<TInput, TRequirement>;

/**
 * Min length validation type.
 */
interface MinLengthValidation<TInput extends string | any[], TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'min_length';
    /**
     * The minimum length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the length of a string
 * or array.
 *
 * @param requirement The minimum length.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function minLength<TInput extends string | any[], TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): MinLengthValidation<TInput, TRequirement>;

/**
 * Min size validation type.
 */
interface MinSizeValidation<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'min_size';
    /**
     * The minimum size.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the size of a map, set
 * or blob.
 *
 * @param requirement The minimum size.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function minSize<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): MinSizeValidation<TInput, TRequirement>;

/**
 * Min value validation type.
 */
interface MinValueValidation<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'min_value';
    /**
     * The minimum value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the value of a string,
 * number or date.
 *
 * @param requirement The minimum value.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function minValue<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput>(requirement: TRequirement, message?: ErrorMessage): MinValueValidation<TInput, TRequirement>;

/**
 * Multiple of validation type.
 */
interface MultipleOfValidation<TInput extends number, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'multiple_of';
    /**
     * The divisor.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates whether a number is a
 * multiple.
 *
 * @param requirement The divisor.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function multipleOf<TInput extends number, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): MultipleOfValidation<TInput, TRequirement>;

/**
 * Not bytes validation type.
 */
interface NotBytesValidation<TInput extends string, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'not_bytes';
    /**
     * The byte length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the bytes of a string.
 *
 * @param requirement The bytes.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function notBytes<TInput extends string, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): NotBytesValidation<TInput, TRequirement>;

/**
 * Not length validation type.
 */
interface NotLengthValidation<TInput extends string | any[], TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'not_length';
    /**
     * The length.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the length of a string
 * or array.
 *
 * @param requirement The length.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function notLength<TInput extends string | any[], TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): NotLengthValidation<TInput, TRequirement>;

/**
 * Not size validation type.
 */
interface NotSizeValidation<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'not_size';
    /**
     * The size.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the size of a map, set
 * or blob.
 *
 * @param requirement The size.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function notSize<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): NotSizeValidation<TInput, TRequirement>;

/**
 * Not value validation type.
 */
interface NotValueValidation<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'not_value';
    /**
     * The value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the value of a string
 * or number.
 *
 * @param requirement The value.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function notValue<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput>(requirement: TRequirement, message?: ErrorMessage): NotValueValidation<TInput, TRequirement>;

/**
 * Octal validation type.
 */
interface OctalValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'octal';
    /**
     * The octal regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates an [octal](https://en.wikipedia.org/wiki/Octal).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function octal<TInput extends string>(message?: ErrorMessage): OctalValidation<TInput>;

/**
 * Regex validation type.
 */
interface RegexValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'regex';
    /**
     * The regex pattern.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a string with a regex.
 *
 * @param requirement The regex pattern.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function regex<TInput extends string>(requirement: RegExp, message?: ErrorMessage): RegexValidation<TInput>;

/**
 * Safe integer validation type.
 */
interface SafeIntegerValidation<TInput extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'safe_integer';
    /**
     * The validation function.
     */
    requirement: (input: TInput) => boolean;
}
/**
 * Creates a pipeline validation action that validates whether a number is a
 * safe integer.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function safeInteger<TInput extends number>(message?: ErrorMessage): SafeIntegerValidation<TInput>;

/**
 * Size validation type.
 */
interface SizeValidation<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'size';
    /**
     * The size.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the size of a map, set
 * or blob.
 *
 * @param requirement The size.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function size<TInput extends Map<any, any> | Set<any> | Blob, TRequirement extends number>(requirement: TRequirement, message?: ErrorMessage): SizeValidation<TInput, TRequirement>;

/**
 * Some validation type.
 */
interface SomeValidation<TInput extends any[]> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'some';
    /**
     * The validation function.
     */
    requirement: (element: TInput[number], index: number, array: TInput[number][]) => boolean;
}
/**
 * Creates a pipeline validation action that validates the items of an array.
 *
 * @param requirement The validation function.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function some<TInput extends any[]>(requirement: (element: TInput[number], index: number, array: TInput[number][]) => boolean, message?: ErrorMessage): SomeValidation<TInput>;

/**
 * Starts with validation type.
 */
interface StartsWithValidation<TInput extends string, TRequirement extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'starts_with';
    /**
     * The start string.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the start of a string.
 *
 * @param requirement The start string.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function startsWith<TInput extends string, TRequirement extends string>(requirement: TRequirement, message?: ErrorMessage): StartsWithValidation<TInput, TRequirement>;

/**
 * ULID validation type.
 */
interface UlidValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'ulid';
    /**
     * The ULID regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a [ULID](https://github.com/ulid/spec).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function ulid<TInput extends string>(message?: ErrorMessage): UlidValidation<TInput>;

/**
 * URL validation type.
 */
interface UrlValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'url';
    /**
     * The validation function.
     */
    requirement: (input: TInput) => boolean;
}
/**
 * Creates a pipeline validation action that validates a URL.
 *
 * Hint: The value is passed to the URL constructor to check if it is valid.
 * This check is not perfect. For example, values like "abc:1234" are accepted.
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function url<TInput extends string>(message?: ErrorMessage): UrlValidation<TInput>;

/**
 * UUID validation type.
 */
interface UuidValidation<TInput extends string> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'uuid';
    /**
     * The UUID regex.
     */
    requirement: RegExp;
}
/**
 * Creates a pipeline validation action that validates a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
 *
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function uuid<TInput extends string>(message?: ErrorMessage): UuidValidation<TInput>;

/**
 * Value validation type.
 */
interface ValueValidation<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput> extends BaseValidation<TInput> {
    /**
     * The validation type.
     */
    type: 'value';
    /**
     * The value.
     */
    requirement: TRequirement;
}
/**
 * Creates a pipeline validation action that validates the value of a string
 * or number.
 *
 * @param requirement The value.
 * @param message The error message.
 *
 * @returns A validation action.
 */
declare function value<TInput extends string | number | bigint | boolean | Date, TRequirement extends TInput>(requirement: TRequirement, message?: ErrorMessage): ValueValidation<TInput, TRequirement>;

export { type AnySchema, type AnySchemaAsync, type ArrayPathItem, type ArraySchema, type ArraySchemaAsync, BIC_REGEX, type BaseSchema, type BaseSchemaAsync, type BaseTransformation, type BaseTransformationAsync, type BaseValidation, type BaseValidationAsync, type BicValidation, type BigintSchema, type BigintSchemaAsync, type BlobSchema, type BlobSchemaAsync, type BooleanSchema, type BooleanSchemaAsync, type Brand, type BrandName, BrandSymbol, type BytesValidation, CUID2_REGEX, type Class, type CreditCardValidation, type Cuid2Validation, type CustomValidation, type CustomValidationAsync, DECIMAL_REGEX, type DateSchema, type DateSchemaAsync, type DecimalValidation, type Default, type DefaultAsync, type DefaultValue, type DefaultValues, EMAIL_REGEX, EMOJI_REGEX, type EmailValidation, type EmojiValidation, type EndsWithValidation, type Enum, type EnumSchema, type EnumSchemaAsync, type ErrorMessage, type EveryValidation, type ExcludesValidation, type Fallback, type FallbackAsync, type FallbackInfo, type FallbackValue, type FallbackValues, type FiniteValidation, type FlatErrors, type GlobalConfig, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, type HashType, type HashValidation, type HexColorValidation, type HexadecimalValidation, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, type ImeiValidation, type IncludesValidation, type Input, type InstanceSchema, type InstanceSchemaAsync, type IntegerValidation, type IntersectOptions, type IntersectOptionsAsync, type IntersectSchema, type IntersectSchemaAsync, type InvalidActionResult, type IpValidation, type Ipv4Validation, type Ipv6Validation, type IsoDateTimeValidation, type IsoDateValidation, type IsoTimeSecondValidation, type IsoTimeValidation, type IsoTimestampValidation, type IsoWeekValidation, type IssuePath, type IssueReason, type LazySchema, type LazySchemaAsync, type LengthValidation, type Literal, type LiteralSchema, type LiteralSchemaAsync, MAC48_REGEX, MAC64_REGEX, type Mac48Validation, type Mac64Validation, type MacValidation, type MapInput, type MapOutput, type MapPathItem, type MapSchema, type MapSchemaAsync, type MaxBytesValidation, type MaxLengthValidation, type MaxSizeValidation, type MaxValueValidation, type MaybePromise, type MaybeReadonly, type MimeTypeValidation, type MinBytesValidation, type MinLengthValidation, type MinSizeValidation, type MinValueValidation, type MultipleOfValidation, type NanSchema, type NanSchemaAsync, type NeverSchema, type NeverSchemaAsync, type NonNullableInput, type NonNullableOutput, type NonNullableSchema, type NonNullableSchemaAsync, type NonNullishInput, type NonNullishOutput, type NonNullishSchema, type NonNullishSchemaAsync, type NonOptionalInput, type NonOptionalOutput, type NonOptionalSchema, type NonOptionalSchemaAsync, type NotBytesValidation, type NotLengthValidation, type NotSizeValidation, type NotValueValidation, type NullSchema, type NullSchemaAsync, type NullableSchema, type NullableSchemaAsync, type NullishSchema, type NullishSchemaAsync, type NumberSchema, type NumberSchemaAsync, OCTAL_REGEX, type ObjectEntries, type ObjectEntriesAsync, type ObjectInput, type ObjectKeys, type ObjectOutput, type ObjectPathItem, type ObjectSchema, type ObjectSchemaAsync, type OctalValidation, type OptionalSchema, type OptionalSchemaAsync, type Output, type PartialObjectEntries, type PartialObjectEntriesAsync, type PathItem, type PathList, type PicklistOptions, type PicklistSchema, type PicklistSchemaAsync, type Pipe, type PipeActionContext, type PipeActionIssue, type PipeActionIssues, type PipeActionResult, type PipeAsync, type RecordInput, type RecordKey, type RecordKeyAsync, type RecordOutput, type RecordPathItem, type RecordSchema, type RecordSchemaAsync, type RegexValidation, type ResolveObject, type SafeIntegerValidation, type SafeParseResult, type SchemaConfig, type SchemaIssue, type SchemaIssues, type SchemaResult, type SchemaWithBrand, type SchemaWithFallback, type SchemaWithFallbackAsync, type SchemaWithMaybeDefault, type SchemaWithMaybeDefaultAsync, type SchemaWithMaybeFallback, type SchemaWithMaybeFallbackAsync, type SchemaWithTransform, type SchemaWithTransformAsync, type SetInput, type SetOutput, type SetPathItem, type SetSchema, type SetSchemaAsync, type SizeValidation, type SomeValidation, type SpecialSchema, type SpecialSchemaAsync, type StartsWithValidation, type StringSchema, type StringSchemaAsync, type SymbolSchema, type SymbolSchemaAsync, type ToCustomTransformation, type ToCustomTransformationAsync, type ToLowerCaseTransformation, type ToMaxValueTransformation, type ToMinValueTransformation, type ToTrimmedEndTransformation, type ToTrimmedStartTransformation, type ToTrimmedTransformation, type ToUpperCaseTransformation, type TupleInput, type TupleItems, type TupleItemsAsync, type TupleOutput, type TuplePathItem, type TupleSchema, type TupleSchemaAsync, type TypedSchemaResult, ULID_REGEX, UUID_REGEX, type UlidValidation, type UndefinedSchema, type UndefinedSchemaAsync, type UnionOptions, type UnionOptionsAsync, type UnionSchema, type UnionSchemaAsync, type UnknownPathItem, type UnknownSchema, type UnknownSchemaAsync, type UntypedSchemaResult, type UrlValidation, type UuidValidation, ValiError, type ValidActionResult, type ValueValidation, type VariantOption, type VariantOptionAsync, type VariantOptions, type VariantOptionsAsync, type VariantSchema, type VariantSchemaAsync, type VoidSchema, type VoidSchemaAsync, actionIssue, actionOutput, any, anyAsync, array, arrayAsync, bic, bigint, bigintAsync, blob, blobAsync, boolean, booleanAsync, brand, bytes, coerce, coerceAsync, creditCard, cuid2, custom, customAsync, date, dateAsync, decimal, defaultArgs, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, email, emoji, endsWith, enumAsync, enum_, every, excludes, fallback, fallbackAsync, finite, flatten, forward, forwardAsync, getDefault, getDefaultAsync, getDefaults, getDefaultsAsync, getFallback, getFallbackAsync, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getSchemaMessage, getSpecificMessage, hash, hexColor, hexadecimal, i18n, imei, includes, instance, instanceAsync, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isLuhnAlgo, isOfType, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, literalAsync, mac, mac48, mac64, map, mapAsync, maxBytes, maxLength, maxSize, maxValue, merge, mergeAsync, mimeType, minBytes, minLength, minSize, minValue, multipleOf, nan, nanAsync, never, neverAsync, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, notBytes, notLength, notSize, notValue, nullAsync, null_, nullable, nullableAsync, nullish, nullishAsync, number, numberAsync, object, objectAsync, octal, omit, omitAsync, optional, optionalAsync, parse, parseAsync, partial, partialAsync, pick, pickAsync, picklist, picklistAsync, pipeResult, pipeResultAsync, record, recordAsync, regex, required, requiredAsync, restAndDefaultArgs, safeInteger, safeParse, safeParseAsync, schemaIssue, schemaResult, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, some, special, specialAsync, startsWith, string, stringAsync, stringify, symbol, symbolAsync, toCustom, toCustomAsync, toLowerCase, toMaxValue, toMinValue, toTrimmed, toTrimmedEnd, toTrimmedStart, toUpperCase, transform, transformAsync, tuple, tupleAsync, ulid, undefinedAsync, undefined_, union, unionAsync, unknown, unknownAsync, unwrap, url, uuid, value, variant, variantAsync, voidAsync, void_ };
