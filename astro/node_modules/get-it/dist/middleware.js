import { Agent } from "http";
import { Agent as Agent$1 } from "https";
import { getDefaultExportFromCjs } from "./_chunks-es/_commonjsHelpers.js";
import require$$0 from "tty";
import require$$1 from "util";
import { processOptions, validateOptions } from "./_chunks-es/defaultOptionsValidator.js";
import progressStream from "progress-stream";
import allowed from "is-retry-allowed";
const isHttpsProto = /^https:/i;
function agent(opts) {
  const httpAgent = new Agent(opts), httpsAgent = new Agent$1(opts), agents = { http: httpAgent, https: httpsAgent };
  return {
    finalizeOptions: (options) => {
      if (options.agent)
        return options;
      if (options.maxRedirects > 0)
        return { ...options, agents };
      const isHttps = isHttpsProto.test(options.href || options.protocol);
      return { ...options, agent: isHttps ? httpsAgent : httpAgent };
    }
  };
}
const leadingSlash = /^\//, trailingSlash = /\/$/;
function base(baseUrl) {
  const baseUri = baseUrl.replace(trailingSlash, "");
  return {
    processOptions: (options) => {
      if (/^https?:\/\//i.test(options.url))
        return options;
      const url = [baseUri, options.url.replace(leadingSlash, "")].join("/");
      return Object.assign({}, options, { url });
    }
  };
}
var src = { exports: {} }, browser$1 = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0)
      return parse(val);
    if (type === "number" && isFinite(val))
      return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse(str) {
    if (str = String(str), !(str.length > 100)) {
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (match) {
        var n = parseFloat(match[1]), type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return;
        }
      }
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    return msAbs >= d ? Math.round(ms2 / d) + "d" : msAbs >= h ? Math.round(ms2 / h) + "h" : msAbs >= m ? Math.round(ms2 / m) + "m" : msAbs >= s ? Math.round(ms2 / s) + "s" : ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    return msAbs >= d ? plural(ms2, msAbs, d, "day") : msAbs >= h ? plural(ms2, msAbs, h, "hour") : msAbs >= m ? plural(ms2, msAbs, m, "minute") : msAbs >= s ? plural(ms2, msAbs, s, "second") : ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = requireMs(), createDebug.destroy = destroy, Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++)
        hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime, enableOverride = null, namespacesCache, enabledCache;
      function debug2(...args) {
        if (!debug2.enabled)
          return;
        const self2 = debug2, curr = Number(/* @__PURE__ */ new Date()), ms2 = curr - (prevTime || curr);
        self2.diff = ms2, self2.prev = prevTime, self2.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%")
            return "%";
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter == "function") {
            const val = args[index];
            match = formatter.call(self2, val), args.splice(index, 1), index--;
          }
          return match;
        }), createDebug.formatArgs.call(self2, args), (self2.log || createDebug.log).apply(self2, args);
      }
      return debug2.namespace = namespace, debug2.useColors = createDebug.useColors(), debug2.color = createDebug.selectColor(namespace), debug2.extend = extend, debug2.destroy = createDebug.destroy, Object.defineProperty(debug2, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache),
        set: (v) => {
          enableOverride = v;
        }
      }), typeof createDebug.init == "function" && createDebug.init(debug2), debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter > "u" ? ":" : delimiter) + namespace);
      return newDebug.log = this.log, newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
      let i;
      const split = (typeof namespaces == "string" ? namespaces : "").split(/[\s,]+/), len = split.length;
      for (i = 0; i < len; i++)
        split[i] && (namespaces = split[i].replace(/\*/g, ".*?"), namespaces[0] === "-" ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      return createDebug.enable(""), namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*")
        return !0;
      let i, len;
      for (i = 0, len = createDebug.skips.length; i < len; i++)
        if (createDebug.skips[i].test(name))
          return !1;
      for (i = 0, len = createDebug.names.length; i < len; i++)
        if (createDebug.names[i].test(name))
          return !0;
      return !1;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      return val instanceof Error ? val.stack || val.message : val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return createDebug.enable(createDebug.load()), createDebug;
  }
  return common = setup, common;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(module, exports) {
    exports.formatArgs = formatArgs, exports.save = save, exports.load = load, exports.useColors = useColors, exports.storage = localstorage(), exports.destroy = /* @__PURE__ */ (() => {
      let warned = !1;
      return () => {
        warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), !this.useColors)
        return;
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0, lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        match !== "%%" && (index++, match === "%c" && (lastC = index));
      }), args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
      } catch {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch {
      }
      return !r && typeof process < "u" && "env" in process && (r = process.env.DEBUG), r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }(browser$1, browser$1.exports)), browser$1.exports;
}
var node = { exports: {} }, browser, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  function getChromeVersion() {
    const matches = /(Chrome|Chromium)\/(?<chromeVersion>\d+)\./.exec(navigator.userAgent);
    if (matches)
      return Number.parseInt(matches.groups.chromeVersion, 10);
  }
  const colorSupport = getChromeVersion() >= 69 ? {
    level: 1,
    hasBasic: !0,
    has256: !1,
    has16m: !1
  } : !1;
  return browser = {
    stdout: colorSupport,
    stderr: colorSupport
  }, browser;
}
var hasRequiredNode;
function requireNode() {
  return hasRequiredNode || (hasRequiredNode = 1, function(module, exports) {
    const tty = require$$0, util = require$$1;
    exports.init = init, exports.log = log, exports.formatArgs = formatArgs, exports.save = save, exports.load = load, exports.useColors = useColors, exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireBrowser();
      supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => /^debug_/i.test(key)).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase());
      let val = process.env[key];
      return /^(yes|on|true|enabled)$/i.test(val) ? val = !0 : /^(no|off|false|disabled)$/i.test(val) ? val = !1 : val === "null" ? val = null : val = Number(val), obj[prop] = val, obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? !!exports.inspectOpts.colors : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color, colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split(`
`).join(`
` + prefix), args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else
        args[0] = getDate() + name + " " + args[0];
    }
    function getDate() {
      return exports.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + `
`);
    }
    function save(namespaces) {
      namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++)
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
    }, formatters.O = function(v) {
      return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
    };
  }(node, node.exports)), node.exports;
}
typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? src.exports = requireBrowser$1() : src.exports = requireNode();
var srcExports = src.exports, debugIt = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
const SENSITIVE_HEADERS = ["cookie", "authorization"], hasOwn = Object.prototype.hasOwnProperty, redactKeys = (source, redacted) => {
  const target = {};
  for (const key in source)
    hasOwn.call(source, key) && (target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? "<redacted>" : source[key]);
  return target;
};
function debug(opts = {}) {
  const verbose = opts.verbose, namespace = opts.namespace || "get-it", defaultLogger = debugIt(namespace), log = opts.log || defaultLogger, shortCircuit = log === defaultLogger && !debugIt.enabled(namespace);
  let requestId = 0;
  return {
    processOptions: (options) => (options.debug = log, options.requestId = options.requestId || ++requestId, options),
    onRequest: (event) => {
      if (shortCircuit || !event)
        return event;
      const options = event.options;
      if (log("[%s] HTTP %s %s", options.requestId, options.method, options.url), verbose && options.body && typeof options.body == "string" && log("[%s] Request body: %s", options.requestId, options.body), verbose && options.headers) {
        const headers2 = opts.redactSensitiveHeaders === !1 ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);
        log("[%s] Request headers: %s", options.requestId, JSON.stringify(headers2, null, 2));
      }
      return event;
    },
    onResponse: (res, context) => {
      if (shortCircuit || !res)
        return res;
      const reqId = context.options.requestId;
      return log("[%s] Response code: %s %s", reqId, res.statusCode, res.statusMessage), verbose && res.body && log("[%s] Response body: %s", reqId, stringifyBody(res)), res;
    },
    onError: (err, context) => {
      const reqId = context.options.requestId;
      return err ? (log("[%s] ERROR: %s", reqId, err.message), err) : (log("[%s] Error encountered, but handled by an earlier middleware", reqId), err);
    }
  };
}
function stringifyBody(res) {
  return (res.headers["content-type"] || "").toLowerCase().indexOf("application/json") !== -1 ? tryFormat(res.body) : res.body;
}
function tryFormat(body) {
  try {
    const parsed = typeof body == "string" ? JSON.parse(body) : body;
    return JSON.stringify(parsed, null, 2);
  } catch {
    return body;
  }
}
function headers(_headers, opts = {}) {
  return {
    processOptions: (options) => {
      const existing = options.headers || {};
      return options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing), options;
    }
  };
}
var __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => (__defNormalProp$1(obj, typeof key != "symbol" ? key + "" : key, value), value);
class HttpError extends Error {
  constructor(res, ctx) {
    super(), __publicField$1(this, "response"), __publicField$1(this, "request");
    const truncatedUrl = res.url.length > 400 ? `${res.url.slice(0, 399)}\u2026` : res.url;
    let msg = `${res.method}-request to ${truncatedUrl} resulted in `;
    msg += `HTTP ${res.statusCode} ${res.statusMessage}`, this.message = msg.trim(), this.response = res, this.request = ctx.options;
  }
}
function httpErrors() {
  return {
    onResponse: (res, ctx) => {
      if (!(res.statusCode >= 400))
        return res;
      throw new HttpError(res, ctx);
    }
  };
}
function injectResponse(opts = {}) {
  if (typeof opts.inject != "function")
    throw new Error("`injectResponse` middleware requires a `inject` function");
  return { interceptRequest: function(prevValue, event) {
    const response = opts.inject(event, prevValue);
    if (!response)
      return prevValue;
    const options = event.context.options;
    return {
      body: "",
      url: options.url,
      method: options.method,
      headers: {},
      statusCode: 200,
      statusMessage: "OK",
      ...response
    };
  } };
}
const isBuffer = typeof Buffer > "u" ? () => !1 : (obj) => Buffer.isBuffer(obj);
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  if (isObject(o) === !1)
    return !1;
  const ctor = o.constructor;
  if (ctor === void 0)
    return !0;
  const prot = ctor.prototype;
  return !(isObject(prot) === !1 || // eslint-disable-next-line no-prototype-builtins
  prot.hasOwnProperty("isPrototypeOf") === !1);
}
const serializeTypes = ["boolean", "string", "number"];
function jsonRequest() {
  return {
    processOptions: (options) => {
      const body = options.body;
      return !body || !(typeof body.pipe != "function" && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject(body))) ? options : Object.assign({}, options, {
        body: JSON.stringify(options.body),
        headers: Object.assign({}, options.headers, {
          "Content-Type": "application/json"
        })
      });
    }
  };
}
function jsonResponse(opts) {
  return {
    onResponse: (response) => {
      const contentType = response.headers["content-type"] || "", shouldDecode = opts && opts.force || contentType.indexOf("application/json") !== -1;
      return !response.body || !contentType || !shouldDecode ? response : Object.assign({}, response, { body: tryParse(response.body) });
    },
    processOptions: (options) => Object.assign({}, options, {
      headers: Object.assign({ Accept: "application/json" }, options.headers)
    })
  };
  function tryParse(body) {
    try {
      return JSON.parse(body);
    } catch (err) {
      throw err.message = `Failed to parsed response body as JSON: ${err.message}`, err;
    }
  }
}
function isBrowserOptions(options) {
  return typeof options == "object" && options !== null && !("protocol" in options);
}
function mtls(config = {}) {
  if (!config.ca)
    throw new Error('Required mtls option "ca" is missing');
  if (!config.cert)
    throw new Error('Required mtls option "cert" is missing');
  if (!config.key)
    throw new Error('Required mtls option "key" is missing');
  return {
    finalizeOptions: (options) => {
      if (isBrowserOptions(options))
        return options;
      const mtlsOpts = {
        cert: config.cert,
        key: config.key,
        ca: config.ca
      };
      return Object.assign({}, options, mtlsOpts);
    }
  };
}
let actualGlobal = {};
typeof globalThis < "u" ? actualGlobal = globalThis : typeof window < "u" ? actualGlobal = window : typeof global < "u" ? actualGlobal = global : typeof self < "u" && (actualGlobal = self);
var global$1 = actualGlobal;
function observable(opts = {}) {
  const Observable = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track
    opts.implementation || global$1.Observable
  );
  if (!Observable)
    throw new Error(
      "`Observable` is not available in global scope, and no implementation was passed"
    );
  return {
    onReturn: (channels, context) => new Observable((observer) => (channels.error.subscribe((err) => observer.error(err)), channels.progress.subscribe(
      (event) => observer.next(Object.assign({ type: "progress" }, event))
    ), channels.response.subscribe((response) => {
      observer.next(Object.assign({ type: "response" }, response)), observer.complete();
    }), channels.request.publish(context), () => channels.abort.publish()))
  };
}
function normalizer(stage) {
  return (prog) => ({
    stage,
    percent: prog.percentage,
    total: prog.length,
    loaded: prog.transferred,
    lengthComputable: !(prog.length === 0 && prog.percentage === 0)
  });
}
function progress() {
  return {
    onHeaders: (response, evt) => {
      const _progress = progressStream({ time: 16 }), normalize = normalizer("download"), contentLength = response.headers["content-length"], length = contentLength ? Number(contentLength) : 0;
      return !isNaN(length) && length > 0 && _progress.setLength(length), _progress.on("progress", (prog) => evt.context.channels.progress.publish(normalize(prog))), response.pipe(_progress);
    },
    onRequest: (evt) => {
      if (!evt.progress)
        return;
      const normalize = normalizer("upload");
      evt.progress.on(
        "progress",
        (prog) => evt.context.channels.progress.publish(normalize(prog))
      );
    }
  };
}
var __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), value);
const promise = (options = {}) => {
  const PromiseImplementation = options.implementation || Promise;
  if (!PromiseImplementation)
    throw new Error("`Promise` is not available in global scope, and no implementation was passed");
  return {
    onReturn: (channels, context) => new PromiseImplementation((resolve, reject) => {
      const cancel = context.options.cancelToken;
      cancel && cancel.promise.then((reason) => {
        channels.abort.publish(reason), reject(reason);
      }), channels.error.subscribe(reject), channels.response.subscribe((response) => {
        resolve(options.onlyBody ? response.body : response);
      }), setTimeout(() => {
        try {
          channels.request.publish(context);
        } catch (err) {
          reject(err);
        }
      }, 0);
    })
  };
};
class Cancel {
  constructor(message) {
    __publicField(this, "__CANCEL__", !0), __publicField(this, "message"), this.message = message;
  }
  toString() {
    return `Cancel${this.message ? `: ${this.message}` : ""}`;
  }
}
const _CancelToken = class {
  constructor(executor) {
    if (__publicField(this, "promise"), __publicField(this, "reason"), typeof executor != "function")
      throw new TypeError("executor must be a function.");
    let resolvePromise = null;
    this.promise = new Promise((resolve) => {
      resolvePromise = resolve;
    }), executor((message) => {
      this.reason || (this.reason = new Cancel(message), resolvePromise(this.reason));
    });
  }
};
__publicField(_CancelToken, "source", () => {
  let cancel;
  return {
    token: new _CancelToken((can) => {
      cancel = can;
    }),
    cancel
  };
});
let CancelToken = _CancelToken;
const isCancel = (value) => !!(value && value != null && value.__CANCEL__);
promise.Cancel = Cancel;
promise.CancelToken = CancelToken;
promise.isCancel = isCancel;
function proxy(_proxy) {
  if (_proxy !== !1 && (!_proxy || !_proxy.host))
    throw new Error("Proxy middleware takes an object of host, port and auth properties");
  return {
    processOptions: (options) => Object.assign({ proxy: _proxy }, options)
  };
}
var defaultShouldRetry = (err, _num, options) => options.method !== "GET" && options.method !== "HEAD" || err.response && err.response.statusCode ? !1 : allowed(err);
const isStream = (stream) => stream !== null && typeof stream == "object" && typeof stream.pipe == "function";
var sharedRetry = (opts) => {
  const maxRetries = opts.maxRetries || 5, retryDelay = opts.retryDelay || getRetryDelay, allowRetry = opts.shouldRetry;
  return {
    onError: (err, context) => {
      const options = context.options, max = options.maxRetries || maxRetries, delay = options.retryDelay || retryDelay, shouldRetry = options.shouldRetry || allowRetry, attemptNumber = options.attemptNumber || 0;
      if (isStream(options.body) || !shouldRetry(err, attemptNumber, options) || attemptNumber >= max)
        return err;
      const newContext = Object.assign({}, context, {
        options: Object.assign({}, options, { attemptNumber: attemptNumber + 1 })
      });
      return setTimeout(() => context.channels.request.publish(newContext), delay(attemptNumber)), null;
    }
  };
};
function getRetryDelay(attemptNum) {
  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;
}
const retry = (opts = {}) => sharedRetry({ shouldRetry: defaultShouldRetry, ...opts });
retry.shouldRetry = defaultShouldRetry;
function encode(data) {
  const query = new URLSearchParams(), nest = (name, _value) => {
    const value = _value instanceof Set ? Array.from(_value) : _value;
    if (Array.isArray(value))
      if (value.length)
        for (const index in value)
          nest(`${name}[${index}]`, value[index]);
      else
        query.append(`${name}[]`, "");
    else if (typeof value == "object" && value !== null)
      for (const [key, obj] of Object.entries(value))
        nest(`${name}[${key}]`, obj);
    else
      query.append(name, value);
  };
  for (const [key, value] of Object.entries(data))
    nest(key, value);
  return query.toString();
}
function urlEncoded() {
  return {
    processOptions: (options) => {
      const body = options.body;
      return !body || !(typeof body.pipe != "function" && !isBuffer(body) && isPlainObject(body)) ? options : {
        ...options,
        body: encode(options.body),
        headers: {
          ...options.headers,
          "Content-Type": "application/x-www-form-urlencoded"
        }
      };
    }
  };
}
function buildKeepAlive(agent2) {
  return function(config = {}) {
    const ms2 = config.ms || 1e3, maxFree = config.maxFree || 256;
    return agent2({
      keepAlive: !0,
      keepAliveMsecs: ms2,
      maxFreeSockets: maxFree
    });
  };
}
const keepAlive = buildKeepAlive(agent);
export {
  Cancel,
  CancelToken,
  agent,
  base,
  debug,
  headers,
  httpErrors,
  injectResponse,
  jsonRequest,
  jsonResponse,
  keepAlive,
  mtls,
  observable,
  processOptions,
  progress,
  promise,
  proxy,
  retry,
  urlEncoded,
  validateOptions
};
//# sourceMappingURL=middleware.js.map
