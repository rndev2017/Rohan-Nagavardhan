/// <reference types="node" />

import {AgentOptions} from 'http'
import {FinalizeNodeOptionsPayload} from 'get-it'
import {HookOnRequestEvent} from 'get-it'
import {HttpContext} from 'get-it'
import {IncomingHttpHeaders} from 'http'
import {IncomingMessage} from 'http'
import {MiddlewareChannels} from 'get-it'
import type {MiddlewareHooks} from 'get-it'
import {MiddlewareResponse} from 'get-it'
import progressStream from 'progress-stream'
import {RequestAdapter} from 'get-it'
import {RequestOptions} from 'get-it'
import type {RetryOptions} from 'get-it'

/**
 * Constructs a http.Agent and uses it for all requests.
 * This can be used to override settings such as `maxSockets`, `maxTotalSockets` (to limit concurrency) or change the `timeout`.
 * @public
 */
export declare function agent(opts?: AgentOptions): any

/** @public */
export declare function base(baseUrl: string): {
  processOptions: (options: RequestOptions) => RequestOptions
}

/**
 * The cancel token API is based on the [cancelable promises proposal](https://github.com/tc39/proposal-cancelable-promises), which is currently at Stage 1.
 *
 * Code shamelessly stolen/borrowed from MIT-licensed [axios](https://github.com/mzabriskie/axios). Thanks to [Nick Uraltsev](https://github.com/nickuraltsev), [Matt Zabriskie](https://github.com/mzabriskie) and the other contributors of that project!
 */
/** @public */
export declare class Cancel {
  __CANCEL__: boolean
  message: string | undefined
  constructor(message: string | undefined)
  toString(): string
}

/** @public */
export declare class CancelToken {
  promise: Promise<any>
  reason?: Cancel
  constructor(executor: (cb: (message?: string) => void) => void)
  static source: () => {
    token: CancelToken
    cancel: (message?: string) => void
  }
}

/** @public */
declare function debug_2(opts?: any): {
  processOptions: (options: RequestOptions) => RequestOptions
  onRequest: (event: HookOnRequestEvent) => HookOnRequestEvent
  onResponse: (res: MiddlewareResponse, context: HttpContext) => MiddlewareResponse
  onError: (err: Error | null, context: HttpContext) => Error | null
}
export {debug_2 as debug}

/** @public */
export declare function headers(
  _headers: any,
  opts?: any,
): {
  processOptions: (options: RequestOptions) => RequestOptions
}

/** @public */
export declare function httpErrors(): {
  onResponse: (res: MiddlewareResponse, ctx: HttpContext) => MiddlewareResponse
}

/** @public */
export declare function injectResponse(opts?: {
  inject: (
    event: Parameters<MiddlewareHooks['interceptRequest']>[1],
    prevValue: Parameters<MiddlewareHooks['interceptRequest']>[0],
  ) => Partial<MiddlewareResponse | undefined | void>
}): {
  interceptRequest: (
    prevValue: MiddlewareResponse | undefined,
    event: {
      adapter: RequestAdapter
      context: HttpContext
    },
  ) => MiddlewareResponse | undefined
}

/** @public */
export declare function jsonRequest(): {
  processOptions: (options: RequestOptions) => RequestOptions
}

/** @public */
export declare function jsonResponse(opts?: any): {
  onResponse: (response: MiddlewareResponse) => MiddlewareResponse
  processOptions: (options: RequestOptions) => RequestOptions & {
    headers: any
  }
}

/** @public */
export declare const keepAlive: (config?: any) => any

/** @public */
export declare function mtls(config?: any): {
  finalizeOptions: (options: RequestOptions | FinalizeNodeOptionsPayload) =>
    | RequestOptions
    | (FinalizeNodeOptionsPayload & {
        cert: any
        key: any
        ca: any
      })
}

/** @public */
export declare function observable(opts?: {implementation?: any}): {
  onReturn: (channels: MiddlewareChannels, context: HttpContext) => any
}

/** @public */
export declare const processOptions: (opts: RequestOptions) => {
  url: string
  body?: any
  bodySize?: number | undefined
  cancelToken?: any
  compress?: boolean | undefined
  headers?: any
  maxRedirects?: number | undefined
  maxRetries?: number | undefined
  retryDelay?: ((attemptNumber: number) => number) | undefined
  method?: string | undefined
  proxy?: any
  query?: any
  rawBody?: boolean | undefined
  shouldRetry?: any
  stream?: boolean | undefined
  timeout: any
  tunnel?: boolean | undefined
  debug?: any
  requestId?: number | undefined
  attemptNumber?: number | undefined
  withCredentials?: boolean | undefined
  fetch?: boolean | Omit<RequestInit, 'method'> | undefined
  useAbortSignal?: boolean | undefined
}

/** @public */
export declare function progress(): {
  onHeaders: (
    response: IncomingMessage,
    evt: {
      headers: IncomingHttpHeaders
      adapter: RequestAdapter
      context: HttpContext
    },
  ) => progressStream.ProgressStream
  onRequest: (evt: HookOnRequestEvent) => void
}

/** @public */
export declare const promise: {
  (options?: {onlyBody?: boolean; implementation?: PromiseConstructor}): {
    onReturn: (channels: MiddlewareChannels, context: HttpContext) => Promise<unknown>
  }
  Cancel: typeof Cancel
  CancelToken: typeof CancelToken
  isCancel: (value: any) => value is Cancel
}

/** @public */
export declare function proxy(_proxy: any): {
  processOptions: (options: RequestOptions) => {
    proxy: any
  } & RequestOptions
}

/** @public */
export declare const retry: {
  (opts?: Partial<RetryOptions>): {
    onError: (err: Error | null, context: HttpContext) => Error | null
  }
  shouldRetry: (err: any, _num: number, options: any) => boolean
}

/** @public */
export declare function urlEncoded(): {
  processOptions: (options: RequestOptions) => RequestOptions
}

/** @public */
export declare const validateOptions: (options: RequestOptions) => void

export {}
