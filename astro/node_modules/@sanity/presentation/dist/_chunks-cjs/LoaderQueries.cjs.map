{"version":3,"file":"LoaderQueries.cjs","sources":["../../../visual-editing-helpers/dist/hooks.js","../../src/loader/LoaderQueries.tsx"],"sourcesContent":["import{useMemo as e,useState as n,useCallback as t,useEffect as i,useSyncExternalStore as r}from\"react\";function o(n){const t=e((()=>JSON.stringify(n||{})),[n]);return e((()=>JSON.parse(t)),[t])}function s(e){const{refreshInterval:o}=e,s=function(){const[e,t]=n(!1);i((()=>{t(navigator.onLine);const e=()=>t(!0),n=()=>t(!1);return window.addEventListener(\"online\",e),window.addEventListener(\"offline\",n),()=>{window.removeEventListener(\"online\",e),window.removeEventListener(\"offline\",n)}}),[]);const o=r(d,(()=>document.visibilityState),(()=>\"hidden\"));return!e||\"hidden\"===o}(),[c,u]=n(\"hit\"),a=t((()=>(u(\"inflight\"),()=>u(\"hit\"))),[]);return i((()=>{if(!o||\"hit\"!==c)return;const e=setTimeout((()=>u(\"stale\")),o);return()=>clearTimeout(e)}),[o,c]),i((()=>{if(\"hit\"!==c)return;const e=()=>u(\"stale\");return window.addEventListener(\"focus\",e),()=>window.removeEventListener(\"focus\",e)}),[o,c]),i((()=>{s&&\"hit\"===c&&u(\"stale\"),!s&&\"stale\"===c&&u(\"refresh\")}),[s,c]),[c,a]}function d(e){return document.addEventListener(\"visibilitychange\",e),()=>document.removeEventListener(\"visibilitychange\",e)}export{o as useQueryParams,s as useRevalidate};//# sourceMappingURL=hooks.js.map\n","import type {ChannelsController} from '@repo/channels'\nimport type {LoaderMsg, VisualEditingConnectionIds} from '@repo/visual-editing-helpers'\nimport {useQueryParams, useRevalidate} from '@repo/visual-editing-helpers/hooks'\nimport type {ClientConfig, ClientPerspective, ContentSourceMap, QueryParams} from '@sanity/client'\nimport {applySourceDocuments, getPublishedId} from '@sanity/client/csm'\nimport {applyPatch} from 'mendoza'\nimport LRUCache from 'mnemonist/lru-cache-with-delete'\nimport {memo, useEffect, useMemo, useState} from 'react'\nimport {type SanityClient, type SanityDocument, useClient} from 'sanity'\n\nimport {LIVE_QUERY_CACHE_BATCH_SIZE, LIVE_QUERY_CACHE_SIZE} from '../constants'\nimport type {LiveQueriesState} from '../types'\n\nexport interface LoaderQueriesProps {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  channel: ChannelsController<VisualEditingConnectionIds, LoaderMsg> | undefined\n  perspective: ClientPerspective\n  liveQueries: LiveQueriesState\n  documentsOnPage: {_id: string; _type: string}[]\n}\n\nexport default function LoaderQueries(props: LoaderQueriesProps): JSX.Element {\n  const {\n    liveDocument,\n    channel,\n    perspective: activePerspective,\n    liveQueries,\n    documentsOnPage,\n  } = props\n  const [cache] = useState(() => new LRUCache<string, SanityDocument>(LIVE_QUERY_CACHE_SIZE))\n  const studioClient = useClient({apiVersion: '2023-10-16'})\n  const clientConfig = useMemo(() => studioClient.config(), [studioClient])\n  const client = useMemo(\n    () =>\n      studioClient.withConfig({\n        resultSourceMap: 'withKeyArraySelector',\n      }),\n    [studioClient],\n  )\n  useEffect(() => {\n    if (channel) {\n      const {projectId, dataset} = clientConfig\n      // @todo - Can this be migrated/deprecated in favour of emitting\n      // `presentation/perspective` at a higher level?\n      channel.send('loaders', 'loader/perspective', {\n        projectId: projectId!,\n        dataset: dataset!,\n        perspective: activePerspective,\n      })\n    }\n  }, [channel, clientConfig, activePerspective])\n\n  const turboIds = useMemo(() => {\n    const documentsActuallyInUse = documentsOnPage.map(({_id}) => _id)\n    const set = new Set(documentsActuallyInUse)\n    const ids = [...set]\n    const max = cache.capacity\n    if (ids.length >= max) {\n      ids.length = max\n    }\n    return ids\n  }, [cache.capacity, documentsOnPage])\n\n  const [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = useState(0)\n\n  return (\n    <>\n      <Turbo\n        cache={cache}\n        client={client}\n        turboIds={turboIds}\n        setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n      />\n      {Object.entries(liveQueries).map(([key, {query, params, perspective}]) => (\n        <QuerySubscription\n          key={`${key}${perspective}`}\n          cache={cache}\n          projectId={clientConfig.projectId!}\n          dataset={clientConfig.dataset!}\n          perspective={perspective}\n          query={query}\n          params={params}\n          channel={channel}\n          client={client}\n          refreshInterval={activePerspective ? 2000 : 0}\n          liveDocument={liveDocument}\n          documentsCacheLastUpdated={documentsCacheLastUpdated}\n        />\n      ))}\n    </>\n  )\n}\n\ninterface SharedProps {\n  /**\n   * The Sanity client to use for fetching data and listening to mutations.\n   */\n  client: SanityClient\n  /**\n   * How frequently queries should be refetched in the background to refresh the parts of queries that can't be source mapped.\n   * Setting it to `0` will disable background refresh.\n   * @defaultValue 10000\n   */\n  refreshInterval?: number\n  /**\n   * The documents cache to use for turbo-charging queries.\n   */\n  cache: LRUCache<string, SanityDocument>\n}\n\ninterface TurboProps extends Pick<SharedProps, 'client' | 'cache'> {\n  turboIds: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nconst Turbo = memo(function Turbo(props: TurboProps) {\n  const {cache, client, turboIds, setDocumentsCacheLastUpdated} = props\n  // Figure out which documents are missing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (!batchSet.has(turboId) && !cache.has(turboId)) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, LIVE_QUERY_CACHE_BATCH_SIZE)\n    if (nextBatchSlice.length === 0) return\n    setBatch((prevBatch) => [...prevBatch.slice(-LIVE_QUERY_CACHE_BATCH_SIZE), nextBatchSlice])\n  }, [batch, cache, turboIds])\n\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = client\n      .listen(\n        '*',\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n          tag: 'presentation-loader',\n        },\n      )\n      .subscribe((update) => {\n        if (update.type === 'mutation' && update.transition === 'disappear') {\n          if (cache.delete(update.documentId)) {\n            setDocumentsCacheLastUpdated(Date.now())\n          }\n        }\n\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const cachedDocument = cache.peek(update.documentId)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = {...cachedDocument} as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          cache.set(update.documentId, patchedDocument)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      })\n    return () => subscription.unsubscribe()\n  }, [cache, client, setDocumentsCacheLastUpdated])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          cache={cache}\n          client={client}\n          ids={ids}\n          setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n        />\n      ))}\n    </>\n  )\n})\n\ninterface GetDocumentsProps extends Pick<SharedProps, 'client' | 'cache'> {\n  ids: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\nconst GetDocuments = memo(function GetDocuments(props: GetDocumentsProps) {\n  const {client, cache, ids, setDocumentsCacheLastUpdated} = props\n\n  useEffect(() => {\n    const missingIds = ids.filter((id) => !cache.has(id))\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          cache.set(doc._id, doc)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [cache, client, ids, setDocumentsCacheLastUpdated])\n\n  return null\n})\nGetDocuments.displayName = 'GetDocuments'\n\ninterface QuerySubscriptionProps\n  extends Pick<\n    UseQuerySubscriptionProps,\n    'client' | 'cache' | 'refreshInterval' | 'liveDocument' | 'documentsCacheLastUpdated'\n  > {\n  projectId: string\n  dataset: string\n  perspective: ClientPerspective\n  query: string\n  params: QueryParams\n  channel: ChannelsController<VisualEditingConnectionIds, LoaderMsg> | undefined\n}\nfunction QuerySubscription(props: QuerySubscriptionProps) {\n  const {\n    cache,\n    projectId,\n    dataset,\n    perspective,\n    query,\n    client,\n    refreshInterval,\n    liveDocument,\n    channel,\n    documentsCacheLastUpdated,\n  } = props\n\n  const params = useQueryParams(props.params)\n  const data = useQuerySubscription({\n    cache,\n    client,\n    liveDocument,\n    params,\n    perspective,\n    query,\n    refreshInterval,\n    documentsCacheLastUpdated,\n  })\n  const result = data?.result\n  const resultSourceMap = data?.resultSourceMap\n\n  useEffect(() => {\n    if (resultSourceMap) {\n      channel!.send('loaders', 'loader/query-change', {\n        projectId,\n        dataset,\n        perspective,\n        query,\n        params,\n        result,\n        resultSourceMap,\n      })\n    }\n  }, [channel, dataset, params, perspective, projectId, query, result, resultSourceMap])\n\n  return null\n}\n\ninterface UseQuerySubscriptionProps\n  extends Required<Pick<SharedProps, 'client' | 'refreshInterval' | 'cache'>> {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  query: string\n  params: QueryParams\n  perspective: ClientPerspective\n  documentsCacheLastUpdated: number\n}\nfunction useQuerySubscription(props: UseQuerySubscriptionProps) {\n  const {\n    cache,\n    liveDocument,\n    client,\n    refreshInterval,\n    query,\n    params,\n    perspective,\n    documentsCacheLastUpdated,\n  } = props\n  const [snapshot, setSnapshot] = useState<{\n    result: unknown\n    resultSourceMap?: ContentSourceMap\n  } | null>(null)\n  const {projectId, dataset} = useMemo(() => {\n    const {projectId, dataset} = client.config()\n    return {projectId, dataset} as Required<Pick<ClientConfig, 'projectId' | 'dataset'>>\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({refreshInterval})\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    let fetching = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const {signal} = controller\n      fetching = true\n      const {result, resultSourceMap} = await client.fetch(query, params, {\n        tag: 'presentation-loader',\n        signal,\n        perspective,\n        filterResponse: false,\n      })\n      fetching = false\n\n      if (!signal.aborted) {\n        setSnapshot({result, resultSourceMap})\n\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        fetching = false\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled && !fetching) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    liveDocument,\n    params,\n    perspective,\n    projectId,\n    query,\n    shouldRefetch,\n    startRefresh,\n  ])\n\n  return useMemo(() => {\n    if (documentsCacheLastUpdated && snapshot?.resultSourceMap) {\n      return {\n        result: turboChargeResultIfSourceMap(\n          cache,\n          liveDocument,\n          snapshot.result,\n          perspective,\n          snapshot.resultSourceMap,\n        ),\n        resultSourceMap: snapshot.resultSourceMap,\n      }\n    }\n    return snapshot\n  }, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot])\n}\n\nlet warnedAboutCrossDatasetReference = false\nexport function turboChargeResultIfSourceMap<T = unknown>(\n  cache: SharedProps['cache'],\n  liveDocument: Partial<SanityDocument> | null | undefined,\n  result: T,\n  perspective: ClientPerspective,\n  resultSourceMap?: ContentSourceMap,\n): T {\n  if (perspective === 'raw') {\n    throw new Error('turboChargeResultIfSourceMap does not support raw perspective')\n  }\n  return applySourceDocuments(\n    result,\n    resultSourceMap,\n    (sourceDocument) => {\n      if (sourceDocument._projectId) {\n        // @TODO Handle cross dataset references\n        if (!warnedAboutCrossDatasetReference) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Cross dataset references are not supported yet, ignoring source document',\n            sourceDocument,\n          )\n          warnedAboutCrossDatasetReference = true\n        }\n        return undefined\n      }\n      // If there's a displayed document, always prefer it\n      if (\n        liveDocument?._id &&\n        getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id)\n      ) {\n        return liveDocument\n      }\n      // Fallback to general documents cache\n      return cache.get(sourceDocument._id)\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (changedValue: any, {previousValue}) => {\n      if (typeof changedValue === 'number' && typeof previousValue === 'string') {\n        // If the string() function was used in the query, we need to convert the source value to a string as well\n        return `${changedValue}`\n      }\n      return changedValue\n    },\n    perspective,\n  )\n}\n"],"names":["d","e","document","addEventListener","removeEventListener","Turbo","memo","props","cache","client","turboIds","setDocumentsCacheLastUpdated","batch","setBatch","useState","useEffect","batchSet","Set","flat","nextBatch","turboId","has","add","nextBatchSlice","slice","LIVE_QUERY_CACHE_BATCH_SIZE","length","prevBatch","subscription","listen","events","effectFormat","includePreviousRevision","includeResult","tag","subscribe","update","_a","_b","type","transition","delete","documentId","Date","now","effects","apply","cachedDocument","peek","patchDoc","_rev","patchedDocument","applyPatch","set","unsubscribe","jsx","Fragment","children","map","ids","jsxRuntime","GetDocuments","JSON","stringify","missingIds","filter","id","getDocuments","then","documents","doc","_id","console","error","QuerySubscription","projectId","dataset","perspective","query","refreshInterval","liveDocument","channel","documentsCacheLastUpdated","params","n","t","parse","useQueryParams","data","snapshot","setSnapshot","useMemo","config","setError","revalidate","startRefresh","o","s","i","navigator","onLine","window","r","visibilityState","c","u","a","setTimeout","clearTimeout","s2","useRevalidate","shouldRefetch","fulfilled","fetching","controller","AbortController","async","effect","signal","result","resultSourceMap","fetch","filterResponse","aborted","onFinally","catch","name","finally","abort","turboChargeResultIfSourceMap","useQuerySubscription","send","displayName","warnedAboutCrossDatasetReference","Error","applySourceDocuments","sourceDocument","_projectId","getPublishedId","get","warn","changedValue","previousValue","exports","default","activePerspective","liveQueries","documentsOnPage","LRUCache","LIVE_QUERY_CACHE_SIZE","studioClient","useClient","apiVersion","clientConfig","withConfig","documentsActuallyInUse","max","capacity","jsxs","Object","entries","key"],"mappings":"qSAA68B,SAASA,EAAEC,GAAU,OAAAC,SAASC,iBAAiB,mBAAmBF,GAAG,IAAIC,SAASE,oBAAoB,mBAAmBH,EAAE,CCqHxkC,MAAMI,EAAQC,EAAAA,MAAK,SAAeC,GAChC,MAAMC,MAACA,EAAAC,OAAOA,EAAQC,SAAAA,EAAAC,6BAAUA,GAAgCJ,GAEzDK,EAAOC,GAAYC,EAAAA,SAAqB,IAC/CC,OAAAA,EAAAA,WAAU,KACF,MAAAC,EAAW,IAAIC,IAAIL,EAAMM,QACzBC,EAAY,IAAIF,IACtB,IAAA,MAAWG,KAAWV,GACfM,EAASK,IAAID,KAAaZ,EAAMa,IAAID,IACvCD,EAAUG,IAAIF,GAGZ,MAAAG,EAAiB,IAAIJ,GAAWK,MAAM,EAAGC,EAAAA,GACjB,IAA1BF,EAAeG,QACnBb,GAAUc,GAAc,IAAIA,EAAUH,OAAOC,EAAAA,GAA8BF,IAAe,GACzF,CAACX,EAAOJ,EAAOE,IAGlBK,aAAU,KACR,MAAMa,EAAenB,EAClBoB,OACC,IACA,CAAC,EACD,CACEC,OAAQ,CAAC,YACTC,aAAc,UACdC,yBAAyB,EACzBC,eAAe,EACfC,IAAK,wBAGRC,WAAWC,IApJlB,IAAAC,EAAAC,EAqJY,GAAgB,aAAhBF,EAAOG,MAA6C,cAAtBH,EAAOI,YACnChC,EAAMiC,OAAOL,EAAOM,aACtB/B,EAA6BgC,KAAKC,OAIlB,aAAhBR,EAAOG,MAAwB,OAAAD,EAAA,OAAAD,EAAAD,EAAOS,cAAP,EAAAR,EAAgBS,SAAhBR,EAAuBZ,OAAQ,OAGlE,MAAMqB,EAAiBvC,EAAMwC,KAAKZ,EAAOM,YACzC,GAAIK,EAAkC,CAE9B,MAAAE,EAAW,IAAIF,UACdE,EAASC,KAChB,MAAMC,EAAkBC,EAAAA,WAAWH,EAAUb,EAAOS,QAAQC,OACtDtC,EAAA6C,IAAIjB,EAAOM,WAAYS,GAC7BxC,EAA6BgC,KAAKC,MACpC,KAEG,MAAA,IAAMhB,EAAa0B,gBACzB,CAAC9C,EAAOC,EAAQE,IAId4C,EAAAA,IAAAC,WAAA,CAAAC,SAAA7C,EAAM8C,KAAKC,GACVC,EAAAL,IAACM,EAAA,CAECrD,QACAC,SACAkD,MACAhD,gCAJKmD,KAAKC,UAAUJ,OAS9B,IAMME,EAAevD,QAAK,SAAsBC,GAC9C,MAAME,OAACA,EAAAD,MAAQA,EAAOmD,IAAAA,EAAAhD,6BAAKA,GAAgCJ,EAE3DQ,OAAAA,EAAAA,WAAU,KACF,MAAAiD,EAAaL,EAAIM,QAAQC,IAAQ1D,EAAMa,IAAI6C,KACvB,IAAXF,EAAAtC,QACfjB,EAAO0D,aAAaH,GAAYI,MAAMC,IACpC,IAAA,MAAWC,KAAOD,EACZC,GAAO,MAAAA,GAAAA,EAAKC,MACd/D,EAAM6C,IAAIiB,EAAIC,IAAKD,GACnB3D,EAA6BgC,KAAKC,OAAK,GAI1C4B,QAAQC,MAAK,GACf,CAACjE,EAAOC,EAAQkD,EAAKhD,IAEjB,IACT,IAeA,SAAS+D,EAAkBnE,GACnB,MAAAC,MACJA,EAAAmE,UACAA,EAAAC,QACAA,EAAAC,YACAA,EAAAC,MACAA,EAAArE,OACAA,EAAAsE,gBACAA,EAAAC,aACAA,EAAAC,QACAA,EAAAC,0BACAA,GACE3E,EAEE4E,ED7OgG,SAAWC,GAASC,MAAAA,EAAEpF,WAAG,IAAI6D,KAAKC,UAAUqB,GAAG,KAAK,CAACA,IAAWnF,OAAAA,EAAAA,SAAG,IAAI6D,KAAKwB,MAAMD,IAAI,CAACA,GAAG,CC6OjLE,CAAehF,EAAM4E,QAC9BK,EAsCR,SAA8BjF,GACtB,MAAAC,MACJA,EAAAwE,aACAA,EAAAvE,OACAA,EAAAsE,gBACAA,EAAAD,MACAA,EAAAK,OACAA,EAAAN,YACAA,EAAAK,0BACAA,GACE3E,GACGkF,EAAUC,GAAe5E,EAAAA,SAGtB,OACJ6D,UAACA,EAAWC,QAAAA,GAAWe,WAAQ,KACnC,MAAOhB,UAAAA,EAAWC,QAAAA,GAAWnE,EAAOmF,SACpC,MAAO,CAACjB,UAAAA,EAAWC,QAAAA,EAAO,GACzB,CAACnE,KAGGgE,EAAOoB,GAAY/E,EAAAA,SAAkB,MAC5C,GAAI2D,EAAa,MAAAA,EAEjB,MAAOqB,EAAYC,GD5S8K,SAAW9F,GAAG,MAAM8E,gBAAgBiB,GAAG/F,EAAEgG,EAAE,WAAW,MAAMhG,EAAEoF,GAAGD,EAAAA,UAAE,GAAIc,EAAAA,WAAG,KAAKb,EAAEc,UAAUC,QAAcnG,MAAAA,EAAE,IAAIoF,GAAE,GAAID,EAAE,IAAIC,GAAE,GAAW,OAAAgB,OAAOlG,iBAAiB,SAASF,GAAGoG,OAAOlG,iBAAiB,UAAUiF,GAAG,KAAKiB,OAAOjG,oBAAoB,SAASH,GAAGoG,OAAOjG,oBAAoB,UAAUgF,EAAC,CAAA,GAAK,IAAUY,MAAAA,EAAEM,EAAAA,qBAAEtG,GAAG,IAAIE,SAASqG,kBAAkB,IAAI,WAAiB,OAACtG,GAAG,WAAW+F,CAAX,CAAtU,IAAuVQ,EAAEC,GAAGrB,EAAAA,SAAE,OAAOsB,EAAErB,EAAAA,aAAG,KAAKoB,EAAE,YAAY,IAAIA,EAAE,SAAS,IAAWP,OAAAA,aAAG,KAAQ,IAACF,GAAG,QAAQQ,EAAE,OAAO,MAAMvG,EAAE0G,YAAY,IAAIF,EAAE,UAAUT,GAAS,MAAA,IAAIY,aAAa3G,EAAC,GAAI,CAAC+F,EAAEQ,IAAIN,aAAG,KAAK,GAAG,QAAQM,EAAE,OAAavG,MAAAA,EAAE,IAAIwG,EAAE,SAAgB,OAAAJ,OAAOlG,iBAAiB,QAAQF,GAAG,IAAIoG,OAAOjG,oBAAoB,QAAQH,EAAC,GAAI,CAAC+F,EAAEQ,IAAIN,aAAG,KAAgBW,GAAR,QAAQL,GAAGC,EAAE,UAAUR,GAAG,UAAUO,GAAGC,EAAE,UAAS,GAAI,CAACR,EAAEO,IAAI,CAACA,EAAEE,EAAE,CC4Sv6BI,CAAc,CAAC/B,oBAC5CgC,EAA+B,YAAfjB,GAA2C,aAAfA,EAClD/E,OAAAA,EAAAA,WAAU,KACR,IAAKgG,EACH,OAGE,IAAAC,GAAY,EACZC,GAAW,EACT,MAAAC,EAAa,IAAIC,gBAEvBC,eAAeC,IACP,MAAAC,OAACA,GAAUJ,EACND,GAAA,EACL,MAAAM,OAACA,kBAAQC,SAAyB/G,EAAOgH,MAAM3C,EAAOK,EAAQ,CAClEjD,IAAK,sBACLoF,SACAzC,cACA6C,gBAAgB,IAEPT,GAAA,EAENK,EAAOK,UACVjC,EAAY,CAAC6B,SAAQC,oBAErBR,GAAY,EAEhB,CACA,MAAMY,EAAY7B,IACX,OAAAsB,IACJQ,OAAOpD,IACNwC,GAAW,EACQ,eAAfxC,EAAMqD,MACRjC,EAASpB,EAAK,IAGjBsD,QAAQH,GACJ,MACAZ,IAAcC,GACjBC,EAAWc,OAAM,CAAA,GAGpB,CACDvH,EACAmE,EACAI,EACAG,EACAN,EACAF,EACAG,EACAiC,EACAhB,IAGKJ,EAAAA,SAAQ,IACTT,SAA6BO,KAAU+B,gBAClC,CACLD,OAAQU,EACNzH,EACAwE,EACAS,EAAS8B,OACT1C,EACAY,EAAS+B,iBAEXA,gBAAiB/B,EAAS+B,iBAGvB/B,GACN,CAACjF,EAAO0E,EAA2BF,EAAcH,EAAaY,GACnE,CAnIeyC,CAAqB,CAChC1H,QACAC,SACAuE,eACAG,SACAN,cACAC,QACAC,kBACAG,8BAEIqC,EAAe,MAAN/B,OAAM,EAAAA,EAAA+B,OACfC,EAAwB,MAANhC,OAAM,EAAAA,EAAAgC,gBAE9BzG,OAAAA,EAAAA,WAAU,KAENyG,GAAAvC,EAASkD,KAAK,UAAW,sBAAuB,CAC9CxD,YACAC,UACAC,cACAC,QACAK,SACAoC,SACAC,mBACD,GAEF,CAACvC,EAASL,EAASO,EAAQN,EAAaF,EAAWG,EAAOyC,EAAQC,IAE9D,IACT,CAzDA3D,EAAauE,YAAc,eAkK3B,IAAIC,GAAmC,EAChC,SAASJ,EACdzH,EACAwE,EACAuC,EACA1C,EACA2C,GAEA,GAAoB,QAAhB3C,EACI,MAAA,IAAIyD,MAAM,iEAEX,OAAAC,EAAAA,qBACLhB,EACAC,GACCgB,IACC,IAAIA,EAAeC,WAanB,OACgB,MAAdzD,GAAcA,EAAAT,KACdmE,EAAeA,eAAA1D,EAAaT,OAASmE,EAAAA,eAAeF,EAAejE,KAE5DS,EAGFxE,EAAMmI,IAAIH,EAAejE,KAlBzB8D,IAEH7D,QAAQoE,KACN,2EACAJ,GAEFH,GAAmC,EAYJ,IAGrC,CAACQ,GAAoBC,mBACS,iBAAjBD,GAAsD,iBAAlBC,EAEtC,GAAGD,IAELA,GAEThE,EAEJ,CAAAkE,QAAAC,QA7YA,SAAsCzI,GAC9B,MAAAyE,aACJA,EAAAC,QACAA,EACAJ,YAAaoE,EAAAC,YACbA,EAAAC,gBACAA,GACE5I,GACGC,GAASM,YAAS,IAAM,IAAIsI,EAAiCJ,QAAAK,OAC9DC,EAAeC,YAAU,CAACC,WAAY,eACtCC,EAAe9D,EAAAA,SAAQ,IAAM2D,EAAa1D,UAAU,CAAC0D,IACrD7I,EAASkF,EAAAA,SACb,IACE2D,EAAaI,WAAW,CACtBlC,gBAAiB,0BAErB,CAAC8B,IAEHvI,EAAAA,WAAU,KACR,GAAIkE,EAAS,CACL,MAAAN,UAACA,EAAWC,QAAAA,GAAW6E,EAGrBxE,EAAAkD,KAAK,UAAW,qBAAsB,CAC5CxD,YACAC,UACAC,YAAaoE,GAEjB,IACC,CAAChE,EAASwE,EAAcR,IAErB,MAAAvI,EAAWiF,EAAAA,SAAQ,KACvB,MAAMgE,EAAyBR,EAAgBzF,KAAI,EAAEa,SAASA,IAExDZ,EAAM,IADA,IAAI1C,IAAI0I,IAEdC,EAAMpJ,EAAMqJ,SAClB,OAAIlG,EAAIjC,QAAUkI,IAChBjG,EAAIjC,OAASkI,GAERjG,CAAA,GACN,CAACnD,EAAMqJ,SAAUV,KAEbjE,EAA2BvE,GAAgCG,WAAS,GAE3E,OAEI8C,EAAAkG,KAAAtG,WAAA,CAAAC,SAAA,CAAAG,EAAAL,IAAClD,EAAA,CACCG,QACAC,SACAC,WACAC,iCAEDoJ,OAAOC,QAAQd,GAAaxF,KAAI,EAAEuG,GAAMnF,QAAOK,SAAQN,kBACtDjB,EAAAL,IAACmB,EAAA,CAEClE,QACAmE,UAAW8E,EAAa9E,UACxBC,QAAS6E,EAAa7E,QACtBC,cACAC,QACAK,SACAF,UACAxE,SACAsE,gBAAiBkE,EAAoB,IAAO,EAC5CjE,eACAE,6BAXK,GAAG+E,IAAMpF,SAgBxB,EAuUAkE,QAAAd,6BAAAA"}