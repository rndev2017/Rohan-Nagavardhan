{"version":3,"file":"index.js","sources":["../src/helpers.ts","../src/calculate/lcs.ts","../src/calculate/diffArray.ts","../src/calculate/diffObject.ts","../src/calculate/diffSimple.ts","../src/calculate/diffString.ts","../src/calculate/diffTypeChange.ts","../src/calculate/diffInput.ts","../src/inputWrappers/array.ts","../src/inputWrappers/basic.ts","../src/inputWrappers/object.ts","../src/inputWrappers/string.ts","../src/inputWrappers/index.ts"],"sourcesContent":["export function replaceProperty<P, V extends P[K], K extends keyof P>(\n  parent: P,\n  prop: K,\n  value: V,\n): V {\n  delete parent[prop]\n  parent[prop] = value\n  return value\n}\n","/*\n * Longest common subsequence implementation, for diffing arrays\n * Reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n */\n\ntype NumberArray = number[]\ntype LengthMatrix = NumberArray[]\ntype Subsequence<E> = {\n  sequence: E[]\n  prevIndices: number[]\n  nextIndices: number[]\n}\n\nexport function getLongestCommonSubsequence<E>(previous: E[], next: E[]): Subsequence<E> {\n  const matrix = getLengthMatrix(previous, next)\n  const result = backtrack(matrix, previous, next)\n  return result\n}\n\nfunction getLengthMatrix<E>(previous: E[], next: E[]): LengthMatrix {\n  const len1 = previous.length\n  const len2 = next.length\n  let x = 0\n  let y = 0\n\n  // initialize empty matrix of len1+1 x len2+1\n  const matrix: LengthMatrix = new Array(len1 + 1)\n  for (x = 0; x < len1 + 1; x++) {\n    matrix[x] = [len2 + 1]\n    for (y = 0; y < len2 + 1; y++) {\n      matrix[x][y] = 0\n    }\n  }\n\n  // save sequence lengths for each coordinate\n  for (x = 1; x < len1 + 1; x++) {\n    for (y = 1; y < len2 + 1; y++) {\n      if (previous[x - 1] === next[y - 1]) {\n        matrix[x][y] = matrix[x - 1][y - 1] + 1\n      } else {\n        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1])\n      }\n    }\n  }\n\n  return matrix\n}\n\nfunction backtrack<E>(matrix: LengthMatrix, previous: E[], next: E[]): Subsequence<E> {\n  let prevIndex = previous.length\n  let nextIndex = next.length\n  const subsequence: Subsequence<E> = {\n    sequence: [],\n    prevIndices: [],\n    nextIndices: [],\n  }\n\n  while (prevIndex !== 0 && nextIndex !== 0) {\n    const areEqual = previous[prevIndex - 1] === next[nextIndex - 1]\n    if (areEqual) {\n      subsequence.sequence.unshift(previous[prevIndex - 1])\n      subsequence.prevIndices.unshift(prevIndex - 1)\n      subsequence.nextIndices.unshift(nextIndex - 1)\n      --prevIndex\n      --nextIndex\n    } else {\n      const valueAtMatrixAbove = matrix[prevIndex][nextIndex - 1]\n      const valueAtMatrixLeft = matrix[prevIndex - 1][nextIndex]\n      if (valueAtMatrixAbove > valueAtMatrixLeft) {\n        --nextIndex\n      } else {\n        --prevIndex\n      }\n    }\n  }\n  return subsequence\n}\n","import {replaceProperty} from '../helpers'\nimport {type ArrayDiff, type ArrayInput, type DiffOptions, type ItemDiff} from '../types'\nimport {addedInput, diffInput, removedInput} from './diffInput'\nimport {getLongestCommonSubsequence} from './lcs'\n\nexport function diffArray<A>(\n  fromInput: ArrayInput<A>,\n  toInput: ArrayInput<A>,\n  options: DiffOptions,\n): ArrayDiff<A> {\n  if (fromInput === toInput) {\n    const fromValue = fromInput.value\n    const toValue = toInput.value\n\n    return {\n      type: 'array',\n      action: 'unchanged',\n      isChanged: false,\n      fromValue,\n      toValue,\n      get items(): ItemDiff<A>[] {\n        const items = diffExactByPosition(fromInput, toInput, options)\n        if (!items) throw new Error('invariant broken: equivalent input, but diff detected')\n        return replaceProperty(this, 'items', items)\n      },\n    }\n  }\n\n  // The key-ed approach should handle most cases (_key'ed objects, primitives):\n  const keyedA = indexByKey(fromInput)\n  const keyedB = indexByKey(toInput)\n\n  if (keyedA && keyedB) {\n    return diffArrayByKey(fromInput, keyedA, toInput, keyedB, options)\n  }\n\n  // Check if they are 100% equivalent:\n  const items = diffExactByPosition(fromInput, toInput, options)\n  if (items) return buildArrayDiff(fromInput, toInput, items, false)\n\n  // Otherwise we create a diff where we model it as removing the from-items and adding the to-items.\n  return diffArrayByReinsert(fromInput, toInput, options)\n}\n\nfunction buildArrayDiff<A>(\n  fromInput: ArrayInput<A>,\n  toInput: ArrayInput<A>,\n  items: ItemDiff<A>[],\n  isChanged: boolean,\n): ArrayDiff<A> {\n  const fromValue = fromInput.value\n  const toValue = toInput.value\n\n  return isChanged\n    ? {\n        type: 'array',\n        action: 'changed',\n        isChanged: true,\n        fromValue,\n        toValue,\n        items,\n        annotation: toInput.annotation,\n      }\n    : {\n        type: 'array',\n        action: 'unchanged',\n        isChanged: false,\n        fromValue,\n        toValue,\n        items,\n      }\n}\n\n/**\n * Diffes the two arrays by position. Returns an `items` array if they are unchanged, or undefined\n * if there are any changes anywhere.\n */\nfunction diffExactByPosition<A>(\n  fromInput: ArrayInput<A>,\n  toInput: ArrayInput<A>,\n  options: DiffOptions,\n): ItemDiff<A>[] | undefined {\n  if (fromInput.length !== toInput.length) {\n    return undefined\n  }\n\n  const items: ItemDiff<A>[] = []\n\n  for (let idx = 0; idx < fromInput.length; idx++) {\n    const diff = diffInput(fromInput.at(idx), toInput.at(idx), options)\n    if (diff.isChanged) {\n      return undefined\n    }\n\n    items.push({\n      fromIndex: idx,\n      toIndex: idx,\n      hasMoved: false,\n      diff,\n      annotation: toInput.annotationAt(idx),\n    })\n  }\n\n  return items\n}\n\nfunction diffArrayByReinsert<A>(\n  fromInput: ArrayInput<A>,\n  toInput: ArrayInput<A>,\n  options: DiffOptions,\n): ArrayDiff<A> {\n  const items: ItemDiff<A>[] = []\n\n  for (let idx = 0; idx < toInput.length; idx++) {\n    const input = toInput.at(idx)\n\n    items.push({\n      fromIndex: undefined,\n      toIndex: idx,\n      hasMoved: false,\n      diff: addedInput(input, undefined, options),\n      annotation: input.annotation,\n    })\n  }\n\n  for (let idx = 0; idx < fromInput.length; idx++) {\n    const input = fromInput.at(idx)\n\n    items.push({\n      fromIndex: idx,\n      toIndex: undefined,\n      hasMoved: false,\n      diff: removedInput(input, undefined, options),\n      annotation: input.annotation,\n    })\n  }\n\n  return buildArrayDiff(fromInput, toInput, items, true)\n}\n\ntype Key = string | number | boolean\n\n/**\n * Diff an array when all the elements have _key in the same position.\n */\nfunction diffArrayByKey<A>(\n  fromArray: ArrayInput<A>,\n  fromKeyIndex: KeyIndex,\n  toArray: ArrayInput<A>,\n  toKeyIndex: KeyIndex,\n  options: DiffOptions,\n): ArrayDiff<A> {\n  const items: ItemDiff<A>[] = []\n  let isChanged = false\n\n  function diffCommon(key: Key, fromIndex: number, toIndex: number, hasMoved: boolean) {\n    deletePositionInIndex(fromKeyIndex.index, key, fromIndex)\n    deletePositionInIndex(toKeyIndex.index, key, toIndex)\n\n    const fromInput = fromArray.at(fromIndex)\n    const toInput = toArray.at(toIndex)\n\n    const diff = diffInput(fromInput, toInput)\n    items.push({\n      fromIndex,\n      toIndex,\n      hasMoved,\n      diff,\n      annotation: toArray.annotationAt(toIndex),\n    })\n\n    if (diff.isChanged || fromIndex !== toIndex) {\n      isChanged = true\n    }\n  }\n\n  const lcs = getLongestCommonSubsequence(fromKeyIndex.keys, toKeyIndex.keys)\n\n  for (let fromIndex = 0; fromIndex < fromKeyIndex.keys.length; fromIndex++) {\n    const key = fromKeyIndex.keys[fromIndex]\n\n    const subsequenceIdx = lcs.prevIndices.indexOf(fromIndex)\n    if (subsequenceIdx !== -1) {\n      // Part of the common subsequence => hasMoved:false\n      diffCommon(key, fromIndex, lcs.nextIndices[subsequenceIdx], false)\n      continue\n    }\n\n    // Not a part of the subsequence. Try to find another item which has the same key\n    // and also is not part of the common subsequence.\n    const toIndexes = toKeyIndex.index.get(key)\n    const toIndex = toIndexes && toIndexes.find((idx) => !lcs.nextIndices.includes(idx))\n    if (toIndex !== undefined) {\n      diffCommon(key, fromIndex, toIndex, true)\n      continue\n    }\n\n    const input = fromArray.at(fromIndex)\n\n    items.push({\n      fromIndex,\n      toIndex: undefined,\n      hasMoved: false,\n      diff: removedInput(input, undefined, options),\n      annotation: fromArray.annotationAt(fromIndex),\n    })\n\n    isChanged = true\n  }\n\n  // The remaining data in toKeyIndex are the new elements which has been added\n  for (const positions of toKeyIndex.index.values()) {\n    for (const toIndex of positions) {\n      const input = toArray.at(toIndex)\n      items.push({\n        fromIndex: undefined,\n        toIndex,\n        hasMoved: false,\n        diff: addedInput(input, undefined, options),\n        annotation: toArray.annotationAt(toIndex),\n      })\n    }\n\n    isChanged = true\n  }\n\n  items.sort(compareItemDiff)\n\n  return buildArrayDiff(fromArray, toArray, items, isChanged)\n}\n\nfunction compareItemDiff<A>(a: ItemDiff<A>, b: ItemDiff<A>): number {\n  if (a.toIndex !== undefined && b.toIndex !== undefined) {\n    return a.toIndex - b.toIndex\n  }\n\n  if (a.fromIndex !== undefined && b.fromIndex !== undefined) {\n    return a.fromIndex - b.fromIndex\n  }\n\n  if (a.fromIndex !== undefined && b.toIndex !== undefined) {\n    // A was removed and B was added. Prefer to sort removals last.\n    return -1\n  }\n\n  if (a.toIndex !== undefined && b.fromIndex !== undefined) {\n    // A was added and B was removed. Prefer to sort removals last.\n    return 1\n  }\n\n  throw new Error('invalid item diff comparison')\n}\n\nfunction deletePositionInIndex(index: Map<Key, number[]>, key: Key, pos: number) {\n  const positions = index.get(key)!\n  deleteArrayValue(positions, pos)\n  if (positions.length === 0) {\n    index.delete(key)\n  }\n}\n\nfunction deleteArrayValue<E>(arr: E[], value: E) {\n  const idx = arr.indexOf(value)\n  if (idx === -1) throw new Error('value not found')\n  arr.splice(idx, 1)\n}\n\ntype KeyIndex = {\n  keys: Key[]\n  index: Map<Key, number[]>\n}\n\n/**\n * Indexes the array by a key. This handles cases where the items are:\n *\n * - Objects with _key\n * - Strings\n * - Numbers\n */\nfunction indexByKey<A>(arr: ArrayInput<A>): KeyIndex | undefined {\n  const index = new Map<Key, number[]>()\n  const keys: Key[] = []\n  const length = arr.length\n\n  for (let i = 0; i < length; i++) {\n    const item = arr.at(i)\n\n    let key: Key | null = null\n\n    switch (item.type) {\n      case 'string':\n        key = `s${item.value}`\n        break\n      case 'number':\n        key = item.value\n        break\n      case 'boolean':\n        key = item.value\n        break\n      case 'null':\n        key = 'n'\n        break\n      case 'object':\n        {\n          const keyField = item.get('_key')\n          if (keyField && keyField.type === 'string') {\n            key = `k${keyField.value}`\n\n            // We do not handle duplicate _key\n            if (index.has(key)) return undefined\n          }\n        }\n        break\n      default:\n    }\n\n    // No key => abort\n    if (key === null) return undefined\n\n    keys.push(key)\n    let positions = index.get(key)\n    if (!positions) {\n      positions = []\n      index.set(key, positions)\n    }\n    positions.push(i)\n  }\n\n  // All is good.\n  return {keys, index}\n}\n\nexport function removedArray<A>(\n  input: ArrayInput<A>,\n  toValue: null | undefined,\n  options: DiffOptions,\n): ArrayDiff<A> & {action: 'removed'} {\n  return {\n    type: 'array',\n    action: 'removed',\n    isChanged: true,\n    fromValue: input.value,\n    toValue,\n    annotation: input.annotation,\n\n    get items(): ArrayDiff<A>['items'] {\n      const items: ArrayDiff<A>['items'] = []\n      for (let i = 0; i < input.length; i++) {\n        const item = input.at(i)\n        items.push({\n          fromIndex: i,\n          toIndex: undefined,\n          hasMoved: false,\n          diff: removedInput(item, undefined, options),\n          annotation: input.annotationAt(i),\n        })\n      }\n\n      return replaceProperty(this, 'items', items)\n    },\n  }\n}\n\nexport function addedArray<A>(\n  input: ArrayInput<A>,\n  fromValue: null | undefined,\n  options: DiffOptions,\n): ArrayDiff<A> & {action: 'added'} {\n  return {\n    type: 'array',\n    action: 'added',\n    isChanged: true,\n    fromValue,\n    toValue: input.value,\n    annotation: input.annotation,\n\n    get items(): ArrayDiff<A>['items'] {\n      const items: ArrayDiff<A>['items'] = []\n      for (let i = 0; i < input.length; i++) {\n        const item = input.at(i)\n        items.push({\n          fromIndex: undefined,\n          toIndex: i,\n          hasMoved: false,\n          diff: addedInput(item, undefined, options),\n          annotation: input.annotationAt(i),\n        })\n      }\n\n      return replaceProperty(this, 'items', items)\n    },\n  }\n}\n","import {replaceProperty} from '../helpers'\nimport {type DiffOptions, type ObjectDiff, type ObjectInput} from '../types'\nimport {addedInput, diffInput, removedInput} from './diffInput'\n\nconst ignoredFields = new Set(['_id', '_type', '_createdAt', '_updatedAt', '_rev', '_weak'])\n\nexport function diffObject<A>(\n  fromInput: ObjectInput<A>,\n  toInput: ObjectInput<A>,\n  options: DiffOptions,\n): ObjectDiff<A> {\n  const fields: ObjectDiff<A>['fields'] = {}\n  let isChanged = false\n\n  for (const key of fromInput.keys) {\n    if (ignoredFields.has(key)) continue\n\n    const fromField = fromInput.get(key)!\n\n    const toField = toInput.get(key)\n    if (toField) {\n      const fieldDiff = diffInput(fromField, toField, options)\n      fields[key] = fieldDiff\n      if (fieldDiff.isChanged) isChanged = true\n    } else {\n      fields[key] = removedInput(fromField, undefined, options)\n      isChanged = true\n    }\n  }\n\n  for (const key of toInput.keys) {\n    if (ignoredFields.has(key)) continue\n\n    // Already handled above\n    if (fromInput.get(key)) continue\n\n    const toField = toInput.get(key)!\n    fields[key] = addedInput(toField, undefined, options)\n    isChanged = true\n  }\n\n  const fromValue = fromInput.value\n  const toValue = toInput.value\n\n  if (!isChanged) {\n    return {\n      type: 'object',\n      action: 'unchanged',\n      isChanged: false,\n      fromValue,\n      toValue,\n      fields,\n    }\n  }\n\n  return {\n    type: 'object',\n    action: 'changed',\n    isChanged: true,\n    fromValue,\n    toValue,\n    fields,\n    annotation: toInput.annotation,\n  }\n}\n\nexport function removedObject<A>(\n  input: ObjectInput<A>,\n  toValue: null | undefined,\n  options: DiffOptions,\n): ObjectDiff<A> & {action: 'removed'} {\n  return {\n    type: 'object',\n    action: 'removed',\n    isChanged: true,\n    fromValue: input.value,\n    toValue,\n    annotation: input.annotation,\n\n    get fields(): ObjectDiff<A>['fields'] {\n      const fields: ObjectDiff<A>['fields'] = {}\n      for (const key of input.keys) {\n        const value = input.get(key)!\n        fields[key] = removedInput(value, undefined, options)\n      }\n      return replaceProperty(this, 'fields', fields)\n    },\n  }\n}\n\nexport function addedObject<A>(\n  input: ObjectInput<A>,\n  fromValue: null | undefined,\n  options: DiffOptions,\n): ObjectDiff<A> & {action: 'added'} {\n  return {\n    type: 'object',\n    action: 'added',\n    isChanged: true,\n    fromValue,\n    toValue: input.value,\n    annotation: input.annotation,\n\n    get fields(): ObjectDiff<A>['fields'] {\n      const fields: ObjectDiff<A>['fields'] = {}\n      for (const key of input.keys) {\n        const value = input.get(key)!\n        fields[key] = addedInput(value, undefined, options)\n      }\n      return replaceProperty(this, 'fields', fields)\n    },\n  }\n}\n","import {\n  type BooleanDiff,\n  type BooleanInput,\n  type DiffOptions,\n  type NumberDiff,\n  type NumberInput,\n} from '../types'\n\nexport function diffNumber<A>(\n  fromInput: NumberInput<A>,\n  toInput: NumberInput<A>,\n  options: DiffOptions,\n): NumberDiff<A> {\n  const fromValue = fromInput.value\n  const toValue = toInput.value\n  const type = fromInput.type\n\n  if (fromValue === toValue)\n    return {\n      type,\n      action: 'unchanged',\n      fromValue,\n      toValue,\n      isChanged: false,\n    }\n\n  return {\n    type: fromInput.type,\n    action: 'changed',\n    isChanged: true,\n    fromValue: fromValue,\n    toValue: toValue,\n    annotation: toInput.annotation,\n  }\n}\n\nexport function diffBoolean<A>(\n  fromInput: BooleanInput<A>,\n  toInput: BooleanInput<A>,\n  options: DiffOptions,\n): BooleanDiff<A> {\n  const fromValue = fromInput.value\n  const toValue = toInput.value\n  const type = fromInput.type\n\n  if (fromValue === toValue)\n    return {\n      type,\n      action: 'unchanged',\n      fromValue,\n      toValue,\n      isChanged: false,\n    }\n\n  return {\n    type: fromInput.type,\n    action: 'changed',\n    isChanged: true,\n    fromValue: fromValue,\n    toValue: toValue,\n    annotation: toInput.annotation,\n  }\n}\n","import {\n  cleanupSemantic,\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  makeDiff,\n} from '@sanity/diff-match-patch'\n\nimport {replaceProperty} from '../helpers'\nimport {type DiffOptions, type StringDiff, type StringDiffSegment, type StringInput} from '../types'\n\nexport function diffString<A>(\n  fromInput: StringInput<A>,\n  toInput: StringInput<A>,\n  options: DiffOptions,\n): StringDiff<A> {\n  const fromValue = fromInput.value\n  const toValue = toInput.value\n\n  if (fromValue === toValue) {\n    return {\n      type: 'string',\n      action: 'unchanged',\n      isChanged: false,\n      fromValue,\n      toValue,\n      segments: [{type: 'stringSegment', action: 'unchanged', text: fromValue}],\n    }\n  }\n\n  return {\n    type: 'string',\n    action: 'changed',\n    isChanged: true,\n    fromValue,\n    toValue,\n    annotation: toInput.annotation,\n\n    // Compute and memoize string segments only when accessed\n    get segments(): StringDiffSegment<A>[] {\n      const segments = buildSegments(fromInput, toInput)\n      return replaceProperty(this, 'segments', segments)\n    },\n  }\n}\n\nfunction buildSegments<A>(\n  fromInput: StringInput<A>,\n  toInput: StringInput<A>,\n): StringDiffSegment<A>[] {\n  const segments: StringDiffSegment<A>[] = []\n  const dmpDiffs = cleanupSemantic(makeDiff(fromInput.value, toInput.value))\n\n  let fromIdx = 0\n  let toIdx = 0\n\n  for (const [op, text] of dmpDiffs) {\n    switch (op) {\n      case DIFF_EQUAL:\n        segments.push({type: 'stringSegment', action: 'unchanged', text})\n        fromIdx += text.length\n        toIdx += text.length\n        break\n      case DIFF_DELETE:\n        for (const segment of fromInput.sliceAnnotation(fromIdx, fromIdx + text.length)) {\n          segments.push({\n            type: 'stringSegment',\n            action: 'removed',\n            text: segment.text,\n            annotation: segment.annotation,\n          })\n        }\n        fromIdx += text.length\n        break\n      case DIFF_INSERT:\n        for (const segment of toInput.sliceAnnotation(toIdx, toIdx + text.length)) {\n          segments.push({\n            type: 'stringSegment',\n            action: 'added',\n            text: segment.text,\n            annotation: segment.annotation,\n          })\n        }\n        toIdx += text.length\n        break\n      default:\n        throw new Error(`Unhandled diff-match-patch operation \"${op}\"`)\n    }\n  }\n\n  return segments\n}\n\nexport function removedString<A>(\n  input: StringInput<A>,\n  toValue: null | undefined,\n  options: DiffOptions,\n): StringDiff<A> & {action: 'removed'} {\n  return {\n    type: 'string',\n    action: 'removed',\n    isChanged: true,\n    fromValue: input.value,\n    toValue,\n    annotation: input.annotation,\n\n    get segments(): StringDiffSegment<A>[] {\n      const segments: StringDiffSegment<A>[] = input\n        .sliceAnnotation(0, input.value.length)\n        .map((segment) => ({type: 'stringSegment', action: 'removed', ...segment}))\n\n      return replaceProperty(this, 'segments', segments)\n    },\n  }\n}\n\nexport function addedString<A>(\n  input: StringInput<A>,\n  fromValue: null | undefined,\n  options: DiffOptions,\n): StringDiff<A> & {action: 'added'} {\n  return {\n    type: 'string',\n    action: 'added',\n    isChanged: true,\n    fromValue,\n    toValue: input.value,\n    annotation: input.annotation,\n\n    get segments(): StringDiffSegment<A>[] {\n      const segments: StringDiffSegment<A>[] = input\n        .sliceAnnotation(0, input.value.length)\n        .map((segment) => ({type: 'stringSegment', action: 'added', ...segment}))\n\n      return replaceProperty(this, 'segments', segments)\n    },\n  }\n}\n","import {type DiffOptions, type Input, type TypeChangeDiff} from '../types'\nimport {addedInput, removedInput} from './diffInput'\n\nexport function diffTypeChange<A>(\n  fromInput: Input<A>,\n  toInput: Input<A>,\n  options: DiffOptions,\n): TypeChangeDiff<A> {\n  return {\n    type: 'typeChange',\n    action: 'changed',\n    isChanged: true,\n\n    fromType: fromInput.type,\n    fromValue: fromInput.value,\n    fromDiff: removedInput(fromInput, undefined, options),\n\n    toType: toInput.type,\n    toValue: toInput.value,\n    toDiff: addedInput(toInput, undefined, options),\n\n    annotation: toInput.annotation,\n  }\n}\n","import {\n  type ArrayInput,\n  type BooleanInput,\n  type Diff,\n  type DiffOptions,\n  type Input,\n  type NumberInput,\n  type ObjectInput,\n  type StringInput,\n} from '../types'\nimport {addedArray, diffArray, removedArray} from './diffArray'\nimport {addedObject, diffObject, removedObject} from './diffObject'\nimport {diffBoolean, diffNumber} from './diffSimple'\nimport {addedString, diffString, removedString} from './diffString'\nimport {diffTypeChange} from './diffTypeChange'\n\n/**\n * Takes a `from` and `to` input and calulates a diff between the two\n *\n * @param fromInput - The source (`from`) input - use {@link wrap | the wrap() method} to generate an \"input\"\n * @param toInput - The destination (`to`) input - use {@link wrap | the wrap() method} to generate an \"input\"\n * @param options - Options for the diffing process - currently no options are defined\n * @returns A diff object representing the change\n * @public\n */\nexport function diffInput<A>(\n  fromInput: Input<A>,\n  toInput: Input<A>,\n  options: DiffOptions = {},\n): Diff<A> {\n  if (fromInput.type !== toInput.type) {\n    if (fromInput.type === 'null') {\n      return addedInput(toInput, null, options)\n    }\n\n    if (toInput.type === 'null') {\n      return removedInput(fromInput, null, options)\n    }\n\n    return diffTypeChange(fromInput, toInput, options)\n  }\n\n  return diffWithType(fromInput.type, fromInput, toInput, options)\n}\n\nfunction diffWithType<A>(\n  type: Input<A>['type'],\n  fromInput: Input<A>,\n  toInput: Input<A>,\n  options: DiffOptions,\n): Diff<A> {\n  switch (type) {\n    case 'null':\n      return {\n        type: 'null',\n        action: 'unchanged',\n        isChanged: false,\n        toValue: null,\n        fromValue: null,\n      }\n    case 'boolean':\n      return diffBoolean(fromInput as BooleanInput<A>, toInput as BooleanInput<A>, options)\n    case 'number':\n      return diffNumber(fromInput as NumberInput<A>, toInput as NumberInput<A>, options)\n    case 'string':\n      return diffString(fromInput as StringInput<A>, toInput as StringInput<A>, options)\n    case 'array':\n      return diffArray(fromInput as ArrayInput<A>, toInput as ArrayInput<A>, options)\n    case 'object':\n      return diffObject(fromInput as ObjectInput<A>, toInput as ObjectInput<A>, options)\n    default:\n      throw new Error(`Unhandled diff type \"${type}\"`)\n  }\n}\n\nexport function removedInput<A>(\n  input: Input<A>,\n  toValue: null | undefined,\n  options: DiffOptions,\n): Diff<A> & {action: 'removed'} {\n  switch (input.type) {\n    case 'null':\n      return {\n        type: 'null',\n        action: 'removed',\n        isChanged: true,\n        fromValue: null,\n        toValue,\n        annotation: input.annotation,\n      }\n    case 'boolean':\n      return {\n        type: 'boolean',\n        action: 'removed',\n        isChanged: true,\n        fromValue: input.value,\n        toValue,\n        annotation: input.annotation,\n      }\n    case 'number':\n      return {\n        type: 'number',\n        action: 'removed',\n        isChanged: true,\n        fromValue: input.value,\n        toValue,\n        annotation: input.annotation,\n      }\n    case 'string':\n      return removedString(input, toValue, options)\n    case 'array':\n      return removedArray(input, toValue, options)\n    case 'object':\n      return removedObject(input, toValue, options)\n    default:\n      throw new Error('Unhandled diff type')\n  }\n}\n\nexport function addedInput<A>(\n  input: Input<A>,\n  fromValue: null | undefined,\n  options: DiffOptions,\n): Diff<A> & {action: 'added'} {\n  switch (input.type) {\n    case 'null':\n      return {\n        type: 'null',\n        action: 'added',\n        isChanged: true,\n        fromValue,\n        toValue: null,\n        annotation: input.annotation,\n      }\n    case 'boolean':\n      return {\n        type: 'boolean',\n        action: 'added',\n        isChanged: true,\n        fromValue,\n        toValue: input.value,\n        annotation: input.annotation,\n      }\n    case 'number':\n      return {\n        type: 'number',\n        action: 'added',\n        isChanged: true,\n        fromValue,\n        toValue: input.value,\n        annotation: input.annotation,\n      }\n    case 'string':\n      return addedString(input, fromValue, options)\n    case 'array':\n      return addedArray(input, fromValue, options)\n    case 'object':\n      return addedObject(input, fromValue, options)\n    default:\n      throw new Error('Unhandled diff type')\n  }\n}\n","import {type ArrayInput, type Input} from '../types'\nimport {wrap} from './index'\n\nexport default class ArrayWrapper<A> implements ArrayInput<A> {\n  type = 'array' as const\n  length: number\n  value: unknown[]\n  annotation: A\n\n  private elements: Input<A>[] = []\n\n  constructor(value: unknown[], annotation: A) {\n    this.annotation = annotation\n    this.value = value\n    this.length = value.length\n  }\n\n  at(idx: number): Input<A> {\n    if (idx >= this.length) throw new Error('out of bounds')\n    const input = this.elements[idx]\n    if (input) {\n      return input\n    }\n\n    return (this.elements[idx] = wrap(this.value[idx], this.annotation))\n  }\n\n  annotationAt(): A {\n    return this.annotation\n  }\n}\n","type SimpleType = 'boolean' | 'number' | 'null'\n\nexport default class BasicWrapper<K extends SimpleType, V, A> {\n  type: K\n  value: V\n  annotation: A\n\n  constructor(type: K, value: V, annotation: A) {\n    this.type = type\n    this.value = value\n    this.annotation = annotation\n  }\n}\n","import {type Input, type ObjectInput} from '../types'\nimport {wrap} from './index'\n\nexport default class ObjectWrapper<A> implements ObjectInput<A> {\n  type = 'object' as const\n  value: Record<string, unknown>\n  keys: string[]\n  annotation: A\n\n  private fields: Record<string, Input<A>> = {}\n\n  constructor(value: Record<string, unknown>, annotation: A) {\n    this.value = value\n    this.annotation = annotation\n    this.keys = Object.keys(value)\n  }\n\n  get(key: string): Input<A> | undefined {\n    const input = this.fields[key]\n    if (input) {\n      return input\n    }\n\n    if (!this.value.hasOwnProperty(key)) {\n      return undefined\n    }\n\n    const raw = this.value[key]\n    return (this.fields[key] = wrap(raw, this.annotation))\n  }\n}\n","import {type StringInput} from '../types'\n\nexport default class StringWrapper<A> implements StringInput<A> {\n  type = 'string' as const\n  value: string\n  annotation: A\n\n  constructor(value: string, annotation: A) {\n    this.value = value\n    this.annotation = annotation\n  }\n\n  sliceAnnotation(start: number, end: number): {text: string; annotation: A}[] {\n    return [{text: this.value.slice(start, end), annotation: this.annotation}]\n  }\n}\n","import {type Input} from '../types'\nimport ArrayWrapper from './array'\nimport BasicWrapper from './basic'\nimport ObjectWrapper from './object'\nimport StringWrapper from './string'\n\n/**\n * Takes an input (any JSON-serializable value) and an annotation, and generates an input\n * object for it, to be used with {@link diffInput | the diffInput() method} and others.\n *\n * @param input - The value to wrap in an input object\n * @param annotation - Annotation attached to the input - will be bound to generated diffs\n * @returns A input object\n * @throws if `input` is not a JSON-serializable type\n * @public\n */\nexport function wrap<A>(input: unknown, annotation: A): Input<A> {\n  if (Array.isArray(input)) {\n    return new ArrayWrapper(input, annotation)\n  } else if (input === null) {\n    return new BasicWrapper('null', input, annotation)\n  }\n\n  const type = typeof input\n  switch (type) {\n    case 'number':\n      return new BasicWrapper(type, input as number, annotation)\n    case 'boolean':\n      return new BasicWrapper(type, input as boolean, annotation)\n    case 'object':\n      return new ObjectWrapper(input as Record<string, unknown>, annotation)\n    case 'string':\n      return new StringWrapper(input as string, annotation)\n    default:\n      throw new Error(`cannot wrap value of type: ${type}`)\n  }\n}\n"],"names":["items","cleanupSemantic","makeDiff","DIFF_EQUAL","DIFF_DELETE","DIFF_INSERT","__publicField"],"mappings":"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"}