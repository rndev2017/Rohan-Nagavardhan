{"version":3,"file":"index.cjs","sources":["../src/validatePreviewUrl.ts","../src/createClientWithConfig.ts","../src/parsePreviewUrl.ts","../src/validateSecret.ts"],"sourcesContent":["import {isDev} from './constants'\nimport {createClientWithConfig} from './createClientWithConfig'\nimport {parsePreviewUrl} from './parsePreviewUrl'\nimport type {ParsedPreviewUrl, PreviewUrlValidateUrlResult, SanityClientLike} from './types'\nimport {validateSecret} from './validateSecret'\n\n/**\n * @public\n */\nexport async function validatePreviewUrl(\n  _client: SanityClientLike,\n  previewUrl: string,\n  /**\n   * @deprecated - this option is automatically determined based on the environment\n   */\n  // Default value based on https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent\n  disableCacheNoStore: boolean = globalThis.navigator?.userAgent === 'Cloudflare-Workers',\n): Promise<PreviewUrlValidateUrlResult> {\n  const client = createClientWithConfig(_client)\n  let parsedPreviewUrl: ParsedPreviewUrl\n  try {\n    parsedPreviewUrl = parsePreviewUrl(previewUrl)\n  } catch (error) {\n    if (isDev) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse preview URL', error, {\n        previewUrl,\n        client,\n      })\n    }\n    return {isValid: false}\n  }\n\n  const {isValid, studioUrl} = await validateSecret(\n    client,\n    parsedPreviewUrl.secret,\n    disableCacheNoStore,\n  )\n  const redirectTo = isValid ? parsedPreviewUrl.redirectTo : undefined\n  let studioOrigin: string | undefined\n  if (isValid) {\n    try {\n      studioOrigin = new URL(studioUrl!).origin\n    } catch (error) {\n      if (isDev) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to parse studioUrl', error, {\n          previewUrl,\n          studioUrl,\n        })\n      }\n    }\n  }\n\n  return {isValid, redirectTo, studioOrigin}\n}\n\nexport type {PreviewUrlValidateUrlResult, SanityClientLike}\n","import {apiVersion} from './constants'\nimport type {SanityClientLike} from './types'\n\n/**\n * Validates the passed in client instance, then clones it and reconfigures it to fit the needs and spec of\n * this package.\n * @internal\n */\nexport function createClientWithConfig(client: SanityClientLike): SanityClientLike {\n  if (!client) {\n    throw new TypeError('`client` is required')\n  }\n\n  if (!client.config().token) {\n    throw new TypeError('`client` must have a `token` specified')\n  }\n\n  return client.withConfig({\n    // Userland might be using an API version that's too old to use perspectives\n    apiVersion,\n    // We can't use the CDN, the secret is typically validated rigth after it's created\n    useCdn: false,\n    // The documents that hold secrets are never drafts\n    perspective: 'published',\n    // Don't waste time returning a source map, we don't need it\n    resultSourceMap: false,\n    // @ts-expect-error - If stega is enabled, make sure it's disabled\n    stega: false,\n  })\n}\n","import {urlSearchParamPreviewPathname, urlSearchParamPreviewSecret} from './constants'\nimport type {ParsedPreviewUrl} from './types'\n\n/**\n * @internal\n */\nexport function parsePreviewUrl(unsafeUrl: string): ParsedPreviewUrl {\n  const url = new URL(unsafeUrl, 'http://localhost')\n  const secret = url.searchParams.get(urlSearchParamPreviewSecret)\n  if (!secret) {\n    throw new Error('Missing secret')\n  }\n  let redirectTo = undefined\n  const unsafeRedirectTo = url.searchParams.get(urlSearchParamPreviewPathname)\n  if (unsafeRedirectTo) {\n    const {pathname, search, hash} = new URL(unsafeRedirectTo, 'http://localhost')\n    redirectTo = `${pathname}${search}${hash}`\n  }\n  return {secret, redirectTo}\n}\n","import {fetchSecretQuery, tag} from './constants'\nimport type {FetchSecretQueryParams, FetchSecretQueryResponse, SanityClientLike} from './types'\n\n/** @internal */\nexport async function validateSecret(\n  client: SanityClientLike,\n  secret: string,\n  disableCacheNoStore: boolean,\n): Promise<{isValid: boolean; studioUrl: string | null}> {\n  // If we're in the Edge Runtime it's usually too quick and we need to delay fetching the secret a little bit\n  // @ts-expect-error -- this global exists if we're in the Edge Runtime\n  if (typeof EdgeRuntime !== 'undefined') {\n    await new Promise((resolve) => setTimeout(resolve, 300))\n  }\n  if (!secret || !secret.trim()) {\n    return {isValid: false, studioUrl: null}\n  }\n  const result = await client.fetch<FetchSecretQueryResponse, FetchSecretQueryParams>(\n    fetchSecretQuery,\n    {secret: secret},\n    {\n      tag,\n      // In CloudFlare Workers we can't pass the cache header\n      ...(!disableCacheNoStore ? {cache: 'no-store'} : undefined),\n    },\n  )\n  if (!result?._id || !result?._updatedAt || !result?.secret) {\n    return {isValid: false, studioUrl: null}\n  }\n  return {isValid: secret === result.secret, studioUrl: result.studioUrl}\n}\n"],"names":["exports","urlSearchParamPreviewPathname","constants","b","urlSearchParamPreviewSecret","u","validatePreviewUrl","async","_client","previewUrl","disableCacheNoStore","navigator","_a","userAgent","client","TypeError","config","token","withConfig","apiVersion","a","useCdn","perspective","resultSourceMap","stega","createClientWithConfig","parsedPreviewUrl","unsafeUrl","url","URL","secret","searchParams","get","Error","redirectTo","unsafeRedirectTo","pathname","search","hash","parsePreviewUrl","error","isDev","i","console","isValid","studioUrl","EdgeRuntime","Promise","resolve","setTimeout","trim","result","fetch","fetchSecretQuery","f","tag","t","cache","_id","_updatedAt","validateSecret","studioOrigin","origin"],"mappings":"iHAuDAA,QAAAC,8BAAAC,EAAAC,EAAAH,QAAAI,4BAAAF,EAAAG,EAAAL,QAAAM,mBA9CsBC,eACpBC,EACAC,EAKAC,EAAmE,uBAAnE,IAA+B,oBAAWC,gBAAX,EAAAC,EAAsBC,UAArD,IAEM,MAAAC,ECVD,SAAgCA,GACrC,IAAKA,EACG,MAAA,IAAIC,UAAU,wBAGlB,IAACD,EAAOE,SAASC,MACb,MAAA,IAAIF,UAAU,0CAGtB,OAAOD,EAAOI,WAAW,CAAAC,WAEvBA,EAAAC,EAEAC,QAAQ,EAERC,YAAa,YAEbC,iBAAiB,EAEjBC,OAAO,GAEX,CDXiBC,CAAuBjB,GAClC,IAAAkB,EACA,IACFA,EEfG,SAAyBC,GACxB,MAAAC,EAAM,IAAIC,IAAIF,EAAW,oBACzBG,EAASF,EAAIG,aAAaC,IAAI5B,EAA2BC,GAC/D,IAAKyB,EACG,MAAA,IAAIG,MAAM,kBAEd,IAAAC,EACJ,MAAMC,EAAmBP,EAAIG,aAAaC,IAAI/B,EAA6BE,GAC3E,GAAIgC,EAAkB,CACd,MAAAC,SAACA,SAAUC,EAAQC,KAAAA,GAAQ,IAAIT,IAAIM,EAAkB,oBAC3DD,EAAa,GAAGE,IAAWC,IAASC,GACtC,CACO,MAAA,CAACR,SAAQI,aAClB,CFEuBK,CAAgB9B,SAC5B+B,GACP,OAAIC,EAEFC,GAAAC,QAAQH,MAAM,8BAA+BA,EAAO,CAClD/B,aACAK,WAGG,CAAC8B,SAAS,EACnB,CAEA,MAAMA,QAACA,EAAAC,UAASA,SG7BItC,eACpBO,EACAgB,EACApB,GAOA,UAHWoC,YAAgB,WACnB,IAAIC,SAASC,GAAYC,WAAWD,EAAS,QAEhDlB,IAAWA,EAAOoB,OACrB,MAAO,CAACN,SAAS,EAAOC,UAAW,MAE/B,MAAAM,QAAerC,EAAOsC,MAC1BC,EAAAC,EACA,CAACxB,UACD,CAAAyB,IACEA,EAAAC,KAEK9C,OAA4C,EAAtB,CAAC+C,MAAO,cAGnC,aAACN,KAAQO,WAAQP,KAAQQ,YAAuB,MAARR,GAAQA,EAAArB,OAG7C,CAACc,QAASd,IAAWqB,EAAOrB,OAAQe,UAAWM,EAAON,WAFpD,CAACD,SAAS,EAAOC,UAAW,KAGvC,CHGqCe,CACjC9C,EACAY,EAAiBI,OACjBpB,GAEIwB,EAAaU,EAAUlB,EAAiBQ,gBAAa,EACvD,IAAA2B,EACA,GAAAjB,EACE,IACaiB,EAAA,IAAIhC,IAAIgB,GAAYiB,aAC5BtB,GACHC,EAAAA,GAEFE,QAAQH,MAAM,4BAA6BA,EAAO,CAChD/B,aACAoC,aAGN,CAGK,MAAA,CAACD,UAASV,aAAY2B,eAC/B"}