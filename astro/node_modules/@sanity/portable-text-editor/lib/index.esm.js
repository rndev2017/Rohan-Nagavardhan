import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import isEqual from "lodash/isEqual.js";
import noop from "lodash/noop.js";
import { createContext, useContext, useRef, useState, useMemo, useEffect, useCallback, startTransition, Component, useLayoutEffect, forwardRef } from "react";
import { Editor, Element as Element$1, Range, Point, Text, Path, Transforms, Node, Operation, createEditor } from "slate";
import { useSlateStatic, ReactEditor, useSelected, withReact, Slate, useSlate, Editable } from "slate-react";
import debug$l from "debug";
import { isKeySegment, isPortableTextSpan, isPortableTextTextBlock, isPortableTextListBlock } from "@sanity/types";
import { randomKey } from "@sanity/util/content";
import { styled } from "styled-components";
import uniq from "lodash/uniq.js";
import { Subject } from "rxjs";
import { Schema } from "@sanity/schema";
import get from "lodash/get.js";
import isUndefined from "lodash/isUndefined.js";
import omitBy from "lodash/omitBy.js";
import isObject from "lodash/isObject.js";
import isString from "lodash/isString.js";
import findIndex from "lodash/findIndex.js";
import clone from "lodash/clone.js";
import omit from "lodash/omit.js";
import flatten$1 from "lodash/flatten.js";
import { isHotkey } from "is-hotkey-esm";
import { htmlToBlocks, normalizeBlock } from "@sanity/block-tools";
import isPlainObject from "lodash/isPlainObject.js";
import throttle from "lodash/throttle.js";
import debounce from "lodash/debounce.js";
const rootName = "sanity-pte:";
debug$l(rootName);
function debugWithName(name) {
  const namespace = `${rootName}${name}`;
  return debug$l && debug$l.enabled(namespace) ? debug$l(namespace) : debug$l(rootName);
}
function createKeyedPath(point, value, types) {
  const blockPath = [point.path[0]];
  if (!value)
    return null;
  const block = value[blockPath[0]];
  if (!block)
    return null;
  const keyedBlockPath = [{ _key: block._key }];
  if (block._type !== types.block.name)
    return keyedBlockPath;
  let keyedChildPath;
  const childPath = point.path.slice(0, 2), child = Array.isArray(block.children) && block.children[childPath[1]];
  return child && (keyedChildPath = ["children", { _key: child._key }]), keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;
}
function createArrayedPath(point, editor) {
  if (!editor)
    return [];
  const [block, blockPath] = Array.from(
    Editor.nodes(editor, {
      at: [],
      match: (n) => isKeySegment(point.path[0]) && n._key === point.path[0]._key
    })
  )[0] || [void 0, void 0];
  if (!block || !Element$1.isElement(block))
    return [];
  if (editor.isVoid(block))
    return [blockPath[0], 0];
  const childPath = [point.path[2]], childIndex = block.children.findIndex((child) => isEqual([{ _key: child._key }], childPath));
  if (childIndex >= 0 && block.children[childIndex]) {
    const child = block.children[childIndex];
    return Element$1.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);
  }
  return blockPath;
}
function toPortableTextRange(value, range, types) {
  if (!range)
    return null;
  let anchor = null, focus = null;
  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);
  anchorPath && range.anchor && (anchor = {
    path: anchorPath,
    offset: range.anchor.offset
  });
  const focusPath = range.focus && createKeyedPath(range.focus, value, types);
  focusPath && range.focus && (focus = {
    path: focusPath,
    offset: range.focus.offset
  });
  const backward = !!(Range.isRange(range) && Range.isBackward(range));
  return anchor && focus ? { anchor, focus, backward } : null;
}
function toSlateRange(selection, editor) {
  if (!selection || !editor)
    return null;
  const anchor = {
    path: createArrayedPath(selection.anchor, editor),
    offset: selection.anchor.offset
  }, focus = {
    path: createArrayedPath(selection.focus, editor),
    offset: selection.focus.offset
  };
  return focus.path.length === 0 || anchor.path.length === 0 ? null : anchor && focus ? { anchor, focus } : null;
}
function moveRangeByOperation(range, operation) {
  const anchor = Point.transform(range.anchor, operation), focus = Point.transform(range.focus, operation);
  return anchor === null || focus === null ? null : Point.equals(anchor, range.anchor) && Point.equals(focus, range.focus) ? range : { anchor, focus };
}
function normalizePoint(point, value) {
  if (!point || !value)
    return null;
  const newPath = [];
  let newOffset = point.offset || 0;
  const blockKey = typeof point.path[0] == "object" && "_key" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == "object" && "_key" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);
  if (block)
    newPath.push({ _key: block._key });
  else
    return null;
  if (block && point.path[1] === "children") {
    if (!block.children || Array.isArray(block.children) && block.children.length === 0)
      return null;
    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);
    if (child)
      newPath.push("children"), newPath.push({ _key: child._key }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
    else
      return null;
  }
  return { path: newPath, offset: newOffset };
}
function normalizeSelection(selection, value) {
  if (!selection || !value || value.length === 0)
    return null;
  let newAnchor = null, newFocus = null;
  const { anchor, focus } = selection;
  return anchor && value.find((blk) => isEqual({ _key: blk._key }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => isEqual({ _key: blk._key }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? { anchor: newAnchor, focus: newFocus, backward: selection.backward } : null;
}
const defaultKeyGenerator = () => randomKey(12), PortableTextEditorKeyGeneratorContext = createContext(defaultKeyGenerator), usePortableTextEditorKeyGenerator = () => {
  const keyGenerator = useContext(PortableTextEditorKeyGeneratorContext);
  if (keyGenerator === void 0)
    throw new Error(
      "The `usePortableTextEditorKeyGenerator` hook must be used inside the <PortableTextEditor> component's context."
    );
  return keyGenerator;
}, EMPTY_MARKDEFS = [], EMPTY_MARKS$1 = [], VOID_CHILD_KEY = "void-child";
function keepObjectEquality(object, keyMap) {
  const value = keyMap[object._key];
  return value && isEqual(object, value) ? value : (keyMap[object._key] = object, object);
}
function toSlateValue(value, { schemaTypes }, keyMap = {}) {
  return value && Array.isArray(value) ? value.map((block) => {
    const { _type, _key, ...rest } = block, voidChildren = [{ _key: VOID_CHILD_KEY, _type: "span", text: "", marks: [] }];
    if (block && block._type === schemaTypes.block.name) {
      const textBlock = block;
      let hasInlines = !1;
      const hasMissingStyle = typeof textBlock.style > "u", hasMissingMarkDefs = typeof textBlock.markDefs > "u", hasMissingChildren = typeof textBlock.children > "u", children = hasMissingChildren ? [{ _type: schemaTypes.span.name, _key: defaultKeyGenerator(), text: "", marks: [] }] : textBlock.children.map((child) => {
        const { _type: cType, _key: cKey, ...cRest } = child;
        return cType !== "span" ? (hasInlines = !0, keepObjectEquality(
          {
            _type: cType,
            _key: cKey,
            children: voidChildren,
            value: cRest,
            __inline: !0
          },
          keyMap
        )) : cType === "span" && !("marks" in cRest) ? keepObjectEquality(
          { _key: cKey, _type: cType, ...cRest, marks: EMPTY_MARKS$1 },
          keyMap
        ) : child;
      });
      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && Element$1.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].value), hasMissingMarkDefs && (rest.markDefs = EMPTY_MARKDEFS), keepObjectEquality({ _type, _key, ...rest, children }, keyMap));
    }
    return keepObjectEquality(
      {
        _type,
        _key,
        children: voidChildren,
        value: rest
      },
      keyMap
    );
  }) : [];
}
function fromSlateValue(value, textBlockType, keyMap = {}) {
  return value.map((block) => {
    const { _key, _type } = block;
    if (!_key || !_type)
      throw new Error("Not a valid block");
    if (_type === textBlockType && "children" in block && Array.isArray(block.children) && _key) {
      let hasInlines = !1;
      const children = block.children.map((child) => {
        const { _type: _cType } = child;
        if ("value" in child && _cType !== "span") {
          hasInlines = !0;
          const { value: v, _key: k, _type: t, __inline: _i, children: _c, ...rest } = child;
          return keepObjectEquality({ ...rest, ...v, _key: k, _type: t }, keyMap);
        }
        return child;
      });
      return hasInlines ? keepObjectEquality({ ...block, children, _key, _type }, keyMap) : block;
    }
    const blockValue = "value" in block && block.value;
    return keepObjectEquality(
      { _key, _type, ...typeof blockValue == "object" ? blockValue : {} },
      keyMap
    );
  });
}
function isEqualToEmptyEditor(children, schemaTypes) {
  var _a;
  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && Element$1.isElement(children[0]) && children[0]._type === schemaTypes.block.name && "style" in children[0] && children[0].style === schemaTypes.styles[0].value && !("listItem" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && Text.isText(children[0].children[0]) && children[0].children[0]._type === "span" && !((_a = children[0].children[0].marks) != null && _a.join("")) && children[0].children[0].text === "";
}
const IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), IS_PROCESSING_LOCAL_CHANGES = /* @__PURE__ */ new WeakMap(), IS_DRAGGING = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), DefaultObject = (props) => /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx("pre", { children: JSON.stringify(props.value, null, 2) }) }), DefaultBlockObject = styled.div`
  user-select: none;
  border: ${(props) => props.selected ? "1px solid blue" : "1px solid transparent"};
`;
styled.span`
  background: #999;
  border: ${(props) => props.selected ? "1px solid blue" : "1px solid transparent"};
`;
const DefaultListItem = styled.div`
  &.pt-list-item {
    width: fit-content;
    position: relative;
    display: block;

    /* Important 'transform' in order to force refresh the ::before and ::after rules
      in Webkit: https://stackoverflow.com/a/21947628/831480
    */
    transform: translateZ(0);
    margin-left: ${(props) => getLeftPositionForListLevel(props.listLevel)};
  }
  &.pt-list-item > .pt-list-item-inner {
    display: flex;
    margin: 0;
    padding: 0;
    &:before {
      justify-content: flex-start;
      vertical-align: top;
    }
  }
  &.pt-list-item-bullet > .pt-list-item-inner:before {
      content: '${(props) => getContentForListLevelAndStyle(props.listLevel, props.listStyle)}';
      font-size: 0.4375rem; /* 7px */
      line-height: 1.5rem; /* Same as body text */
      /* Optical alignment */
      position: relative;
    }
  }
  &.pt-list-item-bullet > .pt-list-item-inner {
    &:before {
      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */
    }
  }
  &.pt-list-item-number {
    counter-increment: ${(props) => getCounterIncrementForListLevel(props.listLevel)};
    counter-reset: ${(props) => getCounterResetForListLevel(props.listLevel)};
  }
  & + :not(.pt-list-item-number) {
    counter-reset: listItemNumber;
  }
  &.pt-list-item-number > .pt-list-item-inner:before {
    content: ${(props) => getCounterContentForListLevel(props.listLevel)};
    min-width: 1.5rem; /* Make sure space between number and text never shrinks */
    /* Optical alignment */
    position: relative;
    top: 1px;
  }
`, DefaultListItemInner = styled.div``;
function getLeftPositionForListLevel(level) {
  switch (Number(level)) {
    case 1:
      return "1.5em";
    case 2:
      return "3em";
    case 3:
      return "4.5em";
    case 4:
      return "6em";
    case 5:
      return "7.5em";
    case 6:
      return "9em";
    case 7:
      return "10.5em";
    case 8:
      return "12em";
    case 9:
      return "13.5em";
    case 10:
      return "15em";
    default:
      return "0em";
  }
}
const bullets = ["\u25CF", "\u25CB", "\u25A0"];
function getContentForListLevelAndStyle(level, style) {
  const normalizedLevel = (level - 1) % 3;
  return style === "bullet" ? bullets[normalizedLevel] : "*";
}
function getCounterIncrementForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemNumber";
    case 2:
      return "listItemAlpha";
    case 3:
      return "listItemRoman";
    case 4:
      return "listItemNumberNext";
    case 5:
      return "listItemLetterNext";
    case 6:
      return "listItemRomanNext";
    case 7:
      return "listItemNumberNextNext";
    case 8:
      return "listItemAlphaNextNext";
    case 9:
      return "listItemRomanNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterResetForListLevel(level) {
  switch (level) {
    case 1:
      return "listItemAlpha";
    case 2:
      return "listItemRoman";
    case 3:
      return "listItemNumberNext";
    case 4:
      return "listItemLetterNext";
    case 5:
      return "listItemRomanNext";
    case 6:
      return "listItemNumberNextNext";
    case 7:
      return "listItemAlphaNextNext";
    case 8:
      return "listItemRomanNextNext";
    case 9:
      return "listItemNumberNextNextNext";
    default:
      return "listItemNumberNextNextNext";
  }
}
function getCounterContentForListLevel(level) {
  switch (level) {
    case 1:
      return "counter(listItemNumber) '. '";
    case 2:
      return "counter(listItemAlpha, lower-alpha) '. '";
    case 3:
      return "counter(listItemRoman, lower-roman) '. '";
    case 4:
      return "counter(listItemNumberNext) '. '";
    case 5:
      return "counter(listItemLetterNext, lower-alpha) '. '";
    case 6:
      return "counter(listItemRomanNext, lower-roman) '. '";
    case 7:
      return "counter(listItemNumberNextNext) '. '";
    case 8:
      return "counter(listItemAlphaNextNext, lower-alpha) '. '";
    case 9:
      return "counter(listItemRomanNextNext, lower-roman) '. '";
    default:
      return "counter(listItemNumberNextNextNext) '. '";
  }
}
const debug$k = debugWithName("components:DraggableBlock"), DraggableBlock = ({ children, element, readOnly, blockRef }) => {
  const editor = useSlateStatic(), dragGhostRef = useRef(), [isDragOver, setIsDragOver] = useState(!1), isVoid = useMemo(() => Editor.isVoid(editor, element), [editor, element]), isInline = useMemo(() => Editor.isInline(editor, element), [editor, element]), [blockElement, setBlockElement] = useState(null);
  useEffect(
    () => setBlockElement(blockRef ? blockRef.current : ReactEditor.toDOMNode(editor, element)),
    [editor, element, blockRef]
  );
  const handleDragOver = useCallback(
    (event) => {
      const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);
      if (!isMyDragOver || !blockElement)
        return;
      event.preventDefault(), event.dataTransfer.dropEffect = "move", IS_DRAGGING_ELEMENT_TARGET.set(editor, element);
      const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);
      let position = "bottom";
      if (element === editor.children[0] ? position = "top" : loc < height / 2 ? (position = "top", IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)) : (position = "bottom", IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)), isMyDragOver === element) {
        event.dataTransfer.dropEffect = "none";
        return;
      }
      setIsDragOver(!0);
    },
    [blockElement, editor, element]
  ), handleDragLeave = useCallback(() => {
    setIsDragOver(!1);
  }, []), handleDragEnd = useCallback(
    (event) => {
      const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);
      if (targetBlock) {
        IS_DRAGGING.set(editor, !1), event.preventDefault(), event.stopPropagation(), IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$k("Removing drag ghost"), document.body.removeChild(dragGhostRef.current));
        const dragPosition2 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
        IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
        let targetPath = ReactEditor.findPath(editor, targetBlock);
        const myPath = ReactEditor.findPath(editor, element), isBefore = Path.isBefore(myPath, targetPath);
        if (dragPosition2 === "bottom" && !isBefore) {
          if (targetPath[0] >= editor.children.length - 1) {
            debug$k("target is already at the bottom, not moving");
            return;
          }
          const originalPath = targetPath;
          targetPath = Path.next(targetPath), debug$k(
            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(
              targetPath
            )}`
          );
        }
        if (dragPosition2 === "top" && isBefore && targetPath[0] !== editor.children.length - 1) {
          const originalPath = targetPath;
          targetPath = Path.previous(targetPath), debug$k(
            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(
              targetPath
            )}`
          );
        }
        if (Path.equals(targetPath, myPath)) {
          event.preventDefault(), debug$k("targetPath and myPath is the same, not moving");
          return;
        }
        debug$k(
          `Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(
            targetPath
          )} (${dragPosition2})`
        ), Transforms.moveNodes(editor, { at: myPath, to: targetPath }), editor.onChange();
        return;
      }
      debug$k("No target element, not doing anything");
    },
    [editor, element]
  ), handleDrop = useCallback(
    (event) => {
      IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$k("On drop (prevented)", element), event.preventDefault(), event.stopPropagation(), setIsDragOver(!1));
    },
    [editor, element]
  ), handleDrag = useCallback(
    (event) => {
      if (!isVoid) {
        IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
        return;
      }
      IS_DRAGGING.set(editor, !0), IS_DRAGGING_BLOCK_ELEMENT.set(editor, element), event.stopPropagation();
      const target = event.target;
      target instanceof HTMLElement && (target.style.opacity = "1");
    },
    [editor, element, isVoid]
  ), handleDragStart = useCallback(
    (event) => {
      if (!isVoid || isInline) {
        debug$k("Not dragging block"), IS_DRAGGING_BLOCK_ELEMENT.delete(editor), IS_DRAGGING.set(editor, !1);
        return;
      }
      if (debug$k("Drag start"), IS_DRAGGING.set(editor, !0), event.dataTransfer && (event.dataTransfer.setData("application/portable-text", "something"), event.dataTransfer.effectAllowed = "move"), blockElement && blockElement instanceof HTMLElement) {
        let dragGhost = blockElement.cloneNode(!0);
        const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
        if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute("data-dragged", ""), document.body) {
          dragGhostRef.current = dragGhost, dragGhost.style.position = "absolute", dragGhost.style.left = "-99999px", dragGhost.style.boxSizing = "border-box", document.body.appendChild(dragGhost);
          const rect = blockElement.getBoundingClientRect(), x = event.clientX - rect.left, y = event.clientY - rect.top;
          dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event.dataTransfer.setDragImage(dragGhost, x, y);
        }
      }
      handleDrag(event);
    },
    [blockElement, editor, handleDrag, isInline, isVoid]
  ), isDraggingOverFirstBlock = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor), isDraggingOverLastBlock = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor), dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "top", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === "bottom", dropIndicator = useMemo(
    () => /* @__PURE__ */ jsx(
      "div",
      {
        className: "pt-drop-indicator",
        style: {
          position: "absolute",
          width: "100%",
          height: 1,
          borderBottom: "1px solid currentColor",
          zIndex: 5
        }
      }
    ),
    []
  );
  return readOnly ? /* @__PURE__ */ jsx(Fragment, { children }) : /* @__PURE__ */ jsxs(
    "div",
    {
      draggable: isVoid,
      onDragStart: handleDragStart,
      onDrag: handleDrag,
      onDragOver: handleDragOver,
      onDragLeave: handleDragLeave,
      onDragEnd: handleDragEnd,
      onDrop: handleDrop,
      children: [
        isDraggingOverTop && dropIndicator,
        children,
        isDraggingOverBottom && dropIndicator
      ]
    }
  );
};
debugWithName("components:Element");
const EMPTY_ANNOTATIONS = [], inlineBlockStyle = { display: "inline-block" }, Element = ({
  attributes,
  children,
  element,
  schemaTypes,
  readOnly,
  renderBlock,
  renderChild,
  renderListItem,
  renderStyle,
  spellCheck
}) => {
  const editor = useSlateStatic(), selected = useSelected(), blockRef = useRef(null), inlineBlockObjectRef = useRef(null), focused = selected && editor.selection && Range.isCollapsed(editor.selection) || !1, value = useMemo(
    () => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0],
    [editor, element, schemaTypes.block.name]
  );
  let renderedBlock = children, className;
  const blockPath = useMemo(() => [{ _key: element._key }], [element]);
  if (typeof element._type != "string")
    throw new Error("Expected element to have a _type property");
  if (typeof element._key != "string")
    throw new Error("Expected element to have a _key property");
  if (editor.isInline(element)) {
    const path = ReactEditor.findPath(editor, element), [block2] = Editor.node(editor, path, { depth: 1 }), schemaType2 = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);
    if (!schemaType2)
      throw new Error("Could not find type for inline block element");
    if (Element$1.isElement(block2)) {
      const elmPath = [{ _key: block2._key }, "children", { _key: element._key }];
      return /* @__PURE__ */ jsxs("span", { ...attributes, children: [
        children,
        /* @__PURE__ */ jsxs(
          "span",
          {
            draggable: !readOnly,
            className: "pt-inline-object",
            ref: inlineBlockObjectRef,
            style: inlineBlockStyle,
            contentEditable: !1,
            children: [
              renderChild && renderChild({
                annotations: EMPTY_ANNOTATIONS,
                // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.
                children: /* @__PURE__ */ jsx(DefaultObject, { value }),
                editorElementRef: inlineBlockObjectRef,
                focused,
                path: elmPath,
                schemaType: schemaType2,
                selected,
                type: schemaType2,
                value
              }),
              !renderChild && /* @__PURE__ */ jsx(DefaultObject, { value })
            ]
          },
          element._key
        )
      ] });
    }
    throw new Error("Block not found!");
  }
  if (element._type === schemaTypes.block.name) {
    className = "pt-block pt-text-block";
    const isListItem = "listItem" in element, style = "style" in element && element.style || "normal";
    className = `pt-block pt-text-block pt-text-block-style-${style}`;
    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);
    renderStyle && blockStyleType && (renderedBlock = renderStyle({
      block: element,
      children,
      focused,
      selected,
      value: style,
      path: blockPath,
      schemaType: blockStyleType,
      editorElementRef: blockRef
    }));
    let level;
    if (isListItem && (typeof element.level == "number" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {
      const listType = schemaTypes.lists.find((item) => item.value === element.listItem);
      renderListItem && listType ? renderedBlock = renderListItem({
        block: value,
        children: renderedBlock,
        focused,
        selected,
        value: element.listItem,
        path: blockPath,
        schemaType: listType,
        level: value.level || 1,
        editorElementRef: blockRef
      }) : renderedBlock = /* @__PURE__ */ jsx(
        DefaultListItem,
        {
          listStyle: value.listItem || schemaTypes.lists[0].value,
          listLevel: value.level || 1,
          children: /* @__PURE__ */ jsx(DefaultListItemInner, { children: renderedBlock })
        }
      );
    }
    const renderProps = Object.defineProperty(
      {
        children: renderedBlock,
        editorElementRef: blockRef,
        focused,
        level,
        listItem: isListItem ? element.listItem : void 0,
        path: blockPath,
        selected,
        style,
        schemaType: schemaTypes.block,
        value
      },
      "type",
      {
        enumerable: !1,
        get() {
          return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaTypes.block;
        }
      }
    ), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;
    return /* @__PURE__ */ jsx("div", { ...attributes, className, spellCheck, children: /* @__PURE__ */ jsx(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ jsx("div", { ref: blockRef, children: propsOrDefaultRendered }) }) }, element._key);
  }
  const schemaType = schemaTypes.blockObjects.find((_type) => _type.name === element._type);
  if (!schemaType)
    throw new Error(`Could not find schema type for block element of _type ${element._type}`);
  className = "pt-block pt-object-block";
  const block = fromSlateValue(
    [element],
    schemaTypes.block.name,
    KEY_TO_VALUE_ELEMENT.get(editor)
  )[0];
  let renderedBlockFromProps;
  if (renderBlock) {
    const _props = Object.defineProperty(
      {
        children: /* @__PURE__ */ jsx(DefaultObject, { value }),
        editorElementRef: blockRef,
        focused,
        path: blockPath,
        schemaType,
        selected,
        value: block
      },
      "type",
      {
        enumerable: !1,
        get() {
          return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType;
        }
      }
    );
    renderedBlockFromProps = renderBlock(_props);
  }
  return /* @__PURE__ */ jsxs("div", { ...attributes, className, children: [
    children,
    /* @__PURE__ */ jsxs(DraggableBlock, { element, readOnly, blockRef, children: [
      renderedBlockFromProps && /* @__PURE__ */ jsx("div", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps }),
      !renderedBlockFromProps && /* @__PURE__ */ jsx(DefaultBlockObject, { selected, children: /* @__PURE__ */ jsx(DefaultObject, { value }) })
    ] })
  ] }, element._key);
}, PortableTextEditorContext = createContext(null), usePortableTextEditor = () => {
  const editor = useContext(PortableTextEditorContext);
  if (!editor)
    throw new Error(
      "The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context."
    );
  return editor;
};
function DefaultAnnotation(props) {
  const handleClick = useCallback(() => alert(JSON.stringify(props.annotation)), [props.annotation]);
  return /* @__PURE__ */ jsx("span", { style: { color: "blue" }, onClick: handleClick, children: props.children });
}
function getPortableTextMemberSchemaTypes(portableTextType) {
  var _a, _b, _c;
  if (!portableTextType)
    throw new Error("Parameter 'portabletextType' missing (required)");
  const blockType = (_a = portableTextType.of) == null ? void 0 : _a.find(findBlockType);
  if (!blockType)
    throw new Error("Block type is not defined in this schema (required)");
  const childrenField = (_b = blockType.fields) == null ? void 0 : _b.find((field) => field.name === "children");
  if (!childrenField)
    throw new Error("Children field for block type found in schema (required)");
  const ofType = childrenField.type.of;
  if (!ofType)
    throw new Error("Valid types for block children not found in schema (required)");
  const spanType = ofType.find((memberType) => memberType.name === "span");
  if (!spanType)
    throw new Error("Span type not found in schema (required)");
  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== "span") || [], blockObjectTypes = ((_c = portableTextType.of) == null ? void 0 : _c.filter((field) => field.name !== blockType.name)) || [];
  return {
    styles: resolveEnabledStyles(blockType),
    decorators: resolveEnabledDecorators(spanType),
    lists: resolveEnabledListItems(blockType),
    block: blockType,
    span: spanType,
    portableText: portableTextType,
    inlineObjects: inlineObjectTypes,
    blockObjects: blockObjectTypes,
    annotations: spanType.annotations
  };
}
function resolveEnabledStyles(blockType) {
  var _a, _b, _c;
  const styleField = (_a = blockType.fields) == null ? void 0 : _a.find((btField) => btField.name === "style");
  if (!styleField)
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  const textStyles = ((_b = styleField.type.options) == null ? void 0 : _b.list) && ((_c = styleField.type.options.list) == null ? void 0 : _c.filter((style) => style.value));
  if (!textStyles || textStyles.length === 0)
    throw new Error(
      "The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}."
    );
  return textStyles;
}
function resolveEnabledDecorators(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
  var _a, _b;
  const listField = (_a = blockType.fields) == null ? void 0 : _a.find((btField) => btField.name === "listItem");
  if (!listField)
    throw new Error("A field with name 'listItem' is not defined in the block type (required).");
  const listItems = ((_b = listField.type.options) == null ? void 0 : _b.list) && listField.type.options.list.filter((list) => list.value);
  if (!listItems)
    throw new Error("The list field need at least to be an empty array");
  return listItems;
}
function findBlockType(type) {
  return type.type ? findBlockType(type.type) : type.name === "block" ? type : null;
}
function compileType(rawType) {
  return Schema.compile({
    name: "blockTypeSchema",
    types: [rawType]
  }).get(rawType.name);
}
function isHighSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 56320 && charCode <= 57343;
}
function cloneDiff(diff2) {
  const [type, patch] = diff2;
  return [type, patch];
}
function getCommonOverlap(textA, textB) {
  let text1 = textA, text2 = textB;
  const text1Length = text1.length, text2Length = text2.length;
  if (text1Length === 0 || text2Length === 0)
    return 0;
  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));
  const textLength = Math.min(text1Length, text2Length);
  if (text1 === text2)
    return textLength;
  let best = 0, length = 1;
  for (let found = 0; found !== -1; ) {
    const pattern = text1.substring(textLength - length);
    if (found = text2.indexOf(pattern), found === -1)
      return best;
    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);
  }
  return best;
}
function getCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1[0] !== text2[0])
    return 0;
  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;
  for (; pointerMin < pointerMid; )
    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  return pointerMid;
}
function getCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])
    return 0;
  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;
  for (; pointerMin < pointerMid; )
    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  return pointerMid;
}
function cleanupSemantic(rawDiffs) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;
  const equalities = [];
  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;
  for (; pointer < diffs.length; )
    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;
  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);
      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;
    }
    pointer++;
  }
  return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\s/, linebreakRegex = /[\r\n]/, blanklineEndRegex = /\n\r?\n$/, blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two)
      return 6;
    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
  }
  let pointer = 1;
  for (; pointer < diffs.length - 1; ) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];
      const commonOffset = getCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
    }
    pointer++;
  }
  return diffs;
}
function cleanupMerge(rawDiffs) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));
  diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "", commonlength;
  for (; pointer < diffs.length; )
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++, textInsert += diffs[pointer][1], pointer++;
        break;
      case DIFF_DELETE:
        countDelete++, textDelete += diffs[pointer][1], pointer++;
        break;
      case DIFF_EQUAL:
        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation");
    }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let hasChanges = !1;
  for (pointer = 1; pointer < diffs.length - 1; )
    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;
  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function trueCount() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs) {
  let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;
  const equalities = [];
  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;
  for (; pointer < diffs.length; )
    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;
  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function bisect(text1, text2, deadline) {
  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);
  for (let x = 0; x < vLength; x++)
    v1[x] = -1, v2[x] = -1;
  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;
  const delta = text1Length - text2Length, front = delta % 2 !== 0;
  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;
  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1Offset = vOffset + k1;
      let x1;
      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;
      let y1 = x1 - k1;
      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )
        x1++, y1++;
      if (v1[k1Offset] = x1, x1 > text1Length)
        k1end += 2;
      else if (y1 > text2Length)
        k1start += 2;
      else if (front) {
        const k2Offset = vOffset + delta - k1;
        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
          const x2 = text1Length - v2[k2Offset];
          if (x1 >= x2)
            return bisectSplit(text1, text2, x1, y1, deadline);
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2Offset = vOffset + k2;
      let x2;
      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;
      let y2 = x2 - k2;
      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )
        x2++, y2++;
      if (v2[k2Offset] = x2, x2 > text1Length)
        k2end += 2;
      else if (y2 > text2Length)
        k2start += 2;
      else if (!front) {
        const k1Offset = vOffset + delta - k2;
        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;
          if (x2 = text1Length - x2, x1 >= x2)
            return bisectSplit(text1, text2, x1, y1, deadline);
        }
      }
    }
  }
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}
function bisectSplit(text1, text2, x, y, deadline) {
  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {
    checkLines: !1,
    deadline
  }), diffsb = doDiff(text1b, text2b, {
    checkLines: !1,
    deadline
  });
  return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2) {
  if ((arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1) <= 0)
    return null;
  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;
  if (longText.length < 4 || shortText.length * 2 < longText.length)
    return null;
  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
  let halfMatch;
  if (halfMatch1 && halfMatch2)
    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
  else {
    if (!halfMatch1 && !halfMatch2)
      return null;
    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;
  }
  if (!halfMatch)
    throw new Error("Unable to find a half match.");
  let text1A, text1B, text2A, text2B;
  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);
  const midCommon = halfMatch[4];
  return [text1A, text1B, text2A, text2B, midCommon];
}
function halfMatchI(longText, shortText, i) {
  const seed = longText.slice(i, i + Math.floor(longText.length / 4));
  let j = -1, bestCommon = "", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {
    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));
  }
  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || "", bestLongTextB || "", bestShortTextA || "", bestShortTextB || "", bestCommon || ""] : null;
}
function charsToLines(diffs, lineArray) {
  for (let x = 0; x < diffs.length; x++) {
    const chars = diffs[x][1], text = [];
    for (let y = 0; y < chars.length; y++)
      text[y] = lineArray[chars.charCodeAt(y)];
    diffs[x][1] = text.join("");
  }
}
function linesToChars(textA, textB) {
  const lineArray = [], lineHash = {};
  lineArray[0] = "";
  function diffLinesToMunge(text) {
    let chars = "", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;
    for (; lineEnd < text.length - 1; ) {
      lineEnd = text.indexOf(`
`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);
      let line = text.slice(lineStart, lineEnd + 1);
      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;
    }
    return chars;
  }
  let maxLines = 4e4;
  const chars1 = diffLinesToMunge(textA);
  maxLines = 65535;
  const chars2 = diffLinesToMunge(textB);
  return {
    chars1,
    chars2,
    lineArray
  };
}
function doLineModeDiff(textA, textB, opts) {
  let text1 = textA, text2 = textB;
  const a = linesToChars(text1, text2);
  text1 = a.chars1, text2 = a.chars2;
  const linearray = a.lineArray;
  let diffs = doDiff(text1, text2, {
    checkLines: !1,
    deadline: opts.deadline
  });
  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "";
  for (; pointer < diffs.length; ) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++, textInsert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        countDelete++, textDelete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (countDelete >= 1 && countInsert >= 1) {
          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;
          const aa = doDiff(textDelete, textInsert, {
            checkLines: !1,
            deadline: opts.deadline
          });
          for (let j = aa.length - 1; j >= 0; j--)
            diffs.splice(pointer, 0, aa[j]);
          pointer += aa.length;
        }
        countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
    pointer++;
  }
  return diffs.pop(), diffs;
}
function computeDiff(text1, text2, opts) {
  let diffs;
  if (!text1)
    return [[DIFF_INSERT, text2]];
  if (!text2)
    return [[DIFF_DELETE, text1]];
  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);
  if (i !== -1)
    return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;
  if (shorttext.length === 1)
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  const halfMatch = findHalfMatch(text1, text2);
  if (halfMatch) {
    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);
    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);
  }
  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);
}
const DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
  if (textA === null || textB === null)
    throw new Error("Null input. (diff)");
  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
  return adjustDiffForSurrogatePairs(diffs), diffs;
}
function doDiff(textA, textB, options) {
  let text1 = textA, text2 = textB;
  if (text1 === text2)
    return text1 ? [[DIFF_EQUAL, text1]] : [];
  let commonlength = getCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);
  let diffs = computeDiff(text1, text2, options);
  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;
}
function createDeadLine(timeout) {
  let t = 1;
  return typeof timeout < "u" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
  return {
    checkLines: !0,
    deadline: createDeadLine(opts.timeout || 1),
    ...opts
  };
}
function combineChar(data, char, dir) {
  return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];
}
function hasSharedChar(diffs, i, j, dir) {
  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
  const inv = dir === 1 ? -1 : 1;
  let insertIdx = null, deleteIdx = null, j = i + dir;
  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {
    const [op, text2] = diffs[j];
    if (text2.length !== 0) {
      if (op === DIFF_INSERT) {
        insertIdx === null && (insertIdx = j);
        continue;
      } else if (op === DIFF_DELETE) {
        deleteIdx === null && (deleteIdx = j);
        continue;
      } else if (op === DIFF_EQUAL) {
        if (insertIdx === null && deleteIdx === null) {
          const [rest, char2] = splitChar(diffs[i][1], dir);
          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);
          return;
        }
        break;
      }
    }
  }
  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);
    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
    return;
  }
  const [text, char] = splitChar(diffs[i][1], dir);
  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
}
function adjustDiffForSurrogatePairs(diffs) {
  for (let i = 0; i < diffs.length; i++) {
    const [diffType, diffText] = diffs[i];
    if (diffText.length === 0) continue;
    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];
    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);
  }
  for (let i = 0; i < diffs.length; i++)
    diffs[i][1].length === 0 && diffs.splice(i, 1);
}
const DEFAULT_OPTIONS = {
  /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */
  threshold: 0.5,
  /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */
  distance: 1e3
};
function applyDefaults(options) {
  return {
    ...DEFAULT_OPTIONS,
    ...options
  };
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc) {
  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (pattern.length > MAX_BITS$1)
    throw new Error("Pattern too long for this browser.");
  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);
  function getBitapScore(e, x) {
    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);
    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;
  }
  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);
  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));
  const matchmask = 1 << pattern.length - 1;
  bestLoc = -1;
  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];
  for (let d = 0; d < pattern.length; d++) {
    for (binMin = 0, binMid = binMax; binMin < binMid; )
      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);
    binMax = binMid;
    let start = Math.max(1, loc - binMid + 1);
    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (let j = finish; j >= start; j--) {
      const charMatch = s[text.charAt(j - 1)];
      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {
        const score = getBitapScore(d, j - 1);
        if (score <= scoreThreshold)
          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)
            start = Math.max(1, 2 * loc - bestLoc);
          else
            break;
      }
    }
    if (getBitapScore(d + 1, loc) > scoreThreshold)
      break;
    lastRd = rd;
  }
  return bestLoc;
}
function getAlphabetFromPattern(pattern) {
  const s = {};
  for (let i = 0; i < pattern.length; i++)
    s[pattern.charAt(i)] = 0;
  for (let i = 0; i < pattern.length; i++)
    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  return s;
}
function match(text, pattern, searchLocation) {
  if (text === null || pattern === null || searchLocation === null)
    throw new Error("Null input. (match())");
  const loc = Math.max(0, Math.min(searchLocation, text.length));
  if (text === pattern)
    return 0;
  if (text.length) {
    if (text.substring(loc, loc + pattern.length) === pattern)
      return loc;
  } else return -1;
  return bitap(text, pattern, loc);
}
function createPatchObject(start1, start2) {
  return {
    diffs: [],
    start1,
    start2,
    utf8Start1: start1,
    utf8Start2: start2,
    length1: 0,
    length2: 0,
    utf8Length1: 0,
    utf8Length2: 0
  };
}
function diffText1(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++)
    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);
  return text.join("");
}
function diffText2(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++)
    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);
  return text.join("");
}
function countUtf8Bytes(str) {
  let bytes = 0;
  for (let i = 0; i < str.length; i++) {
    const codePoint = str.codePointAt(i);
    if (typeof codePoint > "u")
      throw new Error("Failed to get codepoint");
    bytes += utf8len(codePoint);
  }
  return bytes;
}
function adjustIndiciesToUcs2(patches, base) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, byteOffset = 0, idx = 0;
  function advanceTo(target) {
    for (; byteOffset < target; ) {
      const codePoint = base.codePointAt(idx);
      if (typeof codePoint > "u")
        return idx;
      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;
    }
    if (!options.allowExceedingIndices && byteOffset !== target)
      throw new Error("Failed to determine byte offset");
    return idx;
  }
  const adjusted = [];
  for (const patch of patches)
    adjusted.push({
      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),
      start1: advanceTo(patch.start1),
      start2: advanceTo(patch.start2),
      utf8Start1: patch.utf8Start1,
      utf8Start2: patch.utf8Start2,
      length1: patch.length1,
      length2: patch.length2,
      utf8Length1: patch.utf8Length1,
      utf8Length2: patch.utf8Length2
    });
  return adjusted;
}
function utf8len(codePoint) {
  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;
}
const MAX_BITS = 32, DEFAULT_MARGIN = 4, DEFAULT_OPTS = {
  margin: 4
};
function getDefaultOpts() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    ...DEFAULT_OPTS,
    ...opts
  };
}
function make(a, b, options) {
  if (typeof a == "string" && typeof b == "string") {
    let diffs = diff(a, b, {
      checkLines: !0
    });
    return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));
  }
  if (a && Array.isArray(a) && typeof b > "u")
    return _make(diffText1(a), a, getDefaultOpts(options));
  if (typeof a == "string" && b && Array.isArray(b))
    return _make(a, b, getDefaultOpts(options));
  throw new Error("Unknown call format to make()");
}
function _make(textA, diffs, options) {
  if (diffs.length === 0)
    return [];
  const patches = [];
  let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;
  for (let x = 0; x < diffs.length; x++) {
    const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);
    switch (!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);
        break;
      case DIFF_DELETE:
        patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);
        break;
      case DIFF_EQUAL:
        diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);
        break;
      default:
        throw new Error("Unknown diff type");
    }
    diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);
  }
  return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;
}
function addContext(patch, text, opts) {
  if (text.length === 0)
    return;
  let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;
  for (; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin; )
    padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
  padding += opts.margin;
  let prefixStart = patch.start2 - padding;
  prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;
  const prefix = text.substring(prefixStart, patch.start2);
  prefix && patch.diffs.unshift([DIFF_EQUAL, prefix]);
  const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);
  let suffixEnd = patch.start2 + patch.length1 + padding;
  suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;
  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);
  suffix && patch.diffs.push([DIFF_EQUAL, suffix]);
  const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);
  patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;
}
function levenshtein(diffs) {
  let leven = 0, insertions = 0, deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0], data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
  }
  return leven += Math.max(insertions, deletions), leven;
}
function xIndex(diffs, loc) {
  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;
  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)
    lastChars1 = chars1, lastChars2 = chars2;
  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);
}
function addPadding(patches) {
  const paddingLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
  let nullPadding = "";
  for (let x = 1; x <= paddingLength; x++)
    nullPadding += String.fromCharCode(x);
  for (const p of patches)
    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;
  let patch = patches[0], diffs = patch.diffs;
  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)
    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
  else if (paddingLength > diffs[0][1].length) {
    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;
    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
  }
  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)
    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
  else if (paddingLength > diffs[diffs.length - 1][1].length) {
    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
  }
  return nullPadding;
}
function splitMax(patches) {
  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
  const patchSize = MAX_BITS;
  for (let x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patchSize)
      continue;
    const bigpatch = patches[x];
    patches.splice(x--, 1);
    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = "";
    for (; bigpatch.diffs.length !== 0; ) {
      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
      let empty = !0;
      if (preContext !== "") {
        const precontextByteCount = countUtf8Bytes(preContext);
        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);
      }
      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {
        const diffType = bigpatch.diffs[0][0];
        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);
        if (diffType === DIFF_INSERT) {
          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;
          const diff2 = bigpatch.diffs.shift();
          diff2 && patch.diffs.push(diff2), empty = !1;
        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));
      }
      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);
      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);
      postContext !== "" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);
    }
  }
}
function apply$4(patches, originalText) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof patches == "string")
    throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
  let text = originalText;
  if (patches.length === 0)
    return [text, []];
  const parsed = adjustIndiciesToUcs2(patches, text, {
    allowExceedingIndices: opts.allowExceedingIndices
  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);
  text = nullPadding + text + nullPadding, splitMax(parsed, margin);
  let delta = 0;
  const results = [];
  for (let x = 0; x < parsed.length; x++) {
    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);
    let startLoc, endLoc = -1;
    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)
      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;
    else {
      results[x] = !0, delta = startLoc - expectedLoc;
      let text2;
      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)
        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
      else {
        let diffs = diff(text1, text2, {
          checkLines: !1
        });
        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)
          results[x] = !1;
        else {
          diffs = cleanupSemanticLossless(diffs);
          let index1 = 0, index2 = 0;
          for (let y = 0; y < parsed[x].diffs.length; y++) {
            const mod = parsed[x].diffs[y];
            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);
          }
        }
      }
    }
  }
  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];
}
function stringify(patches) {
  return patches.map(stringifyPatch).join("");
}
function stringifyPatch(patch) {
  const {
    utf8Length1,
    utf8Length2,
    utf8Start1,
    utf8Start2,
    diffs
  } = patch;
  let coords1;
  utf8Length1 === 0 ? coords1 = "".concat(utf8Start1, ",0") : utf8Length1 === 1 ? coords1 = "".concat(utf8Start1 + 1) : coords1 = "".concat(utf8Start1 + 1, ",").concat(utf8Length1);
  let coords2;
  utf8Length2 === 0 ? coords2 = "".concat(utf8Start2, ",0") : utf8Length2 === 1 ? coords2 = "".concat(utf8Start2 + 1) : coords2 = "".concat(utf8Start2 + 1, ",").concat(utf8Length2);
  const text = ["@@ -".concat(coords1, " +").concat(coords2, ` @@
`)];
  let op;
  for (let x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        op = "+";
        break;
      case DIFF_DELETE:
        op = "-";
        break;
      case DIFF_EQUAL:
        op = " ";
        break;
      default:
        throw new Error("Unknown patch operation.");
    }
    text[x + 1] = "".concat(op + encodeURI(diffs[x][1]), `
`);
  }
  return text.join("").replace(/%20/g, " ");
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
  if (!textline)
    return [];
  const patches = [], lines = textline.split(`
`);
  let textPointer = 0;
  for (; textPointer < lines.length; ) {
    const m = lines[textPointer].match(patchHeader);
    if (!m)
      throw new Error("Invalid patch string: ".concat(lines[textPointer]));
    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
    for (patches.push(patch), m[2] === "" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === "0" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === "" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === "0" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {
      const currentLine = lines[textPointer], sign = currentLine.charAt(0);
      if (sign === "@")
        break;
      if (sign === "") {
        textPointer++;
        continue;
      }
      let line;
      try {
        line = decodeURI(currentLine.slice(1));
      } catch {
        throw new Error("Illegal escape in parse: ".concat(currentLine));
      }
      const utf8Diff = countUtf8Bytes(line) - line.length;
      if (sign === "-")
        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;
      else if (sign === "+")
        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;
      else if (sign === " ")
        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;
      else
        throw new Error('Invalid patch mode "'.concat(sign, '" in: ').concat(line));
      textPointer++;
    }
  }
  return patches;
}
function toInt(num) {
  return parseInt(num, 10);
}
function setIfMissing(value, path = []) {
  return {
    type: "setIfMissing",
    path,
    value
  };
}
function diffMatchPatch$1(currentValue, nextValue, path = []) {
  const patches = make(currentValue, nextValue), patch = stringify(patches);
  return { type: "diffMatchPatch", path, value: patch };
}
function insert$1(items, position, path = []) {
  return {
    type: "insert",
    path,
    position,
    items
  };
}
function set(value, path = []) {
  return { type: "set", path, value };
}
function unset(path = []) {
  return { type: "unset", path };
}
const debug$j = debugWithName("operationToPatches");
debug$j.enabled = !1;
function createOperationToPatches(types) {
  const textBlockName = types.block.name;
  function insertTextPatch(editor, operation, beforeValue) {
    debug$j.enabled && debug$j("Operation", JSON.stringify(operation, null, 2));
    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];
    if (!block)
      throw new Error("Could not find block");
    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];
    if (!textChild)
      throw new Error("Could not find child");
    const path = [{ _key: block._key }, "children", { _key: textChild._key }, "text"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : "", patch = diffMatchPatch$1(prevText, textChild.text, path);
    return patch.value.length ? [patch] : [];
  }
  function removeTextPatch(editor, operation, beforeValue) {
    const block = editor && editor.children[operation.path[0]];
    if (!block)
      throw new Error("Could not find block");
    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;
    if (child && !textChild)
      throw new Error("Expected span");
    if (!textChild)
      throw new Error("Could not find child");
    const path = [{ _key: block._key }, "children", { _key: textChild._key }, "text"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = diffMatchPatch$1(prevText || "", textChild.text, path);
    return patch.value ? [patch] : [];
  }
  function setNodePatch(editor, operation) {
    if (operation.path.length === 1) {
      const block = editor.children[operation.path[0]];
      if (typeof block._key != "string")
        throw new Error("Expected block to have a _key");
      const setNode = omitBy(
        { ...editor.children[operation.path[0]], ...operation.newProperties },
        isUndefined
      );
      return [set(fromSlateValue([setNode], textBlockName)[0], [{ _key: block._key }])];
    } else if (operation.path.length === 2) {
      const block = editor.children[operation.path[0]];
      if (editor.isTextBlock(block)) {
        const child = block.children[operation.path[1]];
        if (child) {
          const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);
          return keys.forEach((keyName) => {
            if (keys.length === 1 && keyName === "_key") {
              const val = get(operation.newProperties, keyName);
              patches.push(
                set(val, [{ _key: blockKey }, "children", block.children.indexOf(child), keyName])
              );
            } else {
              const val = get(operation.newProperties, keyName);
              patches.push(set(val, [{ _key: blockKey }, "children", { _key: childKey }, keyName]));
            }
          }), patches;
        }
        throw new Error("Could not find a valid child");
      }
      throw new Error("Could not find a valid block");
    } else
      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);
  }
  function insertNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]], isTextBlock = editor.isTextBlock(block);
    if (operation.path.length === 1) {
      const position = operation.path[0] === 0 ? "before" : "after", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block == null ? void 0 : block._key : beforeBlock == null ? void 0 : beforeBlock._key;
      return targetKey ? [
        insert$1([fromSlateValue([operation.node], textBlockName)[0]], position, [
          { _key: targetKey }
        ])
      ] : [
        setIfMissing(beforeValue, []),
        insert$1([fromSlateValue([operation.node], textBlockName)[0]], "before", [
          operation.path[0]
        ])
      ];
    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {
      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? "before" : "after", node = { ...operation.node };
      !node._type && Text.isText(node) && (node._type = "span", node.marks = []);
      const child = fromSlateValue(
        [
          {
            _key: "bogus",
            _type: textBlockName,
            children: [node]
          }
        ],
        textBlockName
      )[0].children[0];
      return [
        insert$1([child], position, [
          { _key: block._key },
          "children",
          block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : { _key: block.children[operation.path[1] - 1]._key }
        ])
      ];
    }
    return debug$j("Something was inserted into a void block. Not producing editor patches."), [];
  }
  function splitNodePatch(editor, operation, beforeValue) {
    const patches = [], splitBlock = editor.children[operation.path[0]];
    if (!editor.isTextBlock(splitBlock))
      throw new Error(
        `Block with path ${JSON.stringify(
          operation.path[0]
        )} is not a text block and can't be split`
      );
    if (operation.path.length === 1) {
      const oldBlock = beforeValue[operation.path[0]];
      if (editor.isTextBlock(oldBlock)) {
        const targetValue = fromSlateValue(
          [editor.children[operation.path[0] + 1]],
          textBlockName
        )[0];
        targetValue && (patches.push(insert$1([targetValue], "after", [{ _key: splitBlock._key }])), oldBlock.children.slice(operation.position).forEach((span) => {
          const path = [{ _key: oldBlock._key }, "children", { _key: span._key }];
          patches.push(unset(path));
        }));
      }
      return patches;
    }
    if (operation.path.length === 2) {
      const splitSpan = splitBlock.children[operation.path[1]];
      if (editor.isTextSpan(splitSpan)) {
        const targetSpans = fromSlateValue(
          [
            {
              ...splitBlock,
              children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)
            }
          ],
          textBlockName
        )[0].children;
        patches.push(
          insert$1(targetSpans, "after", [
            { _key: splitBlock._key },
            "children",
            { _key: splitSpan._key }
          ])
        ), patches.push(
          set(splitSpan.text, [
            { _key: splitBlock._key },
            "children",
            { _key: splitSpan._key },
            "text"
          ])
        );
      }
      return patches;
    }
    return patches;
  }
  function removeNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    if (operation.path.length === 1) {
      if (block && block._key)
        return [unset([{ _key: block._key }])];
      throw new Error("Block not found");
    } else if (editor.isTextBlock(block) && operation.path.length === 2) {
      const spanToRemove = editor.isTextBlock(block) && block.children && block.children[operation.path[1]];
      return spanToRemove ? [unset([{ _key: block._key }, "children", { _key: spanToRemove._key }])] : (debug$j("Span not found in editor trying to remove node"), []);
    } else
      return debug$j("Not creating patch inside object block"), [];
  }
  function mergeNodePatch(editor, operation, beforeValue) {
    const patches = [], block = beforeValue[operation.path[0]], targetBlock = editor.children[operation.path[0]];
    if (operation.path.length === 1)
      if (block != null && block._key) {
        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];
        patches.push(set(newBlock, [{ _key: newBlock._key }])), patches.push(unset([{ _key: block._key }]));
      } else
        throw new Error("Target key not found!");
    else if (operation.path.length === 2 && editor.isTextBlock(targetBlock)) {
      const mergedSpan = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, targetSpan = targetBlock.children[operation.path[1] - 1];
      editor.isTextSpan(targetSpan) && (patches.push(
        set(targetSpan.text, [{ _key: block._key }, "children", { _key: targetSpan._key }, "text"])
      ), mergedSpan && patches.push(unset([{ _key: block._key }, "children", { _key: mergedSpan._key }])));
    } else
      debug$j("Void nodes can't be merged, not creating any patches");
    return patches;
  }
  function moveNodePatch(editor, operation, beforeValue) {
    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];
    if (operation.path.length === 1) {
      const position = operation.path[0] > operation.newPath[0] ? "before" : "after";
      patches.push(unset([{ _key: block._key }])), patches.push(
        insert$1([fromSlateValue([block], textBlockName)[0]], position, [{ _key: targetBlock._key }])
      );
    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {
      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? "after" : "before", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
      patches.push(unset([{ _key: block._key }, "children", { _key: child._key }])), patches.push(
        insert$1([childToInsert], position, [
          { _key: targetBlock._key },
          "children",
          { _key: targetChild._key }
        ])
      );
    }
    return patches;
  }
  return {
    insertNodePatch,
    insertTextPatch,
    mergeNodePatch,
    moveNodePatch,
    removeNodePatch,
    removeTextPatch,
    setNodePatch,
    splitNodePatch
  };
}
const debug$i = debugWithName("plugin:withPortableTextMarkModel");
function createWithPortableTextMarkModel(types, change$) {
  return function(editor) {
    const { apply: apply2, normalizeNode } = editor, decorators = types.decorators.map((t) => t.value), forceNewSelection = () => {
      editor.selection && (Transforms.select(editor, { ...editor.selection }), editor.selection = { ...editor.selection });
      const ptRange = toPortableTextRange(editor.children, editor.selection, types);
      change$.next({ type: "selection", selection: ptRange });
    };
    return editor.normalizeNode = (nodeEntry) => {
      normalizeNode(nodeEntry), editor.operations.some(
        (op) => [
          "insert_node",
          "insert_text",
          "merge_node",
          "remove_node",
          "remove_text",
          "set_node"
        ].includes(op.type)
      ) && mergeSpans(editor);
      const [node, path] = nodeEntry, isSpan = Text.isText(node) && node._type === types.span.name, isTextBlock = editor.isTextBlock(node);
      if (isSpan || isTextBlock) {
        isSpan && !Array.isArray(node.marks) && (debug$i("Adding .marks to span node"), Transforms.setNodes(editor, { marks: [] }, { at: path }), editor.onChange());
        for (const op of editor.operations) {
          if (op.type === "merge_node" && op.path.length === 1 && "markDefs" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
            const [targetBlock, targetPath] = Editor.node(editor, [op.path[0] - 1]);
            if (debug$i("Copying markDefs over to merged block", op), editor.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = uniq([...oldDefs, ...op.properties.markDefs]);
              isEqual(newMarkDefs, targetBlock.markDefs) || (Transforms.setNodes(editor, { markDefs: newMarkDefs }, { at: targetPath, voids: !1 }), editor.onChange());
            }
          }
          if (op.type === "split_node" && op.path.length === 1 && Element$1.isElementProps(op.properties) && op.properties._type === types.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] + 1 < editor.children.length) {
            const [targetBlock, targetPath] = Editor.node(editor, [op.path[0] + 1]);
            if (debug$i("Copying markDefs over to split block", op), editor.isTextBlock(targetBlock)) {
              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];
              Transforms.setNodes(
                editor,
                { markDefs: uniq([...oldDefs, ...op.properties.markDefs]) },
                { at: targetPath, voids: !1 }
              ), editor.onChange();
            }
          }
          if (op.type === "split_node" && op.path.length === 2 && op.properties._type === types.span.name && "marks" in op.properties && Array.isArray(op.properties.marks) && op.properties.marks.length > 0 && op.path[0] + 1 < editor.children.length) {
            const [child, childPath] = Editor.node(editor, [op.path[0] + 1, 0]);
            Text.isText(child) && child.text === "" && Array.isArray(child.marks) && child.marks.length > 0 && (Transforms.setNodes(editor, { marks: [] }, { at: childPath, voids: !1 }), editor.onChange());
          }
          if (op.type === "split_node" && op.path.length === 1 && op.properties._type === types.block.name && "markDefs" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0) {
            const [block, blockPath] = Editor.node(editor, [op.path[0]]);
            editor.isTextBlock(block) && block.children.length === 1 && block.markDefs && block.markDefs.length > 0 && Text.isText(block.children[0]) && block.children[0].text === "" && (!block.children[0].marks || block.children[0].marks.length === 0) && (Transforms.setNodes(editor, { markDefs: [] }, { at: blockPath }), editor.onChange());
          }
        }
        isSpan && Array.isArray(node.marks) && (!node.marks || node.marks.length > 0 && node.text === "") && (Transforms.setNodes(editor, { marks: [] }, { at: path, voids: !1 }), editor.onChange());
      }
      isTextBlock && editor.operations.some(
        (op) => ["split_node", "remove_node", "remove_text", "merge_node"].includes(op.type)
      ) && normalizeMarkDefs(editor, types);
    }, editor.apply = (op) => {
      var _a, _b;
      if (op.type === "insert_text") {
        const { selection } = editor;
        if (selection && Range.isCollapsed(selection) && (_b = (_a = Editor.marks(editor)) == null ? void 0 : _a.marks) != null && _b.some((mark) => !decorators.includes(mark))) {
          const [node] = Array.from(
            Editor.nodes(editor, {
              mode: "lowest",
              at: selection.focus,
              match: (n) => n._type === types.span.name,
              voids: !1
            })
          )[0] || [void 0];
          if (Text.isText(node) && node.text.length === selection.focus.offset && Array.isArray(node.marks) && node.marks.length > 0) {
            apply2(op), Transforms.splitNodes(editor, {
              match: Text.isText,
              at: { ...selection.focus, offset: selection.focus.offset }
            });
            const marksWithoutAnnotationMarks = ({
              ...Editor.marks(editor) || {}
            }.marks || []).filter((mark) => decorators.includes(mark));
            Transforms.setNodes(
              editor,
              { marks: marksWithoutAnnotationMarks },
              { at: Path.next(selection.focus.path) }
            ), debug$i("Inserting text at end of annotation");
            return;
          }
        }
      }
      apply2(op);
    }, editor.addMark = (mark) => {
      if (editor.selection) {
        if (Range.isExpanded(editor.selection)) {
          Transforms.setNodes(editor, {}, { match: Text.isText, split: !0 });
          const splitTextNodes = [
            ...Editor.nodes(editor, { at: editor.selection, match: Text.isText })
          ];
          if (splitTextNodes.every((node) => {
            var _a;
            return (_a = node[0].marks) == null ? void 0 : _a.includes(mark);
          }))
            return editor.removeMark(mark), editor;
          Editor.withoutNormalizing(editor, () => {
            splitTextNodes.forEach(([node, path]) => {
              const marks = [
                ...(Array.isArray(node.marks) ? node.marks : []).filter(
                  (eMark) => eMark !== mark
                ),
                mark
              ];
              Transforms.setNodes(
                editor,
                { marks },
                { at: path, match: Text.isText, split: !0, hanging: !0 }
              );
            });
          }), Editor.normalize(editor);
        } else {
          const existingMarks = {
            ...Editor.marks(editor) || {}
          }.marks || [], marks = {
            ...Editor.marks(editor) || {},
            marks: [...existingMarks, mark]
          };
          return editor.marks = marks, forceNewSelection(), editor;
        }
        editor.onChange(), forceNewSelection();
      }
      return editor;
    }, editor.removeMark = (mark) => {
      const { selection } = editor;
      if (selection) {
        if (Range.isExpanded(selection))
          Editor.withoutNormalizing(editor, () => {
            Transforms.setNodes(editor, {}, { match: Text.isText, split: !0 }), editor.selection && [
              ...Editor.nodes(editor, { at: editor.selection, match: Text.isText })
            ].forEach(([node, path]) => {
              const block = editor.children[path[0]];
              Element$1.isElement(block) && block.children.includes(node) && Transforms.setNodes(
                editor,
                {
                  marks: (Array.isArray(node.marks) ? node.marks : []).filter(
                    (eMark) => eMark !== mark
                  ),
                  _type: "span"
                },
                { at: path }
              );
            });
          }), Editor.normalize(editor);
        else {
          const existingMarks = {
            ...Editor.marks(editor) || {}
          }.marks || [], marks = {
            ...Editor.marks(editor) || {},
            marks: existingMarks.filter((eMark) => eMark !== mark)
          };
          return editor.marks = { marks: marks.marks, _type: "span" }, forceNewSelection(), editor;
        }
        editor.onChange(), forceNewSelection();
      }
      return editor;
    }, editor.pteIsMarkActive = (mark) => {
      if (!editor.selection)
        return !1;
      const selectedNodes = Array.from(
        Editor.nodes(editor, { match: Text.isText, at: editor.selection })
      );
      return Range.isExpanded(editor.selection) ? selectedNodes.every((n) => {
        var _a;
        const [node] = n;
        return (_a = node.marks) == null ? void 0 : _a.includes(mark);
      }) : ({
        ...Editor.marks(editor) || {}
      }.marks || []).includes(mark);
    }, editor.pteToggleMark = (mark) => {
      editor.pteIsMarkActive(mark) ? (debug$i(`Remove mark '${mark}'`), Editor.removeMark(editor, mark)) : (debug$i(`Add mark '${mark}'`), Editor.addMark(editor, mark, !0));
    }, editor;
  };
  function mergeSpans(editor) {
    const { selection } = editor;
    if (selection)
      for (const [node, path] of Array.from(
        Editor.nodes(editor, {
          at: Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])
        })
      ).reverse()) {
        const [parent] = path.length > 1 ? Editor.node(editor, Path.parent(path)) : [void 0], nextPath = [path[0], path[1] + 1];
        if (editor.isTextBlock(parent)) {
          const nextNode = parent.children[nextPath[1]];
          Text.isText(node) && Text.isText(nextNode) && isEqual(nextNode.marks, node.marks) && (debug$i("Merging spans"), Transforms.mergeNodes(editor, { at: nextPath, voids: !0 }), editor.onChange());
        }
      }
  }
}
function normalizeMarkDefs(editor, types) {
  const { selection } = editor;
  if (selection) {
    const blocks = Editor.nodes(editor, {
      at: selection,
      match: (n) => n._type === types.block.name
    });
    for (const [block, path] of blocks)
      if (editor.isTextBlock(block)) {
        const newMarkDefs = (block.markDefs || []).filter((def) => block.children.find((child) => Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));
        isEqual(newMarkDefs, block.markDefs) || (debug$i("Removing markDef not in use"), Transforms.setNodes(
          editor,
          {
            markDefs: newMarkDefs
          },
          { at: path }
        ), editor.onChange());
      }
  }
}
const debug$h = debugWithName("API:editable");
function createWithEditableAPI(portableTextEditor, types, keyGenerator) {
  return function(editor) {
    return portableTextEditor.setEditable({
      focus: () => {
        ReactEditor.focus(editor);
      },
      blur: () => {
        ReactEditor.blur(editor);
      },
      toggleMark: (mark) => {
        editor.pteToggleMark(mark);
      },
      toggleList: (listStyle) => {
        editor.pteToggleListItem(listStyle);
      },
      toggleBlockStyle: (blockStyle) => {
        editor.pteToggleBlockStyle(blockStyle);
      },
      isMarkActive: (mark) => {
        try {
          return editor.pteIsMarkActive(mark);
        } catch (err) {
          return console.warn(err), !1;
        }
      },
      marks: () => ({
        ...Editor.marks(editor) || {}
      }).marks || [],
      undo: () => editor.undo(),
      redo: () => editor.redo(),
      select: (selection) => {
        const slateSelection = toSlateRange(selection, editor);
        slateSelection ? Transforms.select(editor, slateSelection) : Transforms.deselect(editor), editor.onChange();
      },
      focusBlock: () => {
        if (editor.selection) {
          const block = Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
          if (block)
            return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
        }
      },
      focusChild: () => {
        if (editor.selection) {
          const block = Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
          if (block && editor.isTextBlock(block))
            return fromSlateValue(
              [block],
              types.block.name,
              KEY_TO_VALUE_ELEMENT.get(editor)
            )[0].children[editor.selection.focus.path[1]];
        }
      },
      insertChild: (type, value) => {
        var _a;
        if (!editor.selection)
          throw new Error("The editor has no selection");
        const [focusBlock] = Array.from(
          Editor.nodes(editor, {
            at: editor.selection.focus.path.slice(0, 1),
            match: (n) => n._type === types.block.name
          })
        )[0] || [void 0];
        if (!focusBlock)
          throw new Error("No focused text block");
        if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))
          throw new Error("This type cannot be inserted as a child to a text block");
        const child = toSlateValue(
          [
            {
              _key: keyGenerator(),
              _type: types.block.name,
              children: [
                {
                  _key: keyGenerator(),
                  _type: type.name,
                  ...value || {}
                }
              ]
            }
          ],
          portableTextEditor
        )[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = Node.get(editor, focusChildPath);
        return isSpanNode && focusNode._type !== types.span.name && (debug$h("Inserting span child next to inline object child, moving selection + 1"), editor.move({ distance: 1, unit: "character" })), Transforms.insertNodes(editor, child, {
          select: !0,
          at: editor.selection
        }), editor.onChange(), ((_a = toPortableTextRange(
          fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
          editor.selection,
          types
        )) == null ? void 0 : _a.focus.path) || [];
      },
      insertBlock: (type, value) => {
        var _a;
        if (!editor.selection)
          throw new Error("The editor has no selection");
        const block = toSlateValue(
          [
            {
              _key: keyGenerator(),
              _type: type.name,
              ...value || {}
            }
          ],
          portableTextEditor
        )[0], [focusBlock] = Array.from(
          Editor.nodes(editor, {
            at: editor.selection.focus.path.slice(0, 1),
            match: (n) => n._type === types.block.name
          })
        )[0] || [void 0];
        return focusBlock && isEqualToEmptyEditor([focusBlock], types) && Transforms.removeNodes(editor, { at: editor.selection }), Editor.insertNode(editor, block), editor.onChange(), ((_a = toPortableTextRange(
          fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
          editor.selection,
          types
        )) == null ? void 0 : _a.focus.path) || [];
      },
      hasBlockStyle: (style) => {
        try {
          return editor.pteHasBlockStyle(style);
        } catch {
          return !1;
        }
      },
      hasListStyle: (listStyle) => {
        try {
          return editor.pteHasListStyle(listStyle);
        } catch {
          return !1;
        }
      },
      isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),
      findByPath: (path) => {
        const slatePath = toSlateRange(
          { focus: { path, offset: 0 }, anchor: { path, offset: 0 } },
          editor
        );
        if (slatePath) {
          const [block, blockPath] = Editor.node(editor, slatePath.focus.path.slice(0, 1));
          if (block && blockPath && typeof block._key == "string") {
            if (path.length === 1 && slatePath.focus.path.length === 1)
              return [fromSlateValue([block], types.block.name)[0], [{ _key: block._key }]];
            const ptBlock = fromSlateValue(
              [block],
              types.block.name,
              KEY_TO_VALUE_ELEMENT.get(editor)
            )[0];
            if (editor.isTextBlock(ptBlock)) {
              const ptChild = ptBlock.children[slatePath.focus.path[1]];
              if (ptChild)
                return [ptChild, [{ _key: block._key }, "children", { _key: ptChild._key }]];
            }
          }
        }
        return [void 0, void 0];
      },
      findDOMNode: (element) => {
        let node;
        try {
          const [item] = Array.from(
            Editor.nodes(editor, {
              at: [],
              match: (n) => n._key === element._key
            }) || []
          )[0] || [void 0];
          node = ReactEditor.toDOMNode(editor, item);
        } catch {
        }
        return node;
      },
      activeAnnotations: () => {
        var _a;
        if (!editor.selection || editor.selection.focus.path.length < 2)
          return [];
        try {
          const activeAnnotations = [], spans = Editor.nodes(editor, {
            at: editor.selection,
            match: (node) => Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
          });
          for (const [span, path] of spans) {
            const [block] = Editor.node(editor, path, { depth: 1 });
            editor.isTextBlock(block) && ((_a = block.markDefs) == null || _a.forEach((def) => {
              Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);
            }));
          }
          return activeAnnotations;
        } catch {
          return [];
        }
      },
      isAnnotationActive: (annotationType) => {
        if (!editor.selection || editor.selection.focus.path.length < 2)
          return !1;
        try {
          const spans = [
            ...Editor.nodes(editor, {
              at: editor.selection,
              match: (node) => Text.isText(node)
            })
          ];
          if (spans.some(
            ([span]) => {
              var _a;
              return !isPortableTextSpan(span) || !span.marks || ((_a = span.marks) == null ? void 0 : _a.length) === 0;
            }
          ))
            return !1;
          const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {
            const [block] = Editor.node(editor, path, { depth: 1 });
            return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;
          }, []);
          return spans.every(([span]) => {
            var _a;
            if (!isPortableTextSpan(span)) return !1;
            const spanMarkDefs = (_a = span.marks) == null ? void 0 : _a.map(
              (markKey) => {
                var _a2;
                return (_a2 = selectionMarkDefs.find((def) => (def == null ? void 0 : def._key) === markKey)) == null ? void 0 : _a2._type;
              }
            );
            return spanMarkDefs == null ? void 0 : spanMarkDefs.includes(annotationType);
          });
        } catch {
          return !1;
        }
      },
      addAnnotation: (type, value) => {
        const { selection } = editor;
        if (selection) {
          const [block] = Editor.node(editor, selection.focus, { depth: 1 });
          if (Element$1.isElement(block) && block._type === types.block.name) {
            const annotationKey = keyGenerator();
            if (editor.isTextBlock(block)) {
              Transforms.setNodes(
                editor,
                {
                  markDefs: [
                    ...block.markDefs || [],
                    { _type: type.name, _key: annotationKey, ...value }
                  ]
                },
                { at: selection.focus }
              ), editor.onChange(), Range.isCollapsed(selection) && (editor.pteExpandToWord(), editor.onChange());
              const [textNode] = Editor.node(editor, selection.focus, { depth: 2 });
              if (editor.selection) {
                Editor.withoutNormalizing(editor, () => {
                  Transforms.setNodes(editor, {}, { match: Text.isText, split: !0 }), editor.selection && Text.isText(textNode) && (Transforms.setNodes(
                    editor,
                    {
                      marks: [...textNode.marks || [], annotationKey]
                    },
                    {
                      at: editor.selection,
                      match: (n) => n._type === types.span.name
                    }
                  ), editor.onChange());
                }), Editor.normalize(editor), editor.onChange();
                const newSelection = toPortableTextRange(
                  fromSlateValue(
                    editor.children,
                    types.block.name,
                    KEY_TO_VALUE_ELEMENT.get(editor)
                  ),
                  editor.selection,
                  types
                );
                if (newSelection && typeof block._key == "string")
                  return Editor.withoutNormalizing(editor, () => {
                    editor.selection && (Transforms.insertNodes(
                      editor,
                      [{ _type: "span", text: "", marks: [], _key: keyGenerator() }],
                      {
                        at: Range.end(editor.selection)
                      }
                    ), editor.onChange());
                  }), {
                    spanPath: newSelection.focus.path,
                    markDefPath: [{ _key: block._key }, "markDefs", { _key: annotationKey }]
                  };
              }
            }
          }
        }
      },
      delete: (selection, options) => {
        if (selection) {
          const range = toSlateRange(selection, editor);
          if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))
            throw new Error("Invalid range");
          if (range) {
            if (!(options != null && options.mode) || (options == null ? void 0 : options.mode) === "selected") {
              debug$h("Deleting content in selection"), Transforms.delete(editor, {
                at: range,
                hanging: !0,
                voids: !0
              }), editor.onChange();
              return;
            }
            (options == null ? void 0 : options.mode) === "blocks" && (debug$h("Deleting blocks touched by selection"), Transforms.removeNodes(editor, {
              at: range,
              voids: !0,
              match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && Element$1.isElement(node)
            })), (options == null ? void 0 : options.mode) === "children" && (debug$h("Deleting children touched by selection"), Transforms.removeNodes(editor, {
              at: range,
              voids: !0,
              match: (node) => node._type === types.span.name || // Text children
              !editor.isTextBlock(node) && Element$1.isElement(node)
            })), editor.children.length === 0 && (editor.children = [editor.pteCreateEmptyBlock()]), editor.onChange();
          }
        }
      },
      removeAnnotation: (type) => {
        let { selection } = editor;
        if (debug$h("Removing annotation", type), selection) {
          if (Range.isCollapsed(selection)) {
            const [node, nodePath] = Editor.node(editor, selection, { depth: 2 });
            Text.isText(node) && node.marks && typeof node.text == "string" && (Transforms.select(editor, nodePath), selection = editor.selection);
          }
          Editor.withoutNormalizing(editor, () => {
            if (selection && Range.isExpanded(selection)) {
              if (selection = editor.selection, !selection)
                return;
              [
                ...Editor.nodes(editor, {
                  at: selection,
                  match: (node) => editor.isTextBlock(node) && Array.isArray(node.markDefs) && node.markDefs.some((def) => def._type === type.name)
                })
              ].forEach(([block]) => {
                editor.isTextBlock(block) && Array.isArray(block.markDefs) && block.markDefs.filter((def) => def._type === type.name).forEach((def) => {
                  Editor.removeMark(editor, def._key);
                });
              }), normalizeMarkDefs(editor, types);
            }
          }), Editor.normalize(editor), editor.onChange();
        }
      },
      getSelection: () => {
        let ptRange = null;
        if (editor.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
          if (existing)
            return existing;
          ptRange = toPortableTextRange(
            fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
            editor.selection,
            types
          ), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
        }
        return ptRange;
      },
      getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
      isCollapsedSelection: () => !!editor.selection && Range.isCollapsed(editor.selection),
      isExpandedSelection: () => !!editor.selection && Range.isExpanded(editor.selection),
      insertBreak: () => {
        editor.insertBreak(), editor.onChange();
      },
      getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),
      isSelectionsOverlapping: (selectionA, selectionB) => {
        const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);
        return Range.isRange(rangeA) && Range.isRange(rangeB) && Range.includes(rangeA, rangeB);
      }
    }), editor;
  };
}
function createWithInsertBreak(types) {
  return function(editor) {
    const { insertBreak } = editor;
    return editor.insertBreak = () => {
      if (editor.selection) {
        const focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = Node.descendant(editor, focusBlockPath);
        if (editor.isTextBlock(focusBlock)) {
          const [, end] = Range.edges(editor.selection), isEndAtStartOfNode = Editor.isStart(editor, end, end.path), isEmptyTextBlock = focusBlock && isEqualToEmptyEditor([focusBlock], types);
          if (isEndAtStartOfNode && !isEmptyTextBlock) {
            Editor.insertNode(editor, editor.pteCreateEmptyBlock());
            const [nextBlockPath] = Path.next(focusBlockPath);
            Transforms.select(editor, {
              anchor: { path: [nextBlockPath, 0], offset: 0 },
              focus: { path: [nextBlockPath, 0], offset: 0 }
            }), editor.onChange();
            return;
          }
        }
      }
      insertBreak();
    }, editor;
  };
}
function createWithMaxBlocks(maxBlocks) {
  return function(editor) {
    const { apply: apply2 } = editor;
    return editor.apply = (operation) => {
      const rows = maxBlocks;
      rows > 0 && editor.children.length >= rows && (operation.type === "insert_node" || operation.type === "split_node") && operation.path.length === 1 || apply2(operation);
    }, editor;
  };
}
const PRESERVE_KEYS = /* @__PURE__ */ new WeakMap();
function withPreserveKeys(editor, fn) {
  const prev = isPreservingKeys(editor);
  PRESERVE_KEYS.set(editor, !0), fn(), PRESERVE_KEYS.set(editor, prev);
}
function isPreservingKeys(editor) {
  return PRESERVE_KEYS.get(editor);
}
function createWithObjectKeys(schemaTypes, keyGenerator) {
  return function(editor) {
    PRESERVE_KEYS.set(editor, !1);
    const { apply: apply2, normalizeNode } = editor;
    return editor.apply = (operation) => {
      if (operation.type === "split_node") {
        const withNewKey = !isPreservingKeys(editor) || !("_key" in operation.properties);
        operation.properties = {
          ...operation.properties,
          ...withNewKey ? { _key: keyGenerator() } : {}
        };
      }
      if (operation.type === "insert_node") {
        const withNewKey = !isPreservingKeys(editor) || !("_key" in operation.node);
        Editor.isEditor(operation.node) || (operation.node = {
          ...operation.node,
          ...withNewKey ? { _key: keyGenerator() } : {}
        });
      }
      apply2(operation);
    }, editor.normalizeNode = (entry) => {
      const [node, path] = entry;
      if (Element$1.isElement(node) && node._type === schemaTypes.block.name) {
        node._key || Transforms.setNodes(editor, { _key: keyGenerator() }, { at: path });
        for (const [child, childPath] of Node.children(editor, path))
          if (!child._key) {
            Transforms.setNodes(editor, { _key: keyGenerator() }, { at: childPath });
            return;
          }
      }
      normalizeNode(entry);
    }, editor;
  };
}
const BEFORE = "before", AFTER = "after";
function insert(array, position, index, ...args) {
  if (position !== BEFORE && position !== AFTER)
    throw new Error(`Invalid position "${position}", must be either ${BEFORE} or ${AFTER}`);
  const items = flatten(...args);
  if (array.length === 0)
    return items;
  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === "after" ? idx + 1 : idx, copy = array.slice();
  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;
}
function flatten(...values) {
  return values.reduce((prev, item) => prev.concat(item), []);
}
const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function move(arr, from, to) {
  const nextValue = arr.slice(), val = nextValue[from];
  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;
}
function findTargetIndex(array, pathSegment) {
  if (typeof pathSegment == "number")
    return pathSegment;
  const index = findIndex(array, pathSegment);
  return index === -1 ? !1 : index;
}
function apply$3(value, patch) {
  const nextValue = value.slice();
  if (patch.path.length === 0) {
    if (patch.type === "setIfMissing") {
      if (!Array.isArray(patch.value))
        throw new Error("Cannot set value of an array to a non-array");
      return value === void 0 ? patch.value : value;
    } else if (patch.type === "set") {
      if (!Array.isArray(patch.value))
        throw new Error("Cannot set value of an array to a non-array");
      return patch.value;
    } else {
      if (patch.type === "unset")
        return;
      if (patch.type === "move") {
        if (!patch.value || !hasOwn(patch.value, "from") || !hasOwn(patch.value, "to"))
          throw new Error(
            `Invalid value of 'move' patch. Expected a value with "from" and "to" indexes, instead got: ${JSON.stringify(
              patch.value
            )}`
          );
        return move(nextValue, patch.value.from, patch.value.to);
      }
    }
    throw new Error(`Invalid array operation: ${patch.type}`);
  }
  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);
  if (index === !1)
    return nextValue;
  if (tail.length === 0) {
    if (patch.type === "insert") {
      const { position, items } = patch;
      return insert(value, position, index, items);
    } else if (patch.type === "unset") {
      if (typeof index != "number")
        throw new Error(`Expected array index to be a number, instead got "${index}"`);
      return nextValue.splice(index, 1), nextValue;
    }
  }
  return nextValue[index] = _apply(nextValue[index], {
    ...patch,
    path: tail
  }), nextValue;
}
function apply$2(value, patch) {
  const nextValue = clone(value);
  if (patch.path.length === 0) {
    if (patch.type === "set") {
      if (!isObject(patch.value))
        throw new Error("Cannot set value of an object to a non-object");
      return patch.value;
    } else {
      if (patch.type === "unset")
        return;
      if (patch.type === "setIfMissing")
        return value === void 0 ? patch.value : value;
    }
    throw new Error(`Invalid object operation: ${patch.type}`);
  }
  const [head, ...tail] = patch.path;
  if (typeof head != "string")
    throw new Error(`Expected field name to be a string, instad got: ${head}`);
  return tail.length === 0 && patch.type === "unset" ? omit(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {
    ...patch,
    path: tail
  }), nextValue);
}
const OPERATIONS$1 = {
  replace(_currentValue, nextValue) {
    return nextValue;
  },
  set(_currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(_currentValue, _nextValue) {
  },
  inc(currentValue, nextValue) {
    return currentValue + nextValue;
  },
  dec(currentValue, nextValue) {
    return currentValue - nextValue;
  }
}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function apply$1(value, patch) {
  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type))
    throw new Error(
      `Received patch of unsupported type: "${JSON.stringify(
        patch.type
      )}" for primitives. This is most likely a bug.`
    );
  if (patch.path.length > 0)
    throw new Error(
      `Cannot apply deep operations on primitive values. Received patch with type "${patch.type}" and path "${patch.path.map((path) => JSON.stringify(path)).join(".")} that targeted the value "${JSON.stringify(value)}"`
    );
  return OPERATIONS$1[patch.type](value, patch.value);
}
const OPERATIONS = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
  },
  diffMatchPatch(currentValue, nextValue) {
    const [result] = apply$4(parse(nextValue), currentValue, {
      allowExceedingIndices: !0
    });
    return result;
  }
}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function apply(value, patch) {
  if (!SUPPORTED_PATCH_TYPES.includes(patch.type))
    throw new Error(
      `Received patch of unsupported type: "${JSON.stringify(
        patch.type
      )}" for string. This is most likely a bug.`
    );
  if (patch.path.length > 0)
    throw new Error(
      `Cannot apply deep operations on string values. Received patch with type "${patch.type}" and path "${patch.path.join(".")} that targeted the value "${JSON.stringify(value)}"`
    );
  const func = OPERATIONS[patch.type];
  if (func)
    return func(value, patch.value);
  throw new Error("Unknown patch type");
}
function applyAll(value, patches) {
  return patches.reduce(_apply, value);
}
function applyPatch(value, patch) {
  return Array.isArray(value) ? apply$3(value, patch) : isString(value) ? apply(value, patch) : isObject(value) ? apply$2(value, patch) : apply$1(value, patch);
}
function _apply(value, patch) {
  return applyPatch(value, patch);
}
const debug$g = debugWithName("applyPatches"), debugVerbose$3 = debug$g.enabled && !0;
function createApplyPatch(schemaTypes) {
  let previousPatch;
  return function(editor, patch) {
    let changed = !1;
    debugVerbose$3 && (debug$g(`

NEW PATCH =============================================================`), debug$g(JSON.stringify(patch, null, 2)));
    try {
      switch (patch.type) {
        case "insert":
          changed = insertPatch(editor, patch, schemaTypes);
          break;
        case "unset":
          changed = unsetPatch(editor, patch, previousPatch);
          break;
        case "set":
          changed = setPatch(editor, patch);
          break;
        case "diffMatchPatch":
          changed = diffMatchPatch(editor, patch);
          break;
        default:
          debug$g("Unhandled patch", patch.type);
      }
    } catch (err) {
      console.error(err);
    }
    return previousPatch = patch, changed;
  };
}
function diffMatchPatch(editor, patch) {
  const { block, child, childPath } = findBlockAndChildFromPath(editor, patch.path);
  if (!block)
    return debug$g("Block not found"), !1;
  if (!child || !childPath)
    return debug$g("Child not found"), !1;
  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === "children" && patch.path[3] === "text") || !Text.isText(child))
    return !1;
  const patches = parse(patch.value), [newValue] = apply$4(patches, child.text, { allowExceedingIndices: !0 }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);
  debugState(editor, "before");
  let offset = 0;
  for (const [op, text] of diff$1)
    op === DIFF_INSERT ? (editor.apply({ type: "insert_text", path: childPath, offset, text }), offset += text.length) : op === DIFF_DELETE ? editor.apply({ type: "remove_text", path: childPath, offset, text }) : op === DIFF_EQUAL && (offset += text.length);
  return debugState(editor, "after"), !0;
}
function insertPatch(editor, patch, schemaTypes) {
  const {
    block: targetBlock,
    child: targetChild,
    blockPath: targetBlockPath,
    childPath: targetChildPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (!targetBlock || !targetBlockPath)
    return debug$g("Block not found"), !1;
  if (patch.path.length > 1 && patch.path[1] !== "children")
    return debug$g("Ignoring patch targeting void value"), !1;
  if (patch.path.length === 1) {
    const { items: items2, position: position2 } = patch, blocksToInsert = toSlateValue(
      items2,
      { schemaTypes },
      KEY_TO_SLATE_ELEMENT.get(editor)
    ), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === "after" ? targetBlockIndex + 1 : targetBlockIndex;
    return debug$g(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, "before"), Transforms.insertNodes(editor, blocksToInsert, { at: [normalizedIdx2] }), debugState(editor, "after"), !0;
  }
  const { items, position } = patch;
  if (!targetChild || !targetChildPath)
    return debug$g("Child not found"), !1;
  const childrenToInsert = targetBlock && toSlateValue(
    [{ ...targetBlock, children: items }],
    { schemaTypes },
    KEY_TO_SLATE_ELEMENT.get(editor)
  ), targetChildIndex = targetChildPath[1], normalizedIdx = position === "after" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];
  return debug$g(`Inserting children at path ${childInsertPath}`), debugState(editor, "before"), childrenToInsert && Element$1.isElement(childrenToInsert[0]) && Transforms.insertNodes(editor, childrenToInsert[0].children, { at: childInsertPath }), debugState(editor, "after"), !0;
}
function setPatch(editor, patch) {
  let value = patch.value;
  typeof patch.path[3] == "string" && (value = {}, value[patch.path[3]] = patch.value);
  const { block, blockPath, child, childPath } = findBlockAndChildFromPath(editor, patch.path);
  if (!block)
    return debug$g("Block not found"), !1;
  const isTextBlock = editor.isTextBlock(block);
  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== "children")
    return debug$g("Ignoring setting void value"), !1;
  if (debugState(editor, "before"), isTextBlock && child && childPath) {
    if (Text.isText(value) && Text.isText(child)) {
      const newText = child.text;
      value.text !== newText && (debug$g("Setting text property"), editor.apply({
        type: "remove_text",
        path: childPath,
        offset: 0,
        text: newText
      }), editor.apply({
        type: "insert_text",
        path: childPath,
        offset: 0,
        text: value.text
      }), editor.onChange());
    } else
      debug$g("Setting non-text property"), editor.apply({
        type: "set_node",
        path: childPath,
        properties: {},
        newProperties: value
      });
    return !0;
  } else if (Element$1.isElement(block) && patch.path.length === 1 && blockPath) {
    debug$g("Setting block property");
    const { children, ...nextRest } = value, { children: prevChildren, ...prevRest } = block || { children: void 0 };
    editor.apply({
      type: "set_node",
      path: blockPath,
      properties: { ...prevRest },
      newProperties: nextRest
    }), debug$g("Setting children"), block.children.forEach((c, cIndex) => {
      editor.apply({
        type: "remove_node",
        path: blockPath.concat(block.children.length - 1 - cIndex),
        node: c
      });
    }), Array.isArray(children) && children.forEach((c, cIndex) => {
      editor.apply({
        type: "insert_node",
        path: blockPath.concat(cIndex),
        node: c
      });
    });
  } else if (block && "value" in block) {
    const newVal = applyAll([block.value], [patch])[0];
    return Transforms.setNodes(editor, { ...block, value: newVal }, { at: blockPath }), !0;
  }
  return debugState(editor, "after"), !0;
}
function unsetPatch(editor, patch, previousPatch) {
  if (patch.path.length === 0) {
    debug$g("Removing everything"), debugState(editor, "before");
    const previousSelection = editor.selection;
    return Transforms.deselect(editor), editor.children.forEach((c, i) => {
      Transforms.removeNodes(editor, { at: [i] });
    }), Transforms.insertNodes(editor, editor.pteCreateEmptyBlock()), previousSelection && Transforms.select(editor, {
      anchor: { path: [0, 0], offset: 0 },
      focus: { path: [0, 0], offset: 0 }
    }), editor.onChange(), debugState(editor, "after"), !0;
  }
  const { block, blockPath, child, childPath } = findBlockAndChildFromPath(editor, patch.path);
  if (patch.path.length === 1) {
    if (!block || !blockPath)
      return debug$g("Block not found"), !1;
    const blockIndex = blockPath[0];
    return debug$g(`Removing block at path [${blockIndex}]`), debugState(editor, "before"), Transforms.removeNodes(editor, { at: [blockIndex] }), debugState(editor, "after"), !0;
  }
  return editor.isTextBlock(block) && patch.path[1] === "children" && patch.path.length === 3 ? !child || !childPath ? (debug$g("Child not found"), !1) : (debug$g(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, "before"), debugVerbose$3 && debug$g(`Removing child at path ${JSON.stringify(childPath)}`), Transforms.removeNodes(editor, { at: childPath }), debugState(editor, "after"), !0) : !1;
}
function isKeyedSegment(segment) {
  return typeof segment == "object" && "_key" in segment;
}
function debugState(editor, stateName) {
  debugVerbose$3 && (debug$g(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$g(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));
}
function findBlockFromPath(editor, path) {
  let blockIndex = -1;
  const block = editor.children.find((node, index) => {
    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];
    return isMatch && (blockIndex = index), isMatch;
  });
  return block ? { block, path: [blockIndex] } : {};
}
function findBlockAndChildFromPath(editor, path) {
  const { block, path: blockPath } = findBlockFromPath(editor, path);
  if (!(Element$1.isElement(block) && path[1] === "children"))
    return { block, blockPath, child: void 0, childPath: void 0 };
  let childIndex = -1;
  const child = block.children.find((node, index) => {
    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];
    return isMatch && (childIndex = index), isMatch;
  });
  return child ? { block, child, blockPath, childPath: blockPath == null ? void 0 : blockPath.concat(childIndex) } : { block, blockPath, child: void 0, childPath: void 0 };
}
function withRemoteChanges(editor, fn) {
  const prev = isChangingRemotely(editor) || !1;
  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);
}
function isChangingRemotely(editor) {
  return IS_PROCESSING_REMOTE_CHANGES.get(editor);
}
function isChangingLocally(editor) {
  return IS_PROCESSING_LOCAL_CHANGES.get(editor);
}
const PATCHING = /* @__PURE__ */ new WeakMap();
function withoutPatching(editor, fn) {
  const prev = isPatching(editor);
  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);
}
function isPatching(editor) {
  return PATCHING.get(editor);
}
const debug$f = debugWithName("plugin:withUndoRedo"), debugVerbose$2 = debug$f.enabled && !1, SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {
  const state = SAVING.get(editor);
  return state === void 0 ? !0 : state;
}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);
function createWithUndoRedo(options) {
  const { readOnly, patches$, blockSchemaType } = options;
  return (editor) => {
    let previousSnapshot = fromSlateValue(
      editor.children,
      blockSchemaType.name
    );
    const remotePatches = getRemotePatches(editor);
    patches$ && editor.subscriptions.push(() => {
      debug$f("Subscribing to patches");
      const sub = patches$.subscribe(({ patches, snapshot }) => {
        let reset = !1;
        patches.forEach((patch) => {
          if (!reset && patch.origin !== "local" && remotePatches) {
            if (patch.type === "unset" && patch.path.length === 0) {
              debug$f("Someone else cleared the content, resetting undo/redo history"), editor.history = { undos: [], redos: [] }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;
              return;
            }
            remotePatches.push({ patch, time: /* @__PURE__ */ new Date(), snapshot, previousSnapshot });
          }
        }), previousSnapshot = snapshot;
      });
      return () => {
        debug$f("Unsubscribing to patches"), sub.unsubscribe();
      };
    }), editor.history = { undos: [], redos: [] };
    const { apply: apply2 } = editor;
    return editor.apply = (op) => {
      if (readOnly) {
        apply2(op);
        return;
      }
      const { operations, history } = editor, { undos } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor);
      let merge = !0;
      if (save) {
        if (step ? operations.length === 0 && (merge = shouldMerge(op, lastOp) || overwrite) : merge = !1, step && merge)
          step.operations.push(op);
        else {
          const newStep = {
            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],
            timestamp: /* @__PURE__ */ new Date()
          };
          undos.push(newStep), debug$f("Created new undo step", step);
        }
        for (; undos.length > UNDO_STEP_LIMIT; )
          undos.shift();
        shouldClear(op) && (history.redos = []);
      }
      apply2(op);
    }, editor.undo = () => {
      if (readOnly)
        return;
      const { undos } = editor.history;
      if (undos.length > 0) {
        const step = undos[undos.length - 1];
        if (debug$f("Undoing", step), step.operations.length > 0) {
          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);
          let transformedOperations = step.operations;
          otherPatches.forEach((item) => {
            transformedOperations = flatten$1(
              transformedOperations.map(
                (op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)
              )
            );
          });
          try {
            Editor.withoutNormalizing(editor, () => {
              withPreserveKeys(editor, () => {
                withoutSaving(editor, () => {
                  transformedOperations.map(Operation.inverse).reverse().forEach((op) => {
                    editor.apply(op);
                  });
                });
              });
            }), editor.normalize(), editor.onChange();
          } catch (err) {
            debug$f("Could not perform undo step", err), remotePatches.splice(0, remotePatches.length), Transforms.deselect(editor), editor.history = { undos: [], redos: [] }, SAVING.set(editor, !0), editor.onChange();
            return;
          }
          editor.history.redos.push(step), editor.history.undos.pop();
        }
      }
    }, editor.redo = () => {
      if (readOnly)
        return;
      const { redos } = editor.history;
      if (redos.length > 0) {
        const step = redos[redos.length - 1];
        if (debug$f("Redoing", step), step.operations.length > 0) {
          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);
          let transformedOperations = step.operations;
          otherPatches.forEach((item) => {
            transformedOperations = flatten$1(
              transformedOperations.map(
                (op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)
              )
            );
          });
          try {
            Editor.withoutNormalizing(editor, () => {
              withPreserveKeys(editor, () => {
                withoutSaving(editor, () => {
                  transformedOperations.forEach((op) => {
                    editor.apply(op);
                  });
                });
              });
            }), editor.normalize(), editor.onChange();
          } catch (err) {
            debug$f("Could not perform redo step", err), remotePatches.splice(0, remotePatches.length), Transforms.deselect(editor), editor.history = { undos: [], redos: [] }, SAVING.set(editor, !0), editor.onChange();
            return;
          }
          editor.history.undos.push(step), editor.history.redos.pop();
        }
      }
    }, editor;
  };
}
function transformOperation(editor, patch, operation, snapshot, previousSnapshot) {
  debugVerbose$2 && (debug$f(`Adjusting '${operation.type}' operation paths for '${patch.type}' patch`), debug$f(`Operation ${JSON.stringify(operation)}`), debug$f(`Patch ${JSON.stringify(patch)}`));
  const transformedOperation = { ...operation };
  if (patch.type === "insert" && patch.path.length === 1) {
    const insertBlockIndex = (snapshot || []).findIndex(
      (blk) => isEqual({ _key: blk._key }, patch.path[0])
    );
    return debug$f(
      `Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`
    ), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];
  }
  if (patch.type === "unset" && patch.path.length === 1) {
    const unsetBlockIndex = (previousSnapshot || []).findIndex(
      (blk) => isEqual({ _key: blk._key }, patch.path[0])
    );
    return "path" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$f("Skipping transformation that targeted removed block"), []) : (debugVerbose$2 && (debug$f(`Selection ${JSON.stringify(editor.selection)}`), debug$f(
      `Adjusting block path (-1) for '${transformedOperation.type}' operation and patch '${patch.type}'`
    )), [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)]);
  }
  if (patch.type === "unset" && patch.path.length === 0)
    return debug$f(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];
  if (patch.type === "diffMatchPatch") {
    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);
    return !operationTargetBlock || !isEqual({ _key: operationTargetBlock._key }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {
      var _a, _b, _c, _d;
      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;
      const { diffs } = diffPatch;
      if (diffs.forEach((diff2, index) => {
        const [diffType, text] = diff2;
        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));
      }), transformedOperation.type === "insert_text" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "remove_text" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "set_selection") {
        const currentFocus = (_a = transformedOperation.properties) != null && _a.focus ? { ...transformedOperation.properties.focus } : void 0, currentAnchor = (_b = transformedOperation == null ? void 0 : transformedOperation.properties) != null && _b.anchor ? { ...transformedOperation.properties.anchor } : void 0, newFocus = (_c = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _c.focus ? { ...transformedOperation.newProperties.focus } : void 0, newAnchor = (_d = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _d.anchor ? { ...transformedOperation.newProperties.anchor } : void 0;
        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {
          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);
        }), currentFocus && currentAnchor && (transformedOperation.properties = {
          focus: currentFocus,
          anchor: currentAnchor
        }), newFocus && newAnchor && (transformedOperation.newProperties = {
          focus: newFocus,
          anchor: newAnchor
        }));
      }
    }), [transformedOperation]);
  }
  return [transformedOperation];
}
function adjustBlockPath(operation, level, blockIndex) {
  var _a, _b, _c, _d;
  const transformedOperation = { ...operation };
  if (blockIndex >= 0 && transformedOperation.type !== "set_selection" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {
    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];
    transformedOperation.path = newPath;
  }
  if (transformedOperation.type === "set_selection") {
    const currentFocus = (_a = transformedOperation.properties) != null && _a.focus ? { ...transformedOperation.properties.focus } : void 0, currentAnchor = (_b = transformedOperation == null ? void 0 : transformedOperation.properties) != null && _b.anchor ? { ...transformedOperation.properties.anchor } : void 0, newFocus = (_c = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _c.focus ? { ...transformedOperation.newProperties.focus } : void 0, newAnchor = (_d = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _d.anchor ? { ...transformedOperation.newProperties.anchor } : void 0;
    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {
      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);
    }), currentFocus && currentAnchor && (transformedOperation.properties = {
      focus: currentFocus,
      anchor: currentAnchor
    }), newFocus && newAnchor && (transformedOperation.newProperties = {
      focus: newFocus,
      anchor: newAnchor
    }));
  }
  return transformedOperation;
}
const shouldMerge = (op, prev) => !!(op.type === "set_selection" || prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path) && op.text !== " " || prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === "set_selection" && prev.type === "set_selection"), shouldClear = (op) => op.type !== "set_selection";
function withoutSaving(editor, fn) {
  const prev = isSaving(editor);
  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
  return {
    type: "set_selection",
    properties: { ...editor.selection },
    newProperties: { ...editor.selection }
  };
}
function findOperationTargetBlock(editor, operation) {
  let block;
  return operation.type === "set_selection" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : "path" in operation && (block = editor.children[operation.path[0]]), block;
}
const debug$e = debugWithName("plugin:withPatches");
function createWithPatches({
  change$,
  patches$,
  patchFunctions,
  readOnly,
  schemaTypes
}) {
  let previousChildren;
  const applyPatch2 = createApplyPatch(schemaTypes);
  return function(editor) {
    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];
    const { apply: apply2 } = editor;
    let bufferedPatches = [];
    const handleBufferedRemotePatches = () => {
      if (bufferedPatches.length === 0)
        return;
      const patches = bufferedPatches;
      bufferedPatches = [];
      let changed = !1;
      withRemoteChanges(editor, () => {
        Editor.withoutNormalizing(editor, () => {
          withoutPatching(editor, () => {
            withoutSaving(editor, () => {
              withPreserveKeys(editor, () => {
                patches.forEach((patch) => {
                  debug$e.enabled && debug$e(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch2(editor, patch);
                });
              });
            });
          });
        }), changed && (editor.normalize(), editor.onChange());
      });
    }, handlePatches = ({ patches }) => {
      const remotePatches = patches.filter((p) => p.origin !== "local");
      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());
    };
    return patches$ && editor.subscriptions.push(() => {
      debug$e("Subscribing to patches$");
      const sub = patches$.subscribe(handlePatches);
      return () => {
        debug$e("Unsubscribing to patches$"), sub.unsubscribe();
      };
    }), editor.apply = (operation) => {
      if (readOnly)
        return apply2(operation), editor;
      let patches = [];
      previousChildren = editor.children;
      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);
      apply2(operation);
      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);
      if (!isPatching(editor))
        return editor;
      switch (editorWasEmpty && !editorIsEmpty && operation.type !== "set_selection" && patches.push(insert$1(previousChildren, "before", [0])), operation.type) {
        case "insert_text":
          patches = [
            ...patches,
            ...patchFunctions.insertTextPatch(editor, operation, previousChildren)
          ];
          break;
        case "remove_text":
          patches = [
            ...patches,
            ...patchFunctions.removeTextPatch(editor, operation, previousChildren)
          ];
          break;
        case "remove_node":
          patches = [
            ...patches,
            ...patchFunctions.removeNodePatch(editor, operation, previousChildren)
          ];
          break;
        case "split_node":
          patches = [
            ...patches,
            ...patchFunctions.splitNodePatch(editor, operation, previousChildren)
          ];
          break;
        case "insert_node":
          patches = [
            ...patches,
            ...patchFunctions.insertNodePatch(editor, operation, previousChildren)
          ];
          break;
        case "set_node":
          patches = [
            ...patches,
            ...patchFunctions.setNodePatch(editor, operation, previousChildren)
          ];
          break;
        case "merge_node":
          patches = [
            ...patches,
            ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)
          ];
          break;
        case "move_node":
          patches = [
            ...patches,
            ...patchFunctions.moveNodePatch(editor, operation, previousChildren)
          ];
          break;
      }
      return !editorWasEmpty && editorIsEmpty && ["merge_node", "set_node", "remove_text", "remove_node"].includes(operation.type) && (patches = [...patches, unset([])], change$.next({
        type: "unset",
        previousValue: fromSlateValue(
          previousChildren,
          schemaTypes.block.name,
          KEY_TO_VALUE_ELEMENT.get(editor)
        )
      })), editorWasEmpty && patches.length > 0 && (patches = [setIfMissing([], []), ...patches]), patches.length > 0 && patches.forEach((patch) => {
        change$.next({
          type: "patch",
          patch: { ...patch, origin: "local" }
        });
      }), editor;
    }, editor;
  };
}
const debug$d = debugWithName("plugin:withPlaceholderBlock");
function createWithPlaceholderBlock() {
  return function(editor) {
    const { apply: apply2 } = editor;
    return editor.apply = (op) => {
      if (op.type === "remove_node") {
        const node = op.node;
        if (op.path[0] === 0 && Editor.isVoid(editor, node)) {
          const nextPath = Path.next(op.path);
          editor.children[nextPath[0]] || (debug$d("Adding placeholder block"), Editor.insertNode(editor, editor.pteCreateEmptyBlock()));
        }
      }
      apply2(op);
    }, editor;
  };
}
const debug$c = debugWithName("plugin:withPortableTextBlockStyle");
function createWithPortableTextBlockStyle(types) {
  const defaultStyle = types.styles[0].value;
  return function(editor) {
    const { normalizeNode } = editor;
    return editor.normalizeNode = (nodeEntry) => {
      normalizeNode(nodeEntry);
      const [, path] = nodeEntry;
      for (const op of editor.operations)
        if (op.type === "split_node" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !Path.equals(path, op.path)) {
          const [child] = Editor.node(editor, [op.path[0] + 1, 0]);
          if (Text.isText(child) && child.text === "") {
            debug$c(`Normalizing split node to ${defaultStyle} style`, op), Transforms.setNodes(editor, { style: defaultStyle }, { at: [op.path[0] + 1], voids: !1 });
            break;
          }
        }
    }, editor.pteHasBlockStyle = (style) => editor.selection ? [
      ...Editor.nodes(editor, {
        at: editor.selection,
        match: (node) => editor.isTextBlock(node) && node.style === style
      })
    ].length > 0 : !1, editor.pteToggleBlockStyle = (blockStyle) => {
      editor.selection && ([
        ...Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => editor.isTextBlock(node)
        })
      ].forEach(([node, path]) => {
        editor.isTextBlock(node) && node.style === blockStyle ? (debug$c(`Unsetting block style '${blockStyle}'`), Transforms.setNodes(editor, { ...node, style: defaultStyle }, {
          at: path
        })) : (blockStyle ? debug$c(`Setting style '${blockStyle}'`) : debug$c("Setting default style", defaultStyle), Transforms.setNodes(
          editor,
          {
            ...node,
            style: blockStyle || defaultStyle
          },
          { at: path }
        ));
      }), editor.onChange());
    }, editor;
  };
}
const debug$b = debugWithName("plugin:withPortableTextLists"), MAX_LIST_LEVEL = 10;
function createWithPortableTextLists(types) {
  return function(editor) {
    return editor.pteToggleListItem = (listItemStyle) => {
      editor.pteHasListStyle(listItemStyle) ? (debug$b(`Remove list item '${listItemStyle}'`), editor.pteUnsetListItem(listItemStyle)) : (debug$b(`Add list item '${listItemStyle}'`), editor.pteSetListItem(listItemStyle));
    }, editor.pteUnsetListItem = (listItemStyle) => {
      editor.selection && [
        ...Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => Element$1.isElement(node) && node._type === types.block.name
        })
      ].forEach(([node, path]) => {
        if (editor.isListBlock(node)) {
          const { listItem, level, ...rest } = node, newNode = {
            ...rest,
            listItem: void 0,
            level: void 0
          };
          debug$b(`Unsetting list '${listItemStyle}'`), Transforms.setNodes(editor, newNode, { at: path });
        }
      });
    }, editor.pteSetListItem = (listItemStyle) => {
      editor.selection && [
        ...Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => editor.isTextBlock(node)
        })
      ].forEach(([node, path]) => {
        debug$b(`Setting list '${listItemStyle}'`), Transforms.setNodes(
          editor,
          {
            ...node,
            level: 1,
            listItem: listItemStyle || types.lists[0] && types.lists[0].value
          },
          { at: path }
        );
      });
    }, editor.pteEndList = () => {
      if (!editor.selection)
        return !1;
      const selectedBlocks = [
        ...Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => Element$1.isElement(node) && editor.isListBlock(node) && node.children.length === 1 && Text.isText(node.children[0]) && node.children[0].text === ""
        })
      ];
      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {
        Element$1.isElement(node) && (debug$b("Unset list"), Transforms.setNodes(
          editor,
          {
            ...node,
            level: void 0,
            listItem: void 0
          },
          { at: path }
        ));
      }), !0);
    }, editor.pteIncrementBlockLevels = (reverse) => {
      if (!editor.selection)
        return !1;
      const selectedBlocks = [
        ...Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => !!editor.isListBlock(node)
        })
      ];
      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {
        if (editor.isListBlock(node)) {
          let level = node.level || 1;
          reverse ? (level--, debug$b("Decrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))) : (level++, debug$b("Incrementing list level", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))), Transforms.setNodes(
            editor,
            { level: Math.min(MAX_LIST_LEVEL, Math.max(1, level)) },
            { at: path }
          );
        }
      }), !0);
    }, editor.pteHasListStyle = (listStyle) => {
      if (!editor.selection)
        return !1;
      const selectedBlocks = [
        ...Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => editor.isTextBlock(node)
        })
      ];
      return selectedBlocks.length > 0 ? selectedBlocks.every(
        ([node]) => editor.isListBlock(node) && node.listItem === listStyle
      ) : !1;
    }, editor;
  };
}
const debug$a = debugWithName("plugin:withPortableTextSelections"), debugVerbose$1 = debug$a.enabled && !1;
function createWithPortableTextSelections(change$, types) {
  let prevSelection = null;
  return function(editor) {
    const emitPortableTextSelection = () => {
      if (prevSelection !== editor.selection) {
        let ptRange = null;
        if (editor.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
          if (existing)
            ptRange = existing;
          else {
            const value = editor.children;
            ptRange = toPortableTextRange(value, editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
          }
        }
        debugVerbose$1 && debug$a(
          `Emitting selection ${JSON.stringify(ptRange || null)} (${JSON.stringify(
            editor.selection
          )})`
        ), ptRange ? change$.next({ type: "selection", selection: ptRange }) : change$.next({ type: "selection", selection: null });
      }
      prevSelection = editor.selection;
    }, { onChange } = editor;
    return editor.onChange = () => {
      const hasChanges = editor.operations.length > 0;
      onChange(), hasChanges && emitPortableTextSelection();
    }, editor;
  };
}
const debug$9 = debugWithName("plugin:withSchemaTypes");
function createWithSchemaTypes({
  schemaTypes,
  keyGenerator
}) {
  return function(editor) {
    editor.isTextBlock = (value) => isPortableTextTextBlock(value) && value._type === schemaTypes.block.name, editor.isTextSpan = (value) => isPortableTextSpan(value) && value._type == schemaTypes.span.name, editor.isListBlock = (value) => isPortableTextListBlock(value) && value._type === schemaTypes.block.name, editor.isVoid = (element) => schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj) => obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type) && "__inline" in element && element.__inline === !0;
    const { normalizeNode } = editor;
    return editor.normalizeNode = (entry) => {
      const [node, path] = entry;
      if (node._type === void 0 && path.length === 2) {
        debug$9("Setting span type on text node without a type");
        const span = node, key = span._key || keyGenerator();
        Transforms.setNodes(editor, { ...span, _type: schemaTypes.span.name, _key: key }, { at: path });
      }
      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {
        debug$9("Setting missing key on child node without a key");
        const key = keyGenerator();
        Transforms.setNodes(editor, { _key: key }, { at: path });
      }
      normalizeNode(entry);
    }, editor;
  };
}
const debug$8 = debugWithName("plugin:withUtils");
function createWithUtils({ schemaTypes, keyGenerator, portableTextEditor }) {
  return function(editor) {
    return editor.pteExpandToWord = () => {
      const { selection } = editor;
      if (selection && !Range.isExpanded(selection)) {
        const [textNode] = Editor.node(editor, selection.focus, { depth: 2 });
        if (!textNode || !Text.isText(textNode) || textNode.text.length === 0) {
          debug$8("pteExpandToWord: Can't expand to word here");
          return;
        }
        const { focus } = selection, focusOffset = focus.offset, charsBefore = textNode.text.slice(0, focusOffset), charsAfter = textNode.text.slice(focusOffset, -1), isEmpty = (str) => str.match(/\s/g), whiteSpaceBeforeIndex = charsBefore.split("").reverse().findIndex((str) => isEmpty(str)), newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0, whiteSpaceAfterIndex = charsAfter.split("").findIndex((obj) => isEmpty(obj)), newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);
        if (!(newStartOffset === newEndOffset || isNaN(newStartOffset) || isNaN(newEndOffset))) {
          debug$8("pteExpandToWord: Expanding to focused word"), Transforms.setSelection(editor, {
            anchor: { ...selection.anchor, offset: newStartOffset },
            focus: { ...selection.focus, offset: newEndOffset }
          });
          return;
        }
        debug$8("pteExpandToWord: Can't expand to word here");
      }
    }, editor.pteCreateEmptyBlock = () => toSlateValue(
      [
        {
          _type: schemaTypes.block.name,
          _key: keyGenerator(),
          style: schemaTypes.styles[0].value || "normal",
          markDefs: [],
          children: [
            {
              _type: "span",
              _key: keyGenerator(),
              text: "",
              marks: []
            }
          ]
        }
      ],
      portableTextEditor
    )[0], editor;
  };
}
const debug$7 = debugWithName("plugin:withHotKeys"), DEFAULT_HOTKEYS = {
  marks: {
    "mod+b": "strong",
    "mod+i": "em",
    "mod+u": "underline",
    "mod+'": "code"
  },
  custom: {}
};
function createWithHotkeys(types, portableTextEditor, hotkeysFromOptions) {
  const reservedHotkeys = ["enter", "tab", "shift", "delete", "end"], activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;
  return function(editor) {
    return editor.pteWithHotKeys = (event) => {
      var _a, _b, _c, _d;
      Object.keys(activeHotkeys).forEach((cat) => {
        if (cat === "marks")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              event.preventDefault();
              const possibleMark = activeHotkeys[cat];
              if (possibleMark) {
                const mark = possibleMark[hotkey];
                debug$7(`HotKey ${hotkey} to toggle ${mark}`), editor.pteToggleMark(mark);
              }
            }
          }
        if (cat === "custom")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              const possibleCommand = activeHotkeys[cat];
              if (possibleCommand) {
                const command = possibleCommand[hotkey];
                command(event, portableTextEditor);
              }
            }
          }
      });
      const isEnter = isHotkey("enter", event.nativeEvent), isTab = isHotkey("tab", event.nativeEvent), isShiftEnter = isHotkey("shift+enter", event.nativeEvent), isShiftTab = isHotkey("shift+tab", event.nativeEvent), isBackspace = isHotkey("backspace", event.nativeEvent), isDelete = isHotkey("delete", event.nativeEvent), isArrowDown = isHotkey("down", event.nativeEvent), isArrowUp = isHotkey("up", event.nativeEvent);
      if (isArrowDown && editor.selection) {
        const focusBlock = Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
        if (focusBlock && Editor.isVoid(editor, focusBlock)) {
          const nextPath = Path.next(editor.selection.focus.path.slice(0, 1));
          if (!Node.has(editor, nextPath)) {
            Transforms.insertNodes(editor, editor.pteCreateEmptyBlock(), { at: nextPath }), editor.onChange();
            return;
          }
        }
      }
      if (isArrowUp && editor.selection) {
        const isFirstBlock = editor.selection.focus.path[0] === 0, focusBlock = Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
        if (isFirstBlock && focusBlock && Editor.isVoid(editor, focusBlock)) {
          Transforms.insertNodes(editor, editor.pteCreateEmptyBlock(), { at: [0] }), Transforms.select(editor, { path: [0, 0], offset: 0 }), editor.onChange();
          return;
        }
      }
      if (isBackspace && editor.selection && editor.selection.focus.path[0] === 0 && Range.isCollapsed(editor.selection)) {
        const focusBlock = Node.descendant(editor, editor.selection.focus.path.slice(0, 1)), nextPath = Path.next(editor.selection.focus.path.slice(0, 1)), nextBlock = Node.has(editor, nextPath), isTextBlock = isPortableTextTextBlock(focusBlock), isEmptyFocusBlock = isTextBlock && focusBlock.children.length === 1 && ((_b = (_a = focusBlock.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) === "";
        if (nextBlock && isTextBlock && isEmptyFocusBlock) {
          event.preventDefault(), event.stopPropagation(), Transforms.removeNodes(editor, { match: (n) => n === focusBlock }), editor.onChange();
          return;
        }
      }
      if (isBackspace && editor.selection && editor.selection.focus.path[0] > 0 && Range.isCollapsed(editor.selection)) {
        const prevPath = Path.previous(editor.selection.focus.path.slice(0, 1)), prevBlock = Node.descendant(editor, prevPath), focusBlock = Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
        if (prevBlock && focusBlock && Editor.isVoid(editor, prevBlock) && editor.selection.focus.offset === 0) {
          debug$7("Preventing deleting void block above"), event.preventDefault(), event.stopPropagation();
          const isTextBlock = isPortableTextTextBlock(focusBlock), isEmptyFocusBlock = isTextBlock && focusBlock.children.length === 1 && ((_d = (_c = focusBlock.children) == null ? void 0 : _c[0]) == null ? void 0 : _d.text) === "";
          if (!isTextBlock || isEmptyFocusBlock) {
            Transforms.removeNodes(editor, { match: (n) => n === focusBlock }), Transforms.select(editor, prevPath), editor.onChange();
            return;
          }
          if (isTextBlock && !isEmptyFocusBlock) {
            Transforms.select(editor, prevPath), editor.onChange();
            return;
          }
          return;
        }
      }
      if (isDelete && editor.selection && editor.selection.focus.offset === 0 && Range.isCollapsed(editor.selection) && editor.children[editor.selection.focus.path[0] + 1]) {
        const nextBlock = Node.descendant(
          editor,
          Path.next(editor.selection.focus.path.slice(0, 1))
        ), focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = Node.descendant(editor, focusBlockPath);
        if (nextBlock && focusBlock && !Editor.isVoid(editor, focusBlock) && Editor.isVoid(editor, nextBlock)) {
          debug$7("Preventing deleting void block below"), event.preventDefault(), event.stopPropagation(), Transforms.removeNodes(editor, { match: (n) => n === focusBlock }), Transforms.select(editor, focusBlockPath), editor.onChange();
          return;
        }
      }
      if ((isTab || isShiftTab) && editor.selection) {
        const [focusChild] = Editor.node(editor, editor.selection.focus, { depth: 2 }), [focusBlock] = isPortableTextSpan(focusChild) ? Editor.node(editor, editor.selection.focus, { depth: 1 }) : [], hasAnnotationFocus = focusChild && isPortableTextTextBlock(focusBlock) && isPortableTextSpan(focusChild) && (focusChild.marks || []).filter(
          (m) => (focusBlock.markDefs || []).map((def) => def._key).includes(m)
        ).length > 0, [start] = Range.edges(editor.selection), atStartOfNode = Editor.isStart(editor, start, start.path);
        focusChild && isPortableTextSpan(focusChild) && (!hasAnnotationFocus || atStartOfNode) && editor.pteIncrementBlockLevels(isShiftTab) && event.preventDefault();
      }
      if (isEnter && !isShiftEnter && editor.selection) {
        const focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = Node.descendant(editor, focusBlockPath);
        if (editor.isListBlock(focusBlock)) {
          editor.pteEndList() && event.preventDefault();
          return;
        }
        if (editor.isTextBlock(focusBlock) && focusBlock.style && focusBlock.style !== types.styles[0].value) {
          const [, end] = Range.edges(editor.selection);
          if (Editor.isEnd(editor, end, end.path)) {
            Editor.insertNode(editor, editor.pteCreateEmptyBlock()), event.preventDefault(), editor.onChange();
            return;
          }
        }
        if (focusBlock && Editor.isVoid(editor, focusBlock)) {
          Editor.insertNode(editor, editor.pteCreateEmptyBlock()), event.preventDefault(), editor.onChange();
          return;
        }
        event.preventDefault(), editor.insertBreak(), editor.onChange();
      }
      if (isShiftEnter) {
        event.preventDefault(), editor.insertText(`
`);
        return;
      }
      if (isHotkey("mod+z", event.nativeEvent)) {
        event.preventDefault(), editor.undo();
        return;
      }
      (isHotkey("mod+y", event.nativeEvent) || isHotkey("mod+shift+z", event.nativeEvent)) && (event.preventDefault(), editor.redo());
    }, editor;
  };
}
function validateValue(value, types, keyGenerator) {
  let resolution = null, valid = !0;
  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];
  return value === void 0 ? { valid: !0, resolution: null, value } : !Array.isArray(value) || value.length === 0 ? {
    valid: !1,
    resolution: {
      patches: [unset([])],
      description: "Editor value must be an array of Portable Text blocks, or undefined.",
      action: "Unset the value",
      item: value,
      i18n: {
        description: "inputs.portable-text.invalid-value.not-an-array.description",
        action: "inputs.portable-text.invalid-value.not-an-array.action"
      }
    },
    value
  } : (value.some((blk, index) => {
    if (!isPlainObject(blk))
      return resolution = {
        patches: [unset([index])],
        description: `Block must be an object, got ${String(blk)}`,
        action: "Unset invalid item",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.not-an-object.description",
          action: "inputs.portable-text.invalid-value.not-an-object.action",
          values: { index }
        }
      }, !0;
    if (!blk._key || typeof blk._key != "string")
      return resolution = {
        patches: [set({ ...blk, _key: keyGenerator() }, [index])],
        description: `Block at index ${index} is missing required _key.`,
        action: "Set the block with a random _key value",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-key.description",
          action: "inputs.portable-text.invalid-value.missing-key.action",
          values: { index }
        }
      }, !0;
    if (!blk._type || !validBlockTypes.includes(blk._type)) {
      if (blk._type === "block") {
        const currentBlockTypeName = types.block.name;
        return resolution = {
          patches: [set({ ...blk, _type: currentBlockTypeName }, [{ _key: blk._key }])],
          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,
          action: `Use type '${currentBlockTypeName}'`,
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.incorrect-block-type.description",
            action: "inputs.portable-text.invalid-value.incorrect-block-type.action",
            values: { key: blk._key, expectedTypeName: currentBlockTypeName }
          }
        }, !0;
      }
      return !blk._type && isPortableTextTextBlock({ ...blk, _type: types.block.name }) ? (resolution = {
        patches: [set({ ...blk, _type: types.block.name }, [{ _key: blk._key }])],
        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,
        action: `Use type '${types.block.name}'`,
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-block-type.description",
          action: "inputs.portable-text.invalid-value.missing-block-type.action",
          values: { key: blk._key, expectedTypeName: types.block.name }
        }
      }, !0) : blk._type ? (resolution = {
        patches: [unset([{ _key: blk._key }])],
        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.disallowed-type.description",
          action: "inputs.portable-text.invalid-value.disallowed-type.action",
          values: { key: blk._key, typeName: blk._type }
        }
      }, !0) : (resolution = {
        patches: [unset([{ _key: blk._key }])],
        description: `Block with _key '${blk._key}' is missing an _type property`,
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-type.description",
          action: "inputs.portable-text.invalid-value.missing-type.action",
          values: { key: blk._key }
        }
      }, !0);
    }
    if (blk._type === types.block.name) {
      const textBlock = blk;
      if (!textBlock.children || !Array.isArray(textBlock.children))
        return resolution = {
          patches: [unset([{ _key: textBlock._key }])],
          description: `Text block with _key '${textBlock._key}' has a missing or invalid required property 'children'.`,
          action: "Remove the block",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-children.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-children.action",
            values: { key: textBlock._key }
          }
        }, !0;
      if (!blk.markDefs || !Array.isArray(blk.markDefs))
        return resolution = {
          patches: [set({ ...textBlock, markDefs: [] }, [{ _key: textBlock._key }])],
          description: "Block has a missing or invalid required property 'markDefs'.",
          action: "Add empty markDefs array",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.action",
            values: { key: textBlock._key }
          }
        }, !0;
      const orphanedMarks = uniq(
        flatten$1(
          textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])
        )
      ).filter(
        (mark) => !types.decorators.map((dec) => dec.value).includes(mark)
      ).filter(
        (mark) => textBlock.markDefs ? !textBlock.markDefs.find((def) => def._key === mark) : !1
      );
      if (orphanedMarks.length > 0) {
        const spanChildren = textBlock.children.filter(
          (cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark))
        );
        if (spanChildren) {
          const orphaned = orphanedMarks.join(", ");
          return resolution = {
            patches: spanChildren.map((child) => set(
              (child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)),
              [{ _key: blk._key }, "children", { _key: child._key }, "marks"]
            )),
            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,
            action: "Remove invalid marks",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.orphaned-marks.description",
              action: "inputs.portable-text.invalid-value.orphaned-marks.action",
              values: { key: blk._key, orphanedMarks }
            }
          }, !0;
        }
      }
      if (textBlock.children && textBlock.children.length === 0) {
        const newSpan = {
          _type: types.span.name,
          _key: keyGenerator(),
          text: ""
        };
        return resolution = {
          patches: [insert$1([newSpan], "after", [{ _key: blk._key }, "children", 0])],
          description: `Children for text block with _key '${blk._key}' is empty.`,
          action: "Insert an empty text",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.empty-children.description",
            action: "inputs.portable-text.invalid-value.empty-children.action",
            values: { key: blk._key }
          }
        }, !0;
      }
      textBlock.children.some((child, cIndex) => isPlainObject(child) ? child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != "string" ? (resolution = {
        patches: [
          set({ ...child, text: "" }, [{ _key: blk._key }, "children", { _key: child._key }])
        ],
        description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,
        action: "Write an empty text property to the object",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.invalid-span-text.description",
          action: "inputs.portable-text.invalid-value.invalid-span-text.action",
          values: { key: blk._key, childKey: child._key }
        }
      }, !0) : !1 : (resolution = {
        patches: [unset([{ _key: blk._key }, "children", { _key: child._key }])],
        description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,
        action: "Remove the object",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.disallowed-child-type.description",
          action: "inputs.portable-text.invalid-value.disallowed-child-type.action",
          values: { key: blk._key, childKey: child._key, childType: child._type }
        }
      }, !0) : (resolution = {
        patches: [unset([{ _key: blk._key }, "children", { _key: child._key }])],
        description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,
        action: "Remove the object",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-child-type.description",
          action: "inputs.portable-text.invalid-value.missing-child-type.action",
          values: { key: blk._key, childKey: child._key }
        }
      }, !0) : (resolution = {
        patches: [unset([{ _key: blk._key }, "children", cIndex])],
        description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,
        action: "Remove the item",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.non-object-child.description",
          action: "inputs.portable-text.invalid-value.non-object-child.action",
          values: { key: blk._key, index: cIndex }
        }
      }, !0)) && (valid = !1);
    }
    return !1;
  }) && (valid = !1), { valid, resolution, value });
}
const debug$6 = debugWithName("plugin:withInsertData");
function createWithInsertData(change$, schemaTypes, keyGenerator) {
  return function(editor) {
    const blockTypeName = schemaTypes.block.name, spanTypeName = schemaTypes.span.name, whitespaceOnPasteMode = schemaTypes.block.options.unstable_whitespaceOnPasteMode, toPlainText = (blocks) => blocks.map((block) => {
      var _a;
      return editor.isTextBlock(block) ? block.children.map((child) => {
        var _a2;
        return child._type === spanTypeName ? child.text : `[${((_a2 = schemaTypes.inlineObjects.find((t) => t.name === child._type)) == null ? void 0 : _a2.title) || "Object"}]`;
      }).join("") : `[${((_a = schemaTypes.blockObjects.find((t) => t.name === block._type)) == null ? void 0 : _a.title) || "Object"}]`;
    }).join(`

`);
    return editor.setFragmentData = (data, originEvent) => {
      const { selection } = editor;
      if (!selection)
        return;
      const [start, end] = Range.edges(selection), startVoid = Editor.void(editor, { at: start.path }), endVoid = Editor.void(editor, { at: end.path });
      if (Range.isCollapsed(selection) && !startVoid)
        return;
      const domRange = ReactEditor.toDOMRange(editor, selection);
      let contents = domRange.cloneContents();
      if (endVoid) {
        const [voidNode] = endVoid, r = domRange.cloneRange(), domNode = ReactEditor.toDOMNode(editor, voidNode);
        r.setEndAfter(domNode), contents = r.cloneContents();
      }
      Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
        const isNewline = zw.getAttribute("data-slate-zero-width") === "n";
        zw.textContent = isNewline ? `
` : "";
      }), Array.from(contents.querySelectorAll("*")).forEach((elm) => {
        elm.removeAttribute("contentEditable"), elm.removeAttribute("data-slate-inline"), elm.removeAttribute("data-slate-leaf"), elm.removeAttribute("data-slate-node"), elm.removeAttribute("data-slate-spacer"), elm.removeAttribute("data-slate-string"), elm.removeAttribute("data-slate-zero-width"), elm.removeAttribute("draggable");
        for (const key in elm.attributes)
          elm.hasAttribute(key) && elm.removeAttribute(key);
      });
      const div = contents.ownerDocument.createElement("div");
      div.appendChild(contents), div.setAttribute("hidden", "true"), contents.ownerDocument.body.appendChild(div);
      const asHTML = div.innerHTML;
      contents.ownerDocument.body.removeChild(div);
      const fragment = editor.getFragment(), portableText = fromSlateValue(fragment, blockTypeName), asJSON = JSON.stringify(portableText), asPlainText = toPlainText(portableText);
      data.clearData(), data.setData("text/plain", asPlainText), data.setData("text/html", asHTML), data.setData("application/json", asJSON), data.setData("application/x-portable-text", asJSON), debug$6("text", asPlainText), data.setData("application/x-portable-text-event-origin", originEvent || "external"), debug$6("Set fragment data", asJSON, asHTML);
    }, editor.insertPortableTextData = (data) => {
      var _a;
      if (!editor.selection)
        return !1;
      const pText = data.getData("application/x-portable-text"), origin = data.getData("application/x-portable-text-event-origin");
      if (debug$6(`Inserting portable text from ${origin} event`, pText), pText) {
        const parsed = JSON.parse(pText);
        if (Array.isArray(parsed) && parsed.length > 0) {
          const slateValue = _regenerateKeys(
            editor,
            toSlateValue(parsed, { schemaTypes }),
            keyGenerator,
            spanTypeName
          ), validation = validateValue(parsed, schemaTypes, keyGenerator);
          if (!validation.valid) {
            const errorDescription = `${(_a = validation.resolution) == null ? void 0 : _a.description}`;
            return change$.next({
              type: "error",
              level: "warning",
              name: "pasteError",
              description: errorDescription,
              data: validation
            }), debug$6("Invalid insert result", validation), !1;
          }
          return _insertFragment(editor, slateValue, schemaTypes), !0;
        }
      }
      return !1;
    }, editor.insertTextOrHTMLData = (data) => {
      var _a;
      if (!editor.selection)
        return debug$6("No selection, not inserting"), !1;
      change$.next({ type: "loading", isLoading: !0 });
      const html = data.getData("text/html"), text = data.getData("text/plain"), { files } = data, hasFiles = files && files.length > 0;
      if (hasFiles) {
        const plural = files.length === 1 ? "file" : "files";
        debug$6(`Inserting ${plural}`, data);
      }
      if (!hasFiles && (html || text)) {
        debug$6("Inserting data", data);
        let portableText, fragment, insertedType;
        if (html)
          portableText = htmlToBlocks(html, schemaTypes.portableText, {
            unstable_whitespaceOnPasteMode: whitespaceOnPasteMode
          }).map((block) => normalizeBlock(block, { blockTypeName })), fragment = toSlateValue(portableText, { schemaTypes }), insertedType = "HTML";
        else {
          const textToHtml = `<html><body>${escapeHtml(text).split(/\n{2,}/).map(
            (line) => line ? `<p>${line.replace(/(?:\r\n|\r|\n)/g, "<br/>")}</p>` : "<p></p>"
          ).join("")}</body></html>`;
          portableText = htmlToBlocks(textToHtml, schemaTypes.portableText).map(
            (block) => normalizeBlock(block, { blockTypeName })
          ), fragment = toSlateValue(portableText, {
            schemaTypes
          }), insertedType = "text";
        }
        const validation = validateValue(portableText, schemaTypes, keyGenerator);
        if (!validation.valid) {
          const errorDescription = `Could not validate the resulting portable text to insert.
${(_a = validation.resolution) == null ? void 0 : _a.description}
Try to insert as plain text (shift-paste) instead.`;
          return change$.next({
            type: "error",
            level: "warning",
            name: "pasteError",
            description: errorDescription,
            data: validation
          }), debug$6("Invalid insert result", validation), !1;
        }
        return debug$6(`Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`), _insertFragment(editor, fragment, schemaTypes), change$.next({ type: "loading", isLoading: !1 }), !0;
      }
      return change$.next({ type: "loading", isLoading: !1 }), !1;
    }, editor.insertData = (data) => {
      editor.insertPortableTextData(data) || editor.insertTextOrHTMLData(data);
    }, editor.insertFragmentData = (data) => {
      const fragment = data.getData("application/x-portable-text");
      if (fragment) {
        const parsed = JSON.parse(fragment);
        return editor.insertFragment(parsed), !0;
      }
      return !1;
    }, editor;
  };
}
const entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(str) {
  return String(str).replace(/[&<>"'`=/]/g, (s) => entityMap[s]);
}
function _regenerateKeys(editor, fragment, keyGenerator, spanTypeName) {
  return fragment.map((node) => {
    const newNode = { ...node };
    editor.isTextBlock(newNode) && (newNode.markDefs = (newNode.markDefs || []).map((def) => {
      const oldKey = def._key, newKey = keyGenerator();
      return newNode.children = newNode.children.map(
        (child) => child._type === spanTypeName && editor.isTextSpan(child) ? {
          ...child,
          marks: child.marks && child.marks.includes(oldKey) ? (
            // eslint-disable-next-line max-nested-callbacks
            [...child.marks].filter((mark) => mark !== oldKey).concat(newKey)
          ) : child.marks
        } : child
      ), { ...def, _key: newKey };
    }));
    const nodeWithNewKeys = { ...newNode, _key: keyGenerator() };
    return editor.isTextBlock(nodeWithNewKeys) && (nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({
      ...child,
      _key: keyGenerator()
    }))), nodeWithNewKeys;
  });
}
function _insertFragment(editor, fragment, schemaTypes) {
  if (!editor.selection)
    return;
  const [focusBlock, focusPath] = Editor.node(editor, editor.selection, { depth: 1 });
  if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {
    const { markDefs } = focusBlock;
    debug$6("Mixing markDefs of focusBlock and fragments[0] block", markDefs, fragment[0].markDefs), isEqual(markDefs, fragment[0].markDefs) || Transforms.setNodes(
      editor,
      {
        markDefs: uniq([...fragment[0].markDefs || [], ...markDefs || []])
      },
      { at: focusPath, mode: "lowest", voids: !1 }
    );
  }
  isEqualToEmptyEditor(editor.children, schemaTypes) ? (Transforms.splitNodes(editor, { at: [0, 0] }), editor.insertFragment(fragment), Transforms.removeNodes(editor, { at: [0] })) : editor.insertFragment(fragment), editor.onChange();
}
const originalFnMap = /* @__PURE__ */ new WeakMap(), withPlugins = (editor, options) => {
  const e = editor, { keyGenerator, portableTextEditor, patches$, readOnly, maxBlocks } = options, { schemaTypes, change$ } = portableTextEditor;
  e.subscriptions = [], e.destroy ? e.destroy() : originalFnMap.set(e, {
    apply: e.apply,
    onChange: e.onChange,
    normalizeNode: e.normalizeNode
  });
  const operationToPatches = createOperationToPatches(schemaTypes), withObjectKeys = createWithObjectKeys(schemaTypes, keyGenerator), withSchemaTypes = createWithSchemaTypes({ schemaTypes, keyGenerator }), withEditableAPI = createWithEditableAPI(portableTextEditor, schemaTypes, keyGenerator), withPatches = createWithPatches({
    change$,
    keyGenerator,
    patches$,
    patchFunctions: operationToPatches,
    readOnly,
    schemaTypes
  }), withMaxBlocks = createWithMaxBlocks(maxBlocks || -1), withPortableTextLists = createWithPortableTextLists(schemaTypes), withUndoRedo = createWithUndoRedo({
    readOnly,
    patches$,
    blockSchemaType: schemaTypes.block
  }), withPortableTextMarkModel = createWithPortableTextMarkModel(schemaTypes, change$), withPortableTextBlockStyle = createWithPortableTextBlockStyle(schemaTypes), withPlaceholderBlock = createWithPlaceholderBlock(), withInsertBreak = createWithInsertBreak(schemaTypes), withUtils = createWithUtils({ keyGenerator, schemaTypes, portableTextEditor }), withPortableTextSelections = createWithPortableTextSelections(change$, schemaTypes);
  return e.destroy = () => {
    const originalFunctions = originalFnMap.get(e);
    if (!originalFunctions)
      throw new Error("Could not find pristine versions of editor functions");
    e.apply = originalFunctions.apply, e.history = { undos: [], redos: [] }, e.normalizeNode = originalFunctions.normalizeNode, e.onChange = originalFunctions.onChange;
  }, readOnly ? {
    editor: withSchemaTypes(
      withObjectKeys(
        withPortableTextMarkModel(
          withPortableTextBlockStyle(
            withUtils(
              withPlaceholderBlock(
                withPortableTextLists(
                  withPortableTextSelections(withEditableAPI(withInsertBreak(e)))
                )
              )
            )
          )
        )
      )
    ),
    subscribe: () => noop
  } : {
    editor: withSchemaTypes(
      withObjectKeys(
        withPortableTextMarkModel(
          withPortableTextBlockStyle(
            withPortableTextLists(
              withPlaceholderBlock(
                withUtils(
                  withMaxBlocks(
                    withUndoRedo(
                      withPatches(withPortableTextSelections(withEditableAPI(withInsertBreak(e))))
                    )
                  )
                )
              )
            )
          )
        )
      )
    ),
    subscribe: () => {
      const unsubscribes = [];
      return editor.subscriptions.forEach((subscribeFn) => {
        unsubscribes.push(subscribeFn());
      }), () => {
        unsubscribes.forEach((unsubscribeFn) => {
          unsubscribeFn();
        });
      };
    }
  };
}, debug$5 = debugWithName("component:PortableTextEditor:SlateContainer");
function SlateContainer(props) {
  const { patches$, portableTextEditor, readOnly, maxBlocks, keyGenerator } = props, [slateEditor, subscribe] = useMemo(() => {
    debug$5("Creating new Slate editor instance");
    const { editor, subscribe: _sub } = withPlugins(withReact(createEditor()), {
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
    return KEY_TO_VALUE_ELEMENT.set(editor, {}), KEY_TO_SLATE_ELEMENT.set(editor, {}), [editor, _sub];
  }, []);
  useEffect(() => {
    const unsubscribe = subscribe();
    return () => {
      unsubscribe();
    };
  }, [subscribe]), useEffect(() => {
    debug$5("Re-initializing plugin chain"), withPlugins(slateEditor, {
      keyGenerator,
      maxBlocks,
      patches$,
      portableTextEditor,
      readOnly
    });
  }, [keyGenerator, portableTextEditor, maxBlocks, readOnly, patches$, slateEditor]);
  const initialValue = useMemo(() => [slateEditor.pteCreateEmptyBlock()], [slateEditor]);
  return useEffect(() => () => {
    debug$5("Destroying Slate editor"), slateEditor.destroy();
  }, [slateEditor]), /* @__PURE__ */ jsx(Slate, { editor: slateEditor, initialValue, children: props.children });
}
const PortableTextEditorSelectionContext = createContext(null), usePortableTextEditorSelection = () => {
  const selection = useContext(PortableTextEditorSelectionContext);
  if (selection === void 0)
    throw new Error(
      "The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context."
    );
  return selection;
}, PortableTextEditorValueContext = createContext(
  void 0
), PortableTextEditorReadOnlyContext = createContext(!1), usePortableTextEditorReadOnlyStatus = () => {
  const readOnly = useContext(PortableTextEditorReadOnlyContext);
  if (readOnly === void 0)
    throw new Error(
      "The `usePortableTextEditorReadOnly` hook must be used inside the <PortableTextEditor> component's context."
    );
  return readOnly;
}, debug$4 = debugWithName("hook:useSyncValue"), CURRENT_VALUE = /* @__PURE__ */ new WeakMap();
function useSyncValue(props) {
  const { portableTextEditor, readOnly, keyGenerator } = props, { change$, schemaTypes } = portableTextEditor, previousValue = useRef(), slateEditor = useSlate(), updateValueFunctionRef = useRef(), updateFromCurrentValue = useCallback(() => {
    const currentValue = CURRENT_VALUE.get(portableTextEditor);
    if (previousValue.current === currentValue) {
      debug$4("Value is the same object as previous, not need to sync");
      return;
    }
    updateValueFunctionRef.current && currentValue && (debug$4("Updating the value debounced"), updateValueFunctionRef.current(currentValue));
  }, [portableTextEditor]), updateValueDebounced = useCallback(
    debounce(updateFromCurrentValue, 1e3, { trailing: !0, leading: !1 }),
    [updateFromCurrentValue]
  );
  return useMemo(() => {
    const updateFunction = (value) => {
      CURRENT_VALUE.set(portableTextEditor, value);
      const isProcessingLocalChanges = isChangingLocally(slateEditor), isProcessingRemoteChanges = isChangingRemotely(slateEditor);
      if (!readOnly) {
        if (isProcessingLocalChanges) {
          debug$4("Has local changes, not syncing value right now"), updateValueDebounced();
          return;
        }
        if (isProcessingRemoteChanges) {
          debug$4("Has remote changes, not syncing value right now"), updateValueDebounced();
          return;
        }
      }
      let isChanged = !1, isValid = !0;
      const hadSelection = !!slateEditor.selection;
      if ((!value || value.length === 0) && (debug$4("Value is empty"), Editor.withoutNormalizing(slateEditor, () => {
        withoutSaving(slateEditor, () => {
          withoutPatching(slateEditor, () => {
            hadSelection && Transforms.deselect(slateEditor);
            const childrenLength = slateEditor.children.length;
            slateEditor.children.forEach((_, index) => {
              Transforms.removeNodes(slateEditor, {
                at: [childrenLength - 1 - index]
              });
            }), Transforms.insertNodes(slateEditor, slateEditor.pteCreateEmptyBlock(), { at: [0] }), hadSelection && Transforms.select(slateEditor, [0, 0]);
          });
        });
      }), isChanged = !0), value && value.length > 0) {
        const slateValueFromProps = toSlateValue(value, {
          schemaTypes
        });
        Editor.withoutNormalizing(slateEditor, () => {
          withRemoteChanges(slateEditor, () => {
            withoutSaving(slateEditor, () => {
              withoutPatching(slateEditor, () => {
                const childrenLength = slateEditor.children.length;
                if (slateValueFromProps.length < childrenLength) {
                  for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)
                    Transforms.removeNodes(slateEditor, {
                      at: [i]
                    });
                  isChanged = !0;
                }
                slateValueFromProps.forEach((currentBlock, currentBlockIndex) => {
                  const oldBlock = slateEditor.children[currentBlockIndex];
                  if (oldBlock && !isEqual(currentBlock, oldBlock) && isValid) {
                    const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, schemaTypes, keyGenerator);
                    validation.valid ? (oldBlock._key === currentBlock._key ? (debug$4.enabled && debug$4("Updating block", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$4.enabled && debug$4("Replacing block", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), isChanged = !0) : (change$.next({
                      type: "invalidValue",
                      resolution: validation.resolution,
                      value
                    }), isValid = !1);
                  }
                  if (!oldBlock && isValid) {
                    const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, schemaTypes, keyGenerator);
                    debug$4.enabled && debug$4(
                      "Validating and inserting new block in the end of the value",
                      currentBlock
                    ), validation.valid ? withPreserveKeys(slateEditor, () => {
                      Transforms.insertNodes(slateEditor, currentBlock, {
                        at: [currentBlockIndex]
                      });
                    }) : (debug$4("Invalid", validation), change$.next({
                      type: "invalidValue",
                      resolution: validation.resolution,
                      value
                    }), isValid = !1);
                  }
                });
              });
            });
          });
        });
      }
      if (!isValid) {
        debug$4("Invalid value, returning");
        return;
      }
      if (isChanged) {
        debug$4("Server value changed, syncing editor");
        try {
          slateEditor.onChange();
        } catch (err) {
          console.error(err), change$.next({
            type: "invalidValue",
            resolution: null,
            value
          });
          return;
        }
        hadSelection && !slateEditor.selection && (Transforms.select(slateEditor, {
          anchor: { path: [0, 0], offset: 0 },
          focus: { path: [0, 0], offset: 0 }
        }), slateEditor.onChange()), change$.next({ type: "value", value });
      } else
        debug$4("Server value and editor value is equal, no need to sync.");
      previousValue.current = value;
    };
    return updateValueFunctionRef.current = updateFunction, updateFunction;
  }, [
    change$,
    keyGenerator,
    portableTextEditor,
    readOnly,
    schemaTypes,
    slateEditor,
    updateValueDebounced
  ]);
}
function _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {
  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;
  selectionFocusOnBlock && Transforms.deselect(slateEditor), Transforms.removeNodes(slateEditor, { at: [currentBlockIndex] }), withPreserveKeys(slateEditor, () => {
    Transforms.insertNodes(slateEditor, currentBlock, { at: [currentBlockIndex] });
  }), selectionFocusOnBlock && Transforms.select(slateEditor, currentSelection);
}
function _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {
  if (Transforms.setNodes(slateEditor, currentBlock, {
    at: [currentBlockIndex]
  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {
    const oldBlockChildrenLength = oldBlock.children.length;
    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach(
      (_, index) => {
        const childIndex = oldBlockChildrenLength - 1 - index;
        childIndex > 0 && (debug$4("Removing child"), Transforms.removeNodes(slateEditor, {
          at: [currentBlockIndex, childIndex]
        }));
      }
    ), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {
      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !isEqual(currentBlockChild, oldBlockChild), isTextChanged = !isEqual(currentBlockChild.text, oldBlockChild == null ? void 0 : oldBlockChild.text), path = [currentBlockIndex, currentBlockChildIndex];
      if (isChildChanged)
        if (currentBlockChild._key === (oldBlockChild == null ? void 0 : oldBlockChild._key)) {
          debug$4("Updating changed child", currentBlockChild, oldBlockChild), Transforms.setNodes(slateEditor, currentBlockChild, {
            at: path
          });
          const isSpanNode = Text.isText(currentBlockChild) && currentBlockChild._type === "span" && Text.isText(oldBlockChild) && oldBlockChild._type === "span";
          isSpanNode && isTextChanged ? (Transforms.delete(slateEditor, {
            at: { focus: { path, offset: 0 }, anchor: { path, offset: oldBlockChild.text.length } }
          }), Transforms.insertText(slateEditor, currentBlockChild.text, {
            at: path
          }), slateEditor.onChange()) : isSpanNode || (debug$4("Updating changed inline object child", currentBlockChild), Transforms.setNodes(
            slateEditor,
            { _key: VOID_CHILD_KEY },
            {
              at: [...path, 0],
              voids: !0
            }
          ));
        } else oldBlockChild ? (debug$4("Replacing child", currentBlockChild), Transforms.removeNodes(slateEditor, {
          at: [currentBlockIndex, currentBlockChildIndex]
        }), withPreserveKeys(slateEditor, () => {
          Transforms.insertNodes(slateEditor, currentBlockChild, {
            at: [currentBlockIndex, currentBlockChildIndex]
          });
        }), slateEditor.onChange()) : oldBlockChild || (debug$4("Inserting new child", currentBlockChild), withPreserveKeys(slateEditor, () => {
          Transforms.insertNodes(slateEditor, currentBlockChild, {
            at: [currentBlockIndex, currentBlockChildIndex]
          }), slateEditor.onChange();
        }));
    });
  }
}
const debug$3 = debugWithName("component:PortableTextEditor:Synchronizer"), debugVerbose = debug$3.enabled && !1, FLUSH_PATCHES_THROTTLED_MS = process.env.NODE_ENV === "test" ? 500 : 1e3;
function Synchronizer(props) {
  const { change$, portableTextEditor, onChange, keyGenerator, readOnly, value } = props, [selection, setSelection] = useState(null), pendingPatches = useRef([]), syncValue = useSyncValue({
    keyGenerator,
    onChange,
    portableTextEditor,
    readOnly
  }), slateEditor = useSlate();
  useEffect(() => {
    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);
  }, [slateEditor]);
  const onFlushPendingPatches = useCallback(() => {
    if (pendingPatches.current.length > 0) {
      debug$3("Flushing pending patches"), debugVerbose && debug$3(`Patches:
${JSON.stringify(pendingPatches.current, null, 2)}`);
      const snapshot = PortableTextEditor.getValue(portableTextEditor);
      change$.next({ type: "mutation", patches: pendingPatches.current, snapshot }), pendingPatches.current = [];
    }
    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);
  }, [slateEditor, portableTextEditor, change$]), onFlushPendingPatchesThrottled = useMemo(() => throttle(
    () => {
      if (Editor.isNormalizing(slateEditor)) {
        onFlushPendingPatches();
        return;
      }
      onFlushPendingPatchesThrottled();
    },
    FLUSH_PATCHES_THROTTLED_MS,
    {
      leading: !1,
      trailing: !0
    }
  ), [onFlushPendingPatches, slateEditor]);
  useEffect(() => () => {
    onFlushPendingPatches();
  }, [onFlushPendingPatches]), useEffect(() => {
    debug$3("Subscribing to editor changes$");
    const sub = change$.subscribe((next) => {
      switch (next.type) {
        case "patch":
          IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !0), pendingPatches.current.push(next.patch), onFlushPendingPatchesThrottled(), onChange(next);
          break;
        case "selection":
          startTransition(() => {
            debugVerbose && debug$3("Setting selection"), setSelection(next.selection);
          }), onChange(next);
          break;
        default:
          onChange(next);
      }
    });
    return () => {
      debug$3("Unsubscribing to changes$"), sub.unsubscribe();
    };
  }, [change$, onChange, onFlushPendingPatchesThrottled, slateEditor]);
  const handleOnline = useCallback(() => {
    debug$3("Editor is online, syncing from props.value"), change$.next({ type: "connection", value: "online" }), syncValue(value);
  }, [change$, syncValue, value]), handleOffline = useCallback(() => {
    debug$3("Editor is offline"), change$.next({ type: "connection", value: "offline" });
  }, [change$]);
  useEffect(() => (portableTextEditor.props.patches$ && (window.addEventListener("online", handleOnline), window.addEventListener("offline", handleOffline)), () => {
    portableTextEditor.props.patches$ && (window.removeEventListener("online", handleOnline), window.removeEventListener("offline", handleOffline));
  }));
  const isInitialValueFromProps = useRef(!0);
  return useEffect(() => {
    debug$3("Value from props changed, syncing new value"), syncValue(value), isInitialValueFromProps.current && (change$.next({ type: "loading", isLoading: !1 }), change$.next({ type: "ready" }), isInitialValueFromProps.current = !1);
  }, [change$, syncValue, value]), /* @__PURE__ */ jsx(PortableTextEditorKeyGeneratorContext.Provider, { value: keyGenerator, children: /* @__PURE__ */ jsx(PortableTextEditorContext.Provider, { value: portableTextEditor, children: /* @__PURE__ */ jsx(PortableTextEditorValueContext.Provider, { value, children: /* @__PURE__ */ jsx(PortableTextEditorReadOnlyContext.Provider, { value: readOnly, children: /* @__PURE__ */ jsx(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }) }) }) }) });
}
var __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value);
const debug$2 = debugWithName("component:PortableTextEditor");
class PortableTextEditor extends Component {
  constructor(props) {
    if (super(props), __publicField(this, "change$", new Subject()), __publicField(this, "schemaTypes"), __publicField(this, "editable"), __publicField(this, "setEditable", (editable) => {
      this.editable = { ...this.editable, ...editable };
    }), !props.schemaType)
      throw new Error('PortableTextEditor: missing "type" property');
    props.incomingPatches$ && console.warn("The prop 'incomingPatches$' is deprecated and renamed to 'patches$'"), this.change$.next({ type: "loading", isLoading: !0 }), this.schemaTypes = getPortableTextMemberSchemaTypes(
      props.schemaType.hasOwnProperty("jsonType") ? props.schemaType : compileType(props.schemaType)
    );
  }
  componentDidUpdate(prevProps) {
    this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = getPortableTextMemberSchemaTypes(
      this.props.schemaType.hasOwnProperty("jsonType") ? this.props.schemaType : compileType(this.props.schemaType)
    )), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this);
  }
  render() {
    const { onChange, value, children, patches$, incomingPatches$ } = this.props, { change$ } = this, _patches$ = incomingPatches$ || patches$, maxBlocks = typeof this.props.maxBlocks > "u" ? void 0 : parseInt(this.props.maxBlocks.toString(), 10) || void 0, readOnly = !!this.props.readOnly, keyGenerator = this.props.keyGenerator || defaultKeyGenerator;
    return /* @__PURE__ */ jsx(
      SlateContainer,
      {
        keyGenerator,
        maxBlocks,
        patches$: _patches$,
        portableTextEditor: this,
        readOnly,
        children: /* @__PURE__ */ jsx(
          Synchronizer,
          {
            change$,
            keyGenerator,
            onChange,
            portableTextEditor: this,
            readOnly,
            value,
            children
          }
        )
      }
    );
  }
}
__publicField(PortableTextEditor, "activeAnnotations", (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : []), __publicField(PortableTextEditor, "isAnnotationActive", (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1), __publicField(PortableTextEditor, "addAnnotation", (editor, type, value) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.addAnnotation(type, value);
}), __publicField(PortableTextEditor, "blur", (editor) => {
  var _a;
  debug$2("Host blurred"), (_a = editor.editable) == null || _a.blur();
}), __publicField(PortableTextEditor, "delete", (editor, selection, options) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.delete(selection, options);
}), __publicField(PortableTextEditor, "findDOMNode", (editor, element) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.findDOMNode(element);
}), __publicField(PortableTextEditor, "findByPath", (editor, path) => {
  var _a;
  return ((_a = editor.editable) == null ? void 0 : _a.findByPath(path)) || [];
}), __publicField(PortableTextEditor, "focus", (editor) => {
  var _a;
  debug$2("Host requesting focus"), (_a = editor.editable) == null || _a.focus();
}), __publicField(PortableTextEditor, "focusBlock", (editor) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.focusBlock();
}), __publicField(PortableTextEditor, "focusChild", (editor) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.focusChild();
}), __publicField(PortableTextEditor, "getSelection", (editor) => editor.editable ? editor.editable.getSelection() : null), __publicField(PortableTextEditor, "getValue", (editor) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.getValue();
}), __publicField(PortableTextEditor, "hasBlockStyle", (editor, blockStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.hasBlockStyle(blockStyle);
}), __publicField(PortableTextEditor, "hasListStyle", (editor, listStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.hasListStyle(listStyle);
}), __publicField(PortableTextEditor, "isCollapsedSelection", (editor) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isCollapsedSelection();
}), __publicField(PortableTextEditor, "isExpandedSelection", (editor) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isExpandedSelection();
}), __publicField(PortableTextEditor, "isMarkActive", (editor, mark) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isMarkActive(mark);
}), __publicField(PortableTextEditor, "insertChild", (editor, type, value) => {
  var _a;
  return debug$2("Host inserting child"), (_a = editor.editable) == null ? void 0 : _a.insertChild(type, value);
}), __publicField(PortableTextEditor, "insertBlock", (editor, type, value) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.insertBlock(type, value);
}), __publicField(PortableTextEditor, "insertBreak", (editor) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.insertBreak();
}), __publicField(PortableTextEditor, "isVoid", (editor, element) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isVoid(element);
}), __publicField(PortableTextEditor, "isObjectPath", (editor, path) => {
  if (!path || !Array.isArray(path)) return !1;
  const isChildObjectEditPath = path.length > 3 && path[1] === "children";
  return path.length > 1 && path[1] !== "children" || isChildObjectEditPath;
}), __publicField(PortableTextEditor, "marks", (editor) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.marks();
}), __publicField(PortableTextEditor, "select", (editor, selection) => {
  var _a;
  debug$2("Host setting selection", selection), (_a = editor.editable) == null || _a.select(selection);
}), __publicField(PortableTextEditor, "removeAnnotation", (editor, type) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.removeAnnotation(type);
}), __publicField(PortableTextEditor, "toggleBlockStyle", (editor, blockStyle) => {
  var _a;
  return debug$2("Host is toggling block style"), (_a = editor.editable) == null ? void 0 : _a.toggleBlockStyle(blockStyle);
}), __publicField(PortableTextEditor, "toggleList", (editor, listStyle) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.toggleList(listStyle);
}), __publicField(PortableTextEditor, "toggleMark", (editor, mark) => {
  var _a;
  debug$2("Host toggling mark", mark), (_a = editor.editable) == null || _a.toggleMark(mark);
}), __publicField(PortableTextEditor, "getFragment", (editor) => {
  var _a;
  return debug$2("Host getting fragment"), (_a = editor.editable) == null ? void 0 : _a.getFragment();
}), __publicField(PortableTextEditor, "undo", (editor) => {
  var _a;
  debug$2("Host undoing"), (_a = editor.editable) == null || _a.undo();
}), __publicField(PortableTextEditor, "redo", (editor) => {
  var _a;
  debug$2("Host redoing"), (_a = editor.editable) == null || _a.redo();
}), __publicField(PortableTextEditor, "isSelectionsOverlapping", (editor, selectionA, selectionB) => {
  var _a;
  return (_a = editor.editable) == null ? void 0 : _a.isSelectionsOverlapping(selectionA, selectionB);
});
const debug$1 = debugWithName("components:Leaf"), EMPTY_MARKS = [], Leaf = (props) => {
  const { attributes, children, leaf, schemaTypes, renderChild, renderDecorator, renderAnnotation } = props, spanRef = useRef(null), portableTextEditor = usePortableTextEditor(), blockSelected = useSelected(), [focused, setFocused] = useState(!1), [selected, setSelected] = useState(!1), block = children.props.parent, path = useMemo(
    () => block ? [{ _key: block == null ? void 0 : block._key }, "children", { _key: leaf._key }] : [],
    [block, leaf._key]
  ), decoratorValues = useMemo(
    () => schemaTypes.decorators.map((dec) => dec.value),
    [schemaTypes.decorators]
  ), marks = useMemo(
    () => uniq((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))),
    [decoratorValues, leaf.marks]
  ), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = useMemo(
    () => annotationMarks.map(
      (mark) => {
        var _a;
        return !decoratorValues.includes(mark) && ((_a = block == null ? void 0 : block.markDefs) == null ? void 0 : _a.find((def) => def._key === mark));
      }
    ).filter(Boolean),
    [annotationMarks, block, decoratorValues]
  ), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;
  useEffect(() => {
    if (!shouldTrackSelectionAndFocus) {
      setFocused(!1);
      return;
    }
    const sel = PortableTextEditor.getSelection(portableTextEditor);
    sel && isEqual(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && startTransition(() => {
      setFocused(!0);
    });
  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);
  const setSelectedFromRange = useCallback(() => {
    if (!shouldTrackSelectionAndFocus)
      return;
    debug$1("Setting selection and focus from range");
    const winSelection = window.getSelection();
    if (!winSelection) {
      setSelected(!1);
      return;
    }
    if (winSelection && winSelection.rangeCount > 0) {
      const range = winSelection.getRangeAt(0);
      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);
    } else
      setSelected(!1);
  }, [shouldTrackSelectionAndFocus]);
  useEffect(() => {
    if (!shouldTrackSelectionAndFocus)
      return;
    const sub = portableTextEditor.change$.subscribe((next) => {
      if (next.type === "blur") {
        setFocused(!1), setSelected(!1);
        return;
      }
      if (next.type === "focus") {
        const sel = PortableTextEditor.getSelection(portableTextEditor);
        sel && isEqual(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();
        return;
      }
      next.type === "selection" && (next.selection && isEqual(next.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange());
    });
    return () => {
      sub.unsubscribe();
    };
  }, [path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), useEffect(() => setSelectedFromRange(), [setSelectedFromRange]);
  const content = useMemo(() => {
    let returnedChildren = children;
    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark) => {
      const schemaType = schemaTypes.decorators.find((dec) => dec.value === mark);
      if (schemaType && renderDecorator) {
        const _props = Object.defineProperty(
          {
            children: returnedChildren,
            editorElementRef: spanRef,
            focused,
            path,
            selected,
            schemaType,
            value: mark
          },
          "type",
          {
            enumerable: !1,
            get() {
              return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType;
            }
          }
        );
        returnedChildren = renderDecorator(_props);
      }
    }), block && annotations.length > 0 && annotations.forEach((annotation) => {
      const schemaType = schemaTypes.annotations.find((t) => t.name === annotation._type);
      if (schemaType)
        if (renderAnnotation) {
          const _props = Object.defineProperty(
            {
              block,
              children: returnedChildren,
              editorElementRef: spanRef,
              focused,
              path,
              selected,
              schemaType,
              value: annotation
            },
            "type",
            {
              enumerable: !1,
              get() {
                return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaType;
              }
            }
          );
          returnedChildren = /* @__PURE__ */ jsx("span", { ref: spanRef, children: renderAnnotation(_props) });
        } else
          returnedChildren = /* @__PURE__ */ jsx(DefaultAnnotation, { annotation, children: /* @__PURE__ */ jsx("span", { ref: spanRef, children: returnedChildren }) });
    }), block && renderChild)) {
      const child = block.children.find((_child) => _child._key === leaf._key);
      if (child) {
        const _props = Object.defineProperty(
          {
            annotations,
            children: /* @__PURE__ */ jsx(Fragment, { children: returnedChildren }),
            editorElementRef: spanRef,
            focused,
            path,
            schemaType: schemaTypes.span,
            selected,
            value: child
          },
          "type",
          {
            enumerable: !1,
            get() {
              return console.warn("Property 'type' is deprecated, use 'schemaType' instead."), schemaTypes.span;
            }
          }
        );
        returnedChildren = renderChild(_props);
      }
    }
    return returnedChildren;
  }, [
    annotations,
    block,
    children,
    focused,
    leaf,
    marks,
    path,
    renderAnnotation,
    renderChild,
    renderDecorator,
    schemaTypes.annotations,
    schemaTypes.decorators,
    schemaTypes.span,
    selected
  ]);
  return useMemo(
    () => /* @__PURE__ */ jsx("span", { ...attributes, ref: spanRef, children: content }, leaf._key),
    [leaf, attributes, content]
  );
}, useIsomorphicEffect = typeof window > "u" ? useEffect : useLayoutEffect;
function useForwardedRef(ref) {
  const innerRef = useRef(null);
  return useIsomorphicEffect(() => {
    ref && (typeof ref == "function" ? ref(innerRef.current) : ref.current = innerRef.current);
  }), innerRef;
}
const debug = debugWithName("component:Editable"), PLACEHOLDER_STYLE = {
  position: "absolute",
  userSelect: "none",
  pointerEvents: "none",
  left: 0,
  right: 0
}, EMPTY_DECORATIONS_STATE = [], PortableTextEditable = forwardRef(function(props, forwardedRef) {
  const {
    hotkeys,
    onBlur,
    onFocus,
    onBeforeInput,
    onPaste,
    onCopy,
    onClick,
    rangeDecorations,
    renderAnnotation,
    renderBlock,
    renderChild,
    renderDecorator,
    renderListItem,
    renderPlaceholder,
    renderStyle,
    selection: propsSelection,
    scrollSelectionIntoView,
    spellCheck,
    ...restProps
  } = props, portableTextEditor = usePortableTextEditor(), readOnly = usePortableTextEditorReadOnlyStatus(), keyGenerator = usePortableTextEditorKeyGenerator(), ref = useForwardedRef(forwardedRef), [editableElement, setEditableElement] = useState(null), [hasInvalidValue, setHasInvalidValue] = useState(!1), [rangeDecorationState, setRangeDecorationsState] = useState(EMPTY_DECORATIONS_STATE), rangeDecorationsRef = useRef(rangeDecorations), { change$, schemaTypes } = portableTextEditor, slateEditor = useSlate(), blockTypeName = schemaTypes.block.name, withInsertData = useMemo(
    () => createWithInsertData(change$, schemaTypes, keyGenerator),
    [change$, keyGenerator, schemaTypes]
  ), withHotKeys = useMemo(
    () => createWithHotkeys(schemaTypes, portableTextEditor, hotkeys),
    [hotkeys, portableTextEditor, schemaTypes]
  );
  useMemo(() => readOnly ? (debug("Editable is in read only mode"), withInsertData(slateEditor)) : (debug("Editable is in edit mode"), withInsertData(withHotKeys(slateEditor))), [readOnly, slateEditor, withHotKeys, withInsertData]);
  const renderElement = useCallback(
    (eProps) => /* @__PURE__ */ jsx(
      Element,
      {
        ...eProps,
        readOnly,
        renderBlock,
        renderChild,
        renderListItem,
        renderStyle,
        schemaTypes,
        spellCheck
      }
    ),
    [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]
  ), renderLeaf = useCallback(
    (lProps) => {
      if (lProps.leaf._type === "span") {
        let rendered = /* @__PURE__ */ jsx(
          Leaf,
          {
            ...lProps,
            schemaTypes,
            renderAnnotation,
            renderChild,
            renderDecorator,
            readOnly
          }
        );
        if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === "")
          return /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx("span", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),
            rendered
          ] });
        const decoration = lProps.leaf.rangeDecoration;
        return decoration && (rendered = decoration.component({ children: rendered })), rendered;
      }
      return lProps.children;
    },
    [readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]
  ), restoreSelectionFromProps = useCallback(() => {
    if (propsSelection) {
      debug(`Selection from props ${JSON.stringify(propsSelection)}`);
      const normalizedSelection = normalizeSelection(
        propsSelection,
        fromSlateValue(slateEditor.children, blockTypeName)
      );
      if (normalizedSelection !== null) {
        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);
        const slateRange = toSlateRange(normalizedSelection, slateEditor);
        slateRange && (Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === "set_selection") || change$.next({ type: "selection", selection: normalizedSelection }), slateEditor.onChange());
      }
    }
  }, [propsSelection, slateEditor, blockTypeName, change$]), syncRangeDecorations = useCallback(
    (operation) => {
      if (rangeDecorations && rangeDecorations.length > 0) {
        const newSlateRanges = [];
        if (rangeDecorations.forEach((rangeDecorationItem) => {
          const slateRange = toSlateRange(rangeDecorationItem.selection, slateEditor);
          if (!Range.isRange(slateRange)) {
            rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({
              newSelection: null,
              rangeDecoration: rangeDecorationItem,
              origin: "local"
            });
            return;
          }
          let newRange;
          if (operation && (newRange = moveRangeByOperation(slateRange, operation), newRange && newRange !== slateRange || newRange === null && slateRange)) {
            const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);
            rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({
              newSelection: newRangeSelection,
              rangeDecoration: rangeDecorationItem,
              origin: "local"
            });
          }
          newRange !== null && newSlateRanges.push({ ...newRange || slateRange, rangeDecoration: rangeDecorationItem });
        }), newSlateRanges.length > 0) {
          setRangeDecorationsState(newSlateRanges);
          return;
        }
      }
      setRangeDecorationsState(EMPTY_DECORATIONS_STATE);
    },
    [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]
  );
  useEffect(() => {
    const sub = change$.subscribe((next) => {
      switch (next.type) {
        case "ready":
          restoreSelectionFromProps();
          break;
        case "invalidValue":
          setHasInvalidValue(!0);
          break;
        case "value":
          setHasInvalidValue(!1);
          break;
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [change$, restoreSelectionFromProps]), useEffect(() => {
    propsSelection && !hasInvalidValue && restoreSelectionFromProps();
  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);
  const originalApply = useMemo(() => slateEditor.apply, [slateEditor]);
  useEffect(() => {
    syncRangeDecorations();
  }, []), useEffect(() => {
    isEqual(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;
  }, [rangeDecorations, syncRangeDecorations]), useEffect(() => (slateEditor.apply = (op) => {
    originalApply(op), op.type !== "set_selection" && syncRangeDecorations(op);
  }, () => {
    slateEditor.apply = originalApply;
  }), [originalApply, slateEditor, syncRangeDecorations]);
  const handleCopy = useCallback(
    (event) => {
      onCopy && onCopy(event) !== void 0 && event.preventDefault();
    },
    [onCopy]
  ), handlePaste = useCallback(
    (event) => {
      if (event.preventDefault(), !!slateEditor.selection) {
        if (!onPaste) {
          debug("Pasting normally"), slateEditor.insertData(event.clipboardData);
          return;
        }
        new Promise((resolve) => {
          const value = PortableTextEditor.getValue(portableTextEditor), ptRange = toPortableTextRange(value, slateEditor.selection, schemaTypes), path = (ptRange == null ? void 0 : ptRange.focus.path) || [];
          resolve(
            onPaste({
              event,
              value,
              path,
              schemaTypes
            })
          );
        }).then((result) => {
          if (debug("Custom paste function from client resolved", result), change$.next({ type: "loading", isLoading: !0 }), !result || !result.insert) {
            debug("No result from custom paste handler, pasting normally"), slateEditor.insertData(event.clipboardData);
            return;
          }
          if (result && result.insert) {
            slateEditor.insertFragment(
              toSlateValue(result.insert, { schemaTypes })
            ), change$.next({ type: "loading", isLoading: !1 });
            return;
          }
          console.warn("Your onPaste function returned something unexpected:", result);
        }).catch((error) => (change$.next({ type: "loading", isLoading: !1 }), console.error(error), error));
      }
    },
    [change$, onPaste, portableTextEditor, schemaTypes, slateEditor]
  ), handleOnFocus = useCallback(
    (event) => {
      if (onFocus && onFocus(event), !event.isDefaultPrevented()) {
        const selection = PortableTextEditor.getSelection(portableTextEditor);
        selection === null && (Transforms.select(slateEditor, Editor.start(slateEditor, [])), slateEditor.onChange()), change$.next({ type: "focus", event });
        const newSelection = PortableTextEditor.getSelection(portableTextEditor);
        selection === newSelection && change$.next({
          type: "selection",
          selection
        });
      }
    },
    [onFocus, portableTextEditor, change$, slateEditor]
  ), handleClick = useCallback(
    (event) => {
      if (onClick && onClick(event), slateEditor.selection && event.target === event.currentTarget) {
        const [lastBlock, path] = Node.last(slateEditor, []), focusPath = slateEditor.selection.focus.path.slice(0, 1), lastPath = path.slice(0, 1);
        if (Path.equals(focusPath, lastPath)) {
          const node = Node.descendant(slateEditor, path.slice(0, 1));
          lastBlock && Editor.isVoid(slateEditor, node) && (Transforms.insertNodes(slateEditor, slateEditor.pteCreateEmptyBlock()), slateEditor.onChange());
        }
      }
    },
    [onClick, slateEditor]
  ), handleOnBlur = useCallback(
    (event) => {
      onBlur && onBlur(event), event.isPropagationStopped() || change$.next({ type: "blur", event });
    },
    [change$, onBlur]
  ), handleOnBeforeInput = useCallback(
    (event) => {
      onBeforeInput && onBeforeInput(event);
    },
    [onBeforeInput]
  ), validateSelection = useCallback(() => {
    if (!slateEditor.selection)
      return;
    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor), { activeElement } = root;
    if (ref.current !== activeElement)
      return;
    const domSelection = ReactEditor.getWindow(slateEditor).getSelection();
    if (!domSelection || domSelection.rangeCount === 0)
      return;
    const existingDOMRange = domSelection.getRangeAt(0);
    try {
      const newDOMRange = ReactEditor.toDOMRange(slateEditor, slateEditor.selection);
      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug("DOM range out of sync, validating selection"), domSelection == null || domSelection.removeAllRanges(), domSelection.addRange(newDOMRange));
    } catch {
      debug("Could not resolve selection, selecting top document"), Transforms.deselect(slateEditor), slateEditor.children.length > 0 && Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();
    }
  }, [ref, slateEditor]);
  useEffect(() => {
    if (editableElement) {
      const mutationObserver = new MutationObserver(validateSelection);
      return mutationObserver.observe(editableElement, {
        attributeOldValue: !1,
        attributes: !1,
        characterData: !1,
        childList: !0,
        subtree: !0
      }), () => {
        mutationObserver.disconnect();
      };
    }
  }, [validateSelection, editableElement]);
  const handleKeyDown = useCallback(
    (event) => {
      props.onKeyDown && props.onKeyDown(event), event.isDefaultPrevented() || slateEditor.pteWithHotKeys(event);
    },
    [props, slateEditor]
  ), scrollSelectionIntoViewToSlate = useMemo(() => {
    if (scrollSelectionIntoView !== void 0)
      return scrollSelectionIntoView === null ? noop : (editor, domRange) => {
        scrollSelectionIntoView(portableTextEditor, domRange);
      };
  }, [portableTextEditor, scrollSelectionIntoView]), decorate = useCallback(
    ([, path]) => {
      if (isEqualToEmptyEditor(slateEditor.children, schemaTypes))
        return [
          {
            anchor: {
              path: [0, 0],
              offset: 0
            },
            focus: {
              path: [0, 0],
              offset: 0
            },
            placeholder: !0
          }
        ];
      if (path.length === 0)
        return EMPTY_DECORATIONS_STATE;
      const result = rangeDecorationState.filter((item) => Range.isCollapsed(item) ? path.length !== 2 ? !1 : Path.equals(item.focus.path, path) && Path.equals(item.anchor.path, path) : Range.intersection(item, { anchor: { path, offset: 0 }, focus: { path, offset: 0 } }) || Range.includes(item, path));
      return result.length > 0 ? result : EMPTY_DECORATIONS_STATE;
    },
    [slateEditor, schemaTypes, rangeDecorationState]
  );
  return useEffect(() => {
    ref.current = ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);
  }, [slateEditor, ref]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ jsx(
    Editable,
    {
      ...restProps,
      autoFocus: !1,
      className: restProps.className || "pt-editable",
      decorate,
      onBlur: handleOnBlur,
      onCopy: handleCopy,
      onClick: handleClick,
      onDOMBeforeInput: handleOnBeforeInput,
      onFocus: handleOnFocus,
      onKeyDown: handleKeyDown,
      onPaste: handlePaste,
      readOnly,
      renderPlaceholder: void 0,
      renderElement,
      renderLeaf,
      scrollSelectionIntoView: scrollSelectionIntoViewToSlate
    }
  ) : null;
});
function compactPatches(patches) {
  const lastPatch = patches.slice(-1)[0];
  if (lastPatch && lastPatch.type === "unset" && lastPatch.path.length === 0)
    return [lastPatch];
  let finalPatches = patches;
  return finalPatches = finalPatches.filter((patch, index) => {
    if (!patch)
      return !1;
    const nextPatch = finalPatches[index + 1];
    return !(nextPatch && nextPatch.type === "set" && patch.type === "set" && isEqual(patch.path, nextPatch.path));
  }), finalPatches.length !== patches.length ? finalPatches : patches;
}
export {
  PortableTextEditable,
  PortableTextEditor,
  compactPatches,
  defaultKeyGenerator as keyGenerator,
  usePortableTextEditor,
  usePortableTextEditorSelection
};
//# sourceMappingURL=index.esm.js.map
