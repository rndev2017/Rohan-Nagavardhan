{"version":3,"file":"index.cjs","sources":["../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","../../src/constants.ts","../../src/util/findNonInlineElement.ts","../../src/util/stega.ts","../../src/util/findSanityNodes.ts","../../src/util/getRect.ts","../../src/controller.ts"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","export {VERCEL_STEGA_REGEX} from '@vercel/stega'\n\nexport const OVERLAY_ID = 'sanity-visual-editing'\n","import type {ElementNode} from '../types'\n\nexport function findNonInlineElement(element: ElementNode): ElementNode | null {\n  const {display} = window.getComputedStyle(element)\n\n  if (display !== 'inline') return element\n\n  const parent = element.parentElement\n\n  if (!parent) return null\n\n  return findNonInlineElement(parent)\n}\n","import type {SanityStegaNode} from '@repo/visual-editing-helpers'\nimport {vercelStegaDecode} from '@vercel/stega'\n\nimport {VERCEL_STEGA_REGEX} from '../constants'\n\n/**\n * JavaScript regexps are stateful. Have to reset lastIndex between runs to ensure consistent behaviour for the same string\n * @param input\n */\nfunction testVercelStegaRegex(input: string): boolean {\n  VERCEL_STEGA_REGEX.lastIndex = 0\n  return VERCEL_STEGA_REGEX.test(input)\n}\n\nfunction decodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  try {\n    const decoded = vercelStegaDecode<SanityStegaNode>(str)\n    if (!decoded || decoded.origin !== 'sanity.io') {\n      return null\n    }\n    if (isAltText) {\n      decoded.href = decoded.href?.replace('.alt', '')\n    }\n    return decoded\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error('Failed to decode stega for string: ', str, 'with the original error: ', err)\n    return null\n  }\n}\n\nexport function testAndDecodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  if (testVercelStegaRegex(str)) {\n    return decodeStega(str, isAltText)\n  }\n  return null\n}\n","import {decodeSanityNodeData} from '@repo/visual-editing-helpers/csm'\n\nimport {OVERLAY_ID} from '../constants'\nimport type {ElementNode, ResolvedElement, SanityNode, SanityStegaNode} from '../types'\nimport {findNonInlineElement} from './findNonInlineElement'\nimport {testAndDecodeStega} from './stega'\n\nconst isElementNode = (node: ChildNode): node is ElementNode => node.nodeType === Node.ELEMENT_NODE\n\nconst isImgElement = (el: ElementNode): el is HTMLImageElement => el.tagName === 'IMG'\n\nconst isTimeElement = (el: ElementNode): el is HTMLTimeElement => el.tagName === 'TIME'\n\nconst isSvgRootElement = (el: ElementNode): el is SVGSVGElement =>\n  el.tagName.toUpperCase() === 'SVG'\n\nfunction isSanityNode(node: SanityNode | SanityStegaNode): node is SanityNode {\n  return 'path' in node\n}\n\n/**\n * Finds commonality between two document paths strings\n * @param first First path to compare\n * @param second Second path to compare\n * @returns A common path\n */\nexport function findCommonPath(first: string, second: string): string {\n  let firstParts = first.split('.')\n  let secondParts = second.split('.')\n  const maxLength = Math.min(firstParts.length, secondParts.length)\n  firstParts = firstParts.slice(0, maxLength).reverse()\n  secondParts = secondParts.slice(0, maxLength).reverse()\n\n  return firstParts\n    .reduce((parts, part, i) => (part === secondParts[i] ? [...parts, part] : []), [] as string[])\n    .reverse()\n    .join('.')\n}\n\n/**\n * Returns common Sanity node data from multiple nodes\n * If document paths are present, tries to resolve a common path\n * @param nodes An array of Sanity nodes\n * @returns A single sanity node or undefined\n * @internal\n */\nexport function findCommonSanityData(\n  nodes: (SanityNode | SanityStegaNode)[],\n): SanityNode | SanityStegaNode | undefined {\n  // If there are no nodes, or inconsistent node types\n  if (!nodes.length || !nodes.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])) {\n    return undefined\n  }\n  // If legacy nodes, return first match (no common pathfinding)\n  if (!isSanityNode(nodes[0])) return nodes[0]\n\n  const sanityNodes = nodes.filter(isSanityNode)\n  let common: SanityNode | undefined = nodes[0]\n\n  const consistentValueKeys: Array<keyof SanityNode> = [\n    'projectId',\n    'dataset',\n    'id',\n    'baseUrl',\n    'workspace',\n    'tool',\n  ]\n  for (let i = 1; i < sanityNodes.length; i++) {\n    const node = sanityNodes[i]\n    if (consistentValueKeys.some((key) => node[key] !== common?.[key])) {\n      common = undefined\n      break\n    }\n\n    common.path = findCommonPath(common.path, node.path)\n  }\n\n  return common\n}\n\n/**\n * Finds nodes containing sanity specific data\n * @param el - A parent element to traverse\n * @returns An array of objects, each containing an HTML element and decoded sanity data\n * @internal\n */\nexport function findSanityNodes(\n  el: ElementNode | ChildNode | {childNodes: Array<ElementNode>},\n): ResolvedElement[] {\n  const elements: ResolvedElement[] = []\n\n  function addElement(element: ElementNode, data: SanityStegaNode | string) {\n    const sanity = decodeSanityNodeData(data)\n    if (!sanity) {\n      return\n    }\n\n    const measureElement = findNonInlineElement(element)\n    if (!measureElement) {\n      return\n    }\n\n    elements.push({\n      elements: {\n        element,\n        measureElement,\n      },\n      sanity,\n    })\n  }\n\n  if (el) {\n    for (const node of el.childNodes) {\n      const {nodeType, parentElement, textContent} = node\n      // If an edit target is found, find common paths\n      if (isElementNode(node) && node.dataset?.['sanityEditTarget'] !== undefined) {\n        const nodesInTarget = findSanityNodes(node).map(({sanity}) => sanity)\n        // If there are inconsistent node types, continue\n        if (!nodesInTarget.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])) {\n          continue\n        }\n\n        const commonData = findCommonSanityData(nodesInTarget)\n\n        if (commonData) {\n          elements.push({\n            elements: {\n              element: node,\n              measureElement: node,\n            },\n            sanity: commonData,\n          })\n        }\n\n        // Check non-empty, child-only text nodes for stega strings\n      } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {\n        const data = testAndDecodeStega(textContent)\n        if (!data) continue\n        addElement(parentElement, data)\n      }\n      // Check element nodes for data attributes, alt tags, etc\n      else if (isElementNode(node)) {\n        // Do not traverse script tags\n        // Do not traverse the visual editing overlay\n        if (node.tagName === 'SCRIPT' || node.id === OVERLAY_ID) {\n          continue\n        }\n\n        // Prefer elements with explicit data attributes\n        if (node.dataset?.['sanity']) {\n          addElement(node, node.dataset['sanity'])\n        }\n        // Look for legacy sanity data attributes\n        else if (node.dataset?.['sanityEditInfo']) {\n          addElement(node, node.dataset['sanityEditInfo'])\n        } else if (isImgElement(node)) {\n          const data = testAndDecodeStega(node.alt, true)\n          if (!data) continue\n          addElement(node, data)\n          // No need to recurse for img elements\n          continue\n        } else if (isTimeElement(node)) {\n          const data = testAndDecodeStega(node.dateTime, true)\n          if (!data) continue\n          addElement(node, data)\n        } else if (isSvgRootElement(node)) {\n          if (!node.ariaLabel) continue\n          const data = testAndDecodeStega(node.ariaLabel, true)\n          if (!data) continue\n          addElement(node, data)\n        }\n\n        elements.push(...findSanityNodes(node))\n      }\n    }\n  }\n  return elements\n}\n","import type {OverlayRect} from '../types'\n\nexport function getRect(element: Element): OverlayRect {\n  const domRect = element.getBoundingClientRect()\n\n  const rect = {\n    x: domRect.x + scrollX,\n    y: domRect.y + scrollY,\n    w: domRect.width,\n    h: domRect.height,\n  }\n\n  return rect\n}\n","import {v4 as uuid} from 'uuid'\n\nimport type {\n  ElementNode,\n  EventHandlers,\n  OverlayController,\n  OverlayElement,\n  OverlayOptions,\n  ResolvedElement,\n} from './types'\nimport {findSanityNodes} from './util/findSanityNodes'\nimport {getRect} from './util/getRect'\n\nconst isElementNode = (target: EventTarget | null): target is ElementNode => {\n  return target instanceof HTMLElement || target instanceof SVGElement\n}\n\n/**\n * Creates a controller which dispatches overlay related events\n *\n * @param handler - Dispatched event handler\n * @param overlayElement - Parent element containing rendered overlay elements\n * @public\n */\nexport function createOverlayController({\n  handler,\n  overlayElement,\n  preventDefault,\n}: OverlayOptions): OverlayController {\n  let activated = false\n  // Map for getting element by ID\n  const elementIdMap = new Map<string, ElementNode>()\n  // WeakMap for getting data by element\n  const elementsMap = new WeakMap<ElementNode, OverlayElement>()\n  // Set for iterating over elements\n  const elementSet = new Set<ElementNode>()\n  // Weakmap keyed by measureElement to find associated element\n  const measureElements = new WeakMap<ElementNode, ElementNode>()\n\n  let ro: ResizeObserver\n  let io: IntersectionObserver | undefined\n  let mo: MutationObserver\n\n  // The `hoverStack` is used as a container for tracking which elements are hovered at any time.\n  // The browser supports hovering multiple nested elements simultanously, but we only want to\n  // highlight the \"outer most\" element.\n  //\n  // This is how it works:\n  // - Whenever the mouse enters an element, we add it to the stack.\n  // - Whenever the mouse leaves an element, we remove it from the stack.\n  //\n  // When we want to know which element is currently hovered, we take the element at the top of the\n  // stack. Since JavaScript does not have a Stack type, we use an array and take the last element.\n  let hoverStack: Array<ElementNode> = []\n  const getHoveredElement = () => hoverStack[hoverStack.length - 1] as ElementNode | undefined\n\n  function addEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.addEventListener('click', handlers.click, {\n      capture: true,\n    })\n    // We listen for the initial mousemove event, in case the overlay is enabled whilst the cursor is already over an element\n    // mouseenter and mouseleave listeners are attached within this handler\n    el.addEventListener('mousemove', handlers.mousemove, {\n      once: true,\n      capture: true,\n    })\n    // Listen for mousedown in case we need to prevent default behavior\n    el.addEventListener('mousedown', handlers.mousedown, {\n      capture: true,\n    })\n  }\n\n  function removeEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.removeEventListener('click', handlers.click, {\n      capture: true,\n    })\n    el.removeEventListener('mousemove', handlers.mousemove, {\n      capture: true,\n    })\n    el.removeEventListener('mousedown', handlers.mousedown, {\n      capture: true,\n    })\n    el.removeEventListener('mouseenter', handlers.mouseenter)\n    el.removeEventListener('mouseleave', handlers.mouseleave)\n  }\n\n  /**\n   * Executed when element enters the viewport\n   * Enables an element’s event handlers\n   */\n  function activateElement({id, elements, handlers, sanity}: OverlayElement) {\n    const {element, measureElement} = elements\n    addEventHandlers(element, handlers)\n    ro.observe(measureElement)\n    handler({\n      type: 'element/activate',\n      id,\n      rect: getRect(element),\n      sanity,\n    })\n  }\n\n  /**\n   * Executed when element leaves the viewport\n   * Disables an element’s event handlers\n   */\n  function deactivateElement({id, elements, handlers}: OverlayElement) {\n    const {element, measureElement} = elements\n    removeEventHandlers(element, handlers)\n    ro.unobserve(measureElement)\n    // Scrolling from a hovered element will not trigger mouseleave event, so filter the stack\n    hoverStack = hoverStack.filter((el) => el !== element)\n    handler({\n      type: 'element/deactivate',\n      id,\n    })\n  }\n\n  /**\n   * Stores an element’s DOM node and decoded sanity data in state and sets up event handlers\n   */\n  function registerElement({elements, sanity}: ResolvedElement) {\n    const {element, measureElement} = elements\n\n    const eventHandlers: EventHandlers = {\n      click(event) {\n        const target = event.target as ElementNode | null\n        if (element === getHoveredElement() && element.contains(target)) {\n          if (preventDefault) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n          handler({\n            type: 'element/click',\n            id,\n            sanity,\n          })\n        }\n      },\n      mousedown(event) {\n        // prevent iframe from taking focus\n        event.preventDefault()\n      },\n      mousemove(event) {\n        eventHandlers.mouseenter(event)\n        const el = event.currentTarget as ElementNode | null\n        if (el) {\n          el.addEventListener('mouseenter', eventHandlers.mouseenter)\n          el.addEventListener('mouseleave', eventHandlers.mouseleave)\n        }\n      },\n      mouseenter() {\n        // If the Vercel Visual Editing provided by Vercel Toolbar is active, do not overlap overlays\n        if (\n          (document.querySelector('vercel-live-feedback') &&\n            element.closest('[data-vercel-edit-info]')) ||\n          element.closest('[data-vercel-edit-target]')\n        ) {\n          return\n        }\n        hoverStack.push(element)\n        handler({\n          type: 'element/mouseenter',\n          id,\n          rect: getRect(element),\n        })\n      },\n      mouseleave(e) {\n        function leave() {\n          hoverStack.pop()\n          const hoveredElement = getHoveredElement()\n\n          handler({\n            type: 'element/mouseleave',\n            id,\n          })\n\n          if (hoveredElement) {\n            const overlayElement = elementsMap.get(hoveredElement)\n            if (overlayElement) {\n              handler({\n                type: 'element/mouseenter',\n                id: overlayElement.id,\n                rect: getRect(hoveredElement),\n              })\n            }\n          }\n        }\n\n        /**\n         * If moving to an element within the overlay which handles pointer events, attach a new\n         * event handler to that element and defer the original leave event\n         */\n        const {relatedTarget} = e as MouseEvent\n        const isInteractiveOverlayElement =\n          isElementNode(relatedTarget) && overlayElement.contains(relatedTarget)\n\n        if (isInteractiveOverlayElement) {\n          const deferredLeave = () => {\n            leave()\n            relatedTarget.removeEventListener('mouseleave', deferredLeave)\n          }\n          relatedTarget.addEventListener('mouseleave', deferredLeave)\n          return\n        }\n\n        leave()\n      },\n    }\n\n    const id = uuid()\n    const sanityNode = {\n      id,\n      elements,\n      sanity,\n      handlers: eventHandlers,\n    }\n    elementSet.add(element)\n    measureElements.set(measureElement, element)\n    elementIdMap.set(id, element)\n    elementsMap.set(element, sanityNode)\n\n    io?.observe(element)\n\n    handler({\n      type: 'element/register',\n      id,\n      rect: getRect(element),\n      sanity,\n    })\n  }\n\n  function registerElements(node: ElementNode | {childNodes: ElementNode[]}) {\n    const sanityNodes = findSanityNodes(node)\n    for (const sanityNode of sanityNodes) {\n      if (\n        isElementNode(sanityNode.elements.element) &&\n        !elementsMap.has(sanityNode.elements.element)\n      ) {\n        registerElement(sanityNode)\n      }\n    }\n  }\n\n  function unregisterElement(element: ElementNode) {\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      const {id, handlers} = overlayElement\n      removeEventHandlers(element, handlers)\n      ro.unobserve(element)\n      elementsMap.delete(element)\n      elementSet.delete(element)\n      elementIdMap.delete(id)\n      handler({\n        type: 'element/unregister',\n        id,\n      })\n    }\n  }\n\n  // Mutations\n  function handleMutation(mutations: MutationRecord[]) {\n    const needsUpdate = !!mutations.filter((mutation) => {\n      const node: Node | null = mutation.target\n\n      // Ignore overlay elements and container\n      if (node === overlayElement || overlayElement.contains(node)) {\n        return false\n      }\n\n      if (isElementNode(node)) {\n        // @todo - We need to handle cases where `data-sanity` attributes may\n        // have changed, so it's not enough to ignore previously registered\n        // elements. We can just unregister and re-register elements instead of\n        // attempting to update their data. Can this be made more efficient?\n        if (elementsMap.has(node)) {\n          unregisterElement(node)\n        }\n        registerElements({childNodes: [node]})\n      }\n\n      return true\n    }).length\n\n    if (needsUpdate) {\n      for (const element of elementSet) {\n        if (element.isConnected) {\n          updateRect(element)\n        } else {\n          unregisterElement(element)\n        }\n      }\n    }\n  }\n\n  /**\n\n   * Dispatches an event containing the size and position (rect) of an element\n   * @param el - Element to dispatch rect information for\n   */\n  function updateRect(el: ElementNode) {\n    const overlayElement = elementsMap.get(el)\n    if (overlayElement) {\n      handler({\n        type: 'element/updateRect',\n        id: overlayElement.id,\n        rect: getRect(el),\n      })\n    }\n  }\n\n  function handleResize(entries: ResizeObserverEntry[]) {\n    for (const entry of entries) {\n      const target = entry.target\n\n      if (isElementNode(target)) {\n        const element = measureElements.get(target)\n        if (!element) return\n        updateRect(element)\n      }\n    }\n  }\n\n  function handleIntersection(entries: IntersectionObserverEntry[]) {\n    if (!activated) return\n    for (const entry of entries) {\n      const {target} = entry\n      const match = isElementNode(target) && elementsMap.get(target)\n      if (!match) continue\n      if (entry.isIntersecting) {\n        activateElement(match)\n      } else {\n        deactivateElement(match)\n      }\n    }\n  }\n\n  function handleBlur() {\n    hoverStack = []\n    handler({\n      type: 'overlay/blur',\n    })\n  }\n\n  function handleWindowResize() {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  }\n\n  function handleWindowScroll(event: Event) {\n    const {target} = event\n\n    if (target === window.document || !isElementNode(target)) {\n      return\n    }\n\n    for (const element of elementSet) {\n      if (target.contains(element)) {\n        updateRect(element)\n      }\n    }\n  }\n\n  function activate() {\n    if (activated) return\n    io = new IntersectionObserver(handleIntersection, {\n      threshold: 0.3,\n    })\n    elementSet.forEach((element) => io!.observe(element))\n    handler({\n      type: 'overlay/activate',\n    })\n    activated = true\n  }\n\n  function deactivate() {\n    if (!activated) return\n    io?.disconnect()\n    elementSet.forEach((element) => {\n      const overlayElement = elementsMap.get(element)\n      if (overlayElement) {\n        deactivateElement(overlayElement)\n      }\n    })\n    handler({\n      type: 'overlay/deactivate',\n    })\n    activated = false\n  }\n\n  function destroy() {\n    window.removeEventListener('click', handleBlur)\n    window.removeEventListener('resize', handleWindowResize)\n    window.removeEventListener('scroll', handleWindowScroll)\n    mo.disconnect()\n    ro.disconnect()\n\n    elementSet.forEach((element) => {\n      unregisterElement(element)\n    })\n\n    elementIdMap.clear()\n    elementSet.clear()\n\n    hoverStack = []\n    deactivate()\n  }\n\n  function create() {\n    window.addEventListener('click', handleBlur)\n    window.addEventListener('resize', handleWindowResize)\n    window.addEventListener('scroll', handleWindowScroll, {\n      capture: true,\n      passive: true,\n    })\n    ro = new ResizeObserver(handleResize)\n    mo = new MutationObserver(handleMutation)\n    mo.observe(document.body, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n\n    registerElements(document.body)\n    activate()\n  }\n\n  window.document.fonts.ready.then(() => {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  })\n\n  create()\n\n  return {\n    activate,\n    deactivate,\n    destroy,\n  }\n}\n"],"names":["createDataAttribute_index","require","stega","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","OVERLAY_ID","findNonInlineElement","element","display","window","getComputedStyle","parent","parentElement","testAndDecodeStega","str","isAltText","input","VERCEL_STEGA_REGEX","lastIndex","test","_a","decoded","vercelStegaDecode","origin","href","replace","err","console","error","decodeStega","isElementNode","node","nodeType","Node","ELEMENT_NODE","isImgElement","el","tagName","isTimeElement","isSvgRootElement","toUpperCase","isSanityNode","findCommonPath","first","second","firstParts","split","secondParts","maxLength","Math","min","length","reverse","reduce","parts","part","join","findCommonSanityData","nodes","map","n","every","_i","sanityNodes","filter","common","consistentValueKeys","some","key","path","findSanityNodes","_b","_c","elements","addElement","data","sanity","decodeSanityNodeData","measureElement","childNodes","textContent","dataset","sanityEditTarget","nodesInTarget","commonData","TEXT_NODE","id","sanityEditInfo","alt","dateTime","ariaLabel","getRect","domRect","getBoundingClientRect","x","scrollX","y","scrollY","w","width","h","height","target","HTMLElement","SVGElement","exports","O","c","handler","overlayElement","preventDefault","activated","elementIdMap","Map","elementsMap","WeakMap","elementSet","Set","measureElements","ro","io","mo","hoverStack","getHoveredElement","removeEventHandlers","handlers","removeEventListener","click","capture","mousemove","mousedown","mouseenter","mouseleave","activateElement","addEventListener","once","addEventHandlers","observe","type","rect","deactivateElement","unobserve","registerElement","eventHandlers","event","contains","stopPropagation","currentTarget","document","querySelector","closest","e","leave","pop","hoveredElement","get","relatedTarget","deferredLeave","uuid","sanityNode","add","set","registerElements","has","unregisterElement","delete","handleMutation","mutations","mutation","isConnected","updateRect","handleResize","entries","entry","handleIntersection","match","isIntersecting","handleBlur","handleWindowResize","handleWindowScroll","activate","IntersectionObserver","threshold","forEach","deactivate","disconnect","fonts","ready","then","passive","ResizeObserver","MutationObserver","body","attributes","characterData","childList","subtree","destroy","clear","v"],"mappings":"aAAA,IAAAA,EAAAC,QAAA,+BAAAC,EAAAD,QAAA,iBAGA,IAAIE,EAHJF,QAAA,6BAIA,MAAMG,EAAQ,IAAIC,WAAW,IACd,SAASC,IAEtB,IAAKH,IAEHA,SAAyBI,OAAW,KAAeA,OAAOJ,iBAAmBI,OAAOJ,gBAAgBK,KAAKD,SAEpGJ,GACG,MAAA,IAAIM,MAAM,4GAIpB,OAAON,EAAgBC,EACzB,CCXA,MAAMM,EAAY,GAElB,IAAA,IAASC,EAAI,EAAGA,EAAI,MAAOA,EACfD,EAAAE,MAAMD,EAAI,KAAOE,SAAS,IAAIC,MAAM,ICRhD,IAAeC,EAAA,CACbC,kBAFwBT,OAAW,KAAeA,OAAOS,YAAcT,OAAOS,WAAWR,KAAKD,SCIhG,SAASU,EAAGC,EAASC,EAAKC,GACxB,GAAIL,EAAOC,aAAeG,IAAQD,EAChC,OAAOH,EAAOC,aAIhB,MAAMK,GADNH,EAAUA,GAAW,IACAI,SAAWJ,EAAQZ,KAAOA,KAE/C,OAAAe,EAAK,GAAe,GAAVA,EAAK,GAAY,GAC3BA,EAAK,GAAe,GAAVA,EAAK,GAAY,IFDtB,SAAyBE,EAAKH,EAAS,GAGrC,OAAAV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,IAAMV,EAAUa,EAAIH,EAAS,IAAM,IAAMV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,KAAOV,EAAUa,EAAIH,EAAS,IAChf,CESSI,CAAgBH,EACzB,CCxBO,MAAMI,EAAa,wBCAnB,SAASC,EAAqBC,GACnC,MAAMC,QAACA,GAAWC,OAAOC,iBAAiBH,GAEtC,GAAY,WAAZC,EAA6B,OAAAD,EAEjC,MAAMI,EAASJ,EAAQK,cAElB,OAAAD,EAEEL,EAAqBK,GAFR,IAGtB,CCmBgB,SAAAE,EAAmBC,EAAaC,GAAY,GAC1D,OAvB4BC,EAuBHF,EAtBzBG,EAAAA,mBAAmBC,UAAY,EACxBD,EAAAA,mBAAmBE,KAAKH,GAGjC,SAAqBF,EAAaC,GAAY,GAd9C,IAAAK,EAeM,IACI,MAAAC,EAAUC,oBAAmCR,GACnD,OAAKO,GAA8B,cAAnBA,EAAQE,QAGpBR,IACFM,EAAQG,KAAO,OAAAJ,EAAQC,EAAAG,WAAM,EAAAJ,EAAAK,QAAQ,OAAQ,KAExCJ,GALE,WAMFK,GAEP,OAAAC,QAAQC,MAAM,sCAAuCd,EAAK,4BAA6BY,GAChF,IACT,CACF,CAIWG,CAAYf,EAAKC,GAEnB,KA1BT,IAA8BC,CA2B9B,CC7BA,MAAMc,EAAiBC,GAAyCA,EAAKC,WAAaC,KAAKC,aAEjFC,EAAgBC,GAA2D,QAAfA,EAAGC,QAE/DC,EAAiBF,GAA0D,SAAfA,EAAGC,QAE/DE,EAAoBH,GACK,QAA7BA,EAAGC,QAAQG,cAEb,SAASC,EAAaV,GACpB,MAAO,SAAUA,CACnB,CAQgB,SAAAW,EAAeC,EAAeC,GACxC,IAAAC,EAAaF,EAAMG,MAAM,KACzBC,EAAcH,EAAOE,MAAM,KAC/B,MAAME,EAAYC,KAAKC,IAAIL,EAAWM,OAAQJ,EAAYI,QAC1D,OAAAN,EAAaA,EAAWnD,MAAM,EAAGsD,GAAWI,UAC5CL,EAAcA,EAAYrD,MAAM,EAAGsD,GAAWI,UAEvCP,EACJQ,QAAO,CAACC,EAAOC,EAAMhE,IAAOgE,IAASR,EAAYxD,GAAK,IAAI+D,EAAOC,GAAQ,IAAK,IAC9EH,UACAI,KAAK,IACV,CASO,SAASC,EACdC,GAGI,IAACA,EAAMP,SAAWO,EAAMC,KAAKC,GAAMnB,EAAamB,KAAIC,OAAM,CAACD,EAAGE,EAAI3D,IAAQyD,IAAMzD,EAAI,KACtF,OAGE,IAACsC,EAAaiB,EAAM,IAAK,OAAOA,EAAM,GAEpC,MAAAK,EAAcL,EAAMM,OAAOvB,GAC7B,IAAAwB,EAAiCP,EAAM,GAE3C,MAAMQ,EAA+C,CACnD,YACA,UACA,KACA,UACA,YACA,QAEF,IAAA,IAAS3E,EAAI,EAAGA,EAAIwE,EAAYZ,OAAQ5D,IAAK,CACrC,MAAAwC,EAAOgC,EAAYxE,GACrB,GAAA2E,EAAoBC,MAAMC,GAAQrC,EAAKqC,MAAkB,MAATH,OAAS,EAAAA,EAAAG,MAAO,CACzDH,OAAA,EACT,KACF,CAEAA,EAAOI,KAAO3B,EAAeuB,EAAOI,KAAMtC,EAAKsC,KACjD,CAEO,OAAAJ,CACT,CAQO,SAASK,EACdlC,GAvFF,IAAAhB,EAAAmD,EAAAC,EAyFE,MAAMC,EAA8B,GAE3B,SAAAC,EAAWnE,EAAsBoE,GAClC,MAAAC,EAASC,IAAqBF,GACpC,IAAKC,EACH,OAGI,MAAAE,EAAiBxE,EAAqBC,GACvCuE,GAILL,EAASjF,KAAK,CACZiF,SAAU,CACRlE,UACAuE,kBAEFF,UAEJ,CAEI,GAAAxC,EACS,IAAA,MAAAL,KAAQK,EAAG2C,WAAY,CAChC,MAAM/C,SAACA,EAAApB,cAAUA,EAAeoE,YAAAA,GAAejD,EAE3CD,GAAAA,EAAcC,SAAgD,KAAvC,OAAAX,IAAK6D,cAAL,EAAA7D,EAAe8D,kBAAmC,CACrE,MAAAC,EAAgBb,EAAgBvC,GAAM4B,KAAI,EAAEiB,YAAYA,IAE9D,IAAKO,EAAcxB,KAAKC,GAAMnB,EAAamB,KAAIC,OAAM,CAACD,EAAGE,EAAI3D,IAAQyD,IAAMzD,EAAI,KAC7E,SAGI,MAAAiF,EAAa3B,EAAqB0B,GAEpCC,GACFX,EAASjF,KAAK,CACZiF,SAAU,CACRlE,QAASwB,EACT+C,eAAgB/C,GAElB6C,OAAQQ,GAKH,MAAA,GAAApD,IAAaC,KAAKoD,WAAazE,GAAiBoE,EAAa,CAChE,MAAAL,EAAO9D,EAAmBmE,GAChC,IAAKL,EAAM,SACXD,EAAW9D,EAAe+D,EAAI,MAAA,GAGvB7C,EAAcC,GAAO,CAG5B,GAAqB,WAAjBA,EAAKM,SAAwBN,EAAKuD,KAAOjF,EAC3C,SAIE,GAAA,OAAAkE,EAAAxC,EAAKkD,UAAUV,EAAAK,OACNF,EAAA3C,EAAMA,EAAKkD,QAAQL,aAAS,GAGhC,OAAAJ,EAAAzC,EAAKkD,UAAUT,EAAAe,eACXb,EAAA3C,EAAMA,EAAKkD,QAAQM,oBACrB,IAAApD,EAAaJ,GAAO,CAC7B,MAAM4C,EAAO9D,EAAmBkB,EAAKyD,KAAK,GAC1C,IAAKb,EAAM,SACXD,EAAW3C,EAAM4C,GAEjB,QAAA,CAAA,GACSrC,EAAcP,GAAO,CAC9B,MAAM4C,EAAO9D,EAAmBkB,EAAK0D,UAAU,GAC/C,IAAKd,EAAM,SACXD,EAAW3C,EAAM4C,EAAI,MAAA,GACZpC,EAAiBR,GAAO,CAC7B,IAACA,EAAK2D,UAAW,SACrB,MAAMf,EAAO9D,EAAmBkB,EAAK2D,WAAW,GAChD,IAAKf,EAAM,SACXD,EAAW3C,EAAM4C,EACnB,EAEAF,EAASjF,QAAQ8E,EAAgBvC,GACnC,CACF,CAEK,OAAA0C,CACT,CC/KO,SAASkB,EAAQpF,GAChB,MAAAqF,EAAUrF,EAAQsF,wBAEX,MAAA,CACXC,EAAGF,EAAQE,EAAIC,QACfC,EAAGJ,EAAQI,EAAIC,QACfC,EAAGN,EAAQO,MACXC,EAAGR,EAAQS,OAIf,CCAA,MAAMvE,EAAiBwE,GACdA,aAAkBC,aAAeD,aAAkBE,WA4a5DC,QAAAC,EAAArG,EAAAoG,QAAAE,EAlaO,UAAiCC,QACtCA,EAAAC,eACAA,EAAAC,eACAA,IAEA,IAAIC,GAAY,EAEhB,MAAMC,EAAe,IAAIC,IAEnBC,EAAkB,IAAAC,QAElBC,EAAiB,IAAAC,IAEjBC,MAAsBH,QAE5B,IAAII,EACAC,EACAC,EAYAC,EAAiC,GACrC,MAAMC,EAAoB,IAAMD,EAAWA,EAAWvE,OAAS,GAkBtD,SAAAyE,EAAoBxF,EAAiByF,GACzCzF,EAAA0F,oBAAoB,QAASD,EAASE,MAAO,CAC9CC,SAAS,IAEX5F,EAAG0F,oBAAoB,YAAaD,EAASI,UAAW,CACtDD,SAAS,IAEX5F,EAAG0F,oBAAoB,YAAaD,EAASK,UAAW,CACtDF,SAAS,IAEX5F,EAAG0F,oBAAoB,aAAcD,EAASM,YAC9C/F,EAAG0F,oBAAoB,aAAcD,EAASO,WAChD,CAMA,SAASC,GAAgB/C,GAACA,EAAAb,SAAIA,EAAUoD,SAAAA,EAAAjD,OAAUA,IAC1C,MAAArE,QAACA,EAASuE,eAAAA,GAAkBL,GAnC3B,SAAiBrC,EAAiByF,GACtCzF,EAAAkG,iBAAiB,QAAST,EAASE,MAAO,CAC3CC,SAAS,IAIX5F,EAAGkG,iBAAiB,YAAaT,EAASI,UAAW,CACnDM,MAAM,EACNP,SAAS,IAGX5F,EAAGkG,iBAAiB,YAAaT,EAASK,UAAW,CACnDF,SAAS,GAEb,EAsBEQ,CAAiBjI,EAASsH,GAC1BN,EAAGkB,QAAQ3D,GACX8B,EAAQ,CACN8B,KAAM,mBACNpD,KACAqD,KAAMhD,EAAQpF,GACdqE,UAEJ,CAMA,SAASgE,GAAkBtD,GAACA,EAAIb,SAAAA,EAAAoD,SAAUA,IAClC,MAAAtH,QAACA,EAASuE,eAAAA,GAAkBL,EAClCmD,EAAoBrH,EAASsH,GAC7BN,EAAGsB,UAAU/D,GAEb4C,EAAaA,EAAW1D,QAAQ5B,GAAOA,IAAO7B,IAC9CqG,EAAQ,CACN8B,KAAM,qBACNpD,MAEJ,CAKA,SAASwD,GAAgBrE,SAACA,EAAUG,OAAAA,IAClC,MAAMrE,QAACA,EAAAuE,eAASA,GAAkBL,EAE5BsE,EAA+B,CACnC,KAAAhB,CAAMiB,GACJ,MAAM1C,EAAS0C,EAAM1C,OACjB/F,IAAYoH,KAAuBpH,EAAQ0I,SAAS3C,KAClDQ,IACFkC,EAAMlC,iBACNkC,EAAME,mBAERtC,EAAQ,CACN8B,KAAM,gBACNpD,KACAV,WAGN,EACA,SAAAsD,CAAUc,GAERA,EAAMlC,gBACR,EACA,SAAAmB,CAAUe,GACRD,EAAcZ,WAAWa,GACzB,MAAM5G,EAAK4G,EAAMG,cAEf/G,IAAAA,EAAGkG,iBAAiB,aAAcS,EAAcZ,YAChD/F,EAAGkG,iBAAiB,aAAcS,EAAcX,YAEpD,EACA,UAAAD,GAGKiB,SAASC,cAAc,yBACtB9I,EAAQ+I,QAAQ,4BAClB/I,EAAQ+I,QAAQ,+BAIlB5B,EAAWlI,KAAKe,GAChBqG,EAAQ,CACN8B,KAAM,qBACNpD,KACAqD,KAAMhD,EAAQpF,KAElB,EACA,UAAA6H,CAAWmB,GACT,SAASC,IACP9B,EAAW+B,MACX,MAAMC,EAAiB/B,IAOvB,GALAf,EAAQ,CACN8B,KAAM,qBACNpD,OAGEoE,EAAgB,CACZ7C,MAAAA,EAAiBK,EAAYyC,IAAID,GACnC7C,GACFD,EAAQ,CACN8B,KAAM,qBACNpD,GAAIuB,EAAevB,GACnBqD,KAAMhD,EAAQ+D,IAGpB,CACF,CAMM,MAAAE,cAACA,GAAiBL,EAIxB,GAFEzH,EAAc8H,IAAkB/C,EAAeoC,SAASW,GAE1D,CACE,MAAMC,EAAgB,KACpBL,IACAI,EAAc9B,oBAAoB,aAAc+B,EAAa,EAEjDD,EAAAtB,iBAAiB,aAAcuB,EAE/C,SAGF,GAGIvE,EAAKwE,IACLC,EAAa,CACjBzE,KACAb,WACAG,SACAiD,SAAUkB,GAED3B,EAAA4C,IAAIzJ,GACf+G,EAAgB2C,IAAInF,EAAgBvE,GACpCyG,EAAaiD,IAAI3E,EAAI/E,GACrB2G,EAAY+C,IAAI1J,EAASwJ,GAEzB,MAAAvC,GAAAA,EAAIiB,QAAQlI,GAEZqG,EAAQ,CACN8B,KAAM,mBACNpD,KACAqD,KAAMhD,EAAQpF,GACdqE,UAEJ,CAEA,SAASsF,EAAiBnI,GAClB,MAAAgC,EAAcO,EAAgBvC,GACpC,IAAA,MAAWgI,KAAchG,EAErBjC,EAAciI,EAAWtF,SAASlE,WACjC2G,EAAYiD,IAAIJ,EAAWtF,SAASlE,UAErCuI,EAAgBiB,EAGtB,CAEA,SAASK,EAAkB7J,GACnBsG,MAAAA,EAAiBK,EAAYyC,IAAIpJ,GACvC,GAAIsG,EAAgB,CACZ,MAAAvB,GAACA,EAAIuC,SAAAA,GAAYhB,EACvBe,EAAoBrH,EAASsH,GAC7BN,EAAGsB,UAAUtI,GACb2G,EAAYmD,OAAO9J,GACnB6G,EAAWiD,OAAO9J,GAClByG,EAAaqD,OAAO/E,GACpBsB,EAAQ,CACN8B,KAAM,qBACNpD,MAEJ,CACF,CAGA,SAASgF,EAAeC,GACA,GAAAA,EAAUvG,QAAQwG,IACtC,MAAMzI,EAAoByI,EAASlE,OAG/B,OAAAvE,IAAS8E,IAAkBA,EAAeoC,SAASlH,KAInDD,EAAcC,KAKZmF,EAAYiD,IAAIpI,IAClBqI,EAAkBrI,GAEpBmI,EAAiB,CAACnF,WAAY,CAAChD,OAG1B,EAAA,IACNoB,OAGD,IAAA,MAAW5C,KAAW6G,EAChB7G,EAAQkK,YACVC,EAAWnK,GAEX6J,EAAkB7J,EAI1B,CAOA,SAASmK,EAAWtI,GACZyE,MAAAA,EAAiBK,EAAYyC,IAAIvH,GACnCyE,GACFD,EAAQ,CACN8B,KAAM,qBACNpD,GAAIuB,EAAevB,GACnBqD,KAAMhD,EAAQvD,IAGpB,CAEA,SAASuI,EAAaC,GACpB,IAAA,MAAWC,KAASD,EAAS,CAC3B,MAAMtE,EAASuE,EAAMvE,OAEjB,GAAAxE,EAAcwE,GAAS,CACnB,MAAA/F,EAAU+G,EAAgBqC,IAAIrD,GACpC,IAAK/F,EAAS,OACdmK,EAAWnK,EACb,CACF,CACF,CAEA,SAASuK,EAAmBF,GACrB,GAAA7D,EACL,IAAA,MAAW8D,KAASD,EAAS,CACrB,MAAAtE,OAACA,GAAUuE,EACXE,EAAQjJ,EAAcwE,IAAWY,EAAYyC,IAAIrD,GAClDyE,IACDF,EAAMG,eACR3C,EAAgB0C,GAEhBnC,EAAkBmC,GAEtB,CACF,CAEA,SAASE,IACMvD,EAAA,GACbd,EAAQ,CACN8B,KAAM,gBAEV,CAEA,SAASwC,IACP,IAAA,MAAW3K,KAAW6G,EACpBsD,EAAWnK,EAEf,CAEA,SAAS4K,EAAmBnC,GACpB,MAAA1C,OAACA,GAAU0C,EAEjB,GAAe1C,IAAA7F,OAAO2I,UAAatH,EAAcwE,GAIjD,IAAA,MAAW/F,KAAW6G,EAChBd,EAAO2C,SAAS1I,IAClBmK,EAAWnK,EAGjB,CAEA,SAAS6K,IAEPrE,IAAAS,EAAK,IAAI6D,qBAAqBP,EAAoB,CAChDQ,UAAW,KAEblE,EAAWmE,SAAShL,GAAYiH,EAAIiB,QAAQlI,KAC5CqG,EAAQ,CACN8B,KAAM,qBAER3B,GAAY,EACd,CAEA,SAASyE,IAEPzE,IAAI,MAAJS,GAAIA,EAAAiE,aACJrE,EAAWmE,SAAShL,IACZsG,MAAAA,EAAiBK,EAAYyC,IAAIpJ,GACnCsG,GACF+B,EAAkB/B,EAAc,IAGpCD,EAAQ,CACN8B,KAAM,uBAER3B,GAAY,EACd,CAwCA,OAAAtG,OAAO2I,SAASsC,MAAMC,MAAMC,MAAK,KAC/B,IAAA,MAAWrL,KAAW6G,EACpBsD,EAAWnK,EAAO,IArBpBE,OAAO6H,iBAAiB,QAAS2C,GACjCxK,OAAO6H,iBAAiB,SAAU4C,GAClCzK,OAAO6H,iBAAiB,SAAU6C,EAAoB,CACpDnD,SAAS,EACT6D,SAAS,IAEXtE,EAAK,IAAIuE,eAAenB,GACxBlD,EAAK,IAAIsE,iBAAiBzB,GAC1B7C,EAAGgB,QAAQW,SAAS4C,KAAM,CACxBC,YAAY,EACZC,eAAe,EACfC,WAAW,EACXC,SAAS,IAGXlC,EAAiBd,SAAS4C,MAC1BZ,IAWK,CACLA,WACAI,aACAa,QAjDF,WACS5L,OAAAqH,oBAAoB,QAASmD,GACpCxK,OAAOqH,oBAAoB,SAAUoD,GACrCzK,OAAOqH,oBAAoB,SAAUqD,GACrC1D,EAAGgE,aACHlE,EAAGkE,aAEHrE,EAAWmE,SAAShL,IAClB6J,EAAkB7J,EAAO,IAG3ByG,EAAasF,QACblF,EAAWkF,QAEX5E,EAAa,GACb8D,GACF,EAmCF,EAAA/E,QAAA8F,EAAA1M","x_google_ignoreList":[0,1,2,3]}