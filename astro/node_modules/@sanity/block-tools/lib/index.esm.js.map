{"version":3,"file":"index.esm.js","sources":["../src/util/findBlockType.ts","../src/util/resolveJsType.ts","../../types/lib/index.mjs","../../../../node_modules/.pnpm/@vercel+stega@0.1.2/node_modules/@vercel/stega/dist/index.mjs","../src/constants.ts","../src/util/blockContentTypeFeatures.ts","../src/HtmlDeserializer/preprocessors/xpathResult.ts","../src/HtmlDeserializer/preprocessors/gdocs.ts","../src/HtmlDeserializer/preprocessors/html.ts","../src/HtmlDeserializer/preprocessors/notion.ts","../src/HtmlDeserializer/preprocessors/whitespace.ts","../src/HtmlDeserializer/preprocessors/word.ts","../src/HtmlDeserializer/preprocessors/index.ts","../src/HtmlDeserializer/helpers.ts","../src/HtmlDeserializer/rules/gdocs.ts","../src/util/randomKey.ts","../src/HtmlDeserializer/rules/html.ts","../src/HtmlDeserializer/rules/notion.ts","../src/HtmlDeserializer/rules/word.ts","../src/HtmlDeserializer/rules/index.ts","../src/HtmlDeserializer/index.ts","../src/util/normalizeBlock.ts","../src/index.ts"],"sourcesContent":["import {type BlockSchemaType, type SchemaType} from '@sanity/types'\n\nexport function findBlockType(type: SchemaType): type is BlockSchemaType {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return true\n  }\n\n  return false\n}\n","const toString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (toString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","function isObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction isReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\";\n}\nfunction isImage(value) {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith(\"image-\");\n}\nfunction isCrossDatasetReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\" && typeof reference._dataset == \"string\" && typeof reference._projectId == \"string\";\n}\nfunction isSanityDocument(document) {\n  return isObject(document) && typeof document._id == \"string\" && typeof document._type == \"string\";\n}\nfunction isTypedObject(obj) {\n  return isObject(obj) && typeof obj._type == \"string\";\n}\nfunction isKeyedObject(obj) {\n  return isObject(obj) && typeof obj._key == \"string\";\n}\nfunction isValidationErrorMarker(marker) {\n  return marker.level === \"error\";\n}\nfunction isValidationWarningMarker(marker) {\n  return marker.level === \"warning\";\n}\nfunction isValidationInfoMarker(marker) {\n  return marker.level === \"info\";\n}\nfunction isCreateMutation(mutation) {\n  return \"create\" in mutation;\n}\nfunction isCreateIfNotExistsMutation(mutation) {\n  return \"createIfNotExists\" in mutation;\n}\nfunction isCreateOrReplaceMutation(mutation) {\n  return \"createOrReplace\" in mutation;\n}\nfunction isDeleteMutation(mutation) {\n  return \"delete\" in mutation;\n}\nfunction isPatchMutation(mutation) {\n  return \"patch\" in mutation;\n}\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment == \"number\" || typeof segment == \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment == \"string\" && reIndexTuple.test(segment))\n    return !0;\n  if (!Array.isArray(segment) || segment.length !== 2)\n    return !1;\n  const [from, to] = segment;\n  return (typeof from == \"number\" || from === \"\") && (typeof to == \"number\" || to === \"\");\n}\nfunction isRecord$1(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isPortableTextTextBlock(value) {\n  return isRecord$1(value) && typeof value._type == \"string\" && // block types can be named, so expect anything here.\n  Array.isArray(value.children) && value.children.every((child) => isRecord$1(child)) && (\"markDefs\" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord$1(def)) : !1) && (\"style\" in value ? typeof value.style == \"string\" : !0);\n}\nfunction isPortableTextSpan(value) {\n  return isRecord$1(value) && value._type === \"span\" && typeof value.text == \"string\" && (\"marks\" in value ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark == \"string\") : !0);\n}\nfunction isPortableTextListBlock(value) {\n  return isPortableTextTextBlock(value) && \"listItem\" in value && typeof value.listItem == \"string\" && \"level\" in value && Number.isInteger(value.level);\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isDocumentSchemaType(type) {\n  if (!isObjectSchemaType(type))\n    return !1;\n  let current = type;\n  for (; current; ) {\n    if (current.name === \"document\")\n      return !0;\n    current = current.type;\n  }\n  return !1;\n}\nfunction isObjectSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"object\" : !1;\n}\nfunction isArraySchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"array\" : !1;\n}\nfunction isArrayOfBlocksSchemaType(type) {\n  return isArraySchemaType(type) && type.of.some((memberType) => isBlockSchemaType(memberType));\n}\nfunction isArrayOfObjectsSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType));\n}\nfunction isArrayOfPrimitivesSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType));\n}\nfunction isBooleanSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"boolean\" : !1;\n}\nfunction isStringSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"string\" : !1;\n}\nfunction isNumberSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"number\" : !1;\n}\nfunction isPrimitiveSchemaType(type) {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);\n}\nfunction isReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"reference\" || isReferenceSchemaType(type.type));\n}\nfunction isDeprecatedSchemaType(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isDeprecationConfiguration(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isCrossDatasetReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"crossDatasetReference\" || isCrossDatasetReferenceSchemaType(type.type));\n}\nfunction isTitledListValue(item) {\n  return typeof item == \"object\" && item !== null && \"title\" in item && \"value\" in item;\n}\nfunction isSpanSchemaType(type) {\n  return isRecord(type) ? Array.isArray(type.annotations) && Array.isArray(type.decorators) : !1;\n}\nfunction isBlockSchemaType(type) {\n  if (!isRecord(type) || !Array.isArray(type.fields)) return !1;\n  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField), maybeStyle = type.fields.find(isBlockStyleObjectField), maybeList = type.fields.find(isBlockListObjectField);\n  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);\n}\nfunction isBlockStyleObjectField(field) {\n  return !isRecord(field) || field.name !== \"style\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockListObjectField(field) {\n  return !isRecord(field) || field.name !== \"listItem\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockChildrenObjectField(field) {\n  return !isRecord(field) || field.name !== \"children\" || !isArraySchemaType(field.type) ? !1 : field.type.of.some(isSpanSchemaType);\n}\nfunction defineType(schemaDefinition, defineOptions) {\n  return schemaDefinition;\n}\nfunction defineField(schemaField, defineOptions) {\n  return schemaField;\n}\nfunction defineArrayMember(arrayOfSchema, defineOptions) {\n  return arrayOfSchema;\n}\nfunction typed(input) {\n  return input;\n}\nfunction isSlug(thing) {\n  return isObject(thing) && typeof thing.current == \"string\";\n}\nfunction isCreateSquashedMutation(mutation) {\n  return \"createSquashed\" in mutation;\n}\nfunction isValidationError(node) {\n  return node.level === \"error\";\n}\nfunction isValidationWarning(node) {\n  return node.level === \"warning\";\n}\nfunction isValidationInfo(node) {\n  return node.level === \"info\";\n}\nexport {\n  defineArrayMember,\n  defineField,\n  defineType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isArrayOfPrimitivesSchemaType,\n  isArraySchemaType,\n  isBlockChildrenObjectField,\n  isBlockListObjectField,\n  isBlockSchemaType,\n  isBlockStyleObjectField,\n  isBooleanSchemaType,\n  isCreateIfNotExistsMutation,\n  isCreateMutation,\n  isCreateOrReplaceMutation,\n  isCreateSquashedMutation,\n  isCrossDatasetReference,\n  isCrossDatasetReferenceSchemaType,\n  isDeleteMutation,\n  isDeprecatedSchemaType,\n  isDeprecationConfiguration,\n  isDocumentSchemaType,\n  isImage,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  isKeyedObject,\n  isNumberSchemaType,\n  isObjectSchemaType,\n  isPatchMutation,\n  isPortableTextListBlock,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  isPrimitiveSchemaType,\n  isReference,\n  isReferenceSchemaType,\n  isSanityDocument,\n  isSlug,\n  isSpanSchemaType,\n  isStringSchemaType,\n  isTitledListValue,\n  isTypedObject,\n  isValidationError,\n  isValidationErrorMarker,\n  isValidationInfo,\n  isValidationInfoMarker,\n  isValidationWarning,\n  isValidationWarningMarker,\n  typed\n};\n//# sourceMappingURL=index.mjs.map\n","var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {uniq} from 'lodash'\n\nexport interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<string, {object: null} | undefined> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = uniq(\n  Object.values(ELEMENT_MAP)\n    .filter((tag): tag is PartialBlock => 'style' in tag)\n    .map((tag) => tag.style),\n)\n\nexport const DEFAULT_SUPPORTED_DECORATORS = uniq(Object.values(HTML_DECORATOR_TAGS))\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","import {\n  type ArraySchemaType,\n  type BlockSchemaType,\n  type EnumListProps,\n  type I18nTitledListValue,\n  isBlockChildrenObjectField,\n  isBlockListObjectField,\n  isBlockSchemaType,\n  isBlockStyleObjectField,\n  isObjectSchemaType,\n  isTitledListValue,\n  type ObjectSchemaType,\n  type SpanSchemaType,\n  type TitledListValue,\n} from '@sanity/types'\n\nimport {type BlockContentFeatures, type ResolvedAnnotationType} from '../types'\nimport {findBlockType} from './findBlockType'\n\n// Helper method for describing a blockContentType's feature set\nexport default function blockContentFeatures(\n  blockContentType: ArraySchemaType,\n): BlockContentFeatures {\n  if (!blockContentType) {\n    throw new Error(\"Parameter 'blockContentType' required\")\n  }\n\n  const blockType = blockContentType.of.find(findBlockType)\n  if (!isBlockSchemaType(blockType)) {\n    throw new Error(\"'block' type is not defined in this schema (required).\")\n  }\n\n  const ofType = blockType.fields.find(isBlockChildrenObjectField)?.type?.of\n  if (!ofType) {\n    throw new Error('No `of` declaration found for blocks `children` field')\n  }\n\n  const spanType = ofType.find((member): member is SpanSchemaType => member.name === 'span')\n  if (!spanType) {\n    throw new Error('No `span` type found in `block` schema type `children` definition')\n  }\n\n  const inlineObjectTypes = ofType.filter(\n    (inlineType): inlineType is ObjectSchemaType =>\n      inlineType.name !== 'span' && isObjectSchemaType(inlineType),\n  )\n\n  const blockObjectTypes = blockContentType.of.filter(\n    (memberType): memberType is ObjectSchemaType =>\n      memberType.name !== blockType.name && isObjectSchemaType(memberType),\n  )\n\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    annotations: resolveEnabledAnnotationTypes(spanType),\n    lists: resolveEnabledListItems(blockType),\n    types: {\n      block: blockContentType,\n      span: spanType,\n      inlineObjects: inlineObjectTypes,\n      blockObjects: blockObjectTypes,\n    },\n  }\n}\n\nfunction resolveEnabledStyles(blockType: BlockSchemaType): TitledListValue<string>[] {\n  const styleField = blockType.fields.find(isBlockStyleObjectField)\n  if (!styleField) {\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\")\n  }\n\n  const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options)\n  if (textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n\n  return textStyles\n}\n\nfunction resolveEnabledAnnotationTypes(spanType: SpanSchemaType): ResolvedAnnotationType[] {\n  return spanType.annotations.map((annotation) => ({\n    title: annotation.title,\n    type: annotation,\n    value: annotation.name,\n    icon: annotation.icon,\n  }))\n}\n\nfunction resolveEnabledDecorators(spanType: SpanSchemaType): TitledListValue<string>[] {\n  return spanType.decorators\n}\n\nfunction resolveEnabledListItems(blockType: BlockSchemaType): I18nTitledListValue<string>[] {\n  const listField = blockType.fields.find(isBlockListObjectField)\n  if (!listField) {\n    throw new Error(\"A field with name 'list' is not defined in the block type (required).\")\n  }\n\n  const listItems = getTitledListValuesFromEnumListOptions(listField.type.options)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n\n  return listItems\n}\n\nfunction getTitledListValuesFromEnumListOptions(\n  options: EnumListProps<string> | undefined,\n): I18nTitledListValue<string>[] {\n  const list = options ? options.list : undefined\n  if (!Array.isArray(list)) {\n    return []\n  }\n\n  return list.map((item) => (isTitledListValue(item) ? item : {title: item, value: item}))\n}\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import {type HtmlPreprocessorOptions} from '../../types'\nimport {normalizeWhitespace, removeAllWhitespace, tagName} from '../helpers'\nimport {_XPathResult} from './xpathResult'\n\nexport default (html: string, doc: Document, options: HtmlPreprocessorOptions): Document => {\n  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || 'preserve'\n  let gDocsRootOrSiblingNode = doc\n    .evaluate(\n      '//*[@id and contains(@id, \"docs-internal-guid\")]',\n      doc,\n      null,\n      _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n      null,\n    )\n    .iterateNext()\n\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === 'b'\n\n    // If this document isn't wrapped in a 'b' tag, then assume all siblings live on the root level\n    if (!isWrappedRootTag) {\n      gDocsRootOrSiblingNode = doc.body\n    }\n\n    switch (whitespaceOnPasteMode) {\n      case 'normalize':\n        // Keep only 1 empty block between content nodes\n        normalizeWhitespace(gDocsRootOrSiblingNode)\n        break\n      case 'remove':\n        // Remove all whitespace nodes\n        removeAllWhitespace(gDocsRootOrSiblingNode)\n        break\n      default:\n        break\n    }\n\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n\n      if (\n        elm?.parentElement === gDocsRootOrSiblingNode ||\n        (!isWrappedRootTag && elm.parentElement === doc.body)\n      ) {\n        elm?.setAttribute('data-is-root-node', 'true')\n        tagName(elm)\n      }\n\n      // Handle checkmark lists - The first child of a list item is an image with a checkmark, and the serializer\n      // expects the first child to be the text node\n      if (tagName(elm) === 'li' && elm.firstChild && tagName(elm?.firstChild) === 'img') {\n        elm.removeChild(elm.firstChild)\n      }\n    }\n\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    if (isWrappedRootTag) {\n      doc.body.firstElementChild?.replaceWith(...Array.from(gDocsRootOrSiblingNode.childNodes))\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport default (html: string, doc: Document): Document => {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nexport default (html: string, doc: Document): Document => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g\n\n  if (html.match(NOTION_REGEX)) {\n    // Tag every child with attribute 'is-notion' so that the Notion rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-notion', 'true')\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {PRESERVE_WHITESPACE_TAGS} from '../../constants'\nimport {_XPathResult} from './xpathResult'\n\nexport default (_: string, doc: Document): Document => {\n  // Recursively process all nodes.\n  function processNode(node: Node) {\n    // If this is a text node and not inside a tag where whitespace should be preserved, process it.\n    if (\n      node.nodeType === _XPathResult.BOOLEAN_TYPE &&\n      !PRESERVE_WHITESPACE_TAGS.includes(node.parentElement?.tagName.toLowerCase() || '')\n    ) {\n      node.textContent =\n        node.textContent\n          ?.replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n          .replace(/[\\r\\n]+/g, ' ') || '' // Replace newlines with spaces\n    }\n    // Otherwise, if this node has children, process them.\n    else {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        processNode(node.childNodes[i])\n      }\n    }\n  }\n\n  // Process all nodes starting from the root.\n  processNode(doc.body)\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport default (html: string, doc: Document): Document => {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = new Text(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = document.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = document.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import preprocessGDocs from './gdocs'\nimport preprocessHTML from './html'\nimport preprocessNotion from './notion'\nimport preprocessWhitespace from './whitespace'\nimport preprocessWord from './word'\n\nexport default [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML,\n]\n","import {\n  type ArraySchemaType,\n  isPortableTextTextBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {vercelStegaClean} from '@vercel/stega'\nimport {isEqual} from 'lodash'\n\nimport {DEFAULT_BLOCK} from '../constants'\nimport {\n  type BlockEnabledFeatures,\n  type HtmlParser,\n  type HtmlPreprocessorOptions,\n  type MinimalBlock,\n  type MinimalSpan,\n  type PlaceholderAnnotation,\n  type PlaceholderDecorator,\n  type TypedObject,\n} from '../types'\nimport blockContentTypeFeatures from '../util/blockContentTypeFeatures'\nimport {resolveJsType} from '../util/resolveJsType'\nimport preprocessors from './preprocessors'\n\n/**\n * A utility function to create the options needed for the various rule sets,\n * based on the structure of the blockContentType\n *\n * @param blockContentType - Schema type for array containing _at least_ a block child type\n * @returns\n */\nexport function createRuleOptions(blockContentType: ArraySchemaType): BlockEnabledFeatures {\n  const features = blockContentTypeFeatures(blockContentType)\n  const enabledBlockStyles = features.styles.map((item) => item.value || item.title)\n  const enabledSpanDecorators = features.decorators.map((item) => item.value || item.title)\n  const enabledBlockAnnotations = features.annotations.map((item) => item.value || item.title || '')\n  const enabledListTypes = features.lists.map((item) => item.value || item.title || '')\n  return {\n    enabledBlockStyles,\n    enabledSpanDecorators,\n    enabledBlockAnnotations,\n    enabledListTypes,\n  }\n}\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n// TODO: make this plugin-style\nexport function preprocess(\n  html: string,\n  parseHtml: HtmlParser,\n  options: HtmlPreprocessorOptions,\n): Document {\n  const cleanHTML = vercelStegaClean(html)\n  const doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML))\n  preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options)\n  })\n  return doc\n}\n\nfunction normalizeHtmlBeforePreprocess(html: string): string {\n  return html.trim()\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nexport function flattenNestedBlocks(blocks: TypedObject[]): TypedObject[] {\n  let depth = 0\n  const flattened: TypedObject[] = []\n  const traverse = (nodes: TypedObject[]) => {\n    const toRemove: TypedObject[] = []\n    nodes.forEach((node) => {\n      if (depth === 0) {\n        flattened.push(node)\n      }\n      if (isPortableTextTextBlock(node)) {\n        if (depth > 0) {\n          toRemove.push(node)\n          flattened.push(node)\n        }\n        depth++\n        traverse(node.children)\n      }\n      if (node._type === '__block') {\n        toRemove.push(node)\n        flattened.push((node as any).block)\n      }\n    })\n    toRemove.forEach((node) => {\n      nodes.splice(nodes.indexOf(node), 1)\n    })\n    depth--\n  }\n  traverse(blocks)\n  return flattened\n}\n\nfunction nextSpan(block: PortableTextTextBlock, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: PortableTextTextBlock, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n\n/**\n * NOTE: _mutates_ passed blocks!\n *\n * @param blocks - Array of blocks to trim whitespace for\n * @returns\n */\nexport function trimWhitespace(blocks: TypedObject[]): TypedObject[] {\n  blocks.forEach((block) => {\n    if (!isPortableTextTextBlock(block)) {\n      return\n    }\n\n    // eslint-disable-next-line complexity\n    block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child)) {\n        return\n      }\n      const nextChild = nextSpan(block, index)\n      const prevChild = prevSpan(block, index)\n      if (index === 0) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (index === block.children.length - 1) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) &&\n        nextChild &&\n        isMinimalSpan(nextChild) &&\n        /\\s/.test(nextChild.text.slice(0, 1))\n      ) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.slice(0, 1)) &&\n        prevChild &&\n        isMinimalSpan(prevChild) &&\n        /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1)))\n      ) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (!child.text) {\n        block.children.splice(index, 1)\n      }\n      if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {\n        prevChild.text += ' '\n        block.children.splice(index, 1)\n      } else if (\n        nextChild &&\n        isEqual(nextChild.marks, child.marks) &&\n        isWhiteSpaceChar(child.text)\n      ) {\n        nextChild.text = ` ${nextChild.text}`\n        block.children.splice(index, 1)\n      }\n    })\n  })\n\n  return blocks\n}\n\nexport function ensureRootIsBlocks(blocks: TypedObject[]): TypedObject[] {\n  return blocks.reduce((memo, node, i, original) => {\n    if (node._type === 'block') {\n      memo.push(node)\n      return memo\n    }\n\n    if (node._type === '__block') {\n      memo.push((node as any).block)\n      return memo\n    }\n\n    const lastBlock = memo[memo.length - 1]\n    if (\n      i > 0 &&\n      !isPortableTextTextBlock(original[i - 1]) &&\n      isPortableTextTextBlock<TypedObject>(lastBlock)\n    ) {\n      lastBlock.children.push(node)\n      return memo\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    memo.push(block)\n    return memo\n  }, [] as TypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) == '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(node: TypedObject): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(node: TypedObject): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n\n/**\n * Helper to normalize whitespace to only 1 empty block between content nodes\n * @param node - Root node to process\n */\nexport function normalizeWhitespace(rootNode: Node) {\n  let emptyBlockCount = 0\n  let lastParent = null\n  const nodesToRemove: Node[] = []\n\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child)\n      emptyBlockCount = 0\n      continue\n    }\n\n    const elm = child as HTMLElement\n\n    if (isWhitespaceBlock(elm)) {\n      if (lastParent && elm.parentElement === lastParent) {\n        emptyBlockCount++\n        if (emptyBlockCount > 1) {\n          nodesToRemove.push(elm)\n        }\n      } else {\n        // Different parent, reset counter\n        emptyBlockCount = 1\n      }\n\n      lastParent = elm.parentElement\n    } else {\n      // Recurse into child nodes\n      normalizeWhitespace(child)\n      // Reset counter for siblings\n      emptyBlockCount = 0\n    }\n  }\n\n  // Remove marked nodes\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node))\n}\n\n/**\n * Helper to remove all whitespace nodes\n * @param node - Root node to process\n */\nexport function removeAllWhitespace(rootNode: Node) {\n  const nodesToRemove: Node[] = []\n\n  function collectNodesToRemove(currentNode: Node) {\n    if (isElement(currentNode)) {\n      const elm = currentNode as HTMLElement\n\n      // Handle <br> tags that is between <p> tags\n      if (\n        tagName(elm) === 'br' &&\n        (tagName(elm.nextElementSibling) === 'p' || tagName(elm.previousElementSibling) === 'p')\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Handle empty blocks\n      if (\n        (tagName(elm) === 'p' || tagName(elm) === 'br') &&\n        elm?.firstChild?.textContent?.trim() === ''\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Recursively process child nodes\n      for (let child = elm.firstChild; child; child = child.nextSibling) {\n        collectNodesToRemove(child)\n      }\n    }\n  }\n\n  collectNodesToRemove(rootNode)\n\n  // Remove the collected nodes\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node))\n}\n\nfunction isWhitespaceBlock(elm: HTMLElement): boolean {\n  return ['p', 'br'].includes(tagName(elm) || '') && !elm.textContent?.trim()\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport {type BlockEnabledFeatures, type DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style\\s*:\\s*italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight\\s*:\\s*700/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  if (!isElement(el) || tagName(el.parentNode) === 'a') {\n    return false\n  }\n\n  const style = isElement(el) && el.getAttribute('style')\n\n  return /text-decoration\\s*:\\s*underline/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for strike-through in their html\n// allows for line-through regex to be more lineient to allow for other text-decoration before or after\nfunction isStrikethrough(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction isRootNode(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-root-node'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(el: Node, enabledBlockStyles: string[]): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!enabledBlockStyles.includes(block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport default function createGDocsRules(\n  _blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures,\n): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isStrikethrough(el)) {\n            span.marks.push('strike-through')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(el, options.enabledBlockStyles),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el.classList.contains('apple-interchange-newline')\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs inside empty paragraphs\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el?.parentNode?.textContent === ''\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs on the root\n        if (tagName(el) === 'br' && isGoogleDocs(el) && isElement(el) && isRootNode(el)) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import getRandomValues from 'get-random-values-esm'\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).slice(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_DECORATOR_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_SPAN_TAGS,\n  type PartialBlock,\n} from '../../constants'\nimport {type BlockEnabledFeatures, type DeserializerRule} from '../../types'\nimport {randomKey} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\n\nexport function resolveListItem(\n  listNodeTagName: string,\n  enabledListTypes: string[],\n): string | undefined {\n  if (listNodeTagName === 'ul' && enabledListTypes.includes('bullet')) {\n    return 'bullet'\n  }\n  if (listNodeTagName === 'ol' && enabledListTypes.includes('number')) {\n    return 'number'\n  }\n  return undefined\n}\n\nexport default function createHTMLRules(\n  blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures,\n): DeserializerRule[] {\n  return [\n    // Text nodes\n    {\n      deserialize(el) {\n        if (tagName(el) === 'pre') {\n          return undefined\n        }\n        const isValidWhiteSpace =\n          el.nodeType === 3 &&\n          (el.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') === ' ' &&\n          el.nextSibling &&\n          el.nextSibling.nodeType !== 3 &&\n          el.previousSibling &&\n          el.previousSibling.nodeType !== 3\n        const isValidText =\n          (isValidWhiteSpace || el.textContent !== ' ') && tagName(el.parentNode) !== 'body'\n        if (el.nodeName === '#text' && isValidText) {\n          return {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: (el.textContent || '').replace(/\\s\\s+/g, ' '),\n          }\n        }\n        return undefined\n      },\n    }, // Pre element\n    {\n      deserialize(el) {\n        if (tagName(el) !== 'pre') {\n          return undefined\n        }\n\n        const isCodeEnabled = options.enabledBlockStyles.includes('code')\n\n        return {\n          _type: 'block',\n          style: 'normal',\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? ['code'] : [],\n              text: el.textContent || '',\n            },\n          ],\n        }\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n\n        const children: HTMLElement[] = []\n        el.childNodes.forEach((node, index) => {\n          if (\n            node.nodeType === 1 &&\n            Object.keys(blocks).includes((node as Element).localName.toLowerCase())\n          ) {\n            if (!el.ownerDocument) {\n              return\n            }\n\n            const span = el.ownerDocument.createElement('span')\n            span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n            if (index !== el.childNodes.length) {\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el.parentNode) === 'li') {\n          return next(el.childNodes)\n        }\n        // If style is not supported, return a defaultBlockType\n        if (!options.enabledBlockStyles.includes(block.style)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        const parentTag = tagName(el.parentNode) || ''\n        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {\n          return undefined\n        }\n        const enabledListItem = resolveListItem(parentTag, options.enabledListTypes)\n        // If the list item style is not supported, return a new default block\n        if (!enabledListItem) {\n          return block({_type: 'block', children: next(el.childNodes)})\n        }\n        listItem.listItem = enabledListItem\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) != 'a') {\n          return undefined\n        }\n        const linkEnabled = options.enabledBlockAnnotations.includes('link')\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        let markDef\n        if (linkEnabled) {\n          markDef = {\n            _key: randomKey(12),\n            _type: 'link',\n            href: href,\n          }\n          return {\n            _type: '__annotation',\n            markDef: markDef,\n            children: next(el.childNodes),\n          }\n        }\n        return el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes)\n      },\n    },\n  ]\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {DEFAULT_SPAN, HTML_BLOCK_TAGS, HTML_HEADER_TAGS} from '../../constants'\nimport {type DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 or 600 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight:700/.test(style || '') || /font-weight:600/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration:underline/.test(style || '')\n}\n\n// Check for attribute given by the Notion preprocessor\nfunction isNotion(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-notion'))\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nexport default function createNotionRules(_blockContentType: ArraySchemaType): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        // Notion normally exports semantic HTML. However, if you copy a single block, the formatting will be inline styles\n        // This handles a limited set of styles\n        if (isElement(el) && tagName(el) === 'span' && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {BLOCK_DEFAULT_STYLE, DEFAULT_BLOCK} from '../../constants'\nimport {type DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  return isElement(el) && el.className\n    ? el.className === 'MsoListParagraphCxSpFirst' ||\n        el.className === 'MsoListParagraphCxSpMiddle' ||\n        el.className === 'MsoListParagraphCxSpLast'\n    : false\n}\n\nexport default function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'p' && isWordListElement(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {type ArraySchemaType} from '@sanity/types'\n\nimport {type BlockEnabledFeatures, type DeserializerRule} from '../../types'\nimport createGDocsRules from './gdocs'\nimport createHTMLRules from './html'\nimport createNotionRules from './notion'\nimport createWordRules from './word'\n\nexport function createRules(\n  blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures,\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(blockContentType),\n    ...createGDocsRules(blockContentType, options),\n    ...createHTMLRules(blockContentType, options),\n  ]\n}\n","import {\n  type ArraySchemaType,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {flatten} from 'lodash'\n\nimport {\n  type ArbitraryTypedObject,\n  type DeserializerRule,\n  type HtmlDeserializerOptions,\n  type PlaceholderAnnotation,\n  type PlaceholderDecorator,\n  type TypedObject,\n} from '../types'\nimport {findBlockType} from '../util/findBlockType'\nimport {resolveJsType} from '../util/resolveJsType'\nimport {\n  createRuleOptions,\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  flattenNestedBlocks,\n  isMinimalBlock,\n  isMinimalSpan,\n  isNodeList,\n  isPlaceholderAnnotation,\n  isPlaceholderDecorator,\n  preprocess,\n  tagName,\n  trimWhitespace,\n} from './helpers'\nimport {createRules} from './rules'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  blockContentType: ArraySchemaType\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  _markDefs: PortableTextObject[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(blockContentType: ArraySchemaType, options: HtmlDeserializerOptions = {}) {\n    const {rules = [], unstable_whitespaceOnPasteMode = 'preserve'} = options\n    if (!blockContentType) {\n      throw new Error(\"Parameter 'blockContentType' is required\")\n    }\n    const standardRules = createRules(blockContentType, createRuleOptions(blockContentType))\n    this.rules = [...rules, ...standardRules]\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.blockContentType = blockContentType\n    this.parseHtml = (html) => {\n      const doc = preprocess(html, parseHtml, {unstable_whitespaceOnPasteMode})\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n    // Ensure that there are no blocks within blocks, and trim whitespace\n    const blocks = trimWhitespace(\n      flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children))),\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block): block is PortableTextTextBlock => block._type === 'block')\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return flatten(block.children.map((child) => child.marks || [])).includes(def._key)\n            }),\n          )\n        })\n    }\n\n    // Set back the potentially hoisted block type\n    const type = this.blockContentType.of.find(findBlockType)\n    if (!type) {\n      return blocks\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = type.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (elements: Node | Node[] | NodeList): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {\n        throw new Error(`A rule returned an invalid deserialized representation: \"${node}\".`)\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && 'listItem' in ret) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === 'blockquote') {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if ('children' in node && Array.isArray((node as PortableTextBlock).children)) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation: PlaceholderAnnotation): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if ('children' in node && Array.isArray((node as PortableTextBlock).children)) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import {isPortableTextSpan, type PortableTextSpan, type PortableTextTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\n\nimport {type TypedObject} from '../types'\nimport {randomKey} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {},\n): Omit<TypedObject | PortableTextTextBlock<TypedObject | PortableTextSpan>, '_key'> & {\n  _key: string\n} {\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node ? (node as TypedObject & {_key: string}) : {...node, _key: randomKey(12)}\n  }\n\n  const block: Omit<PortableTextTextBlock<TypedObject | PortableTextSpan>, 'style'> = {\n    _key: randomKey(12),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: `${block._key}${0}`,\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce(\n      (acc, child) => {\n        const previousChild = acc[acc.length - 1]\n        if (\n          previousChild &&\n          isPortableTextSpan(child) &&\n          isPortableTextSpan(previousChild) &&\n          isEqual(previousChild.marks, child.marks)\n        ) {\n          if (lastChild && lastChild === child && child.text === '' && block.children.length > 1) {\n            return acc\n          }\n\n          previousChild.text += child.text\n          return acc\n        }\n        acc.push(child)\n        return acc\n      },\n      [] as (TypedObject | PortableTextSpan)[],\n    )\n    .map((child, index) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = `${block._key}${index}`\n      if (isPortableTextSpan(child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs?.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = (block.markDefs || []).filter((markDef) => usedMarkDefs.includes(markDef._key))\n  return block\n}\n","import {type ArraySchemaType, type PortableTextTextBlock} from '@sanity/types'\n\nimport HtmlDeserializer from './HtmlDeserializer'\nimport {type BlockContentFeatures, type HtmlDeserializerOptions, type TypedObject} from './types'\nimport blockContentTypeFeatures from './util/blockContentTypeFeatures'\nimport {normalizeBlock} from './util/normalizeBlock'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param blockContentType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  blockContentType: ArraySchemaType,\n  options: HtmlDeserializerOptions = {},\n): (TypedObject | PortableTextTextBlock)[] {\n  const deserializer = new HtmlDeserializer(blockContentType, options)\n  return deserializer.deserialize(html).map((block) => normalizeBlock(block))\n}\n\n/**\n * Normalize and extract features of an schema type containing a block type\n *\n * @param blockContentType - Schema type for the block type\n * @returns Returns the featureset of a compiled block content type.\n * @public\n */\nexport function getBlockContentFeatures(blockContentType: ArraySchemaType): BlockContentFeatures {\n  return blockContentTypeFeatures(blockContentType)\n}\n\nexport {normalizeBlock}\nexport {randomKey} from './util/randomKey'\nexport type {BlockContentFeatures, HtmlDeserializerOptions, TypedObject}\nexport type {\n  ArbitraryTypedObject,\n  BlockEditorSchemaProps,\n  DeserializerRule,\n  HtmlParser,\n  ResolvedAnnotationType,\n} from './types'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\n"],"names":["_","blockContentTypeFeatures","vercelStegaClean","blocks","isEmphasis","isStrong","isUnderline","getListItemStyle","getListItemLevel","parseHtml"],"mappings":"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","x_google_ignoreList":[3]}