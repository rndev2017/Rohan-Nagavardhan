{"version":3,"file":"_internal.esm.js","sources":["../src/legacy/actionUtils.ts","../src/sanity/extractSchema.ts","../src/sanity/validation/createValidationResult.ts","../src/sanity/groupProblems.ts","../src/sanity/validation/utils/getDupes.ts","../src/core/traverseSchema.ts","../src/sanity/coreTypes.ts","../src/sanity/traverseSchema.ts","../src/sanity/validation/types/array.ts","../src/sanity/validation/utils/isJSONTypeOf.ts","../src/sanity/validation/types/block.ts","../src/sanity/validation/utils/validateNonObjectFieldsProp.ts","../src/sanity/validation/utils/validateTypeName.ts","../src/sanity/validation/types/deprecated.ts","../src/sanity/validation/types/common.ts","../src/sanity/validation/types/crossDatasetReference.ts","../src/sanity/validation/utils/isComponent.ts","../src/sanity/validation/utils/validateComponent.ts","../src/sanity/validation/types/object.ts","../src/sanity/validation/types/document.ts","../src/sanity/validation/types/file.ts","../src/sanity/validation/types/image.ts","../src/sanity/validation/types/reference.ts","../src/sanity/validation/types/rootType.ts","../src/sanity/validation/types/slug.ts","../src/sanity/validateSchema.ts"],"sourcesContent":["import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {type SchemaType} from '@sanity/types'\nimport {difference} from 'lodash'\n\nconst ACTIONS_FLAG = '__experimental_actions'\n\nconst DEFAULT_ACTIONS = ['create', 'update', 'delete', 'publish']\nconst VALID_ACTIONS = DEFAULT_ACTIONS\n\n// todo: enable this when officially deprecating experimental actions\nconst DEPRECATE_EXPERIMENTAL_ACTIONS = false\n\nconst hasWarned = {}\nconst readActions = (schemaType: SchemaType): string[] => {\n  if (DEPRECATE_EXPERIMENTAL_ACTIONS && !(schemaType.name in hasWarned)) {\n    console.warn(`Heads up! Experimental actions is now deprecated and replaced by Document Actions. Read more about how to migrate on ${generateHelpUrl(\n      'experimental-actions-replaced-by-document-actions',\n    )}\".\n`)\n    ;(hasWarned as any)[schemaType.name] = true\n  }\n\n  return ACTIONS_FLAG in schemaType ? (schemaType[ACTIONS_FLAG] as string[]) : DEFAULT_ACTIONS\n}\n\nconst validateActions = (typeName: string, actions: string[]) => {\n  if (!Array.isArray(actions)) {\n    throw new Error(\n      `The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(\n        ', ',\n      )}`,\n    )\n  }\n\n  const invalid = difference(actions, VALID_ACTIONS)\n\n  if (invalid.length > 0) {\n    throw new Error(\n      `Invalid action${\n        invalid.length > 1 ? 's' : ''\n      } configured for schema type \"${typeName}\": ${invalid.join(\n        ', ',\n      )}. Valid actions are: ${VALID_ACTIONS.join(', ')}`,\n    )\n  }\n\n  return actions\n}\n\nexport const resolveEnabledActions = (schemaType: SchemaType): string[] =>\n  validateActions(schemaType.name, readActions(schemaType))\n\nexport const isActionEnabled = (schemaType: SchemaType, action: string): boolean =>\n  resolveEnabledActions(schemaType).includes(action)\n","import {\n  type ArraySchemaType,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type Schema as SchemaDef,\n  type SchemaType as SanitySchemaType,\n  type StringSchemaType,\n} from '@sanity/types'\nimport {\n  type ArrayTypeNode,\n  createReferenceTypeNode,\n  type DocumentSchemaType,\n  type InlineTypeNode,\n  type NullTypeNode,\n  type NumberTypeNode,\n  type ObjectAttribute,\n  type ObjectTypeNode,\n  type SchemaType,\n  type StringTypeNode,\n  type TypeDeclarationSchemaType,\n  type TypeNode,\n  type UnionTypeNode,\n  type UnknownTypeNode,\n} from 'groq-js'\n\nconst documentDefaultFields = (typeName: string): Record<string, ObjectAttribute> => ({\n  _id: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _type: {\n    type: 'objectAttribute',\n    value: {type: 'string', value: typeName},\n  },\n  _createdAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _updatedAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _rev: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n})\nconst typesMap = new Map<string, TypeNode>([\n  ['text', {type: 'string'}],\n  ['url', {type: 'string'}],\n  ['datetime', {type: 'string'}],\n  ['date', {type: 'string'}],\n  ['boolean', {type: 'boolean'}],\n  ['email', {type: 'string'}],\n])\n\nexport interface ExtractSchemaOptions {\n  enforceRequiredFields?: boolean\n}\n\nexport function extractSchema(\n  schemaDef: SchemaDef,\n  extractOptions: ExtractSchemaOptions = {},\n): SchemaType {\n  const inlineFields = new Set<SanitySchemaType>()\n  const schema: SchemaType = []\n\n  // get a list of all the types in the schema, sorted by their dependencies. This ensures that when we check for inline/reference types, we have already processed the type\n  const sortedSchemaTypeNames = sortByDependencies(schemaDef)\n  sortedSchemaTypeNames.forEach((typeName) => {\n    const schemaType = schemaDef.get(typeName)\n    if (schemaType === undefined) {\n      return\n    }\n    const base = convertBaseType(schemaType)\n    if (base === null) {\n      return\n    }\n    if (base.type === 'type') {\n      inlineFields.add(schemaType)\n    }\n\n    schema.push(base)\n  })\n\n  function convertBaseType(\n    schemaType: SanitySchemaType,\n  ): DocumentSchemaType | TypeDeclarationSchemaType | null {\n    let typeName: string | undefined\n    if (schemaType.type) {\n      typeName = schemaType.type.name\n    } else if ('jsonType' in schemaType) {\n      typeName = schemaType.jsonType\n    }\n\n    if (typeName === 'document' && isObjectType(schemaType)) {\n      const defaultAttributes = documentDefaultFields(schemaType.name)\n\n      const object = createObject(schemaType)\n      if (object.type === 'unknown') {\n        return null\n      }\n\n      return {\n        name: schemaType.name,\n        type: 'document',\n        attributes: {\n          ...defaultAttributes,\n          ...object.attributes,\n        },\n      }\n    }\n\n    const value = convertSchemaType(schemaType)\n    if (value.type === 'unknown') {\n      return null\n    }\n    if (value.type === 'object') {\n      return {\n        name: schemaType.name,\n        type: 'type',\n        value: {\n          type: 'object',\n          attributes: {\n            _type: {\n              type: 'objectAttribute',\n              value: {\n                type: 'string',\n                value: schemaType.name,\n              },\n            },\n            ...value.attributes,\n          },\n        },\n      }\n    }\n\n    return {\n      name: schemaType.name,\n      type: 'type',\n      value,\n    }\n  }\n\n  function convertSchemaType(schemaType: SanitySchemaType): TypeNode {\n    if (lastType(schemaType)?.name === 'document') {\n      return createReferenceTypeNode(schemaType.name)\n    }\n\n    // if we have already seen the base type, we can just reference it\n    if (inlineFields.has(schemaType.type!)) {\n      return {type: 'inline', name: schemaType.type!.name} satisfies InlineTypeNode\n    }\n\n    // If we have a type that is point to a type, that is pointing to a type, we assume this is a circular reference\n    // and we return an inline type referencing it instead\n    if (schemaType.type?.type?.name === 'object') {\n      return {type: 'inline', name: schemaType.type.name} satisfies InlineTypeNode\n    }\n\n    if (isStringType(schemaType)) {\n      return createStringTypeNodeDefintion(schemaType)\n    }\n\n    if (isNumberType(schemaType)) {\n      return createNumberTypeNodeDefintion(schemaType)\n    }\n\n    // map some known types\n    if (schemaType.type && typesMap.has(schemaType.type.name)) {\n      return typesMap.get(schemaType.type.name)!\n    }\n\n    // Cross dataset references are not supported\n    if (isCrossDatasetReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies UnknownTypeNode // we don't support cross-dataset references at the moment\n    }\n\n    if (isReferenceType(schemaType)) {\n      return createReferenceTypeNodeDefintion(schemaType)\n    }\n\n    if (isArrayType(schemaType)) {\n      return createArray(schemaType)\n    }\n\n    if (isObjectType(schemaType)) {\n      return createObject(schemaType)\n    }\n\n    throw new Error(`Type \"${schemaType.name}\" not found`)\n  }\n\n  function createObject(\n    schemaType: ObjectSchemaType | SanitySchemaType,\n  ): ObjectTypeNode | UnknownTypeNode {\n    const attributes: Record<string, ObjectAttribute> = {}\n\n    const fields = gatherFields(schemaType)\n    for (const field of fields) {\n      const fieldIsRequired = isFieldRequired(field)\n      const value = convertSchemaType(field.type)\n      if (value === null) {\n        continue\n      }\n\n      // if the field sets assetRequired() we will mark the asset attribute as required\n      // also guard against the case where the field is not an object, though type validation should catch this\n      if (hasAssetRequired(field) && value.type === 'object') {\n        value.attributes.asset.optional = false\n      }\n\n      // if we extract with enforceRequiredFields, we will mark the field as optional only if it is not a required field,\n      // else we will always mark it as optional\n      const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === false : true\n\n      attributes[field.name] = {\n        type: 'objectAttribute',\n        value,\n        optional,\n      }\n    }\n\n    // Ignore empty objects\n    if (Object.keys(attributes).length === 0) {\n      return {type: 'unknown'} satisfies UnknownTypeNode\n    }\n\n    if (schemaType.type?.name !== 'document' && schemaType.name !== 'object') {\n      attributes._type = {\n        type: 'objectAttribute',\n        value: {\n          type: 'string',\n          value: schemaType.name,\n        },\n      }\n    }\n\n    return {\n      type: 'object',\n      attributes,\n    }\n  }\n\n  function createArray(arraySchemaType: ArraySchemaType): ArrayTypeNode | NullTypeNode {\n    const of: TypeNode[] = []\n    for (const item of arraySchemaType.of) {\n      const field = convertSchemaType(item)\n      if (field.type === 'inline') {\n        of.push({\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n          rest: field,\n        } satisfies ObjectTypeNode)\n      } else if (field.type === 'object') {\n        field.rest = {\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n        }\n        of.push(field)\n      } else {\n        of.push(field)\n      }\n    }\n\n    if (of.length === 0) {\n      return {type: 'null'}\n    }\n\n    return {\n      type: 'array',\n      of:\n        of.length > 1\n          ? {\n              type: 'union',\n              of,\n            }\n          : of[0],\n    }\n  }\n\n  return schema\n}\n\nfunction createKeyField(): ObjectAttribute<StringTypeNode> {\n  return {\n    type: 'objectAttribute',\n    value: {\n      type: 'string',\n    },\n  }\n}\n\nfunction isFieldRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let required = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'required') {\n            required = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (required) {\n        return true\n      }\n    }\n\n    if (typeof rule === 'object' && rule !== null && '_required' in rule) {\n      if (rule._required === 'required') {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction hasAssetRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let assetRequired = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'assetRequired') {\n            assetRequired = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (assetRequired) {\n        return true\n      }\n    }\n\n    if (\n      typeof rule === 'object' &&\n      rule !== null &&\n      '_rules' in rule &&\n      Array.isArray(rule._rules)\n    ) {\n      if (rule._rules.some((r) => r.flag === 'assetRequired')) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction isObjectType(typeDef: SanitySchemaType): typeDef is ObjectSchemaType {\n  return isType(typeDef, 'object') || typeDef.jsonType === 'object' || 'fields' in typeDef\n}\nfunction isArrayType(typeDef: SanitySchemaType): typeDef is ArraySchemaType {\n  return isType(typeDef, 'array')\n}\nfunction isReferenceType(typeDef: SanitySchemaType): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\nfunction isCrossDatasetReferenceType(typeDef: SanitySchemaType) {\n  return isType(typeDef, 'crossDatasetReference')\n}\nfunction isStringType(typeDef: SanitySchemaType): typeDef is StringSchemaType {\n  return isType(typeDef, 'string')\n}\nfunction isNumberType(typeDef: SanitySchemaType): typeDef is NumberSchemaType {\n  return isType(typeDef, 'number')\n}\nfunction createStringTypeNodeDefintion(\n  stringSchemaType: StringSchemaType,\n): StringTypeNode | UnionTypeNode<StringTypeNode> {\n  const listOptions = stringSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'string',\n        value: typeof v === 'string' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'string',\n  }\n}\n\nfunction createNumberTypeNodeDefintion(\n  numberSchemaType: NumberSchemaType,\n): NumberTypeNode | UnionTypeNode<NumberTypeNode> {\n  const listOptions = numberSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'number',\n        value: typeof v === 'number' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'number',\n  }\n}\n\nfunction createReferenceTypeNodeDefintion(\n  reference: ReferenceSchemaType,\n): ObjectTypeNode | UnionTypeNode<ObjectTypeNode> {\n  const references = gatherReferenceNames(reference)\n  if (references.length === 1) {\n    return createReferenceTypeNode(references[0])\n  }\n\n  return {\n    type: 'union',\n    of: references.map((name) => createReferenceTypeNode(name)),\n  }\n}\n\n// Traverse the reference type tree and gather all the reference names\nfunction gatherReferenceNames(type: ReferenceSchemaType): string[] {\n  const allReferences = gatherReferenceTypes(type)\n  // Remove duplicates\n  return [...new Set([...allReferences.map((ref) => ref.name)])]\n}\n\nfunction gatherReferenceTypes(type: ReferenceSchemaType): ObjectSchemaType[] {\n  const refTo = 'to' in type ? type.to : []\n  if ('type' in type && isReferenceType(type.type!)) {\n    return [...gatherReferenceTypes(type.type), ...refTo]\n  }\n\n  return refTo\n}\n\n// Traverse the type tree and gather all the fields\nfunction gatherFields(type: SanitySchemaType | ObjectSchemaType): ObjectField[] {\n  if ('fields' in type) {\n    return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n  }\n\n  return []\n}\n\n// Traverse the type tree and check if the type or any of its subtypes are of the given type\nfunction isType(\n  typeDef: SanitySchemaType | ObjectField | ObjectFieldType,\n  typeName: string,\n): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\n// Traverse the type tree and return the \"last\" type, ie deepest type in the tree\nfunction lastType(typeDef: SanitySchemaType): SanitySchemaType | undefined {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (!type.type) {\n      return type\n    }\n    type = type.type\n  }\n\n  return undefined\n}\n\n// Sorts the types by their dependencies by using a topological sort depth-first algorithm.\nfunction sortByDependencies(compiledSchema: SchemaDef): string[] {\n  const seen = new Set<SanitySchemaType>()\n\n  // Walks the dependencies of a schema type and adds them to the dependencies set\n  function walkDependencies(\n    schemaType: SanitySchemaType,\n    dependencies: Set<SanitySchemaType>,\n  ): void {\n    if (seen.has(schemaType)) {\n      return\n    }\n    seen.add(schemaType)\n\n    if ('fields' in schemaType) {\n      for (const field of gatherFields(schemaType)) {\n        const last = lastType(field.type)\n        if (last!.name === 'document') {\n          dependencies.add(last!)\n          continue\n        }\n\n        let schemaTypeName: string | undefined\n        if (schemaType.type!.type) {\n          schemaTypeName = field.type.type!.name\n        } else if ('jsonType' in schemaType.type!) {\n          schemaTypeName = field.type.jsonType\n        }\n\n        if (schemaTypeName === 'object' || schemaTypeName === 'block') {\n          if (isReferenceType(field.type)) {\n            field.type.to.forEach((ref) => dependencies.add(ref.type!))\n          } else {\n            dependencies.add(field.type)\n          }\n        }\n        walkDependencies(field.type, dependencies)\n      }\n    } else if ('of' in schemaType) {\n      for (const item of schemaType.of) {\n        walkDependencies(item, dependencies)\n      }\n    }\n  }\n  const dependencyMap = new Map<SanitySchemaType, Set<SanitySchemaType>>()\n  compiledSchema.getTypeNames().forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName)\n    if (schemaType === undefined || schemaType.type === null) {\n      return\n    }\n    const dependencies = new Set<SanitySchemaType>()\n\n    walkDependencies(schemaType, dependencies)\n    dependencyMap.set(schemaType, dependencies)\n    seen.clear() // Clear the seen set for the next type\n  })\n\n  // Sorts the types by their dependencies\n  const typeNames: string[] = []\n  // holds a temporary mark for types that are currently being visited, to detect cyclic dependencies\n  const currentlyVisiting = new Set<SanitySchemaType>()\n\n  // holds a permanent mark for types that have been already visited\n  const visited = new Set<SanitySchemaType>()\n\n  // visit implements a depth-first search\n  function visit(type: SanitySchemaType) {\n    if (visited.has(type)) {\n      return\n    }\n    // If we find a type that is already in the temporary mark, we have a cyclic dependency.\n    if (currentlyVisiting.has(type)) {\n      return\n    }\n    // mark this as a temporary mark, meaning it's being visited\n    currentlyVisiting.add(type)\n    const deps = dependencyMap.get(type)\n    if (deps !== undefined) {\n      deps.forEach((dep) => visit(dep))\n    }\n    currentlyVisiting.delete(type)\n    visited.add(type)\n\n    if (!typeNames.includes(type.name)) {\n      typeNames.unshift(type.name)\n    }\n  }\n  // Visit all types in the dependency map\n  for (const [type] of dependencyMap) {\n    visit(type)\n  }\n\n  return typeNames\n}\n","import {type SchemaValidationResult} from '../typedefs'\n\n// Temporary solution to ensure we have a central registry over used helpIds\nexport const HELP_IDS = {\n  TYPE_INVALID: 'schema-type-invalid',\n  TYPE_IS_ESM_MODULE: 'schema-type-is-esm-module',\n  TYPE_NAME_RESERVED: 'schema-type-name-reserved',\n  TYPE_MISSING_NAME: 'schema-type-missing-name-or-type',\n  TYPE_MISSING_TYPE: 'schema-type-missing-name-or-type',\n  TYPE_TITLE_RECOMMENDED: 'schema-type-title-is-recommended',\n  TYPE_TITLE_INVALID: 'schema-type-title-is-recommended',\n  OBJECT_FIELDS_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NOT_UNIQUE: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NAME_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_DEFINITION_INVALID_TYPE: 'schema-object-fields-invalid',\n  ARRAY_PREDEFINED_CHOICES_INVALID: 'schema-predefined-choices-invalid',\n  ARRAY_OF_ARRAY: 'schema-array-of-array',\n  ARRAY_OF_INVALID: 'schema-array-of-invalid',\n  ARRAY_OF_NOT_UNIQUE: 'schema-array-of-invalid',\n  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: 'schema-array-of-type-global-type-conflict',\n  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: 'schema-array-of-type-builtin-type-conflict',\n  REFERENCE_TO_INVALID: 'schema-reference-to-invalid',\n  REFERENCE_TO_NOT_UNIQUE: 'schema-reference-to-invalid',\n  REFERENCE_INVALID_OPTIONS: 'schema-reference-invalid-options',\n  REFERENCE_INVALID_OPTIONS_LOCATION: 'schema-reference-options-nesting',\n  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: 'schema-reference-filter-params-combination',\n  SLUG_SLUGIFY_FN_RENAMED: 'slug-slugifyfn-renamed',\n  ASSET_METADATA_FIELD_INVALID: 'asset-metadata-field-invalid',\n  CROSS_DATASET_REFERENCE_INVALID: 'cross-dataset-reference-invalid',\n  DEPRECATED_BLOCKEDITOR_KEY: 'schema-deprecated-blockeditor-key',\n  STANDALONE_BLOCK_TYPE: 'schema-standalone-block-type',\n}\n\nfunction createValidationResult(\n  severity: SchemaValidationResult['severity'],\n  message: string,\n  helpId: string | null,\n): SchemaValidationResult {\n  if (helpId && !Object.keys(HELP_IDS).some((id) => (HELP_IDS as any)[id] === helpId)) {\n    throw new Error(\n      `Used the unknown helpId \"${helpId}\", please add it to the array in createValidationResult.js`,\n    )\n  }\n  return {\n    severity,\n    message,\n    helpId: helpId!,\n  }\n}\n\nexport const error = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('error', message, helpId!)\n\nexport const warning = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('warning', message, helpId!)\n","import {\n  type SchemaType,\n  type SchemaTypeDefinition,\n  type SchemaValidationProblemGroup,\n} from '@sanity/types'\nimport {flatten, get} from 'lodash'\n\nimport {type ProblemPath, type ProblemPathPropertySegment, type TypeWithProblems} from './typedefs'\nimport {error} from './validation/createValidationResult'\n\n/**\n * @internal\n */\nexport function groupProblems(types: SchemaTypeDefinition[]): SchemaValidationProblemGroup[] {\n  return flatten<TypeWithProblems>(types.map((type) => getTypeProblems(type))).filter(\n    (type) => type.problems.length > 0,\n  )\n}\n\nfunction createTypeWithMembersProblemsAccessor(\n  memberPropertyName: string,\n  getMembers = (type: SchemaType) => get(type, memberPropertyName),\n) {\n  return function getProblems(type: any, parentPath: ProblemPath): TypeWithProblems[] {\n    const currentPath: ProblemPath = [\n      ...parentPath,\n      {kind: 'type', type: type.type, name: type.name},\n    ]\n\n    const members = getMembers(type) || []\n\n    const memberProblems: TypeWithProblems[][] = Array.isArray(members)\n      ? members.map((memberType) => {\n          const propertySegment: ProblemPathPropertySegment = {\n            kind: 'property',\n            name: memberPropertyName,\n          }\n          const memberPath: ProblemPath = [...currentPath, propertySegment]\n          return getTypeProblems(memberType, memberPath as any)\n        })\n      : [\n          [\n            {\n              path: currentPath,\n              problems: [error(`Member declaration (${memberPropertyName}) is not an array`)],\n            },\n          ],\n        ]\n\n    return [\n      {\n        path: currentPath,\n        problems: type._problems || [],\n      },\n      ...flatten(memberProblems),\n    ]\n  }\n}\n\nconst arrify = (val: any) =>\n  Array.isArray(val) ? val : (typeof val === 'undefined' && []) || [val]\n\nconst getObjectProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getImageProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getFileProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getArrayProblems = createTypeWithMembersProblemsAccessor('of')\nconst getReferenceProblems = createTypeWithMembersProblemsAccessor('to', (type) =>\n  'to' in type ? arrify(type.to) : [],\n)\nconst getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor('marks.annotations')\nconst getBlockMemberProblems = createTypeWithMembersProblemsAccessor('of')\nconst getBlockProblems = (type: any, problems: any) => [\n  ...getBlockAnnotationProblems(type, problems),\n  ...getBlockMemberProblems(type, problems),\n]\n\nfunction getDefaultProblems(type: any, path = []): TypeWithProblems[] {\n  return [\n    {\n      path: [...path, {kind: 'type', type: type.type, name: type.name}],\n      problems: type._problems || [],\n    },\n  ]\n}\n\nfunction getTypeProblems(type: SchemaTypeDefinition, path = []): TypeWithProblems[] {\n  switch (type.type) {\n    case 'object': {\n      return getObjectProblems(type, path)\n    }\n    case 'document': {\n      return getObjectProblems(type, path)\n    }\n    case 'array': {\n      return getArrayProblems(type, path)\n    }\n    case 'reference': {\n      return getReferenceProblems(type, path)\n    }\n    case 'block': {\n      return getBlockProblems(type, path)\n    }\n    case 'image': {\n      return getImageProblems(type, path)\n    }\n    case 'file': {\n      return getFileProblems(type, path)\n    }\n    default: {\n      return getDefaultProblems(type, path)\n    }\n  }\n}\n","export function getDupes(array: any, selector = (v: any) => v) {\n  const dupes = array.reduce((acc: any, item: any) => {\n    const key = selector(item)\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(item)\n    return acc\n  }, {})\n\n  return Object.keys(dupes)\n    .map((key) => (dupes[key].length > 1 ? dupes[key] : null))\n    .filter(Boolean)\n}\n","import {flatten, uniq} from 'lodash'\n\nimport {getDupes} from '../sanity/validation/utils/getDupes'\n\ntype SchemaType = Record<string, any>\ntype SchemaTypeDef = Record<string, any>\n\ntype VisitContext = {\n  isRoot: boolean\n  isReserved: (typeName: string) => boolean\n  visit: Visitor\n  index: number\n  isDuplicate: (typeName: string) => boolean\n  getType: (typeName: string) => null | SchemaType\n  getTypeNames: () => Array<string>\n}\n\nexport type Visitor = (typeDef: SchemaTypeDef, arg1: VisitContext) => SchemaType\n\nconst NOOP_VISITOR: Visitor = (typeDef) => typeDef\n\nexport class UnknownType {\n  name: string\n\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nconst TYPE_TYPE = {name: 'type', type: null}\n\nconst FUTURE_RESERVED = ['any', 'time', 'date']\n\nexport function traverseSchema(\n  types: SchemaTypeDef[] = [],\n  coreTypes: SchemaTypeDef[] = [],\n  visitor: Visitor = NOOP_VISITOR,\n) {\n  const coreTypesRegistry = Object.create(null)\n  const registry = Object.create(null)\n\n  const coreTypeNames = coreTypes.map((typeDef) => typeDef.name)\n\n  const reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames)\n\n  const typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean)\n\n  coreTypes.forEach((coreType) => {\n    coreTypesRegistry[coreType.name] = coreType\n  })\n\n  types.forEach((type, i) => {\n    // Allocate a placeholder for each type\n    registry[(type && type.name) || `__unnamed_${i}`] = {}\n  })\n\n  function getType(typeName: any) {\n    return typeName === 'type'\n      ? TYPE_TYPE\n      : coreTypesRegistry[typeName] || registry[typeName] || null\n  }\n\n  const duplicateNames = uniq(flatten(getDupes(typeNames)))\n\n  function isDuplicate(typeName: any) {\n    return duplicateNames.includes(typeName)\n  }\n  function getTypeNames() {\n    return typeNames.concat(coreTypeNames)\n  }\n  function isReserved(typeName: any) {\n    return typeName === 'type' || reservedTypeNames.includes(typeName)\n  }\n\n  const visitType = (isRoot: any) => (typeDef: any, index: any) => {\n    return visitor(typeDef, {\n      visit: visitType(false),\n      isRoot,\n      getType,\n      getTypeNames,\n      isReserved,\n      isDuplicate,\n      index,\n    })\n  }\n\n  coreTypes.forEach((coreTypeDef) => {\n    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef))\n  })\n\n  types.forEach((typeDef, i) => {\n    Object.assign(\n      registry[(typeDef && typeDef.name) || `__unnamed_${i}`],\n      visitType(true)(typeDef, i),\n    )\n  })\n\n  return {\n    get(typeName: string) {\n      const res = registry[typeName] || coreTypesRegistry[typeName]\n      if (res) {\n        return res\n      }\n      throw new Error(`No such type: ${typeName}`)\n    },\n    has(typeName: string): boolean {\n      return typeName in registry || typeName in coreTypesRegistry\n    },\n    getTypeNames(): string[] {\n      return Object.keys(registry)\n    },\n    getTypes() {\n      return this.getTypeNames().map(this.get)\n    },\n    toJSON() {\n      return this.getTypes()\n    },\n  }\n}\n","const coreTypes = [\n  {name: 'array', jsonType: 'array', type: 'type'},\n  {name: 'block', jsonType: 'object', type: 'type'},\n  {name: 'boolean', jsonType: 'boolean', type: 'type'},\n  {name: 'datetime', jsonType: 'string', type: 'type'},\n  {name: 'date', jsonType: 'string', type: 'type'},\n  {name: 'document', jsonType: 'object', type: 'type'},\n  {name: 'email', jsonType: 'string', type: 'type'},\n  {name: 'file', jsonType: 'object', type: 'type'},\n  {name: 'geopoint', jsonType: 'object', type: 'type'},\n  {name: 'image', jsonType: 'object', type: 'type'},\n  {name: 'number', jsonType: 'number', type: 'type'},\n  {name: 'object', jsonType: 'object', type: 'type'},\n  {name: 'reference', jsonType: 'object', type: 'type'},\n  {name: 'crossDatasetReference', jsonType: 'object', type: 'type'},\n  {name: 'slug', jsonType: 'object', type: 'type'},\n  {name: 'span', jsonType: 'object', type: 'type'},\n  {name: 'string', jsonType: 'string', type: 'type'},\n  {name: 'telephone', jsonType: 'string', type: 'type'},\n  {name: 'text', jsonType: 'string', type: 'type'},\n  {name: 'url', jsonType: 'string', type: 'type'},\n] as const\n\nexport const coreTypeNames = coreTypes.map((t) => t.name)\nexport default coreTypes\n","import {traverseSchema, type Visitor} from '../core/traverseSchema'\nimport coreTypes from './coreTypes'\nimport {type _FIXME_} from './typedefs'\n\nexport function traverseSanitySchema(schemaTypes: _FIXME_[], visitor: Visitor) {\n  return traverseSchema(schemaTypes, coreTypes as _FIXME_, visitor)\n}\n","import humanizeList from 'humanize-list'\nimport {flatten, partition} from 'lodash'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction isPrimitiveTypeName(typeName: any) {\n  return typeName === 'string' || typeName === 'number' || typeName === 'boolean'\n}\n\nfunction isAssignable(typeName: any, type: any) {\n  return (typeof type.name === 'string' ? type.name : type.type) === typeName\n}\n\nfunction quote(n: any) {\n  return `\"${n}\"`\n}\n\nfunction pluralize(arr: unknown[], suf = 's') {\n  return arr.length === 1 ? '' : suf\n}\n\nfunction format(value: unknown) {\n  if (Array.isArray(value)) {\n    return `array with ${value.length} entries`\n  }\n  if (typeof value === 'object' && value !== null) {\n    return `object with keys ${humanizeList(Object.keys(value).map(quote))}`\n  }\n  return quote(value)\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  // name should already have been marked\n  const ofIsArray = Array.isArray(typeDef.of)\n\n  if (ofIsArray) {\n    const invalid = typeDef.of.reduce((errs: any, def: any, idx: any) => {\n      if (typeof def.name === 'string') {\n        // If an array member has been given a \"local\" type name, we want to trigger an error if the given member type name\n        // is one of the builtin types\n        //\n        // The following examples should be an error (where book is an existing root level type and reference is a built-in type):\n        //  - (…) of: [{type: 'book', name: 'image'}]\n        //  - (…) of: [{type: 'book', name: 'object'}]\n        //  - (…) of: [{type: 'object', name: 'reference'}]\n        // The following examples are valid (where \"address\" is not defined as a global object type)\n        //  - (…) of: [{type: 'object', name: 'address'}]\n        // The following examples are redundant, but should be allowed (at least for now)\n        //  - (…) of: [{type: 'object', name: 'object'}]\n        //  - (…) of: [{type: 'image', name: 'image'}]\n\n        if (\n          // specifying the same name as the type is redundant, but should not be a hard error at this point\n          // Consider showing a warning for this and deprecate this ability eventually\n          def.name !== def.type &&\n          coreTypeNames.includes(def.name)\n        ) {\n          return errs.concat(\n            error(\n              `Found array member declaration with the same type name as a built-in type (\"${def.name}\"). Array members can not be given the same name as a built-in type.`,\n              HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n            ),\n          )\n        }\n      }\n\n      if (def.type === 'object' && def.name && visitorContext.getType(def.name)) {\n        return errs.concat(\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${def.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        )\n      }\n      if (def.type === 'array') {\n        return errs.concat(\n          error(\n            `Found array member declaration of type \"array\" - multidimensional arrays are not currently supported by Sanity`,\n            HELP_IDS.ARRAY_OF_ARRAY,\n          ),\n        )\n      }\n\n      if (def) {\n        return errs\n      }\n\n      const err = `Found ${def === null ? 'null' : typeof def}, expected member declaration`\n      return errs.concat(\n        error(\n          `Found invalid type member declaration in array at index ${idx}: ${err}`,\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n      )\n    }, [])\n\n    if (invalid.length > 0) {\n      return {\n        ...typeDef,\n        of: [],\n        _problems: invalid,\n      }\n    }\n  }\n\n  const problems = flatten([\n    ofIsArray\n      ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in array. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.ARRAY_OF_NOT_UNIQUE,\n          ),\n        )\n      : error(\n          'The array type is missing or having an invalid value for the required \"of\" property',\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n  ])\n  const of = ofIsArray ? typeDef.of : []\n\n  // Don't allow object types without a name in block arrays\n  const hasObjectTypesWithoutName = of.some(\n    (type: any) => type.type === 'object' && typeof type.name === 'undefined',\n  )\n  const hasBlockType = of.some((ofType: any) => ofType.type === 'block')\n  if (hasBlockType && hasObjectTypesWithoutName) {\n    problems.push(\n      error(\n        \"The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.\",\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const [primitiveTypes, objectTypes] = partition(\n    of,\n    (ofType) =>\n      isPrimitiveTypeName(ofType.type) ||\n      isPrimitiveTypeName(visitorContext.getType(ofType.type)?.jsonType),\n  )\n\n  const isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0\n\n  if (isMixedArray) {\n    const primitiveTypeNames = primitiveTypes.map((t) => t.type)\n    const objectTypeNames = objectTypes.map((t) => t.type)\n    problems.push(\n      error(\n        `The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(\n          primitiveTypeNames,\n        )} ${humanizeList(primitiveTypeNames.map(quote))} and object type${pluralize(\n          objectTypeNames,\n        )} ${humanizeList(objectTypeNames.map(quote))})`,\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const list = typeDef?.options?.list\n  if (!isMixedArray && Array.isArray(list)) {\n    const isArrayOfPrimitives = primitiveTypes.length > 0\n    if (isArrayOfPrimitives) {\n      list.forEach((option) => {\n        const value = option?.value ?? option\n        const isDeclared = primitiveTypes.some((primitiveType) => {\n          return typeof value === visitorContext.getType(primitiveType.type).jsonType\n        })\n        if (!isDeclared) {\n          const formattedTypeList = humanizeList(\n            primitiveTypes.map((t) => t.name || t.type),\n            {conjunction: 'or'},\n          )\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                value,\n              )}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    } else {\n      list.forEach((option) => {\n        const optionTypeName = option._type || 'object'\n        const isDeclared = objectTypes.some((validObjectType) =>\n          isAssignable(optionTypeName, validObjectType),\n        )\n        if (!isDeclared) {\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                option,\n              )}. Must be an object with \"_type\" set to ${humanizeList(\n                objectTypes\n                  .map((t) => t.name || t.type)\n                  .map((t) => (t === 'object' ? 'undefined' : quote(t))),\n                {conjunction: 'or'},\n              )}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    }\n  }\n\n  if (typeDef?.options?.list && typeDef?.options?.layout === 'tags') {\n    problems.push(\n      warning(\n        'Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.',\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    of: of.map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n","export function isJSONTypeOf(type: any, jsonType: any, visitorContext: any) {\n  if ('jsonType' in type) {\n    return type.jsonType === jsonType\n  }\n  const parentType = visitorContext.getType(type.type)\n  if (!parentType) {\n    throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`)\n  }\n  return isJSONTypeOf(parentType, jsonType, visitorContext)\n}\n","import humanizeList from 'humanize-list'\nimport {isPlainObject, omit} from 'lodash'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {isJSONTypeOf} from '../utils/isJSONTypeOf'\n\nconst getTypeOf = (thing: any) => (Array.isArray(thing) ? 'array' : typeof thing)\nconst quote = (str: any) => `\"${str}\"`\nconst allowedKeys = [\n  'components',\n  'lists',\n  'marks',\n  'name',\n  'of',\n  'options',\n  'styles',\n  'title',\n  'type',\n  'validation',\n]\nconst allowedMarkKeys = ['decorators', 'annotations']\nconst allowedStyleKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedDecoratorKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedListKeys = ['title', 'value', 'icon', 'component']\nconst supportedBuiltInObjectTypes = ['file', 'image', 'object', 'reference']\n\nexport default function validateBlockType(typeDef: any, visitorContext: any) {\n  const problems = []\n  let styles = typeDef.styles\n  let lists = typeDef.lists\n  let marks = typeDef.marks\n  let members = typeDef.of\n\n  const disallowedKeys = Object.keys(typeDef).filter(\n    (key) => !allowedKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (marks) {\n    marks = validateMarks(typeDef.marks, visitorContext, problems)\n  }\n\n  if (styles) {\n    styles = validateStyles(styles, visitorContext, problems)\n  }\n\n  if (lists) {\n    lists = validateLists(lists, visitorContext, problems)\n  }\n\n  if (members) {\n    members = validateMembers(members, visitorContext, problems)\n  }\n  return {\n    ...omit(typeDef, disallowedKeys),\n    marks,\n    styles,\n    name: typeDef.name || typeDef.type,\n    of: members,\n    _problems: problems,\n  }\n}\n\nfunction validateMarks(marks: any, visitorContext: any, problems: any) {\n  let decorators = marks.decorators\n  let annotations = marks.annotations\n\n  if (!isPlainObject(marks)) {\n    problems.push(error(`\"marks\" declaration should be an object, got ${getTypeOf(marks)}`))\n    return problems\n  }\n\n  const disallowedMarkKeys = Object.keys(marks).filter(\n    (key) => !allowedMarkKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedMarkKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedMarkKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (decorators && !Array.isArray(decorators)) {\n    problems.push(\n      error(`\"marks.decorators\" declaration should be an array, got ${getTypeOf(decorators)}`),\n    )\n  } else if (decorators) {\n    decorators\n      .filter((dec: any) => !!dec.blockEditor)\n      .forEach((dec: any) => {\n        dec.icon = dec.blockEditor.icon\n        dec.component = dec.blockEditor.render\n      })\n    decorators = validateDecorators(decorators, visitorContext, problems)\n  }\n\n  if (annotations && !Array.isArray(annotations)) {\n    problems.push(\n      error(`\"marks.annotations\" declaration should be an array, got ${getTypeOf(annotations)}`),\n    )\n  } else if (annotations) {\n    annotations = validateAnnotations(annotations, visitorContext, problems)\n  }\n\n  return {...marks, decorators, annotations}\n}\n\nfunction validateLists(lists: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(lists)) {\n    problems.push(error(`\"lists\" declaration should be an array, got ${getTypeOf(lists)}`))\n    return problems\n  }\n\n  lists.forEach((list, index) => {\n    if (!isPlainObject(list)) {\n      problems.push(error(`List must be an object, got ${getTypeOf(list)}`))\n      return\n    }\n\n    const name = list.value || `#${index}`\n    const disallowedKeys = Object.keys(list).filter(\n      (key) => !allowedListKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for list ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!list.value) {\n      problems.push(error(`List #${index} is missing required \"value\" property`))\n    } else if (typeof list.value !== 'string') {\n      problems.push(\n        error(\n          `List type #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            list.value,\n          )}`,\n        ),\n      )\n    } else if (!list.title) {\n      problems.push(warning(`List type ${name} is missing recommended \"title\" property`))\n    }\n  })\n  return lists\n}\n\nfunction validateStyles(styles: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(styles)) {\n    problems.push(error(`\"styles\" declaration should be an array, got ${getTypeOf(styles)}`))\n    return problems\n  }\n\n  styles.forEach((style, index) => {\n    if (!isPlainObject(style)) {\n      problems.push(error(`Style must be an object, got ${getTypeOf(style)}`))\n      return\n    }\n\n    const name = style.value || `#${index}`\n    const disallowedKeys = Object.keys(style).filter(\n      (key) => !allowedStyleKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for style ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!style.value) {\n      problems.push(error(`Style #${index} is missing required \"value\" property`))\n    } else if (typeof style.value !== 'string') {\n      problems.push(\n        error(\n          `Style #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            style.value,\n          )}`,\n        ),\n      )\n    } else if (!style.title) {\n      problems.push(warning(`Style ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof style.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Style has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      style.component = style.component || style.blockEditor.render\n    }\n  })\n  return styles\n}\n\nfunction validateDecorators(decorators: any, visitorContext: any, problems: any) {\n  decorators.forEach((decorator: any, index: any) => {\n    if (!isPlainObject(decorator)) {\n      problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`))\n      return\n    }\n\n    const name = decorator.value || `#${index}`\n    const disallowedKeys = Object.keys(decorator).filter(\n      (key) => !allowedDecoratorKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for decorator ${name}: ${humanizeList(\n            disallowedKeys.map(quote),\n          )}`,\n        ),\n      )\n    }\n\n    if (!decorator.value) {\n      problems.push(error(`Decorator #${index} is missing required \"value\" property`))\n    } else if (typeof decorator.value !== 'string') {\n      problems.push(\n        error(\n          `Decorator #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            decorator.value,\n          )}`,\n        ),\n      )\n    } else if (!decorator.title) {\n      problems.push(warning(`Decorator ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof decorator.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Decorator \"${name}\" has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      decorator.icon = decorator.icon || decorator.blockEditor.icon\n      decorator.component = decorator.component || decorator.blockEditor.render\n    }\n  })\n  return decorators\n}\n\nfunction validateAnnotations(annotations: any, visitorContext: any, problems: any) {\n  return annotations.map((annotation: any) => {\n    if (!isPlainObject(annotation)) {\n      return {\n        ...annotation,\n        _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)],\n      }\n    }\n\n    const {_problems} = visitorContext.visit(annotation, visitorContext)\n    const targetType = annotation.type && visitorContext.getType(annotation.type)\n    if (targetType && !isJSONTypeOf(targetType, 'object', visitorContext)) {\n      _problems.push(\n        error(\n          `Annotation cannot have type \"${annotation.type}\" - annotation types must inherit from object`,\n        ),\n      )\n    }\n\n    if (typeof annotation.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Annotation has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      annotation.icon = annotation.icon || annotation.blockEditor.icon\n      if (annotation.blockEditor?.render && !annotation.components?.annotation) {\n        annotation.components = annotation.components || {}\n        annotation.components.annotation =\n          annotation.components.annotation || annotation.blockEditor.render\n      }\n    }\n\n    return {...annotation, _problems}\n  })\n}\n\nfunction validateMembers(members: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(members)) {\n    problems.push(error(`\"of\" declaration should be an array, got ${getTypeOf(members)}`))\n    return undefined\n  }\n\n  return members.map((member) => {\n    const {_problems} = visitorContext.visit(member, visitorContext)\n    if (member.type === 'object' && member.name && visitorContext.getType(member.name)) {\n      return {\n        ...member,\n        _problems: [\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${member.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n\n    // Test that each member is of a support object-like type\n    let type = member\n    while (type && !type.jsonType) {\n      type = visitorContext.getType(type.type)\n    }\n    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n))\n    if (\n      // Must be object-like type (to validate hoisted types)\n      (type && type.jsonType !== 'object') ||\n      // Can't be a core type, or core object type that isn't supported (like 'span')\n      nonObjectCoreTypes.some((coreName) => coreName === member.type)\n    ) {\n      return {\n        ...member,\n        _problems: [\n          error(\n            `Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join(\n              \"', '\",\n            )}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`,\n            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n    return {...member, _problems}\n  })\n}\n","import {type SchemaType} from '@sanity/types'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error} from '../createValidationResult'\n\nexport function validateNonObjectFieldsProp(\n  typeDef: SchemaType,\n  visitorContext: any,\n): SchemaValidationResult[] {\n  if (!('fields' in typeDef)) {\n    return []\n  }\n\n  let type = typeDef\n  while (type && !type.jsonType) {\n    type = visitorContext.getType(type.type)\n  }\n\n  if (type && type.jsonType !== 'object') {\n    return [error(`Type has propery \"fields\", but is not an object/document type.`)]\n  }\n\n  return []\n}\n","import humanize from 'humanize-list'\nimport leven from 'leven'\n\nimport {error, HELP_IDS} from '../createValidationResult'\n\nconst quote = (str: any) => `\"${str}\"`\n\nexport function validateTypeName(typeName: string, visitorContext: any) {\n  const possibleTypeNames = visitorContext.getTypeNames()\n\n  if (!typeName) {\n    return [error(`Type is missing a type.`, HELP_IDS.TYPE_MISSING_TYPE)]\n  }\n\n  if (typeof typeName !== 'string') {\n    return [\n      error(\n        `Type has an invalid \"type\"-property - should be a string.`,\n        HELP_IDS.TYPE_MISSING_TYPE,\n      ),\n    ]\n  }\n\n  const isValid = possibleTypeNames.includes(typeName)\n\n  if (!isValid) {\n    const suggestions = possibleTypeNames\n      .map((possibleTypeName: any) => {\n        return [leven(typeName, possibleTypeName), possibleTypeName]\n      })\n      .filter(([distance]: any) => distance < 3)\n      .map(([_, name]: any) => name)\n\n    const suggestion =\n      suggestions.length > 0\n        ? ` Did you mean ${humanize(suggestions.map(quote), {conjunction: 'or'})}?`\n        : ''\n\n    return [error(`Unknown type: ${typeName}.${suggestion}`)]\n  }\n  return []\n}\n","import {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\n\nexport function validateDeprecatedProperties(type: any): SchemaValidationResult[] {\n  const warnings = []\n\n  if (type?.inputComponent) {\n    warnings.push(\n      warning(`The \"inputComponent\" property is deprecated. Use \"components.input\" instead.`),\n    )\n  }\n\n  if (type?.preview?.component) {\n    warnings.push(\n      warning(`The \"preview.component\" property is deprecated. Use \"components.preview\" instead.`),\n    )\n  }\n\n  if (type?.diffComponent) {\n    warnings.push(\n      warning(`The \"diffComponent\" property is deprecated. Use \"components.diff\" instead.`),\n    )\n  }\n\n  if (type?.options?.editModal) {\n    warnings.push(\n      warning(`The \"options.editModal\" property is deprecated. Use \"options.modal\" instead.`),\n    )\n  }\n\n  if (type?.options?.isHighlighted) {\n    warnings.push(\n      warning(\n        `The \"options.isHighlighted\" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {validateNonObjectFieldsProp} from '../utils/validateNonObjectFieldsProp'\nimport {validateTypeName} from '../utils/validateTypeName'\nimport {validateDeprecatedProperties} from './deprecated'\n\nexport default (typeDef: any, visitorContext: any) => {\n  return {\n    ...typeDef,\n    _problems: [\n      ...validateTypeName(typeDef.type, visitorContext),\n      ...validateNonObjectFieldsProp(typeDef, visitorContext),\n      ...validateDeprecatedProperties(typeDef),\n    ].filter(Boolean),\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nconst VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/\nexport function isValidDatasetName(name: string): string | true {\n  const isValid = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name)\n  return (\n    isValid ||\n    `The provided dataset \"${name}\" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`\n  )\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n          ),\n        )\n      : error(\n          'The cross dataset reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The cross dataset reference type should define at least one referenced type. Please check the \"to\" property.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  normalizedTo.forEach((crossDatasetTypeDef: any, index: any) => {\n    if (!crossDatasetTypeDef.type) {\n      problems.push(\n        error(\n          `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n\n    if (!isPlainObject(crossDatasetTypeDef.preview)) {\n      problems.push(\n        error(\n          `Missing required preview config for the referenced type \"${\n            crossDatasetTypeDef.type || '<unknown type>'\n          }\"`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n  })\n\n  if (typeof typeDef.dataset === 'string') {\n    const datasetValidation = isValidDatasetName(typeDef.dataset)\n    if (datasetValidation !== true) {\n      problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A cross dataset reference must specify a `dataset`',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeDef.studioUrl && typeof typeDef.studioUrl !== 'function') {\n    problems.push(\n      error(\n        'The \"studioUrl\" property on a cross dataset reference must be a function taking \"{id, type}\" as argument and returning a studio url.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","const REACT_SYM_RE = /^Symbol\\(react\\..+\\)$/\n\nexport function isComponentLike(value: any) {\n  const type = typeof value\n  // Note: we're not using `isValidElementType` from react-is here since it accepts too much, e.g. any strings.\n  return (\n    type === 'function' ||\n    (typeof value?.$$typeof === 'symbol' && REACT_SYM_RE.test(String(value?.$$typeof)))\n  )\n}\n","import inspect from '../../inspect'\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\nimport {isComponentLike} from './isComponent'\n\nexport function validateComponent(typeDef: any): SchemaValidationResult[] {\n  const components = 'components' in typeDef ? typeDef.components : false\n  if (!components) {\n    return []\n  }\n\n  const warnings: SchemaValidationResult[] = []\n\n  if (components.input && !isComponentLike(components.input)) {\n    warnings.push(\n      warning(\n        `The \\`components.input\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.input,\n        )}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.field && !isComponentLike(components.field)) {\n    warnings.push(\n      warning(\n        `The \\`components.field\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.field,\n        )}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.item && !isComponentLike(components.item)) {\n    warnings.push(\n      warning(\n        `The \\`components.item\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.item,\n        )}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.preview && !isComponentLike(components.preview)) {\n    warnings.push(\n      warning(\n        `The \\`components.preview\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.preview,\n        )}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {isPlainObject} from 'lodash'\n\nimport inspect from '../../inspect'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nconst VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/\nconst CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/\ninterface Field {\n  name: string\n}\n\ninterface PreviewConfig {\n  select?: {\n    [key: string]: string\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  prepare?: Function\n}\n\nfunction validateFieldName(name: any): Array<any> {\n  if (typeof name !== 'string') {\n    return [\n      error(\n        `Field names must be strings. Saw \"${inspect(name)}\"`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (name.startsWith('_')) {\n    return [\n      error(\n        `Invalid field name \"${name}\". Field names cannot start with underscores \"_\" as it's reserved for system fields.`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n\n  if (!VALID_FIELD_RE.test(name)) {\n    return [\n      error(\n        `Invalid field name: \"${name}\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(\n          VALID_FIELD_RE,\n        )}).`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (!CONVENTIONAL_FIELD_RE.test(name)) {\n    return [\n      warning(\n        'Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' +\n          ' It may be wise to keep special characters out of field names for easier access later on.',\n      ),\n      HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n    ]\n  }\n  return []\n}\n\nexport function validateField(field: any, _visitorContext: any) {\n  if (!isPlainObject(field)) {\n    return [\n      error(\n        `Incorrect type for field definition - should be an object, saw ${inspect(field)}`,\n        HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE,\n      ),\n    ]\n  }\n\n  const problems = []\n  problems.push(\n    ...('name' in field\n      ? validateFieldName(field.name)\n      : [error('Missing field name', HELP_IDS.OBJECT_FIELD_NAME_INVALID)]),\n  )\n  problems.push(...validateComponent(field))\n  return problems\n}\n\nfunction getDuplicateFields(array: Array<Field>): Array<Array<Field> | null> {\n  const dupes: {[name: string]: Array<Field>} = {}\n  array.forEach((field) => {\n    if (!dupes[field.name]) {\n      dupes[field.name] = []\n    }\n    dupes[field.name].push(field)\n  })\n  return Object.keys(dupes)\n    .map((fieldName) => (dupes[fieldName].length > 1 ? dupes[fieldName] : null))\n    .filter(Boolean)\n}\n\nexport function validateFields(fields: any, options = {allowEmpty: false}) {\n  const problems = []\n  const fieldsIsArray = Array.isArray(fields)\n  if (!fieldsIsArray) {\n    return [\n      error(\n        `The \"fields\" property must be an array of fields. Instead saw \"${typeof fields}\"`,\n        HELP_IDS.OBJECT_FIELDS_INVALID,\n      ),\n    ]\n  }\n\n  const fieldsWithNames = fields.filter((field) => typeof field.name === 'string')\n\n  getDuplicateFields(fieldsWithNames).forEach((dupes) => {\n    problems.push(\n      error(\n        `Found ${dupes!.length} fields with name \"${dupes![0].name}\" in object`,\n        HELP_IDS.OBJECT_FIELD_NOT_UNIQUE,\n      ),\n    )\n  })\n\n  if (fields.length === 0 && !options.allowEmpty) {\n    problems.push(error('Object should have at least one field', HELP_IDS.OBJECT_FIELDS_INVALID))\n  }\n\n  const standaloneBlockFields = fields\n    .filter((field) => field.type === 'block')\n    .map((field) => `\"${field.name}\"`)\n\n  if (standaloneBlockFields.length > 0) {\n    const fmtFields = standaloneBlockFields.join(', ')\n    problems.push(\n      error(\n        `Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`,\n        HELP_IDS.STANDALONE_BLOCK_TYPE,\n      ),\n    )\n  }\n\n  return problems\n}\n\nexport function validatePreview(preview: PreviewConfig) {\n  if (!isPlainObject(preview)) {\n    return [error(`The \"preview\" property must be an object, instead saw \"${typeof preview}\"`)]\n  }\n\n  if (typeof preview.prepare !== 'undefined' && typeof preview.prepare !== 'function') {\n    return [\n      error(\n        `The \"preview.prepare\" property must be a function, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  if (!preview.select) {\n    return []\n  }\n\n  if (!isPlainObject(preview.select)) {\n    return [\n      error(\n        `The \"preview.select\" property must be an object, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  return Object.keys(preview.select).reduce((errs: any, key) => {\n    return typeof preview.select![key] === 'string'\n      ? errs\n      : errs.concat(\n          error(\n            `The key \"${key}\" of \"preview.select\" must be a string, instead saw \"${typeof preview\n              .select![key]}\"`,\n          ),\n        )\n  }, [])\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  let problems = validateFields(typeDef.fields)\n\n  let preview = typeDef.preview\n  if (preview) {\n    const previewErrors = validatePreview(typeDef.preview)\n    problems = problems.concat(previewErrors)\n    preview = previewErrors.some((err: any) => err.severity === 'error') ? {} : preview\n  }\n\n  if (\n    typeDef.type !== 'document' &&\n    typeDef.type !== 'object' &&\n    typeof typeDef.initialValue !== 'undefined'\n  ) {\n    problems.push(\n      error(`The \"initialValue\" property is currently only supported for document & object types.`),\n    )\n  }\n\n  return {\n    ...typeDef,\n    preview,\n    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field: any, index: any) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {isPlainObject} from 'lodash'\n\nimport {error} from '../createValidationResult'\nimport object from './object'\n\nexport default (typeDefinition: any, visitorContext: any) => {\n  const typeDef = object(typeDefinition, visitorContext)\n  const {initialValue, initialValues} = typeDef\n\n  const hasInitialValue = typeof initialValue !== 'undefined'\n  if (hasInitialValue && !isPlainObject(initialValue) && typeof initialValue !== 'function') {\n    typeDef._problems.push(\n      error(`The \"initialValue\" property must be either a plain object or a function`),\n    )\n  }\n\n  if (typeof initialValues !== 'undefined') {\n    typeDef._problems.push(error(`Found property \"initialValues\" - did you mean \"initialValue\"?`))\n  }\n\n  return typeDef\n}\n","import {error, HELP_IDS} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  const invalidFieldNames = Array.isArray(fields)\n    ? fields?.filter((field) => field.name === 'asset')\n    : []\n\n  if (\n    typeDef.options &&\n    typeof typeDef.options.metadata !== 'undefined' &&\n    !Array.isArray(typeDef.options.metadata)\n  ) {\n    problems.push(\n      error(\n        `Invalid type for file \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (invalidFieldNames.length > 0) {\n    problems.push(error('The name `asset` is not a valid field name for type `file`.'))\n  }\n\n  return {\n    ...typeDef,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nconst autoMeta = ['dimensions', 'hasAlpha', 'isOpaque']\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  let options = typeDef.options\n  const metadata = options?.metadata\n  const superfluousMeta = Array.isArray(metadata)\n    ? metadata.filter((meta) => autoMeta.includes(meta))\n    : []\n\n  const invalidFieldNames = ['asset', 'hotspot', 'crop']\n\n  const fieldsWithInvalidName = Array.isArray(fields)\n    ? fields?.filter((field) => invalidFieldNames.includes(field.name))\n    : []\n\n  if (typeof metadata !== 'undefined' && !Array.isArray(metadata)) {\n    problems.push(\n      error(\n        `Invalid type for image \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (superfluousMeta.length > 0) {\n    problems.push(\n      warning(\n        `Image \\`metadata\\` field contains superfluous properties (they are always included): ${superfluousMeta.join(\n          ', ',\n        )}`,\n      ),\n    )\n    options = {...options, metadata: metadata!.filter((meta) => !autoMeta.includes(meta))}\n  } else if (fieldsWithInvalidName.length > 0) {\n    problems.push(\n      error(\n        `The names \\`${invalidFieldNames.join(\n          '`, `',\n        )}\\` are invalid field names for type \\`image\\`.`,\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    options,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.REFERENCE_TO_INVALID,\n          ),\n        )\n      : error(\n          'The reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.REFERENCE_TO_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The reference type should define at least one accepted type. Please check the \"to\" property.',\n        HELP_IDS.REFERENCE_TO_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const hasName = Boolean(typeDef.name)\n  if (!hasName && Object.keys(typeDef).length === 1) {\n    // Short-circuit on obviously invalid types (only key is _problems)\n    return {\n      ...typeDef,\n      _problems: [\n        error(\n          'Invalid/undefined type declaration, check declaration or the import/export of the schema type.',\n          HELP_IDS.TYPE_INVALID,\n        ),\n      ],\n    }\n  }\n\n  const problems = []\n  if (looksLikeEsmModule(typeDef)) {\n    problems.push(\n      error(\n        'Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property',\n        HELP_IDS.TYPE_IS_ESM_MODULE,\n      ),\n    )\n  } else if (!hasName) {\n    problems.push(error('Missing type name', HELP_IDS.TYPE_MISSING_NAME))\n  } else if (visitorContext.isReserved(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: \"${typeDef.name}\" is a reserved name.`,\n        HELP_IDS.TYPE_NAME_RESERVED,\n      ),\n    )\n  }\n\n  if (visitorContext.isDuplicate(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: A type with name \"${typeDef.name}\" is already defined in the schema.`,\n      ),\n    )\n  }\n\n  problems.push(...validateComponent(typeDef))\n\n  if ('title' in typeDef && typeof typeDef.title !== 'string') {\n    problems.push(warning('Type title is not a string.', HELP_IDS.TYPE_TITLE_INVALID))\n  }\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction looksLikeEsmModule(typeDef: any) {\n  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title)\n}\n","import {HELP_IDS, warning} from '../createValidationResult'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n\n  if (typeDef.options && typeDef.options.slugifyFn) {\n    problems.push(\n      warning(\n        'Heads up! The \"slugifyFn\" option has been renamed to \"slugify\".',\n        HELP_IDS.SLUG_SLUGIFY_FN_RENAMED,\n      ),\n    )\n\n    typeDef.options.slugify = typeDef.options.slugifyFn\n  }\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n","import {traverseSanitySchema} from './traverseSchema'\nimport {type _FIXME_} from './typedefs'\nimport array from './validation/types/array'\nimport block from './validation/types/block'\nimport common from './validation/types/common'\nimport crossDatasetReference from './validation/types/crossDatasetReference'\nimport documentVisitor from './validation/types/document'\nimport file from './validation/types/file'\nimport image from './validation/types/image'\nimport object from './validation/types/object'\nimport reference from './validation/types/reference'\nimport rootType from './validation/types/rootType'\nimport slug from './validation/types/slug'\n\nconst typeVisitors = {\n  array,\n  object,\n  slug,\n  file,\n  image,\n  block,\n  document: documentVisitor,\n  reference: reference,\n  crossDatasetReference: crossDatasetReference,\n}\n\nconst getNoopVisitor = (visitorContext: any) => (schemaDef: any) => ({\n  name: `<unnamed_type_@_index_${visitorContext.index}>`,\n  ...schemaDef,\n  _problems: [],\n})\n\nfunction combine(...visitors: any) {\n  return (schemaType: any, visitorContext: any) => {\n    return visitors.reduce(\n      (result: any, visitor: any) => {\n        const res = visitor(result, visitorContext)\n        return {\n          ...res,\n          _problems: result._problems.concat(res._problems),\n        }\n      },\n      {_problems: [], ...schemaType},\n    )\n  }\n}\n\n/**\n * @internal\n */\nexport function validateSchema(schemaTypes: _FIXME_) {\n  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {\n    const typeVisitor =\n      (schemaDef && schemaDef.type && (typeVisitors as any)[schemaDef.type]) ||\n      getNoopVisitor(visitorContext)\n\n    if (visitorContext.isRoot) {\n      return combine(rootType, common, typeVisitor)(schemaDef, visitorContext)\n    }\n\n    return combine(common, typeVisitor)(schemaDef, visitorContext)\n  })\n}\n"],"names":["object","reference","array","coreTypes","coreTypeNames","quote","_a","humanize","normalizeToProp","getOptionErrors","block"],"mappings":"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"}