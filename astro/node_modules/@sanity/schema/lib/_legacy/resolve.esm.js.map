{"version":3,"file":"resolve.esm.js","sources":["../../src/legacy/searchConfig/resolve.ts"],"sourcesContent":["import {isFinite, uniqBy} from 'lodash'\n\nexport const DEFAULT_MAX_FIELD_DEPTH = 5\n\nconst stringFieldsSymbols = {} as Record<number, symbol>\n\nconst getStringFieldSymbol = (maxDepth: number) => {\n  if (!stringFieldsSymbols[maxDepth]) {\n    stringFieldsSymbols[maxDepth] = Symbol(`__cachedStringFields_${maxDepth}`)\n  }\n\n  return stringFieldsSymbols[maxDepth]\n}\n\nconst isReference = (type: any) => type.type && type.type.name === 'reference'\n\nconst portableTextFields = ['style', 'list']\nconst isPortableTextBlock: any = (type: any) =>\n  type.name === 'block' || (type.type && isPortableTextBlock(type.type))\nconst isPortableTextArray = (type: any) =>\n  type.jsonType === 'array' && Array.isArray(type.of) && type.of.some(isPortableTextBlock)\n\nfunction reduceType(type: any, reducer: any, acc: any, path = [], maxDepth: any) {\n  if (maxDepth < 0) {\n    return acc\n  }\n\n  const accumulator = reducer(acc, type, path)\n  if (type.jsonType === 'array' && Array.isArray(type.of)) {\n    return reduceArray(type, reducer, accumulator, path, maxDepth)\n  }\n\n  if (type.jsonType === 'object' && Array.isArray(type.fields) && !isReference(type)) {\n    return reduceObject(type, reducer, accumulator, path, maxDepth)\n  }\n\n  return accumulator\n}\n\nfunction reduceArray(arrayType: any, reducer: any, accumulator: any, path: any, maxDepth: any) {\n  return arrayType.of.reduce(\n    (acc: any, ofType: any) => reduceType(ofType, reducer, acc, path, maxDepth - 1),\n    accumulator,\n  )\n}\n\nfunction reduceObject(objectType: any, reducer: any, accumulator: any, path: any, maxDepth: any) {\n  const isPtBlock = isPortableTextBlock(objectType)\n  return objectType.fields.reduce((acc: any, field: any) => {\n    // Don't include styles and list types as searchable paths for portable text blocks\n    if (isPtBlock && portableTextFields.includes(field.name)) {\n      return acc\n    }\n\n    const segment = [field.name].concat(field.type.jsonType === 'array' ? [[]] : [])\n    return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1)\n  }, accumulator)\n}\n\nconst BASE_WEIGHTS = [\n  {weight: 1, path: ['_id']},\n  {weight: 1, path: ['_type']},\n]\n\nconst PREVIEW_FIELD_WEIGHT_MAP = {\n  title: 10,\n  subtitle: 5,\n  description: 1.5,\n}\n\n/**\n * @internal\n */\nexport function deriveFromPreview(\n  type: {\n    preview: {select: Record<string, string>}\n  },\n  maxDepth: number,\n): {weight?: number; path: (string | number)[]}[] {\n  const select = type?.preview?.select\n\n  if (!select) {\n    return []\n  }\n\n  const fields: {weight: number; path: (string | number)[]}[] = []\n\n  for (const fieldName of Object.keys(select)) {\n    if (!(fieldName in PREVIEW_FIELD_WEIGHT_MAP)) {\n      continue\n    }\n\n    const path = select[fieldName].split('.')\n\n    if (maxDepth > -1 && path.length - 1 > maxDepth) {\n      continue\n    }\n\n    fields.push({\n      weight: (PREVIEW_FIELD_WEIGHT_MAP as any)[fieldName],\n      path,\n    })\n  }\n\n  return fields\n}\n\nfunction getCachedStringFieldPaths(type: any, maxDepth: number) {\n  const symbol = getStringFieldSymbol(maxDepth)\n  if (!type[symbol]) {\n    type[symbol] = uniqBy(\n      [\n        ...BASE_WEIGHTS,\n        ...deriveFromPreview(type, maxDepth),\n        ...getStringFieldPaths(type, maxDepth).map((path: any) => ({weight: 1, path})),\n        ...getPortableTextFieldPaths(type, maxDepth).map((path: any) => ({\n          weight: 1,\n          path,\n          mapWith: 'pt::text',\n        })),\n      ],\n      (spec) => spec.path.join('.'),\n    )\n  }\n  return type[symbol]\n}\n\nfunction getCachedBaseFieldPaths(type: any, maxDepth: number) {\n  const symbol = getStringFieldSymbol(maxDepth)\n  if (!type[symbol]) {\n    type[symbol] = uniqBy([...BASE_WEIGHTS, ...deriveFromPreview(type, maxDepth)], (spec) =>\n      spec.path.join('.'),\n    )\n  }\n  return type[symbol]\n}\n\nfunction getStringFieldPaths(type: any, maxDepth: number) {\n  const reducer = (accumulator: any, childType: any, path: any) =>\n    childType.jsonType === 'string' ? [...accumulator, path] : accumulator\n\n  return reduceType(type, reducer, [], [], maxDepth)\n}\n\nfunction getPortableTextFieldPaths(type: any, maxDepth: any) {\n  const reducer = (accumulator: any, childType: any, path: any) =>\n    isPortableTextArray(childType) ? [...accumulator, path] : accumulator\n\n  return reduceType(type, reducer, [], [], maxDepth)\n}\n\nexport function resolveSearchConfigForBaseFieldPaths(type: any, maxDepth?: number) {\n  return getCachedBaseFieldPaths(type, normalizeMaxDepth(maxDepth))\n}\n\n/**\n * @internal\n */\nexport function resolveSearchConfig(type: any, maxDepth?: number) {\n  return getCachedStringFieldPaths(type, normalizeMaxDepth(maxDepth))\n}\n\n/**\n * Normalizes a one-indexed maxDepth to a zero-indexed maxDepth\n * 0 = all fields\n *\n * @internal\n */\nfunction normalizeMaxDepth(maxDepth?: number) {\n  if (!isFinite(maxDepth) || maxDepth! < 1 || maxDepth! > DEFAULT_MAX_FIELD_DEPTH) {\n    return DEFAULT_MAX_FIELD_DEPTH - 1\n  }\n\n  return maxDepth! - 1\n}\n"],"names":[],"mappings":"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"}