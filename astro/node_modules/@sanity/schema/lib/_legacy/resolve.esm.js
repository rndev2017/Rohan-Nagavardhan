import isFinite from "lodash/isFinite.js";
import uniqBy from "lodash/uniqBy.js";
const DEFAULT_MAX_FIELD_DEPTH = 5, stringFieldsSymbols = {}, getStringFieldSymbol = (maxDepth) => (stringFieldsSymbols[maxDepth] || (stringFieldsSymbols[maxDepth] = Symbol(`__cachedStringFields_${maxDepth}`)), stringFieldsSymbols[maxDepth]), isReference = (type) => type.type && type.type.name === "reference", portableTextFields = ["style", "list"], isPortableTextBlock = (type) => type.name === "block" || type.type && isPortableTextBlock(type.type), isPortableTextArray = (type) => type.jsonType === "array" && Array.isArray(type.of) && type.of.some(isPortableTextBlock);
function reduceType(type, reducer, acc, path = [], maxDepth) {
  if (maxDepth < 0)
    return acc;
  const accumulator = reducer(acc, type, path);
  return type.jsonType === "array" && Array.isArray(type.of) ? reduceArray(type, reducer, accumulator, path, maxDepth) : type.jsonType === "object" && Array.isArray(type.fields) && !isReference(type) ? reduceObject(type, reducer, accumulator, path, maxDepth) : accumulator;
}
function reduceArray(arrayType, reducer, accumulator, path, maxDepth) {
  return arrayType.of.reduce(
    (acc, ofType) => reduceType(ofType, reducer, acc, path, maxDepth - 1),
    accumulator
  );
}
function reduceObject(objectType, reducer, accumulator, path, maxDepth) {
  const isPtBlock = isPortableTextBlock(objectType);
  return objectType.fields.reduce((acc, field) => {
    if (isPtBlock && portableTextFields.includes(field.name))
      return acc;
    const segment = [field.name].concat(field.type.jsonType === "array" ? [[]] : []);
    return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);
  }, accumulator);
}
const BASE_WEIGHTS = [
  { weight: 1, path: ["_id"] },
  { weight: 1, path: ["_type"] }
], PREVIEW_FIELD_WEIGHT_MAP = {
  title: 10,
  subtitle: 5,
  description: 1.5
};
function deriveFromPreview(type, maxDepth) {
  var _a;
  const select = (_a = type == null ? void 0 : type.preview) == null ? void 0 : _a.select;
  if (!select)
    return [];
  const fields = [];
  for (const fieldName of Object.keys(select)) {
    if (!(fieldName in PREVIEW_FIELD_WEIGHT_MAP))
      continue;
    const path = select[fieldName].split(".");
    maxDepth > -1 && path.length - 1 > maxDepth || fields.push({
      weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
      path
    });
  }
  return fields;
}
function getCachedStringFieldPaths(type, maxDepth) {
  const symbol = getStringFieldSymbol(maxDepth);
  return type[symbol] || (type[symbol] = uniqBy(
    [
      ...BASE_WEIGHTS,
      ...deriveFromPreview(type, maxDepth),
      ...getStringFieldPaths(type, maxDepth).map((path) => ({ weight: 1, path })),
      ...getPortableTextFieldPaths(type, maxDepth).map((path) => ({
        weight: 1,
        path,
        mapWith: "pt::text"
      }))
    ],
    (spec) => spec.path.join(".")
  )), type[symbol];
}
function getCachedBaseFieldPaths(type, maxDepth) {
  const symbol = getStringFieldSymbol(maxDepth);
  return type[symbol] || (type[symbol] = uniqBy(
    [...BASE_WEIGHTS, ...deriveFromPreview(type, maxDepth)],
    (spec) => spec.path.join(".")
  )), type[symbol];
}
function getStringFieldPaths(type, maxDepth) {
  return reduceType(type, (accumulator, childType, path) => childType.jsonType === "string" ? [...accumulator, path] : accumulator, [], [], maxDepth);
}
function getPortableTextFieldPaths(type, maxDepth) {
  return reduceType(type, (accumulator, childType, path) => isPortableTextArray(childType) ? [...accumulator, path] : accumulator, [], [], maxDepth);
}
function resolveSearchConfigForBaseFieldPaths(type, maxDepth) {
  return getCachedBaseFieldPaths(type, normalizeMaxDepth(maxDepth));
}
function resolveSearchConfig(type, maxDepth) {
  return getCachedStringFieldPaths(type, normalizeMaxDepth(maxDepth));
}
function normalizeMaxDepth(maxDepth) {
  return !isFinite(maxDepth) || maxDepth < 1 || maxDepth > DEFAULT_MAX_FIELD_DEPTH ? DEFAULT_MAX_FIELD_DEPTH - 1 : maxDepth - 1;
}
export {
  DEFAULT_MAX_FIELD_DEPTH,
  resolveSearchConfig,
  resolveSearchConfigForBaseFieldPaths
};
//# sourceMappingURL=resolve.esm.js.map
