"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var difference = require("lodash/difference.js"), resolve = require("./_chunks-cjs/resolve.js"), groqJs = require("groq-js"), flatten = require("lodash/flatten.js"), get = require("lodash/get.js"), uniq = require("lodash/uniq.js"), humanizeList = require("humanize-list"), partition = require("lodash/partition.js"), isPlainObject = require("lodash/isPlainObject.js"), omit = require("lodash/omit.js"), leven = require("leven"), inspect = require("object-inspect");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var difference__default = /* @__PURE__ */ _interopDefaultCompat(difference), flatten__default = /* @__PURE__ */ _interopDefaultCompat(flatten), get__default = /* @__PURE__ */ _interopDefaultCompat(get), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq), humanizeList__default = /* @__PURE__ */ _interopDefaultCompat(humanizeList), partition__default = /* @__PURE__ */ _interopDefaultCompat(partition), isPlainObject__default = /* @__PURE__ */ _interopDefaultCompat(isPlainObject), omit__default = /* @__PURE__ */ _interopDefaultCompat(omit), leven__default = /* @__PURE__ */ _interopDefaultCompat(leven), inspect__default = /* @__PURE__ */ _interopDefaultCompat(inspect);
const ACTIONS_FLAG = "__experimental_actions", DEFAULT_ACTIONS = ["create", "update", "delete", "publish"], VALID_ACTIONS = DEFAULT_ACTIONS, readActions = (schemaType) => ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS, validateActions = (typeName, actions) => {
  if (!Array.isArray(actions))
    throw new Error(
      `The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(
        ", "
      )}`
    );
  const invalid = difference__default.default(actions, VALID_ACTIONS);
  if (invalid.length > 0)
    throw new Error(
      `Invalid action${invalid.length > 1 ? "s" : ""} configured for schema type "${typeName}": ${invalid.join(
        ", "
      )}. Valid actions are: ${VALID_ACTIONS.join(", ")}`
    );
  return actions;
}, resolveEnabledActions = (schemaType) => validateActions(schemaType.name, readActions(schemaType)), isActionEnabled = (schemaType, action) => resolveEnabledActions(schemaType).includes(action), documentDefaultFields = (typeName) => ({
  _id: {
    type: "objectAttribute",
    value: { type: "string" }
  },
  _type: {
    type: "objectAttribute",
    value: { type: "string", value: typeName }
  },
  _createdAt: {
    type: "objectAttribute",
    value: { type: "string" }
  },
  _updatedAt: {
    type: "objectAttribute",
    value: { type: "string" }
  },
  _rev: {
    type: "objectAttribute",
    value: { type: "string" }
  }
}), typesMap = /* @__PURE__ */ new Map([
  ["text", { type: "string" }],
  ["url", { type: "string" }],
  ["datetime", { type: "string" }],
  ["date", { type: "string" }],
  ["boolean", { type: "boolean" }],
  ["email", { type: "string" }]
]);
function extractSchema(schemaDef, extractOptions = {}) {
  const inlineFields = /* @__PURE__ */ new Set(), schema = [];
  sortByDependencies(schemaDef).forEach((typeName) => {
    const schemaType = schemaDef.get(typeName);
    if (schemaType === void 0)
      return;
    const base = convertBaseType(schemaType);
    base !== null && (base.type === "type" && inlineFields.add(schemaType), schema.push(base));
  });
  function convertBaseType(schemaType) {
    let typeName;
    if (schemaType.type ? typeName = schemaType.type.name : "jsonType" in schemaType && (typeName = schemaType.jsonType), typeName === "document" && isObjectType(schemaType)) {
      const defaultAttributes = documentDefaultFields(schemaType.name), object2 = createObject(schemaType);
      return object2.type === "unknown" ? null : {
        name: schemaType.name,
        type: "document",
        attributes: {
          ...defaultAttributes,
          ...object2.attributes
        }
      };
    }
    const value = convertSchemaType(schemaType);
    return value.type === "unknown" ? null : value.type === "object" ? {
      name: schemaType.name,
      type: "type",
      value: {
        type: "object",
        attributes: {
          _type: {
            type: "objectAttribute",
            value: {
              type: "string",
              value: schemaType.name
            }
          },
          ...value.attributes
        }
      }
    } : {
      name: schemaType.name,
      type: "type",
      value
    };
  }
  function convertSchemaType(schemaType) {
    var _a, _b, _c;
    if (((_a = lastType(schemaType)) == null ? void 0 : _a.name) === "document")
      return groqJs.createReferenceTypeNode(schemaType.name);
    if (inlineFields.has(schemaType.type))
      return { type: "inline", name: schemaType.type.name };
    if (((_c = (_b = schemaType.type) == null ? void 0 : _b.type) == null ? void 0 : _c.name) === "object")
      return { type: "inline", name: schemaType.type.name };
    if (isStringType(schemaType))
      return createStringTypeNodeDefintion(schemaType);
    if (isNumberType(schemaType))
      return createNumberTypeNodeDefintion(schemaType);
    if (schemaType.type && typesMap.has(schemaType.type.name))
      return typesMap.get(schemaType.type.name);
    if (isCrossDatasetReferenceType(schemaType))
      return { type: "unknown" };
    if (isReferenceType(schemaType))
      return createReferenceTypeNodeDefintion(schemaType);
    if (isArrayType(schemaType))
      return createArray(schemaType);
    if (isObjectType(schemaType))
      return createObject(schemaType);
    throw new Error(`Type "${schemaType.name}" not found`);
  }
  function createObject(schemaType) {
    var _a;
    const attributes = {}, fields = gatherFields(schemaType);
    for (const field of fields) {
      const fieldIsRequired = isFieldRequired(field), value = convertSchemaType(field.type);
      if (value === null)
        continue;
      hasAssetRequired(field) && value.type === "object" && (value.attributes.asset.optional = !1);
      const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === !1 : !0;
      attributes[field.name] = {
        type: "objectAttribute",
        value,
        optional
      };
    }
    return Object.keys(attributes).length === 0 ? { type: "unknown" } : (((_a = schemaType.type) == null ? void 0 : _a.name) !== "document" && schemaType.name !== "object" && (attributes._type = {
      type: "objectAttribute",
      value: {
        type: "string",
        value: schemaType.name
      }
    }), {
      type: "object",
      attributes
    });
  }
  function createArray(arraySchemaType) {
    const of = [];
    for (const item of arraySchemaType.of) {
      const field = convertSchemaType(item);
      field.type === "inline" ? of.push({
        type: "object",
        attributes: {
          _key: createKeyField()
        },
        rest: field
      }) : (field.type === "object" && (field.rest = {
        type: "object",
        attributes: {
          _key: createKeyField()
        }
      }), of.push(field));
    }
    return of.length === 0 ? { type: "null" } : {
      type: "array",
      of: of.length > 1 ? {
        type: "union",
        of
      } : of[0]
    };
  }
  return schema;
}
function createKeyField() {
  return {
    type: "objectAttribute",
    value: {
      type: "string"
    }
  };
}
function isFieldRequired(field) {
  const { validation } = field.type;
  if (!validation)
    return !1;
  const rules = Array.isArray(validation) ? validation : [validation];
  for (const rule of rules) {
    let required = !1;
    const proxy = new Proxy(
      {},
      {
        get: (target, methodName) => () => (methodName === "required" && (required = !0), proxy)
      }
    );
    if (typeof rule == "function" && (rule(proxy), required) || typeof rule == "object" && rule !== null && "_required" in rule && rule._required === "required")
      return !0;
  }
  return !1;
}
function hasAssetRequired(field) {
  const { validation } = field.type;
  if (!validation)
    return !1;
  const rules = Array.isArray(validation) ? validation : [validation];
  for (const rule of rules) {
    let assetRequired = !1;
    const proxy = new Proxy(
      {},
      {
        get: (target, methodName) => () => (methodName === "assetRequired" && (assetRequired = !0), proxy)
      }
    );
    if (typeof rule == "function" && (rule(proxy), assetRequired) || typeof rule == "object" && rule !== null && "_rules" in rule && Array.isArray(rule._rules) && rule._rules.some((r) => r.flag === "assetRequired"))
      return !0;
  }
  return !1;
}
function isObjectType(typeDef) {
  return isType(typeDef, "object") || typeDef.jsonType === "object" || "fields" in typeDef;
}
function isArrayType(typeDef) {
  return isType(typeDef, "array");
}
function isReferenceType(typeDef) {
  return isType(typeDef, "reference");
}
function isCrossDatasetReferenceType(typeDef) {
  return isType(typeDef, "crossDatasetReference");
}
function isStringType(typeDef) {
  return isType(typeDef, "string");
}
function isNumberType(typeDef) {
  return isType(typeDef, "number");
}
function createStringTypeNodeDefintion(stringSchemaType) {
  var _a;
  const listOptions = (_a = stringSchemaType.options) == null ? void 0 : _a.list;
  return listOptions && Array.isArray(listOptions) ? {
    type: "union",
    of: listOptions.map((v) => ({
      type: "string",
      value: typeof v == "string" ? v : v.value
    }))
  } : {
    type: "string"
  };
}
function createNumberTypeNodeDefintion(numberSchemaType) {
  var _a;
  const listOptions = (_a = numberSchemaType.options) == null ? void 0 : _a.list;
  return listOptions && Array.isArray(listOptions) ? {
    type: "union",
    of: listOptions.map((v) => ({
      type: "number",
      value: typeof v == "number" ? v : v.value
    }))
  } : {
    type: "number"
  };
}
function createReferenceTypeNodeDefintion(reference2) {
  const references = gatherReferenceNames(reference2);
  return references.length === 1 ? groqJs.createReferenceTypeNode(references[0]) : {
    type: "union",
    of: references.map((name) => groqJs.createReferenceTypeNode(name))
  };
}
function gatherReferenceNames(type) {
  const allReferences = gatherReferenceTypes(type);
  return [.../* @__PURE__ */ new Set([...allReferences.map((ref) => ref.name)])];
}
function gatherReferenceTypes(type) {
  const refTo = "to" in type ? type.to : [];
  return "type" in type && isReferenceType(type.type) ? [...gatherReferenceTypes(type.type), ...refTo] : refTo;
}
function gatherFields(type) {
  return "fields" in type ? type.type ? gatherFields(type.type).concat(type.fields) : type.fields : [];
}
function isType(typeDef, typeName) {
  let type = typeDef;
  for (; type; ) {
    if (type.name === typeName || type.type && type.type.name === typeName)
      return !0;
    type = type.type;
  }
  return !1;
}
function lastType(typeDef) {
  let type = typeDef;
  for (; type; ) {
    if (!type.type)
      return type;
    type = type.type;
  }
}
function sortByDependencies(compiledSchema) {
  const seen = /* @__PURE__ */ new Set();
  function walkDependencies(schemaType, dependencies) {
    if (!seen.has(schemaType)) {
      if (seen.add(schemaType), "fields" in schemaType)
        for (const field of gatherFields(schemaType)) {
          const last = lastType(field.type);
          if (last.name === "document") {
            dependencies.add(last);
            continue;
          }
          let schemaTypeName;
          schemaType.type.type ? schemaTypeName = field.type.type.name : "jsonType" in schemaType.type && (schemaTypeName = field.type.jsonType), (schemaTypeName === "object" || schemaTypeName === "block") && (isReferenceType(field.type) ? field.type.to.forEach((ref) => dependencies.add(ref.type)) : dependencies.add(field.type)), walkDependencies(field.type, dependencies);
        }
      else if ("of" in schemaType)
        for (const item of schemaType.of)
          walkDependencies(item, dependencies);
    }
  }
  const dependencyMap = /* @__PURE__ */ new Map();
  compiledSchema.getTypeNames().forEach((typeName) => {
    const schemaType = compiledSchema.get(typeName);
    if (schemaType === void 0 || schemaType.type === null)
      return;
    const dependencies = /* @__PURE__ */ new Set();
    walkDependencies(schemaType, dependencies), dependencyMap.set(schemaType, dependencies), seen.clear();
  });
  const typeNames = [], currentlyVisiting = /* @__PURE__ */ new Set(), visited = /* @__PURE__ */ new Set();
  function visit(type) {
    if (visited.has(type) || currentlyVisiting.has(type))
      return;
    currentlyVisiting.add(type);
    const deps = dependencyMap.get(type);
    deps !== void 0 && deps.forEach((dep) => visit(dep)), currentlyVisiting.delete(type), visited.add(type), typeNames.includes(type.name) || typeNames.unshift(type.name);
  }
  for (const [type] of dependencyMap)
    visit(type);
  return typeNames;
}
const HELP_IDS = {
  TYPE_INVALID: "schema-type-invalid",
  TYPE_IS_ESM_MODULE: "schema-type-is-esm-module",
  TYPE_NAME_RESERVED: "schema-type-name-reserved",
  TYPE_MISSING_NAME: "schema-type-missing-name-or-type",
  TYPE_MISSING_TYPE: "schema-type-missing-name-or-type",
  TYPE_TITLE_RECOMMENDED: "schema-type-title-is-recommended",
  TYPE_TITLE_INVALID: "schema-type-title-is-recommended",
  OBJECT_FIELDS_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_NOT_UNIQUE: "schema-object-fields-invalid",
  OBJECT_FIELD_NAME_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_DEFINITION_INVALID_TYPE: "schema-object-fields-invalid",
  ARRAY_PREDEFINED_CHOICES_INVALID: "schema-predefined-choices-invalid",
  ARRAY_OF_ARRAY: "schema-array-of-array",
  ARRAY_OF_INVALID: "schema-array-of-invalid",
  ARRAY_OF_NOT_UNIQUE: "schema-array-of-invalid",
  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: "schema-array-of-type-global-type-conflict",
  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: "schema-array-of-type-builtin-type-conflict",
  REFERENCE_TO_INVALID: "schema-reference-to-invalid",
  REFERENCE_TO_NOT_UNIQUE: "schema-reference-to-invalid",
  REFERENCE_INVALID_OPTIONS: "schema-reference-invalid-options",
  REFERENCE_INVALID_OPTIONS_LOCATION: "schema-reference-options-nesting",
  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: "schema-reference-filter-params-combination",
  SLUG_SLUGIFY_FN_RENAMED: "slug-slugifyfn-renamed",
  ASSET_METADATA_FIELD_INVALID: "asset-metadata-field-invalid",
  CROSS_DATASET_REFERENCE_INVALID: "cross-dataset-reference-invalid",
  DEPRECATED_BLOCKEDITOR_KEY: "schema-deprecated-blockeditor-key",
  STANDALONE_BLOCK_TYPE: "schema-standalone-block-type"
};
function createValidationResult(severity, message, helpId) {
  if (helpId && !Object.keys(HELP_IDS).some((id) => HELP_IDS[id] === helpId))
    throw new Error(
      `Used the unknown helpId "${helpId}", please add it to the array in createValidationResult.js`
    );
  return {
    severity,
    message,
    helpId
  };
}
const error = (message, helpId) => createValidationResult("error", message, helpId), warning = (message, helpId) => createValidationResult("warning", message, helpId);
function groupProblems(types) {
  return flatten__default.default(types.map((type) => getTypeProblems(type))).filter(
    (type) => type.problems.length > 0
  );
}
function createTypeWithMembersProblemsAccessor(memberPropertyName, getMembers = (type) => get__default.default(type, memberPropertyName)) {
  return function(type, parentPath) {
    const currentPath = [
      ...parentPath,
      { kind: "type", type: type.type, name: type.name }
    ], members = getMembers(type) || [], memberProblems = Array.isArray(members) ? members.map((memberType) => {
      const propertySegment = {
        kind: "property",
        name: memberPropertyName
      }, memberPath = [...currentPath, propertySegment];
      return getTypeProblems(memberType, memberPath);
    }) : [
      [
        {
          path: currentPath,
          problems: [error(`Member declaration (${memberPropertyName}) is not an array`)]
        }
      ]
    ];
    return [
      {
        path: currentPath,
        problems: type._problems || []
      },
      ...flatten__default.default(memberProblems)
    ];
  };
}
const arrify = (val) => Array.isArray(val) ? val : typeof val > "u" && [] || [val], getObjectProblems = createTypeWithMembersProblemsAccessor("fields"), getImageProblems = createTypeWithMembersProblemsAccessor("fields"), getFileProblems = createTypeWithMembersProblemsAccessor("fields"), getArrayProblems = createTypeWithMembersProblemsAccessor("of"), getReferenceProblems = createTypeWithMembersProblemsAccessor(
  "to",
  (type) => "to" in type ? arrify(type.to) : []
), getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor("marks.annotations"), getBlockMemberProblems = createTypeWithMembersProblemsAccessor("of"), getBlockProblems = (type, problems) => [
  ...getBlockAnnotationProblems(type, problems),
  ...getBlockMemberProblems(type, problems)
];
function getDefaultProblems(type, path = []) {
  return [
    {
      path: [...path, { kind: "type", type: type.type, name: type.name }],
      problems: type._problems || []
    }
  ];
}
function getTypeProblems(type, path = []) {
  switch (type.type) {
    case "object":
      return getObjectProblems(type, path);
    case "document":
      return getObjectProblems(type, path);
    case "array":
      return getArrayProblems(type, path);
    case "reference":
      return getReferenceProblems(type, path);
    case "block":
      return getBlockProblems(type, path);
    case "image":
      return getImageProblems(type, path);
    case "file":
      return getFileProblems(type, path);
    default:
      return getDefaultProblems(type, path);
  }
}
function getDupes(array2, selector = (v) => v) {
  const dupes = array2.reduce((acc, item) => {
    const key = selector(item);
    return acc[key] || (acc[key] = []), acc[key].push(item), acc;
  }, {});
  return Object.keys(dupes).map((key) => dupes[key].length > 1 ? dupes[key] : null).filter(Boolean);
}
const NOOP_VISITOR = (typeDef) => typeDef, TYPE_TYPE = { name: "type", type: null }, FUTURE_RESERVED = ["any", "time", "date"];
function traverseSchema(types = [], coreTypes2 = [], visitor = NOOP_VISITOR) {
  const coreTypesRegistry = /* @__PURE__ */ Object.create(null), registry = /* @__PURE__ */ Object.create(null), coreTypeNames2 = coreTypes2.map((typeDef) => typeDef.name), reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames2), typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean);
  coreTypes2.forEach((coreType) => {
    coreTypesRegistry[coreType.name] = coreType;
  }), types.forEach((type, i) => {
    registry[type && type.name || `__unnamed_${i}`] = {};
  });
  function getType(typeName) {
    return typeName === "type" ? TYPE_TYPE : coreTypesRegistry[typeName] || registry[typeName] || null;
  }
  const duplicateNames = uniq__default.default(flatten__default.default(getDupes(typeNames)));
  function isDuplicate(typeName) {
    return duplicateNames.includes(typeName);
  }
  function getTypeNames() {
    return typeNames.concat(coreTypeNames2);
  }
  function isReserved(typeName) {
    return typeName === "type" || reservedTypeNames.includes(typeName);
  }
  const visitType = (isRoot) => (typeDef, index) => visitor(typeDef, {
    visit: visitType(!1),
    isRoot,
    getType,
    getTypeNames,
    isReserved,
    isDuplicate,
    index
  });
  return coreTypes2.forEach((coreTypeDef) => {
    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
  }), types.forEach((typeDef, i) => {
    Object.assign(
      registry[typeDef && typeDef.name || `__unnamed_${i}`],
      visitType(!0)(typeDef, i)
    );
  }), {
    get(typeName) {
      const res = registry[typeName] || coreTypesRegistry[typeName];
      if (res)
        return res;
      throw new Error(`No such type: ${typeName}`);
    },
    has(typeName) {
      return typeName in registry || typeName in coreTypesRegistry;
    },
    getTypeNames() {
      return Object.keys(registry);
    },
    getTypes() {
      return this.getTypeNames().map(this.get);
    },
    toJSON() {
      return this.getTypes();
    }
  };
}
const coreTypes = [
  { name: "array", jsonType: "array", type: "type" },
  { name: "block", jsonType: "object", type: "type" },
  { name: "boolean", jsonType: "boolean", type: "type" },
  { name: "datetime", jsonType: "string", type: "type" },
  { name: "date", jsonType: "string", type: "type" },
  { name: "document", jsonType: "object", type: "type" },
  { name: "email", jsonType: "string", type: "type" },
  { name: "file", jsonType: "object", type: "type" },
  { name: "geopoint", jsonType: "object", type: "type" },
  { name: "image", jsonType: "object", type: "type" },
  { name: "number", jsonType: "number", type: "type" },
  { name: "object", jsonType: "object", type: "type" },
  { name: "reference", jsonType: "object", type: "type" },
  { name: "crossDatasetReference", jsonType: "object", type: "type" },
  { name: "slug", jsonType: "object", type: "type" },
  { name: "span", jsonType: "object", type: "type" },
  { name: "string", jsonType: "string", type: "type" },
  { name: "telephone", jsonType: "string", type: "type" },
  { name: "text", jsonType: "string", type: "type" },
  { name: "url", jsonType: "string", type: "type" }
], coreTypeNames = coreTypes.map((t) => t.name);
function traverseSanitySchema(schemaTypes, visitor) {
  return traverseSchema(schemaTypes, coreTypes, visitor);
}
function isPrimitiveTypeName(typeName) {
  return typeName === "string" || typeName === "number" || typeName === "boolean";
}
function isAssignable(typeName, type) {
  return (typeof type.name == "string" ? type.name : type.type) === typeName;
}
function quote$2(n) {
  return `"${n}"`;
}
function pluralize(arr, suf = "s") {
  return arr.length === 1 ? "" : suf;
}
function format(value) {
  return Array.isArray(value) ? `array with ${value.length} entries` : typeof value == "object" && value !== null ? `object with keys ${humanizeList__default.default(Object.keys(value).map(quote$2))}` : quote$2(value);
}
var array = (typeDef, visitorContext) => {
  var _a, _b, _c;
  const ofIsArray = Array.isArray(typeDef.of);
  if (ofIsArray) {
    const invalid = typeDef.of.reduce((errs, def, idx) => {
      if (typeof def.name == "string" && // specifying the same name as the type is redundant, but should not be a hard error at this point
      // Consider showing a warning for this and deprecate this ability eventually
      def.name !== def.type && coreTypeNames.includes(def.name))
        return errs.concat(
          error(
            `Found array member declaration with the same type name as a built-in type ("${def.name}"). Array members can not be given the same name as a built-in type.`,
            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT
          )
        );
      if (def.type === "object" && def.name && visitorContext.getType(def.name))
        return errs.concat(
          warning(
            `Found array member declaration with the same name as the global schema type "${def.name}". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,
            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT
          )
        );
      if (def.type === "array")
        return errs.concat(
          error(
            'Found array member declaration of type "array" - multidimensional arrays are not currently supported by Sanity',
            HELP_IDS.ARRAY_OF_ARRAY
          )
        );
      if (def)
        return errs;
      const err = `Found ${def === null ? "null" : typeof def}, expected member declaration`;
      return errs.concat(
        error(
          `Found invalid type member declaration in array at index ${idx}: ${err}`,
          HELP_IDS.ARRAY_OF_INVALID
        )
      );
    }, []);
    if (invalid.length > 0)
      return {
        ...typeDef,
        of: [],
        _problems: invalid
      };
  }
  const problems = flatten__default.default([
    ofIsArray ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map(
      (dupes) => error(
        `Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in array. This makes it impossible to tell their values apart and you should consider naming them`,
        HELP_IDS.ARRAY_OF_NOT_UNIQUE
      )
    ) : error(
      'The array type is missing or having an invalid value for the required "of" property',
      HELP_IDS.ARRAY_OF_INVALID
    )
  ]), of = ofIsArray ? typeDef.of : [], hasObjectTypesWithoutName = of.some(
    (type) => type.type === "object" && typeof type.name > "u"
  );
  of.some((ofType) => ofType.type === "block") && hasObjectTypesWithoutName && problems.push(
    error(
      "The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.",
      HELP_IDS.ARRAY_OF_INVALID
    )
  );
  const [primitiveTypes, objectTypes] = partition__default.default(
    of,
    (ofType) => {
      var _a2;
      return isPrimitiveTypeName(ofType.type) || isPrimitiveTypeName((_a2 = visitorContext.getType(ofType.type)) == null ? void 0 : _a2.jsonType);
    }
  ), isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0;
  if (isMixedArray) {
    const primitiveTypeNames = primitiveTypes.map((t) => t.type), objectTypeNames = objectTypes.map((t) => t.type);
    problems.push(
      error(
        `The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(
          primitiveTypeNames
        )} ${humanizeList__default.default(primitiveTypeNames.map(quote$2))} and object type${pluralize(
          objectTypeNames
        )} ${humanizeList__default.default(objectTypeNames.map(quote$2))})`,
        HELP_IDS.ARRAY_OF_INVALID
      )
    );
  }
  const list = (_a = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _a.list;
  return !isMixedArray && Array.isArray(list) && (primitiveTypes.length > 0 ? list.forEach((option) => {
    var _a2;
    const value = (_a2 = option == null ? void 0 : option.value) != null ? _a2 : option;
    if (!primitiveTypes.some((primitiveType) => typeof value === visitorContext.getType(primitiveType.type).jsonType)) {
      const formattedTypeList = humanizeList__default.default(
        primitiveTypes.map((t) => t.name || t.type),
        { conjunction: "or" }
      );
      problems.push(
        error(
          `An invalid entry found in options.list: ${format(
            value
          )}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`,
          HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID
        )
      );
    }
  }) : list.forEach((option) => {
    const optionTypeName = option._type || "object";
    objectTypes.some(
      (validObjectType) => isAssignable(optionTypeName, validObjectType)
    ) || problems.push(
      error(
        `An invalid entry found in options.list: ${format(
          option
        )}. Must be an object with "_type" set to ${humanizeList__default.default(
          objectTypes.map((t) => t.name || t.type).map((t) => t === "object" ? "undefined" : quote$2(t)),
          { conjunction: "or" }
        )}`,
        HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID
      )
    );
  })), (_b = typeDef == null ? void 0 : typeDef.options) != null && _b.list && ((_c = typeDef == null ? void 0 : typeDef.options) == null ? void 0 : _c.layout) === "tags" && problems.push(
    warning(
      "Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`."
    )
  ), {
    ...typeDef,
    of: of.map(visitorContext.visit),
    _problems: problems
  };
};
function isJSONTypeOf(type, jsonType, visitorContext) {
  if ("jsonType" in type)
    return type.jsonType === jsonType;
  const parentType = visitorContext.getType(type.type);
  if (!parentType)
    throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`);
  return isJSONTypeOf(parentType, jsonType, visitorContext);
}
const getTypeOf = (thing) => Array.isArray(thing) ? "array" : typeof thing, quote$1 = (str) => `"${str}"`, allowedKeys = [
  "components",
  "lists",
  "marks",
  "name",
  "of",
  "options",
  "styles",
  "title",
  "type",
  "validation"
], allowedMarkKeys = ["decorators", "annotations"], allowedStyleKeys = ["blockEditor", "title", "value", "icon", "component"], allowedDecoratorKeys = ["blockEditor", "title", "value", "icon", "component"], allowedListKeys = ["title", "value", "icon", "component"], supportedBuiltInObjectTypes = ["file", "image", "object", "reference"];
function validateBlockType(typeDef, visitorContext) {
  const problems = [];
  let styles = typeDef.styles, lists = typeDef.lists, marks = typeDef.marks, members = typeDef.of;
  const disallowedKeys = Object.keys(typeDef).filter(
    (key) => !allowedKeys.includes(key) && !key.startsWith("_")
  );
  return disallowedKeys.length > 0 && problems.push(
    error(
      `Found unknown properties for block declaration: ${humanizeList__default.default(
        disallowedKeys.map(quote$1)
      )}`
    )
  ), marks && (marks = validateMarks(typeDef.marks, visitorContext, problems)), styles && (styles = validateStyles(styles, visitorContext, problems)), lists && (lists = validateLists(lists, visitorContext, problems)), members && (members = validateMembers(members, visitorContext, problems)), {
    ...omit__default.default(typeDef, disallowedKeys),
    marks,
    styles,
    name: typeDef.name || typeDef.type,
    of: members,
    _problems: problems
  };
}
function validateMarks(marks, visitorContext, problems) {
  let decorators = marks.decorators, annotations = marks.annotations;
  if (!isPlainObject__default.default(marks))
    return problems.push(error(`"marks" declaration should be an object, got ${getTypeOf(marks)}`)), problems;
  const disallowedMarkKeys = Object.keys(marks).filter(
    (key) => !allowedMarkKeys.includes(key) && !key.startsWith("_")
  );
  return disallowedMarkKeys.length > 0 && problems.push(
    error(
      `Found unknown properties for block declaration: ${humanizeList__default.default(
        disallowedMarkKeys.map(quote$1)
      )}`
    )
  ), decorators && !Array.isArray(decorators) ? problems.push(
    error(`"marks.decorators" declaration should be an array, got ${getTypeOf(decorators)}`)
  ) : decorators && (decorators.filter((dec) => !!dec.blockEditor).forEach((dec) => {
    dec.icon = dec.blockEditor.icon, dec.component = dec.blockEditor.render;
  }), decorators = validateDecorators(decorators, visitorContext, problems)), annotations && !Array.isArray(annotations) ? problems.push(
    error(`"marks.annotations" declaration should be an array, got ${getTypeOf(annotations)}`)
  ) : annotations && (annotations = validateAnnotations(annotations, visitorContext, problems)), { ...marks, decorators, annotations };
}
function validateLists(lists, visitorContext, problems) {
  return Array.isArray(lists) ? (lists.forEach((list, index) => {
    if (!isPlainObject__default.default(list)) {
      problems.push(error(`List must be an object, got ${getTypeOf(list)}`));
      return;
    }
    const name = list.value || `#${index}`, disallowedKeys = Object.keys(list).filter(
      (key) => !allowedListKeys.includes(key) && !key.startsWith("_")
    );
    disallowedKeys.length > 0 && problems.push(
      error(
        `Found unknown properties for list ${name}: ${humanizeList__default.default(disallowedKeys.map(quote$1))}`
      )
    ), list.value ? typeof list.value != "string" ? problems.push(
      error(
        `List type #${index} has an invalid "value" property, expected string, got ${getTypeOf(
          list.value
        )}`
      )
    ) : list.title || problems.push(warning(`List type ${name} is missing recommended "title" property`)) : problems.push(error(`List #${index} is missing required "value" property`));
  }), lists) : (problems.push(error(`"lists" declaration should be an array, got ${getTypeOf(lists)}`)), problems);
}
function validateStyles(styles, visitorContext, problems) {
  return Array.isArray(styles) ? (styles.forEach((style, index) => {
    if (!isPlainObject__default.default(style)) {
      problems.push(error(`Style must be an object, got ${getTypeOf(style)}`));
      return;
    }
    const name = style.value || `#${index}`, disallowedKeys = Object.keys(style).filter(
      (key) => !allowedStyleKeys.includes(key) && !key.startsWith("_")
    );
    disallowedKeys.length > 0 && problems.push(
      error(
        `Found unknown properties for style ${name}: ${humanizeList__default.default(disallowedKeys.map(quote$1))}`
      )
    ), style.value ? typeof style.value != "string" ? problems.push(
      error(
        `Style #${index} has an invalid "value" property, expected string, got ${getTypeOf(
          style.value
        )}`
      )
    ) : style.title || problems.push(warning(`Style ${name} is missing recommended "title" property`)) : problems.push(error(`Style #${index} is missing required "value" property`)), typeof style.blockEditor < "u" && (problems.push(
      warning(
        'Style has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.',
        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY
      )
    ), style.component = style.component || style.blockEditor.render);
  }), styles) : (problems.push(error(`"styles" declaration should be an array, got ${getTypeOf(styles)}`)), problems);
}
function validateDecorators(decorators, visitorContext, problems) {
  return decorators.forEach((decorator, index) => {
    if (!isPlainObject__default.default(decorator)) {
      problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`));
      return;
    }
    const name = decorator.value || `#${index}`, disallowedKeys = Object.keys(decorator).filter(
      (key) => !allowedDecoratorKeys.includes(key) && !key.startsWith("_")
    );
    disallowedKeys.length > 0 && problems.push(
      error(
        `Found unknown properties for decorator ${name}: ${humanizeList__default.default(
          disallowedKeys.map(quote$1)
        )}`
      )
    ), decorator.value ? typeof decorator.value != "string" ? problems.push(
      error(
        `Decorator #${index} has an invalid "value" property, expected string, got ${getTypeOf(
          decorator.value
        )}`
      )
    ) : decorator.title || problems.push(warning(`Decorator ${name} is missing recommended "title" property`)) : problems.push(error(`Decorator #${index} is missing required "value" property`)), typeof decorator.blockEditor < "u" && (problems.push(
      warning(
        `Decorator "${name}" has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.`,
        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY
      )
    ), decorator.icon = decorator.icon || decorator.blockEditor.icon, decorator.component = decorator.component || decorator.blockEditor.render);
  }), decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
  return annotations.map((annotation) => {
    var _a, _b;
    if (!isPlainObject__default.default(annotation))
      return {
        ...annotation,
        _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)]
      };
    const { _problems } = visitorContext.visit(annotation, visitorContext), targetType = annotation.type && visitorContext.getType(annotation.type);
    return targetType && !isJSONTypeOf(targetType, "object", visitorContext) && _problems.push(
      error(
        `Annotation cannot have type "${annotation.type}" - annotation types must inherit from object`
      )
    ), typeof annotation.blockEditor < "u" && (problems.push(
      warning(
        'Annotation has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.',
        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY
      )
    ), annotation.icon = annotation.icon || annotation.blockEditor.icon, (_a = annotation.blockEditor) != null && _a.render && !((_b = annotation.components) != null && _b.annotation) && (annotation.components = annotation.components || {}, annotation.components.annotation = annotation.components.annotation || annotation.blockEditor.render)), { ...annotation, _problems };
  });
}
function validateMembers(members, visitorContext, problems) {
  if (!Array.isArray(members)) {
    problems.push(error(`"of" declaration should be an array, got ${getTypeOf(members)}`));
    return;
  }
  return members.map((member) => {
    const { _problems } = visitorContext.visit(member, visitorContext);
    if (member.type === "object" && member.name && visitorContext.getType(member.name))
      return {
        ...member,
        _problems: [
          warning(
            `Found array member declaration with the same name as the global schema type "${member.name}". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,
            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT
          )
        ]
      };
    let type = member;
    for (; type && !type.jsonType; )
      type = visitorContext.getType(type.type);
    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n));
    return (
      // Must be object-like type (to validate hoisted types)
      type && type.jsonType !== "object" || // Can't be a core type, or core object type that isn't supported (like 'span')
      nonObjectCoreTypes.some((coreName) => coreName === member.type) ? {
        ...member,
        _problems: [
          error(
            `Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join(
              "', '"
            )}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`,
            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT
          )
        ]
      } : { ...member, _problems }
    );
  });
}
function validateNonObjectFieldsProp(typeDef, visitorContext) {
  if (!("fields" in typeDef))
    return [];
  let type = typeDef;
  for (; type && !type.jsonType; )
    type = visitorContext.getType(type.type);
  return type && type.jsonType !== "object" ? [error('Type has propery "fields", but is not an object/document type.')] : [];
}
const quote = (str) => `"${str}"`;
function validateTypeName(typeName, visitorContext) {
  const possibleTypeNames = visitorContext.getTypeNames();
  if (!typeName)
    return [error("Type is missing a type.", HELP_IDS.TYPE_MISSING_TYPE)];
  if (typeof typeName != "string")
    return [
      error(
        'Type has an invalid "type"-property - should be a string.',
        HELP_IDS.TYPE_MISSING_TYPE
      )
    ];
  if (!possibleTypeNames.includes(typeName)) {
    const suggestions = possibleTypeNames.map((possibleTypeName) => [leven__default.default(typeName, possibleTypeName), possibleTypeName]).filter(([distance]) => distance < 3).map(([_, name]) => name), suggestion = suggestions.length > 0 ? ` Did you mean ${humanizeList__default.default(suggestions.map(quote), { conjunction: "or" })}?` : "";
    return [error(`Unknown type: ${typeName}.${suggestion}`)];
  }
  return [];
}
function validateDeprecatedProperties(type) {
  var _a, _b, _c;
  const warnings = [];
  return type != null && type.inputComponent && warnings.push(
    warning('The "inputComponent" property is deprecated. Use "components.input" instead.')
  ), (_a = type == null ? void 0 : type.preview) != null && _a.component && warnings.push(
    warning('The "preview.component" property is deprecated. Use "components.preview" instead.')
  ), type != null && type.diffComponent && warnings.push(
    warning('The "diffComponent" property is deprecated. Use "components.diff" instead.')
  ), (_b = type == null ? void 0 : type.options) != null && _b.editModal && warnings.push(
    warning('The "options.editModal" property is deprecated. Use "options.modal" instead.')
  ), (_c = type == null ? void 0 : type.options) != null && _c.isHighlighted && warnings.push(
    warning(
      'The "options.isHighlighted" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.'
    )
  ), warnings;
}
var common = (typeDef, visitorContext) => ({
  ...typeDef,
  _problems: [
    ...validateTypeName(typeDef.type, visitorContext),
    ...validateNonObjectFieldsProp(typeDef, visitorContext),
    ...validateDeprecatedProperties(typeDef)
  ].filter(Boolean)
});
function normalizeToProp$1(typeDef) {
  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : typeDef.to;
}
const VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;
function isValidDatasetName(name) {
  return name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name) || `The provided dataset "${name}" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`;
}
var crossDatasetReference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || isPlainObject__default.default(typeDef.to), normalizedTo = normalizeToProp$1(typeDef), problems = flatten__default.default([
    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(
      (dupes) => error(
        `Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`,
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    ) : error(
      'The cross dataset reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.',
      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
    )
  ]);
  if (isValidTo && normalizedTo.length === 0 && problems.push(
    error(
      'The cross dataset reference type should define at least one referenced type. Please check the "to" property.',
      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
    )
  ), normalizedTo.forEach((crossDatasetTypeDef, index) => {
    crossDatasetTypeDef.type || problems.push(
      error(
        `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    ), isPlainObject__default.default(crossDatasetTypeDef.preview) || problems.push(
      error(
        `Missing required preview config for the referenced type "${crossDatasetTypeDef.type || "<unknown type>"}"`,
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    );
  }), typeof typeDef.dataset == "string") {
    const datasetValidation = isValidDatasetName(typeDef.dataset);
    datasetValidation !== !0 && problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  } else
    problems.push(
      error(
        "A cross dataset reference must specify a `dataset`",
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    );
  return typeDef.studioUrl && typeof typeDef.studioUrl != "function" && problems.push(
    error(
      'The "studioUrl" property on a cross dataset reference must be a function taking "{id, type}" as argument and returning a studio url.',
      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
    )
  ), problems.push(...getOptionErrors$1(typeDef)), {
    ...typeDef,
    _problems: problems
  };
};
function getOptionErrors$1(typeDef) {
  const { options } = typeDef, problems = [];
  return problems.push(
    ...["filter", "filterParams"].filter((key) => key in typeDef).map(
      (key) => error(
        `\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`,
        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION
      )
    )
  ), options ? isPlainObject__default.default(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(
    error(
      "`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.",
      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION
    )
  ) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(
    error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)
  ) : typeof options.filterParams < "u" && !isPlainObject__default.default(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(
    Object.keys(options.filterParams).filter((key) => key.startsWith("__") || key.startsWith("$")).map((key) => error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))
  ) : problems : problems.concat(
    error(
      "The reference type expects `options` to be an object",
      HELP_IDS.REFERENCE_INVALID_OPTIONS
    )
  ) : problems;
}
const REACT_SYM_RE = /^Symbol\(react\..+\)$/;
function isComponentLike(value) {
  return typeof value == "function" || typeof (value == null ? void 0 : value.$$typeof) == "symbol" && REACT_SYM_RE.test(String(value == null ? void 0 : value.$$typeof));
}
function validateComponent(typeDef) {
  const components = "components" in typeDef ? typeDef.components : !1;
  if (!components)
    return [];
  const warnings = [];
  return components.input && !isComponentLike(components.input) && warnings.push(
    warning(
      `The \`components.input\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect__default.default(
        components.input
      )}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`
    )
  ), components.field && !isComponentLike(components.field) && warnings.push(
    warning(
      `The \`components.field\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect__default.default(
        components.field
      )}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`
    )
  ), components.item && !isComponentLike(components.item) && warnings.push(
    warning(
      `The \`components.item\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect__default.default(
        components.item
      )}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`
    )
  ), components.preview && !isComponentLike(components.preview) && warnings.push(
    warning(
      `The \`components.preview\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect__default.default(
        components.preview
      )}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`
    )
  ), warnings;
}
const VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/, CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
  return typeof name != "string" ? [
    error(
      `Field names must be strings. Saw "${inspect__default.default(name)}"`,
      HELP_IDS.OBJECT_FIELD_NAME_INVALID
    )
  ] : name.startsWith("_") ? [
    error(
      `Invalid field name "${name}". Field names cannot start with underscores "_" as it's reserved for system fields.`,
      HELP_IDS.OBJECT_FIELD_NAME_INVALID
    )
  ] : VALID_FIELD_RE.test(name) ? CONVENTIONAL_FIELD_RE.test(name) ? [] : [
    warning(
      "Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional? It may be wise to keep special characters out of field names for easier access later on."
    ),
    HELP_IDS.OBJECT_FIELD_NAME_INVALID
  ] : [
    error(
      `Invalid field name: "${name}". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(
        VALID_FIELD_RE
      )}).`,
      HELP_IDS.OBJECT_FIELD_NAME_INVALID
    )
  ];
}
function validateField(field, _visitorContext) {
  if (!isPlainObject__default.default(field))
    return [
      error(
        `Incorrect type for field definition - should be an object, saw ${inspect__default.default(field)}`,
        HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE
      )
    ];
  const problems = [];
  return problems.push(
    ..."name" in field ? validateFieldName(field.name) : [error("Missing field name", HELP_IDS.OBJECT_FIELD_NAME_INVALID)]
  ), problems.push(...validateComponent(field)), problems;
}
function getDuplicateFields(array2) {
  const dupes = {};
  return array2.forEach((field) => {
    dupes[field.name] || (dupes[field.name] = []), dupes[field.name].push(field);
  }), Object.keys(dupes).map((fieldName) => dupes[fieldName].length > 1 ? dupes[fieldName] : null).filter(Boolean);
}
function validateFields(fields, options = { allowEmpty: !1 }) {
  const problems = [];
  if (!Array.isArray(fields))
    return [
      error(
        `The "fields" property must be an array of fields. Instead saw "${typeof fields}"`,
        HELP_IDS.OBJECT_FIELDS_INVALID
      )
    ];
  const fieldsWithNames = fields.filter((field) => typeof field.name == "string");
  getDuplicateFields(fieldsWithNames).forEach((dupes) => {
    problems.push(
      error(
        `Found ${dupes.length} fields with name "${dupes[0].name}" in object`,
        HELP_IDS.OBJECT_FIELD_NOT_UNIQUE
      )
    );
  }), fields.length === 0 && !options.allowEmpty && problems.push(error("Object should have at least one field", HELP_IDS.OBJECT_FIELDS_INVALID));
  const standaloneBlockFields = fields.filter((field) => field.type === "block").map((field) => `"${field.name}"`);
  if (standaloneBlockFields.length > 0) {
    const fmtFields = standaloneBlockFields.join(", ");
    problems.push(
      error(
        `Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`,
        HELP_IDS.STANDALONE_BLOCK_TYPE
      )
    );
  }
  return problems;
}
function validatePreview(preview) {
  return isPlainObject__default.default(preview) ? typeof preview.prepare < "u" && typeof preview.prepare != "function" ? [
    error(
      `The "preview.prepare" property must be a function, instead saw "${typeof preview.prepare}"`
    )
  ] : preview.select ? isPlainObject__default.default(preview.select) ? Object.keys(preview.select).reduce((errs, key) => typeof preview.select[key] == "string" ? errs : errs.concat(
    error(
      `The key "${key}" of "preview.select" must be a string, instead saw "${typeof preview.select[key]}"`
    )
  ), []) : [
    error(
      `The "preview.select" property must be an object, instead saw "${typeof preview.prepare}"`
    )
  ] : [] : [error(`The "preview" property must be an object, instead saw "${typeof preview}"`)];
}
var object = (typeDef, visitorContext) => {
  let problems = validateFields(typeDef.fields), preview = typeDef.preview;
  if (preview) {
    const previewErrors = validatePreview(typeDef.preview);
    problems = problems.concat(previewErrors), preview = previewErrors.some((err) => err.severity === "error") ? {} : preview;
  }
  return typeDef.type !== "document" && typeDef.type !== "object" && typeof typeDef.initialValue < "u" && problems.push(
    error('The "initialValue" property is currently only supported for document & object types.')
  ), {
    ...typeDef,
    preview,
    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field, index) => {
      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
}, documentVisitor = (typeDefinition, visitorContext) => {
  const typeDef = object(typeDefinition, visitorContext), { initialValue, initialValues } = typeDef;
  return typeof initialValue < "u" && !isPlainObject__default.default(initialValue) && typeof initialValue != "function" && typeDef._problems.push(
    error('The "initialValue" property must be either a plain object or a function')
  ), typeof initialValues < "u" && typeDef._problems.push(error('Found property "initialValues" - did you mean "initialValue"?')), typeDef;
}, file = (typeDef, visitorContext) => {
  const problems = [], fields = typeDef.fields;
  fields && problems.push(...validateFields(fields, { allowEmpty: !0 }));
  const invalidFieldNames = Array.isArray(fields) ? fields == null ? void 0 : fields.filter((field) => field.name === "asset") : [];
  return typeDef.options && typeof typeDef.options.metadata < "u" && !Array.isArray(typeDef.options.metadata) ? problems.push(
    error(
      "Invalid type for file `metadata` field - must be an array of strings",
      HELP_IDS.ASSET_METADATA_FIELD_INVALID
    )
  ) : invalidFieldNames.length > 0 && problems.push(error("The name `asset` is not a valid field name for type `file`.")), {
    ...typeDef,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
const autoMeta = ["dimensions", "hasAlpha", "isOpaque"];
var image = (typeDef, visitorContext) => {
  const problems = [], fields = typeDef.fields;
  fields && problems.push(...validateFields(fields, { allowEmpty: !0 }));
  let options = typeDef.options;
  const metadata = options == null ? void 0 : options.metadata, superfluousMeta = Array.isArray(metadata) ? metadata.filter((meta) => autoMeta.includes(meta)) : [], invalidFieldNames = ["asset", "hotspot", "crop"], fieldsWithInvalidName = Array.isArray(fields) ? fields == null ? void 0 : fields.filter((field) => invalidFieldNames.includes(field.name)) : [];
  return typeof metadata < "u" && !Array.isArray(metadata) ? problems.push(
    error(
      "Invalid type for image `metadata` field - must be an array of strings",
      HELP_IDS.ASSET_METADATA_FIELD_INVALID
    )
  ) : superfluousMeta.length > 0 ? (problems.push(
    warning(
      `Image \`metadata\` field contains superfluous properties (they are always included): ${superfluousMeta.join(
        ", "
      )}`
    )
  ), options = { ...options, metadata: metadata.filter((meta) => !autoMeta.includes(meta)) }) : fieldsWithInvalidName.length > 0 && problems.push(
    error(
      `The names \`${invalidFieldNames.join(
        "`, `"
      )}\` are invalid field names for type \`image\`.`
    )
  ), {
    ...typeDef,
    options,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
function normalizeToProp(typeDef) {
  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : typeDef.to;
}
var reference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || isPlainObject__default.default(typeDef.to), normalizedTo = normalizeToProp(typeDef), problems = flatten__default.default([
    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(
      (dupes) => error(
        `Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`,
        HELP_IDS.REFERENCE_TO_INVALID
      )
    ) : error(
      'The reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.',
      HELP_IDS.REFERENCE_TO_INVALID
    )
  ]);
  return isValidTo && normalizedTo.length === 0 && problems.push(
    error(
      'The reference type should define at least one accepted type. Please check the "to" property.',
      HELP_IDS.REFERENCE_TO_INVALID
    )
  ), problems.push(...getOptionErrors(typeDef)), {
    ...typeDef,
    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),
    _problems: problems
  };
};
function getOptionErrors(typeDef) {
  const { options } = typeDef, problems = [];
  return problems.push(
    ...["filter", "filterParams"].filter((key) => key in typeDef).map(
      (key) => error(
        `\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`,
        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION
      )
    )
  ), options ? isPlainObject__default.default(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(
    error(
      "`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.",
      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION
    )
  ) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(
    error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)
  ) : typeof options.filterParams < "u" && !isPlainObject__default.default(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(
    Object.keys(options.filterParams).filter((key) => key.startsWith("__") || key.startsWith("$")).map((key) => error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))
  ) : problems : problems.concat(
    error(
      "The reference type expects `options` to be an object",
      HELP_IDS.REFERENCE_INVALID_OPTIONS
    )
  ) : problems;
}
var rootType = (typeDef, visitorContext) => {
  const hasName = !!typeDef.name;
  if (!hasName && Object.keys(typeDef).length === 1)
    return {
      ...typeDef,
      _problems: [
        error(
          "Invalid/undefined type declaration, check declaration or the import/export of the schema type.",
          HELP_IDS.TYPE_INVALID
        )
      ]
    };
  const problems = [];
  return looksLikeEsmModule(typeDef) ? problems.push(
    error(
      "Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property",
      HELP_IDS.TYPE_IS_ESM_MODULE
    )
  ) : hasName ? visitorContext.isReserved(typeDef.name) && problems.push(
    error(
      `Invalid type name: "${typeDef.name}" is a reserved name.`,
      HELP_IDS.TYPE_NAME_RESERVED
    )
  ) : problems.push(error("Missing type name", HELP_IDS.TYPE_MISSING_NAME)), visitorContext.isDuplicate(typeDef.name) && problems.push(
    error(
      `Invalid type name: A type with name "${typeDef.name}" is already defined in the schema.`
    )
  ), problems.push(...validateComponent(typeDef)), "title" in typeDef && typeof typeDef.title != "string" && problems.push(warning("Type title is not a string.", HELP_IDS.TYPE_TITLE_INVALID)), {
    ...typeDef,
    _problems: problems
  };
};
function looksLikeEsmModule(typeDef) {
  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);
}
var slug = (typeDef, visitorContext) => {
  const problems = [];
  return typeDef.options && typeDef.options.slugifyFn && (problems.push(
    warning(
      'Heads up! The "slugifyFn" option has been renamed to "slugify".',
      HELP_IDS.SLUG_SLUGIFY_FN_RENAMED
    )
  ), typeDef.options.slugify = typeDef.options.slugifyFn), {
    ...typeDef,
    _problems: problems
  };
};
const typeVisitors = {
  array,
  object,
  slug,
  file,
  image,
  block: validateBlockType,
  document: documentVisitor,
  reference,
  crossDatasetReference
}, getNoopVisitor = (visitorContext) => (schemaDef) => ({
  name: `<unnamed_type_@_index_${visitorContext.index}>`,
  ...schemaDef,
  _problems: []
});
function combine(...visitors) {
  return (schemaType, visitorContext) => visitors.reduce(
    (result, visitor) => {
      const res = visitor(result, visitorContext);
      return {
        ...res,
        _problems: result._problems.concat(res._problems)
      };
    },
    { _problems: [], ...schemaType }
  );
}
function validateSchema(schemaTypes) {
  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {
    const typeVisitor = schemaDef && schemaDef.type && typeVisitors[schemaDef.type] || getNoopVisitor(visitorContext);
    return visitorContext.isRoot ? combine(rootType, common, typeVisitor)(schemaDef, visitorContext) : combine(common, typeVisitor)(schemaDef, visitorContext);
  });
}
exports.DEFAULT_MAX_FIELD_DEPTH = resolve.DEFAULT_MAX_FIELD_DEPTH;
exports.resolveSearchConfig = resolve.resolveSearchConfig;
exports.resolveSearchConfigForBaseFieldPaths = resolve.resolveSearchConfigForBaseFieldPaths;
exports.extractSchema = extractSchema;
exports.groupProblems = groupProblems;
exports.isActionEnabled = isActionEnabled;
exports.validateSchema = validateSchema;
//# sourceMappingURL=_internal.js.map
