{"version":3,"file":"index.esm.js","sources":["../src/readConfig.ts","../src/readSchema.ts","../src/safeParseQuery.ts","../src/getBabelConfig.ts","../src/typescript/parseSource.ts","../src/typescript/expressionResolvers.ts","../src/typescript/findQueriesInSource.ts","../src/typescript/moduleResolver.ts","../src/typescript/findQueriesInPath.ts","../src/typescript/registerBabel.ts","../src/typescript/typeGenerator.ts"],"sourcesContent":["import {readFile} from 'node:fs/promises'\n\nimport * as json5 from 'json5'\nimport * as z from 'zod'\n\nexport const configDefintion = z.object({\n  path: z\n    .string()\n    .or(z.array(z.string()))\n    .default([\n      './src/**/*.{ts,tsx,js,jsx,mjs,cjs}',\n      './app/**/*.{ts,tsx,js,jsx,mjs,cjs}',\n      './sanity/**/*.{ts,tsx,js,jsx,mjs,cjs}',\n    ]),\n  schema: z.string().default('./schema.json'),\n  generates: z.string().default('./sanity.types.ts'),\n  formatGeneratedCode: z.boolean().default(true),\n})\n\nexport type CodegenConfig = z.infer<typeof configDefintion>\n\nexport async function readConfig(path: string): Promise<CodegenConfig> {\n  try {\n    const content = await readFile(path, 'utf-8')\n    const json = json5.parse(content)\n    return configDefintion.parseAsync(json)\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(`Error in config file\\n ${error.errors.map((err) => err.message).join('\\n')}`)\n    }\n    if (typeof error === 'object' && error !== null && 'code' in error && error.code === 'ENOENT') {\n      return configDefintion.parse({})\n    }\n\n    throw error\n  }\n}\n","import {readFile} from 'node:fs/promises'\n\nimport {type SchemaType} from 'groq-js'\n\n/**\n * Read a schema from a given path\n * @param path - The path to the schema\n * @returns The schema\n * @internal\n * @beta\n **/\nexport async function readSchema(path: string): Promise<SchemaType> {\n  const content = await readFile(path, 'utf-8')\n  return JSON.parse(content) // todo: ZOD validation?\n}\n","import {parse} from 'groq-js'\n\n/**\n * safeParseQuery parses a GROQ query string, but first attempts to extract any parameters used in slices. This method is _only_\n * intended for use in type generation where we don't actually execute the parsed AST on a dataset, and should not be used elsewhere.\n * @internal\n */\nexport function safeParseQuery(query: string) {\n  const params: Record<string, unknown> = {}\n\n  for (const param of extractSliceParams(query)) {\n    params[param] = 0 // we don't care about the value, just the type\n  }\n  return parse(query, {params})\n}\n\n/**\n * Finds occurences of `[($start|{number})..($end|{number})]` in a query string and returns the start and end values, and return\n * the names of the start and end variables.\n * @internal\n */\nexport function* extractSliceParams(query: string): Generator<string> {\n  const sliceRegex = /\\[(\\$(\\w+)|\\d)\\.\\.\\.?(\\$(\\w+)|\\d)\\]/g\n  const matches = query.matchAll(sliceRegex)\n  if (!matches) {\n    return\n  }\n  const params = new Set<string>()\n  for (const match of matches) {\n    const start = match[1] === `$${match[2]}` ? match[2] : null\n    if (start !== null) {\n      yield start\n    }\n    const end = match[3] === `$${match[4]}` ? match[4] : null\n    if (end !== null) {\n      yield end\n    }\n  }\n}\n","import {existsSync} from 'node:fs'\nimport {join, resolve} from 'node:path'\n\nimport {type TransformOptions} from '@babel/core'\n\n/**\n * Because of bundlers and compilers, knowing the exact path the babel configuration will be\n * located at post - build is not always trivial. We traverse from the current directory upwards\n * until we find the first `babel.config.json` and use that path.\n *\n * @param path - The path to start looking for the babel configuration\n * @returns The path to the `babel.config.json` file\n * @internal\n */\nexport function findBabelConfig(path: string): string {\n  const configPath = join(path, 'babel.config.json')\n  if (existsSync(configPath)) {\n    return configPath\n  }\n\n  const parent = resolve(join(path, '..'))\n  if (parent && parent !== path) {\n    return findBabelConfig(parent)\n  }\n\n  throw new Error('Could not find `babel.config.json` in @sanity/codegen')\n}\n\n/**\n * Get the default babel configuration for `@sanity/codegen`\n *\n * @param path - The path to start looking for the babel configuration. Defaults to `__dirname`\n * @returns A babel configuration object\n * @internal\n */\nexport function getBabelConfig(path?: string): TransformOptions {\n  const configPath = findBabelConfig(path || __dirname)\n  return {extends: configPath}\n}\n","import {parse, type TransformOptions} from '@babel/core'\nimport type * as babelTypes from '@babel/types'\n\n// helper function to parse a source file\nexport function parseSourceFile(\n  source: string,\n  filename: string,\n  babelOptions: TransformOptions,\n): babelTypes.File {\n  const result = parse(source, {\n    ...babelOptions,\n    filename,\n  })\n\n  if (!result) {\n    throw new Error(`Failed to parse ${filename}`)\n  }\n\n  return result\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport {type TransformOptions} from '@babel/core'\nimport traverse, {type Scope} from '@babel/traverse'\nimport * as babelTypes from '@babel/types'\nimport createDebug from 'debug'\n\nimport {parseSourceFile} from './parseSource'\n\nconst debug = createDebug('sanity:codegen:findQueries:debug')\n\ntype resolveExpressionReturnType = string\n\n/**\n * NamedQueryResult is a result of a named query\n */\nexport interface NamedQueryResult {\n  /** name is the name of the query */\n  name: string\n  /** result is a groq query */\n  result: resolveExpressionReturnType\n}\n\nconst TAGGED_TEMPLATE_ALLOW_LIST = ['groq']\n\n/**\n * resolveExpression takes a node and returns the resolved value of the expression.\n * @beta\n * @internal\n */\nexport function resolveExpression({\n  node,\n  file,\n  scope,\n  filename,\n  resolver,\n  babelConfig,\n  params = [],\n  fnArguments = [],\n}: {\n  node: babelTypes.Node\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n  params?: babelTypes.Node[]\n  fnArguments?: babelTypes.Node[]\n}): resolveExpressionReturnType {\n  debug(\n    `Resolving node ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n  if (\n    babelTypes.isTaggedTemplateExpression(node) &&\n    babelTypes.isIdentifier(node.tag) &&\n    TAGGED_TEMPLATE_ALLOW_LIST.includes(node.tag.name)\n  ) {\n    return resolveExpression({\n      node: node.quasi,\n      scope,\n      filename,\n      file,\n      resolver,\n      params,\n      babelConfig,\n      fnArguments,\n    })\n  }\n\n  if (babelTypes.isTemplateLiteral(node)) {\n    const resolvedExpressions = node.expressions.map((expression) =>\n      resolveExpression({\n        node: expression,\n        scope,\n        filename,\n        file,\n        resolver,\n        params,\n        babelConfig,\n        fnArguments,\n      }),\n    )\n    return node.quasis\n      .map((quasi, idx) => {\n        return (quasi.value.cooked || '') + (resolvedExpressions[idx] || '')\n      })\n      .join('')\n  }\n\n  if (babelTypes.isLiteral(node)) {\n    if (node.type === 'NullLiteral' || node.type === 'RegExpLiteral') {\n      throw new Error(`Unsupported literal type: ${node.type}`)\n    }\n\n    return node.value.toString()\n  }\n\n  if (babelTypes.isIdentifier(node)) {\n    return resolveIdentifier({\n      node,\n      scope,\n      filename,\n      file,\n      resolver,\n      fnArguments,\n      babelConfig,\n      params,\n    })\n  }\n\n  if (babelTypes.isVariableDeclarator(node)) {\n    if (!node.init) {\n      throw new Error(`Unsupported variable declarator`)\n    }\n\n    return resolveExpression({\n      node: node.init,\n      fnArguments,\n      scope,\n      filename,\n      file,\n      babelConfig,\n      resolver,\n    })\n  }\n\n  if (babelTypes.isCallExpression(node)) {\n    return resolveCallExpression({\n      node,\n      scope,\n      filename,\n      file,\n      resolver,\n      babelConfig,\n      params,\n      fnArguments,\n    })\n  }\n\n  if (\n    babelTypes.isArrowFunctionExpression(node) ||\n    babelTypes.isFunctionDeclaration(node) ||\n    babelTypes.isFunctionExpression(node)\n  ) {\n    return resolveExpression({\n      node: node.body,\n      params: node.params,\n      fnArguments,\n      scope,\n      filename,\n      file,\n      babelConfig,\n      resolver,\n    })\n  }\n\n  if (babelTypes.isNewExpression(node)) {\n    return resolveExpression({\n      node: node.callee,\n      scope,\n      filename,\n      file,\n      babelConfig,\n      resolver,\n    })\n  }\n\n  if (babelTypes.isImportDefaultSpecifier(node) || babelTypes.isImportSpecifier(node)) {\n    return resolveImportSpecifier({node, file, scope, filename, resolver, babelConfig})\n  }\n\n  if (babelTypes.isAssignmentPattern(node)) {\n    return resolveExpression({\n      node: node.right,\n      scope,\n      filename,\n      file,\n      resolver,\n      params,\n      babelConfig,\n      fnArguments,\n    })\n  }\n\n  throw new Error(\n    `Unsupported expression type: ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveIdentifier({\n  node,\n  scope,\n  filename,\n  file,\n  resolver,\n  babelConfig,\n  fnArguments,\n  params,\n}: {\n  node: babelTypes.Identifier\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n  fnArguments: babelTypes.Node[]\n  params: babelTypes.Node[]\n}): resolveExpressionReturnType {\n  const paramIndex = params.findIndex(\n    (param) =>\n      (babelTypes.isIdentifier(param) && node.name === param.name) ||\n      (babelTypes.isAssignmentPattern(param) &&\n        babelTypes.isIdentifier(param.left) &&\n        node.name === param.left.name),\n  )\n  const argument = fnArguments[paramIndex]\n  if (argument && babelTypes.isLiteral(argument)) {\n    return resolveExpression({\n      node: argument,\n      scope,\n      filename,\n      file,\n      resolver,\n      params,\n      babelConfig,\n      fnArguments,\n    })\n  }\n  const binding = scope.getBinding(node.name)\n  if (binding) {\n    if (babelTypes.isIdentifier(binding.path.node)) {\n      const isSame = binding.path.node.name === node.name\n      if (isSame) {\n        throw new Error(\n          `Could not resolve same identifier \"${node.name}\" in \"${filename}:${node.loc?.start.line}:${node.loc?.start.column}\"`,\n        )\n      }\n    }\n    return resolveExpression({\n      node: binding.path.node,\n      params,\n      fnArguments,\n      scope,\n      filename,\n      babelConfig,\n      file,\n      resolver,\n    })\n  }\n\n  throw new Error(\n    `Could not find binding for node \"${node.name}\" in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveCallExpression({\n  node,\n  scope,\n  filename,\n  file,\n  resolver,\n  babelConfig,\n  params,\n}: {\n  node: babelTypes.CallExpression\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n  fnArguments: babelTypes.Node[]\n  params: babelTypes.Node[]\n}): resolveExpressionReturnType {\n  const {callee} = node\n  return resolveExpression({\n    node: callee,\n    scope,\n    filename,\n    file,\n    resolver,\n    babelConfig,\n    params,\n    fnArguments: node.arguments,\n  })\n}\n\nfunction resolveImportSpecifier({\n  node,\n  file,\n  filename,\n  resolver,\n  babelConfig,\n}: {\n  node: babelTypes.ImportDefaultSpecifier | babelTypes.ImportSpecifier | babelTypes.ExportSpecifier\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n}): resolveExpressionReturnType {\n  let importDeclaration: babelTypes.ImportDeclaration | undefined\n  traverse(file, {\n    ImportDeclaration(n) {\n      if (!babelTypes.isImportDeclaration(n.node)) {\n        return\n      }\n      for (const specifier of n.node.specifiers) {\n        if (babelTypes.isImportDefaultSpecifier(specifier)) {\n          if (specifier.local.loc?.identifierName === node.local.name) {\n            importDeclaration = n.node\n            break\n          }\n        }\n        if (specifier.local.name === node.local.name) {\n          importDeclaration = n.node\n        }\n      }\n    },\n  })\n\n  if (!importDeclaration) {\n    throw new Error(`Could not find import declaration for ${node.local.name}`)\n  }\n\n  const importName = node.local.name // the name of the variable to import\n  const importFileName = importDeclaration.source.value // the file to import from\n\n  const importPath =\n    importFileName.startsWith('./') || importFileName.startsWith('../')\n      ? path.resolve(path.dirname(filename), importFileName)\n      : importFileName\n\n  const resolvedFile = resolver(importPath)\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let newScope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      newScope = p.scope\n    },\n  })\n  if (!newScope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = newScope.getBinding(importName)\n  if (binding) {\n    return resolveExpression({\n      node: binding.path.node,\n      file: tree,\n      scope: newScope,\n      babelConfig,\n      filename: resolvedFile,\n      resolver,\n    })\n  }\n\n  // It's not a global binding, but it might be a named export\n  let namedExport: babelTypes.ExportNamedDeclaration | undefined\n  let newImportName: string | undefined\n  traverse(tree, {\n    ExportDeclaration(p) {\n      if (p.node.type === 'ExportNamedDeclaration') {\n        for (const specifier of p.node.specifiers) {\n          if (\n            specifier.type === 'ExportSpecifier' &&\n            specifier.exported.type === 'Identifier' &&\n            specifier.exported.name === importName\n          ) {\n            namedExport = p.node\n            newImportName = specifier.exported.name\n          }\n        }\n      }\n    },\n  })\n\n  if (namedExport && newImportName) {\n    return resolveExportSpecifier({\n      node: namedExport,\n      importName: newImportName,\n      filename: resolvedFile,\n      resolver,\n      babelConfig,\n    })\n  }\n\n  throw new Error(`Could not find binding for import \"${importName}\" in ${importFileName}`)\n}\n\nfunction resolveExportSpecifier({\n  node,\n  importName,\n  filename,\n  babelConfig,\n  resolver,\n}: {\n  node: babelTypes.ExportNamedDeclaration\n  importName: string\n  filename: string\n  babelConfig: TransformOptions\n  resolver: NodeJS.RequireResolve\n}): resolveExpressionReturnType {\n  if (!node.source) {\n    throw new Error(`Could not find source for export \"${importName}\" in ${filename}`)\n  }\n\n  const importFileName = node.source.value\n  const importPath = path.resolve(path.dirname(filename), importFileName)\n  const resolvedFile = resolver(importPath)\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let newScope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      newScope = p.scope\n    },\n  })\n  if (!newScope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = newScope.getBinding(importName)\n  if (binding) {\n    return resolveExpression({\n      node: binding.path.node,\n      file: tree,\n      scope: newScope,\n      filename: importFileName,\n      babelConfig,\n      resolver,\n    })\n  }\n\n  throw new Error(`Could not find binding for export \"${importName}\" in ${importFileName}`)\n}\n","import {createRequire} from 'node:module'\n\nimport {type NodePath, type TransformOptions, traverse} from '@babel/core'\nimport * as babelTypes from '@babel/types'\n\nimport {getBabelConfig} from '../getBabelConfig'\nimport {type NamedQueryResult, resolveExpression} from './expressionResolvers'\nimport {parseSourceFile} from './parseSource'\n\nconst require = createRequire(__filename)\n\nconst groqTagName = 'groq'\n\nconst ignoreValue = '@sanity-typegen-ignore'\n\n/**\n * findQueriesInSource takes a source string and returns all GROQ queries in it.\n * @param source - The source code to search for queries\n * @param filename - The filename of the source code\n * @param babelConfig - The babel configuration to use when parsing the source\n * @param resolver - A resolver function to use when resolving module imports\n * @returns\n * @beta\n * @internal\n */\nexport function findQueriesInSource(\n  source: string,\n  filename: string,\n  babelConfig: TransformOptions = getBabelConfig(),\n  resolver: NodeJS.RequireResolve = require.resolve,\n): NamedQueryResult[] {\n  const queries: NamedQueryResult[] = []\n  const file = parseSourceFile(source, filename, babelConfig)\n\n  traverse(file, {\n    // Look for variable declarations, e.g. `const myQuery = groq`... and extract the query.\n    // The variable name is used as the name of the query result type\n    VariableDeclarator(path) {\n      const {node, scope} = path\n\n      const init = node.init\n\n      // Look for tagged template expressions that are called with the `groq` tag\n      if (\n        babelTypes.isTaggedTemplateExpression(init) &&\n        babelTypes.isIdentifier(init.tag) &&\n        babelTypes.isIdentifier(node.id) &&\n        init.tag.name === groqTagName\n      ) {\n        // If we find a comment leading the decleration which macthes with ignoreValue we don't add\n        // the query\n        if (declarationLeadingCommentContains(path, ignoreValue)) {\n          return\n        }\n\n        const queryName = `${node.id.name}`\n        const queryResult = resolveExpression({\n          node: init,\n          file,\n          scope,\n          babelConfig,\n          filename,\n          resolver,\n        })\n\n        queries.push({name: queryName, result: queryResult})\n      }\n    },\n  })\n\n  return queries\n}\n\nfunction declarationLeadingCommentContains(path: NodePath, comment: string): boolean {\n  /*\n   * We have to consider these cases:\n   *\n   * // @sanity-typegen-ignore\n   * const query = groq`...`\n   *\n   * // AST\n   * VariableDeclaration {\n   *   declarations: [\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *   ],\n   *   leadingComments: ...\n   * }\n   *\n   * // @sanity-typegen-ignore\n   * const query1 = groq`...`, query2 = groq`...`\n   *\n   * // AST\n   * VariableDeclaration {\n   *   declarations: [\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *   ],\n   *   leadingComments: ...\n   * }\n   *\n   * // @sanity-typegen-ignore\n   * export const query = groq`...`\n   *\n   * // AST\n   * ExportNamedDeclaration {\n   *   declaration: VariableDeclaration {\n   *     declarations: [\n   *       VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *       VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *     ],\n   *   },\n   *   leadingComments: ...\n   * }\n   *\n   * In the case where multiple variables are under the same VariableDeclaration the leadingComments\n   * will still be on the VariableDeclaration\n   *\n   * In the case where the variable is exported, the leadingComments are on the\n   * ExportNamedDeclaration which includes the VariableDeclaration in its own declaration property\n   */\n\n  const variableDeclaration = path.find((node) => node.isVariableDeclaration())\n  if (!variableDeclaration) return false\n\n  if (\n    variableDeclaration.node.leadingComments?.find(\n      (commentItem) => commentItem.value.trim() === comment,\n    )\n  ) {\n    return true\n  }\n\n  // If the declaration is exported, the comment lies on the parent of the export declaration\n  if (\n    variableDeclaration.parent.leadingComments?.find(\n      (commentItem) => commentItem.value.trim() === comment,\n    )\n  ) {\n    return true\n  }\n\n  return false\n}\n","import createDebug from 'debug'\nimport {createMatchPath, loadConfig as loadTSConfig} from 'tsconfig-paths'\n\nconst debug = createDebug('sanity:codegen:moduleResolver')\n\n/**\n * This is a custom implementation of require.resolve that takes into account the paths\n * configuration in tsconfig.json. This is necessary if we want to resolve paths that are\n * custom defined in the tsconfig.json file.\n * Resolving here is best effort and might not work in all cases.\n * @beta\n */\nexport function getResolver(cwd?: string): NodeJS.RequireResolve {\n  const tsConfig = loadTSConfig(cwd)\n\n  if (tsConfig.resultType === 'failed') {\n    debug('Could not load tsconfig, using default resolver: %s', tsConfig.message)\n    return require.resolve\n  }\n\n  const matchPath = createMatchPath(\n    tsConfig.absoluteBaseUrl,\n    tsConfig.paths,\n    tsConfig.mainFields,\n    tsConfig.addMatchAll,\n  )\n\n  const resolve = function (request: string, options?: {paths?: string[]}): string {\n    const found = matchPath(request)\n    if (found !== undefined) {\n      return require.resolve(found, options)\n    }\n    return require.resolve(request, options)\n  }\n\n  // wrap the resolve.path function to make it available.\n  resolve.paths = (request: string): string[] | null => {\n    return require.resolve.paths(request)\n  }\n  return resolve\n}\n","import fs from 'node:fs/promises'\n\nimport {type TransformOptions} from '@babel/core'\nimport createDebug from 'debug'\nimport glob from 'globby'\n\nimport {getBabelConfig} from '../getBabelConfig'\nimport {type NamedQueryResult} from './expressionResolvers'\nimport {findQueriesInSource} from './findQueriesInSource'\nimport {getResolver} from './moduleResolver'\n\nconst debug = createDebug('sanity:codegen:findQueries:debug')\n\ntype ResultQueries = {\n  type: 'queries'\n  filename: string\n  queries: NamedQueryResult[]\n}\ntype ResultError = {\n  type: 'error'\n  error: Error\n  filename: string\n}\n\n/**\n * findQueriesInPath takes a path or array of paths and returns all GROQ queries in the files.\n * @param path - The path or array of paths to search for queries\n * @param babelOptions - The babel configuration to use when parsing the source\n * @param resolver - A resolver function to use when resolving module imports\n * @returns An async generator that yields the results of the search\n * @beta\n * @internal\n */\nexport async function* findQueriesInPath({\n  path,\n  babelOptions = getBabelConfig(),\n  resolver = getResolver(),\n}: {\n  path: string | string[]\n  babelOptions?: TransformOptions\n  resolver?: NodeJS.RequireResolve\n}): AsyncGenerator<ResultQueries | ResultError> {\n  const queryNames = new Set()\n  // Holds all query names found in the source files\n  debug(`Globing ${path}`)\n\n  const stream = glob.stream(path, {\n    absolute: false,\n    ignore: ['**/node_modules/**'], // we never want to look in node_modules\n    onlyFiles: true,\n  })\n\n  for await (const filename of stream) {\n    if (typeof filename !== 'string') {\n      continue\n    }\n\n    debug(`Found file \"${filename}\"`)\n    try {\n      const source = await fs.readFile(filename, 'utf8')\n      const queries = findQueriesInSource(source, filename, babelOptions, resolver)\n      // Check and error on duplicate query names, because we can't generate types with the same name.\n      for (const query of queries) {\n        if (queryNames.has(query.name)) {\n          throw new Error(\n            `Duplicate query name found: \"${query.name}\". Query names must be unique across all files.`,\n          )\n        }\n        queryNames.add(query.name)\n      }\n      yield {type: 'queries', filename, queries}\n    } catch (error) {\n      debug(`Error in file \"${filename}\"`, error)\n      yield {type: 'error', error, filename}\n    }\n  }\n}\n","import {type TransformOptions} from '@babel/core'\nimport register from '@babel/register'\n\nimport {getBabelConfig} from '../getBabelConfig'\n\n/**\n * Register Babel with the given options\n *\n * @param babelOptions - The options to use when registering Babel\n * @beta\n */\nexport function registerBabel(babelOptions?: TransformOptions): void {\n  const options = babelOptions || getBabelConfig()\n\n  register({...options, extensions: ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs']})\n}\n","import {CodeGenerator} from '@babel/generator'\nimport * as t from '@babel/types'\nimport {\n  type ArrayTypeNode,\n  type DocumentSchemaType,\n  type ObjectAttribute,\n  type ObjectTypeNode,\n  type SchemaType,\n  type TypeDeclarationSchemaType,\n  type TypeNode,\n  type UnionTypeNode,\n} from 'groq-js'\n\nconst REFERENCE_SYMBOL_NAME = 'internalGroqTypeReferenceTo'\n\n/**\n * A class used to generate TypeScript types from a given schema\n * @internal\n * @beta\n */\nexport class TypeGenerator {\n  private generatedTypeName: Set<string> = new Set()\n  private typeNameMap: Map<string, string> = new Map()\n\n  private readonly schema: SchemaType\n\n  constructor(schema: SchemaType) {\n    this.schema = schema\n  }\n\n  /**\n   * Generate TypeScript types for the given schema\n   * @returns string\n   * @internal\n   * @beta\n   */\n  generateSchemaTypes(): string {\n    const typeDeclarations: (t.TSTypeAliasDeclaration | t.ExportNamedDeclaration)[] = []\n\n    this.schema.forEach((schema) => {\n      const typeLiteral = this.getTypeNodeType(schema)\n\n      const typeAlias = t.tsTypeAliasDeclaration(\n        t.identifier(this.getTypeName(schema.name)),\n        null,\n        typeLiteral,\n      )\n\n      typeDeclarations.push(t.exportNamedDeclaration(typeAlias))\n    })\n\n    // Generate TypeScript code from the AST nodes\n    return typeDeclarations.map((decl) => new CodeGenerator(decl).generate().code).join('\\n\\n')\n  }\n\n  /**\n   * Takes a identifier and a type node and generates a type alias for the type node.\n   * @param identifierName - The name of the type to generated\n   * @param typeNode - The type node to generate the type for\n   * @returns\n   * @internal\n   * @beta\n   */\n  generateTypeNodeTypes(identifierName: string, typeNode: TypeNode): string {\n    const type = this.getTypeNodeType(typeNode)\n\n    const typeAlias = t.tsTypeAliasDeclaration(\n      t.identifier(this.getTypeName(identifierName)),\n      null,\n      type,\n    )\n\n    return new CodeGenerator(t.exportNamedDeclaration(typeAlias)).generate().code.trim()\n  }\n\n  static generateKnownTypes(): string {\n    const typeOperator = t.tsTypeOperator(t.tsSymbolKeyword())\n    typeOperator.operator = 'unique'\n\n    const identifier = t.identifier(REFERENCE_SYMBOL_NAME)\n    identifier.typeAnnotation = t.tsTypeAnnotation(typeOperator)\n\n    const decleration = t.variableDeclaration('const', [t.variableDeclarator(identifier)])\n    decleration.declare = true\n    return new CodeGenerator(t.exportNamedDeclaration(decleration)).generate().code.trim()\n  }\n\n  /**\n   * Since we are sanitizing identifiers we migt end up with collisions. Ie there might be a type mux.video and muxVideo, both these\n   * types would be sanityized into MuxVideo. To avoid this we keep track of the generated type names and add a index to the name.\n   * When we reference a type we also keep track of the original name so we can reference the correct type later.\n   */\n  private getTypeName(name: string): string {\n    const desiredName = uppercaseFirstLetter(sanitizeIdentifier(name))\n\n    let generatedName = desiredName\n    let i = 2\n    while (this.generatedTypeName.has(generatedName)) {\n      // add _ and a index and increment that index until we find a name that is not in the map\n      generatedName = `${desiredName}_${i++}`\n    }\n    this.generatedTypeName.add(generatedName)\n    this.typeNameMap.set(name, generatedName)\n    return generatedName\n  }\n\n  private getTypeNodeType(\n    typeNode: TypeNode | TypeDeclarationSchemaType | DocumentSchemaType,\n  ): t.TSType {\n    switch (typeNode.type) {\n      case 'string': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.stringLiteral(typeNode.value))\n        }\n        return t.tsStringKeyword()\n      }\n      case 'number': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.numericLiteral(typeNode.value))\n        }\n        return t.tsNumberKeyword()\n      }\n      case 'boolean': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.booleanLiteral(typeNode.value))\n        }\n        return t.tsBooleanKeyword()\n      }\n      case 'unknown': {\n        return t.tsUnknownKeyword()\n      }\n      case 'document': {\n        return this.generateDocumentType(typeNode)\n      }\n      case 'type': {\n        return this.getTypeNodeType(typeNode.value)\n      }\n      case 'array': {\n        return this.generateArrayTsType(typeNode)\n      }\n      case 'object': {\n        return this.generateObjectTsType(typeNode)\n      }\n      case 'union': {\n        return this.generateUnionTsType(typeNode)\n      }\n      case 'inline': {\n        return t.tsTypeReference(\n          t.identifier(uppercaseFirstLetter(sanitizeIdentifier(typeNode.name))),\n        )\n      }\n      case 'null': {\n        return t.tsNullKeyword()\n      }\n\n      default:\n        // @ts-expect-error This should never happen\n        throw new Error(`Type \"${typeNode.type}\" not found in schema`)\n    }\n  }\n\n  // Helper function used to generate TS types for array type nodes.\n  private generateArrayTsType(typeNode: ArrayTypeNode): t.TSTypeReference {\n    const typeNodes = this.getTypeNodeType(typeNode.of)\n    const arrayType = t.tsTypeReference(\n      t.identifier('Array'),\n      t.tsTypeParameterInstantiation([typeNodes]),\n    )\n\n    return arrayType\n  }\n\n  // Helper function used to generate TS types for object properties.\n  private generateObjectProperty(key: string, attribute: ObjectAttribute): t.TSPropertySignature {\n    const type = this.getTypeNodeType(attribute.value)\n    const propertySignature = t.tsPropertySignature(\n      t.identifier(sanitizeIdentifier(key)),\n      t.tsTypeAnnotation(type),\n    )\n    propertySignature.optional = attribute.optional\n\n    return propertySignature\n  }\n\n  // Helper function used to generate TS types for object type nodes.\n  private generateObjectTsType(typeNode: ObjectTypeNode): t.TSType {\n    const props: t.TSPropertySignature[] = []\n    Object.entries(typeNode.attributes).forEach(([key, attribute]) => {\n      props.push(this.generateObjectProperty(key, attribute))\n    })\n    if (typeNode.rest !== undefined) {\n      switch (typeNode.rest.type) {\n        case 'unknown': {\n          return t.tsUnknownKeyword()\n        }\n        case 'object': {\n          Object.entries(typeNode.rest.attributes).forEach(([key, attribute]) => {\n            props.push(this.generateObjectProperty(key, attribute))\n          })\n          break\n        }\n        case 'inline': {\n          return t.tsIntersectionType([\n            t.tsTypeLiteral(props),\n            t.tsTypeReference(\n              t.identifier(\n                this.typeNameMap.get(typeNode.rest.name) ||\n                  uppercaseFirstLetter(sanitizeIdentifier(typeNode.rest.name)),\n              ),\n            ),\n          ])\n        }\n        default: {\n          // @ts-expect-error This should never happen\n          throw new Error(`Type \"${typeNode.rest.type}\" not found in schema`)\n        }\n      }\n    }\n    if (typeNode.dereferencesTo !== undefined) {\n      const derefType = t.tsPropertySignature(\n        t.identifier(REFERENCE_SYMBOL_NAME),\n        t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(typeNode.dereferencesTo))),\n      )\n      derefType.computed = true\n      derefType.optional = true\n      props.push(derefType)\n    }\n    return t.tsTypeLiteral(props)\n  }\n\n  // Helper function used to generate TS types for union type nodes.\n  private generateUnionTsType(typeNode: UnionTypeNode): t.TSType {\n    if (typeNode.of.length === 0) {\n      return t.tsNeverKeyword()\n    }\n    if (typeNode.of.length === 1) {\n      return this.getTypeNodeType(typeNode.of[0])\n    }\n\n    const typeNodes = typeNode.of.map((node) => this.getTypeNodeType(node))\n\n    return t.tsUnionType(typeNodes)\n  }\n\n  // Helper function used to generate TS types for document type nodes.\n  private generateDocumentType(document: DocumentSchemaType): t.TSType {\n    const props = Object.entries(document.attributes).map(([key, node]) =>\n      this.generateObjectProperty(key, node),\n    )\n\n    return t.tsTypeLiteral(props)\n  }\n}\nfunction uppercaseFirstLetter(input: string): string {\n  return input.charAt(0).toUpperCase() + input.slice(1)\n}\n\nfunction sanitizeIdentifier(input: string): string {\n  return `${input.replace(/^\\d/, '_').replace(/[^$\\w]+(.)/g, (_, char) => char.toUpperCase())}`\n}\n"],"names":["path","parse","debug","babelTypes","require","traverse","loadTSConfig","resolve","fs"],"mappings":"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"}