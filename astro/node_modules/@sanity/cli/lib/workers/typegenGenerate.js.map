{"version":3,"file":"typegenGenerate.js","sources":["../../src/workers/typegenGenerate.ts"],"sourcesContent":["import {isMainThread, parentPort, workerData as _workerData} from 'node:worker_threads'\n\nimport {\n  findQueriesInPath,\n  getResolver,\n  readSchema,\n  registerBabel,\n  safeParseQuery,\n  TypeGenerator,\n} from '@sanity/codegen'\nimport createDebug from 'debug'\nimport {typeEvaluate, type TypeNode} from 'groq-js'\nimport {format as prettierFormat, type Options as PrettierOptions} from 'prettier'\n\nconst $info = createDebug('sanity:codegen:generate:info')\nconst $warn = createDebug('sanity:codegen:generate:warn')\n\nexport interface TypegenGenerateTypesWorkerData {\n  workDir: string\n  workspaceName?: string\n  schemaPath: string\n  searchPath: string | string[]\n  prettierConfig: PrettierOptions | null\n}\n\nexport type TypegenGenerateTypesWorkerMessage =\n  | {\n      type: 'error'\n      error: Error\n      fatal: boolean\n      query?: string\n      filename?: string\n    }\n  | {\n      type: 'types'\n      filename: string\n      types: {\n        queryName: string\n        query: string\n        type: string\n        unknownTypeNodesGenerated: number\n        typeNodesGenerated: number\n        emptyUnionTypeNodesGenerated: number\n      }[]\n    }\n  | {\n      type: 'schema'\n      filename: string\n      schema: string\n      length: number\n    }\n  | {\n      type: 'complete'\n    }\n\nif (isMainThread || !parentPort) {\n  throw new Error('This module must be run as a worker thread')\n}\n\nconst opts = _workerData as TypegenGenerateTypesWorkerData\n\nregisterBabel()\n\nfunction maybeFormatCode(code: string, prettierConfig: PrettierOptions | null): Promise<string> {\n  if (!prettierConfig) {\n    return Promise.resolve(`${code}\\n`) // add an extra new newline, poor mans formatting\n  }\n\n  try {\n    return prettierFormat(code, {\n      ...prettierConfig,\n      parser: 'typescript' as const,\n    })\n  } catch (err) {\n    $warn(`Error formatting: ${err.message}`)\n  }\n  return Promise.resolve(code)\n}\n\nasync function main() {\n  const schema = await readSchema(opts.schemaPath)\n\n  const typeGenerator = new TypeGenerator(schema)\n  const schemaTypes = await maybeFormatCode(\n    [typeGenerator.generateSchemaTypes(), TypeGenerator.generateKnownTypes()].join('\\n').trim(),\n    opts.prettierConfig,\n  )\n  const resolver = getResolver()\n\n  parentPort?.postMessage({\n    type: 'schema',\n    schema: schemaTypes,\n    filename: 'schema.json',\n    length: schema.length,\n  } satisfies TypegenGenerateTypesWorkerMessage)\n\n  const queries = findQueriesInPath({\n    path: opts.searchPath,\n    resolver,\n  })\n\n  for await (const result of queries) {\n    if (result.type === 'error') {\n      parentPort?.postMessage({\n        type: 'error',\n        error: result.error,\n        fatal: false,\n        filename: result.filename,\n      } satisfies TypegenGenerateTypesWorkerMessage)\n      continue\n    }\n    $info(`Processing ${result.queries.length} queries in \"${result.filename}\"...`)\n\n    const fileQueryTypes: {\n      queryName: string\n      query: string\n      type: string\n      unknownTypeNodesGenerated: number\n      typeNodesGenerated: number\n      emptyUnionTypeNodesGenerated: number\n    }[] = []\n    for (const {name: queryName, result: query} of result.queries) {\n      try {\n        const ast = safeParseQuery(query)\n        const queryTypes = typeEvaluate(ast, schema)\n\n        const type = await maybeFormatCode(\n          typeGenerator.generateTypeNodeTypes(`${queryName}Result`, queryTypes).trim(),\n          opts.prettierConfig,\n        )\n\n        const queryTypeStats = walkAndCountQueryTypeNodeStats(queryTypes)\n        fileQueryTypes.push({\n          queryName,\n          query,\n          type,\n          unknownTypeNodesGenerated: queryTypeStats.unknownTypes,\n          typeNodesGenerated: queryTypeStats.allTypes,\n          emptyUnionTypeNodesGenerated: queryTypeStats.emptyUnions,\n        })\n      } catch (err) {\n        parentPort?.postMessage({\n          type: 'error',\n          error: new Error(\n            `Error generating types for query \"${queryName}\" in \"${result.filename}\": ${err.message}`,\n            {cause: err},\n          ),\n          fatal: false,\n          query,\n        } satisfies TypegenGenerateTypesWorkerMessage)\n      }\n    }\n\n    if (fileQueryTypes.length > 0) {\n      $info(`Generated types for ${fileQueryTypes.length} queries in \"${result.filename}\"\\n`)\n      parentPort?.postMessage({\n        type: 'types',\n        types: fileQueryTypes,\n        filename: result.filename,\n      } satisfies TypegenGenerateTypesWorkerMessage)\n    }\n  }\n\n  parentPort?.postMessage({\n    type: 'complete',\n  } satisfies TypegenGenerateTypesWorkerMessage)\n}\n\nfunction walkAndCountQueryTypeNodeStats(typeNode: TypeNode): {\n  allTypes: number\n  unknownTypes: number\n  emptyUnions: number\n} {\n  switch (typeNode.type) {\n    case 'unknown': {\n      return {allTypes: 1, unknownTypes: 1, emptyUnions: 0}\n    }\n    case 'array': {\n      const acc = walkAndCountQueryTypeNodeStats(typeNode.of)\n      acc.allTypes += 1 // count the array type itself\n      return acc\n    }\n    case 'object': {\n      // if the rest is unknown, we count it as one unknown type\n      if (typeNode.rest && typeNode.rest.type === 'unknown') {\n        return {allTypes: 2, unknownTypes: 1, emptyUnions: 0} // count the object type itself as well\n      }\n\n      const restStats = typeNode.rest\n        ? walkAndCountQueryTypeNodeStats(typeNode.rest)\n        : {allTypes: 1, unknownTypes: 0, emptyUnions: 0} // count the object type itself\n\n      return Object.values(typeNode.attributes).reduce((acc, attribute) => {\n        const {allTypes, unknownTypes, emptyUnions} = walkAndCountQueryTypeNodeStats(\n          attribute.value,\n        )\n        return {\n          allTypes: acc.allTypes + allTypes,\n          unknownTypes: acc.unknownTypes + unknownTypes,\n          emptyUnions: acc.emptyUnions + emptyUnions,\n        }\n      }, restStats)\n    }\n    case 'union': {\n      if (typeNode.of.length === 0) {\n        return {allTypes: 1, unknownTypes: 0, emptyUnions: 1}\n      }\n\n      return typeNode.of.reduce(\n        (acc, type) => {\n          const {allTypes, unknownTypes, emptyUnions} = walkAndCountQueryTypeNodeStats(type)\n          return {\n            allTypes: acc.allTypes + allTypes,\n            unknownTypes: acc.unknownTypes + unknownTypes,\n            emptyUnions: acc.emptyUnions + emptyUnions,\n          }\n        },\n        {allTypes: 1, unknownTypes: 0, emptyUnions: 0}, // count the union type itself\n      )\n    }\n    default: {\n      return {allTypes: 1, unknownTypes: 0, emptyUnions: 0}\n    }\n  }\n}\n\nmain()\n"],"names":["createDebug","isMainThread","parentPort","_workerData","registerBabel","prettierFormat","readSchema","TypeGenerator","getResolver","findQueriesInPath","safeParseQuery","typeEvaluate"],"mappings":"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"}