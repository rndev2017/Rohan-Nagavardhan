"use strict";
var node_worker_threads = require("node:worker_threads"), codegen = require("@sanity/codegen"), createDebug = require("debug"), groqJs = require("groq-js"), prettier = require("prettier");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var createDebug__default = /* @__PURE__ */ _interopDefaultCompat(createDebug);
const $info = createDebug__default.default("sanity:codegen:generate:info"), $warn = createDebug__default.default("sanity:codegen:generate:warn");
if (node_worker_threads.isMainThread || !node_worker_threads.parentPort)
  throw new Error("This module must be run as a worker thread");
const opts = node_worker_threads.workerData;
codegen.registerBabel();
function maybeFormatCode(code, prettierConfig) {
  if (!prettierConfig)
    return Promise.resolve(`${code}
`);
  try {
    return prettier.format(code, {
      ...prettierConfig,
      parser: "typescript"
    });
  } catch (err) {
    $warn(`Error formatting: ${err.message}`);
  }
  return Promise.resolve(code);
}
async function main() {
  const schema = await codegen.readSchema(opts.schemaPath), typeGenerator = new codegen.TypeGenerator(schema), schemaTypes = await maybeFormatCode(
    [typeGenerator.generateSchemaTypes(), codegen.TypeGenerator.generateKnownTypes()].join(`
`).trim(),
    opts.prettierConfig
  ), resolver = codegen.getResolver();
  node_worker_threads.parentPort?.postMessage({
    type: "schema",
    schema: schemaTypes,
    filename: "schema.json",
    length: schema.length
  });
  const queries = codegen.findQueriesInPath({
    path: opts.searchPath,
    resolver
  });
  for await (const result of queries) {
    if (result.type === "error") {
      node_worker_threads.parentPort?.postMessage({
        type: "error",
        error: result.error,
        fatal: !1,
        filename: result.filename
      });
      continue;
    }
    $info(`Processing ${result.queries.length} queries in "${result.filename}"...`);
    const fileQueryTypes = [];
    for (const { name: queryName, result: query } of result.queries)
      try {
        const ast = codegen.safeParseQuery(query), queryTypes = groqJs.typeEvaluate(ast, schema), type = await maybeFormatCode(
          typeGenerator.generateTypeNodeTypes(`${queryName}Result`, queryTypes).trim(),
          opts.prettierConfig
        ), queryTypeStats = walkAndCountQueryTypeNodeStats(queryTypes);
        fileQueryTypes.push({
          queryName,
          query,
          type,
          unknownTypeNodesGenerated: queryTypeStats.unknownTypes,
          typeNodesGenerated: queryTypeStats.allTypes,
          emptyUnionTypeNodesGenerated: queryTypeStats.emptyUnions
        });
      } catch (err) {
        node_worker_threads.parentPort?.postMessage({
          type: "error",
          error: new Error(
            `Error generating types for query "${queryName}" in "${result.filename}": ${err.message}`,
            { cause: err }
          ),
          fatal: !1,
          query
        });
      }
    fileQueryTypes.length > 0 && ($info(`Generated types for ${fileQueryTypes.length} queries in "${result.filename}"
`), node_worker_threads.parentPort?.postMessage({
      type: "types",
      types: fileQueryTypes,
      filename: result.filename
    }));
  }
  node_worker_threads.parentPort?.postMessage({
    type: "complete"
  });
}
function walkAndCountQueryTypeNodeStats(typeNode) {
  switch (typeNode.type) {
    case "unknown":
      return { allTypes: 1, unknownTypes: 1, emptyUnions: 0 };
    case "array": {
      const acc = walkAndCountQueryTypeNodeStats(typeNode.of);
      return acc.allTypes += 1, acc;
    }
    case "object": {
      if (typeNode.rest && typeNode.rest.type === "unknown")
        return { allTypes: 2, unknownTypes: 1, emptyUnions: 0 };
      const restStats = typeNode.rest ? walkAndCountQueryTypeNodeStats(typeNode.rest) : { allTypes: 1, unknownTypes: 0, emptyUnions: 0 };
      return Object.values(typeNode.attributes).reduce((acc, attribute) => {
        const { allTypes, unknownTypes, emptyUnions } = walkAndCountQueryTypeNodeStats(
          attribute.value
        );
        return {
          allTypes: acc.allTypes + allTypes,
          unknownTypes: acc.unknownTypes + unknownTypes,
          emptyUnions: acc.emptyUnions + emptyUnions
        };
      }, restStats);
    }
    case "union":
      return typeNode.of.length === 0 ? { allTypes: 1, unknownTypes: 0, emptyUnions: 1 } : typeNode.of.reduce(
        (acc, type) => {
          const { allTypes, unknownTypes, emptyUnions } = walkAndCountQueryTypeNodeStats(type);
          return {
            allTypes: acc.allTypes + allTypes,
            unknownTypes: acc.unknownTypes + unknownTypes,
            emptyUnions: acc.emptyUnions + emptyUnions
          };
        },
        { allTypes: 1, unknownTypes: 0, emptyUnions: 0 }
        // count the union type itself
      );
    default:
      return { allTypes: 1, unknownTypes: 0, emptyUnions: 0 };
  }
}
main();
//# sourceMappingURL=typegenGenerate.js.map
