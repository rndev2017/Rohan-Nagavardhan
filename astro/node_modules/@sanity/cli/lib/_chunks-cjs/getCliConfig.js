"use strict";
var fs = require("node:fs"), path = require("node:path"), node_worker_threads = require("node:worker_threads"), cliWorker = require("./cliWorker.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), path__default = /* @__PURE__ */ _interopDefaultCompat(path);
const requireFunc = typeof __webpack_require__ == "function" ? __non_webpack_require__ : require;
function dynamicRequire(request) {
  const mod = requireFunc(request);
  return mod.__esModule && mod.default ? mod.default : mod;
}
dynamicRequire.resolve = requireFunc.resolve;
async function getCliConfig(cwd, { forked } = {}) {
  if (forked)
    try {
      return await getCliConfigForked(cwd);
    } catch {
    }
  const { unregister } = require("esbuild-register/dist/node").register();
  try {
    return getSanityCliConfig(cwd) || getSanityJsonConfig(cwd);
  } catch (err) {
    throw err;
  } finally {
    unregister();
  }
}
function getCliConfigSync(cwd) {
  return getSanityCliConfig(cwd) || getSanityJsonConfig(cwd);
}
async function getCliConfigForked(cwd) {
  const workerPath = await cliWorker.getCliWorkerPath("getCliConfig");
  return new Promise((resolve, reject) => {
    const worker = new node_worker_threads.Worker(workerPath, {
      workerData: cwd,
      // eslint-disable-next-line no-process-env
      env: process.env
    });
    worker.on("message", (message) => {
      if (message.type === "config")
        resolve(message.config);
      else {
        const error = new Error(message.error);
        error.type = message.errorType, reject(new Error(message.error));
      }
    }), worker.on("error", reject), worker.on("exit", (code) => {
      code !== 0 && reject(new Error(`Worker stopped with exit code ${code}`));
    });
  });
}
function getSanityJsonConfig(cwd) {
  const configPath = path__default.default.join(cwd, "sanity.json");
  return fs__default.default.existsSync(configPath) ? {
    config: loadJsonConfig(configPath),
    path: configPath,
    version: 2
  } : null;
}
function getSanityCliConfig(cwd) {
  const jsConfigPath = path__default.default.join(cwd, "sanity.cli.js"), tsConfigPath = path__default.default.join(cwd, "sanity.cli.ts"), [js, ts] = [fs__default.default.existsSync(jsConfigPath), fs__default.default.existsSync(tsConfigPath)];
  return !js && !ts ? null : !js && ts ? {
    config: importConfig(tsConfigPath),
    path: tsConfigPath,
    version: 3
  } : (js && ts && warn("Found both `sanity.cli.js` and `sanity.cli.ts` - using sanity.cli.js"), {
    config: importConfig(jsConfigPath),
    path: jsConfigPath,
    version: 3
  });
}
function loadJsonConfig(filePath) {
  try {
    const content = fs__default.default.readFileSync(filePath, "utf8");
    return JSON.parse(content);
  } catch (err) {
    return console.error(`Error reading "${filePath}": ${err.message}`), null;
  }
}
function importConfig(filePath) {
  try {
    const config = dynamicRequire(filePath);
    if (config === null || typeof config != "object")
      throw new Error("Module export is not a configuration object");
    return "default" in config ? config.default : config;
  } catch (err) {
    return err.code === "MODULE_NOT_FOUND" && err.message.includes("sanity/cli") || console.error(`Error reading "${filePath}": ${err.message}`), null;
  }
}
function warn(warning) {
  typeof process.send == "function" ? process.send({ type: "warning", warning }) : console.warn(warning);
}
exports.dynamicRequire = dynamicRequire;
exports.getCliConfig = getCliConfig;
exports.getCliConfigSync = getCliConfigSync;
//# sourceMappingURL=getCliConfig.js.map
