"use strict";
var fs$1 = require("node:fs"), path$1 = require("node:path"), createDebug = require("debug"), require$$0 = require("fs"), require$$0$1 = require("path"), require$$0$2 = require("os"), require$$3 = require("crypto");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs$1), path__default = /* @__PURE__ */ _interopDefaultCompat(path$1), createDebug__default = /* @__PURE__ */ _interopDefaultCompat(createDebug), require$$0__default = /* @__PURE__ */ _interopDefaultCompat(require$$0), require$$0__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$0$1), require$$0__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$0$2), require$$3__default = /* @__PURE__ */ _interopDefaultCompat(require$$3);
const debug = createDebug__default.default("sanity:cli");
function resolveRootDir(cwd) {
  try {
    return resolveProjectRoot(cwd) || cwd;
  } catch (err) {
    throw new Error(`Error occurred trying to resolve project root:
${err.message}`);
  }
}
function hasStudioConfig(basePath) {
  return [
    fileExists(path__default.default.join(basePath, "sanity.config.js")),
    fileExists(path__default.default.join(basePath, "sanity.config.ts")),
    isSanityV2StudioRoot(basePath)
  ].some(Boolean);
}
function resolveProjectRoot(basePath, iterations = 0) {
  if (hasStudioConfig(basePath))
    return basePath;
  const parentDir = path__default.default.resolve(basePath, "..");
  return parentDir === basePath || iterations > 30 ? !1 : resolveProjectRoot(parentDir, iterations + 1);
}
function isSanityV2StudioRoot(basePath) {
  try {
    const content = fs__default.default.readFileSync(path__default.default.join(basePath, "sanity.json"), "utf8"), isRoot = !!JSON.parse(content)?.root;
    return isRoot && debug("Found Sanity v2 studio root at %s", basePath), isRoot;
  } catch {
    return !1;
  }
}
function fileExists(filePath) {
  return fs__default.default.existsSync(filePath);
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      return this instanceof a2 ? Reflect.construct(f, arguments, this.constructor) : f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: !0,
      get: function() {
        return n[k];
      }
    });
  }), a;
}
var main$1 = { exports: {} }, name = "dotenv", version$1 = "16.4.5", description = "Loads environment variables from .env file", main = "lib/main.js", types = "lib/main.d.ts", exports$1 = {
  ".": {
    types: "./lib/main.d.ts",
    require: "./lib/main.js",
    default: "./lib/main.js"
  },
  "./config": "./config.js",
  "./config.js": "./config.js",
  "./lib/env-options": "./lib/env-options.js",
  "./lib/env-options.js": "./lib/env-options.js",
  "./lib/cli-options": "./lib/cli-options.js",
  "./lib/cli-options.js": "./lib/cli-options.js",
  "./package.json": "./package.json"
}, scripts = {
  "dts-check": "tsc --project tests/types/tsconfig.json",
  lint: "standard",
  "lint-readme": "standard-markdown",
  pretest: "npm run lint && npm run dts-check",
  test: "tap tests/*.js --100 -Rspec",
  "test:coverage": "tap --coverage-report=lcov",
  prerelease: "npm test",
  release: "standard-version"
}, repository = {
  type: "git",
  url: "git://github.com/motdotla/dotenv.git"
}, funding = "https://dotenvx.com", keywords = [
  "dotenv",
  "env",
  ".env",
  "environment",
  "variables",
  "config",
  "settings"
], readmeFilename = "README.md", license = "BSD-2-Clause", devDependencies = {
  "@definitelytyped/dtslint": "^0.0.133",
  "@types/node": "^18.11.3",
  decache: "^4.6.1",
  sinon: "^14.0.1",
  standard: "^17.0.0",
  "standard-markdown": "^7.1.0",
  "standard-version": "^9.5.0",
  tap: "^16.3.0",
  tar: "^6.1.11",
  typescript: "^4.8.4"
}, engines = {
  node: ">=12"
}, browser = {
  fs: !1
}, require$$4 = {
  name,
  version: version$1,
  description,
  main,
  types,
  exports: exports$1,
  scripts,
  repository,
  funding,
  keywords,
  readmeFilename,
  license,
  devDependencies,
  engines,
  browser
};
const fs = require$$0__default.default, path = require$$0__default$1.default, os = require$$0__default$2.default, crypto = require$$3__default.default, packageJson = require$$4, version = packageJson.version, LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse(src) {
  const obj = {};
  let lines = src.toString();
  lines = lines.replace(/\r\n?/mg, `
`);
  let match;
  for (; (match = LINE.exec(lines)) != null; ) {
    const key = match[1];
    let value = match[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), maybeQuote === '"' && (value = value.replace(/\\n/g, `
`), value = value.replace(/\\r/g, "\r")), obj[key] = value;
  }
  return obj;
}
function _parseVault(options) {
  const vaultPath = _vaultPath(options), result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    throw err.code = "MISSING_DATA", err;
  }
  const keys = _dotenvKey(options).split(","), length = keys.length;
  let decrypted;
  for (let i = 0; i < length; i++)
    try {
      const key = keys[i].trim(), attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error) {
      if (i + 1 >= length)
        throw error;
    }
  return DotenvModule.parse(decrypted);
}
function _log(message) {
  console.log(`[dotenv@${version}][INFO] ${message}`);
}
function _warn(message) {
  console.log(`[dotenv@${version}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`);
}
function _dotenvKey(options) {
  return options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0 ? options.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
}
function _instructions(result, dotenvKey) {
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error) {
    if (error.code === "ERR_INVALID_URL") {
      const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      throw err.code = "INVALID_DOTENV_KEY", err;
    }
    throw error;
  }
  const key = uri.password;
  if (!key) {
    const err = new Error("INVALID_DOTENV_KEY: Missing key part");
    throw err.code = "INVALID_DOTENV_KEY", err;
  }
  const environment = uri.searchParams.get("environment");
  if (!environment) {
    const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
    throw err.code = "INVALID_DOTENV_KEY", err;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`, ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    throw err.code = "NOT_FOUND_DOTENV_ENVIRONMENT", err;
  }
  return { ciphertext, key };
}
function _vaultPath(options) {
  let possibleVaultPath = null;
  if (options && options.path && options.path.length > 0)
    if (Array.isArray(options.path))
      for (const filepath of options.path)
        fs.existsSync(filepath) && (possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`);
    else
      possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
  else
    possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
  return fs.existsSync(possibleVaultPath) ? possibleVaultPath : null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options) {
  _log("Loading env from encrypted .env.vault");
  const parsed = DotenvModule._parseVault(options);
  let processEnv = process.env;
  return options && options.processEnv != null && (processEnv = options.processEnv), DotenvModule.populate(processEnv, parsed, options), { parsed };
}
function configDotenv(options) {
  const dotenvPath = path.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug2 = !!(options && options.debug);
  options && options.encoding ? encoding = options.encoding : debug2 && _debug("No encoding is specified. UTF-8 is used by default");
  let optionPaths = [dotenvPath];
  if (options && options.path)
    if (!Array.isArray(options.path))
      optionPaths = [_resolveHome(options.path)];
    else {
      optionPaths = [];
      for (const filepath of options.path)
        optionPaths.push(_resolveHome(filepath));
    }
  let lastError;
  const parsedAll = {};
  for (const path2 of optionPaths)
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
      DotenvModule.populate(parsedAll, parsed, options);
    } catch (e) {
      debug2 && _debug(`Failed to load ${path2} ${e.message}`), lastError = e;
    }
  let processEnv = process.env;
  return options && options.processEnv != null && (processEnv = options.processEnv), DotenvModule.populate(processEnv, parsedAll, options), lastError ? { parsed: parsedAll, error: lastError } : { parsed: parsedAll };
}
function config(options) {
  if (_dotenvKey(options).length === 0)
    return DotenvModule.configDotenv(options);
  const vaultPath = _vaultPath(options);
  return vaultPath ? DotenvModule._configVault(options) : (_warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`), DotenvModule.configDotenv(options));
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12), authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
    return aesgcm.setAuthTag(authTag), `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error) {
    const isRange = error instanceof RangeError, invalidKeyLength = error.message === "Invalid key length", decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      throw err.code = "INVALID_DOTENV_KEY", err;
    } else if (decryptionFailed) {
      const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      throw err.code = "DECRYPTION_FAILED", err;
    } else
      throw error;
  }
}
function populate(processEnv, parsed, options = {}) {
  const debug2 = !!(options && options.debug), override = !!(options && options.override);
  if (typeof parsed != "object") {
    const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    throw err.code = "OBJECT_REQUIRED", err;
  }
  for (const key of Object.keys(parsed))
    Object.prototype.hasOwnProperty.call(processEnv, key) ? (override === !0 && (processEnv[key] = parsed[key]), debug2 && _debug(override === !0 ? `"${key}" is already defined and WAS overwritten` : `"${key}" is already defined and was NOT overwritten`)) : processEnv[key] = parsed[key];
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
};
main$1.exports.configDotenv = DotenvModule.configDotenv;
main$1.exports._configVault = DotenvModule._configVault;
main$1.exports._parseVault = DotenvModule._parseVault;
main$1.exports.config = DotenvModule.config;
main$1.exports.decrypt = DotenvModule.decrypt;
var parse_1 = main$1.exports.parse = DotenvModule.parse;
main$1.exports.populate = DotenvModule.populate;
main$1.exports = DotenvModule;
var mainExports = main$1.exports, dotenv = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
function _interpolate(envValue, environment, config2) {
  const matches = envValue.match(/(.?\${*[\w]*(?::-[\w/]*)?}*)/g) || [];
  return matches.reduce(function(newEnv, match, index) {
    const parts = /(.?)\${*([\w]*(?::-[\w/]*)?)?}*/g.exec(match);
    if (!parts || parts.length === 0)
      return newEnv;
    const prefix = parts[1];
    let value, replacePart;
    if (prefix === "\\")
      replacePart = parts[0], value = replacePart.replace("\\$", "$");
    else {
      const keyParts = parts[2].split(":-"), key = keyParts[0];
      if (replacePart = parts[0].substring(prefix.length), value = Object.prototype.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || keyParts[1] || "", keyParts.length > 1 && value) {
        const replaceNested = matches[index + 1];
        matches[index + 1] = "", newEnv = newEnv.replace(replaceNested, "");
      }
      value = _interpolate(value, environment, config2);
    }
    return newEnv.replace(replacePart, value);
  }, envValue);
}
function expand(config2) {
  const environment = config2.ignoreProcessEnv ? {} : process.env;
  for (const configKey in config2.parsed) {
    const value = Object.prototype.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];
    config2.parsed[configKey] = _interpolate(value, environment, config2);
  }
  for (const processKey in config2.parsed)
    environment[processKey] = config2.parsed[processKey];
  return config2;
}
var expand_1 = expand;
function loadEnv(mode, envDir, prefixes = ["VITE_"]) {
  if (mode === "local")
    throw new Error(
      '"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.'
    );
  const env = {}, envFiles = [
    /** default file */
    ".env",
    /** local file */
    ".env.local",
    /** mode file */
    `.env.${mode}`,
    /** mode local file */
    `.env.${mode}.local`
  ], parsed = Object.fromEntries(
    envFiles.flatMap((file) => {
      const envPath = lookupFile(envDir, [file], {
        rootDir: envDir
      });
      return envPath ? Object.entries(parse_1(fs__default.default.readFileSync(envPath))) : [];
    })
  );
  parsed.NODE_ENV && process.env.VITE_USER_NODE_ENV === void 0 && (process.env.VITE_USER_NODE_ENV = parsed.NODE_ENV), parsed.BROWSER && process.env.BROWSER === void 0 && (process.env.BROWSER = parsed.BROWSER), parsed.BROWSER_ARGS && process.env.BROWSER_ARGS === void 0 && (process.env.BROWSER_ARGS = parsed.BROWSER_ARGS);
  try {
    expand_1({ parsed });
  } catch (e) {
    throw e.message.includes("split") ? new Error("dotenv-expand failed to expand env vars. Maybe you need to escape `$`?") : e;
  }
  for (const [key, value] of Object.entries(parsed))
    prefixes.some((prefix) => key.startsWith(prefix)) && (env[key] = value);
  for (const key in process.env)
    prefixes.some((prefix) => key.startsWith(prefix)) && (env[key] = process.env[key]);
  return env;
}
function lookupFile(dir, formats, options) {
  for (const format of formats) {
    const fullPath = path__default.default.join(dir, format);
    if (fs__default.default.existsSync(fullPath) && fs__default.default.statSync(fullPath).isFile())
      return fullPath;
  }
  const parentDir = path__default.default.dirname(dir);
  if (parentDir !== dir && (!options?.rootDir || parentDir.startsWith(options?.rootDir)))
    return lookupFile(parentDir, formats, options);
}
exports.commonjsGlobal = commonjsGlobal;
exports.debug = debug;
exports.dotenv = dotenv;
exports.getAugmentedNamespace = getAugmentedNamespace;
exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
exports.loadEnv = loadEnv;
exports.resolveRootDir = resolveRootDir;
//# sourceMappingURL=loadEnv.js.map
