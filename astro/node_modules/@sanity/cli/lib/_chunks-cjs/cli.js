"use strict";
var fs$p = require("node:fs"), os$6 = require("node:os"), path$t = require("node:path"), chalk$4 = require("chalk"), loadEnv = require("./loadEnv.js"), nodeMachineId = require("node-machine-id"), require$$0$4 = require("path"), require$$1$2 = require("module"), require$$0$5 = require("fs"), telemetry = require("@sanity/telemetry"), childProcess$2 = require("node:child_process"), fs$o = require("node:fs/promises"), util$b = require("node:util"), require$$0$6 = require("os"), require$$0$a = require("url"), require$$1$3 = require("get-it"), require$$2$1 = require("get-it/middleware"), require$$0$7 = require("constants"), require$$0$8 = require("stream"), require$$0$9 = require("util"), require$$5$1 = require("assert"), require$$3$1 = require("events"), require$$6$1 = require("http"), semver$2 = require("semver"), pkgDir = require("pkg-dir"), client$1 = require("@sanity/client"), require$$3$2 = require("crypto"), require$$0$b = require("child_process"), require$$0$c = require("fs/promises"), fs$q = require("@sanity/util/fs"), decompress = require("decompress"), validateNpmPackageName = require("validate-npm-package-name"), getCliConfig = require("./getCliConfig.js"), require$$0$d = require("buffer"), silverFleece = require("silver-fleece"), journeyConfig = require("./journeyConfig.js"), http$1 = require("node:http"), traverse = require("@babel/traverse"), require$$0$e = require("readline"), require$$0$f = require("tty");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _mergeNamespaces(n, m) {
  return m.forEach(function(e) {
    e && typeof e != "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: !0,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }), Object.freeze(n);
}
var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs$p), os__default = /* @__PURE__ */ _interopDefaultCompat(os$6), path__default = /* @__PURE__ */ _interopDefaultCompat(path$t), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk$4), require$$0__default = /* @__PURE__ */ _interopDefaultCompat(require$$0$4), require$$1__default = /* @__PURE__ */ _interopDefaultCompat(require$$1$2), require$$0__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$0$5), childProcess__default = /* @__PURE__ */ _interopDefaultCompat(childProcess$2), fs__default$1 = /* @__PURE__ */ _interopDefaultCompat(fs$o), util__default = /* @__PURE__ */ _interopDefaultCompat(util$b), require$$0__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$0$6), require$$0__default$6 = /* @__PURE__ */ _interopDefaultCompat(require$$0$a), require$$1__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$1$3), require$$2__default = /* @__PURE__ */ _interopDefaultCompat(require$$2$1), require$$0__default$3 = /* @__PURE__ */ _interopDefaultCompat(require$$0$7), require$$0__default$4 = /* @__PURE__ */ _interopDefaultCompat(require$$0$8), require$$0__default$5 = /* @__PURE__ */ _interopDefaultCompat(require$$0$9), require$$5__default = /* @__PURE__ */ _interopDefaultCompat(require$$5$1), require$$3__default = /* @__PURE__ */ _interopDefaultCompat(require$$3$1), require$$6__default = /* @__PURE__ */ _interopDefaultCompat(require$$6$1), semver__default = /* @__PURE__ */ _interopDefaultCompat(semver$2), pkgDir__default = /* @__PURE__ */ _interopDefaultCompat(pkgDir), require$$3__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$3$2), require$$0__default$7 = /* @__PURE__ */ _interopDefaultCompat(require$$0$b), require$$0__default$8 = /* @__PURE__ */ _interopDefaultCompat(require$$0$c), decompress__default = /* @__PURE__ */ _interopDefaultCompat(decompress), validateNpmPackageName__default = /* @__PURE__ */ _interopDefaultCompat(validateNpmPackageName), require$$0__default$9 = /* @__PURE__ */ _interopDefaultCompat(require$$0$d), http__default = /* @__PURE__ */ _interopDefaultCompat(http$1), traverse__default = /* @__PURE__ */ _interopDefaultCompat(traverse), require$$0__default$a = /* @__PURE__ */ _interopDefaultCompat(require$$0$e), require$$0__default$b = /* @__PURE__ */ _interopDefaultCompat(require$$0$f), resolveFrom$2 = { exports: {} };
const path$s = require$$0__default.default, Module = require$$1__default.default, fs$n = require$$0__default$1.default, resolveFrom = (fromDirectory, moduleId, silent) => {
  if (typeof fromDirectory != "string")
    throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
  if (typeof moduleId != "string")
    throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
  try {
    fromDirectory = fs$n.realpathSync(fromDirectory);
  } catch (error2) {
    if (error2.code === "ENOENT")
      fromDirectory = path$s.resolve(fromDirectory);
    else {
      if (silent)
        return;
      throw error2;
    }
  }
  const fromFile = path$s.join(fromDirectory, "noop.js"), resolveFileName = () => Module._resolveFilename(moduleId, {
    id: fromFile,
    filename: fromFile,
    paths: Module._nodeModulePaths(fromDirectory)
  });
  if (silent)
    try {
      return resolveFileName();
    } catch {
      return;
    }
  return resolveFileName();
};
resolveFrom$2.exports = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);
resolveFrom$2.exports.silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, !0);
var resolveFromExports = resolveFrom$2.exports, resolveFrom$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(resolveFromExports);
const CliCommand = telemetry.defineTrace({
  name: "CLI Command Executed",
  version: 1,
  description: "A CLI command was executed"
});
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module2, exports2) {
  (function() {
    var undefined$1, VERSION = "4.17.21", LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag2 = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrimStart = /^\s+/, reWhitespace = /\s/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], templateCounter = -1, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag2] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
    var deburredLetters = {
      // Latin-1 Supplement block.
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      // Latin Extended-A block.
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    }, htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = typeof loadEnv.commonjsGlobal == "object" && loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.Object === Object && loadEnv.commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root2 = freeGlobal || freeSelf || Function("return this")(), freeExports = exports2 && !exports2.nodeType && exports2, freeModule = freeExports && !0 && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        return types2 || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch {
      }
    }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array2, setter, iteratee, accumulator) {
      for (var index = -1, length = array2 == null ? 0 : array2.length; ++index < length; ) {
        var value = array2[index];
        setter(accumulator, value, iteratee(value), array2);
      }
      return accumulator;
    }
    function arrayEach(array2, iteratee) {
      for (var index = -1, length = array2 == null ? 0 : array2.length; ++index < length && iteratee(array2[index], index, array2) !== !1; )
        ;
      return array2;
    }
    function arrayEachRight(array2, iteratee) {
      for (var length = array2 == null ? 0 : array2.length; length-- && iteratee(array2[length], length, array2) !== !1; )
        ;
      return array2;
    }
    function arrayEvery(array2, predicate) {
      for (var index = -1, length = array2 == null ? 0 : array2.length; ++index < length; )
        if (!predicate(array2[index], index, array2))
          return !1;
      return !0;
    }
    function arrayFilter(array2, predicate) {
      for (var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array2[index];
        predicate(value, index, array2) && (result[resIndex++] = value);
      }
      return result;
    }
    function arrayIncludes(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      return !!length && baseIndexOf(array2, value, 0) > -1;
    }
    function arrayIncludesWith(array2, value, comparator) {
      for (var index = -1, length = array2 == null ? 0 : array2.length; ++index < length; )
        if (comparator(value, array2[index]))
          return !0;
      return !1;
    }
    function arrayMap(array2, iteratee) {
      for (var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length); ++index < length; )
        result[index] = iteratee(array2[index], index, array2);
      return result;
    }
    function arrayPush(array2, values) {
      for (var index = -1, length = values.length, offset = array2.length; ++index < length; )
        array2[offset + index] = values[index];
      return array2;
    }
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      for (initAccum && length && (accumulator = array2[++index]); ++index < length; )
        accumulator = iteratee(accumulator, array2[index], index, array2);
      return accumulator;
    }
    function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
      var length = array2 == null ? 0 : array2.length;
      for (initAccum && length && (accumulator = array2[--length]); length--; )
        accumulator = iteratee(accumulator, array2[length], length, array2);
      return accumulator;
    }
    function arraySome(array2, predicate) {
      for (var index = -1, length = array2 == null ? 0 : array2.length; ++index < length; )
        if (predicate(array2[index], index, array2))
          return !0;
      return !1;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      return eachFunc(collection, function(value, key2, collection2) {
        if (predicate(value, key2, collection2))
          return result = key2, !1;
      }), result;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      for (var length = array2.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; )
        if (predicate(array2[index], index, array2))
          return index;
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array2, value, fromIndex, comparator) {
      for (var index = fromIndex - 1, length = array2.length; ++index < length; )
        if (comparator(array2[index], value))
          return index;
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array2, iteratee) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseSum(array2, iteratee) / length : NAN;
    }
    function baseProperty(key2) {
      return function(object) {
        return object == null ? undefined$1 : object[key2];
      };
    }
    function basePropertyOf(object) {
      return function(key2) {
        return object == null ? undefined$1 : object[key2];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      return eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection2);
      }), accumulator;
    }
    function baseSortBy(array2, comparer) {
      var length = array2.length;
      for (array2.sort(comparer); length--; )
        array2[length] = array2[length].value;
      return array2;
    }
    function baseSum(array2, iteratee) {
      for (var result, index = -1, length = array2.length; ++index < length; ) {
        var current = iteratee(array2[index]);
        current !== undefined$1 && (result = result === undefined$1 ? current : result + current);
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      for (var index = -1, result = Array(n); ++index < n; )
        result[index] = iteratee(index);
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key2) {
        return [key2, object[key2]];
      });
    }
    function baseTrim(string) {
      return string && string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "");
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key2) {
        return object[key2];
      });
    }
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
        ;
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
        ;
      return index;
    }
    function countHolders(array2, placeholder) {
      for (var length = array2.length, result = 0; length--; )
        array2[length] === placeholder && ++result;
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key2) {
      return object == null ? undefined$1 : object[key2];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator2) {
      for (var data, result = []; !(data = iterator2.next()).done; )
        result.push(data.value);
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      return map2.forEach(function(value, key2) {
        result[++index] = [key2, value];
      }), result;
    }
    function overArg2(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array2, placeholder) {
      for (var index = -1, length = array2.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array2[index];
        (value === placeholder || value === PLACEHOLDER) && (array2[index] = PLACEHOLDER, result[resIndex++] = index);
      }
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      return set2.forEach(function(value) {
        result[++index] = value;
      }), result;
    }
    function setToPairs(set2) {
      var index = -1, result = Array(set2.size);
      return set2.forEach(function(value) {
        result[++index] = [value, value];
      }), result;
    }
    function strictIndexOf(array2, value, fromIndex) {
      for (var index = fromIndex - 1, length = array2.length; ++index < length; )
        if (array2[index] === value)
          return index;
      return -1;
    }
    function strictLastIndexOf(array2, value, fromIndex) {
      for (var index = fromIndex + 1; index--; )
        if (array2[index] === value)
          return index;
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      for (var index = string.length; index-- && reWhitespace.test(string.charAt(index)); )
        ;
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); )
        ++result;
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
      var Array2 = context.Array, Date3 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError, arrayProto = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype, coreJsData = context["__core-js_shared__"], funcToString2 = funcProto2.toString, hasOwnProperty2 = objectProto2.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }(), nativeObjectToString = objectProto2.toString, objectCtorString2 = funcToString2.call(Object2), oldDash = root2._, reIsNative = RegExp2(
        "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1, defineProperty2 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          return func({}, "", {}), func;
        } catch {
        }
      }(), ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date3 && Date3.now !== root2.Date.now && Date3.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout, nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg2(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date3.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create"), metaMap = WeakMap2 && new WeakMap2(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2), symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper)
            return value;
          if (hasOwnProperty2.call(value, "__wrapped__"))
            return wrapperClone(value);
        }
        return new LodashWrapper(value);
      }
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject3(proto))
            return {};
          if (objectCreate)
            return objectCreate(proto);
          object.prototype = proto;
          var result2 = new object();
          return object.prototype = undefined$1, result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: lodash2
        }
      }, lodash2.prototype = baseLodash.prototype, lodash2.prototype.constructor = lodash2, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        return result2.__actions__ = copyArray(this.__actions__), result2.__dir__ = this.__dir__, result2.__filtered__ = this.__filtered__, result2.__iteratees__ = copyArray(this.__iteratees__), result2.__takeCount__ = this.__takeCount__, result2.__views__ = copyArray(this.__views__), result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1, result2.__filtered__ = !0;
        } else
          result2 = this.clone(), result2.__dir__ *= -1;
        return result2;
      }
      function lazyValue() {
        var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end2 = view.end, length = end2 - start, index = isRight ? end2 : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length)
          return baseWrapperValue(array2, this.__actions__);
        var result2 = [];
        outer:
          for (; length-- && resIndex < takeCount; ) {
            index += dir;
            for (var iterIndex = -1, value = array2[index]; ++iterIndex < iterLength; ) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG)
                value = computed;
              else if (!computed) {
                if (type2 == LAZY_FILTER_FLAG)
                  continue outer;
                break outer;
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
      }
      function hashDelete(key2) {
        var result2 = this.has(key2) && delete this.__data__[key2];
        return this.size -= result2 ? 1 : 0, result2;
      }
      function hashGet(key2) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key2];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key2) ? data[key2] : undefined$1;
      }
      function hashHas(key2) {
        var data = this.__data__;
        return nativeCreate ? data[key2] !== undefined$1 : hasOwnProperty2.call(data, key2);
      }
      function hashSet(key2, value) {
        var data = this.__data__;
        return this.size += this.has(key2) ? 0 : 1, data[key2] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value, this;
      }
      Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [], this.size = 0;
      }
      function listCacheDelete(key2) {
        var data = this.__data__, index = assocIndexOf(data, key2);
        if (index < 0)
          return !1;
        var lastIndex = data.length - 1;
        return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0;
      }
      function listCacheGet(key2) {
        var data = this.__data__, index = assocIndexOf(data, key2);
        return index < 0 ? undefined$1 : data[index][1];
      }
      function listCacheHas(key2) {
        return assocIndexOf(this.__data__, key2) > -1;
      }
      function listCacheSet(key2, value) {
        var data = this.__data__, index = assocIndexOf(data, key2);
        return index < 0 ? (++this.size, data.push([key2, value])) : data[index][1] = value, this;
      }
      ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0, this.__data__ = {
          hash: new Hash(),
          map: new (Map2 || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key2) {
        var result2 = getMapData(this, key2).delete(key2);
        return this.size -= result2 ? 1 : 0, result2;
      }
      function mapCacheGet(key2) {
        return getMapData(this, key2).get(key2);
      }
      function mapCacheHas(key2) {
        return getMapData(this, key2).has(key2);
      }
      function mapCacheSet(key2, value) {
        var data = getMapData(this, key2), size2 = data.size;
        return data.set(key2, value), this.size += data.size == size2 ? 0 : 1, this;
      }
      MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        for (this.__data__ = new MapCache(); ++index < length; )
          this.add(values2[index]);
      }
      function setCacheAdd(value) {
        return this.__data__.set(value, HASH_UNDEFINED), this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache(), this.size = 0;
      }
      function stackDelete(key2) {
        var data = this.__data__, result2 = data.delete(key2);
        return this.size = data.size, result2;
      }
      function stackGet(key2) {
        return this.__data__.get(key2);
      }
      function stackHas(key2) {
        return this.__data__.has(key2);
      }
      function stackSet(key2, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs2 = data.__data__;
          if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1)
            return pairs2.push([key2, value]), this.size = ++data.size, this;
          data = this.__data__ = new MapCache(pairs2);
        }
        return data.set(key2, value), this.size = data.size, this;
      }
      Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key2 in value)
          (inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
          isIndex(key2, length))) && result2.push(key2);
        return result2;
      }
      function arraySample(array2) {
        var length = array2.length;
        return length ? array2[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array2, n) {
        return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
      }
      function arrayShuffle(array2) {
        return shuffleSelf(copyArray(array2));
      }
      function assignMergeValue(object, key2, value) {
        (value !== undefined$1 && !eq(object[key2], value) || value === undefined$1 && !(key2 in object)) && baseAssignValue(object, key2, value);
      }
      function assignValue(object, key2, value) {
        var objValue = object[key2];
        (!(hasOwnProperty2.call(object, key2) && eq(objValue, value)) || value === undefined$1 && !(key2 in object)) && baseAssignValue(object, key2, value);
      }
      function assocIndexOf(array2, key2) {
        for (var length = array2.length; length--; )
          if (eq(array2[length][0], key2))
            return length;
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        return baseEach(collection, function(value, key2, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        }), accumulator;
      }
      function baseAssign(object, source2) {
        return object && copyObject(source2, keys(source2), object);
      }
      function baseAssignIn(object, source2) {
        return object && copyObject(source2, keysIn(source2), object);
      }
      function baseAssignValue(object, key2, value) {
        key2 == "__proto__" && defineProperty2 ? defineProperty2(object, key2, {
          configurable: !0,
          enumerable: !0,
          value,
          writable: !0
        }) : object[key2] = value;
      }
      function baseAt(object, paths) {
        for (var index = -1, length = paths.length, result2 = Array2(length), skip2 = object == null; ++index < length; )
          result2[index] = skip2 ? undefined$1 : get2(object, paths[index]);
        return result2;
      }
      function baseClamp(number2, lower, upper) {
        return number2 === number2 && (upper !== undefined$1 && (number2 = number2 <= upper ? number2 : upper), lower !== undefined$1 && (number2 = number2 >= lower ? number2 : lower)), number2;
      }
      function baseClone(value, bitmask, customizer, key2, object, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer && (result2 = object ? customizer(value, key2, object, stack2) : customizer(value)), result2 !== undefined$1)
          return result2;
        if (!isObject3(value))
          return value;
        var isArr = isArray2(value);
        if (isArr) {
          if (result2 = initCloneArray(value), !isDeep)
            return copyArray(value, result2);
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value))
            return cloneBuffer(value, isDeep);
          if (tag == objectTag2 || tag == argsTag || isFunc && !object) {
            if (result2 = isFlat || isFunc ? {} : initCloneObject(value), !isDeep)
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
          } else {
            if (!cloneableTags[tag])
              return object ? value : {};
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack());
        var stacked = stack2.get(value);
        if (stacked)
          return stacked;
        stack2.set(value, result2), isSet(value) ? value.forEach(function(subValue) {
          result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        }) : isMap(value) && value.forEach(function(subValue, key3) {
          result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
        });
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? undefined$1 : keysFunc(value);
        return arrayEach(props || value, function(subValue, key3) {
          props && (key3 = subValue, subValue = value[key3]), assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
        }), result2;
      }
      function baseConforms(source2) {
        var props = keys(source2);
        return function(object) {
          return baseConformsTo(object, source2, props);
        };
      }
      function baseConformsTo(object, source2, props) {
        var length = props.length;
        if (object == null)
          return !length;
        for (object = Object2(object); length--; ) {
          var key2 = props[length], predicate = source2[key2], value = object[key2];
          if (value === undefined$1 && !(key2 in object) || !predicate(value))
            return !1;
        }
        return !0;
      }
      function baseDelay(func, wait2, args) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait2);
      }
      function baseDifference(array2, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = !0, length = array2.length, result2 = [], valuesLength = values2.length;
        if (!length)
          return result2;
        iteratee2 && (values2 = arrayMap(values2, baseUnary(iteratee2))), comparator ? (includes2 = arrayIncludesWith, isCommon = !1) : values2.length >= LARGE_ARRAY_SIZE && (includes2 = cacheHas, isCommon = !1, values2 = new SetCache(values2));
        outer:
          for (; ++index < length; ) {
            var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
            if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
              for (var valuesIndex = valuesLength; valuesIndex--; )
                if (values2[valuesIndex] === computed)
                  continue outer;
              result2.push(value);
            } else includes2(values2, computed, comparator) || result2.push(value);
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0);
      function baseEvery(collection, predicate) {
        var result2 = !0;
        return baseEach(collection, function(value, index, collection2) {
          return result2 = !!predicate(value, index, collection2), result2;
        }), result2;
      }
      function baseExtremum(array2, iteratee2, comparator) {
        for (var index = -1, length = array2.length; ++index < length; ) {
          var value = array2[index], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed)))
            var computed = current, result2 = value;
        }
        return result2;
      }
      function baseFill(array2, value, start, end2) {
        var length = array2.length;
        for (start = toInteger(start), start < 0 && (start = -start > length ? 0 : length + start), end2 = end2 === undefined$1 || end2 > length ? length : toInteger(end2), end2 < 0 && (end2 += length), end2 = start > end2 ? 0 : toLength(end2); start < end2; )
          array2[start++] = value;
        return array2;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        return baseEach(collection, function(value, index, collection2) {
          predicate(value, index, collection2) && result2.push(value);
        }), result2;
      }
      function baseFlatten(array2, depth2, predicate, isStrict, result2) {
        var index = -1, length = array2.length;
        for (predicate || (predicate = isFlattenable), result2 || (result2 = []); ++index < length; ) {
          var value = array2[index];
          depth2 > 0 && predicate(value) ? depth2 > 1 ? baseFlatten(value, depth2 - 1, predicate, isStrict, result2) : arrayPush(result2, value) : isStrict || (result2[result2.length] = value);
        }
        return result2;
      }
      var baseFor = createBaseFor(), baseForRight = createBaseFor(!0);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key2) {
          return isFunction2(object[key2]);
        });
      }
      function baseGet(object, path2) {
        path2 = castPath(path2, object);
        for (var index = 0, length = path2.length; object != null && index < length; )
          object = object[toKey(path2[index++])];
        return index && index == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        return value == null ? value === undefined$1 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key2) {
        return object != null && hasOwnProperty2.call(object, key2);
      }
      function baseHasIn(object, key2) {
        return object != null && key2 in Object2(object);
      }
      function baseInRange(number2, start, end2) {
        return number2 >= nativeMin(start, end2) && number2 < nativeMax(start, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        for (var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = 1 / 0, result2 = []; othIndex--; ) {
          var array2 = arrays[othIndex];
          othIndex && iteratee2 && (array2 = arrayMap(array2, baseUnary(iteratee2))), maxLength = nativeMin(array2.length, maxLength), caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined$1;
        }
        array2 = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          for (; ++index < length && result2.length < maxLength; ) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (value = comparator || value !== 0 ? value : 0, !(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              for (othIndex = othLength; --othIndex; ) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator)))
                  continue outer;
              }
              seen && seen.push(computed), result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        return baseForOwn(object, function(value, key2, object2) {
          setter(accumulator, iteratee2(value), key2, object2);
        }), accumulator;
      }
      function baseInvoke(object, path2, args) {
        path2 = castPath(path2, object), object = parent(object, path2);
        var func = object == null ? object : object[toKey(last2(path2))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        return value === other ? !0 : value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag2 : objTag, othTag = othTag == argsTag ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other))
            return !1;
          objIsArr = !0, objIsObj = !1;
        }
        if (isSameTag && !objIsObj)
          return stack2 || (stack2 = new Stack()), objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            return stack2 || (stack2 = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        return isSameTag ? (stack2 || (stack2 = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack2)) : !1;
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source2, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null)
          return !length;
        for (object = Object2(object); index--; ) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object))
            return !1;
        }
        for (; ++index < length; ) {
          data = matchData[index];
          var key2 = data[0], objValue = object[key2], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key2 in object))
              return !1;
          } else {
            var stack2 = new Stack();
            if (customizer)
              var result2 = customizer(objValue, srcValue, key2, object, source2, stack2);
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2))
              return !1;
          }
        }
        return !0;
      }
      function baseIsNative(value) {
        if (!isObject3(value) || isMasked(value))
          return !1;
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        return typeof value == "function" ? value : value == null ? identity2 : typeof value == "object" ? isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object))
          return nativeKeys(object);
        var result2 = [];
        for (var key2 in Object2(object))
          hasOwnProperty2.call(object, key2) && key2 != "constructor" && result2.push(key2);
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject3(object))
          return nativeKeysIn(object);
        var isProto = isPrototype(object), result2 = [];
        for (var key2 in object)
          key2 == "constructor" && (isProto || !hasOwnProperty2.call(object, key2)) || result2.push(key2);
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        return baseEach(collection, function(value, key2, collection2) {
          result2[++index] = iteratee2(value, key2, collection2);
        }), result2;
      }
      function baseMatches(source2) {
        var matchData = getMatchData(source2);
        return matchData.length == 1 && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
          return object === source2 || baseIsMatch(object, source2, matchData);
        };
      }
      function baseMatchesProperty(path2, srcValue) {
        return isKey(path2) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path2), srcValue) : function(object) {
          var objValue = get2(object, path2);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source2, srcIndex, customizer, stack2) {
        object !== source2 && baseFor(source2, function(srcValue, key2) {
          if (stack2 || (stack2 = new Stack()), isObject3(srcValue))
            baseMergeDeep(object, source2, key2, srcIndex, baseMerge, customizer, stack2);
          else {
            var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source2, stack2) : undefined$1;
            newValue === undefined$1 && (newValue = srcValue), assignMergeValue(object, key2, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source2, key2, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key2), srcValue = safeGet(source2, key2), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key2, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source2, stack2) : undefined$1, isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue, isArr || isBuff || isTyped ? isArray2(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject3(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject3(objValue) || isFunction2(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
        }
        isCommon && (stack2.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack2), stack2.delete(srcValue)), assignMergeValue(object, key2, newValue);
      }
      function baseNth(array2, n) {
        var length = array2.length;
        if (length)
          return n += n < 0 ? length : 0, isIndex(n, length) ? array2[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        iteratees.length ? iteratees = arrayMap(iteratees, function(iteratee2) {
          return isArray2(iteratee2) ? function(value) {
            return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
          } : iteratee2;
        }) : iteratees = [identity2];
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key2, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index, value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path2) {
          return hasIn(object, path2);
        });
      }
      function basePickBy(object, paths, predicate) {
        for (var index = -1, length = paths.length, result2 = {}; ++index < length; ) {
          var path2 = paths[index], value = baseGet(object, path2);
          predicate(value, path2) && baseSet(result2, castPath(path2, object), value);
        }
        return result2;
      }
      function basePropertyDeep(path2) {
        return function(object) {
          return baseGet(object, path2);
        };
      }
      function basePullAll(array2, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
        for (array2 === values2 && (values2 = copyArray(values2)), iteratee2 && (seen = arrayMap(array2, baseUnary(iteratee2))); ++index < length; )
          for (var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value; (fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1; )
            seen !== array2 && splice.call(seen, fromIndex, 1), splice.call(array2, fromIndex, 1);
        return array2;
      }
      function basePullAt(array2, indexes) {
        for (var length = array2 ? indexes.length : 0, lastIndex = length - 1; length--; ) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            isIndex(index) ? splice.call(array2, index, 1) : baseUnset(array2, index);
          }
        }
        return array2;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end2, step, fromRight) {
        for (var index = -1, length = nativeMax(nativeCeil((end2 - start) / (step || 1)), 0), result2 = Array2(length); length--; )
          result2[fromRight ? length : ++index] = start, start += step;
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER)
          return result2;
        do
          n % 2 && (result2 += string), n = nativeFloor(n / 2), n && (string += string);
        while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array2 = values(collection);
        return shuffleSelf(array2, baseClamp(n, 0, array2.length));
      }
      function baseSet(object, path2, value, customizer) {
        if (!isObject3(object))
          return object;
        path2 = castPath(path2, object);
        for (var index = -1, length = path2.length, lastIndex = length - 1, nested = object; nested != null && ++index < length; ) {
          var key2 = toKey(path2[index]), newValue = value;
          if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype")
            return object;
          if (index != lastIndex) {
            var objValue = nested[key2];
            newValue = customizer ? customizer(objValue, key2, nested) : undefined$1, newValue === undefined$1 && (newValue = isObject3(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {});
          }
          assignValue(nested, key2, newValue), nested = nested[key2];
        }
        return object;
      }
      var baseSetData = metaMap ? function(func, data) {
        return metaMap.set(func, data), func;
      } : identity2, baseSetToString = defineProperty2 ? function(func, string) {
        return defineProperty2(func, "toString", {
          configurable: !0,
          enumerable: !1,
          value: constant(string),
          writable: !0
        });
      } : identity2;
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array2, start, end2) {
        var index = -1, length = array2.length;
        start < 0 && (start = -start > length ? 0 : length + start), end2 = end2 > length ? length : end2, end2 < 0 && (end2 += length), length = start > end2 ? 0 : end2 - start >>> 0, start >>>= 0;
        for (var result2 = Array2(length); ++index < length; )
          result2[index] = array2[index + start];
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        return baseEach(collection, function(value, index, collection2) {
          return result2 = predicate(value, index, collection2), !result2;
        }), !!result2;
      }
      function baseSortedIndex(array2, value, retHighest) {
        var low = 0, high = array2 == null ? low : array2.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          for (; low < high; ) {
            var mid = low + high >>> 1, computed = array2[mid];
            computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
          }
          return high;
        }
        return baseSortedIndexBy(array2, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
        var low = 0, high = array2 == null ? 0 : array2.length;
        if (high === 0)
          return 0;
        value = iteratee2(value);
        for (var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1; low < high; ) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN)
            var setLow = retHighest || othIsReflexive;
          else valIsUndefined ? setLow = othIsReflexive && (retHighest || othIsDefined) : valIsNull ? setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : othIsNull || othIsSymbol ? setLow = !1 : setLow = retHighest ? computed <= value : computed < value;
          setLow ? low = mid + 1 : high = mid;
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array2, iteratee2) {
        for (var index = -1, length = array2.length, resIndex = 0, result2 = []; ++index < length; ) {
          var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        return typeof value == "number" ? value : isSymbol(value) ? NAN : +value;
      }
      function baseToString(value) {
        if (typeof value == "string")
          return value;
        if (isArray2(value))
          return arrayMap(value, baseToString) + "";
        if (isSymbol(value))
          return symbolToString ? symbolToString.call(value) : "";
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = !0, result2 = [], seen = result2;
        if (comparator)
          isCommon = !1, includes2 = arrayIncludesWith;
        else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array2);
          if (set3)
            return setToArray(set3);
          isCommon = !1, includes2 = cacheHas, seen = new SetCache();
        } else
          seen = iteratee2 ? [] : result2;
        outer:
          for (; ++index < length; ) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
              for (var seenIndex = seen.length; seenIndex--; )
                if (seen[seenIndex] === computed)
                  continue outer;
              iteratee2 && seen.push(computed), result2.push(value);
            } else includes2(seen, computed, comparator) || (seen !== result2 && seen.push(computed), result2.push(value));
          }
        return result2;
      }
      function baseUnset(object, path2) {
        return path2 = castPath(path2, object), object = parent(object, path2), object == null || delete object[toKey(last2(path2))];
      }
      function baseUpdate(object, path2, updater, customizer) {
        return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
      }
      function baseWhile(array2, predicate, isDrop, fromRight) {
        for (var length = array2.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2); )
          ;
        return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        return result2 instanceof LazyWrapper && (result2 = result2.value()), arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2)
          return length ? baseUniq(arrays[0]) : [];
        for (var index = -1, result2 = Array2(length); ++index < length; )
          for (var array2 = arrays[index], othIndex = -1; ++othIndex < length; )
            othIndex != index && (result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator));
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        for (var index = -1, length = props.length, valsLength = values2.length, result2 = {}; ++index < length; ) {
          var value = index < valsLength ? values2[index] : undefined$1;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        return isArray2(value) ? value : isKey(value, object) ? [value] : stringToPath(toString8(value));
      }
      var castRest = baseRest;
      function castSlice(array2, start, end2) {
        var length = array2.length;
        return end2 = end2 === undefined$1 ? length : end2, !start && end2 >= length ? array2 : baseSlice(array2, start, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep)
          return buffer2.slice();
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        return buffer2.copy(result2), result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        return new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer)), result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp2) {
        var result2 = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
        return result2.lastIndex = regexp2.lastIndex, result2;
      }
      function cloneSymbol(symbol2) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol2)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)
            return 1;
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)
            return -1;
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength)
              return result2;
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; )
          result2[leftIndex] = partials[leftIndex];
        for (; ++argsIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result2[holders[argsIndex]] = args[argsIndex]);
        for (; rangeLength--; )
          result2[leftIndex++] = args[argsIndex++];
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; )
          result2[argsIndex] = args[argsIndex];
        for (var offset = argsIndex; ++rightIndex < rightLength; )
          result2[offset + rightIndex] = partials[rightIndex];
        for (; ++holdersIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result2[offset + holders[holdersIndex]] = args[argsIndex++]);
        return result2;
      }
      function copyArray(source2, array2) {
        var index = -1, length = source2.length;
        for (array2 || (array2 = Array2(length)); ++index < length; )
          array2[index] = source2[index];
        return array2;
      }
      function copyObject(source2, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        for (var index = -1, length = props.length; ++index < length; ) {
          var key2 = props[index], newValue = customizer ? customizer(object[key2], source2[key2], key2, object, source2) : undefined$1;
          newValue === undefined$1 && (newValue = source2[key2]), isNew ? baseAssignValue(object, key2, newValue) : assignValue(object, key2, newValue);
        }
        return object;
      }
      function copySymbols(source2, object) {
        return copyObject(source2, getSymbols(source2), object);
      }
      function copySymbolsIn(source2, object) {
        return copyObject(source2, getSymbolsIn(source2), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          for (customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined$1 : customizer, length = 1), object = Object2(object); ++index < length; ) {
            var source2 = sources[index];
            source2 && assigner(object, source2, index, customizer);
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null)
            return collection;
          if (!isArrayLike2(collection))
            return eachFunc(collection, iteratee2);
          for (var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection); (fromRight ? index-- : ++index < length) && iteratee2(iterable[index], index, iterable) !== !1; )
            ;
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          for (var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length; length--; ) {
            var key2 = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key2], key2, iterable) === !1)
              break;
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString8(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject3(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          for (var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper); index--; )
            args[index] = arguments[index];
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          if (length -= holders.length, length < arity)
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          var fn2 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection), predicate = function(key2) {
              return iteratee2(iterable[key2], key2, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          for (fromRight && funcs.reverse(); index--; ) {
            var func = funcs[index];
            if (typeof func != "function")
              throw new TypeError2(FUNC_ERROR_TEXT);
            if (prereq && !wrapper && getFuncName(func) == "wrapper")
              var wrapper = new LodashWrapper([], !0);
          }
          for (index = wrapper ? index : length; ++index < length; ) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1 ? wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value))
              return wrapper.plant(value).value();
            for (var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value; ++index2 < length; )
              result2 = funcs[index2].call(this, result2);
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          for (var length = arguments.length, args = Array2(length), index = length; index--; )
            args[index] = arguments[index];
          if (isCurried)
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), isAry && ary2 < length && (args.length = ary2), this && this !== root2 && this instanceof wrapper && (fn2 = Ctor || createCtor(fn2)), fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1)
            return defaultValue;
          if (value !== undefined$1 && (result2 = value), other !== undefined$1) {
            if (result2 === undefined$1)
              return other;
            typeof value == "string" || typeof other == "string" ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2)
          return charsLength ? baseRepeat(chars, length) : chars;
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root2 && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; )
            args[leftIndex] = partials[leftIndex];
          for (; argsLength--; )
            args[leftIndex++] = arguments[++argsIndex];
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end2, step) {
          return step && typeof step != "number" && isIterateeCall(start, end2, step) && (end2 = step = undefined$1), start = toFinite(start), end2 === undefined$1 ? (end2 = start, start = 0) : end2 = toFinite(end2), step = step === undefined$1 ? start < end2 ? 1 : -1 : toFinite(step), baseRange(start, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          return typeof value == "string" && typeof other == "string" || (value = toNumber(value), other = toNumber(other)), operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG), bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ], result2 = wrapFunc.apply(undefined$1, newData);
        return isLaziable(func) && setData(result2, newData), result2.placeholder = placeholder, setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          if (number2 = toNumber(number2), precision = precision == null ? 0 : nativeMin(toInteger(precision), 292), precision && nativeIsFinite(number2)) {
            var pair = (toString8(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            return pair = (toString8(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet = Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY ? function(values2) {
        return new Set2(values2);
      } : noop2;
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        var length = partials ? partials.length : 0;
        if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined$1), ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0), arity = arity === undefined$1 ? arity : toInteger(arity), length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func), newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)), !bitmask || bitmask == WRAP_BIND_FLAG)
          var result2 = createBind(func, bitmask, thisArg);
        else bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? result2 = createCurry(func, bitmask, arity) : (bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length ? result2 = createPartial(func, bitmask, thisArg, partials) : result2 = createHybrid.apply(undefined$1, newData);
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key2, object) {
        return objValue === undefined$1 || eq(objValue, objectProto2[key2]) && !hasOwnProperty2.call(object, key2) ? srcValue : objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key2, object, source2, stack2) {
        return isObject3(objValue) && isObject3(srcValue) && (stack2.set(srcValue, objValue), baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2), stack2.delete(srcValue)), objValue;
      }
      function customOmitClone(value) {
        return isPlainObject3(value) ? undefined$1 : value;
      }
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength))
          return !1;
        var arrStacked = stack2.get(array2), othStacked = stack2.get(other);
        if (arrStacked && othStacked)
          return arrStacked == other && othStacked == array2;
        var index = -1, result2 = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        for (stack2.set(array2, other), stack2.set(other, array2); ++index < arrLength; ) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer)
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack2) : customizer(arrValue, othValue, index, array2, other, stack2);
          if (compared !== undefined$1) {
            if (compared)
              continue;
            result2 = !1;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2)))
                return seen.push(othIndex);
            })) {
              result2 = !1;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = !1;
            break;
          }
        }
        return stack2.delete(array2), stack2.delete(other), result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)
              return !1;
            object = object.buffer, other = other.buffer;
          case arrayBufferTag:
            return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other)));
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            if (convert || (convert = setToArray), object.size != other.size && !isPartial)
              return !1;
            var stacked = stack2.get(object);
            if (stacked)
              return stacked == other;
            bitmask |= COMPARE_UNORDERED_FLAG, stack2.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            return stack2.delete(object), result2;
          case symbolTag:
            if (symbolValueOf)
              return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
        return !1;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial)
          return !1;
        for (var index = objLength; index--; ) {
          var key2 = objProps[index];
          if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2)))
            return !1;
        }
        var objStacked = stack2.get(object), othStacked = stack2.get(other);
        if (objStacked && othStacked)
          return objStacked == other && othStacked == object;
        var result2 = !0;
        stack2.set(object, other), stack2.set(other, object);
        for (var skipCtor = isPartial; ++index < objLength; ) {
          key2 = objProps[index];
          var objValue = object[key2], othValue = other[key2];
          if (customizer)
            var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = !1;
            break;
          }
          skipCtor || (skipCtor = key2 == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor) && (result2 = !1);
        }
        return stack2.delete(object), stack2.delete(other), result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = metaMap ? function(func) {
        return metaMap.get(func);
      } : noop2;
      function getFuncName(func) {
        for (var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array2.length : 0; length--; ) {
          var data = array2[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func)
            return data.name;
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        return result2 = result2 === iteratee ? baseIteratee : result2, arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key2) {
        var data = map3.__data__;
        return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        for (var result2 = keys(object), length = result2.length; length--; ) {
          var key2 = result2[length], value = object[key2];
          result2[length] = [key2, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key2) {
        var value = getValue(object, key2);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = !0;
        } catch {
        }
        var result2 = nativeObjectToString.call(value);
        return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result2;
      }
      var getSymbols = nativeGetSymbols ? function(object) {
        return object == null ? [] : (object = Object2(object), arrayFilter(nativeGetSymbols(object), function(symbol2) {
          return propertyIsEnumerable.call(object, symbol2);
        }));
      } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object) {
        for (var result2 = []; object; )
          arrayPush(result2, getSymbols(object)), object = getPrototype2(object);
        return result2;
      } : stubArray, getTag = baseGetTag;
      (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) && (getTag = function(value) {
        var result2 = baseGetTag(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString)
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        return result2;
      });
      function getView(start, end2, transforms) {
        for (var index = -1, length = transforms.length; ++index < length; ) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end2 -= size2;
              break;
            case "take":
              end2 = nativeMin(end2, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end2 - size2);
              break;
          }
        }
        return { start, end: end2 };
      }
      function getWrapDetails(source2) {
        var match3 = source2.match(reWrapDetails);
        return match3 ? match3[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path2, hasFunc) {
        path2 = castPath(path2, object);
        for (var index = -1, length = path2.length, result2 = !1; ++index < length; ) {
          var key2 = toKey(path2[index]);
          if (!(result2 = object != null && hasFunc(object, key2)))
            break;
          object = object[key2];
        }
        return result2 || ++index != length ? result2 : (length = object == null ? 0 : object.length, !!length && isLength(length) && isIndex(key2, length) && (isArray2(object) || isArguments(object)));
      }
      function initCloneArray(array2) {
        var length = array2.length, result2 = new array2.constructor(length);
        return length && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index") && (result2.index = array2.index, result2.input = array2.input), result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype2(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source2, details) {
        var length = details.length;
        if (!length)
          return source2;
        var lastIndex = length - 1;
        return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), source2.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type2 = typeof value;
        return length = length ?? MAX_SAFE_INTEGER, !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      function isIterateeCall(value, index, object) {
        if (!isObject3(object))
          return !1;
        var type2 = typeof index;
        return (type2 == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type2 == "string" && index in object) ? eq(object[index], value) : !1;
      }
      function isKey(value, object) {
        if (isArray2(value))
          return !1;
        var type2 = typeof value;
        return type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype))
          return !1;
        if (func === other)
          return !0;
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject3(value);
      }
      function matchesStrictComparable(key2, srcValue) {
        return function(object) {
          return object == null ? !1 : object[key2] === srcValue && (srcValue !== undefined$1 || key2 in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key2) {
          return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key2;
        }), cache = result2.cache;
        return result2;
      }
      function mergeData(data, source2) {
        var bitmask = data[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG), isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo))
          return data;
        srcBitmask & WRAP_BIND_FLAG && (data[2] = source2[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
        var value = source2[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source2[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source2[4];
        }
        return value = source2[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source2[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source2[6]), value = source2[7], value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = data[8] == null ? source2[8] : nativeMin(data[8], source2[8])), data[9] == null && (data[9] = source2[9]), data[0] = source2[0], data[1] = newBitmask, data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null)
          for (var key2 in Object2(object))
            result2.push(key2);
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform3) {
        return start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0), function() {
          for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length); ++index < length; )
            array2[index] = args[start + index];
          index = -1;
          for (var otherArgs = Array2(start + 1); ++index < start; )
            otherArgs[index] = args[index];
          return otherArgs[start] = transform3(array2), apply(func, this, otherArgs);
        };
      }
      function parent(object, path2) {
        return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
      }
      function reorder(array2, indexes) {
        for (var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2); length--; ) {
          var index = indexes[length];
          array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array2;
      }
      function safeGet(object, key2) {
        if (!(key2 === "constructor" && typeof object[key2] == "function") && key2 != "__proto__")
          return object[key2];
      }
      var setData = shortOut(baseSetData), setTimeout2 = ctxSetTimeout || function(func, wait2) {
        return root2.setTimeout(func, wait2);
      }, setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source2 = reference + "";
        return setToString(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
      }
      function shortOut(func) {
        var count2 = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          if (lastCalled = stamp, remaining > 0) {
            if (++count2 >= HOT_COUNT)
              return arguments[0];
          } else
            count2 = 0;
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array2, size2) {
        var index = -1, length = array2.length, lastIndex = length - 1;
        for (size2 = size2 === undefined$1 ? length : size2; ++index < size2; ) {
          var rand = baseRandom(index, lastIndex), value = array2[rand];
          array2[rand] = array2[index], array2[index] = value;
        }
        return array2.length = size2, array2;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        return string.charCodeAt(0) === 46 && result2.push(""), string.replace(rePropName, function(match3, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match3);
        }), result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value))
          return value;
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch {
          }
          try {
            return func + "";
          } catch {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        return arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
        }), details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper)
          return wrapper.clone();
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        return result2.__actions__ = copyArray(wrapper.__actions__), result2.__index__ = wrapper.__index__, result2.__values__ = wrapper.__values__, result2;
      }
      function chunk(array2, size2, guard) {
        (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined$1) ? size2 = 1 : size2 = nativeMax(toInteger(size2), 0);
        var length = array2 == null ? 0 : array2.length;
        if (!length || size2 < 1)
          return [];
        for (var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2)); index < length; )
          result2[resIndex++] = baseSlice(array2, index, index += size2);
        return result2;
      }
      function compact(array2) {
        for (var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = []; ++index < length; ) {
          var value = array2[index];
          value && (result2[resIndex++] = value);
        }
        return result2;
      }
      function concat2() {
        var length = arguments.length;
        if (!length)
          return [];
        for (var args = Array2(length - 1), array2 = arguments[0], index = length; index--; )
          args[index - 1] = arguments[index];
        return arrayPush(isArray2(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array2, values2) {
        return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, !0)) : [];
      }), differenceBy = baseRest(function(array2, values2) {
        var iteratee2 = last2(values2);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2)) : [];
      }), differenceWith = baseRest(function(array2, values2) {
        var comparator = last2(values2);
        return isArrayLikeObject(comparator) && (comparator = undefined$1), isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, !0), undefined$1, comparator) : [];
      });
      function drop(array2, n, guard) {
        var length = array2 == null ? 0 : array2.length;
        return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array2, n < 0 ? 0 : n, length)) : [];
      }
      function dropRight(array2, n, guard) {
        var length = array2 == null ? 0 : array2.length;
        return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array2, 0, n < 0 ? 0 : n)) : [];
      }
      function dropRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), !0, !0) : [];
      }
      function dropWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), !0) : [];
      }
      function fill2(array2, value, start, end2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? (start && typeof start != "number" && isIterateeCall(array2, value, start) && (start = 0, end2 = length), baseFill(array2, value, start, end2)) : [];
      }
      function findIndex2(array2, predicate, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length)
          return -1;
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array2, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array2, predicate, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length)
          return -1;
        var index = length - 1;
        return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), baseFindIndex(array2, getIteratee(predicate, 3), index, !0);
      }
      function flatten(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, 1) : [];
      }
      function flattenDeep(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, INFINITY) : [];
      }
      function flattenDepth(array2, depth2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? (depth2 = depth2 === undefined$1 ? 1 : toInteger(depth2), baseFlatten(array2, depth2)) : [];
      }
      function fromPairs(pairs2) {
        for (var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {}; ++index < length; ) {
          var pair = pairs2[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array2) {
        return array2 && array2.length ? array2[0] : undefined$1;
      }
      function indexOf(array2, value, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length)
          return -1;
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array2, value, index);
      }
      function initial(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSlice(array2, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      }), intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return iteratee2 === last2(mapped) ? iteratee2 = undefined$1 : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      }), intersectionWith = baseRest(function(arrays) {
        var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, comparator && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join2(array2, separator2) {
        return array2 == null ? "" : nativeJoin.call(array2, separator2);
      }
      function last2(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? array2[length - 1] : undefined$1;
      }
      function lastIndexOf(array2, value, fromIndex) {
        var length = array2 == null ? 0 : array2.length;
        if (!length)
          return -1;
        var index = length;
        return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, !0);
      }
      function nth(array2, n) {
        return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array2, values2) {
        return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
      }
      function pullAllBy(array2, values2, iteratee2) {
        return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
      }
      function pullAllWith(array2, values2, comparator) {
        return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined$1, comparator) : array2;
      }
      var pullAt = flatRest(function(array2, indexes) {
        var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
        return basePullAt(array2, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending)), result2;
      });
      function remove(array2, predicate) {
        var result2 = [];
        if (!(array2 && array2.length))
          return result2;
        var index = -1, indexes = [], length = array2.length;
        for (predicate = getIteratee(predicate, 3); ++index < length; ) {
          var value = array2[index];
          predicate(value, index, array2) && (result2.push(value), indexes.push(index));
        }
        return basePullAt(array2, indexes), result2;
      }
      function reverse(array2) {
        return array2 == null ? array2 : nativeReverse.call(array2);
      }
      function slice2(array2, start, end2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? (end2 && typeof end2 != "number" && isIterateeCall(array2, start, end2) ? (start = 0, end2 = length) : (start = start == null ? 0 : toInteger(start), end2 = end2 === undefined$1 ? length : toInteger(end2)), baseSlice(array2, start, end2)) : [];
      }
      function sortedIndex(array2, value) {
        return baseSortedIndex(array2, value);
      }
      function sortedIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        if (length) {
          var index = baseSortedIndex(array2, value);
          if (index < length && eq(array2[index], value))
            return index;
        }
        return -1;
      }
      function sortedLastIndex(array2, value) {
        return baseSortedIndex(array2, value, !0);
      }
      function sortedLastIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), !0);
      }
      function sortedLastIndexOf(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        if (length) {
          var index = baseSortedIndex(array2, value, !0) - 1;
          if (eq(array2[index], value))
            return index;
        }
        return -1;
      }
      function sortedUniq(array2) {
        return array2 && array2.length ? baseSortedUniq(array2) : [];
      }
      function sortedUniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSlice(array2, 1, length) : [];
      }
      function take2(array2, n, guard) {
        return array2 && array2.length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array2, 0, n < 0 ? 0 : n)) : [];
      }
      function takeRight(array2, n, guard) {
        var length = array2 == null ? 0 : array2.length;
        return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array2, n < 0 ? 0 : n, length)) : [];
      }
      function takeRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), !1, !0) : [];
      }
      function takeWhile2(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
      }), unionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2));
      }), unionWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined$1, comparator);
      });
      function uniq(array2) {
        return array2 && array2.length ? baseUniq(array2) : [];
      }
      function uniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array2, comparator) {
        return comparator = typeof comparator == "function" ? comparator : undefined$1, array2 && array2.length ? baseUniq(array2, undefined$1, comparator) : [];
      }
      function unzip(array2) {
        if (!(array2 && array2.length))
          return [];
        var length = 0;
        return array2 = arrayFilter(array2, function(group) {
          if (isArrayLikeObject(group))
            return length = nativeMax(group.length, length), !0;
        }), baseTimes(length, function(index) {
          return arrayMap(array2, baseProperty(index));
        });
      }
      function unzipWith(array2, iteratee2) {
        if (!(array2 && array2.length))
          return [];
        var result2 = unzip(array2);
        return iteratee2 == null ? result2 : arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array2, values2) {
        return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
      }), xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      }), xorBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      }), xorWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      }), zip2 = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        return iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1, unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        return result2.__chain__ = !0, result2;
      }
      function tap2(value, interceptor) {
        return interceptor(value), value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        return length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start) ? this.thru(interceptor) : (value = value.slice(start, +start + (length ? 1 : 0)), value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined$1
        }), new LodashWrapper(value, this.__chain__).thru(function(array2) {
          return length && !array2.length && array2.push(undefined$1), array2;
        }));
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        this.__values__ === undefined$1 && (this.__values__ = toArray2(this.value()));
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        for (var result2, parent2 = this; parent2 instanceof baseLodash; ) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0, clone3.__values__ = undefined$1, result2 ? previous.__wrapped__ = clone3 : result2 = clone3;
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        return previous.__wrapped__ = value, result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined$1
          }), new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key2) {
        hasOwnProperty2.call(result2, key2) ? ++result2[key2] : baseAssignValue(result2, key2, 1);
      });
      function every2(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex2), findLast = createFind(findLastIndex);
      function flatMap2(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth2) {
        return depth2 = depth2 === undefined$1 ? 1 : toInteger(depth2), baseFlatten(map2(collection, iteratee2), depth2);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy2 = createAggregator(function(result2, value, key2) {
        hasOwnProperty2.call(result2, key2) ? result2[key2].push(value) : baseAssignValue(result2, key2, [value]);
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path2, args) {
        var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        return baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
        }), result2;
      }), keyBy = createAggregator(function(result2, value, key2) {
        baseAssignValue(result2, key2, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        return collection == null ? [] : (isArray2(iteratees) || (iteratees = iteratees == null ? [] : [iteratees]), orders = guard ? undefined$1 : orders, isArray2(orders) || (orders = orders == null ? [] : [orders]), baseOrderBy(collection, iteratees, orders));
      }
      var partition2 = createAggregator(function(result2, value, key2) {
        result2[key2 ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce2(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample2(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n);
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null)
          return 0;
        if (isArrayLike2(collection))
          return isString(collection) ? stringSize(collection) : collection.length;
        var tag = getTag(collection);
        return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null)
          return [];
        var length = iteratees.length;
        return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      }), now = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return n = toInteger(n), function() {
          if (--n < 1)
            return func.apply(this, arguments);
        };
      }
      function ary(func, n, guard) {
        return n = guard ? undefined$1 : n, n = func && n == null ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return n = toInteger(n), function() {
          return --n > 0 && (result2 = func.apply(this, arguments)), n <= 1 && (func = undefined$1), result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      }), bindKey = baseRest(function(object, key2, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key2, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        return result2.placeholder = curry.placeholder, result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        return result2.placeholder = curryRight.placeholder, result2;
      }
      function debounce2(func, wait2, options2) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        wait2 = toNumber(wait2) || 0, isObject3(options2) && (leading = !!options2.leading, maxing = "maxWait" in options2, maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait2) : maxWait, trailing = "trailing" in options2 ? !!options2.trailing : trailing);
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          return lastArgs = lastThis = undefined$1, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
        }
        function leadingEdge(time) {
          return lastInvokeTime = time, timerId = setTimeout2(timerExpired, wait2), leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time))
            return trailingEdge(time);
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          return timerId = undefined$1, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined$1, result2);
        }
        function cancel() {
          timerId !== undefined$1 && clearTimeout2(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
            if (timerId === undefined$1)
              return leadingEdge(lastCallTime);
            if (maxing)
              return clearTimeout2(timerId), timerId = setTimeout2(timerExpired, wait2), invokeFunc(lastCallTime);
          }
          return timerId === undefined$1 && (timerId = setTimeout2(timerExpired, wait2)), result2;
        }
        return debounced.cancel = cancel, debounced.flush = flush, debounced;
      }
      var defer2 = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      }), delay2 = baseRest(function(func, wait2, args) {
        return baseDelay(func, toNumber(wait2) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        var memoized = function() {
          var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key2))
            return cache.get(key2);
          var result2 = func.apply(this, args);
          return memoized.cache = cache.set(key2, result2) || cache, result2;
        };
        return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once2(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; )
            args[index] = transforms[index].call(this, args[index]);
          return apply(func, this, args);
        });
      }), partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      }), partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      }), rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return start = start === undefined$1 ? start : toInteger(start), baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return start = start == null ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
          var array2 = args[start], otherArgs = castSlice(args, 0, start);
          return array2 && arrayPush(otherArgs, array2), apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait2, options2) {
        var leading = !0, trailing = !0;
        if (typeof func != "function")
          throw new TypeError2(FUNC_ERROR_TEXT);
        return isObject3(options2) && (leading = "leading" in options2 ? !!options2.leading : leading, trailing = "trailing" in options2 ? !!options2.trailing : trailing), debounce2(func, wait2, {
          leading,
          maxWait: wait2,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length)
          return [];
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source2) {
        return source2 == null || baseConformsTo(object, source2, keys(source2));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt), gte2 = createRelationalOperation(function(value, other) {
        return value >= other;
      }), isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      }, isArray2 = Array2.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean2(value) {
        return value === !0 || value === !1 || isObjectLike2(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse, isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject3(value);
      }
      function isEmpty2(value) {
        if (value == null)
          return !0;
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments(value)))
          return !value.length;
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag)
          return !value.size;
        if (isPrototype(value))
          return !baseKeys(value).length;
        for (var key2 in value)
          if (hasOwnProperty2.call(value, key2))
            return !1;
        return !0;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value))
          return !1;
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject3(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject3(value))
          return !1;
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger2(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject3(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source2) {
        return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
      }
      function isMatchWith(object, source2, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseIsMatch(object, source2, getMatchData(source2), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value))
          throw new Error2(CORE_ERROR_TEXT);
        return baseIsNative(value);
      }
      function isNull2(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject3(value) {
        if (!isObjectLike2(value) || baseGetTag(value) != objectTag2)
          return !1;
        var proto = getPrototype2(value);
        if (proto === null)
          return !0;
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt), lte2 = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value)
          return [];
        if (isArrayLike2(value))
          return isString(value) ? stringToArray(value) : copyArray(value);
        if (symIterator && value[symIterator])
          return iteratorToArray(value[symIterator]());
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value)
          return value === 0 ? value : 0;
        if (value = toNumber(value), value === INFINITY || value === -INFINITY) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number")
          return value;
        if (isSymbol(value))
          return NAN;
        if (isObject3(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject3(other) ? other + "" : other;
        }
        if (typeof value != "string")
          return value === 0 ? value : +value;
        value = baseTrim(value);
        var isBinary2 = reIsBinary.test(value);
        return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString8(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign2 = createAssigner(function(object, source2) {
        if (isPrototype(source2) || isArrayLike2(source2)) {
          copyObject(source2, keys(source2), object);
          return;
        }
        for (var key2 in source2)
          hasOwnProperty2.call(source2, key2) && assignValue(object, key2, source2[key2]);
      }), assignIn = createAssigner(function(object, source2) {
        copyObject(source2, keysIn(source2), object);
      }), assignInWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keysIn(source2), object, customizer);
      }), assignWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keys(source2), object, customizer);
      }), at = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1, length = sources.length, guard = length > 2 ? sources[2] : undefined$1;
        for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; )
          for (var source2 = sources[index], props = keysIn(source2), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
            var key2 = props[propsIndex], value = object[key2];
            (value === undefined$1 || eq(value, objectProto2[key2]) && !hasOwnProperty2.call(object, key2)) && (object[key2] = source2[key2]);
          }
        return object;
      }), defaultsDeep = baseRest(function(args) {
        return args.push(undefined$1, customDefaultsMerge), apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path2, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path2);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path2) {
        return object != null && hasPath(object, path2, baseHas);
      }
      function hasIn(object, path2) {
        return object != null && hasPath(object, path2, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key2) {
        value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), result2[value] = key2;
      }, constant(identity2)), invertBy = createInverter(function(result2, value, key2) {
        value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), hasOwnProperty2.call(result2, value) ? result2[value].push(key2) : result2[value] = [key2];
      }, getIteratee), invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, iteratee2(value, key2, object2), value);
        }), result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, key2, iteratee2(value, key2, object2));
        }), result2;
      }
      var merge2 = createAssigner(function(object, source2, srcIndex) {
        baseMerge(object, source2, srcIndex);
      }), mergeWith = createAssigner(function(object, source2, srcIndex, customizer) {
        baseMerge(object, source2, srcIndex, customizer);
      }), omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null)
          return result2;
        var isDeep = !1;
        paths = arrayMap(paths, function(path2) {
          return path2 = castPath(path2, object), isDeep || (isDeep = path2.length > 1), path2;
        }), copyObject(object, getAllKeysIn(object), result2), isDeep && (result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
        for (var length = paths.length; length--; )
          baseUnset(result2, paths[length]);
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null)
          return {};
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path2) {
          return predicate(value, path2[0]);
        });
      }
      function result(object, path2, defaultValue) {
        path2 = castPath(path2, object);
        var index = -1, length = path2.length;
        for (length || (length = 1, object = undefined$1); ++index < length; ) {
          var value = object == null ? undefined$1 : object[toKey(path2[index])];
          value === undefined$1 && (index = length, value = defaultValue), object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path2, value) {
        return object == null ? object : baseSet(object, path2, value);
      }
      function setWith(object, path2, value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseSet(object, path2, value, customizer);
      }
      var toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray2(object);
        if (iteratee2 = getIteratee(iteratee2, 4), accumulator == null) {
          var Ctor = object && object.constructor;
          isArrLike ? accumulator = isArr ? new Ctor() : [] : isObject3(object) ? accumulator = isFunction2(Ctor) ? baseCreate(getPrototype2(object)) : {} : accumulator = {};
        }
        return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        }), accumulator;
      }
      function unset(object, path2) {
        return object == null ? !0 : baseUnset(object, path2);
      }
      function update(object, path2, updater) {
        return object == null ? object : baseUpdate(object, path2, castFunction(updater));
      }
      function updateWith(object, path2, updater, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number2, lower, upper) {
        return upper === undefined$1 && (upper = lower, lower = undefined$1), upper !== undefined$1 && (upper = toNumber(upper), upper = upper === upper ? upper : 0), lower !== undefined$1 && (lower = toNumber(lower), lower = lower === lower ? lower : 0), baseClamp(toNumber(number2), lower, upper);
      }
      function inRange(number2, start, end2) {
        return start = toFinite(start), end2 === undefined$1 ? (end2 = start, start = 0) : end2 = toFinite(end2), number2 = toNumber(number2), baseInRange(number2, start, end2);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating) && (upper = floating = undefined$1), floating === undefined$1 && (typeof upper == "boolean" ? (floating = upper, upper = undefined$1) : typeof lower == "boolean" && (floating = lower, lower = undefined$1)), lower === undefined$1 && upper === undefined$1 ? (lower = 0, upper = 1) : (lower = toFinite(lower), upper === undefined$1 ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
          var temp = lower;
          lower = upper, upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase2 = createCompounder(function(result2, word, index) {
        return word = word.toLowerCase(), result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString8(string).toLowerCase());
      }
      function deburr(string) {
        return string = toString8(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString8(string), target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end2 = position;
        return position -= target.length, position >= 0 && string.slice(position, end2) == target;
      }
      function escape2(string) {
        return string = toString8(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        return string = toString8(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      }), lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      }), lowerFirst = createCaseFirst("toLowerCase");
      function pad2(string, length, chars) {
        string = toString8(string), length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length)
          return string;
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString8(string), length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart2(string, length, chars) {
        string = toString8(string), length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        return guard || radix == null ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString8(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat2(string, n, guard) {
        return (guard ? isIterateeCall(string, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n), baseRepeat(toString8(string), n);
      }
      function replace() {
        var args = arguments, string = toString8(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator2, limit) {
        return limit && typeof limit != "number" && isIterateeCall(string, separator2, limit) && (separator2 = limit = undefined$1), limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0, limit ? (string = toString8(string), string && (typeof separator2 == "string" || separator2 != null && !isRegExp2(separator2)) && (separator2 = baseToString(separator2), !separator2 && hasUnicode(string)) ? castSlice(stringToArray(string), 0, limit) : string.split(separator2, limit)) : [];
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        return string = toString8(string), position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length), target = baseToString(target), string.slice(position, position + target.length) == target;
      }
      function template(string, options2, guard) {
        var settings = lodash2.templateSettings;
        guard && isIterateeCall(string, options2, guard) && (options2 = undefined$1), string = toString8(string), options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source2 = "__p += '", reDelimiters = RegExp2(
          (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
          "g"
        ), sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
        string.replace(reDelimiters, function(match3, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          return interpolateValue || (interpolateValue = esTemplateValue), source2 += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source2 += `' +
__e(` + escapeValue + `) +
'`), evaluateValue && (isEvaluating = !0, source2 += `';
` + evaluateValue + `;
__p += '`), interpolateValue && (source2 += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`), index = offset + match3.length, match3;
        }), source2 += `';
`;
        var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
        if (!variable)
          source2 = `with (obj) {
` + source2 + `
}
`;
        else if (reForbiddenIdentifierChars.test(variable))
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source2 = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + source2 + `return __p
}`;
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$1, importsValues);
        });
        if (result2.source = source2, isError(result2))
          throw result2;
        return result2;
      }
      function toLower(value) {
        return toString8(value).toLowerCase();
      }
      function toUpper(value) {
        return toString8(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        if (string = toString8(string), string && (guard || chars === undefined$1))
          return baseTrim(string);
        if (!string || !(chars = baseToString(chars)))
          return string;
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        if (string = toString8(string), string && (guard || chars === undefined$1))
          return string.slice(0, trimmedEndIndex(string) + 1);
        if (!string || !(chars = baseToString(chars)))
          return string;
        var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        if (string = toString8(string), string && (guard || chars === undefined$1))
          return string.replace(reTrimStart, "");
        if (!string || !(chars = baseToString(chars)))
          return string;
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options2) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options2)) {
          var separator2 = "separator" in options2 ? options2.separator : separator2;
          length = "length" in options2 ? toInteger(options2.length) : length, omission = "omission" in options2 ? baseToString(options2.omission) : omission;
        }
        string = toString8(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength)
          return string;
        var end2 = length - stringSize(omission);
        if (end2 < 1)
          return omission;
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator2 === undefined$1)
          return result2 + omission;
        if (strSymbols && (end2 += result2.length - end2), isRegExp2(separator2)) {
          if (string.slice(end2).search(separator2)) {
            var match3, substring = result2;
            for (separator2.global || (separator2 = RegExp2(separator2.source, toString8(reFlags.exec(separator2)) + "g")), separator2.lastIndex = 0; match3 = separator2.exec(substring); )
              var newEnd = match3.index;
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString(separator2), end2) != end2) {
          var index = result2.lastIndexOf(separator2);
          index > -1 && (result2 = result2.slice(0, index));
        }
        return result2 + omission;
      }
      function unescape(string) {
        return string = toString8(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      }), upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        return string = toString8(string), pattern = guard ? undefined$1 : pattern, pattern === undefined$1 ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      }), bindAll = flatRest(function(object, methodNames) {
        return arrayEach(methodNames, function(key2) {
          key2 = toKey(key2), baseAssignValue(object, key2, bind(object[key2], object));
        }), object;
      });
      function cond(pairs2) {
        var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
        return pairs2 = length ? arrayMap(pairs2, function(pair) {
          if (typeof pair[1] != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return [toIteratee(pair[0]), pair[1]];
        }) : [], baseRest(function(args) {
          for (var index = -1; ++index < length; ) {
            var pair = pairs2[index];
            if (apply(pair[0], this, args))
              return apply(pair[1], this, args);
          }
        });
      }
      function conforms(source2) {
        return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow2 = createFlow(), flowRight = createFlow(!0);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches2(source2) {
        return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path2, srcValue) {
        return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path2, args) {
        return function(object) {
          return baseInvoke(object, path2, args);
        };
      }), methodOf = baseRest(function(object, args) {
        return function(path2) {
          return baseInvoke(object, path2, args);
        };
      });
      function mixin(object, source2, options2) {
        var props = keys(source2), methodNames = baseFunctions(source2, props);
        options2 == null && !(isObject3(source2) && (methodNames.length || !props.length)) && (options2 = source2, source2 = object, object = this, methodNames = baseFunctions(source2, keys(source2)));
        var chain2 = !(isObject3(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
        return arrayEach(methodNames, function(methodName) {
          var func = source2[methodName];
          object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain2 || chainAll) {
              var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
              return actions.push({ func, args: arguments, thisArg: object }), result2.__chain__ = chainAll, result2;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          });
        }), object;
      }
      function noConflict() {
        return root2._ === this && (root2._ = oldDash), this;
      }
      function noop2() {
      }
      function nthArg(n) {
        return n = toInteger(n), baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome);
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
      }
      function propertyOf(object) {
        return function(path2) {
          return object == null ? undefined$1 : baseGet(object, path2);
        };
      }
      var range2 = createRange(), rangeRight = createRange(!0);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return !1;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return !0;
      }
      function times(n, iteratee2) {
        if (n = toInteger(n), n < 1 || n > MAX_SAFE_INTEGER)
          return [];
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2), n -= MAX_ARRAY_LENGTH;
        for (var result2 = baseTimes(length, iteratee2); ++index < n; )
          iteratee2(index);
        return result2;
      }
      function toPath(value) {
        return isArray2(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString8(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString8(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1), floor = createRound("floor");
      function max2(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined$1;
      }
      function maxBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array2) {
        return baseMean(array2, identity2);
      }
      function meanBy(array2, iteratee2) {
        return baseMean(array2, getIteratee(iteratee2, 2));
      }
      function min2(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : undefined$1;
      }
      function minBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1), round2 = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array2) {
        return array2 && array2.length ? baseSum(array2, identity2) : 0;
      }
      function sumBy(array2, iteratee2) {
        return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
      }
      return lodash2.after = after, lodash2.ary = ary, lodash2.assign = assign2, lodash2.assignIn = assignIn, lodash2.assignInWith = assignInWith, lodash2.assignWith = assignWith, lodash2.at = at, lodash2.before = before, lodash2.bind = bind, lodash2.bindAll = bindAll, lodash2.bindKey = bindKey, lodash2.castArray = castArray, lodash2.chain = chain, lodash2.chunk = chunk, lodash2.compact = compact, lodash2.concat = concat2, lodash2.cond = cond, lodash2.conforms = conforms, lodash2.constant = constant, lodash2.countBy = countBy, lodash2.create = create2, lodash2.curry = curry, lodash2.curryRight = curryRight, lodash2.debounce = debounce2, lodash2.defaults = defaults2, lodash2.defaultsDeep = defaultsDeep, lodash2.defer = defer2, lodash2.delay = delay2, lodash2.difference = difference, lodash2.differenceBy = differenceBy, lodash2.differenceWith = differenceWith, lodash2.drop = drop, lodash2.dropRight = dropRight, lodash2.dropRightWhile = dropRightWhile, lodash2.dropWhile = dropWhile, lodash2.fill = fill2, lodash2.filter = filter2, lodash2.flatMap = flatMap2, lodash2.flatMapDeep = flatMapDeep, lodash2.flatMapDepth = flatMapDepth, lodash2.flatten = flatten, lodash2.flattenDeep = flattenDeep, lodash2.flattenDepth = flattenDepth, lodash2.flip = flip2, lodash2.flow = flow2, lodash2.flowRight = flowRight, lodash2.fromPairs = fromPairs, lodash2.functions = functions, lodash2.functionsIn = functionsIn, lodash2.groupBy = groupBy2, lodash2.initial = initial, lodash2.intersection = intersection, lodash2.intersectionBy = intersectionBy, lodash2.intersectionWith = intersectionWith, lodash2.invert = invert, lodash2.invertBy = invertBy, lodash2.invokeMap = invokeMap, lodash2.iteratee = iteratee, lodash2.keyBy = keyBy, lodash2.keys = keys, lodash2.keysIn = keysIn, lodash2.map = map2, lodash2.mapKeys = mapKeys, lodash2.mapValues = mapValues, lodash2.matches = matches2, lodash2.matchesProperty = matchesProperty, lodash2.memoize = memoize, lodash2.merge = merge2, lodash2.mergeWith = mergeWith, lodash2.method = method, lodash2.methodOf = methodOf, lodash2.mixin = mixin, lodash2.negate = negate, lodash2.nthArg = nthArg, lodash2.omit = omit, lodash2.omitBy = omitBy, lodash2.once = once2, lodash2.orderBy = orderBy, lodash2.over = over, lodash2.overArgs = overArgs, lodash2.overEvery = overEvery, lodash2.overSome = overSome, lodash2.partial = partial, lodash2.partialRight = partialRight, lodash2.partition = partition2, lodash2.pick = pick, lodash2.pickBy = pickBy, lodash2.property = property, lodash2.propertyOf = propertyOf, lodash2.pull = pull, lodash2.pullAll = pullAll, lodash2.pullAllBy = pullAllBy, lodash2.pullAllWith = pullAllWith, lodash2.pullAt = pullAt, lodash2.range = range2, lodash2.rangeRight = rangeRight, lodash2.rearg = rearg, lodash2.reject = reject, lodash2.remove = remove, lodash2.rest = rest, lodash2.reverse = reverse, lodash2.sampleSize = sampleSize, lodash2.set = set2, lodash2.setWith = setWith, lodash2.shuffle = shuffle, lodash2.slice = slice2, lodash2.sortBy = sortBy, lodash2.sortedUniq = sortedUniq, lodash2.sortedUniqBy = sortedUniqBy, lodash2.split = split, lodash2.spread = spread, lodash2.tail = tail, lodash2.take = take2, lodash2.takeRight = takeRight, lodash2.takeRightWhile = takeRightWhile, lodash2.takeWhile = takeWhile2, lodash2.tap = tap2, lodash2.throttle = throttle2, lodash2.thru = thru, lodash2.toArray = toArray2, lodash2.toPairs = toPairs, lodash2.toPairsIn = toPairsIn, lodash2.toPath = toPath, lodash2.toPlainObject = toPlainObject, lodash2.transform = transform2, lodash2.unary = unary, lodash2.union = union, lodash2.unionBy = unionBy, lodash2.unionWith = unionWith, lodash2.uniq = uniq, lodash2.uniqBy = uniqBy, lodash2.uniqWith = uniqWith, lodash2.unset = unset, lodash2.unzip = unzip, lodash2.unzipWith = unzipWith, lodash2.update = update, lodash2.updateWith = updateWith, lodash2.values = values, lodash2.valuesIn = valuesIn, lodash2.without = without, lodash2.words = words, lodash2.wrap = wrap, lodash2.xor = xor, lodash2.xorBy = xorBy, lodash2.xorWith = xorWith, lodash2.zip = zip2, lodash2.zipObject = zipObject, lodash2.zipObjectDeep = zipObjectDeep, lodash2.zipWith = zipWith, lodash2.entries = toPairs, lodash2.entriesIn = toPairsIn, lodash2.extend = assignIn, lodash2.extendWith = assignInWith, mixin(lodash2, lodash2), lodash2.add = add, lodash2.attempt = attempt, lodash2.camelCase = camelCase2, lodash2.capitalize = capitalize, lodash2.ceil = ceil, lodash2.clamp = clamp, lodash2.clone = clone2, lodash2.cloneDeep = cloneDeep, lodash2.cloneDeepWith = cloneDeepWith, lodash2.cloneWith = cloneWith, lodash2.conformsTo = conformsTo, lodash2.deburr = deburr, lodash2.defaultTo = defaultTo, lodash2.divide = divide, lodash2.endsWith = endsWith, lodash2.eq = eq, lodash2.escape = escape2, lodash2.escapeRegExp = escapeRegExp, lodash2.every = every2, lodash2.find = find2, lodash2.findIndex = findIndex2, lodash2.findKey = findKey, lodash2.findLast = findLast, lodash2.findLastIndex = findLastIndex, lodash2.findLastKey = findLastKey, lodash2.floor = floor, lodash2.forEach = forEach, lodash2.forEachRight = forEachRight, lodash2.forIn = forIn, lodash2.forInRight = forInRight, lodash2.forOwn = forOwn, lodash2.forOwnRight = forOwnRight, lodash2.get = get2, lodash2.gt = gt, lodash2.gte = gte2, lodash2.has = has, lodash2.hasIn = hasIn, lodash2.head = head, lodash2.identity = identity2, lodash2.includes = includes, lodash2.indexOf = indexOf, lodash2.inRange = inRange, lodash2.invoke = invoke, lodash2.isArguments = isArguments, lodash2.isArray = isArray2, lodash2.isArrayBuffer = isArrayBuffer, lodash2.isArrayLike = isArrayLike2, lodash2.isArrayLikeObject = isArrayLikeObject, lodash2.isBoolean = isBoolean2, lodash2.isBuffer = isBuffer, lodash2.isDate = isDate2, lodash2.isElement = isElement, lodash2.isEmpty = isEmpty2, lodash2.isEqual = isEqual, lodash2.isEqualWith = isEqualWith, lodash2.isError = isError, lodash2.isFinite = isFinite2, lodash2.isFunction = isFunction2, lodash2.isInteger = isInteger2, lodash2.isLength = isLength, lodash2.isMap = isMap, lodash2.isMatch = isMatch, lodash2.isMatchWith = isMatchWith, lodash2.isNaN = isNaN2, lodash2.isNative = isNative, lodash2.isNil = isNil, lodash2.isNull = isNull2, lodash2.isNumber = isNumber2, lodash2.isObject = isObject3, lodash2.isObjectLike = isObjectLike2, lodash2.isPlainObject = isPlainObject3, lodash2.isRegExp = isRegExp2, lodash2.isSafeInteger = isSafeInteger, lodash2.isSet = isSet, lodash2.isString = isString, lodash2.isSymbol = isSymbol, lodash2.isTypedArray = isTypedArray2, lodash2.isUndefined = isUndefined2, lodash2.isWeakMap = isWeakMap, lodash2.isWeakSet = isWeakSet, lodash2.join = join2, lodash2.kebabCase = kebabCase, lodash2.last = last2, lodash2.lastIndexOf = lastIndexOf, lodash2.lowerCase = lowerCase, lodash2.lowerFirst = lowerFirst, lodash2.lt = lt, lodash2.lte = lte2, lodash2.max = max2, lodash2.maxBy = maxBy, lodash2.mean = mean, lodash2.meanBy = meanBy, lodash2.min = min2, lodash2.minBy = minBy, lodash2.stubArray = stubArray, lodash2.stubFalse = stubFalse, lodash2.stubObject = stubObject, lodash2.stubString = stubString, lodash2.stubTrue = stubTrue, lodash2.multiply = multiply, lodash2.nth = nth, lodash2.noConflict = noConflict, lodash2.noop = noop2, lodash2.now = now, lodash2.pad = pad2, lodash2.padEnd = padEnd, lodash2.padStart = padStart2, lodash2.parseInt = parseInt2, lodash2.random = random, lodash2.reduce = reduce2, lodash2.reduceRight = reduceRight, lodash2.repeat = repeat2, lodash2.replace = replace, lodash2.result = result, lodash2.round = round2, lodash2.runInContext = runInContext2, lodash2.sample = sample2, lodash2.size = size, lodash2.snakeCase = snakeCase, lodash2.some = some, lodash2.sortedIndex = sortedIndex, lodash2.sortedIndexBy = sortedIndexBy, lodash2.sortedIndexOf = sortedIndexOf, lodash2.sortedLastIndex = sortedLastIndex, lodash2.sortedLastIndexBy = sortedLastIndexBy, lodash2.sortedLastIndexOf = sortedLastIndexOf, lodash2.startCase = startCase, lodash2.startsWith = startsWith, lodash2.subtract = subtract, lodash2.sum = sum, lodash2.sumBy = sumBy, lodash2.template = template, lodash2.times = times, lodash2.toFinite = toFinite, lodash2.toInteger = toInteger, lodash2.toLength = toLength, lodash2.toLower = toLower, lodash2.toNumber = toNumber, lodash2.toSafeInteger = toSafeInteger, lodash2.toString = toString8, lodash2.toUpper = toUpper, lodash2.trim = trim, lodash2.trimEnd = trimEnd, lodash2.trimStart = trimStart, lodash2.truncate = truncate, lodash2.unescape = unescape, lodash2.uniqueId = uniqueId, lodash2.upperCase = upperCase, lodash2.upperFirst = upperFirst, lodash2.each = forEach, lodash2.eachRight = forEachRight, lodash2.first = head, mixin(lodash2, function() {
        var source2 = {};
        return baseForOwn(lodash2, function(func, methodName) {
          hasOwnProperty2.call(lodash2.prototype, methodName) || (source2[methodName] = func);
        }), source2;
      }(), { chain: !1 }), lodash2.VERSION = VERSION, arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      }), arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          return result2.__filtered__ ? result2.__takeCount__ = nativeMin(n, result2.__takeCount__) : result2.__views__.push({
            size: nativeMin(n, MAX_ARRAY_LENGTH),
            type: methodName + (result2.__dir__ < 0 ? "Right" : "")
          }), result2;
        }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      }), arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          return result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type: type2
          }), result2.__filtered__ = result2.__filtered__ || isFilter, result2;
        };
      }), arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      }), arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      }), LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      }, LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      }, LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      }, LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
        return typeof path2 == "function" ? new LazyWrapper(this) : this.map(function(value) {
          return baseInvoke(value, path2, args);
        });
      }), LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      }, LazyWrapper.prototype.slice = function(start, end2) {
        start = toInteger(start);
        var result2 = this;
        return result2.__filtered__ && (start > 0 || end2 < 0) ? new LazyWrapper(result2) : (start < 0 ? result2 = result2.takeRight(-start) : start && (result2 = result2.drop(start)), end2 !== undefined$1 && (end2 = toInteger(end2), result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start)), result2);
      }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      }, LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        lodashFunc && (lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value), interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1 && (isLazy = useLazy = !1);
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            return result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined$1 }), new LodashWrapper(result2, chainAll);
          }
          return isUnwrapped && onlyLazy ? func.apply(this, args) : (result2 = this.thru(interceptor), isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2);
        });
      }), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key2 = lodashFunc.name + "";
          hasOwnProperty2.call(realNames, key2) || (realNames[key2] = []), realNames[key2].push({ name: methodName, func: lodashFunc });
        }
      }), realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined$1
      }], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, LazyWrapper.prototype.value = lazyValue, lodash2.prototype.at = wrapperAt, lodash2.prototype.chain = wrapperChain, lodash2.prototype.commit = wrapperCommit, lodash2.prototype.next = wrapperNext, lodash2.prototype.plant = wrapperPlant, lodash2.prototype.reverse = wrapperReverse, lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue, lodash2.prototype.first = lodash2.prototype.head, symIterator && (lodash2.prototype[symIterator] = wrapperToIterator), lodash2;
    }, _2 = runInContext();
    freeModule ? ((freeModule.exports = _2)._ = _2, freeExports._ = _2) : root2._ = _2;
  }).call(loadEnv.commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const purpose$2 = "Transform `sanity/desk` imports to `sanity/structure`", description$3 = `
Modifies all code paths that are found to import  from 'sanity/desk' to instead import from
'sanity/structure', and renames any renamed members.

from: import {deskTool} from 'sanity/desk'
  to: import {structureTool} from 'sanity/structure'

from: import {StructureBuilder} from 'sanity/desk'
  to: import {StructureBuilder} from 'sanity/structure'
`.trim(), deskRename = {
  purpose: purpose$2,
  description: description$3,
  filename: "deskRename.js"
}, purpose$1 = "Add parts types directive to all ts/tsx files that has one or more part imports", description$2 = `
Adds a '///<reference types="@sanity/types/parts" />' header to all source files that has one or more part imports.
For example:

Before:
---- somefile.ts
import client from 'part:@sanity/base/client'
//\u2026
----

After:
---- somefile.ts
///<reference types="@sanity/types/parts" />
import client from 'part:@sanity/base/client'
//\u2026
----


`.trim(), partsTypeDirective = {
  purpose: purpose$1,
  description: description$2,
  filename: "partsTypeDirective.js"
};
var semverCompare = function(a, b) {
  for (var pa = a.split("."), pb = b.split("."), i2 = 0; i2 < 3; i2++) {
    var na = Number(pa[i2]), nb = Number(pb[i2]);
    if (na > nb) return 1;
    if (nb > na) return -1;
    if (!isNaN(na) && isNaN(nb)) return 1;
    if (isNaN(na) && !isNaN(nb)) return -1;
  }
  return 0;
}, semverCompare$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(semverCompare);
async function readJson(filePath) {
  const content = await fs$o.readFile(filePath, "utf8");
  return JSON.parse(content);
}
const purpose = "Transform react-icons v2 imports to v3 form", description$1 = `
Modifies all found react-icons import and require statements from their v2 form
to the path structure used in react-icons v3. For instance:

from: import {MdPerson} from 'react-icons/lib/md'
  to: import {MdPerson} from 'react-icons/md'

from: import PersonIcon from 'react-icons/lib/md/person'
  to: import {MdPerson as PersonIcon} from 'react-icons/md'
`.trim(), reactIconsV3 = {
  purpose,
  description: description$1,
  filename: "reactIconsV3.js",
  verify: async (context) => {
    const { workDir } = context, studioPkg = await maybeReadJson(path__default.default.join(workDir, "package.json")), dependencyVersion = ((studioPkg && studioPkg.dependencies || {})["react-icons"] || "").replace(/^[\^~]/, "");
    if (!dependencyVersion)
      throw new Error("Could not find react-icons declared as dependency in package.json");
    if (semverCompare$1(dependencyVersion, "3.0.0") < 0)
      throw new Error("react-icons declared in package.json dependencies is lower than 3.0.0");
    const iconPkgPath = resolveFrom$1.silent(workDir, "react-icons/package.json"), iconPkg = iconPkgPath && await maybeReadJson(iconPkgPath);
    if (iconPkg && semverCompare$1(iconPkg.version, "3.0.0") < 0)
      throw new Error("The installed version of react-icon seems to be < 3.0.0");
  }
};
async function maybeReadJson(jsonPath) {
  try {
    return await readJson(jsonPath);
  } catch {
    return null;
  }
}
var mods = {
  reactIconsV3,
  partsTypeDirective,
  deskRename
};
const codemodAction = async function(args, context) {
  const { output, cliRoot, workDir } = context, [name] = args.argsWithoutOptions, cliFlags = args.extOptions;
  if (!name) {
    printMods(output);
    return;
  }
  const normalizedMods = {};
  for (const [originalName, mod2] of Object.entries(mods))
    normalizedMods[originalName.toLowerCase()] = mod2;
  const mod = normalizedMods[name.toLowerCase()];
  if (!mod)
    throw new Error(`Codemod with name "${name}" not found`);
  typeof mod.verify == "function" && cliFlags.verify !== !1 && await mod.verify(context);
  const exts = cliFlags.extensions ? cliFlags.extensions.split(",").map((ext2) => ext2.trim().replace(/^\./, "")) : ["js", "ts", "tsx"], dryRun = !!(!(typeof cliFlags.dry > "u") && cliFlags.dry);
  ensureNpx();
  const hasGitIgnore = fs__default.default.existsSync(path__default.default.join(workDir, ".gitignore")), modPath = path__default.default.resolve(path__default.default.join(cliRoot, "codemods", mod.filename)), cmdArgs = [
    "jscodeshift",
    "--ignore-pattern",
    "node_modules",
    "--ignore-pattern",
    "dist",
    hasGitIgnore && "--ignore-config",
    hasGitIgnore && ".gitignore",
    "-t",
    modPath,
    "--extensions",
    exts.join(","),
    dryRun && "--dry",
    workDir
  ].filter((item) => typeof item == "string"), child = childProcess__default.default.spawn("npx", cmdArgs, {
    stdio: "inherit"
  });
  process.on("SIGINT", () => {
    child.kill(2);
  }), child.on("close", (code) => {
    process.exit(code || void 0);
  });
};
function printMods(output) {
  output.print(`Available code modifications:
`);
  for (const [modName, mod] of Object.entries(mods))
    output.print(`${modName} - ${mod.purpose}`);
}
function ensureNpx() {
  try {
    if (!childProcess__default.default.execSync("npx --help", { encoding: "utf8" }).includes("npm"))
      throw new Error("Not the npx we expected");
  } catch {
    throw new Error(
      'Failed to run "npx" - required to run codemods. Do you have a recent version of npm installed?'
    );
  }
}
const helpText$a = `
Runs a given code modification script on the current studio folder.
Running the command without a specified codemod name will list available transformations.

Options
  --dry Dry run (no changes are made to files)
  --extensions=EXT Transform files with these file extensions (comma separated list)
                   (default: js,ts,tsx)
  --no-verify Skips verification steps before running codemod

Examples
  # Show available code mods
  sanity codemod

  # Run codemod to transform react-icons imports from v2 style to v3 style,
  # but only as a dry-run (do not write the files)
  sanity codemod reactIconsV3 --dry

`, codemodCommand = {
  name: "codemod",
  signature: "[CODEMOD_NAME]",
  description: "Updates Sanity Studio codebase with a code modification script",
  helpText: helpText$a,
  action: codemodAction
};
var objectTag = "[object Object]";
function isHostObject(value) {
  var result = !1;
  if (value != null && typeof value.toString != "function")
    try {
      result = !!(value + "");
    } catch {
    }
  return result;
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$3 = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString = objectProto.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isPlainObject$3(value) {
  if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value))
    return !1;
  var proto = getPrototype(value);
  if (proto === null)
    return !0;
  var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$3;
const isPlainObject$2 = lodash_isplainobject;
function isPromiseLike(obj) {
  return obj && typeof obj == "object" && typeof obj.then == "function";
}
function promiseProps(obj) {
  const keys = Object.keys(obj), values = keys.map((key2) => obj[key2]);
  return promiseArray(values).then((results) => {
    const result = {};
    for (let i2 = 0; i2 < keys.length; i2++)
      result[keys[i2]] = results[i2];
    return result;
  });
}
function promiseArray(arr) {
  return Promise.all(arr.map(promisePropsRecursive));
}
function promisePropsRecursive(obj) {
  return isPromiseLike(obj) ? obj.then(promisePropsRecursive) : isPlainObject$2(obj) ? promiseProps(obj) : Array.isArray(obj) ? promiseArray(obj) : Promise.resolve(obj);
}
var promisePropsRecursive_1 = promisePropsRecursive, promiseProps$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(promisePropsRecursive_1), xdgBasedir$2 = {};
(function(exports2) {
  const os2 = require$$0__default$2.default, path2 = require$$0__default.default, homeDirectory = os2.homedir(), { env } = process;
  exports2.data = env.XDG_DATA_HOME || (homeDirectory ? path2.join(homeDirectory, ".local", "share") : void 0), exports2.config = env.XDG_CONFIG_HOME || (homeDirectory ? path2.join(homeDirectory, ".config") : void 0), exports2.cache = env.XDG_CACHE_HOME || (homeDirectory ? path2.join(homeDirectory, ".cache") : void 0), exports2.runtime = env.XDG_RUNTIME_DIR || void 0, exports2.dataDirs = (env.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":"), exports2.data && exports2.dataDirs.unshift(exports2.data), exports2.configDirs = (env.XDG_CONFIG_DIRS || "/etc/xdg").split(":"), exports2.config && exports2.configDirs.unshift(exports2.config);
})(xdgBasedir$2);
var xdgBasedir$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(xdgBasedir$2), registryUrl$2 = { exports: {} }, utils$b = {}, ini$5 = {};
ini$5.parse = ini$5.decode = decode$1;
ini$5.stringify = ini$5.encode = encode$1;
ini$5.safe = safe$1;
ini$5.unsafe = unsafe$1;
var eol$1 = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
function encode$1(obj, opt) {
  var children = [], out = "";
  typeof opt == "string" ? opt = {
    section: opt,
    whitespace: !1
  } : (opt = opt || {}, opt.whitespace = opt.whitespace === !0);
  var separator2 = opt.whitespace ? " = " : "=";
  return Object.keys(obj).forEach(function(k, _2, __) {
    var val = obj[k];
    val && Array.isArray(val) ? val.forEach(function(item) {
      out += safe$1(k + "[]") + separator2 + safe$1(item) + `
`;
    }) : val && typeof val == "object" ? children.push(k) : out += safe$1(k) + separator2 + safe$1(val) + eol$1;
  }), opt.section && out.length && (out = "[" + safe$1(opt.section) + "]" + eol$1 + out), children.forEach(function(k, _2, __) {
    var nk = dotSplit$1(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, child = encode$1(obj[k], {
      section,
      whitespace: opt.whitespace
    });
    out.length && child.length && (out += eol$1), out += child;
  }), out;
}
function dotSplit$1(str2) {
  return str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
    return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
  });
}
function decode$1(str2) {
  var out = {}, p = out, section = null, re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines2 = str2.split(/[\r\n]+/g);
  return lines2.forEach(function(line3, _2, __) {
    if (!(!line3 || line3.match(/^\s*[;#]/))) {
      var match3 = line3.match(re);
      if (match3) {
        if (match3[1] !== void 0) {
          if (section = unsafe$1(match3[1]), section === "__proto__") {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key2 = unsafe$1(match3[2]);
        if (key2 !== "__proto__") {
          var value = match3[3] ? unsafe$1(match3[4]) : !0;
          switch (value) {
            case "true":
            case "false":
            case "null":
              value = JSON.parse(value);
          }
          if (key2.length > 2 && key2.slice(-2) === "[]") {
            if (key2 = key2.substring(0, key2.length - 2), key2 === "__proto__")
              return;
            p[key2] ? Array.isArray(p[key2]) || (p[key2] = [p[key2]]) : p[key2] = [];
          }
          Array.isArray(p[key2]) ? p[key2].push(value) : p[key2] = value;
        }
      }
    }
  }), Object.keys(out).filter(function(k, _2, __) {
    if (!out[k] || typeof out[k] != "object" || Array.isArray(out[k]))
      return !1;
    var parts = dotSplit$1(k), p2 = out, l = parts.pop(), nl = l.replace(/\\\./g, ".");
    return parts.forEach(function(part, _3, __2) {
      part !== "__proto__" && ((!p2[part] || typeof p2[part] != "object") && (p2[part] = {}), p2 = p2[part]);
    }), p2 === out && nl === l ? !1 : (p2[nl] = out[k], !0);
  }).forEach(function(del, _2, __) {
    delete out[del];
  }), out;
}
function isQuoted$1(val) {
  return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
}
function safe$1(val) {
  return typeof val != "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted$1(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
}
function unsafe$1(val, doUnesc) {
  if (val = (val || "").trim(), isQuoted$1(val)) {
    val.charAt(0) === "'" && (val = val.substr(1, val.length - 2));
    try {
      val = JSON.parse(val);
    } catch {
    }
  } else {
    for (var esc = !1, unesc = "", i2 = 0, l = val.length; i2 < l; i2++) {
      var c2 = val.charAt(i2);
      if (esc)
        "\\;#".indexOf(c2) !== -1 ? unesc += c2 : unesc += "\\" + c2, esc = !1;
      else {
        if (";#".indexOf(c2) !== -1)
          break;
        c2 === "\\" ? esc = !0 : unesc += c2;
      }
    }
    return esc && (unesc += "\\"), unesc.trim();
  }
  return val;
}
var singleComment = 1, multiComment = 2;
function stripWithoutWhitespace() {
  return "";
}
function stripWithWhitespace(str2, start, end2) {
  return str2.slice(start, end2).replace(/\S/g, " ");
}
var stripJsonComments$1 = function(str2, opts) {
  opts = opts || {};
  for (var currentChar, nextChar, insideString = !1, insideComment = !1, offset = 0, ret = "", strip = opts.whitespace === !1 ? stripWithoutWhitespace : stripWithWhitespace, i2 = 0; i2 < str2.length; i2++) {
    if (currentChar = str2[i2], nextChar = str2[i2 + 1], !insideComment && currentChar === '"') {
      var escaped = str2[i2 - 1] === "\\" && str2[i2 - 2] !== "\\";
      escaped || (insideString = !insideString);
    }
    if (!insideString) {
      if (!insideComment && currentChar + nextChar === "//")
        ret += str2.slice(offset, i2), offset = i2, insideComment = singleComment, i2++;
      else if (insideComment === singleComment && currentChar + nextChar === `\r
`) {
        i2++, insideComment = !1, ret += strip(str2, offset, i2), offset = i2;
        continue;
      } else if (insideComment === singleComment && currentChar === `
`)
        insideComment = !1, ret += strip(str2, offset, i2), offset = i2;
      else if (!insideComment && currentChar + nextChar === "/*") {
        ret += str2.slice(offset, i2), offset = i2, insideComment = multiComment, i2++;
        continue;
      } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
        i2++, insideComment = !1, ret += strip(str2, offset, i2 + 1), offset = i2 + 1;
        continue;
      }
    }
  }
  return ret + (insideComment ? strip(str2.substr(offset)) : str2.substr(offset));
}, fs$m = require$$0__default$1.default, ini$4 = ini$5, path$r = require$$0__default.default, stripJsonComments = stripJsonComments$1, parse$e = utils$b.parse = function(content) {
  return /^\s*{/.test(content) ? JSON.parse(stripJsonComments(content)) : ini$4.parse(content);
}, file = utils$b.file = function() {
  var args = [].slice.call(arguments).filter(function(arg) {
    return arg != null;
  });
  for (var i2 in args)
    if (typeof args[i2] != "string")
      return;
  var file2 = path$r.join.apply(null, args);
  try {
    return fs$m.readFileSync(file2, "utf-8");
  } catch {
    return;
  }
};
utils$b.json = function() {
  var content = file.apply(null, arguments);
  return content ? parse$e(content) : null;
};
utils$b.env = function(prefix, env) {
  env = env || process.env;
  var obj = {}, l = prefix.length;
  for (var k in env)
    if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
      for (var keypath = k.substring(l).split("__"), _emptyStringIndex; (_emptyStringIndex = keypath.indexOf("")) > -1; )
        keypath.splice(_emptyStringIndex, 1);
      var cursor = obj;
      keypath.forEach(function(_subkey, i2) {
        !_subkey || typeof cursor != "object" || (i2 === keypath.length - 1 && (cursor[_subkey] = env[k]), cursor[_subkey] === void 0 && (cursor[_subkey] = {}), cursor = cursor[_subkey]);
      });
    }
  return obj;
};
utils$b.find = function() {
  var rel = path$r.join.apply(null, [].slice.call(arguments));
  function find2(start, rel2) {
    var file2 = path$r.join(start, rel2);
    try {
      return fs$m.statSync(file2), file2;
    } catch {
      if (path$r.dirname(start) !== start)
        return find2(path$r.dirname(start), rel2);
    }
  }
  return find2(process.cwd(), rel);
};
var deepExtend$2 = { exports: {} };
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function isSpecificValue(val) {
  return val instanceof Buffer || val instanceof Date || val instanceof RegExp;
}
function cloneSpecificValue(val) {
  if (val instanceof Buffer) {
    var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
    return val.copy(x), x;
  } else {
    if (val instanceof Date)
      return new Date(val.getTime());
    if (val instanceof RegExp)
      return new RegExp(val);
    throw new Error("Unexpected situation");
  }
}
function deepCloneArray(arr) {
  var clone2 = [];
  return arr.forEach(function(item, index) {
    typeof item == "object" && item !== null ? Array.isArray(item) ? clone2[index] = deepCloneArray(item) : isSpecificValue(item) ? clone2[index] = cloneSpecificValue(item) : clone2[index] = deepExtend$1({}, item) : clone2[index] = item;
  }), clone2;
}
function safeGetProperty(object, property) {
  return property === "__proto__" ? void 0 : object[property];
}
var deepExtend$1 = deepExtend$2.exports = function() {
  if (arguments.length < 1 || typeof arguments[0] != "object")
    return !1;
  if (arguments.length < 2)
    return arguments[0];
  var target = arguments[0], args = Array.prototype.slice.call(arguments, 1), val, src2;
  return args.forEach(function(obj) {
    typeof obj != "object" || obj === null || Array.isArray(obj) || Object.keys(obj).forEach(function(key2) {
      if (src2 = safeGetProperty(target, key2), val = safeGetProperty(obj, key2), val !== target)
        if (typeof val != "object" || val === null) {
          target[key2] = val;
          return;
        } else if (Array.isArray(val)) {
          target[key2] = deepCloneArray(val);
          return;
        } else if (isSpecificValue(val)) {
          target[key2] = cloneSpecificValue(val);
          return;
        } else if (typeof src2 != "object" || src2 === null || Array.isArray(src2)) {
          target[key2] = deepExtend$1({}, val);
          return;
        } else {
          target[key2] = deepExtend$1(src2, val);
          return;
        }
    });
  }), target;
}, deepExtendExports = deepExtend$2.exports;
function hasKey$1(obj, keys) {
  var o = obj;
  keys.slice(0, -1).forEach(function(key3) {
    o = o[key3] || {};
  });
  var key2 = keys[keys.length - 1];
  return key2 in o;
}
function isNumber$4(x) {
  return typeof x == "number" || /^0x[0-9a-f]+$/i.test(x) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
function isConstructorOrProto(obj, key2) {
  return key2 === "constructor" && typeof obj[key2] == "function" || key2 === "__proto__";
}
var minimist = function(args, opts) {
  opts || (opts = {});
  var flags = {
    bools: {},
    strings: {},
    unknownFn: null
  };
  typeof opts.unknown == "function" && (flags.unknownFn = opts.unknown), typeof opts.boolean == "boolean" && opts.boolean ? flags.allBools = !0 : [].concat(opts.boolean).filter(Boolean).forEach(function(key3) {
    flags.bools[key3] = !0;
  });
  var aliases2 = {};
  function aliasIsBoolean(key3) {
    return aliases2[key3].some(function(x) {
      return flags.bools[x];
    });
  }
  Object.keys(opts.alias || {}).forEach(function(key3) {
    aliases2[key3] = [].concat(opts.alias[key3]), aliases2[key3].forEach(function(x) {
      aliases2[x] = [key3].concat(aliases2[key3].filter(function(y) {
        return x !== y;
      }));
    });
  }), [].concat(opts.string).filter(Boolean).forEach(function(key3) {
    flags.strings[key3] = !0, aliases2[key3] && [].concat(aliases2[key3]).forEach(function(k) {
      flags.strings[k] = !0;
    });
  });
  var defaults2 = opts.default || {}, argv = { _: [] };
  function argDefined(key3, arg2) {
    return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key3] || flags.bools[key3] || aliases2[key3];
  }
  function setKey(obj, keys, value2) {
    for (var o = obj, i3 = 0; i3 < keys.length - 1; i3++) {
      var key3 = keys[i3];
      if (isConstructorOrProto(o, key3))
        return;
      o[key3] === void 0 && (o[key3] = {}), (o[key3] === Object.prototype || o[key3] === Number.prototype || o[key3] === String.prototype) && (o[key3] = {}), o[key3] === Array.prototype && (o[key3] = []), o = o[key3];
    }
    var lastKey = keys[keys.length - 1];
    isConstructorOrProto(o, lastKey) || ((o === Object.prototype || o === Number.prototype || o === String.prototype) && (o = {}), o === Array.prototype && (o = []), o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] == "boolean" ? o[lastKey] = value2 : Array.isArray(o[lastKey]) ? o[lastKey].push(value2) : o[lastKey] = [o[lastKey], value2]);
  }
  function setArg(key3, val, arg2) {
    if (!(arg2 && flags.unknownFn && !argDefined(key3, arg2) && flags.unknownFn(arg2) === !1)) {
      var value2 = !flags.strings[key3] && isNumber$4(val) ? Number(val) : val;
      setKey(argv, key3.split("."), value2), (aliases2[key3] || []).forEach(function(x) {
        setKey(argv, x.split("."), value2);
      });
    }
  }
  Object.keys(flags.bools).forEach(function(key3) {
    setArg(key3, defaults2[key3] === void 0 ? !1 : defaults2[key3]);
  });
  var notFlags = [];
  args.indexOf("--") !== -1 && (notFlags = args.slice(args.indexOf("--") + 1), args = args.slice(0, args.indexOf("--")));
  for (var i2 = 0; i2 < args.length; i2++) {
    var arg = args[i2], key2, next;
    if (/^--.+=/.test(arg)) {
      var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
      key2 = m[1];
      var value = m[2];
      flags.bools[key2] && (value = value !== "false"), setArg(key2, value, arg);
    } else if (/^--no-.+/.test(arg))
      key2 = arg.match(/^--no-(.+)/)[1], setArg(key2, !1, arg);
    else if (/^--.+/.test(arg))
      key2 = arg.match(/^--(.+)/)[1], next = args[i2 + 1], next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key2] && !flags.allBools && (!aliases2[key2] || !aliasIsBoolean(key2)) ? (setArg(key2, next, arg), i2 += 1) : /^(true|false)$/.test(next) ? (setArg(key2, next === "true", arg), i2 += 1) : setArg(key2, flags.strings[key2] ? "" : !0, arg);
    else if (/^-[^-]+/.test(arg)) {
      for (var letters = arg.slice(1, -1).split(""), broken = !1, j = 0; j < letters.length; j++) {
        if (next = arg.slice(j + 2), next === "-") {
          setArg(letters[j], next, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
          setArg(letters[j], next.slice(1), arg), broken = !0;
          break;
        }
        if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next, arg), broken = !0;
          break;
        }
        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], arg.slice(j + 2), arg), broken = !0;
          break;
        } else
          setArg(letters[j], flags.strings[letters[j]] ? "" : !0, arg);
      }
      key2 = arg.slice(-1)[0], !broken && key2 !== "-" && (args[i2 + 1] && !/^(-|--)[^-]/.test(args[i2 + 1]) && !flags.bools[key2] && (!aliases2[key2] || !aliasIsBoolean(key2)) ? (setArg(key2, args[i2 + 1], arg), i2 += 1) : args[i2 + 1] && /^(true|false)$/.test(args[i2 + 1]) ? (setArg(key2, args[i2 + 1] === "true", arg), i2 += 1) : setArg(key2, flags.strings[key2] ? "" : !0, arg));
    } else if ((!flags.unknownFn || flags.unknownFn(arg) !== !1) && argv._.push(flags.strings._ || !isNumber$4(arg) ? arg : Number(arg)), opts.stopEarly) {
      argv._.push.apply(argv._, args.slice(i2 + 1));
      break;
    }
  }
  return Object.keys(defaults2).forEach(function(k) {
    hasKey$1(argv, k.split(".")) || (setKey(argv, k.split("."), defaults2[k]), (aliases2[k] || []).forEach(function(x) {
      setKey(argv, x.split("."), defaults2[k]);
    }));
  }), opts["--"] ? argv["--"] = notFlags.slice() : notFlags.forEach(function(k) {
    argv._.push(k);
  }), argv;
}, minimist$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(minimist), cc = utils$b, join = require$$0__default.default.join, deepExtend = deepExtendExports, etc = "/etc", win$1 = process.platform === "win32", home = win$1 ? process.env.USERPROFILE : process.env.HOME, rc$1 = function(name, defaults2, argv, parse3) {
  if (typeof name != "string")
    throw new Error("rc(name): name *must* be string");
  argv || (argv = minimist(process.argv.slice(2))), defaults2 = (typeof defaults2 == "string" ? cc.json(defaults2) : defaults2) || {}, parse3 = parse3 || cc.parse;
  var env = cc.env(name + "_"), configs = [defaults2], configFiles = [];
  function addConfigFile(file2) {
    if (!(configFiles.indexOf(file2) >= 0)) {
      var fileConfig = cc.file(file2);
      fileConfig && (configs.push(parse3(fileConfig)), configFiles.push(file2));
    }
  }
  return win$1 || [
    join(etc, name, "config"),
    join(etc, name + "rc")
  ].forEach(addConfigFile), home && [
    join(home, ".config", name, "config"),
    join(home, ".config", name),
    join(home, "." + name, "config"),
    join(home, "." + name + "rc")
  ].forEach(addConfigFile), addConfigFile(cc.find("." + name + "rc")), env.config && addConfigFile(env.config), argv.config && addConfigFile(argv.config), deepExtend.apply(null, configs.concat([
    env,
    argv,
    configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
  ]));
};
const rc = rc$1, registryUrl$1 = (scope2) => {
  const result = rc("npm", { registry: "https://registry.npmjs.org/" }), url2 = result[`${scope2}:registry`] || result.config_registry || result.registry;
  return url2.slice(-1) === "/" ? url2 : `${url2}/`;
};
registryUrl$2.exports = registryUrl$1;
registryUrl$2.exports.default = registryUrl$1;
var registryUrlExports = registryUrl$2.exports, npmConf$1 = { exports: {} }, dist$4 = {}, caFile = {}, constants$5 = require$$0__default$3.default, origCwd$1 = process.cwd, cwd$1 = null, platform$3 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return cwd$1 || (cwd$1 = origCwd$1.call(process)), cwd$1;
};
try {
  process.cwd();
} catch {
}
if (typeof process.chdir == "function") {
  var chdir$1 = process.chdir;
  process.chdir = function(d) {
    cwd$1 = null, chdir$1.call(process, d);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir$1);
}
var polyfills$3 = patch$3;
function patch$3(fs2) {
  constants$5.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs2), fs2.lutimes || patchLutimes(fs2), fs2.chown = chownFix(fs2.chown), fs2.fchown = chownFix(fs2.fchown), fs2.lchown = chownFix(fs2.lchown), fs2.chmod = chmodFix(fs2.chmod), fs2.fchmod = chmodFix(fs2.fchmod), fs2.lchmod = chmodFix(fs2.lchmod), fs2.chownSync = chownFixSync(fs2.chownSync), fs2.fchownSync = chownFixSync(fs2.fchownSync), fs2.lchownSync = chownFixSync(fs2.lchownSync), fs2.chmodSync = chmodFixSync(fs2.chmodSync), fs2.fchmodSync = chmodFixSync(fs2.fchmodSync), fs2.lchmodSync = chmodFixSync(fs2.lchmodSync), fs2.stat = statFix(fs2.stat), fs2.fstat = statFix(fs2.fstat), fs2.lstat = statFix(fs2.lstat), fs2.statSync = statFixSync(fs2.statSync), fs2.fstatSync = statFixSync(fs2.fstatSync), fs2.lstatSync = statFixSync(fs2.lstatSync), fs2.chmod && !fs2.lchmod && (fs2.lchmod = function(path2, mode2, cb) {
    cb && process.nextTick(cb);
  }, fs2.lchmodSync = function() {
  }), fs2.chown && !fs2.lchown && (fs2.lchown = function(path2, uid, gid, cb) {
    cb && process.nextTick(cb);
  }, fs2.lchownSync = function() {
  }), platform$3 === "win32" && (fs2.rename = typeof fs2.rename != "function" ? fs2.rename : function(fs$rename) {
    function rename(from2, to, cb) {
      var start = Date.now(), backoff = 0;
      fs$rename(from2, to, function CB(er) {
        if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
          setTimeout(function() {
            fs2.stat(to, function(stater, st) {
              stater && stater.code === "ENOENT" ? fs$rename(from2, to, CB) : cb(er);
            });
          }, backoff), backoff < 100 && (backoff += 10);
          return;
        }
        cb && cb(er);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(rename, fs$rename), rename;
  }(fs2.rename)), fs2.read = typeof fs2.read != "function" ? fs2.read : function(fs$read) {
    function read2(fd, buffer2, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ == "function") {
        var eagCounter = 0;
        callback = function(er, _2, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10)
            return eagCounter++, fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(read2, fs$read), read2;
  }(fs2.read), fs2.readSync = typeof fs2.readSync != "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer2, offset, length, position) {
      for (var eagCounter = 0; ; )
        try {
          return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode2, callback) {
      fs3.open(
        path2,
        constants$5.O_WRONLY | constants$5.O_SYMLINK,
        mode2,
        function(err, fd) {
          if (err) {
            callback && callback(err);
            return;
          }
          fs3.fchmod(fd, mode2, function(err2) {
            fs3.close(fd, function(err22) {
              callback && callback(err2 || err22);
            });
          });
        }
      );
    }, fs3.lchmodSync = function(path2, mode2) {
      var fd = fs3.openSync(path2, constants$5.O_WRONLY | constants$5.O_SYMLINK, mode2), threw = !0, ret;
      try {
        ret = fs3.fchmodSync(fd, mode2), threw = !1;
      } finally {
        if (threw)
          try {
            fs3.closeSync(fd);
          } catch {
          }
        else
          fs3.closeSync(fd);
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    constants$5.hasOwnProperty("O_SYMLINK") && fs3.futimes ? (fs3.lutimes = function(path2, at, mt, cb) {
      fs3.open(path2, constants$5.O_SYMLINK, function(er, fd) {
        if (er) {
          cb && cb(er);
          return;
        }
        fs3.futimes(fd, at, mt, function(er2) {
          fs3.close(fd, function(er22) {
            cb && cb(er2 || er22);
          });
        });
      });
    }, fs3.lutimesSync = function(path2, at, mt) {
      var fd = fs3.openSync(path2, constants$5.O_SYMLINK), ret, threw = !0;
      try {
        ret = fs3.futimesSync(fd, at, mt), threw = !1;
      } finally {
        if (threw)
          try {
            fs3.closeSync(fd);
          } catch {
          }
        else
          fs3.closeSync(fd);
      }
      return ret;
    }) : fs3.futimes && (fs3.lutimes = function(_a, _b, _c, cb) {
      cb && process.nextTick(cb);
    }, fs3.lutimesSync = function() {
    });
  }
  function chmodFix(orig) {
    return orig && function(target, mode2, cb) {
      return orig.call(fs2, target, mode2, function(er) {
        chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    return orig && function(target, mode2) {
      try {
        return orig.call(fs2, target, mode2);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function chownFix(orig) {
    return orig && function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    return orig && function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function statFix(orig) {
    return orig && function(target, options2, cb) {
      typeof options2 == "function" && (cb = options2, options2 = null);
      function callback(er, stats) {
        stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
      }
      return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    return orig && function(target, options2) {
      var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
      return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
    };
  }
  function chownErOk(er) {
    if (!er || er.code === "ENOSYS")
      return !0;
    var nonroot = !process.getuid || process.getuid() !== 0;
    return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
  }
}
var Stream$2 = require$$0__default$4.default.Stream, legacyStreams$1 = legacy$3;
function legacy$3(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options2) {
    if (!(this instanceof ReadStream)) return new ReadStream(path2, options2);
    Stream$2.call(this);
    var self2 = this;
    this.path = path2, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options2 = options2 || {};
    for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options2[key2];
    }
    if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end)
        throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err), self2.readable = !1;
        return;
      }
      self2.fd = fd, self2.emit("open", fd), self2._read();
    });
  }
  function WriteStream(path2, options2) {
    if (!(this instanceof WriteStream)) return new WriteStream(path2, options2);
    Stream$2.call(this), this.path = path2, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options2 = options2 || {};
    for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options2[key2];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0)
        throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    this.busy = !1, this._queue = [], this.fd === null && (this._open = fs2.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
  }
}
var clone_1$1 = clone$5, getPrototypeOf$1 = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$5(obj) {
  if (obj === null || typeof obj != "object")
    return obj;
  if (obj instanceof Object)
    var copy3 = { __proto__: getPrototypeOf$1(obj) };
  else
    var copy3 = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(obj).forEach(function(key2) {
    Object.defineProperty(copy3, key2, Object.getOwnPropertyDescriptor(obj, key2));
  }), copy3;
}
var fs$l = require$$0__default$1.default, polyfills$2 = polyfills$3, legacy$2 = legacyStreams$1, clone$4 = clone_1$1, util$a = require$$0__default$5.default, gracefulQueue$1, previousSymbol$1;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue$1 = Symbol.for("graceful-fs.queue"), previousSymbol$1 = Symbol.for("graceful-fs.previous")) : (gracefulQueue$1 = "___graceful-fs.queue", previousSymbol$1 = "___graceful-fs.previous");
function noop$4() {
}
function publishQueue$1(context, queue2) {
  Object.defineProperty(context, gracefulQueue$1, {
    get: function() {
      return queue2;
    }
  });
}
var debug$4 = noop$4;
util$a.debuglog ? debug$4 = util$a.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug$4 = function() {
  var m = util$a.format.apply(util$a, arguments);
  m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
});
if (!fs$l[gracefulQueue$1]) {
  var queue$2 = loadEnv.commonjsGlobal[gracefulQueue$1] || [];
  publishQueue$1(fs$l, queue$2), fs$l.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$l, fd, function(err) {
        err || resetQueue$1(), typeof cb == "function" && cb.apply(this, arguments);
      });
    }
    return Object.defineProperty(close, previousSymbol$1, {
      value: fs$close
    }), close;
  }(fs$l.close), fs$l.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$l, arguments), resetQueue$1();
    }
    return Object.defineProperty(closeSync, previousSymbol$1, {
      value: fs$closeSync
    }), closeSync;
  }(fs$l.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    debug$4(fs$l[gracefulQueue$1]), require$$5__default.default.equal(fs$l[gracefulQueue$1].length, 0);
  });
}
loadEnv.commonjsGlobal[gracefulQueue$1] || publishQueue$1(loadEnv.commonjsGlobal, fs$l[gracefulQueue$1]);
var gracefulFs$1 = patch$2(clone$4(fs$l));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$l.__patched && (gracefulFs$1 = patch$2(fs$l), fs$l.__patched = !0);
function patch$2(fs2) {
  polyfills$2(fs2), fs2.gracefulify = patch$2, fs2.createReadStream = createReadStream, fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options2, cb) {
    return typeof options2 == "function" && (cb = options2, options2 = null), go$readFile(path2, options2, cb);
    function go$readFile(path3, options3, cb2, startTime) {
      return fs$readFile(path3, options3, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue$1([go$readFile, [path3, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options2, cb) {
    return typeof options2 == "function" && (cb = options2, options2 = null), go$writeFile(path2, data, options2, cb);
    function go$writeFile(path3, data2, options3, cb2, startTime) {
      return fs$writeFile(path3, data2, options3, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue$1([go$writeFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  fs$appendFile && (fs2.appendFile = appendFile);
  function appendFile(path2, data, options2, cb) {
    return typeof options2 == "function" && (cb = options2, options2 = null), go$appendFile(path2, data, options2, cb);
    function go$appendFile(path3, data2, options3, cb2, startTime) {
      return fs$appendFile(path3, data2, options3, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue$1([go$appendFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  fs$copyFile && (fs2.copyFile = copyFile);
  function copyFile(src2, dest, flags, cb) {
    return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src3, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src3, dest2, flags2, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue$1([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir(path2, options2, cb) {
    typeof options2 == "function" && (cb = options2, options2 = null);
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path3, options3, cb2, startTime) {
      return fs$readdir(path3, fs$readdirCallback(
        path3,
        options3,
        cb2,
        startTime
      ));
    } : function(path3, options3, cb2, startTime) {
      return fs$readdir(path3, options3, fs$readdirCallback(
        path3,
        options3,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options2, cb);
    function fs$readdirCallback(path3, options3, cb2, startTime) {
      return function(err, files) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue$1([
          go$readdir,
          [path3, options3, cb2],
          err,
          startTime || Date.now(),
          Date.now()
        ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy$2(fs2);
    ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
  var fs$WriteStream = fs2.WriteStream;
  fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: !0,
    configurable: !0
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: !0,
    configurable: !0
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: !0,
    configurable: !0
  });
  function ReadStream(path2, options2) {
    return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
    });
  }
  function WriteStream(path2, options2) {
    return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
    });
  }
  function createReadStream(path2, options2) {
    return new fs2.ReadStream(path2, options2);
  }
  function createWriteStream(path2, options2) {
    return new fs2.WriteStream(path2, options2);
  }
  var fs$open = fs2.open;
  fs2.open = open2;
  function open2(path2, flags, mode2, cb) {
    return typeof mode2 == "function" && (cb = mode2, mode2 = null), go$open(path2, flags, mode2, cb);
    function go$open(path3, flags2, mode3, cb2, startTime) {
      return fs$open(path3, flags2, mode3, function(err, fd) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue$1([go$open, [path3, flags2, mode3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  return fs2;
}
function enqueue$1(elem) {
  debug$4("ENQUEUE", elem[0].name, elem[1]), fs$l[gracefulQueue$1].push(elem), retry$3();
}
var retryTimer$1;
function resetQueue$1() {
  for (var now = Date.now(), i2 = 0; i2 < fs$l[gracefulQueue$1].length; ++i2)
    fs$l[gracefulQueue$1][i2].length > 2 && (fs$l[gracefulQueue$1][i2][3] = now, fs$l[gracefulQueue$1][i2][4] = now);
  retry$3();
}
function retry$3() {
  if (clearTimeout(retryTimer$1), retryTimer$1 = void 0, fs$l[gracefulQueue$1].length !== 0) {
    var elem = fs$l[gracefulQueue$1].shift(), fn2 = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
    if (startTime === void 0)
      debug$4("RETRY", fn2.name, args), fn2.apply(null, args);
    else if (Date.now() - startTime >= 6e4) {
      debug$4("TIMEOUT", fn2.name, args);
      var cb = args.pop();
      typeof cb == "function" && cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
      sinceAttempt >= desiredDelay ? (debug$4("RETRY", fn2.name, args), fn2.apply(null, args.concat([startTime]))) : fs$l[gracefulQueue$1].push(elem);
    }
    retryTimer$1 === void 0 && (retryTimer$1 = setTimeout(retry$3, 0));
  }
}
var __importDefault$9 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(caFile, "__esModule", { value: !0 });
caFile.readCAFileSync = void 0;
const graceful_fs_1 = __importDefault$9(gracefulFs$1);
function readCAFileSync$1(filePath) {
  try {
    const contents = graceful_fs_1.default.readFileSync(filePath, "utf8"), delim = "-----END CERTIFICATE-----";
    return contents.split(delim).filter((ca) => !!ca.trim()).map((ca) => `${ca.trimLeft()}${delim}`);
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
}
caFile.readCAFileSync = readCAFileSync$1;
(function(exports2) {
  var __createBinding2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    k2 === void 0 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
      return m[k];
    } }), Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), o[k2] = m[k];
  }), __exportStar2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: !0 }), __exportStar2(caFile, exports2);
})(dist$4);
var configChain = { exports: {} }, protoList = ProtoList$1;
function setProto(obj, proto) {
  if (typeof Object.setPrototypeOf == "function")
    return Object.setPrototypeOf(obj, proto);
  obj.__proto__ = proto;
}
function ProtoList$1() {
  this.list = [];
  var root2 = null;
  Object.defineProperty(this, "root", {
    get: function() {
      return root2;
    },
    set: function(r) {
      root2 = r, this.list.length && setProto(this.list[this.list.length - 1], r);
    },
    enumerable: !0,
    configurable: !0
  });
}
ProtoList$1.prototype = {
  get length() {
    return this.list.length;
  },
  get keys() {
    var k = [];
    for (var i2 in this.list[0]) k.push(i2);
    return k;
  },
  get snapshot() {
    var o = {};
    return this.keys.forEach(function(k) {
      o[k] = this.get(k);
    }, this), o;
  },
  get store() {
    return this.list[0];
  },
  push: function(obj) {
    return typeof obj != "object" && (obj = { valueOf: obj }), this.list.length >= 1 && setProto(this.list[this.list.length - 1], obj), setProto(obj, this.root), this.list.push(obj);
  },
  pop: function() {
    return this.list.length >= 2 && setProto(this.list[this.list.length - 2], this.root), this.list.pop();
  },
  unshift: function(obj) {
    return setProto(obj, this.list[0] || this.root), this.list.unshift(obj);
  },
  shift: function() {
    return this.list.length === 1 && setProto(this.list[0], this.root), this.list.shift();
  },
  get: function(key2) {
    return this.list[0][key2];
  },
  set: function(key2, val, save) {
    return this.length || this.push({}), save && this.list[0].hasOwnProperty(key2) && this.push({}), this.list[0][key2] = val;
  },
  forEach: function(fn2, thisp) {
    for (var key2 in this.list[0]) fn2.call(thisp, key2, this.list[0][key2]);
  },
  slice: function() {
    return this.list.slice.apply(this.list, arguments);
  },
  splice: function() {
    for (var ret = this.list.splice.apply(this.list, arguments), i2 = 0, l = this.list.length; i2 < l; i2++)
      setProto(this.list[i2], this.list[i2 + 1] || this.root);
    return ret;
  }
};
var ProtoList = protoList, path$q = require$$0__default.default, fs$k = require$$0__default$1.default, ini$3 = ini$5, EE$1 = require$$3__default.default.EventEmitter, url$2 = require$$0__default$6.default, http = require$$6__default.default, exports$1 = configChain.exports = function() {
  for (var args = [].slice.call(arguments), conf2 = new ConfigChain$1(); args.length; ) {
    var a = args.shift();
    a && conf2.push(typeof a == "string" ? json$3(a) : a);
  }
  return conf2;
};
exports$1.find = function() {
  var rel = path$q.join.apply(null, [].slice.call(arguments));
  function find2(start, rel2) {
    var file2 = path$q.join(start, rel2);
    try {
      return fs$k.statSync(file2), file2;
    } catch {
      if (path$q.dirname(start) !== start)
        return find2(path$q.dirname(start), rel2);
    }
  }
  return find2(__dirname, rel);
};
var parse$d = exports$1.parse = function(content, file2, type2) {
  if (content = "" + content, type2)
    if (type2 === "json")
      if (this.emit)
        try {
          return JSON.parse(content);
        } catch (er) {
          this.emit("error", er);
        }
      else
        return JSON.parse(content);
    else
      return ini$3.parse(content);
  else try {
    return JSON.parse(content);
  } catch {
    return ini$3.parse(content);
  }
}, json$3 = exports$1.json = function() {
  var args = [].slice.call(arguments).filter(function(arg) {
    return arg != null;
  }), file2 = path$q.join.apply(null, args), content;
  try {
    content = fs$k.readFileSync(file2, "utf-8");
  } catch {
    return;
  }
  return parse$d(content, file2, "json");
};
exports$1.env = function(prefix, env) {
  env = env || process.env;
  var obj = {}, l = prefix.length;
  for (var k in env)
    k.indexOf(prefix) === 0 && (obj[k.substring(l)] = env[k]);
  return obj;
};
exports$1.ConfigChain = ConfigChain$1;
function ConfigChain$1() {
  EE$1.apply(this), ProtoList.apply(this, arguments), this._awaiting = 0, this._saving = 0, this.sources = {};
}
var extras = {
  constructor: { value: ConfigChain$1 }
};
Object.keys(EE$1.prototype).forEach(function(k) {
  extras[k] = Object.getOwnPropertyDescriptor(EE$1.prototype, k);
});
ConfigChain$1.prototype = Object.create(ProtoList.prototype, extras);
ConfigChain$1.prototype.del = function(key2, where) {
  if (where) {
    var target = this.sources[where];
    if (target = target && target.data, !target)
      return this.emit("error", new Error("not found " + where));
    delete target[key2];
  } else
    for (var i2 = 0, l = this.list.length; i2 < l; i2++)
      delete this.list[i2][key2];
  return this;
};
ConfigChain$1.prototype.set = function(key2, value, where) {
  var target;
  if (where) {
    if (target = this.sources[where], target = target && target.data, !target)
      return this.emit("error", new Error("not found " + where));
  } else if (target = this.list[0], !target)
    return this.emit("error", new Error("cannot set, no confs!"));
  return target[key2] = value, this;
};
ConfigChain$1.prototype.get = function(key2, where) {
  return where ? (where = this.sources[where], where && (where = where.data), where && Object.hasOwnProperty.call(where, key2) ? where[key2] : void 0) : this.list[0][key2];
};
ConfigChain$1.prototype.save = function(where, type2, cb) {
  typeof type2 == "function" && (cb = type2, type2 = null);
  var target = this.sources[where];
  if (!target || !(target.path || target.source) || !target.data)
    return this.emit("error", new Error("bad save target: " + where));
  if (target.source) {
    var pref = target.prefix || "";
    return Object.keys(target.data).forEach(function(k) {
      target.source[pref + k] = target.data[k];
    }), this;
  }
  var type2 = type2 || target.type, data = target.data;
  return target.type === "json" ? data = JSON.stringify(data) : data = ini$3.stringify(data), this._saving++, fs$k.writeFile(target.path, data, "utf8", function(er) {
    if (this._saving--, er)
      return cb ? cb(er) : this.emit("error", er);
    this._saving === 0 && (cb && cb(), this.emit("save"));
  }.bind(this)), this;
};
ConfigChain$1.prototype.addFile = function(file2, type2, name) {
  name = name || file2;
  var marker = { __source__: name };
  return this.sources[name] = { path: file2, type: type2 }, this.push(marker), this._await(), fs$k.readFile(file2, "utf8", function(er, data) {
    er && this.emit("error", er), this.addString(data, file2, type2, marker);
  }.bind(this)), this;
};
ConfigChain$1.prototype.addEnv = function(prefix, env, name) {
  name = name || "env";
  var data = exports$1.env(prefix, env);
  return this.sources[name] = { data, source: env, prefix }, this.add(data, name);
};
ConfigChain$1.prototype.addUrl = function(req, type2, name) {
  this._await();
  var href = url$2.format(req);
  name = name || href;
  var marker = { __source__: name };
  return this.sources[name] = { href, type: type2 }, this.push(marker), http.request(req, function(res) {
    var c2 = [], ct = res.headers["content-type"];
    type2 || (type2 = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null, marker.type = type2), res.on("data", c2.push.bind(c2)).on("end", function() {
      this.addString(Buffer.concat(c2), href, type2, marker);
    }.bind(this)).on("error", this.emit.bind(this, "error"));
  }.bind(this)).on("error", this.emit.bind(this, "error")).end(), this;
};
ConfigChain$1.prototype.addString = function(data, file2, type2, marker) {
  return data = this.parse(data, file2, type2), this.add(data, marker), this;
};
ConfigChain$1.prototype.add = function(data, marker) {
  if (marker && typeof marker == "object") {
    var i2 = this.list.indexOf(marker);
    if (i2 === -1)
      return this.emit("error", new Error("bad marker"));
    this.splice(i2, 1, data), marker = marker.__source__, this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data, this._resolve();
  } else
    typeof marker == "string" && (this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data), this._await(), this.push(data), process.nextTick(this._resolve.bind(this));
  return this;
};
ConfigChain$1.prototype.parse = exports$1.parse;
ConfigChain$1.prototype._await = function() {
  this._awaiting++;
};
ConfigChain$1.prototype._resolve = function() {
  this._awaiting--, this._awaiting === 0 && this.emit("load", this);
};
var configChainExports = configChain.exports, envKeyToSetting$1 = function(x) {
  const colonIndex = x.indexOf(":");
  if (colonIndex === -1)
    return normalize(x);
  const firstPart = x.substr(0, colonIndex), secondPart = x.substr(colonIndex + 1);
  return `${normalize(firstPart)}:${normalize(secondPart)}`;
};
function normalize(s) {
  if (s = s.toLowerCase(), s === "_authtoken") return "_authToken";
  let r = s[0];
  for (let i2 = 1; i2 < s.length; i2++)
    r += s[i2] === "_" ? "-" : s[i2];
  return r;
}
var util$9 = {}, dist$3 = {}, envReplace$2 = {};
Object.defineProperty(envReplace$2, "__esModule", { value: !0 });
envReplace$2.envReplace = void 0;
const ENV_EXPR = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
function envReplace$1(settingValue, env) {
  return settingValue.replace(ENV_EXPR, replaceEnvMatch.bind(null, env));
}
envReplace$2.envReplace = envReplace$1;
function replaceEnvMatch(env, orig, escape2, name) {
  if (escape2.length % 2)
    return orig.slice((escape2.length + 1) / 2);
  const envValue = getEnvValue(env, name);
  if (envValue === void 0)
    throw new Error(`Failed to replace env in config: ${orig}`);
  return `${escape2.slice(escape2.length / 2)}${envValue}`;
}
const ENV_VALUE = /([^:-]+)(:?)-(.+)/;
function getEnvValue(env, name) {
  const matched = name.match(ENV_VALUE);
  if (!matched)
    return env[name];
  const [, variableName, colon, fallback2] = matched;
  return Object.prototype.hasOwnProperty.call(env, variableName) ? !env[variableName] && colon ? fallback2 : env[variableName] : fallback2;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.envReplace = void 0;
  var env_replace_1 = envReplace$2;
  Object.defineProperty(exports2, "envReplace", { enumerable: !0, get: function() {
    return env_replace_1.envReplace;
  } });
})(dist$3);
const fs$j = require$$0__default$1.default, path$p = require$$0__default.default, { envReplace } = dist$3, parseField = (types2, field, key2) => {
  if (typeof field != "string")
    return field;
  const typeList = [].concat(types2[key2]), isPath = typeList.indexOf(path$p) !== -1, isBool = typeList.indexOf(Boolean) !== -1, isString = typeList.indexOf(String) !== -1, isNumber2 = typeList.indexOf(Number) !== -1;
  if (field = `${field}`.trim(), /^".*"$/.test(field))
    try {
      field = JSON.parse(field);
    } catch {
      throw new Error(`Failed parsing JSON config key ${key2}: ${field}`);
    }
  if (isBool && !isString && field === "")
    return !0;
  switch (field) {
    case "true":
      return !0;
    case "false":
      return !1;
    case "null":
      return null;
    case "undefined":
      return;
  }
  return field = envReplace(field, process.env), isPath && ((process.platform === "win32" ? /^~(\/|\\)/ : /^~\//).test(field) && process.env.HOME && (field = path$p.resolve(process.env.HOME, field.substr(2))), field = path$p.resolve(field)), isNumber2 && !isNaN(field) && (field = Number(field)), field;
}, findPrefix = (name) => {
  name = path$p.resolve(name);
  let walkedUp = !1;
  for (; path$p.basename(name) === "node_modules"; )
    name = path$p.dirname(name), walkedUp = !0;
  if (walkedUp)
    return name;
  const find2 = (name2, original) => {
    const regex = /^[a-zA-Z]:(\\|\/)?$/;
    if (name2 === "/" || process.platform === "win32" && regex.test(name2))
      return original;
    try {
      const files = fs$j.readdirSync(name2);
      if (files.includes("node_modules") || files.includes("package.json") || files.includes("package.json5") || files.includes("package.yaml") || files.includes("pnpm-workspace.yaml"))
        return name2;
      const dirname = path$p.dirname(name2);
      return dirname === name2 ? original : find2(dirname, original);
    } catch (error2) {
      if (name2 === original) {
        if (error2.code === "ENOENT")
          return original;
        throw error2;
      }
      return original;
    }
  };
  return find2(name, name);
};
util$9.envReplace = envReplace;
util$9.findPrefix = findPrefix;
util$9.parseField = parseField;
var types$2 = {}, hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$2;
  hasRequiredTypes$1 = 1;
  const path2 = require$$0__default.default, Stream2 = require$$0__default$4.default.Stream, url2 = require$$0__default$6.default, Umask = () => {
  }, getLocalAddresses = () => [], semver2 = () => {
  };
  return types$2.types = {
    access: [null, "restricted", "public"],
    "allow-same-version": Boolean,
    "always-auth": Boolean,
    also: [null, "dev", "development"],
    audit: Boolean,
    "auth-type": ["legacy", "sso", "saml", "oauth"],
    "bin-links": Boolean,
    browser: [null, String],
    ca: [null, String, Array],
    cafile: path2,
    cache: path2,
    "cache-lock-stale": Number,
    "cache-lock-retries": Number,
    "cache-lock-wait": Number,
    "cache-max": Number,
    "cache-min": Number,
    cert: [null, String],
    cidr: [null, String, Array],
    color: ["always", Boolean],
    depth: Number,
    description: Boolean,
    dev: Boolean,
    "dry-run": Boolean,
    editor: String,
    "engine-strict": Boolean,
    force: Boolean,
    "fetch-retries": Number,
    "fetch-retry-factor": Number,
    "fetch-retry-mintimeout": Number,
    "fetch-retry-maxtimeout": Number,
    git: String,
    "git-tag-version": Boolean,
    "commit-hooks": Boolean,
    global: Boolean,
    globalconfig: path2,
    "global-style": Boolean,
    group: [Number, String],
    "https-proxy": [null, url2],
    "user-agent": String,
    "ham-it-up": Boolean,
    heading: String,
    "if-present": Boolean,
    "ignore-prepublish": Boolean,
    "ignore-scripts": Boolean,
    "init-module": path2,
    "init-author-name": String,
    "init-author-email": String,
    "init-author-url": ["", url2],
    "init-license": String,
    "init-version": semver2,
    json: Boolean,
    key: [null, String],
    "legacy-bundling": Boolean,
    link: Boolean,
    // local-address must be listed as an IP for a local network interface
    // must be IPv4 due to node bug
    "local-address": getLocalAddresses(),
    loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
    logstream: Stream2,
    "logs-max": Number,
    long: Boolean,
    maxsockets: Number,
    message: String,
    "metrics-registry": [null, String],
    "node-options": [null, String],
    "node-version": [null, semver2],
    "no-proxy": [null, String, Array],
    offline: Boolean,
    "onload-script": [null, String],
    only: [null, "dev", "development", "prod", "production"],
    optional: Boolean,
    "package-lock": Boolean,
    otp: [null, String],
    "package-lock-only": Boolean,
    parseable: Boolean,
    "prefer-offline": Boolean,
    "prefer-online": Boolean,
    prefix: path2,
    production: Boolean,
    progress: Boolean,
    proxy: [null, !1, url2],
    provenance: Boolean,
    // allow proxy to be disabled explicitly
    "read-only": Boolean,
    "rebuild-bundle": Boolean,
    registry: [null, url2],
    rollback: Boolean,
    save: Boolean,
    "save-bundle": Boolean,
    "save-dev": Boolean,
    "save-exact": Boolean,
    "save-optional": Boolean,
    "save-prefix": String,
    "save-prod": Boolean,
    scope: String,
    "script-shell": [null, String],
    "scripts-prepend-node-path": [!1, !0, "auto", "warn-only"],
    searchopts: String,
    searchexclude: [null, String],
    searchlimit: Number,
    searchstaleness: Number,
    "send-metrics": Boolean,
    shell: String,
    shrinkwrap: Boolean,
    "sign-git-tag": Boolean,
    "sso-poll-frequency": Number,
    "sso-type": [null, "oauth", "saml"],
    "strict-ssl": Boolean,
    tag: String,
    timing: Boolean,
    tmp: path2,
    unicode: Boolean,
    "unsafe-perm": Boolean,
    usage: Boolean,
    user: [Number, String],
    userconfig: path2,
    umask: Umask,
    version: Boolean,
    "tag-version-prefix": String,
    versions: Boolean,
    viewer: String,
    _exit: Boolean
  }, types$2;
}
const { readCAFileSync } = dist$4, fs$i = require$$0__default$1.default, path$o = require$$0__default.default, { ConfigChain } = configChainExports, envKeyToSetting = envKeyToSetting$1, util$8 = util$9;
class Conf extends ConfigChain {
  // https://github.com/npm/cli/blob/latest/lib/config/core.js#L203-L217
  constructor(base2, types2) {
    super(base2), this.root = base2, this._parseField = util$8.parseField.bind(null, types2 || requireTypes$1());
  }
  // https://github.com/npm/cli/blob/latest/lib/config/core.js#L326-L338
  add(data, marker) {
    try {
      for (const x of Object.keys(data))
        data[x] = this._parseField(data[x], x);
    } catch (error2) {
      throw error2;
    }
    return super.add(data, marker);
  }
  // https://github.com/npm/cli/blob/latest/lib/config/core.js#L306-L319
  addFile(file2, name) {
    name = name || file2;
    const marker = { __source__: name };
    this.sources[name] = { path: file2, type: "ini" }, this.push(marker), this._await();
    try {
      const contents = fs$i.readFileSync(file2, "utf8");
      this.addString(contents, file2, "ini", marker);
    } catch (error2) {
      if (error2.code === "ENOENT")
        this.add({}, marker);
      else
        return `Issue while reading "${file2}". ${error2.message}`;
    }
  }
  // https://github.com/npm/cli/blob/latest/lib/config/core.js#L341-L357
  addEnv(env) {
    env = env || process.env;
    const conf2 = {};
    return Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
      env[x] && (conf2[envKeyToSetting(x.substr(11))] = env[x]);
    }), super.addEnv("", conf2, "env");
  }
  // https://github.com/npm/cli/blob/latest/lib/config/load-prefix.js
  loadPrefix() {
    const cli = this.list[0];
    Object.defineProperty(this, "prefix", {
      enumerable: !0,
      set: (prefix) => {
        const g = this.get("global");
        this[g ? "globalPrefix" : "localPrefix"] = prefix;
      },
      get: () => this.get("global") ? this.globalPrefix : this.localPrefix
    }), Object.defineProperty(this, "globalPrefix", {
      enumerable: !0,
      set: (prefix) => {
        this.set("prefix", prefix);
      },
      get: () => path$o.resolve(this.get("prefix"))
    });
    let p;
    if (Object.defineProperty(this, "localPrefix", {
      enumerable: !0,
      set: (prefix) => {
        p = prefix;
      },
      get: () => p
    }), Object.prototype.hasOwnProperty.call(cli, "prefix"))
      p = path$o.resolve(cli.prefix);
    else
      try {
        p = util$8.findPrefix(process.cwd());
      } catch (error2) {
        throw error2;
      }
    return p;
  }
  // https://github.com/npm/cli/blob/latest/lib/config/load-cafile.js
  loadCAFile(file2) {
    if (!file2)
      return;
    const ca = readCAFileSync(file2);
    ca && this.set("ca", ca);
  }
  // https://github.com/npm/cli/blob/latest/lib/config/set-user.js
  loadUser() {
    const defConf = this.root;
    if (this.get("global"))
      return;
    if (process.env.SUDO_UID) {
      defConf.user = Number(process.env.SUDO_UID);
      return;
    }
    const prefix = path$o.resolve(this.get("prefix"));
    try {
      const stats = fs$i.statSync(prefix);
      defConf.user = stats.uid;
    } catch (error2) {
      if (error2.code === "ENOENT")
        return;
      throw error2;
    }
  }
}
var conf = Conf, defaults$5 = {};
(function(exports2) {
  const os2 = require$$0__default$2.default, path2 = require$$0__default.default, temp = os2.tmpdir(), uidOrPid = process.getuid ? process.getuid() : process.pid, hasUnicode = () => !0, isWindows2 = process.platform === "win32", osenv = {
    editor: () => process.env.EDITOR || process.env.VISUAL || (isWindows2 ? "notepad.exe" : "vi"),
    shell: () => isWindows2 ? process.env.COMSPEC || "cmd.exe" : process.env.SHELL || "/bin/bash"
  }, umask = {
    fromString: () => process.umask()
  };
  let home2 = os2.homedir();
  home2 ? process.env.HOME = home2 : home2 = path2.resolve(temp, "npm-" + uidOrPid);
  const cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm", cacheRoot = process.platform === "win32" && process.env.APPDATA || home2, cache = path2.resolve(cacheRoot, cacheExtra);
  let defaults2, globalPrefix;
  Object.defineProperty(exports2, "defaults", {
    get: function() {
      return defaults2 || (process.env.PREFIX ? globalPrefix = process.env.PREFIX : process.platform === "win32" ? globalPrefix = path2.dirname(process.execPath) : (globalPrefix = path2.dirname(path2.dirname(process.execPath)), process.env.DESTDIR && (globalPrefix = path2.join(process.env.DESTDIR, globalPrefix))), defaults2 = {
        access: null,
        "allow-same-version": !1,
        "always-auth": !1,
        also: null,
        audit: !0,
        "auth-type": "legacy",
        "bin-links": !0,
        browser: null,
        ca: null,
        cafile: null,
        cache,
        "cache-lock-stale": 6e4,
        "cache-lock-retries": 10,
        "cache-lock-wait": 1e4,
        "cache-max": 1 / 0,
        "cache-min": 10,
        cert: null,
        cidr: null,
        color: process.env.NO_COLOR == null,
        depth: 1 / 0,
        description: !0,
        dev: !1,
        "dry-run": !1,
        editor: osenv.editor(),
        "engine-strict": !1,
        force: !1,
        "fetch-retries": 2,
        "fetch-retry-factor": 10,
        "fetch-retry-mintimeout": 1e4,
        "fetch-retry-maxtimeout": 6e4,
        git: "git",
        "git-tag-version": !0,
        "commit-hooks": !0,
        global: !1,
        globalconfig: path2.resolve(globalPrefix, "etc", "npmrc"),
        "global-style": !1,
        group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
        "ham-it-up": !1,
        heading: "npm",
        "if-present": !1,
        "ignore-prepublish": !1,
        "ignore-scripts": !1,
        "init-module": path2.resolve(home2, ".npm-init.js"),
        "init-author-name": "",
        "init-author-email": "",
        "init-author-url": "",
        "init-version": "1.0.0",
        "init-license": "ISC",
        json: !1,
        key: null,
        "legacy-bundling": !1,
        link: !1,
        "local-address": void 0,
        loglevel: "notice",
        logstream: process.stderr,
        "logs-max": 10,
        long: !1,
        maxsockets: 50,
        message: "%s",
        "metrics-registry": null,
        "node-options": null,
        // We remove node-version to fix the issue described here: https://github.com/pnpm/pnpm/issues/4203#issuecomment-1133872769
        offline: !1,
        "onload-script": !1,
        only: null,
        optional: !0,
        otp: null,
        "package-lock": !0,
        "package-lock-only": !1,
        parseable: !1,
        "prefer-offline": !1,
        "prefer-online": !1,
        prefix: globalPrefix,
        production: process.env.NODE_ENV === "production",
        progress: !process.env.TRAVIS && !process.env.CI,
        provenance: !1,
        proxy: null,
        "https-proxy": null,
        "no-proxy": null,
        "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
        "read-only": !1,
        "rebuild-bundle": !0,
        registry: "https://registry.npmjs.org/",
        rollback: !0,
        save: !0,
        "save-bundle": !1,
        "save-dev": !1,
        "save-exact": !1,
        "save-optional": !1,
        "save-prefix": "^",
        "save-prod": !1,
        scope: "",
        "script-shell": null,
        "scripts-prepend-node-path": "warn-only",
        searchopts: "",
        searchexclude: null,
        searchlimit: 20,
        searchstaleness: 15 * 60,
        "send-metrics": !1,
        shell: osenv.shell(),
        shrinkwrap: !0,
        "sign-git-tag": !1,
        "sso-poll-frequency": 500,
        "sso-type": "oauth",
        "strict-ssl": !0,
        tag: "latest",
        "tag-version-prefix": "v",
        timing: !1,
        tmp: temp,
        unicode: hasUnicode(),
        "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
        usage: !1,
        user: process.platform === "win32" ? 0 : "nobody",
        userconfig: path2.resolve(home2, ".npmrc"),
        umask: process.umask ? process.umask() : umask.fromString("022"),
        version: !1,
        versions: !1,
        viewer: process.platform === "win32" ? "browser" : "man",
        _exit: !0
      }, defaults2);
    }
  });
})(defaults$5);
(function(module2) {
  const path2 = require$$0__default.default, Conf2 = conf, _defaults = defaults$5;
  module2.exports = (opts, types2, defaults2) => {
    const conf2 = new Conf2(Object.assign({}, _defaults.defaults, defaults2), types2);
    conf2.add(Object.assign({}, opts), "cli");
    const warnings = [];
    let failedToLoadBuiltInConfig = !1;
    if (require.resolve.paths) {
      const paths = require.resolve.paths("npm");
      let npmPath;
      try {
        npmPath = require.resolve("npm", { paths: paths.slice(-1) });
      } catch {
        failedToLoadBuiltInConfig = !0;
      }
      npmPath && warnings.push(conf2.addFile(path2.resolve(path2.dirname(npmPath), "..", "npmrc"), "builtin"));
    }
    conf2.addEnv(), conf2.loadPrefix();
    const projectConf = path2.resolve(conf2.localPrefix, ".npmrc"), userConf = conf2.get("userconfig");
    if (!conf2.get("global") && projectConf !== userConf ? warnings.push(conf2.addFile(projectConf, "project")) : conf2.add({}, "project"), conf2.get("workspace-prefix") && conf2.get("workspace-prefix") !== projectConf) {
      const workspaceConf = path2.resolve(conf2.get("workspace-prefix"), ".npmrc");
      warnings.push(conf2.addFile(workspaceConf, "workspace"));
    }
    if (warnings.push(conf2.addFile(conf2.get("userconfig"), "user")), conf2.get("prefix")) {
      const etc2 = path2.resolve(conf2.get("prefix"), "etc");
      conf2.root.globalconfig = path2.resolve(etc2, "npmrc"), conf2.root.globalignorefile = path2.resolve(etc2, "npmignore");
    }
    warnings.push(conf2.addFile(conf2.get("globalconfig"), "global")), conf2.loadUser();
    const caFile2 = conf2.get("cafile");
    return caFile2 && conf2.loadCAFile(caFile2), {
      config: conf2,
      warnings: warnings.filter(Boolean),
      failedToLoadBuiltInConfig
    };
  }, Object.defineProperty(module2.exports, "defaults", {
    get() {
      return _defaults.defaults;
    },
    enumerable: !0
  });
})(npmConf$1);
var npmConfExports = npmConf$1.exports;
const url$1 = require$$0__default$6.default, npmConf = npmConfExports, tokenKey = ":_authToken", legacyTokenKey = ":_auth", userKey = ":username", passwordKey = ":_password";
var registryAuthToken$1 = function() {
  let checkUrl, options2;
  arguments.length >= 2 ? (checkUrl = arguments[0], options2 = Object.assign({}, arguments[1])) : typeof arguments[0] == "string" ? checkUrl = arguments[0] : options2 = Object.assign({}, arguments[0]), options2 = options2 || {};
  const providedNpmrc = options2.npmrc;
  return options2.npmrc = (options2.npmrc ? {
    config: {
      get: (key2) => providedNpmrc[key2]
    }
  } : npmConf()).config, checkUrl = checkUrl || options2.npmrc.get("registry") || npmConf.defaults.registry, getRegistryAuthInfo(checkUrl, options2) || getLegacyAuthInfo(options2.npmrc);
};
function getRegistryAuthInfo(checkUrl, options2) {
  const parsed = url$1.parse(checkUrl, !1, !0);
  let pathname;
  for (; pathname !== "/" && parsed.pathname !== pathname; ) {
    pathname = parsed.pathname || "/";
    const regUrl = "//" + parsed.host + pathname.replace(/\/$/, ""), authInfo = getAuthInfoForUrl(regUrl, options2.npmrc);
    if (authInfo)
      return authInfo;
    if (!options2.recursive)
      return /\/$/.test(checkUrl) ? void 0 : getRegistryAuthInfo(url$1.resolve(checkUrl, "."), options2);
    parsed.pathname = url$1.resolve(normalizePath$1(pathname), "..") || "/";
  }
}
function getLegacyAuthInfo(npmrc) {
  return npmrc.get("_auth") ? { token: replaceEnvironmentVariable(npmrc.get("_auth")), type: "Basic" } : void 0;
}
function normalizePath$1(path2) {
  return path2[path2.length - 1] === "/" ? path2 : path2 + "/";
}
function getAuthInfoForUrl(regUrl, npmrc) {
  const bearerAuth = getBearerToken(npmrc.get(regUrl + tokenKey) || npmrc.get(regUrl + "/" + tokenKey));
  if (bearerAuth)
    return bearerAuth;
  const username = npmrc.get(regUrl + userKey) || npmrc.get(regUrl + "/" + userKey), password2 = npmrc.get(regUrl + passwordKey) || npmrc.get(regUrl + "/" + passwordKey), basicAuth = getTokenForUsernameAndPassword(username, password2);
  if (basicAuth)
    return basicAuth;
  const basicAuthWithToken = getLegacyAuthToken(npmrc.get(regUrl + legacyTokenKey) || npmrc.get(regUrl + "/" + legacyTokenKey));
  if (basicAuthWithToken)
    return basicAuthWithToken;
}
function replaceEnvironmentVariable(token2) {
  return token2.replace(/^\$\{?([^}]*)\}?$/, function(fullMatch, envVar) {
    return process.env[envVar];
  });
}
function getBearerToken(tok) {
  return tok ? { token: replaceEnvironmentVariable(tok), type: "Bearer" } : void 0;
}
function getTokenForUsernameAndPassword(username, password2) {
  if (!username || !password2)
    return;
  const pass = Buffer.from(replaceEnvironmentVariable(password2), "base64").toString("utf8");
  return {
    token: Buffer.from(username + ":" + pass, "utf8").toString("base64"),
    type: "Basic",
    password: pass,
    username
  };
}
function getLegacyAuthToken(tok) {
  return tok ? { token: replaceEnvironmentVariable(tok), type: "Basic" } : void 0;
}
const url = require$$0__default$6.default, { getIt } = require$$1__default$1.default, { debug: debug$3, retry: retry$2, promise: promise$1, httpErrors, jsonResponse } = require$$2__default.default, registryUrl = registryUrlExports, registryAuthToken = registryAuthToken$1, semver$1 = semver__default.default, isJson = (contentType) => /(application\/json|\+json)/.test(contentType || "");
function shouldRetry(err, num, options2) {
  const response = err.response || { statusCode: 500, headers: {} };
  return (
    // allow retries on low-level errors (socket errors et al)
    retry$2.shouldRetry(err, num, options2) || // npm registry routinely fails, giving 503 and similar
    response && response.statusCode >= 500 || // npm registry sometimes returns 2xx with HTML content
    response.statusCode < 300 && !isJson(response.headers["content-type"])
  );
}
function resolveRegistryUrl(pkgName, options2) {
  if (options2.registryUrl)
    return options2.registryUrl;
  const scope2 = pkgName.split("/")[0];
  return registryUrl(scope2);
}
const httpRequest = getIt([
  jsonResponse({ force: !0 }),
  httpErrors(),
  debug$3({ namespace: "get-latest-version" }),
  promise$1(),
  retry$2({ shouldRetry })
]);
async function getLatestVersion(pkgName, opts) {
  const options2 = typeof opts == "string" ? { range: opts, auth: !0 } : Object.assign({ range: "latest", auth: !0 }, opts), regUrl = resolveRegistryUrl(pkgName, options2), pkgUrl = url.resolve(regUrl, encodeURIComponent(pkgName).replace(/^%40/, "@")), authInfo = options2.auth && registryAuthToken(regUrl, { recursive: !0 }), request2 = options2.request || httpRequest, headers = {
    accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
  };
  authInfo && (headers.authorization = `${authInfo.type} ${authInfo.token}`);
  let res;
  try {
    res = await request2({ url: pkgUrl, headers });
  } catch (err) {
    throw err.response && err.response.statusCode === 404 ? new Error(`Package \`${pkgName}\` doesn't exist`) : err;
  }
  const data = res.body, range2 = options2.range, latest = data["dist-tags"].latest;
  if (data["dist-tags"][range2])
    return options2.includeLatest ? { latest, inRange: data["dist-tags"][range2] } : data["dist-tags"][range2];
  if (data.versions[range2])
    return options2.includeLatest ? { latest, inRange: range2 } : range2;
  const versions = Object.keys(data.versions), version = semver$1.maxSatisfying(versions, range2);
  return version ? options2.includeLatest ? { latest, inRange: version } : version : options2.includeLatest ? { latest, inRange: void 0 } : void 0;
}
getLatestVersion.request = httpRequest;
var src = getLatestVersion, latestVersion = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(src);
async function getCliVersion() {
  const cliPath = pkgDir__default.default.sync(__dirname);
  if (!cliPath)
    throw new Error("Unable to resolve root of @sanity/cli module");
  let data;
  try {
    data = await fs__default$1.default.readFile(path__default.default.join(cliPath, "package.json"), "utf-8");
  } catch (err) {
    throw new Error(`Unable to read @sanity/cli/package.json: ${err.message}`);
  }
  return JSON.parse(data).version;
}
function getLocalVersion(moduleId, workDir) {
  const fromPath = workDir || process.cwd(), modulePath = resolveFrom$1.silent(fromPath, path$t.join(moduleId, "package.json"));
  if (modulePath)
    return tryGetVersion(modulePath);
  const pathSegment = path$t.normalize(moduleId), parentPath = resolveFrom$1.silent(fromPath, moduleId);
  if (!parentPath)
    return;
  const moduleRoot = parentPath.slice(0, parentPath.lastIndexOf(pathSegment) + pathSegment.length), manifestPath = path$t.join(moduleRoot, "package.json");
  return tryGetVersion(manifestPath);
}
function tryGetVersion(modulePath) {
  try {
    const fileContent = fs$p.readFileSync(modulePath, "utf8");
    return JSON.parse(fileContent).version;
  } catch {
    return;
  }
}
const PACKAGES_TO_EXCLUDE = [
  "@sanity/block-content-to-html",
  "@sanity/block-content-to-react",
  "@sanity/block-tools",
  "@sanity/client"
], defaultOptions = {
  includeCli: !0
};
async function findSanityModuleVersions(context, options2 = {}) {
  const { spinner } = context.output, { target, includeCli } = { ...defaultOptions, ...options2 }, cliVersion = await getCliVersion(), sanityModules = filterSanityModules(getLocalManifest(context.workDir)), resolveOpts = { includeCli, target }, spin = spinner("Resolving latest versions").start(), versions = await promiseProps$1(
    buildPackageArray(sanityModules, context.workDir, resolveOpts, cliVersion)
  ), packages = Object.values(versions);
  return spin.stop(), packages.map((mod) => {
    const current = mod.installed || semver__default.default.minVersion(mod.declared)?.toString() || "", needsUpdate = target === "latest" ? semverCompare$1(current, mod.latest) === -1 : typeof mod.latestInRange < "u" && mod.installed !== mod.latestInRange;
    return { ...mod, needsUpdate };
  });
}
function getLocalManifest(workDir) {
  try {
    const fileContent = fs$p.readFileSync(path$t.join(workDir, "package.json"), "utf8");
    return JSON.parse(fileContent);
  } catch {
    return {};
  }
}
function filterSanityModules(manifest) {
  const dependencies = {
    ...manifest.dependencies,
    ...manifest.devDependencies
  };
  return Object.keys(dependencies).filter((mod) => mod.startsWith("@sanity/") || mod === "sanity").filter((mod) => !PACKAGES_TO_EXCLUDE.includes(mod)).sort().reduce(
    (versions, dependency) => (versions[dependency] = dependencies[dependency], versions),
    {}
  );
}
function buildPackageArray(packages, workDir, options2 = {}, cliVersion) {
  const { includeCli, target } = options2, modules = [];
  if (includeCli) {
    const [cliMajor] = cliVersion.split("."), latest = tryFindLatestVersion("@sanity/cli", target || `^${cliMajor}`);
    modules.push({
      name: "@sanity/cli",
      declared: `^${cliVersion}`,
      installed: trimHash(cliVersion),
      latest: latest.then((versions) => versions.latest),
      latestInRange: latest.then((versions) => versions.latestInRange),
      isPinned: !1,
      isGlobal: !0
    });
  }
  return [
    ...modules,
    ...Object.keys(packages).map((pkgName) => {
      const latest = tryFindLatestVersion(pkgName, target || packages[pkgName] || "latest"), localVersion = getLocalVersion(pkgName, workDir);
      return {
        name: pkgName,
        declared: packages[pkgName],
        installed: localVersion ? trimHash(localVersion) : void 0,
        latest: latest.then((versions) => versions.latest),
        latestInRange: latest.then((versions) => versions.latestInRange),
        isPinned: isPinnedVersion(packages[pkgName]),
        isGlobal: !1
      };
    })
  ];
}
async function tryFindLatestVersion(pkgName, range2) {
  try {
    const { latest, inRange } = await latestVersion(pkgName, { range: range2, includeLatest: !0 });
    return { latest, latestInRange: inRange };
  } catch (err) {
    if (!(err instanceof Error) || !err.message.includes("No version exists"))
      throw err;
    return { latest: await latestVersion(pkgName), latestInRange: void 0 };
  }
}
function isPinnedVersion(version) {
  return /^\d+\.\d+\.\d+/.test(version);
}
function trimHash(version) {
  return version.replace(/\+[a-z0-9]{8,}$/, "");
}
const BASE_URL = "https://docs.sanity.io/help/";
function generateHelpUrl(slug) {
  return BASE_URL + slug;
}
var constants$4 = require$$0__default$3.default, origCwd = process.cwd, cwd = null, platform$2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return cwd || (cwd = origCwd.call(process)), cwd;
};
try {
  process.cwd();
} catch {
}
if (typeof process.chdir == "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null, chdir.call(process, d);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$1;
function patch$1(fs2) {
  constants$4.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs2), fs2.lutimes || patchLutimes(fs2), fs2.chown = chownFix(fs2.chown), fs2.fchown = chownFix(fs2.fchown), fs2.lchown = chownFix(fs2.lchown), fs2.chmod = chmodFix(fs2.chmod), fs2.fchmod = chmodFix(fs2.fchmod), fs2.lchmod = chmodFix(fs2.lchmod), fs2.chownSync = chownFixSync(fs2.chownSync), fs2.fchownSync = chownFixSync(fs2.fchownSync), fs2.lchownSync = chownFixSync(fs2.lchownSync), fs2.chmodSync = chmodFixSync(fs2.chmodSync), fs2.fchmodSync = chmodFixSync(fs2.fchmodSync), fs2.lchmodSync = chmodFixSync(fs2.lchmodSync), fs2.stat = statFix(fs2.stat), fs2.fstat = statFix(fs2.fstat), fs2.lstat = statFix(fs2.lstat), fs2.statSync = statFixSync(fs2.statSync), fs2.fstatSync = statFixSync(fs2.fstatSync), fs2.lstatSync = statFixSync(fs2.lstatSync), fs2.chmod && !fs2.lchmod && (fs2.lchmod = function(path2, mode2, cb) {
    cb && process.nextTick(cb);
  }, fs2.lchmodSync = function() {
  }), fs2.chown && !fs2.lchown && (fs2.lchown = function(path2, uid, gid, cb) {
    cb && process.nextTick(cb);
  }, fs2.lchownSync = function() {
  }), platform$2 === "win32" && (fs2.rename = typeof fs2.rename != "function" ? fs2.rename : function(fs$rename) {
    function rename(from2, to, cb) {
      var start = Date.now(), backoff = 0;
      fs$rename(from2, to, function CB(er) {
        if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
          setTimeout(function() {
            fs2.stat(to, function(stater, st) {
              stater && stater.code === "ENOENT" ? fs$rename(from2, to, CB) : cb(er);
            });
          }, backoff), backoff < 100 && (backoff += 10);
          return;
        }
        cb && cb(er);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(rename, fs$rename), rename;
  }(fs2.rename)), fs2.read = typeof fs2.read != "function" ? fs2.read : function(fs$read) {
    function read2(fd, buffer2, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ == "function") {
        var eagCounter = 0;
        callback = function(er, _2, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10)
            return eagCounter++, fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(read2, fs$read), read2;
  }(fs2.read), fs2.readSync = typeof fs2.readSync != "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer2, offset, length, position) {
      for (var eagCounter = 0; ; )
        try {
          return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode2, callback) {
      fs3.open(
        path2,
        constants$4.O_WRONLY | constants$4.O_SYMLINK,
        mode2,
        function(err, fd) {
          if (err) {
            callback && callback(err);
            return;
          }
          fs3.fchmod(fd, mode2, function(err2) {
            fs3.close(fd, function(err22) {
              callback && callback(err2 || err22);
            });
          });
        }
      );
    }, fs3.lchmodSync = function(path2, mode2) {
      var fd = fs3.openSync(path2, constants$4.O_WRONLY | constants$4.O_SYMLINK, mode2), threw = !0, ret;
      try {
        ret = fs3.fchmodSync(fd, mode2), threw = !1;
      } finally {
        if (threw)
          try {
            fs3.closeSync(fd);
          } catch {
          }
        else
          fs3.closeSync(fd);
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    constants$4.hasOwnProperty("O_SYMLINK") && fs3.futimes ? (fs3.lutimes = function(path2, at, mt, cb) {
      fs3.open(path2, constants$4.O_SYMLINK, function(er, fd) {
        if (er) {
          cb && cb(er);
          return;
        }
        fs3.futimes(fd, at, mt, function(er2) {
          fs3.close(fd, function(er22) {
            cb && cb(er2 || er22);
          });
        });
      });
    }, fs3.lutimesSync = function(path2, at, mt) {
      var fd = fs3.openSync(path2, constants$4.O_SYMLINK), ret, threw = !0;
      try {
        ret = fs3.futimesSync(fd, at, mt), threw = !1;
      } finally {
        if (threw)
          try {
            fs3.closeSync(fd);
          } catch {
          }
        else
          fs3.closeSync(fd);
      }
      return ret;
    }) : fs3.futimes && (fs3.lutimes = function(_a, _b, _c, cb) {
      cb && process.nextTick(cb);
    }, fs3.lutimesSync = function() {
    });
  }
  function chmodFix(orig) {
    return orig && function(target, mode2, cb) {
      return orig.call(fs2, target, mode2, function(er) {
        chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    return orig && function(target, mode2) {
      try {
        return orig.call(fs2, target, mode2);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function chownFix(orig) {
    return orig && function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    return orig && function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function statFix(orig) {
    return orig && function(target, options2, cb) {
      typeof options2 == "function" && (cb = options2, options2 = null);
      function callback(er, stats) {
        stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
      }
      return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    return orig && function(target, options2) {
      var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
      return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
    };
  }
  function chownErOk(er) {
    if (!er || er.code === "ENOSYS")
      return !0;
    var nonroot = !process.getuid || process.getuid() !== 0;
    return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
  }
}
var Stream$1 = require$$0__default$4.default.Stream, legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options2) {
    if (!(this instanceof ReadStream)) return new ReadStream(path2, options2);
    Stream$1.call(this);
    var self2 = this;
    this.path = path2, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options2 = options2 || {};
    for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options2[key2];
    }
    if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end)
        throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err), self2.readable = !1;
        return;
      }
      self2.fd = fd, self2.emit("open", fd), self2._read();
    });
  }
  function WriteStream(path2, options2) {
    if (!(this instanceof WriteStream)) return new WriteStream(path2, options2);
    Stream$1.call(this), this.path = path2, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options2 = options2 || {};
    for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options2[key2];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0)
        throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    this.busy = !1, this._queue = [], this.fd === null && (this._open = fs2.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
  }
}
var clone_1 = clone$3, getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$3(obj) {
  if (obj === null || typeof obj != "object")
    return obj;
  if (obj instanceof Object)
    var copy3 = { __proto__: getPrototypeOf(obj) };
  else
    var copy3 = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(obj).forEach(function(key2) {
    Object.defineProperty(copy3, key2, Object.getOwnPropertyDescriptor(obj, key2));
  }), copy3;
}
var fs$h = require$$0__default$1.default, polyfills = polyfills$1, legacy = legacyStreams, clone$2 = clone_1, util$7 = require$$0__default$5.default, gracefulQueue, previousSymbol;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
function noop$3() {
}
function publishQueue(context, queue2) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$2 = noop$3;
util$7.debuglog ? debug$2 = util$7.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug$2 = function() {
  var m = util$7.format.apply(util$7, arguments);
  m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
});
if (!fs$h[gracefulQueue]) {
  var queue$1 = loadEnv.commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$h, queue$1), fs$h.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$h, fd, function(err) {
        err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
      });
    }
    return Object.defineProperty(close, previousSymbol, {
      value: fs$close
    }), close;
  }(fs$h.close), fs$h.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$h, arguments), resetQueue();
    }
    return Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    }), closeSync;
  }(fs$h.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    debug$2(fs$h[gracefulQueue]), require$$5__default.default.equal(fs$h[gracefulQueue].length, 0);
  });
}
loadEnv.commonjsGlobal[gracefulQueue] || publishQueue(loadEnv.commonjsGlobal, fs$h[gracefulQueue]);
var gracefulFs = patch(clone$2(fs$h));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$h.__patched && (gracefulFs = patch(fs$h), fs$h.__patched = !0);
function patch(fs2) {
  polyfills(fs2), fs2.gracefulify = patch, fs2.createReadStream = createReadStream, fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options2, cb) {
    return typeof options2 == "function" && (cb = options2, options2 = null), go$readFile(path2, options2, cb);
    function go$readFile(path3, options3, cb2, startTime) {
      return fs$readFile(path3, options3, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path3, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options2, cb) {
    return typeof options2 == "function" && (cb = options2, options2 = null), go$writeFile(path2, data, options2, cb);
    function go$writeFile(path3, data2, options3, cb2, startTime) {
      return fs$writeFile(path3, data2, options3, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  fs$appendFile && (fs2.appendFile = appendFile);
  function appendFile(path2, data, options2, cb) {
    return typeof options2 == "function" && (cb = options2, options2 = null), go$appendFile(path2, data, options2, cb);
    function go$appendFile(path3, data2, options3, cb2, startTime) {
      return fs$appendFile(path3, data2, options3, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  fs$copyFile && (fs2.copyFile = copyFile);
  function copyFile(src2, dest, flags, cb) {
    return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src3, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src3, dest2, flags2, function(err) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir(path2, options2, cb) {
    typeof options2 == "function" && (cb = options2, options2 = null);
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path3, options3, cb2, startTime) {
      return fs$readdir(path3, fs$readdirCallback(
        path3,
        options3,
        cb2,
        startTime
      ));
    } : function(path3, options3, cb2, startTime) {
      return fs$readdir(path3, options3, fs$readdirCallback(
        path3,
        options3,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options2, cb);
    function fs$readdirCallback(path3, options3, cb2, startTime) {
      return function(err, files) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
          go$readdir,
          [path3, options3, cb2],
          err,
          startTime || Date.now(),
          Date.now()
        ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
  var fs$WriteStream = fs2.WriteStream;
  fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: !0,
    configurable: !0
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: !0,
    configurable: !0
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: !0,
    configurable: !0
  });
  function ReadStream(path2, options2) {
    return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
    });
  }
  function WriteStream(path2, options2) {
    return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
    });
  }
  function createReadStream(path2, options2) {
    return new fs2.ReadStream(path2, options2);
  }
  function createWriteStream(path2, options2) {
    return new fs2.WriteStream(path2, options2);
  }
  var fs$open = fs2.open;
  fs2.open = open2;
  function open2(path2, flags, mode2, cb) {
    return typeof mode2 == "function" && (cb = mode2, mode2 = null), go$open(path2, flags, mode2, cb);
    function go$open(path3, flags2, mode3, cb2, startTime) {
      return fs$open(path3, flags2, mode3, function(err, fd) {
        err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path3, flags2, mode3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$2("ENQUEUE", elem[0].name, elem[1]), fs$h[gracefulQueue].push(elem), retry$1();
}
var retryTimer;
function resetQueue() {
  for (var now = Date.now(), i2 = 0; i2 < fs$h[gracefulQueue].length; ++i2)
    fs$h[gracefulQueue][i2].length > 2 && (fs$h[gracefulQueue][i2][3] = now, fs$h[gracefulQueue][i2][4] = now);
  retry$1();
}
function retry$1() {
  if (clearTimeout(retryTimer), retryTimer = void 0, fs$h[gracefulQueue].length !== 0) {
    var elem = fs$h[gracefulQueue].shift(), fn2 = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
    if (startTime === void 0)
      debug$2("RETRY", fn2.name, args), fn2.apply(null, args);
    else if (Date.now() - startTime >= 6e4) {
      debug$2("TIMEOUT", fn2.name, args);
      var cb = args.pop();
      typeof cb == "function" && cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
      sinceAttempt >= desiredDelay ? (debug$2("RETRY", fn2.name, args), fn2.apply(null, args.concat([startTime]))) : fs$h[gracefulQueue].push(elem);
    }
    retryTimer === void 0 && (retryTimer = setTimeout(retry$1, 0));
  }
}
var makeDir$2 = { exports: {} };
const fs$g = require$$0__default$1.default, path$n = require$$0__default.default, { promisify: promisify$3 } = require$$0__default$5.default, semver = semver__default.default, useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0"), checkPath = (pth) => {
  if (process.platform === "win32" && /[<>:"|?*]/.test(pth.replace(path$n.parse(pth).root, ""))) {
    const error2 = new Error(`Path contains invalid characters: ${pth}`);
    throw error2.code = "EINVAL", error2;
  }
}, processOptions = (options2) => ({
  ...{
    mode: 511,
    fs: fs$g
  },
  ...options2
}), permissionError$1 = (pth) => {
  const error2 = new Error(`operation not permitted, mkdir '${pth}'`);
  return error2.code = "EPERM", error2.errno = -4048, error2.path = pth, error2.syscall = "mkdir", error2;
}, makeDir$1 = async (input2, options2) => {
  checkPath(input2), options2 = processOptions(options2);
  const mkdir = promisify$3(options2.fs.mkdir), stat = promisify$3(options2.fs.stat);
  if (useNativeRecursiveOption && options2.fs.mkdir === fs$g.mkdir) {
    const pth = path$n.resolve(input2);
    return await mkdir(pth, {
      mode: options2.mode,
      recursive: !0
    }), pth;
  }
  const make2 = async (pth) => {
    try {
      return await mkdir(pth, options2.mode), pth;
    } catch (error2) {
      if (error2.code === "EPERM")
        throw error2;
      if (error2.code === "ENOENT") {
        if (path$n.dirname(pth) === pth)
          throw permissionError$1(pth);
        if (error2.message.includes("null bytes"))
          throw error2;
        return await make2(path$n.dirname(pth)), make2(pth);
      }
      try {
        if (!(await stat(pth)).isDirectory())
          throw new Error("The path is not a directory");
      } catch {
        throw error2;
      }
      return pth;
    }
  };
  return make2(path$n.resolve(input2));
};
makeDir$2.exports = makeDir$1;
makeDir$2.exports.sync = (input2, options2) => {
  if (checkPath(input2), options2 = processOptions(options2), useNativeRecursiveOption && options2.fs.mkdirSync === fs$g.mkdirSync) {
    const pth = path$n.resolve(input2);
    return fs$g.mkdirSync(pth, {
      mode: options2.mode,
      recursive: !0
    }), pth;
  }
  const make2 = (pth) => {
    try {
      options2.fs.mkdirSync(pth, options2.mode);
    } catch (error2) {
      if (error2.code === "EPERM")
        throw error2;
      if (error2.code === "ENOENT") {
        if (path$n.dirname(pth) === pth)
          throw permissionError$1(pth);
        if (error2.message.includes("null bytes"))
          throw error2;
        return make2(path$n.dirname(pth)), make2(pth);
      }
      try {
        if (!options2.fs.statSync(pth).isDirectory())
          throw new Error("The path is not a directory");
      } catch {
        throw error2;
      }
    }
    return pth;
  };
  return make2(path$n.resolve(input2));
};
var makeDirExports = makeDir$2.exports, writeFileAtomic$1 = { exports: {} }, imurmurhash = { exports: {} };
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
(function(module2) {
  (function() {
    var cache;
    function MurmurHash32(key2, seed) {
      var m = this instanceof MurmurHash32 ? this : cache;
      if (m.reset(seed), typeof key2 == "string" && key2.length > 0 && m.hash(key2), m !== this)
        return m;
    }
    MurmurHash32.prototype.hash = function(key2) {
      var h1, k1, i2, top, len;
      switch (len = key2.length, this.len += len, k1 = this.k1, i2 = 0, this.rem) {
        case 0:
          k1 ^= len > i2 ? key2.charCodeAt(i2++) & 65535 : 0;
        case 1:
          k1 ^= len > i2 ? (key2.charCodeAt(i2++) & 65535) << 8 : 0;
        case 2:
          k1 ^= len > i2 ? (key2.charCodeAt(i2++) & 65535) << 16 : 0;
        case 3:
          k1 ^= len > i2 ? (key2.charCodeAt(i2) & 255) << 24 : 0, k1 ^= len > i2 ? (key2.charCodeAt(i2++) & 65280) >> 8 : 0;
      }
      if (this.rem = len + this.rem & 3, len -= this.rem, len > 0) {
        for (h1 = this.h1; k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1, h1 = h1 << 13 | h1 >>> 19, h1 = h1 * 5 + 3864292196 & 4294967295, !(i2 >= len); )
          k1 = key2.charCodeAt(i2++) & 65535 ^ (key2.charCodeAt(i2++) & 65535) << 8 ^ (key2.charCodeAt(i2++) & 65535) << 16, top = key2.charCodeAt(i2++), k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
        switch (k1 = 0, this.rem) {
          case 3:
            k1 ^= (key2.charCodeAt(i2 + 2) & 65535) << 16;
          case 2:
            k1 ^= (key2.charCodeAt(i2 + 1) & 65535) << 8;
          case 1:
            k1 ^= key2.charCodeAt(i2) & 65535;
        }
        this.h1 = h1;
      }
      return this.k1 = k1, this;
    }, MurmurHash32.prototype.result = function() {
      var k1, h1;
      return k1 = this.k1, h1 = this.h1, k1 > 0 && (k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1), h1 ^= this.len, h1 ^= h1 >>> 16, h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295, h1 ^= h1 >>> 13, h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295, h1 ^= h1 >>> 16, h1 >>> 0;
    }, MurmurHash32.prototype.reset = function(seed) {
      return this.h1 = typeof seed == "number" ? seed : 0, this.rem = this.k1 = this.len = 0, this;
    }, cache = new MurmurHash32(), module2.exports = MurmurHash32;
  })();
})(imurmurhash);
var imurmurhashExports = imurmurhash.exports, signalExit$1 = { exports: {} }, signals$1 = { exports: {} }, hasRequiredSignals;
function requireSignals() {
  return hasRequiredSignals || (hasRequiredSignals = 1, function(module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ], process.platform !== "win32" && module2.exports.push(
      "SIGVTALRM",
      "SIGXCPU",
      "SIGXFSZ",
      "SIGUSR2",
      "SIGTRAP",
      "SIGSYS",
      "SIGQUIT",
      "SIGIOT"
      // should detect profiler and enable/disable accordingly.
      // see #21
      // 'SIGPROF'
    ), process.platform === "linux" && module2.exports.push(
      "SIGIO",
      "SIGPOLL",
      "SIGPWR",
      "SIGSTKFLT",
      "SIGUNUSED"
    );
  }(signals$1)), signals$1.exports;
}
var process$1 = loadEnv.commonjsGlobal.process;
const processOk = function(process2) {
  return process2 && typeof process2 == "object" && typeof process2.removeListener == "function" && typeof process2.emit == "function" && typeof process2.reallyExit == "function" && typeof process2.listeners == "function" && typeof process2.kill == "function" && typeof process2.pid == "number" && typeof process2.on == "function";
};
if (!processOk(process$1))
  signalExit$1.exports = function() {
    return function() {
    };
  };
else {
  var assert$1 = require$$5__default.default, signals = requireSignals(), isWin$3 = /^win/i.test(process$1.platform), EE = require$$3__default.default;
  typeof EE != "function" && (EE = EE.EventEmitter);
  var emitter;
  process$1.__signal_exit_emitter__ ? emitter = process$1.__signal_exit_emitter__ : (emitter = process$1.__signal_exit_emitter__ = new EE(), emitter.count = 0, emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), signalExit$1.exports = function(cb, opts) {
    if (!processOk(loadEnv.commonjsGlobal.process))
      return function() {
      };
    assert$1.equal(typeof cb, "function", "a callback must be provided for exit handler"), loaded === !1 && load$3();
    var ev = "exit";
    opts && opts.alwaysLast && (ev = "afterexit");
    var remove = function() {
      emitter.removeListener(ev, cb), emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0 && unload();
    };
    return emitter.on(ev, cb), remove;
  };
  var unload = function() {
    !loaded || !processOk(loadEnv.commonjsGlobal.process) || (loaded = !1, signals.forEach(function(sig) {
      try {
        process$1.removeListener(sig, sigListeners[sig]);
      } catch {
      }
    }), process$1.emit = originalProcessEmit, process$1.reallyExit = originalProcessReallyExit, emitter.count -= 1);
  };
  signalExit$1.exports.unload = unload;
  var emit = function(event, code, signal) {
    emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
  }, sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function() {
      if (processOk(loadEnv.commonjsGlobal.process)) {
        var listeners = process$1.listeners(sig);
        listeners.length === emitter.count && (unload(), emit("exit", null, sig), emit("afterexit", null, sig), isWin$3 && sig === "SIGHUP" && (sig = "SIGINT"), process$1.kill(process$1.pid, sig));
      }
    };
  }), signalExit$1.exports.signals = function() {
    return signals;
  };
  var loaded = !1, load$3 = function() {
    loaded || !processOk(loadEnv.commonjsGlobal.process) || (loaded = !0, emitter.count += 1, signals = signals.filter(function(sig) {
      try {
        return process$1.on(sig, sigListeners[sig]), !0;
      } catch {
        return !1;
      }
    }), process$1.emit = processEmit, process$1.reallyExit = processReallyExit);
  };
  signalExit$1.exports.load = load$3;
  var originalProcessReallyExit = process$1.reallyExit, processReallyExit = function(code) {
    processOk(loadEnv.commonjsGlobal.process) && (process$1.exitCode = code || /* istanbul ignore next */
    0, emit("exit", process$1.exitCode, null), emit("afterexit", process$1.exitCode, null), originalProcessReallyExit.call(process$1, process$1.exitCode));
  }, originalProcessEmit = process$1.emit, processEmit = function(ev, arg) {
    if (ev === "exit" && processOk(loadEnv.commonjsGlobal.process)) {
      arg !== void 0 && (process$1.exitCode = arg);
      var ret = originalProcessEmit.apply(this, arguments);
      return emit("exit", process$1.exitCode, null), emit("afterexit", process$1.exitCode, null), ret;
    } else
      return originalProcessEmit.apply(this, arguments);
  };
}
var signalExitExports = signalExit$1.exports, isTypedarray = isTypedArray$2;
isTypedArray$2.strict = isStrictTypedArray;
isTypedArray$2.loose = isLooseTypedArray;
var toString = Object.prototype.toString, names = {
  "[object Int8Array]": !0,
  "[object Int16Array]": !0,
  "[object Int32Array]": !0,
  "[object Uint8Array]": !0,
  "[object Uint8ClampedArray]": !0,
  "[object Uint16Array]": !0,
  "[object Uint32Array]": !0,
  "[object Float32Array]": !0,
  "[object Float64Array]": !0
};
function isTypedArray$2(arr) {
  return isStrictTypedArray(arr) || isLooseTypedArray(arr);
}
function isStrictTypedArray(arr) {
  return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
}
function isLooseTypedArray(arr) {
  return names[toString.call(arr)];
}
var isTypedArray$1 = isTypedarray.strict, typedarrayToBuffer = function(arr) {
  if (isTypedArray$1(arr)) {
    var buf = Buffer.from(arr.buffer);
    return arr.byteLength !== arr.buffer.byteLength && (buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)), buf;
  } else
    return Buffer.from(arr);
};
writeFileAtomic$1.exports = writeFile;
writeFileAtomic$1.exports.sync = writeFileSync;
writeFileAtomic$1.exports._getTmpname = getTmpname;
writeFileAtomic$1.exports._cleanupOnExit = cleanupOnExit;
const fs$f = require$$0__default$1.default, MurmurHash3 = imurmurhashExports, onExit$1 = signalExitExports, path$m = require$$0__default.default, isTypedArray = isTypedarray, typedArrayToBuffer = typedarrayToBuffer, { promisify: promisify$2 } = require$$0__default$5.default, activeFiles = {}, threadId = function() {
  try {
    return require("worker_threads").threadId;
  } catch {
    return 0;
  }
}();
let invocations = 0;
function getTmpname(filename) {
  return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
}
function cleanupOnExit(tmpfile) {
  return () => {
    try {
      fs$f.unlinkSync(typeof tmpfile == "function" ? tmpfile() : tmpfile);
    } catch {
    }
  };
}
function serializeActiveFile(absoluteName) {
  return new Promise((resolve2) => {
    activeFiles[absoluteName] || (activeFiles[absoluteName] = []), activeFiles[absoluteName].push(resolve2), activeFiles[absoluteName].length === 1 && resolve2();
  });
}
function isChownErrOk(err) {
  return err.code === "ENOSYS" || (!process.getuid || process.getuid() !== 0) && (err.code === "EINVAL" || err.code === "EPERM");
}
async function writeFileAsync(filename, data, options2 = {}) {
  typeof options2 == "string" && (options2 = { encoding: options2 });
  let fd, tmpfile;
  const removeOnExitHandler = onExit$1(cleanupOnExit(() => tmpfile)), absoluteName = path$m.resolve(filename);
  try {
    await serializeActiveFile(absoluteName);
    const truename = await promisify$2(fs$f.realpath)(filename).catch(() => filename);
    if (tmpfile = getTmpname(truename), !options2.mode || !options2.chown) {
      const stats = await promisify$2(fs$f.stat)(truename).catch(() => {
      });
      stats && (options2.mode == null && (options2.mode = stats.mode), options2.chown == null && process.getuid && (options2.chown = { uid: stats.uid, gid: stats.gid }));
    }
    fd = await promisify$2(fs$f.open)(tmpfile, "w", options2.mode), options2.tmpfileCreated && await options2.tmpfileCreated(tmpfile), isTypedArray(data) && (data = typedArrayToBuffer(data)), Buffer.isBuffer(data) ? await promisify$2(fs$f.write)(fd, data, 0, data.length, 0) : data != null && await promisify$2(fs$f.write)(fd, String(data), 0, String(options2.encoding || "utf8")), options2.fsync !== !1 && await promisify$2(fs$f.fsync)(fd), await promisify$2(fs$f.close)(fd), fd = null, options2.chown && await promisify$2(fs$f.chown)(tmpfile, options2.chown.uid, options2.chown.gid).catch((err) => {
      if (!isChownErrOk(err))
        throw err;
    }), options2.mode && await promisify$2(fs$f.chmod)(tmpfile, options2.mode).catch((err) => {
      if (!isChownErrOk(err))
        throw err;
    }), await promisify$2(fs$f.rename)(tmpfile, truename);
  } finally {
    fd && await promisify$2(fs$f.close)(fd).catch(
      /* istanbul ignore next */
      () => {
      }
    ), removeOnExitHandler(), await promisify$2(fs$f.unlink)(tmpfile).catch(() => {
    }), activeFiles[absoluteName].shift(), activeFiles[absoluteName].length > 0 ? activeFiles[absoluteName][0]() : delete activeFiles[absoluteName];
  }
}
function writeFile(filename, data, options2, callback) {
  options2 instanceof Function && (callback = options2, options2 = {});
  const promise2 = writeFileAsync(filename, data, options2);
  return callback && promise2.then(callback, callback), promise2;
}
function writeFileSync(filename, data, options2) {
  typeof options2 == "string" ? options2 = { encoding: options2 } : options2 || (options2 = {});
  try {
    filename = fs$f.realpathSync(filename);
  } catch {
  }
  const tmpfile = getTmpname(filename);
  if (!options2.mode || !options2.chown)
    try {
      const stats = fs$f.statSync(filename);
      options2 = Object.assign({}, options2), options2.mode || (options2.mode = stats.mode), !options2.chown && process.getuid && (options2.chown = { uid: stats.uid, gid: stats.gid });
    } catch {
    }
  let fd;
  const cleanup = cleanupOnExit(tmpfile), removeOnExitHandler = onExit$1(cleanup);
  let threw = !0;
  try {
    if (fd = fs$f.openSync(tmpfile, "w", options2.mode || 438), options2.tmpfileCreated && options2.tmpfileCreated(tmpfile), isTypedArray(data) && (data = typedArrayToBuffer(data)), Buffer.isBuffer(data) ? fs$f.writeSync(fd, data, 0, data.length, 0) : data != null && fs$f.writeSync(fd, String(data), 0, String(options2.encoding || "utf8")), options2.fsync !== !1 && fs$f.fsyncSync(fd), fs$f.closeSync(fd), fd = null, options2.chown)
      try {
        fs$f.chownSync(tmpfile, options2.chown.uid, options2.chown.gid);
      } catch (err) {
        if (!isChownErrOk(err))
          throw err;
      }
    if (options2.mode)
      try {
        fs$f.chmodSync(tmpfile, options2.mode);
      } catch (err) {
        if (!isChownErrOk(err))
          throw err;
      }
    fs$f.renameSync(tmpfile, filename), threw = !1;
  } finally {
    if (fd)
      try {
        fs$f.closeSync(fd);
      } catch {
      }
    removeOnExitHandler(), threw && cleanup();
  }
}
var writeFileAtomicExports = writeFileAtomic$1.exports, isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1, disallowedKeys = [
  "__proto__",
  "prototype",
  "constructor"
], isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.includes(segment));
function getPathSegments(path2) {
  const pathArray = path2.split("."), parts = [];
  for (let i2 = 0; i2 < pathArray.length; i2++) {
    let p = pathArray[i2];
    for (; p[p.length - 1] === "\\" && pathArray[i2 + 1] !== void 0; )
      p = p.slice(0, -1) + ".", p += pathArray[++i2];
    parts.push(p);
  }
  return isValidPath(parts) ? parts : [];
}
var dotProp$1 = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 != "string")
      return value === void 0 ? object : value;
    const pathArray = getPathSegments(path2);
    if (pathArray.length !== 0) {
      for (let i2 = 0; i2 < pathArray.length; i2++) {
        if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i2]))
          return value;
        if (object = object[pathArray[i2]], object == null) {
          if (i2 !== pathArray.length - 1)
            return value;
          break;
        }
      }
      return object;
    }
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 != "string")
      return object;
    const root2 = object, pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      isObj(object[p]) || (object[p] = {}), i2 === pathArray.length - 1 && (object[p] = value), object = object[p];
    }
    return root2;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 != "string")
      return !1;
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      if (i2 === pathArray.length - 1)
        return delete object[p], !0;
      if (object = object[p], !isObj(object))
        return !1;
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 != "string")
      return !1;
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0)
      return !1;
    for (let i2 = 0; i2 < pathArray.length; i2++)
      if (isObj(object)) {
        if (!(pathArray[i2] in object))
          return !1;
        object = object[pathArray[i2]];
      } else
        return !1;
    return !0;
  }
};
const crypto = require$$3__default$1.default;
var cryptoRandomString$1 = (length) => {
  if (!Number.isFinite(length))
    throw new TypeError("Expected a finite number");
  return crypto.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
};
const cryptoRandomString = cryptoRandomString$1;
var uniqueString$1 = () => cryptoRandomString(32);
const path$l = require$$0__default.default, os$5 = require$$0__default$2.default, fs$e = gracefulFs, makeDir = makeDirExports, xdgBasedir = xdgBasedir$2, writeFileAtomic = writeFileAtomicExports, dotProp = dotProp$1, uniqueString = uniqueString$1, configDirectory = xdgBasedir.config || path$l.join(os$5.tmpdir(), uniqueString()), permissionError = "You don't have access to this file.", makeDirOptions = { mode: 448 }, writeFileOptions = { mode: 384 };
class Configstore {
  constructor(id, defaults2, options2 = {}) {
    const pathPrefix = options2.globalConfigPath ? path$l.join(id, "config.json") : path$l.join("configstore", `${id}.json`);
    this.path = options2.configPath || path$l.join(configDirectory, pathPrefix), defaults2 && (this.all = {
      ...defaults2,
      ...this.all
    });
  }
  get all() {
    try {
      return JSON.parse(fs$e.readFileSync(this.path, "utf8"));
    } catch (error2) {
      if (error2.code === "ENOENT")
        return {};
      if (error2.code === "EACCES" && (error2.message = `${error2.message}
${permissionError}
`), error2.name === "SyntaxError")
        return writeFileAtomic.sync(this.path, "", writeFileOptions), {};
      throw error2;
    }
  }
  set all(value) {
    try {
      makeDir.sync(path$l.dirname(this.path), makeDirOptions), writeFileAtomic.sync(this.path, JSON.stringify(value, void 0, "	"), writeFileOptions);
    } catch (error2) {
      throw error2.code === "EACCES" && (error2.message = `${error2.message}
${permissionError}
`), error2;
    }
  }
  get size() {
    return Object.keys(this.all || {}).length;
  }
  get(key2) {
    return dotProp.get(this.all, key2);
  }
  set(key2, value) {
    const config2 = this.all;
    if (arguments.length === 1)
      for (const k of Object.keys(key2))
        dotProp.set(config2, k, key2[k]);
    else
      dotProp.set(config2, key2, value);
    this.all = config2;
  }
  has(key2) {
    return dotProp.has(this.all, key2);
  }
  delete(key2) {
    const config2 = this.all;
    dotProp.delete(config2, key2), this.all = config2;
  }
  clear() {
    this.all = {};
  }
}
var configstore = Configstore, ConfigStore = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(configstore);
const sanityEnv$1 = (process.env.SANITY_INTERNAL_ENV || "").toLowerCase(), configName = sanityEnv$1 && sanityEnv$1 !== "production" ? `sanity-${sanityEnv$1}` : "sanity", defaults$4 = {};
let config$1;
const getUserConfig = () => (config$1 || (config$1 = new ConfigStore(configName, defaults$4, { globalConfigPath: !0 })), config$1), apiHosts = {
  staging: "https://api.sanity.work",
  development: "http://api.sanity.wtf"
}, defaults$3 = {
  requireUser: !0,
  requireProject: !0
}, authErrors = () => ({
  onError: (err) => (!err || !isReqResError(err) || (err.response && err.response.body && err.response.body.statusCode) === 401 && (err.message = `${err.message}. You may need to login again with ${chalk__default.default.cyan(
    "sanity login"
  )}.
For more information, see ${generateHelpUrl("cli-errors")}.`), err)
});
function isReqResError(err) {
  return err.hasOwnProperty("response");
}
function getCliToken() {
  const envAuthToken = process.env.SANITY_AUTH_TOKEN, userConfig = getUserConfig();
  return envAuthToken || userConfig.get("authToken");
}
function getClientWrapper(cliApiConfig, configPath2) {
  const requester = client$1.requester.clone();
  return requester.use(authErrors()), function(opts) {
    const sanityEnv2 = process.env.SANITY_INTERNAL_ENV || "production", { requireUser, requireProject, api } = { ...defaults$3, ...opts }, token2 = getCliToken(), apiHost = apiHosts[sanityEnv2], apiConfig = {
      ...cliApiConfig || {},
      ...api || {}
    };
    if (apiHost && (apiConfig.apiHost = apiHost), requireUser && !token2)
      throw new Error('You must login first - run "sanity login"');
    if (requireProject && !apiConfig.projectId) {
      const relativeConfigPath = path__default.default.relative(process.cwd(), configPath2);
      throw new Error(
        `${relativeConfigPath} does not contain a project identifier ("api.projectId"), which is required for the Sanity CLI to communicate with the Sanity API`
      );
    }
    return client$1.createClient({
      ...apiConfig,
      apiVersion: "1",
      dataset: apiConfig.dataset || "~dummy-placeholder-dataset-",
      token: requireUser ? token2 : void 0,
      useProjectHostname: requireProject,
      requester,
      useCdn: !1
    });
  };
}
const printVersionResultCommand = async (args, context) => {
  const versions = await findSanityModuleVersions(context, { target: "latest" });
  printResult(versions, context.output.print);
};
function printResult(versions, print) {
  const { versionLength, formatName } = getFormatters(versions);
  versions.forEach((mod) => {
    const version = lodashExports.padStart(mod.installed || "<missing>", versionLength), latest = mod.installed === mod.latest ? chalk__default.default.green("(up to date)") : `(latest: ${chalk__default.default.yellow(mod.latest)})`;
    print(`${formatName(getDisplayName(mod))} ${version} ${latest}`);
  });
}
function getFormatters(versions) {
  const nameLength = versions.reduce((max2, mod) => Math.max(max2, getDisplayName(mod).length), 0), versionLength = versions.reduce(
    (max2, mod) => Math.max(max2, (mod.installed || "<missing>").length),
    0
  );
  return { nameLength, versionLength, formatName: (name) => lodashExports.padEnd(name, nameLength + 1).replace(/^@sanity\/(.*?)(\s|$)/, `${chalk__default.default.yellow("@sanity/")}${chalk__default.default.cyan("$1")}$2`).replace(/^sanity(\s|$)/, `${chalk__default.default.yellow("sanity")}$1`) };
}
function getDisplayName(mod) {
  return mod.isGlobal ? `${mod.name} (global)` : mod.name;
}
const printDebugInfo = async (args, context) => {
  const flags = args.extOptions, { user, globalConfig, projectConfig, project, versions } = await gatherInfo(context), { chalk: chalk2 } = context;
  context.output.print(`
User:`), user instanceof Error ? context.output.print(`  ${chalk2.red(user.message)}
`) : printKeyValue(
    {
      ID: user.id,
      Name: user.name,
      Email: user.email,
      Roles: project ? project.userRoles : void 0
    },
    context
  ), project && (context.output.print("Project:"), printKeyValue(
    {
      ID: project.id,
      "Display name": project.displayName,
      "Studio URL": project.studioHostname
    },
    context
  ));
  const authToken = process.env.SANITY_AUTH_TOKEN || globalConfig.authToken;
  authToken && (context.output.print("Authentication:"), printKeyValue(
    {
      "User type": globalConfig.authType || "normal",
      "Auth token": flags.secrets ? authToken : "<redacted>"
    },
    context
  ), flags.secrets || context.output.print(`  (run with --secrets to reveal token)
`)), context.output.print(`Global config (${chalk2.yellow(getGlobalConfigLocation())}):`);
  const globalCfg = lodashExports.omit(globalConfig, ["authType", "authToken"]);
  if (context.output.print(`  ${formatObject(globalCfg).replace(/\n/g, `
  `)}
`), projectConfig) {
    const configLocation = context.cliConfigPath ? ` (${chalk2.yellow(path__default.default.relative(process.cwd(), context.cliConfigPath))})` : "";
    context.output.print(`Project config${configLocation}:`), context.output.print(`  ${formatObject(projectConfig).replace(/\n/g, `
  `)}`);
  }
  versions && (context.output.print(`
Package versions:`), printResult(versions, (line3) => context.output.print(`  ${line3}`)), context.output.print(""));
};
function formatObject(obj) {
  return util__default.default.inspect(obj, { colors: !0, depth: 1 / 0 });
}
function printKeyValue(obj, context) {
  let printedLines = 0;
  Object.keys(obj).forEach((key2) => {
    typeof obj[key2] < "u" && (context.output.print(`  ${key2}: ${formatObject(obj[key2])}`), printedLines++);
  }), printedLines > 0 && context.output.print("");
}
async function gatherInfo(context) {
  const baseInfo = await promiseProps$1({
    globalConfig: gatherGlobalConfigInfo(),
    projectConfig: gatherProjectConfigInfo(context)
  }), withUser = {
    ...baseInfo,
    user: await gatherUserInfo(context, {
      projectBased: !!(baseInfo.projectConfig && baseInfo.projectConfig.api)
    })
  };
  return promiseProps$1({
    project: gatherProjectInfo(context, withUser),
    versions: findSanityModuleVersions(context, { target: "latest" }),
    ...withUser
  });
}
function getGlobalConfigLocation() {
  const user = (os__default.default.userInfo().username || "user").replace(/\\/g, ""), configDir = xdgBasedir$1.config || path__default.default.join(os__default.default.tmpdir(), user, ".config");
  return path__default.default.join(configDir, "sanity", "config.json");
}
function gatherGlobalConfigInfo() {
  return getUserConfig().all;
}
function gatherProjectConfigInfo(context) {
  const { cliConfig } = context;
  return cliConfig?.api?.projectId ? cliConfig : {
    error: 'Missing required "api.projectId" key'
  };
}
async function gatherProjectInfo(context, baseInfo) {
  const projectId = context.apiClient({ requireUser: !1, requireProject: !1 }).config().projectId, hasToken = !!getCliToken();
  if (!projectId || !hasToken)
    return null;
  const projectInfo = await context.apiClient({ requireUser: !0, requireProject: !1 }).withConfig({ apiVersion: "2023-06-06" }).request({ url: `/projects/${projectId}` });
  if (!projectInfo)
    return new Error(`Project specified in configuration (${projectId}) does not exist in API`);
  const userId = baseInfo.user instanceof Error ? null : baseInfo.user.id, host = projectInfo.studioHost, member = (projectInfo.members || []).find((user) => user.id === userId), hostname = host && `https://${host}.sanity.studio/`;
  return {
    id: projectId,
    displayName: projectInfo.displayName,
    studioHostname: hostname,
    userRoles: member ? member.roles.map((role) => role.name) : ["<none>"]
  };
}
async function gatherUserInfo(context, options2) {
  if (!getCliToken())
    return new Error("Not logged in");
  const userInfo = await context.apiClient({ requireUser: !0, requireProject: options2.projectBased }).users.getById("me");
  return userInfo ? lodashExports.pick(userInfo, ["id", "name", "email"]) : new Error("Token expired or invalid");
}
const help$2 = `
Used to find information about the Sanity environment, and to debug Sanity-related issues.

Options
  --secrets Include API keys in output

Examples
  # Show information about the user, project, and local/global Sanity environment
  sanity debug

  # Include API keys in the output
  sanity debug --secrets
`, debugCommand = {
  name: "debug",
  signature: "[--secrets]",
  description: "Provides diagnostic info for Sanity Studio troubleshooting",
  helpText: help$2,
  action: printDebugInfo
};
var isWsl$2 = { exports: {} };
const fs$d = require$$0__default$1.default;
let isDocker$2;
function hasDockerEnv() {
  try {
    return fs$d.statSync("/.dockerenv"), !0;
  } catch {
    return !1;
  }
}
function hasDockerCGroup() {
  try {
    return fs$d.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return !1;
  }
}
var isDocker_1 = () => (isDocker$2 === void 0 && (isDocker$2 = hasDockerEnv() || hasDockerCGroup()), isDocker$2);
const os$4 = require$$0__default$2.default, fs$c = require$$0__default$1.default, isDocker$1 = isDocker_1, isWsl$1 = () => {
  if (process.platform !== "linux")
    return !1;
  if (os$4.release().toLowerCase().includes("microsoft"))
    return !isDocker$1();
  try {
    return fs$c.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : !1;
  } catch {
    return !1;
  }
};
process.env.__IS_WSL_TEST__ ? isWsl$2.exports = isWsl$1 : isWsl$2.exports = isWsl$1();
var isWslExports = isWsl$2.exports, defineLazyProp = (object, propertyName, fn2) => {
  const define = (value) => Object.defineProperty(object, propertyName, { value, enumerable: !0, writable: !0 });
  return Object.defineProperty(object, propertyName, {
    configurable: !0,
    enumerable: !0,
    get() {
      const result = fn2();
      return define(result), result;
    },
    set(value) {
      define(value);
    }
  }), object;
};
const path$k = require$$0__default.default, childProcess$1 = require$$0__default$7.default, { promises: fs$b, constants: fsConstants } = require$$0__default$1.default, isWsl = isWslExports, isDocker = isDocker_1, defineLazyProperty = defineLazyProp, localXdgOpenPath = path$k.join(__dirname, "xdg-open"), { platform: platform$1, arch } = process, hasContainerEnv = () => {
  try {
    return fs$b.statSync("/run/.containerenv"), !0;
  } catch {
    return !1;
  }
};
let cachedResult;
function isInsideContainer() {
  return cachedResult === void 0 && (cachedResult = hasContainerEnv() || isDocker()), cachedResult;
}
const getWslDrivesMountPoint = /* @__PURE__ */ (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint)
      return mountPoint;
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = !1;
    try {
      await fs$b.access(configFilePath, fsConstants.F_OK), isConfigFileExists = !0;
    } catch {
    }
    if (!isConfigFileExists)
      return defaultMountPoint;
    const configContent = await fs$b.readFile(configFilePath, { encoding: "utf8" }), configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
    return configMountPoint ? (mountPoint = configMountPoint.groups.mountPoint.trim(), mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`, mountPoint) : defaultMountPoint;
  };
})(), pTryEach = async (array2, mapper) => {
  let latestError;
  for (const item of array2)
    try {
      return await mapper(item);
    } catch (error2) {
      latestError = error2;
    }
  throw latestError;
}, baseOpen = async (options2) => {
  if (options2 = {
    wait: !1,
    background: !1,
    newInstance: !1,
    allowNonzeroExitCode: !1,
    ...options2
  }, Array.isArray(options2.app))
    return pTryEach(options2.app, (singleApp) => baseOpen({
      ...options2,
      app: singleApp
    }));
  let { name: app, arguments: appArguments = [] } = options2.app || {};
  if (appArguments = [...appArguments], Array.isArray(app))
    return pTryEach(app, (appName) => baseOpen({
      ...options2,
      app: {
        name: appName,
        arguments: appArguments
      }
    }));
  let command2;
  const cliArguments = [], childProcessOptions = {};
  if (platform$1 === "darwin")
    command2 = "open", options2.wait && cliArguments.push("--wait-apps"), options2.background && cliArguments.push("--background"), options2.newInstance && cliArguments.push("--new"), app && cliArguments.push("-a", app);
  else if (platform$1 === "win32" || isWsl && !isInsideContainer() && !app) {
    const mountPoint = await getWslDrivesMountPoint();
    command2 = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`, cliArguments.push(
      "-NoProfile",
      "-NonInteractive",
      "\u2013ExecutionPolicy",
      "Bypass",
      "-EncodedCommand"
    ), isWsl || (childProcessOptions.windowsVerbatimArguments = !0);
    const encodedArguments = ["Start"];
    options2.wait && encodedArguments.push("-Wait"), app ? (encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList"), options2.target && appArguments.unshift(options2.target)) : options2.target && encodedArguments.push(`"${options2.target}"`), appArguments.length > 0 && (appArguments = appArguments.map((arg) => `"\`"${arg}\`""`), encodedArguments.push(appArguments.join(","))), options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
  } else {
    if (app)
      command2 = app;
    else {
      const isBundled = !__dirname || __dirname === "/";
      let exeLocalXdgOpen = !1;
      try {
        await fs$b.access(localXdgOpenPath, fsConstants.X_OK), exeLocalXdgOpen = !0;
      } catch {
      }
      command2 = process.versions.electron || platform$1 === "android" || isBundled || !exeLocalXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    appArguments.length > 0 && cliArguments.push(...appArguments), options2.wait || (childProcessOptions.stdio = "ignore", childProcessOptions.detached = !0);
  }
  options2.target && cliArguments.push(options2.target), platform$1 === "darwin" && appArguments.length > 0 && cliArguments.push("--args", ...appArguments);
  const subprocess = childProcess$1.spawn(command2, cliArguments, childProcessOptions);
  return options2.wait ? new Promise((resolve2, reject) => {
    subprocess.once("error", reject), subprocess.once("close", (exitCode) => {
      if (!options2.allowNonzeroExitCode && exitCode > 0) {
        reject(new Error(`Exited with code ${exitCode}`));
        return;
      }
      resolve2(subprocess);
    });
  }) : (subprocess.unref(), subprocess);
}, open = (target, options2) => {
  if (typeof target != "string")
    throw new TypeError("Expected a `target`");
  return baseOpen({
    ...options2,
    target
  });
}, openApp = (name, options2) => {
  if (typeof name != "string")
    throw new TypeError("Expected a `name`");
  const { arguments: appArguments = [] } = options2 || {};
  if (appArguments != null && !Array.isArray(appArguments))
    throw new TypeError("Expected `appArguments` as Array type");
  return baseOpen({
    ...options2,
    app: {
      name,
      arguments: appArguments
    }
  });
};
function detectArchBinary(binary2) {
  if (typeof binary2 == "string" || Array.isArray(binary2))
    return binary2;
  const { [arch]: archBinary } = binary2;
  if (!archBinary)
    throw new Error(`${arch} is not supported`);
  return archBinary;
}
function detectPlatformBinary({ [platform$1]: platformBinary }, { wsl }) {
  if (wsl && isWsl)
    return detectArchBinary(wsl);
  if (!platformBinary)
    throw new Error(`${platform$1} is not supported`);
  return detectArchBinary(platformBinary);
}
const apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  linux: ["google-chrome", "google-chrome-stable", "chromium"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
open.apps = apps;
open.openApp = openApp;
var open_1 = open, open$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(open_1);
const docsCommand = {
  name: "docs",
  helpText: "",
  signature: "docs",
  description: "Opens Sanity Studio documentation in your web browser",
  async action(args, context) {
    const { output } = context, { print } = output, url2 = "https://www.sanity.io/docs";
    print(`Opening ${url2}`), await open$1(url2);
  }
};
var leven$2 = { exports: {} };
const array = [], charCodeCache = [], leven = (left2, right2) => {
  if (left2 === right2)
    return 0;
  const swap = left2;
  left2.length > right2.length && (left2 = right2, right2 = swap);
  let leftLength = left2.length, rightLength = right2.length;
  for (; leftLength > 0 && left2.charCodeAt(~-leftLength) === right2.charCodeAt(~-rightLength); )
    leftLength--, rightLength--;
  let start = 0;
  for (; start < leftLength && left2.charCodeAt(start) === right2.charCodeAt(start); )
    start++;
  if (leftLength -= start, rightLength -= start, leftLength === 0)
    return rightLength;
  let bCharCode, result, temp, temp2, i2 = 0, j = 0;
  for (; i2 < leftLength; )
    charCodeCache[i2] = left2.charCodeAt(start + i2), array[i2] = ++i2;
  for (; j < rightLength; )
    for (bCharCode = right2.charCodeAt(start + j), temp = j++, result = j, i2 = 0; i2 < leftLength; i2++)
      temp2 = bCharCode === charCodeCache[i2] ? temp : temp + 1, temp = array[i2], result = array[i2] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
  return result;
};
leven$2.exports = leven;
leven$2.exports.default = leven;
var levenExports = leven$2.exports, leven$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(levenExports);
const commonMistakes = { get: "list" }, levenThreshold = 3, coreCommands = [
  "build",
  "check",
  "configcheck",
  "cors",
  "dataset",
  "deploy",
  "dev",
  "documents",
  "exec",
  "graphql",
  "hook",
  "migration",
  "preview",
  "schema",
  "start",
  "undeploy",
  "uninstall",
  "users"
], discouragedCommands = ["upgrade", "check", "configcheck", "uninstall"], helpText$9 = `
Run the command again within a Sanity project directory, where "sanity"
is installed as a dependency.`;
function getNoSuchCommandText(cmdName, parentGroupName, groups) {
  return parentGroupName && groups && groups[parentGroupName] ? suggestCommand(cmdName, groups[parentGroupName], parentGroupName) : coreCommands.includes(cmdName) ? `Command "${cmdName}" is not available outside of a Sanity project context.${helpText$9}` : suggestCommand(cmdName, groups ? groups.default : []);
}
function suggestCommand(cmdName, group, parentGroupName = null) {
  const closest = group.filter((command2) => !discouragedCommands.includes(command2.name)).map((command2) => leven$1(command2.name, cmdName)).reduce(
    (current, distance, index) => distance < current.distance ? { index, distance } : current,
    { index: 0, distance: 1 / 0 }
  );
  let suggestCmd = "";
  closest.distance <= levenThreshold && (suggestCmd = group[closest.index].name);
  const alternative = commonMistakes[cmdName];
  !suggestCmd && alternative && (suggestCmd = alternative);
  const input2 = chalk__default.default.cyan(`"${cmdName}"`), suggest = chalk__default.default.green(`"${suggestCmd}"`), help2 = chalk__default.default.cyan('"sanity --help"'), didYouMean = suggestCmd ? `Did you mean ${suggest}? ` : " ";
  return parentGroupName ? `${input2} is not a subcommand of "sanity ${parentGroupName}". ${didYouMean}See ${help2}` : `${input2} is not a sanity command. ${didYouMean}See ${help2}`;
}
function generateCommandsDocumentation(commandGroups, group = "default") {
  const commandGroup = commandGroups[group], commands = commandGroup && commandGroup.filter((cmd) => !cmd.hideFromHelp);
  if (!commands || commands.length === 0)
    throw new Error(getNoSuchCommandText(group));
  const cmdLength = commands.reduce((max2, cmd) => Math.max(cmd.name.length, max2), 0), prefix = group === "default" ? "" : ` ${group}`;
  return [
    `usage: sanity${prefix} [--default] [-v|--version] [-d|--debug] [-h|--help] <command> [<args>]`,
    "",
    "Commands:"
  ].concat(commands.map((cmd) => `   ${lodashExports.padEnd(cmd.name, cmdLength + 1)} ${cmd.description}`)).concat(["", `See 'sanity help${prefix} <command>' for specific information on a subcommand.`]).join(`
`);
}
function generateCommandDocumentation(command2, group, subCommand) {
  if (!command2)
    throw new Error(
      subCommand ? `"${subCommand}" is not a subcommand of "${group}". See 'sanity help ${group}'` : getNoSuchCommandText(group || command2)
    );
  return [
    `usage: sanity ${[group || command2.name, subCommand].filter(Boolean).join(" ")} ${command2.signature}`,
    "",
    `   ${command2.description}`,
    "",
    (command2.helpText || "").trim()
  ].join(`
`);
}
function isCommandGroup(cmdOrGroup) {
  return "isGroupRoot" in cmdOrGroup;
}
const showHelpAction = async (args, context) => {
  const [commandName, subCommandName] = args.argsWithoutOptions, { commandGroups } = context.commandRunner;
  if (!commandName) {
    loadEnv.debug('No command given to "help", showing generate Sanity CLI help'), context.output.print(generateCommandsDocumentation(commandGroups));
    return;
  }
  const defaultCommand = commandGroups.default.find((cmd) => cmd.name === commandName);
  if (defaultCommand && !isCommandGroup(defaultCommand)) {
    loadEnv.debug(`Found command in default group with name "${commandName}"`), context.output.print(generateCommandDocumentation(defaultCommand));
    return;
  }
  const group = commandGroups[commandName];
  if (!subCommandName && !group)
    throw loadEnv.debug(`No subcommand given, and we couldn't find a group with name "${group}"`), new Error(getNoSuchCommandText(commandName, null, commandGroups));
  if (!subCommandName && group) {
    loadEnv.debug(`No subcommand given, but found group with name "${commandName}"`), context.output.print(generateCommandsDocumentation(commandGroups, commandName));
    return;
  }
  if (subCommandName && !group)
    throw loadEnv.debug(`Subcommand given, but couldn't find group with name "${commandName}"`), new Error(getNoSuchCommandText(subCommandName, commandName, commandGroups));
  const subCommand = context.commandRunner.resolveSubcommand(group, subCommandName, commandName);
  if (!subCommand)
    throw loadEnv.debug(`Subcommand given, but not found in group "${commandName}"`), new Error(getNoSuchCommandText(subCommandName, commandName, commandGroups));
  loadEnv.debug('Subcommand "%s" for group "%s" found, showing help', subCommandName, commandName), isCommandGroup(subCommand.command) || context.output.print(
    generateCommandDocumentation(subCommand.command, commandName, subCommandName)
  );
}, help$1 = `
With no options and no COMMAND given, the synopsis of the sanity command and a
list of the most commonly used commands are printed on the standard output.

If a command is given, the help page for that command is printed to standard
output. This will usually be more in-depth than the brief description shown in
the command list.
`, command$1 = {
  name: "help",
  signature: "[COMMAND]",
  description: "Displays help information about Sanity CLI commands",
  action: showHelpAction,
  helpText: help$1
};
var frameworks = {}, readConfigFile$1 = {}, jsYaml$4 = {}, loader$5 = {}, common$l = {};
function isNothing$2(subject) {
  return typeof subject > "u" || subject === null;
}
function isObject$7(subject) {
  return typeof subject == "object" && subject !== null;
}
function toArray$3(sequence) {
  return Array.isArray(sequence) ? sequence : isNothing$2(sequence) ? [] : [sequence];
}
function extend$4(target, source2) {
  var index, length, key2, sourceKeys;
  if (source2)
    for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
      key2 = sourceKeys[index], target[key2] = source2[key2];
  return target;
}
function repeat$3(string, count2) {
  var result = "", cycle;
  for (cycle = 0; cycle < count2; cycle += 1)
    result += string;
  return result;
}
function isNegativeZero$2(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
common$l.isNothing = isNothing$2;
common$l.isObject = isObject$7;
common$l.toArray = toArray$3;
common$l.repeat = repeat$3;
common$l.isNegativeZero = isNegativeZero$2;
common$l.extend = extend$4;
function YAMLException$e(reason, mark2) {
  Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
YAMLException$e.prototype = Object.create(Error.prototype);
YAMLException$e.prototype.constructor = YAMLException$e;
YAMLException$e.prototype.toString = function(compact) {
  var result = this.name + ": ";
  return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
};
var exception$2 = YAMLException$e, common$k = common$l;
function Mark$3(name, buffer2, position, line3, column2) {
  this.name = name, this.buffer = buffer2, this.position = position, this.line = line3, this.column = column2;
}
Mark$3.prototype.getSnippet = function(indent, maxLength) {
  var head, start, tail, end2, snippet2;
  if (!this.buffer) return null;
  for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
    if (start -= 1, this.position - start > maxLength / 2 - 1) {
      head = " ... ", start += 5;
      break;
    }
  for (tail = "", end2 = this.position; end2 < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end2)) === -1; )
    if (end2 += 1, end2 - this.position > maxLength / 2 - 1) {
      tail = " ... ", end2 -= 5;
      break;
    }
  return snippet2 = this.buffer.slice(start, end2), common$k.repeat(" ", indent) + head + snippet2 + tail + `
` + common$k.repeat(" ", indent + this.position - start + head.length) + "^";
};
Mark$3.prototype.toString = function(compact) {
  var snippet2, where = "";
  return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet2 = this.getSnippet(), snippet2 && (where += `:
` + snippet2)), where;
};
var mark$2 = Mark$3, YAMLException$d = exception$2, TYPE_CONSTRUCTOR_OPTIONS$2 = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
], YAML_NODE_KINDS$2 = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases$2(map2) {
  var result = {};
  return map2 !== null && Object.keys(map2).forEach(function(style) {
    map2[style].forEach(function(alias) {
      result[String(alias)] = style;
    });
  }), result;
}
function Type$O(tag, options2) {
  if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS$2.indexOf(name) === -1)
      throw new YAMLException$d('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
  }), this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
    return !0;
  }, this.construct = options2.construct || function(data) {
    return data;
  }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.defaultStyle = options2.defaultStyle || null, this.styleAliases = compileStyleAliases$2(options2.styleAliases || null), YAML_NODE_KINDS$2.indexOf(this.kind) === -1)
    throw new YAMLException$d('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var type$2 = Type$O, common$j = common$l, YAMLException$c = exception$2, Type$N = type$2;
function compileList$2(schema2, name, result) {
  var exclude = [];
  return schema2.include.forEach(function(includedSchema) {
    result = compileList$2(includedSchema, name, result);
  }), schema2[name].forEach(function(currentType) {
    result.forEach(function(previousType, previousIndex) {
      previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
    }), result.push(currentType);
  }), result.filter(function(type2, index) {
    return exclude.indexOf(index) === -1;
  });
}
function compileMap$2() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, index, length;
  function collectType(type2) {
    result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
  }
  for (index = 0, length = arguments.length; index < length; index += 1)
    arguments[index].forEach(collectType);
  return result;
}
function Schema$d(definition) {
  this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type2) {
    if (type2.loadKind && type2.loadKind !== "scalar")
      throw new YAMLException$c("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
  }), this.compiledImplicit = compileList$2(this, "implicit", []), this.compiledExplicit = compileList$2(this, "explicit", []), this.compiledTypeMap = compileMap$2(this.compiledImplicit, this.compiledExplicit);
}
Schema$d.DEFAULT = null;
Schema$d.create = function() {
  var schemas, types2;
  switch (arguments.length) {
    case 1:
      schemas = Schema$d.DEFAULT, types2 = arguments[0];
      break;
    case 2:
      schemas = arguments[0], types2 = arguments[1];
      break;
    default:
      throw new YAMLException$c("Wrong number of arguments for Schema.create function");
  }
  if (schemas = common$j.toArray(schemas), types2 = common$j.toArray(types2), !schemas.every(function(schema2) {
    return schema2 instanceof Schema$d;
  }))
    throw new YAMLException$c("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  if (!types2.every(function(type2) {
    return type2 instanceof Type$N;
  }))
    throw new YAMLException$c("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  return new Schema$d({
    include: schemas,
    explicit: types2
  });
};
var schema$2 = Schema$d, Type$M = type$2, str$2 = new Type$M("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
}), Type$L = type$2, seq$2 = new Type$L("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
}), Type$K = type$2, map$3 = new Type$K("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
}), Schema$c = schema$2, failsafe$2 = new Schema$c({
  explicit: [
    str$2,
    seq$2,
    map$3
  ]
}), Type$J = type$2;
function resolveYamlNull$2(data) {
  if (data === null) return !0;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull$2() {
  return null;
}
function isNull$2(object) {
  return object === null;
}
var _null$2 = new Type$J("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull$2,
  construct: constructYamlNull$2,
  predicate: isNull$2,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
}), Type$I = type$2;
function resolveYamlBoolean$2(data) {
  if (data === null) return !1;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean$2(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean$2(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool$2 = new Type$I("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean$2,
  construct: constructYamlBoolean$2,
  predicate: isBoolean$2,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), common$i = common$l, Type$H = type$2;
function isHexCode$2(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode$2(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode$2(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger$2(data) {
  if (data === null) return !1;
  var max2 = data.length, index = 0, hasDigits = !1, ch;
  if (!max2) return !1;
  if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
    if (index + 1 === max2) return !0;
    if (ch = data[++index], ch === "b") {
      for (index++; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (ch !== "0" && ch !== "1") return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      for (index++; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isHexCode$2(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (!isOctCode$2(data.charCodeAt(index))) return !1;
        hasDigits = !0;
      }
    return hasDigits && ch !== "_";
  }
  if (ch === "_") return !1;
  for (; index < max2; index++)
    if (ch = data[index], ch !== "_") {
      if (ch === ":") break;
      if (!isDecCode$2(data.charCodeAt(index)))
        return !1;
      hasDigits = !0;
    }
  return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger$2(data) {
  var value = data, sign2 = 1, ch, base2, digits = [];
  return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign2 * parseInt(value.slice(2), 2) : value[1] === "x" ? sign2 * parseInt(value, 16) : sign2 * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
    digits.unshift(parseInt(v, 10));
  }), value = 0, base2 = 1, digits.forEach(function(d) {
    value += d * base2, base2 *= 60;
  }), sign2 * value) : sign2 * parseInt(value, 10);
}
function isInteger$3(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common$i.isNegativeZero(object);
}
var int$2 = new Type$H("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger$2,
  construct: constructYamlInteger$2,
  predicate: isInteger$3,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), common$h = common$l, Type$G = type$2, YAML_FLOAT_PATTERN$2 = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat$2(data) {
  return !(data === null || !YAML_FLOAT_PATTERN$2.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_");
}
function constructYamlFloat$2(data) {
  var value, sign2, base2, digits;
  return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
    digits.unshift(parseFloat(v, 10));
  }), value = 0, base2 = 1, digits.forEach(function(d) {
    value += d * base2, base2 *= 60;
  }), sign2 * value) : sign2 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT$2 = /^[-+]?[0-9]+e/;
function representYamlFloat$2(object, style) {
  var res;
  if (isNaN(object))
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (common$h.isNegativeZero(object))
    return "-0.0";
  return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT$2.test(res) ? res.replace("e", ".e") : res;
}
function isFloat$3(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$h.isNegativeZero(object));
}
var float$2 = new Type$G("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat$2,
  construct: constructYamlFloat$2,
  predicate: isFloat$3,
  represent: representYamlFloat$2,
  defaultStyle: "lowercase"
}), Schema$b = schema$2, json$2 = new Schema$b({
  include: [
    failsafe$2
  ],
  implicit: [
    _null$2,
    bool$2,
    int$2,
    float$2
  ]
}), Schema$a = schema$2, core$6 = new Schema$a({
  include: [
    json$2
  ]
}), Type$F = type$2, YAML_DATE_REGEXP$2 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), YAML_TIMESTAMP_REGEXP$2 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp$2(data) {
  return data === null ? !1 : YAML_DATE_REGEXP$2.exec(data) !== null || YAML_TIMESTAMP_REGEXP$2.exec(data) !== null;
}
function constructYamlTimestamp$2(data) {
  var match3, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  if (match3 = YAML_DATE_REGEXP$2.exec(data), match3 === null && (match3 = YAML_TIMESTAMP_REGEXP$2.exec(data)), match3 === null) throw new Error("Date resolve error");
  if (year = +match3[1], month = +match3[2] - 1, day = +match3[3], !match3[4])
    return new Date(Date.UTC(year, month, day));
  if (hour = +match3[4], minute = +match3[5], second = +match3[6], match3[7]) {
    for (fraction = match3[7].slice(0, 3); fraction.length < 3; )
      fraction += "0";
    fraction = +fraction;
  }
  return match3[9] && (tz_hour = +match3[10], tz_minute = +(match3[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match3[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
}
function representYamlTimestamp$2(object) {
  return object.toISOString();
}
var timestamp$3 = new Type$F("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp$2,
  construct: constructYamlTimestamp$2,
  instanceOf: Date,
  represent: representYamlTimestamp$2
}), Type$E = type$2;
function resolveYamlMerge$2(data) {
  return data === "<<" || data === null;
}
var merge$4 = new Type$E("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge$2
});
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var NodeBuffer$1;
try {
  var _require$3 = commonjsRequire;
  NodeBuffer$1 = _require$3("buffer").Buffer;
} catch {
}
var Type$D = type$2, BASE64_MAP$2 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function resolveYamlBinary$2(data) {
  if (data === null) return !1;
  var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP$2;
  for (idx = 0; idx < max2; idx++)
    if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
      if (code < 0) return !1;
      bitlen += 6;
    }
  return bitlen % 8 === 0;
}
function constructYamlBinary$2(data) {
  var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP$2, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++)
    idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
  return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer$1 ? NodeBuffer$1.from ? NodeBuffer$1.from(result) : new NodeBuffer$1(result) : result;
}
function representYamlBinary$2(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP$2;
  for (idx = 0; idx < max2; idx++)
    idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
  return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
}
function isBinary$2(object) {
  return NodeBuffer$1 && NodeBuffer$1.isBuffer(object);
}
var binary$3 = new Type$D("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary$2,
  construct: constructYamlBinary$2,
  predicate: isBinary$2,
  represent: representYamlBinary$2
}), Type$C = type$2, _hasOwnProperty$b = Object.prototype.hasOwnProperty, _toString$8 = Object.prototype.toString;
function resolveYamlOmap$2(data) {
  if (data === null) return !0;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], pairHasKey = !1, _toString$8.call(pair) !== "[object Object]") return !1;
    for (pairKey in pair)
      if (_hasOwnProperty$b.call(pair, pairKey))
        if (!pairHasKey) pairHasKey = !0;
        else return !1;
    if (!pairHasKey) return !1;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return !1;
  }
  return !0;
}
function constructYamlOmap$2(data) {
  return data !== null ? data : [];
}
var omap$2 = new Type$C("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap$2,
  construct: constructYamlOmap$2
}), Type$B = type$2, _toString$7 = Object.prototype.toString;
function resolveYamlPairs$2(data) {
  if (data === null) return !0;
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], _toString$7.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return !0;
}
function constructYamlPairs$2(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
    pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
  return result;
}
var pairs$3 = new Type$B("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs$2,
  construct: constructYamlPairs$2
}), Type$A = type$2, _hasOwnProperty$a = Object.prototype.hasOwnProperty;
function resolveYamlSet$2(data) {
  if (data === null) return !0;
  var key2, object = data;
  for (key2 in object)
    if (_hasOwnProperty$a.call(object, key2) && object[key2] !== null)
      return !1;
  return !0;
}
function constructYamlSet$2(data) {
  return data !== null ? data : {};
}
var set$2 = new Type$A("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet$2,
  construct: constructYamlSet$2
}), Schema$9 = schema$2, default_safe$1 = new Schema$9({
  include: [
    core$6
  ],
  implicit: [
    timestamp$3,
    merge$4
  ],
  explicit: [
    binary$3,
    omap$2,
    pairs$3,
    set$2
  ]
}), Type$z = type$2;
function resolveJavascriptUndefined$1() {
  return !0;
}
function constructJavascriptUndefined$1() {
}
function representJavascriptUndefined$1() {
  return "";
}
function isUndefined$1(object) {
  return typeof object > "u";
}
var _undefined$1 = new Type$z("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: resolveJavascriptUndefined$1,
  construct: constructJavascriptUndefined$1,
  predicate: isUndefined$1,
  represent: representJavascriptUndefined$1
}), Type$y = type$2;
function resolveJavascriptRegExp$1(data) {
  if (data === null || data.length === 0) return !1;
  var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
  return !(regexp2[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp2[regexp2.length - modifiers.length - 1] !== "/"));
}
function constructJavascriptRegExp$1(data) {
  var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
  return regexp2[0] === "/" && (tail && (modifiers = tail[1]), regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1)), new RegExp(regexp2, modifiers);
}
function representJavascriptRegExp$1(object) {
  var result = "/" + object.source + "/";
  return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
}
function isRegExp$1(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var regexp$1 = new Type$y("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: resolveJavascriptRegExp$1,
  construct: constructJavascriptRegExp$1,
  predicate: isRegExp$1,
  represent: representJavascriptRegExp$1
}), esprima$4;
try {
  var _require$2 = commonjsRequire;
  esprima$4 = _require$2("esprima");
} catch {
  typeof window < "u" && (esprima$4 = window.esprima);
}
var Type$x = type$2;
function resolveJavascriptFunction$1(data) {
  if (data === null) return !1;
  try {
    var source2 = "(" + data + ")", ast = esprima$4.parse(source2, { range: !0 });
    return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
  } catch {
    return !1;
  }
}
function constructJavascriptFunction$1(data) {
  var source2 = "(" + data + ")", ast = esprima$4.parse(source2, { range: !0 }), params = [], body;
  if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
    throw new Error("Failed to resolve function");
  return ast.body[0].expression.params.forEach(function(param) {
    params.push(param.name);
  }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source2.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source2.slice(body[0], body[1]));
}
function representJavascriptFunction$1(object) {
  return object.toString();
}
function isFunction$2(object) {
  return Object.prototype.toString.call(object) === "[object Function]";
}
var _function$1 = new Type$x("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: resolveJavascriptFunction$1,
  construct: constructJavascriptFunction$1,
  predicate: isFunction$2,
  represent: representJavascriptFunction$1
}), Schema$8 = schema$2, default_full$1 = Schema$8.DEFAULT = new Schema$8({
  include: [
    default_safe$1
  ],
  explicit: [
    _undefined$1,
    regexp$1,
    _function$1
  ]
}), common$g = common$l, YAMLException$b = exception$2, Mark$2 = mark$2, DEFAULT_SAFE_SCHEMA$3 = default_safe$1, DEFAULT_FULL_SCHEMA$3 = default_full$1, _hasOwnProperty$9 = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN$2 = 1, CONTEXT_FLOW_OUT$2 = 2, CONTEXT_BLOCK_IN$2 = 3, CONTEXT_BLOCK_OUT$2 = 4, CHOMPING_CLIP$2 = 1, CHOMPING_STRIP$2 = 2, CHOMPING_KEEP$2 = 3, PATTERN_NON_PRINTABLE$2 = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS$2 = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS$2 = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE$2 = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI$2 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class$2(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL$2(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE$2(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL$2(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR$2(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode$2(c2) {
  var lc;
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
}
function escapedHexLen$2(c2) {
  return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
}
function fromDecimalCode$2(c2) {
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
}
function simpleEscapeSequence$2(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint$2(c2) {
  return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck$2 = new Array(256), simpleEscapeMap$2 = new Array(256);
for (var i$2 = 0; i$2 < 256; i$2++)
  simpleEscapeCheck$2[i$2] = simpleEscapeSequence$2(i$2) ? 1 : 0, simpleEscapeMap$2[i$2] = simpleEscapeSequence$2(i$2);
function State$6(input2, options2) {
  this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_FULL_SCHEMA$3, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
}
function generateError$2(state2, message) {
  return new YAMLException$b(
    message,
    new Mark$2(state2.filename, state2.input, state2.position, state2.line, state2.position - state2.lineStart)
  );
}
function throwError$3(state2, message) {
  throw generateError$2(state2, message);
}
function throwWarning$2(state2, message) {
  state2.onWarning && state2.onWarning.call(null, generateError$2(state2, message));
}
var directiveHandlers$2 = {
  YAML: function(state2, name, args) {
    var match3, major, minor;
    state2.version !== null && throwError$3(state2, "duplication of %YAML directive"), args.length !== 1 && throwError$3(state2, "YAML directive accepts exactly one argument"), match3 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match3 === null && throwError$3(state2, "ill-formed argument of the YAML directive"), major = parseInt(match3[1], 10), minor = parseInt(match3[2], 10), major !== 1 && throwError$3(state2, "unacceptable YAML version of the document"), state2.version = args[0], state2.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning$2(state2, "unsupported YAML version of the document");
  },
  TAG: function(state2, name, args) {
    var handle, prefix;
    args.length !== 2 && throwError$3(state2, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE$2.test(handle) || throwError$3(state2, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty$9.call(state2.tagMap, handle) && throwError$3(state2, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI$2.test(prefix) || throwError$3(state2, "ill-formed tag prefix (second argument) of the TAG directive"), state2.tagMap[handle] = prefix;
  }
};
function captureSegment$2(state2, start, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start < end2) {
    if (_result = state2.input.slice(start, end2), checkJson)
      for (_position = 0, _length = _result.length; _position < _length; _position += 1)
        _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError$3(state2, "expected valid JSON character");
    else PATTERN_NON_PRINTABLE$2.test(_result) && throwError$3(state2, "the stream contains non-printable characters");
    state2.result += _result;
  }
}
function mergeMappings$2(state2, destination, source2, overridableKeys) {
  var sourceKeys, key2, index, quantity;
  for (common$g.isObject(source2) || throwError$3(state2, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
    key2 = sourceKeys[index], _hasOwnProperty$9.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
}
function storeMappingPair$2(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode))
    for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
      Array.isArray(keyNode[index]) && throwError$3(state2, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class$2(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
  if (typeof keyNode == "object" && _class$2(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
    if (Array.isArray(valueNode))
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
        mergeMappings$2(state2, _result, valueNode[index], overridableKeys);
    else
      mergeMappings$2(state2, _result, valueNode, overridableKeys);
  else
    !state2.json && !_hasOwnProperty$9.call(overridableKeys, keyNode) && _hasOwnProperty$9.call(_result, keyNode) && (state2.line = startLine || state2.line, state2.position = startPos || state2.position, throwError$3(state2, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
  return _result;
}
function readLineBreak$2(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position), ch === 10 ? state2.position++ : ch === 13 ? (state2.position++, state2.input.charCodeAt(state2.position) === 10 && state2.position++) : throwError$3(state2, "a line break is expected"), state2.line += 1, state2.lineStart = state2.position;
}
function skipSeparationSpace$2(state2, allowComments, checkIndent) {
  for (var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position); ch !== 0; ) {
    for (; is_WHITE_SPACE$2(ch); )
      ch = state2.input.charCodeAt(++state2.position);
    if (allowComments && ch === 35)
      do
        ch = state2.input.charCodeAt(++state2.position);
      while (ch !== 10 && ch !== 13 && ch !== 0);
    if (is_EOL$2(ch))
      for (readLineBreak$2(state2), ch = state2.input.charCodeAt(state2.position), lineBreaks++, state2.lineIndent = 0; ch === 32; )
        state2.lineIndent++, ch = state2.input.charCodeAt(++state2.position);
    else
      break;
  }
  return checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent && throwWarning$2(state2, "deficient indentation"), lineBreaks;
}
function testDocumentSeparator$2(state2) {
  var _position = state2.position, ch;
  return ch = state2.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2) && (_position += 3, ch = state2.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL$2(ch)));
}
function writeFoldedLines$2(state2, count2) {
  count2 === 1 ? state2.result += " " : count2 > 1 && (state2.result += common$g.repeat(`
`, count2 - 1));
}
function readPlainScalar$2(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  if (ch = state2.input.charCodeAt(state2.position), is_WS_OR_EOL$2(ch) || is_FLOW_INDICATOR$2(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL$2(following) || withinFlowCollection && is_FLOW_INDICATOR$2(following)))
    return !1;
  for (state2.kind = "scalar", state2.result = "", captureStart = captureEnd = state2.position, hasPendingContent = !1; ch !== 0; ) {
    if (ch === 58) {
      if (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL$2(following) || withinFlowCollection && is_FLOW_INDICATOR$2(following))
        break;
    } else if (ch === 35) {
      if (preceding = state2.input.charCodeAt(state2.position - 1), is_WS_OR_EOL$2(preceding))
        break;
    } else {
      if (state2.position === state2.lineStart && testDocumentSeparator$2(state2) || withinFlowCollection && is_FLOW_INDICATOR$2(ch))
        break;
      if (is_EOL$2(ch))
        if (_line = state2.line, _lineStart = state2.lineStart, _lineIndent = state2.lineIndent, skipSeparationSpace$2(state2, !1, -1), state2.lineIndent >= nodeIndent) {
          hasPendingContent = !0, ch = state2.input.charCodeAt(state2.position);
          continue;
        } else {
          state2.position = captureEnd, state2.line = _line, state2.lineStart = _lineStart, state2.lineIndent = _lineIndent;
          break;
        }
    }
    hasPendingContent && (captureSegment$2(state2, captureStart, captureEnd, !1), writeFoldedLines$2(state2, state2.line - _line), captureStart = captureEnd = state2.position, hasPendingContent = !1), is_WHITE_SPACE$2(ch) || (captureEnd = state2.position + 1), ch = state2.input.charCodeAt(++state2.position);
  }
  return captureSegment$2(state2, captureStart, captureEnd, !1), state2.result ? !0 : (state2.kind = _kind, state2.result = _result, !1);
}
function readSingleQuotedScalar$2(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 39)
    return !1;
  for (state2.kind = "scalar", state2.result = "", state2.position++, captureStart = captureEnd = state2.position; (ch = state2.input.charCodeAt(state2.position)) !== 0; )
    if (ch === 39)
      if (captureSegment$2(state2, captureStart, state2.position, !0), ch = state2.input.charCodeAt(++state2.position), ch === 39)
        captureStart = state2.position, state2.position++, captureEnd = state2.position;
      else
        return !0;
    else is_EOL$2(ch) ? (captureSegment$2(state2, captureStart, captureEnd, !0), writeFoldedLines$2(state2, skipSeparationSpace$2(state2, !1, nodeIndent)), captureStart = captureEnd = state2.position) : state2.position === state2.lineStart && testDocumentSeparator$2(state2) ? throwError$3(state2, "unexpected end of the document within a single quoted scalar") : (state2.position++, captureEnd = state2.position);
  throwError$3(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar$2(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 34)
    return !1;
  for (state2.kind = "scalar", state2.result = "", state2.position++, captureStart = captureEnd = state2.position; (ch = state2.input.charCodeAt(state2.position)) !== 0; ) {
    if (ch === 34)
      return captureSegment$2(state2, captureStart, state2.position, !0), state2.position++, !0;
    if (ch === 92) {
      if (captureSegment$2(state2, captureStart, state2.position, !0), ch = state2.input.charCodeAt(++state2.position), is_EOL$2(ch))
        skipSeparationSpace$2(state2, !1, nodeIndent);
      else if (ch < 256 && simpleEscapeCheck$2[ch])
        state2.result += simpleEscapeMap$2[ch], state2.position++;
      else if ((tmp2 = escapedHexLen$2(ch)) > 0) {
        for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
          ch = state2.input.charCodeAt(++state2.position), (tmp2 = fromHexCode$2(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError$3(state2, "expected hexadecimal character");
        state2.result += charFromCodepoint$2(hexResult), state2.position++;
      } else
        throwError$3(state2, "unknown escape sequence");
      captureStart = captureEnd = state2.position;
    } else is_EOL$2(ch) ? (captureSegment$2(state2, captureStart, captureEnd, !0), writeFoldedLines$2(state2, skipSeparationSpace$2(state2, !1, nodeIndent)), captureStart = captureEnd = state2.position) : state2.position === state2.lineStart && testDocumentSeparator$2(state2) ? throwError$3(state2, "unexpected end of the document within a double quoted scalar") : (state2.position++, captureEnd = state2.position);
  }
  throwError$3(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection$2(state2, nodeIndent) {
  var readNext = !0, _line, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch === 91)
    terminator = 93, isMapping = !1, _result = [];
  else if (ch === 123)
    terminator = 125, isMapping = !0, _result = {};
  else
    return !1;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(++state2.position); ch !== 0; ) {
    if (skipSeparationSpace$2(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), ch === terminator)
      return state2.position++, state2.tag = _tag, state2.anchor = _anchor, state2.kind = isMapping ? "mapping" : "sequence", state2.result = _result, !0;
    readNext || throwError$3(state2, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL$2(following) && (isPair = isExplicitPair = !0, state2.position++, skipSeparationSpace$2(state2, !0, nodeIndent))), _line = state2.line, composeNode$2(state2, nodeIndent, CONTEXT_FLOW_IN$2, !1, !0), keyTag = state2.tag, keyNode = state2.result, skipSeparationSpace$2(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), (isExplicitPair || state2.line === _line) && ch === 58 && (isPair = !0, ch = state2.input.charCodeAt(++state2.position), skipSeparationSpace$2(state2, !0, nodeIndent), composeNode$2(state2, nodeIndent, CONTEXT_FLOW_IN$2, !1, !0), valueNode = state2.result), isMapping ? storeMappingPair$2(state2, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair$2(state2, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace$2(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), ch === 44 ? (readNext = !0, ch = state2.input.charCodeAt(++state2.position)) : readNext = !1;
  }
  throwError$3(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar$2(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP$2, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch === 124)
    folding = !1;
  else if (ch === 62)
    folding = !0;
  else
    return !1;
  for (state2.kind = "scalar", state2.result = ""; ch !== 0; )
    if (ch = state2.input.charCodeAt(++state2.position), ch === 43 || ch === 45)
      CHOMPING_CLIP$2 === chomping ? chomping = ch === 43 ? CHOMPING_KEEP$2 : CHOMPING_STRIP$2 : throwError$3(state2, "repeat of a chomping mode identifier");
    else if ((tmp2 = fromDecimalCode$2(ch)) >= 0)
      tmp2 === 0 ? throwError$3(state2, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError$3(state2, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
    else
      break;
  if (is_WHITE_SPACE$2(ch)) {
    do
      ch = state2.input.charCodeAt(++state2.position);
    while (is_WHITE_SPACE$2(ch));
    if (ch === 35)
      do
        ch = state2.input.charCodeAt(++state2.position);
      while (!is_EOL$2(ch) && ch !== 0);
  }
  for (; ch !== 0; ) {
    for (readLineBreak$2(state2), state2.lineIndent = 0, ch = state2.input.charCodeAt(state2.position); (!detectedIndent || state2.lineIndent < textIndent) && ch === 32; )
      state2.lineIndent++, ch = state2.input.charCodeAt(++state2.position);
    if (!detectedIndent && state2.lineIndent > textIndent && (textIndent = state2.lineIndent), is_EOL$2(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      chomping === CHOMPING_KEEP$2 ? state2.result += common$g.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP$2 && didReadContent && (state2.result += `
`);
      break;
    }
    for (folding ? is_WHITE_SPACE$2(ch) ? (atMoreIndented = !0, state2.result += common$g.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state2.result += common$g.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state2.result += " ") : state2.result += common$g.repeat(`
`, emptyLines) : state2.result += common$g.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state2.position; !is_EOL$2(ch) && ch !== 0; )
      ch = state2.input.charCodeAt(++state2.position);
    captureSegment$2(state2, captureStart, state2.position, !1);
  }
  return !0;
}
function readBlockSequence$2(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = !1, ch;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(state2.position); ch !== 0 && !(ch !== 45 || (following = state2.input.charCodeAt(state2.position + 1), !is_WS_OR_EOL$2(following))); ) {
    if (detected = !0, state2.position++, skipSeparationSpace$2(state2, !0, -1) && state2.lineIndent <= nodeIndent) {
      _result.push(null), ch = state2.input.charCodeAt(state2.position);
      continue;
    }
    if (_line = state2.line, composeNode$2(state2, nodeIndent, CONTEXT_BLOCK_IN$2, !1, !0), _result.push(state2.result), skipSeparationSpace$2(state2, !0, -1), ch = state2.input.charCodeAt(state2.position), (state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0)
      throwError$3(state2, "bad indentation of a sequence entry");
    else if (state2.lineIndent < nodeIndent)
      break;
  }
  return detected ? (state2.tag = _tag, state2.anchor = _anchor, state2.kind = "sequence", state2.result = _result, !0) : !1;
}
function readBlockMapping$2(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _pos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(state2.position); ch !== 0; ) {
    if (following = state2.input.charCodeAt(state2.position + 1), _line = state2.line, _pos = state2.position, (ch === 63 || ch === 58) && is_WS_OR_EOL$2(following))
      ch === 63 ? (atExplicitKey && (storeMappingPair$2(state2, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError$3(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state2.position += 1, ch = following;
    else if (composeNode$2(state2, flowIndent, CONTEXT_FLOW_OUT$2, !1, !0))
      if (state2.line === _line) {
        for (ch = state2.input.charCodeAt(state2.position); is_WHITE_SPACE$2(ch); )
          ch = state2.input.charCodeAt(++state2.position);
        if (ch === 58)
          ch = state2.input.charCodeAt(++state2.position), is_WS_OR_EOL$2(ch) || throwError$3(state2, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair$2(state2, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state2.tag, keyNode = state2.result;
        else if (detected)
          throwError$3(state2, "can not read an implicit mapping pair; a colon is missed");
        else
          return state2.tag = _tag, state2.anchor = _anchor, !0;
      } else if (detected)
        throwError$3(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return state2.tag = _tag, state2.anchor = _anchor, !0;
    else
      break;
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && (composeNode$2(state2, nodeIndent, CONTEXT_BLOCK_OUT$2, !0, allowCompact) && (atExplicitKey ? keyNode = state2.result : valueNode = state2.result), atExplicitKey || (storeMappingPair$2(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace$2(state2, !0, -1), ch = state2.input.charCodeAt(state2.position)), state2.lineIndent > nodeIndent && ch !== 0)
      throwError$3(state2, "bad indentation of a mapping entry");
    else if (state2.lineIndent < nodeIndent)
      break;
  }
  return atExplicitKey && storeMappingPair$2(state2, _result, overridableKeys, keyTag, keyNode, null), detected && (state2.tag = _tag, state2.anchor = _anchor, state2.kind = "mapping", state2.result = _result), detected;
}
function readTagProperty$2(state2) {
  var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 33) return !1;
  if (state2.tag !== null && throwError$3(state2, "duplication of a tag property"), ch = state2.input.charCodeAt(++state2.position), ch === 60 ? (isVerbatim = !0, ch = state2.input.charCodeAt(++state2.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state2.input.charCodeAt(++state2.position)) : tagHandle = "!", _position = state2.position, isVerbatim) {
    do
      ch = state2.input.charCodeAt(++state2.position);
    while (ch !== 0 && ch !== 62);
    state2.position < state2.length ? (tagName = state2.input.slice(_position, state2.position), ch = state2.input.charCodeAt(++state2.position)) : throwError$3(state2, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; ch !== 0 && !is_WS_OR_EOL$2(ch); )
      ch === 33 && (isNamed ? throwError$3(state2, "tag suffix cannot contain exclamation marks") : (tagHandle = state2.input.slice(_position - 1, state2.position + 1), PATTERN_TAG_HANDLE$2.test(tagHandle) || throwError$3(state2, "named tag handle cannot contain such characters"), isNamed = !0, _position = state2.position + 1)), ch = state2.input.charCodeAt(++state2.position);
    tagName = state2.input.slice(_position, state2.position), PATTERN_FLOW_INDICATORS$2.test(tagName) && throwError$3(state2, "tag suffix cannot contain flow indicator characters");
  }
  return tagName && !PATTERN_TAG_URI$2.test(tagName) && throwError$3(state2, "tag name cannot contain such characters: " + tagName), isVerbatim ? state2.tag = tagName : _hasOwnProperty$9.call(state2.tagMap, tagHandle) ? state2.tag = state2.tagMap[tagHandle] + tagName : tagHandle === "!" ? state2.tag = "!" + tagName : tagHandle === "!!" ? state2.tag = "tag:yaml.org,2002:" + tagName : throwError$3(state2, 'undeclared tag handle "' + tagHandle + '"'), !0;
}
function readAnchorProperty$2(state2) {
  var _position, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 38) return !1;
  for (state2.anchor !== null && throwError$3(state2, "duplication of an anchor property"), ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL$2(ch) && !is_FLOW_INDICATOR$2(ch); )
    ch = state2.input.charCodeAt(++state2.position);
  return state2.position === _position && throwError$3(state2, "name of an anchor node must contain at least one character"), state2.anchor = state2.input.slice(_position, state2.position), !0;
}
function readAlias$2(state2) {
  var _position, alias, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 42) return !1;
  for (ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL$2(ch) && !is_FLOW_INDICATOR$2(ch); )
    ch = state2.input.charCodeAt(++state2.position);
  return state2.position === _position && throwError$3(state2, "name of an alias node must contain at least one character"), alias = state2.input.slice(_position, state2.position), state2.anchorMap.hasOwnProperty(alias) || throwError$3(state2, 'unidentified alias "' + alias + '"'), state2.result = state2.anchorMap[alias], skipSeparationSpace$2(state2, !0, -1), !0;
}
function composeNode$2(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
  if (state2.listener !== null && state2.listener("open", state2), state2.tag = null, state2.anchor = null, state2.kind = null, state2.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT$2 === nodeContext || CONTEXT_BLOCK_IN$2 === nodeContext, allowToSeek && skipSeparationSpace$2(state2, !0, -1) && (atNewLine = !0, state2.lineIndent > parentIndent ? indentStatus = 1 : state2.lineIndent === parentIndent ? indentStatus = 0 : state2.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
    for (; readTagProperty$2(state2) || readAnchorProperty$2(state2); )
      skipSeparationSpace$2(state2, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state2.lineIndent > parentIndent ? indentStatus = 1 : state2.lineIndent === parentIndent ? indentStatus = 0 : state2.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
  if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT$2 === nodeContext) && (CONTEXT_FLOW_IN$2 === nodeContext || CONTEXT_FLOW_OUT$2 === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state2.position - state2.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence$2(state2, blockIndent) || readBlockMapping$2(state2, blockIndent, flowIndent)) || readFlowCollection$2(state2, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar$2(state2, flowIndent) || readSingleQuotedScalar$2(state2, flowIndent) || readDoubleQuotedScalar$2(state2, flowIndent) ? hasContent = !0 : readAlias$2(state2) ? (hasContent = !0, (state2.tag !== null || state2.anchor !== null) && throwError$3(state2, "alias node should not have any properties")) : readPlainScalar$2(state2, flowIndent, CONTEXT_FLOW_IN$2 === nodeContext) && (hasContent = !0, state2.tag === null && (state2.tag = "?")), state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence$2(state2, blockIndent))), state2.tag !== null && state2.tag !== "!")
    if (state2.tag === "?") {
      for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
        if (type2 = state2.implicitTypes[typeIndex], type2.resolve(state2.result)) {
          state2.result = type2.construct(state2.result), state2.tag = type2.tag, state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result);
          break;
        }
    } else _hasOwnProperty$9.call(state2.typeMap[state2.kind || "fallback"], state2.tag) ? (type2 = state2.typeMap[state2.kind || "fallback"][state2.tag], state2.result !== null && type2.kind !== state2.kind && throwError$3(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"'), type2.resolve(state2.result) ? (state2.result = type2.construct(state2.result), state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result)) : throwError$3(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag")) : throwError$3(state2, "unknown tag !<" + state2.tag + ">");
  return state2.listener !== null && state2.listener("close", state2), state2.tag !== null || state2.anchor !== null || hasContent;
}
function readDocument$2(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
  for (state2.version = null, state2.checkLineBreaks = state2.legacy, state2.tagMap = {}, state2.anchorMap = {}; (ch = state2.input.charCodeAt(state2.position)) !== 0 && (skipSeparationSpace$2(state2, !0, -1), ch = state2.input.charCodeAt(state2.position), !(state2.lineIndent > 0 || ch !== 37)); ) {
    for (hasDirectives = !0, ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL$2(ch); )
      ch = state2.input.charCodeAt(++state2.position);
    for (directiveName = state2.input.slice(_position, state2.position), directiveArgs = [], directiveName.length < 1 && throwError$3(state2, "directive name must not be less than one character in length"); ch !== 0; ) {
      for (; is_WHITE_SPACE$2(ch); )
        ch = state2.input.charCodeAt(++state2.position);
      if (ch === 35) {
        do
          ch = state2.input.charCodeAt(++state2.position);
        while (ch !== 0 && !is_EOL$2(ch));
        break;
      }
      if (is_EOL$2(ch)) break;
      for (_position = state2.position; ch !== 0 && !is_WS_OR_EOL$2(ch); )
        ch = state2.input.charCodeAt(++state2.position);
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    ch !== 0 && readLineBreak$2(state2), _hasOwnProperty$9.call(directiveHandlers$2, directiveName) ? directiveHandlers$2[directiveName](state2, directiveName, directiveArgs) : throwWarning$2(state2, 'unknown document directive "' + directiveName + '"');
  }
  if (skipSeparationSpace$2(state2, !0, -1), state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45 ? (state2.position += 3, skipSeparationSpace$2(state2, !0, -1)) : hasDirectives && throwError$3(state2, "directives end mark is expected"), composeNode$2(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT$2, !1, !0), skipSeparationSpace$2(state2, !0, -1), state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS$2.test(state2.input.slice(documentStart, state2.position)) && throwWarning$2(state2, "non-ASCII line breaks are interpreted as content"), state2.documents.push(state2.result), state2.position === state2.lineStart && testDocumentSeparator$2(state2)) {
    state2.input.charCodeAt(state2.position) === 46 && (state2.position += 3, skipSeparationSpace$2(state2, !0, -1));
    return;
  }
  if (state2.position < state2.length - 1)
    throwError$3(state2, "end of the stream or a document separator is expected");
  else
    return;
}
function loadDocuments$2(input2, options2) {
  input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
  var state2 = new State$6(input2, options2);
  for (state2.input += "\0"; state2.input.charCodeAt(state2.position) === 32; )
    state2.lineIndent += 1, state2.position += 1;
  for (; state2.position < state2.length - 1; )
    readDocument$2(state2);
  return state2.documents;
}
function loadAll$2(input2, iterator2, options2) {
  var documents = loadDocuments$2(input2, options2), index, length;
  if (typeof iterator2 != "function")
    return documents;
  for (index = 0, length = documents.length; index < length; index += 1)
    iterator2(documents[index]);
}
function load$2(input2, options2) {
  var documents = loadDocuments$2(input2, options2);
  if (documents.length !== 0) {
    if (documents.length === 1)
      return documents[0];
    throw new YAMLException$b("expected a single document in the stream, but found more");
  }
}
function safeLoadAll$1(input2, output, options2) {
  if (typeof output == "function")
    loadAll$2(input2, output, common$g.extend({ schema: DEFAULT_SAFE_SCHEMA$3 }, options2));
  else
    return loadAll$2(input2, common$g.extend({ schema: DEFAULT_SAFE_SCHEMA$3 }, options2));
}
function safeLoad$1(input2, options2) {
  return load$2(input2, common$g.extend({ schema: DEFAULT_SAFE_SCHEMA$3 }, options2));
}
loader$5.loadAll = loadAll$2;
loader$5.load = load$2;
loader$5.safeLoadAll = safeLoadAll$1;
loader$5.safeLoad = safeLoad$1;
var dumper$5 = {}, common$f = common$l, YAMLException$a = exception$2, DEFAULT_FULL_SCHEMA$2 = default_full$1, DEFAULT_SAFE_SCHEMA$2 = default_safe$1, _toString$6 = Object.prototype.toString, _hasOwnProperty$8 = Object.prototype.hasOwnProperty, CHAR_TAB$2 = 9, CHAR_LINE_FEED$2 = 10, CHAR_SPACE$2 = 32, CHAR_EXCLAMATION$2 = 33, CHAR_DOUBLE_QUOTE$3 = 34, CHAR_SHARP$2 = 35, CHAR_PERCENT$2 = 37, CHAR_AMPERSAND$2 = 38, CHAR_SINGLE_QUOTE$3 = 39, CHAR_ASTERISK$3 = 42, CHAR_COMMA$5 = 44, CHAR_MINUS$2 = 45, CHAR_COLON$3 = 58, CHAR_GREATER_THAN$2 = 62, CHAR_QUESTION$2 = 63, CHAR_COMMERCIAL_AT$2 = 64, CHAR_LEFT_SQUARE_BRACKET$4 = 91, CHAR_RIGHT_SQUARE_BRACKET$4 = 93, CHAR_GRAVE_ACCENT$2 = 96, CHAR_LEFT_CURLY_BRACKET$2 = 123, CHAR_VERTICAL_LINE$2 = 124, CHAR_RIGHT_CURLY_BRACKET$2 = 125, ESCAPE_SEQUENCES$2 = {};
ESCAPE_SEQUENCES$2[0] = "\\0";
ESCAPE_SEQUENCES$2[7] = "\\a";
ESCAPE_SEQUENCES$2[8] = "\\b";
ESCAPE_SEQUENCES$2[9] = "\\t";
ESCAPE_SEQUENCES$2[10] = "\\n";
ESCAPE_SEQUENCES$2[11] = "\\v";
ESCAPE_SEQUENCES$2[12] = "\\f";
ESCAPE_SEQUENCES$2[13] = "\\r";
ESCAPE_SEQUENCES$2[27] = "\\e";
ESCAPE_SEQUENCES$2[34] = '\\"';
ESCAPE_SEQUENCES$2[92] = "\\\\";
ESCAPE_SEQUENCES$2[133] = "\\N";
ESCAPE_SEQUENCES$2[160] = "\\_";
ESCAPE_SEQUENCES$2[8232] = "\\L";
ESCAPE_SEQUENCES$2[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX$2 = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function compileStyleMap$2(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
    tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty$8.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
  return result;
}
function encodeHex$2(character) {
  var string, handle, length;
  if (string = character.toString(16).toUpperCase(), character <= 255)
    handle = "x", length = 2;
  else if (character <= 65535)
    handle = "u", length = 4;
  else if (character <= 4294967295)
    handle = "U", length = 8;
  else
    throw new YAMLException$a("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + handle + common$f.repeat("0", length - string.length) + string;
}
function State$5(options2) {
  this.schema = options2.schema || DEFAULT_FULL_SCHEMA$2, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common$f.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap$2(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function indentString$2(string, spaces) {
  for (var ind = common$f.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
    next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
  return result;
}
function generateNextLine$2(state2, level) {
  return `
` + common$f.repeat(" ", state2.indent * level);
}
function testImplicitResolving$2(state2, str2) {
  var index, length, type2;
  for (index = 0, length = state2.implicitTypes.length; index < length; index += 1)
    if (type2 = state2.implicitTypes[index], type2.resolve(str2))
      return !0;
  return !1;
}
function isWhitespace$2(c2) {
  return c2 === CHAR_SPACE$2 || c2 === CHAR_TAB$2;
}
function isPrintable$2(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
}
function isPlainSafe$2(c2) {
  return isPrintable$2(c2) && c2 !== 65279 && c2 !== CHAR_COMMA$5 && c2 !== CHAR_LEFT_SQUARE_BRACKET$4 && c2 !== CHAR_RIGHT_SQUARE_BRACKET$4 && c2 !== CHAR_LEFT_CURLY_BRACKET$2 && c2 !== CHAR_RIGHT_CURLY_BRACKET$2 && c2 !== CHAR_COLON$3 && c2 !== CHAR_SHARP$2;
}
function isPlainSafeFirst$2(c2) {
  return isPrintable$2(c2) && c2 !== 65279 && !isWhitespace$2(c2) && c2 !== CHAR_MINUS$2 && c2 !== CHAR_QUESTION$2 && c2 !== CHAR_COLON$3 && c2 !== CHAR_COMMA$5 && c2 !== CHAR_LEFT_SQUARE_BRACKET$4 && c2 !== CHAR_RIGHT_SQUARE_BRACKET$4 && c2 !== CHAR_LEFT_CURLY_BRACKET$2 && c2 !== CHAR_RIGHT_CURLY_BRACKET$2 && c2 !== CHAR_SHARP$2 && c2 !== CHAR_AMPERSAND$2 && c2 !== CHAR_ASTERISK$3 && c2 !== CHAR_EXCLAMATION$2 && c2 !== CHAR_VERTICAL_LINE$2 && c2 !== CHAR_GREATER_THAN$2 && c2 !== CHAR_SINGLE_QUOTE$3 && c2 !== CHAR_DOUBLE_QUOTE$3 && c2 !== CHAR_PERCENT$2 && c2 !== CHAR_COMMERCIAL_AT$2 && c2 !== CHAR_GRAVE_ACCENT$2;
}
function needIndentIndicator$2(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN$2 = 1, STYLE_SINGLE$2 = 2, STYLE_LITERAL$2 = 3, STYLE_FOLDED$2 = 4, STYLE_DOUBLE$2 = 5;
function chooseScalarStyle$2(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i2, char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst$2(string.charCodeAt(0)) && !isWhitespace$2(string.charCodeAt(string.length - 1));
  if (singleLineOnly)
    for (i2 = 0; i2 < string.length; i2++) {
      if (char = string.charCodeAt(i2), !isPrintable$2(char))
        return STYLE_DOUBLE$2;
      plain = plain && isPlainSafe$2(char);
    }
  else {
    for (i2 = 0; i2 < string.length; i2++) {
      if (char = string.charCodeAt(i2), char === CHAR_LINE_FEED$2)
        hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
        i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i2);
      else if (!isPrintable$2(char))
        return STYLE_DOUBLE$2;
      plain = plain && isPlainSafe$2(char);
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
  }
  return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN$2 : STYLE_SINGLE$2 : indentPerLevel > 9 && needIndentIndicator$2(string) ? STYLE_DOUBLE$2 : hasFoldableLine ? STYLE_FOLDED$2 : STYLE_LITERAL$2;
}
function writeScalar$2(state2, string, level, iskey) {
  state2.dump = function() {
    if (string.length === 0)
      return "''";
    if (!state2.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX$2.indexOf(string) !== -1)
      return "'" + string + "'";
    var indent = state2.indent * Math.max(1, level), lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent), singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving$2(state2, string2);
    }
    switch (chooseScalarStyle$2(string, singleLineOnly, state2.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN$2:
        return string;
      case STYLE_SINGLE$2:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL$2:
        return "|" + blockHeader$2(string, state2.indent) + dropEndingNewline$2(indentString$2(string, indent));
      case STYLE_FOLDED$2:
        return ">" + blockHeader$2(string, state2.indent) + dropEndingNewline$2(indentString$2(foldString$2(string, lineWidth), indent));
      case STYLE_DOUBLE$2:
        return '"' + escapeString$3(string) + '"';
      default:
        throw new YAMLException$a("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader$2(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator$2(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + `
`;
}
function dropEndingNewline$2(string) {
  return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
}
function foldString$2(string, width) {
  for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
    var nextLF = string.indexOf(`
`);
    return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine$2(string.slice(0, nextLF), width);
  }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match3; match3 = lineRe.exec(string); ) {
    var prefix = match3[1], line3 = match3[2];
    moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine$2(line3, width), prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine$2(line3, width) {
  if (line3 === "" || line3[0] === " ") return line3;
  for (var breakRe = / [^ ]/g, match3, start = 0, end2, curr = 0, next = 0, result = ""; match3 = breakRe.exec(line3); )
    next = match3.index, next - start > width && (end2 = curr > start ? curr : next, result += `
` + line3.slice(start, end2), start = end2 + 1), curr = next;
  return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
}
function escapeString$3(string) {
  for (var result = "", char, nextChar, escapeSeq, i2 = 0; i2 < string.length; i2++) {
    if (char = string.charCodeAt(i2), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i2 + 1), nextChar >= 56320 && nextChar <= 57343)) {
      result += encodeHex$2((char - 55296) * 1024 + nextChar - 56320 + 65536), i2++;
      continue;
    }
    escapeSeq = ESCAPE_SEQUENCES$2[char], result += !escapeSeq && isPrintable$2(char) ? string[i2] : escapeSeq || encodeHex$2(char);
  }
  return result;
}
function writeFlowSequence$2(state2, level, object) {
  var _result = "", _tag = state2.tag, index, length;
  for (index = 0, length = object.length; index < length; index += 1)
    writeNode$2(state2, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state2.condenseFlow ? "" : " ")), _result += state2.dump);
  state2.tag = _tag, state2.dump = "[" + _result + "]";
}
function writeBlockSequence$2(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, index, length;
  for (index = 0, length = object.length; index < length; index += 1)
    writeNode$2(state2, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine$2(state2, level)), state2.dump && CHAR_LINE_FEED$2 === state2.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state2.dump);
  state2.tag = _tag, state2.dump = _result || "[]";
}
function writeFlowMapping$2(state2, level, object) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1)
    pairBuffer = state2.condenseFlow ? '"' : "", index !== 0 && (pairBuffer += ", "), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode$2(state2, level, objectKey, !1, !1) && (state2.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " "), writeNode$2(state2, level, objectValue, !1, !1) && (pairBuffer += state2.dump, _result += pairBuffer));
  state2.tag = _tag, state2.dump = "{" + _result + "}";
}
function writeBlockMapping$2(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state2.sortKeys === !0)
    objectKeyList.sort();
  else if (typeof state2.sortKeys == "function")
    objectKeyList.sort(state2.sortKeys);
  else if (state2.sortKeys)
    throw new YAMLException$a("sortKeys must be a boolean or a function");
  for (index = 0, length = objectKeyList.length; index < length; index += 1)
    pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine$2(state2, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode$2(state2, level + 1, objectKey, !0, !0, !0) && (explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024, explicitPair && (state2.dump && CHAR_LINE_FEED$2 === state2.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state2.dump, explicitPair && (pairBuffer += generateNextLine$2(state2, level)), writeNode$2(state2, level + 1, objectValue, !0, explicitPair) && (state2.dump && CHAR_LINE_FEED$2 === state2.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state2.dump, _result += pairBuffer));
  state2.tag = _tag, state2.dump = _result || "{}";
}
function detectType$2(state2, object, explicit) {
  var _result, typeList, index, length, type2, style;
  for (typeList = explicit ? state2.explicitTypes : state2.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
    if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (state2.tag = explicit ? type2.tag : "?", type2.represent) {
        if (style = state2.styleMap[type2.tag] || type2.defaultStyle, _toString$6.call(type2.represent) === "[object Function]")
          _result = type2.represent(object, style);
        else if (_hasOwnProperty$8.call(type2.represent, style))
          _result = type2.represent[style](object, style);
        else
          throw new YAMLException$a("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        state2.dump = _result;
      }
      return !0;
    }
  return !1;
}
function writeNode$2(state2, level, object, block, compact, iskey) {
  state2.tag = null, state2.dump = object, detectType$2(state2, object, !1) || detectType$2(state2, object, !0);
  var type2 = _toString$6.call(state2.dump);
  block && (block = state2.flowLevel < 0 || state2.flowLevel > level);
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate2;
  if (objectOrArray && (duplicateIndex = state2.duplicates.indexOf(object), duplicate2 = duplicateIndex !== -1), (state2.tag !== null && state2.tag !== "?" || duplicate2 || state2.indent !== 2 && level > 0) && (compact = !1), duplicate2 && state2.usedDuplicates[duplicateIndex])
    state2.dump = "*ref_" + duplicateIndex;
  else {
    if (objectOrArray && duplicate2 && !state2.usedDuplicates[duplicateIndex] && (state2.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
      block && Object.keys(state2.dump).length !== 0 ? (writeBlockMapping$2(state2, level, state2.dump, compact), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + state2.dump)) : (writeFlowMapping$2(state2, level, state2.dump), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + " " + state2.dump));
    else if (type2 === "[object Array]") {
      var arrayLevel = state2.noArrayIndent && level > 0 ? level - 1 : level;
      block && state2.dump.length !== 0 ? (writeBlockSequence$2(state2, arrayLevel, state2.dump, compact), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + state2.dump)) : (writeFlowSequence$2(state2, arrayLevel, state2.dump), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + " " + state2.dump));
    } else if (type2 === "[object String]")
      state2.tag !== "?" && writeScalar$2(state2, state2.dump, level, iskey);
    else {
      if (state2.skipInvalid) return !1;
      throw new YAMLException$a("unacceptable kind of an object to dump " + type2);
    }
    state2.tag !== null && state2.tag !== "?" && (state2.dump = "!<" + state2.tag + "> " + state2.dump);
  }
  return !0;
}
function getDuplicateReferences$2(object, state2) {
  var objects = [], duplicatesIndexes = [], index, length;
  for (inspectNode$2(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
    state2.duplicates.push(objects[duplicatesIndexes[index]]);
  state2.usedDuplicates = new Array(length);
}
function inspectNode$2(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object == "object")
    if (index = objects.indexOf(object), index !== -1)
      duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
    else if (objects.push(object), Array.isArray(object))
      for (index = 0, length = object.length; index < length; index += 1)
        inspectNode$2(object[index], objects, duplicatesIndexes);
    else
      for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
        inspectNode$2(object[objectKeyList[index]], objects, duplicatesIndexes);
}
function dump$2(input2, options2) {
  options2 = options2 || {};
  var state2 = new State$5(options2);
  return state2.noRefs || getDuplicateReferences$2(input2, state2), writeNode$2(state2, 0, input2, !0, !0) ? state2.dump + `
` : "";
}
function safeDump$1(input2, options2) {
  return dump$2(input2, common$f.extend({ schema: DEFAULT_SAFE_SCHEMA$2 }, options2));
}
dumper$5.dump = dump$2;
dumper$5.safeDump = safeDump$1;
var loader$4 = loader$5, dumper$4 = dumper$5;
function deprecated$1(name) {
  return function() {
    throw new Error("Function " + name + " is deprecated and cannot be used.");
  };
}
jsYaml$4.Type = type$2;
jsYaml$4.Schema = schema$2;
jsYaml$4.FAILSAFE_SCHEMA = failsafe$2;
jsYaml$4.JSON_SCHEMA = json$2;
jsYaml$4.CORE_SCHEMA = core$6;
jsYaml$4.DEFAULT_SAFE_SCHEMA = default_safe$1;
jsYaml$4.DEFAULT_FULL_SCHEMA = default_full$1;
jsYaml$4.load = loader$4.load;
jsYaml$4.loadAll = loader$4.loadAll;
jsYaml$4.safeLoad = loader$4.safeLoad;
jsYaml$4.safeLoadAll = loader$4.safeLoadAll;
jsYaml$4.dump = dumper$4.dump;
jsYaml$4.safeDump = dumper$4.safeDump;
jsYaml$4.YAMLException = exception$2;
jsYaml$4.MINIMAL_SCHEMA = failsafe$2;
jsYaml$4.SAFE_SCHEMA = default_safe$1;
jsYaml$4.DEFAULT_SCHEMA = default_full$1;
jsYaml$4.scan = deprecated$1("scan");
jsYaml$4.parse = deprecated$1("parse");
jsYaml$4.compose = deprecated$1("compose");
jsYaml$4.addConstructor = deprecated$1("addConstructor");
var yaml$2 = jsYaml$4, jsYaml$3 = yaml$2, toml = {}, parse$c = { exports: {} }, tomlParser = { exports: {} };
const ParserEND = 1114112;
class ParserError extends Error {
  /* istanbul ignore next */
  constructor(msg, filename, linenumber) {
    super("[ParserError] " + msg, filename, linenumber), this.name = "ParserError", this.code = "ParserError", Error.captureStackTrace && Error.captureStackTrace(this, ParserError);
  }
}
let State$4 = class {
  constructor(parser2) {
    this.parser = parser2, this.buf = "", this.returned = null, this.result = null, this.resultTable = null, this.resultArr = null;
  }
};
class Parser {
  constructor() {
    this.pos = 0, this.col = 0, this.line = 0, this.obj = {}, this.ctx = this.obj, this.stack = [], this._buf = "", this.char = null, this.ii = 0, this.state = new State$4(this.parseStart);
  }
  parse(str2) {
    if (str2.length === 0 || str2.length == null) return;
    this._buf = String(str2), this.ii = -1, this.char = -1;
    let getNext;
    for (; getNext === !1 || this.nextChar(); )
      getNext = this.runOne();
    this._buf = null;
  }
  nextChar() {
    return this.char === 10 && (++this.line, this.col = -1), ++this.ii, this.char = this._buf.codePointAt(this.ii), ++this.pos, ++this.col, this.haveBuffer();
  }
  haveBuffer() {
    return this.ii < this._buf.length;
  }
  runOne() {
    return this.state.parser.call(this, this.state.returned);
  }
  finish() {
    this.char = ParserEND;
    let last2;
    do
      last2 = this.state.parser, this.runOne();
    while (this.state.parser !== last2);
    return this.ctx = null, this.state = null, this._buf = null, this.obj;
  }
  next(fn2) {
    if (typeof fn2 != "function") throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn2));
    this.state.parser = fn2;
  }
  goto(fn2) {
    return this.next(fn2), this.runOne();
  }
  call(fn2, returnWith) {
    returnWith && this.next(returnWith), this.stack.push(this.state), this.state = new State$4(fn2);
  }
  callNow(fn2, returnWith) {
    return this.call(fn2, returnWith), this.runOne();
  }
  return(value) {
    if (this.stack.length === 0) throw this.error(new ParserError("Stack underflow"));
    value === void 0 && (value = this.state.buf), this.state = this.stack.pop(), this.state.returned = value;
  }
  returnNow(value) {
    return this.return(value), this.runOne();
  }
  consume() {
    if (this.char === ParserEND) throw this.error(new ParserError("Unexpected end-of-buffer"));
    this.state.buf += this._buf[this.ii];
  }
  error(err) {
    return err.line = this.line, err.col = this.col, err.pos = this.pos, err;
  }
  /* istanbul ignore next */
  parseStart() {
    throw new ParserError("Must declare a parseStart method");
  }
}
Parser.END = ParserEND;
Parser.Error = ParserError;
var parser$2 = Parser, createDatetime = (value) => {
  const date = new Date(value);
  if (isNaN(date))
    throw new TypeError("Invalid Datetime");
  return date;
}, formatNum = (d, num) => {
  for (num = String(num); num.length < d; ) num = "0" + num;
  return num;
};
const f$2 = formatNum;
class FloatingDateTime extends Date {
  constructor(value) {
    super(value + "Z"), this.isFloating = !0;
  }
  toISOString() {
    const date = `${this.getUTCFullYear()}-${f$2(2, this.getUTCMonth() + 1)}-${f$2(2, this.getUTCDate())}`, time = `${f$2(2, this.getUTCHours())}:${f$2(2, this.getUTCMinutes())}:${f$2(2, this.getUTCSeconds())}.${f$2(3, this.getUTCMilliseconds())}`;
    return `${date}T${time}`;
  }
}
var createDatetimeFloat = (value) => {
  const date = new FloatingDateTime(value);
  if (isNaN(date))
    throw new TypeError("Invalid Datetime");
  return date;
};
const f$1 = formatNum, DateTime = loadEnv.commonjsGlobal.Date;
let Date$1 = class extends DateTime {
  constructor(value) {
    super(value), this.isDate = !0;
  }
  toISOString() {
    return `${this.getUTCFullYear()}-${f$1(2, this.getUTCMonth() + 1)}-${f$1(2, this.getUTCDate())}`;
  }
};
var createDate$1 = (value) => {
  const date = new Date$1(value);
  if (isNaN(date))
    throw new TypeError("Invalid Datetime");
  return date;
};
const f = formatNum;
class Time extends Date {
  constructor(value) {
    super(`0000-01-01T${value}Z`), this.isTime = !0;
  }
  toISOString() {
    return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
  }
}
var createTime$1 = (value) => {
  const date = new Time(value);
  if (isNaN(date))
    throw new TypeError("Invalid Datetime");
  return date;
};
tomlParser.exports = makeParserClass(parser$2);
tomlParser.exports.makeParserClass = makeParserClass;
class TomlError extends Error {
  constructor(msg) {
    super(msg), this.name = "TomlError", Error.captureStackTrace && Error.captureStackTrace(this, TomlError), this.fromTOML = !0, this.wrapped = null;
  }
}
TomlError.wrap = (err) => {
  const terr = new TomlError(err.message);
  return terr.code = err.code, terr.wrapped = err, terr;
};
tomlParser.exports.TomlError = TomlError;
const createDateTime = createDatetime, createDateTimeFloat = createDatetimeFloat, createDate = createDate$1, createTime = createTime$1, CTRL_I = 9, CTRL_J = 10, CTRL_M = 13, CTRL_CHAR_BOUNDARY = 31, CHAR_SP = 32, CHAR_QUOT = 34, CHAR_NUM = 35, CHAR_APOS = 39, CHAR_PLUS$1 = 43, CHAR_COMMA$4 = 44, CHAR_HYPHEN = 45, CHAR_PERIOD = 46, CHAR_0 = 48, CHAR_1 = 49, CHAR_7 = 55, CHAR_9 = 57, CHAR_COLON$2 = 58, CHAR_EQUALS$2 = 61, CHAR_A = 65, CHAR_E = 69, CHAR_F = 70, CHAR_T = 84, CHAR_U = 85, CHAR_Z = 90, CHAR_LOWBAR = 95, CHAR_a = 97, CHAR_b = 98, CHAR_e = 101, CHAR_f = 102, CHAR_i = 105, CHAR_l = 108, CHAR_n = 110, CHAR_o = 111, CHAR_r = 114, CHAR_s = 115, CHAR_t = 116, CHAR_u = 117, CHAR_x = 120, CHAR_z = 122, CHAR_LCUB = 123, CHAR_RCUB = 125, CHAR_LSQB = 91, CHAR_BSOL = 92, CHAR_RSQB = 93, CHAR_DEL = 127, SURROGATE_FIRST = 55296, SURROGATE_LAST = 57343, escapes = {
  [CHAR_b]: "\b",
  [CHAR_t]: "	",
  [CHAR_n]: `
`,
  [CHAR_f]: "\f",
  [CHAR_r]: "\r",
  [CHAR_QUOT]: '"',
  [CHAR_BSOL]: "\\"
};
function isDigit(cp2) {
  return cp2 >= CHAR_0 && cp2 <= CHAR_9;
}
function isHexit(cp2) {
  return cp2 >= CHAR_A && cp2 <= CHAR_F || cp2 >= CHAR_a && cp2 <= CHAR_f || cp2 >= CHAR_0 && cp2 <= CHAR_9;
}
function isBit(cp2) {
  return cp2 === CHAR_1 || cp2 === CHAR_0;
}
function isOctit(cp2) {
  return cp2 >= CHAR_0 && cp2 <= CHAR_7;
}
function isAlphaNumQuoteHyphen(cp2) {
  return cp2 >= CHAR_A && cp2 <= CHAR_Z || cp2 >= CHAR_a && cp2 <= CHAR_z || cp2 >= CHAR_0 && cp2 <= CHAR_9 || cp2 === CHAR_APOS || cp2 === CHAR_QUOT || cp2 === CHAR_LOWBAR || cp2 === CHAR_HYPHEN;
}
function isAlphaNumHyphen(cp2) {
  return cp2 >= CHAR_A && cp2 <= CHAR_Z || cp2 >= CHAR_a && cp2 <= CHAR_z || cp2 >= CHAR_0 && cp2 <= CHAR_9 || cp2 === CHAR_LOWBAR || cp2 === CHAR_HYPHEN;
}
const _type = Symbol("type"), _declared = Symbol("declared"), hasOwnProperty$2 = Object.prototype.hasOwnProperty, defineProperty = Object.defineProperty, descriptor = { configurable: !0, enumerable: !0, writable: !0, value: void 0 };
function hasKey(obj, key2) {
  return hasOwnProperty$2.call(obj, key2) ? !0 : (key2 === "__proto__" && defineProperty(obj, "__proto__", descriptor), !1);
}
const INLINE_TABLE = Symbol("inline-table");
function InlineTable() {
  return Object.defineProperties({}, {
    [_type]: { value: INLINE_TABLE }
  });
}
function isInlineTable(obj) {
  return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_TABLE;
}
const TABLE = Symbol("table");
function Table() {
  return Object.defineProperties({}, {
    [_type]: { value: TABLE },
    [_declared]: { value: !1, writable: !0 }
  });
}
function isTable(obj) {
  return obj === null || typeof obj != "object" ? !1 : obj[_type] === TABLE;
}
const _contentType = Symbol("content-type"), INLINE_LIST = Symbol("inline-list");
function InlineList(type2) {
  return Object.defineProperties([], {
    [_type]: { value: INLINE_LIST },
    [_contentType]: { value: type2 }
  });
}
function isInlineList(obj) {
  return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_LIST;
}
const LIST = Symbol("list");
function List() {
  return Object.defineProperties([], {
    [_type]: { value: LIST }
  });
}
function isList(obj) {
  return obj === null || typeof obj != "object" ? !1 : obj[_type] === LIST;
}
let _custom;
try {
  const utilInspect = eval("require('util').inspect");
  _custom = utilInspect.custom;
} catch (_2) {
}
const _inspect = _custom || "inspect";
class BoxedBigInt {
  constructor(value) {
    try {
      this.value = loadEnv.commonjsGlobal.BigInt.asIntN(64, value);
    } catch {
      this.value = null;
    }
    Object.defineProperty(this, _type, { value: INTEGER });
  }
  isNaN() {
    return this.value === null;
  }
  /* istanbul ignore next */
  toString() {
    return String(this.value);
  }
  /* istanbul ignore next */
  [_inspect]() {
    return `[BigInt: ${this.toString()}]}`;
  }
  valueOf() {
    return this.value;
  }
}
const INTEGER = Symbol("integer");
function Integer(value) {
  let num = Number(value);
  return Object.is(num, -0) && (num = 0), loadEnv.commonjsGlobal.BigInt && !Number.isSafeInteger(num) ? new BoxedBigInt(value) : Object.defineProperties(new Number(num), {
    isNaN: { value: function() {
      return isNaN(this);
    } },
    [_type]: { value: INTEGER },
    [_inspect]: { value: () => `[Integer: ${value}]` }
  });
}
function isInteger$2(obj) {
  return obj === null || typeof obj != "object" ? !1 : obj[_type] === INTEGER;
}
const FLOAT = Symbol("float");
function Float(value) {
  return Object.defineProperties(new Number(value), {
    [_type]: { value: FLOAT },
    [_inspect]: { value: () => `[Float: ${value}]` }
  });
}
function isFloat$2(obj) {
  return obj === null || typeof obj != "object" ? !1 : obj[_type] === FLOAT;
}
function tomlType$1(value) {
  const type2 = typeof value;
  if (type2 === "object") {
    if (value === null) return "null";
    if (value instanceof Date) return "datetime";
    if (_type in value)
      switch (value[_type]) {
        case INLINE_TABLE:
          return "inline-table";
        case INLINE_LIST:
          return "inline-list";
        case TABLE:
          return "table";
        case LIST:
          return "list";
        case FLOAT:
          return "float";
        case INTEGER:
          return "integer";
      }
  }
  return type2;
}
function makeParserClass(Parser2) {
  class TOMLParser2 extends Parser2 {
    constructor() {
      super(), this.ctx = this.obj = Table();
    }
    /* MATCH HELPER */
    atEndOfWord() {
      return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
    }
    atEndOfLine() {
      return this.char === Parser2.END || this.char === CTRL_J || this.char === CTRL_M;
    }
    parseStart() {
      if (this.char === Parser2.END)
        return null;
      if (this.char === CHAR_LSQB)
        return this.call(this.parseTableOrList);
      if (this.char === CHAR_NUM)
        return this.call(this.parseComment);
      if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
        return null;
      if (isAlphaNumQuoteHyphen(this.char))
        return this.callNow(this.parseAssignStatement);
      throw this.error(new TomlError(`Unknown character "${this.char}"`));
    }
    // HELPER, this strips any whitespace and comments to the end of the line
    // then RETURNS. Last state in a production.
    parseWhitespaceToEOL() {
      if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
        return null;
      if (this.char === CHAR_NUM)
        return this.goto(this.parseComment);
      if (this.char === Parser2.END || this.char === CTRL_J)
        return this.return();
      throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
    }
    /* ASSIGNMENT: key = value */
    parseAssignStatement() {
      return this.callNow(this.parseAssign, this.recordAssignStatement);
    }
    recordAssignStatement(kv) {
      let target = this.ctx, finalKey = kv.key.pop();
      for (let kw of kv.key) {
        if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
          throw this.error(new TomlError("Can't redefine existing key"));
        target = target[kw] = target[kw] || Table();
      }
      if (hasKey(target, finalKey))
        throw this.error(new TomlError("Can't redefine existing key"));
      return isInteger$2(kv.value) || isFloat$2(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseWhitespaceToEOL);
    }
    /* ASSSIGNMENT expression, key = value possibly inside an inline table */
    parseAssign() {
      return this.callNow(this.parseKeyword, this.recordAssignKeyword);
    }
    recordAssignKeyword(key2) {
      return this.state.resultTable ? this.state.resultTable.push(key2) : this.state.resultTable = [key2], this.goto(this.parseAssignKeywordPreDot);
    }
    parseAssignKeywordPreDot() {
      if (this.char === CHAR_PERIOD)
        return this.next(this.parseAssignKeywordPostDot);
      if (this.char !== CHAR_SP && this.char !== CTRL_I)
        return this.goto(this.parseAssignEqual);
    }
    parseAssignKeywordPostDot() {
      if (this.char !== CHAR_SP && this.char !== CTRL_I)
        return this.callNow(this.parseKeyword, this.recordAssignKeyword);
    }
    parseAssignEqual() {
      if (this.char === CHAR_EQUALS$2)
        return this.next(this.parseAssignPreValue);
      throw this.error(new TomlError('Invalid character, expected "="'));
    }
    parseAssignPreValue() {
      return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseValue, this.recordAssignValue);
    }
    recordAssignValue(value) {
      return this.returnNow({ key: this.state.resultTable, value });
    }
    /* COMMENTS: #...eol */
    parseComment() {
      do
        if (this.char === Parser2.END || this.char === CTRL_J)
          return this.return();
      while (this.nextChar());
    }
    /* TABLES AND LISTS, [foo] and [[foo]] */
    parseTableOrList() {
      if (this.char === CHAR_LSQB)
        this.next(this.parseList);
      else
        return this.goto(this.parseTable);
    }
    /* TABLE [foo.bar.baz] */
    parseTable() {
      return this.ctx = this.obj, this.goto(this.parseTableNext);
    }
    parseTableNext() {
      return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseTableMore);
    }
    parseTableMore(keyword) {
      if (this.char === CHAR_SP || this.char === CTRL_I)
        return null;
      if (this.char === CHAR_RSQB) {
        if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared]))
          throw this.error(new TomlError("Can't redefine existing key"));
        return this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table(), this.ctx[_declared] = !0, this.next(this.parseWhitespaceToEOL);
      } else if (this.char === CHAR_PERIOD) {
        if (!hasKey(this.ctx, keyword))
          this.ctx = this.ctx[keyword] = Table();
        else if (isTable(this.ctx[keyword]))
          this.ctx = this.ctx[keyword];
        else if (isList(this.ctx[keyword]))
          this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
        else
          throw this.error(new TomlError("Can't redefine existing key"));
        return this.next(this.parseTableNext);
      } else
        throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
    }
    /* LIST [[a.b.c]] */
    parseList() {
      return this.ctx = this.obj, this.goto(this.parseListNext);
    }
    parseListNext() {
      return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseListMore);
    }
    parseListMore(keyword) {
      if (this.char === CHAR_SP || this.char === CTRL_I)
        return null;
      if (this.char === CHAR_RSQB) {
        if (hasKey(this.ctx, keyword) || (this.ctx[keyword] = List()), isInlineList(this.ctx[keyword]))
          throw this.error(new TomlError("Can't extend an inline array"));
        if (isList(this.ctx[keyword])) {
          const next = Table();
          this.ctx[keyword].push(next), this.ctx = next;
        } else
          throw this.error(new TomlError("Can't redefine an existing key"));
        return this.next(this.parseListEnd);
      } else if (this.char === CHAR_PERIOD) {
        if (!hasKey(this.ctx, keyword))
          this.ctx = this.ctx[keyword] = Table();
        else {
          if (isInlineList(this.ctx[keyword]))
            throw this.error(new TomlError("Can't extend an inline array"));
          if (isInlineTable(this.ctx[keyword]))
            throw this.error(new TomlError("Can't extend an inline table"));
          if (isList(this.ctx[keyword]))
            this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
          else if (isTable(this.ctx[keyword]))
            this.ctx = this.ctx[keyword];
          else
            throw this.error(new TomlError("Can't redefine an existing key"));
        }
        return this.next(this.parseListNext);
      } else
        throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
    }
    parseListEnd(keyword) {
      if (this.char === CHAR_RSQB)
        return this.next(this.parseWhitespaceToEOL);
      throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
    }
    /* VALUE string, number, boolean, inline list, inline object */
    parseValue() {
      if (this.char === Parser2.END)
        throw this.error(new TomlError("Key without value"));
      if (this.char === CHAR_QUOT)
        return this.next(this.parseDoubleString);
      if (this.char === CHAR_APOS)
        return this.next(this.parseSingleString);
      if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS$1)
        return this.goto(this.parseNumberSign);
      if (this.char === CHAR_i)
        return this.next(this.parseInf);
      if (this.char === CHAR_n)
        return this.next(this.parseNan);
      if (isDigit(this.char))
        return this.goto(this.parseNumberOrDateTime);
      if (this.char === CHAR_t || this.char === CHAR_f)
        return this.goto(this.parseBoolean);
      if (this.char === CHAR_LSQB)
        return this.call(this.parseInlineList, this.recordValue);
      if (this.char === CHAR_LCUB)
        return this.call(this.parseInlineTable, this.recordValue);
      throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
    }
    recordValue(value) {
      return this.returnNow(value);
    }
    parseInf() {
      if (this.char === CHAR_n)
        return this.next(this.parseInf2);
      throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
    }
    parseInf2() {
      if (this.char === CHAR_f)
        return this.state.buf === "-" ? this.return(-1 / 0) : this.return(1 / 0);
      throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
    }
    parseNan() {
      if (this.char === CHAR_a)
        return this.next(this.parseNan2);
      throw this.error(new TomlError('Unexpected character, expected "nan"'));
    }
    parseNan2() {
      if (this.char === CHAR_n)
        return this.return(NaN);
      throw this.error(new TomlError('Unexpected character, expected "nan"'));
    }
    /* KEYS, barewords or basic, literal, or dotted */
    parseKeyword() {
      return this.char === CHAR_QUOT ? this.next(this.parseBasicString) : this.char === CHAR_APOS ? this.next(this.parseLiteralString) : this.goto(this.parseBareKey);
    }
    /* KEYS: barewords */
    parseBareKey() {
      do {
        if (this.char === Parser2.END)
          throw this.error(new TomlError("Key ended without value"));
        if (isAlphaNumHyphen(this.char))
          this.consume();
        else {
          if (this.state.buf.length === 0)
            throw this.error(new TomlError("Empty bare keys are not allowed"));
          return this.returnNow();
        }
      } while (this.nextChar());
    }
    /* STRINGS, single quoted (literal) */
    parseSingleString() {
      return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiStringMaybe) : this.goto(this.parseLiteralString);
    }
    parseLiteralString() {
      do {
        if (this.char === CHAR_APOS)
          return this.return();
        if (this.atEndOfLine())
          throw this.error(new TomlError("Unterminated string"));
        if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
          throw this.errorControlCharInString();
        this.consume();
      } while (this.nextChar());
    }
    parseLiteralMultiStringMaybe() {
      return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiString) : this.returnNow();
    }
    parseLiteralMultiString() {
      return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseLiteralMultiStringContent) : this.goto(this.parseLiteralMultiStringContent);
    }
    parseLiteralMultiStringContent() {
      do {
        if (this.char === CHAR_APOS)
          return this.next(this.parseLiteralMultiEnd);
        if (this.char === Parser2.END)
          throw this.error(new TomlError("Unterminated multi-line string"));
        if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
          throw this.errorControlCharInString();
        this.consume();
      } while (this.nextChar());
    }
    parseLiteralMultiEnd() {
      return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiEnd2) : (this.state.buf += "'", this.goto(this.parseLiteralMultiStringContent));
    }
    parseLiteralMultiEnd2() {
      return this.char === CHAR_APOS ? this.return() : (this.state.buf += "''", this.goto(this.parseLiteralMultiStringContent));
    }
    /* STRINGS double quoted */
    parseDoubleString() {
      return this.char === CHAR_QUOT ? this.next(this.parseMultiStringMaybe) : this.goto(this.parseBasicString);
    }
    parseBasicString() {
      do {
        if (this.char === CHAR_BSOL)
          return this.call(this.parseEscape, this.recordEscapeReplacement);
        if (this.char === CHAR_QUOT)
          return this.return();
        if (this.atEndOfLine())
          throw this.error(new TomlError("Unterminated string"));
        if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
          throw this.errorControlCharInString();
        this.consume();
      } while (this.nextChar());
    }
    recordEscapeReplacement(replacement) {
      return this.state.buf += replacement, this.goto(this.parseBasicString);
    }
    parseMultiStringMaybe() {
      return this.char === CHAR_QUOT ? this.next(this.parseMultiString) : this.returnNow();
    }
    parseMultiString() {
      return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseMultiStringContent) : this.goto(this.parseMultiStringContent);
    }
    parseMultiStringContent() {
      do {
        if (this.char === CHAR_BSOL)
          return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
        if (this.char === CHAR_QUOT)
          return this.next(this.parseMultiEnd);
        if (this.char === Parser2.END)
          throw this.error(new TomlError("Unterminated multi-line string"));
        if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
          throw this.errorControlCharInString();
        this.consume();
      } while (this.nextChar());
    }
    errorControlCharInString() {
      let displayCode = "\\u00";
      return this.char < 16 && (displayCode += "0"), displayCode += this.char.toString(16), this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
    }
    recordMultiEscapeReplacement(replacement) {
      return this.state.buf += replacement, this.goto(this.parseMultiStringContent);
    }
    parseMultiEnd() {
      return this.char === CHAR_QUOT ? this.next(this.parseMultiEnd2) : (this.state.buf += '"', this.goto(this.parseMultiStringContent));
    }
    parseMultiEnd2() {
      return this.char === CHAR_QUOT ? this.return() : (this.state.buf += '""', this.goto(this.parseMultiStringContent));
    }
    parseMultiEscape() {
      return this.char === CTRL_M || this.char === CTRL_J ? this.next(this.parseMultiTrim) : this.char === CHAR_SP || this.char === CTRL_I ? this.next(this.parsePreMultiTrim) : this.goto(this.parseEscape);
    }
    parsePreMultiTrim() {
      if (this.char === CHAR_SP || this.char === CTRL_I)
        return null;
      if (this.char === CTRL_M || this.char === CTRL_J)
        return this.next(this.parseMultiTrim);
      throw this.error(new TomlError("Can't escape whitespace"));
    }
    parseMultiTrim() {
      return this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M ? null : this.returnNow();
    }
    parseEscape() {
      if (this.char in escapes)
        return this.return(escapes[this.char]);
      if (this.char === CHAR_u)
        return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
      if (this.char === CHAR_U)
        return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
      throw this.error(new TomlError("Unknown escape character: " + this.char));
    }
    parseUnicodeReturn(char) {
      try {
        const codePoint = parseInt(char, 16);
        if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST)
          throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
        return this.returnNow(String.fromCodePoint(codePoint));
      } catch (err) {
        throw this.error(TomlError.wrap(err));
      }
    }
    parseSmallUnicode() {
      if (isHexit(this.char)) {
        if (this.consume(), this.state.buf.length >= 4) return this.return();
      } else
        throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
    }
    parseLargeUnicode() {
      if (isHexit(this.char)) {
        if (this.consume(), this.state.buf.length >= 8) return this.return();
      } else
        throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
    }
    /* NUMBERS */
    parseNumberSign() {
      return this.consume(), this.next(this.parseMaybeSignedInfOrNan);
    }
    parseMaybeSignedInfOrNan() {
      return this.char === CHAR_i ? this.next(this.parseInf) : this.char === CHAR_n ? this.next(this.parseNan) : this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
    }
    parseNumberIntegerStart() {
      return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberIntegerExponentOrDecimal)) : this.goto(this.parseNumberInteger);
    }
    parseNumberIntegerExponentOrDecimal() {
      return this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Integer(this.state.buf));
    }
    parseNumberInteger() {
      if (isDigit(this.char))
        this.consume();
      else {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder);
        if (this.char === CHAR_E || this.char === CHAR_e)
          return this.consume(), this.next(this.parseNumberExponentSign);
        if (this.char === CHAR_PERIOD)
          return this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat);
        {
          const result = Integer(this.state.buf);
          if (result.isNaN())
            throw this.error(new TomlError("Invalid number"));
          return this.returnNow(result);
        }
      }
    }
    parseNoUnder() {
      if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e)
        throw this.error(new TomlError("Unexpected character, expected digit"));
      if (this.atEndOfWord())
        throw this.error(new TomlError("Incomplete number"));
      return this.returnNow();
    }
    parseNumberFloat() {
      if (this.char === CHAR_LOWBAR)
        return this.call(this.parseNoUnder, this.parseNumberFloat);
      if (isDigit(this.char))
        this.consume();
      else return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Float(this.state.buf));
    }
    parseNumberExponentSign() {
      if (isDigit(this.char))
        return this.goto(this.parseNumberExponent);
      if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS$1)
        this.consume(), this.call(this.parseNoUnder, this.parseNumberExponent);
      else
        throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
    }
    parseNumberExponent() {
      if (isDigit(this.char))
        this.consume();
      else return this.char === CHAR_LOWBAR ? this.call(this.parseNoUnder) : this.returnNow(Float(this.state.buf));
    }
    /* NUMBERS or DATETIMES  */
    parseNumberOrDateTime() {
      return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberBaseOrDateTime)) : this.goto(this.parseNumberOrDateTimeOnly);
    }
    parseNumberOrDateTimeOnly() {
      if (this.char === CHAR_LOWBAR)
        return this.call(this.parseNoUnder, this.parseNumberInteger);
      if (isDigit(this.char))
        this.consume(), this.state.buf.length > 4 && this.next(this.parseNumberInteger);
      else return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_HYPHEN ? this.goto(this.parseDateTime) : this.char === CHAR_COLON$2 ? this.goto(this.parseOnlyTimeHour) : this.returnNow(Integer(this.state.buf));
    }
    parseDateTimeOnly() {
      if (this.state.buf.length < 4) {
        if (isDigit(this.char))
          return this.consume();
        if (this.char === CHAR_COLON$2)
          return this.goto(this.parseOnlyTimeHour);
        throw this.error(new TomlError("Expected digit while parsing year part of a date"));
      } else {
        if (this.char === CHAR_HYPHEN)
          return this.goto(this.parseDateTime);
        throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
      }
    }
    parseNumberBaseOrDateTime() {
      return this.char === CHAR_b ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerBin)) : this.char === CHAR_o ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerOct)) : this.char === CHAR_x ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerHex)) : this.char === CHAR_PERIOD ? this.goto(this.parseNumberInteger) : isDigit(this.char) ? this.goto(this.parseDateTimeOnly) : this.returnNow(Integer(this.state.buf));
    }
    parseIntegerHex() {
      if (isHexit(this.char))
        this.consume();
      else {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder);
        {
          const result = Integer(this.state.buf);
          if (result.isNaN())
            throw this.error(new TomlError("Invalid number"));
          return this.returnNow(result);
        }
      }
    }
    parseIntegerOct() {
      if (isOctit(this.char))
        this.consume();
      else {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder);
        {
          const result = Integer(this.state.buf);
          if (result.isNaN())
            throw this.error(new TomlError("Invalid number"));
          return this.returnNow(result);
        }
      }
    }
    parseIntegerBin() {
      if (isBit(this.char))
        this.consume();
      else {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder);
        {
          const result = Integer(this.state.buf);
          if (result.isNaN())
            throw this.error(new TomlError("Invalid number"));
          return this.returnNow(result);
        }
      }
    }
    /* DATETIME */
    parseDateTime() {
      if (this.state.buf.length < 4)
        throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
      return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseDateMonth);
    }
    parseDateMonth() {
      if (this.char === CHAR_HYPHEN) {
        if (this.state.buf.length < 2)
          throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
        return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseDateDay);
      } else if (isDigit(this.char))
        this.consume();
      else
        throw this.error(new TomlError("Incomplete datetime"));
    }
    parseDateDay() {
      if (this.char === CHAR_T || this.char === CHAR_SP) {
        if (this.state.buf.length < 2)
          throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
        return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseStartTimeHour);
      } else {
        if (this.atEndOfWord())
          return this.return(createDate(this.state.result + "-" + this.state.buf));
        if (isDigit(this.char))
          this.consume();
        else
          throw this.error(new TomlError("Incomplete datetime"));
      }
    }
    parseStartTimeHour() {
      return this.atEndOfWord() ? this.returnNow(createDate(this.state.result)) : this.goto(this.parseTimeHour);
    }
    parseTimeHour() {
      if (this.char === CHAR_COLON$2) {
        if (this.state.buf.length < 2)
          throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
        return this.state.result += "T" + this.state.buf, this.state.buf = "", this.next(this.parseTimeMin);
      } else if (isDigit(this.char))
        this.consume();
      else
        throw this.error(new TomlError("Incomplete datetime"));
    }
    parseTimeMin() {
      if (this.state.buf.length < 2 && isDigit(this.char))
        this.consume();
      else {
        if (this.state.buf.length === 2 && this.char === CHAR_COLON$2)
          return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeSec);
        throw this.error(new TomlError("Incomplete datetime"));
      }
    }
    parseTimeSec() {
      if (isDigit(this.char)) {
        if (this.consume(), this.state.buf.length === 2)
          return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeZoneOrFraction);
      } else
        throw this.error(new TomlError("Incomplete datetime"));
    }
    parseOnlyTimeHour() {
      if (this.char === CHAR_COLON$2) {
        if (this.state.buf.length < 2)
          throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
        return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeMin);
      } else
        throw this.error(new TomlError("Incomplete time"));
    }
    parseOnlyTimeMin() {
      if (this.state.buf.length < 2 && isDigit(this.char))
        this.consume();
      else {
        if (this.state.buf.length === 2 && this.char === CHAR_COLON$2)
          return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeSec);
        throw this.error(new TomlError("Incomplete time"));
      }
    }
    parseOnlyTimeSec() {
      if (isDigit(this.char)) {
        if (this.consume(), this.state.buf.length === 2)
          return this.next(this.parseOnlyTimeFractionMaybe);
      } else
        throw this.error(new TomlError("Incomplete time"));
    }
    parseOnlyTimeFractionMaybe() {
      if (this.state.result += ":" + this.state.buf, this.char === CHAR_PERIOD)
        this.state.buf = "", this.next(this.parseOnlyTimeFraction);
      else
        return this.return(createTime(this.state.result));
    }
    parseOnlyTimeFraction() {
      if (isDigit(this.char))
        this.consume();
      else if (this.atEndOfWord()) {
        if (this.state.buf.length === 0) throw this.error(new TomlError("Expected digit in milliseconds"));
        return this.returnNow(createTime(this.state.result + "." + this.state.buf));
      } else
        throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
    }
    parseTimeZoneOrFraction() {
      if (this.char === CHAR_PERIOD)
        this.consume(), this.next(this.parseDateTimeFraction);
      else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS$1)
        this.consume(), this.next(this.parseTimeZoneHour);
      else {
        if (this.char === CHAR_Z)
          return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
        if (this.atEndOfWord())
          return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
        throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
      }
    }
    parseDateTimeFraction() {
      if (isDigit(this.char))
        this.consume();
      else {
        if (this.state.buf.length === 1)
          throw this.error(new TomlError("Expected digit in milliseconds"));
        if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS$1)
          this.consume(), this.next(this.parseTimeZoneHour);
        else {
          if (this.char === CHAR_Z)
            return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
          if (this.atEndOfWord())
            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
          throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
      }
    }
    parseTimeZoneHour() {
      if (isDigit(this.char)) {
        if (this.consume(), /\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
      } else
        throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
    }
    parseTimeZoneSep() {
      if (this.char === CHAR_COLON$2)
        this.consume(), this.next(this.parseTimeZoneMin);
      else
        throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
    }
    parseTimeZoneMin() {
      if (isDigit(this.char)) {
        if (this.consume(), /\d\d$/.test(this.state.buf)) return this.return(createDateTime(this.state.result + this.state.buf));
      } else
        throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
    }
    /* BOOLEAN */
    parseBoolean() {
      if (this.char === CHAR_t)
        return this.consume(), this.next(this.parseTrue_r);
      if (this.char === CHAR_f)
        return this.consume(), this.next(this.parseFalse_a);
    }
    parseTrue_r() {
      if (this.char === CHAR_r)
        return this.consume(), this.next(this.parseTrue_u);
      throw this.error(new TomlError("Invalid boolean, expected true or false"));
    }
    parseTrue_u() {
      if (this.char === CHAR_u)
        return this.consume(), this.next(this.parseTrue_e);
      throw this.error(new TomlError("Invalid boolean, expected true or false"));
    }
    parseTrue_e() {
      if (this.char === CHAR_e)
        return this.return(!0);
      throw this.error(new TomlError("Invalid boolean, expected true or false"));
    }
    parseFalse_a() {
      if (this.char === CHAR_a)
        return this.consume(), this.next(this.parseFalse_l);
      throw this.error(new TomlError("Invalid boolean, expected true or false"));
    }
    parseFalse_l() {
      if (this.char === CHAR_l)
        return this.consume(), this.next(this.parseFalse_s);
      throw this.error(new TomlError("Invalid boolean, expected true or false"));
    }
    parseFalse_s() {
      if (this.char === CHAR_s)
        return this.consume(), this.next(this.parseFalse_e);
      throw this.error(new TomlError("Invalid boolean, expected true or false"));
    }
    parseFalse_e() {
      if (this.char === CHAR_e)
        return this.return(!1);
      throw this.error(new TomlError("Invalid boolean, expected true or false"));
    }
    /* INLINE LISTS */
    parseInlineList() {
      if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
        return null;
      if (this.char === Parser2.END)
        throw this.error(new TomlError("Unterminated inline array"));
      return this.char === CHAR_NUM ? this.call(this.parseComment) : this.char === CHAR_RSQB ? this.return(this.state.resultArr || InlineList()) : this.callNow(this.parseValue, this.recordInlineListValue);
    }
    recordInlineListValue(value) {
      if (this.state.resultArr) {
        const listType = this.state.resultArr[_contentType], valueType = tomlType$1(value);
        if (listType !== valueType)
          throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
      } else
        this.state.resultArr = InlineList(tomlType$1(value));
      return isFloat$2(value) || isInteger$2(value) ? this.state.resultArr.push(value.valueOf()) : this.state.resultArr.push(value), this.goto(this.parseInlineListNext);
    }
    parseInlineListNext() {
      if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
        return null;
      if (this.char === CHAR_NUM)
        return this.call(this.parseComment);
      if (this.char === CHAR_COMMA$4)
        return this.next(this.parseInlineList);
      if (this.char === CHAR_RSQB)
        return this.goto(this.parseInlineList);
      throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
    }
    /* INLINE TABLE */
    parseInlineTable() {
      if (this.char === CHAR_SP || this.char === CTRL_I)
        return null;
      if (this.char === Parser2.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
        throw this.error(new TomlError("Unterminated inline array"));
      return this.char === CHAR_RCUB ? this.return(this.state.resultTable || InlineTable()) : (this.state.resultTable || (this.state.resultTable = InlineTable()), this.callNow(this.parseAssign, this.recordInlineTableValue));
    }
    recordInlineTableValue(kv) {
      let target = this.state.resultTable, finalKey = kv.key.pop();
      for (let kw of kv.key) {
        if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
          throw this.error(new TomlError("Can't redefine existing key"));
        target = target[kw] = target[kw] || Table();
      }
      if (hasKey(target, finalKey))
        throw this.error(new TomlError("Can't redefine existing key"));
      return isInteger$2(kv.value) || isFloat$2(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseInlineTableNext);
    }
    parseInlineTableNext() {
      if (this.char === CHAR_SP || this.char === CTRL_I)
        return null;
      if (this.char === Parser2.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
        throw this.error(new TomlError("Unterminated inline array"));
      if (this.char === CHAR_COMMA$4)
        return this.next(this.parseInlineTable);
      if (this.char === CHAR_RCUB)
        return this.goto(this.parseInlineTable);
      throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
    }
  }
  return TOMLParser2;
}
var tomlParserExports = tomlParser.exports, parsePrettyError = prettyError$2;
function prettyError$2(err, buf) {
  if (err.pos == null || err.line == null) return err;
  let msg = err.message;
  if (msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:
`, buf && buf.split) {
    const lines2 = buf.split(/\n/), lineNumWidth = String(Math.min(lines2.length, err.line + 3)).length;
    let linePadding = " ";
    for (; linePadding.length < lineNumWidth; ) linePadding += " ";
    for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines2.length, err.line + 2); ++ii) {
      let lineNum = String(ii + 1);
      if (lineNum.length < lineNumWidth && (lineNum = " " + lineNum), err.line === ii) {
        msg += lineNum + "> " + lines2[ii] + `
`, msg += linePadding + "  ";
        for (let hh = 0; hh < err.col; ++hh)
          msg += " ";
        msg += `^
`;
      } else
        msg += lineNum + ": " + lines2[ii] + `
`;
    }
  }
  return err.message = msg + `
`, err;
}
var parseString_1 = parseString;
const TOMLParser$2 = tomlParserExports, prettyError$1 = parsePrettyError;
function parseString(str2) {
  loadEnv.commonjsGlobal.Buffer && loadEnv.commonjsGlobal.Buffer.isBuffer(str2) && (str2 = str2.toString("utf8"));
  const parser2 = new TOMLParser$2();
  try {
    return parser2.parse(str2), parser2.finish();
  } catch (err) {
    throw prettyError$1(err, str2);
  }
}
var parseAsync_1 = parseAsync;
const TOMLParser$1 = tomlParserExports, prettyError = parsePrettyError;
function parseAsync(str2, opts) {
  opts || (opts = {});
  const index = 0, blocksize = opts.blocksize || 40960, parser2 = new TOMLParser$1();
  return new Promise((resolve2, reject) => {
    setImmediate(parseAsyncNext, index, blocksize, resolve2, reject);
  });
  function parseAsyncNext(index2, blocksize2, resolve2, reject) {
    if (index2 >= str2.length)
      try {
        return resolve2(parser2.finish());
      } catch (err) {
        return reject(prettyError(err, str2));
      }
    try {
      parser2.parse(str2.slice(index2, index2 + blocksize2)), setImmediate(parseAsyncNext, index2 + blocksize2, blocksize2, resolve2, reject);
    } catch (err) {
      reject(prettyError(err, str2));
    }
  }
}
var parseStream_1 = parseStream;
const stream$2 = require$$0__default$4.default, TOMLParser = tomlParserExports;
function parseStream(stm) {
  return stm ? parseReadable(stm) : parseTransform();
}
function parseReadable(stm) {
  const parser2 = new TOMLParser();
  return stm.setEncoding("utf8"), new Promise((resolve2, reject) => {
    let readable2, ended = !1, errored = !1;
    function finish2() {
      if (ended = !0, !readable2)
        try {
          resolve2(parser2.finish());
        } catch (err) {
          reject(err);
        }
    }
    function error2(err) {
      errored = !0, reject(err);
    }
    stm.once("end", finish2), stm.once("error", error2), readNext();
    function readNext() {
      readable2 = !0;
      let data;
      for (; (data = stm.read()) !== null; )
        try {
          parser2.parse(data);
        } catch (err) {
          return error2(err);
        }
      if (readable2 = !1, ended) return finish2();
      errored || stm.once("readable", readNext);
    }
  });
}
function parseTransform() {
  const parser2 = new TOMLParser();
  return new stream$2.Transform({
    objectMode: !0,
    transform(chunk, encoding, cb) {
      try {
        parser2.parse(chunk.toString(encoding));
      } catch (err) {
        this.emit("error", err);
      }
      cb();
    },
    flush(cb) {
      try {
        this.push(parser2.finish());
      } catch (err) {
        this.emit("error", err);
      }
      cb();
    }
  });
}
parse$c.exports = parseString_1;
parse$c.exports.async = parseAsync_1;
parse$c.exports.stream = parseStream_1;
parse$c.exports.prettyError = parsePrettyError;
var parseExports = parse$c.exports, stringify$7 = { exports: {} };
stringify$7.exports = stringify$6;
stringify$7.exports.value = stringifyInline;
function stringify$6(obj) {
  if (obj === null) throw typeError("null");
  if (obj === void 0) throw typeError("undefined");
  if (typeof obj != "object") throw typeError(typeof obj);
  if (typeof obj.toJSON == "function" && (obj = obj.toJSON()), obj == null) return null;
  const type2 = tomlType(obj);
  if (type2 !== "table") throw typeError(type2);
  return stringifyObject("", "", obj);
}
function typeError(type2) {
  return new Error("Can only stringify objects, not " + type2);
}
function arrayOneTypeError() {
  return new Error("Array values can't have mixed types");
}
function getInlineKeys(obj) {
  return Object.keys(obj).filter((key2) => isInline(obj[key2]));
}
function getComplexKeys(obj) {
  return Object.keys(obj).filter((key2) => !isInline(obj[key2]));
}
function toJSON(obj) {
  let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, "__proto__") ? { ["__proto__"]: void 0 } : {};
  for (let prop of Object.keys(obj))
    obj[prop] && typeof obj[prop].toJSON == "function" && !("toISOString" in obj[prop]) ? nobj[prop] = obj[prop].toJSON() : nobj[prop] = obj[prop];
  return nobj;
}
function stringifyObject(prefix, indent, obj) {
  obj = toJSON(obj);
  var inlineKeys, complexKeys;
  inlineKeys = getInlineKeys(obj), complexKeys = getComplexKeys(obj);
  var result = [], inlineIndent = indent || "";
  inlineKeys.forEach((key2) => {
    var type2 = tomlType(obj[key2]);
    type2 !== "undefined" && type2 !== "null" && result.push(inlineIndent + stringifyKey(key2) + " = " + stringifyAnyInline(obj[key2], !0));
  }), result.length > 0 && result.push("");
  var complexIndent = prefix && inlineKeys.length > 0 ? indent + "  " : "";
  return complexKeys.forEach((key2) => {
    result.push(stringifyComplex(prefix, complexIndent, key2, obj[key2]));
  }), result.join(`
`);
}
function isInline(value) {
  switch (tomlType(value)) {
    case "undefined":
    case "null":
    case "integer":
    case "nan":
    case "float":
    case "boolean":
    case "string":
    case "datetime":
      return !0;
    case "array":
      return value.length === 0 || tomlType(value[0]) !== "table";
    case "table":
      return Object.keys(value).length === 0;
    default:
      return !1;
  }
}
function tomlType(value) {
  return value === void 0 ? "undefined" : value === null ? "null" : typeof value == "bigint" || Number.isInteger(value) && !Object.is(value, -0) ? "integer" : typeof value == "number" ? "float" : typeof value == "boolean" ? "boolean" : typeof value == "string" ? "string" : "toISOString" in value ? isNaN(value) ? "undefined" : "datetime" : Array.isArray(value) ? "array" : "table";
}
function stringifyKey(key2) {
  var keyStr = String(key2);
  return /^[-A-Za-z0-9_]+$/.test(keyStr) ? keyStr : stringifyBasicString(keyStr);
}
function stringifyBasicString(str2) {
  return '"' + escapeString$2(str2).replace(/"/g, '\\"') + '"';
}
function stringifyLiteralString(str2) {
  return "'" + str2 + "'";
}
function numpad(num, str2) {
  for (; str2.length < num; ) str2 = "0" + str2;
  return str2;
}
function escapeString$2(str2) {
  return str2.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/([\u0000-\u001f\u007f])/, (c2) => "\\u" + numpad(4, c2.codePointAt(0).toString(16)));
}
function stringifyMultilineString(str2) {
  let escaped = str2.split(/\n/).map((str3) => escapeString$2(str3).replace(/"(?="")/g, '\\"')).join(`
`);
  return escaped.slice(-1) === '"' && (escaped += `\\
`), `"""
` + escaped + '"""';
}
function stringifyAnyInline(value, multilineOk) {
  let type2 = tomlType(value);
  return type2 === "string" && (multilineOk && /\n/.test(value) ? type2 = "string-multiline" : !/[\b\t\n\f\r']/.test(value) && /"/.test(value) && (type2 = "string-literal")), stringifyInline(value, type2);
}
function stringifyInline(value, type2) {
  switch (type2 || (type2 = tomlType(value)), type2) {
    case "string-multiline":
      return stringifyMultilineString(value);
    case "string":
      return stringifyBasicString(value);
    case "string-literal":
      return stringifyLiteralString(value);
    case "integer":
      return stringifyInteger(value);
    case "float":
      return stringifyFloat(value);
    case "boolean":
      return stringifyBoolean(value);
    case "datetime":
      return stringifyDatetime(value);
    case "array":
      return stringifyInlineArray(value.filter((_2) => tomlType(_2) !== "null" && tomlType(_2) !== "undefined" && tomlType(_2) !== "nan"));
    case "table":
      return stringifyInlineTable(value);
    default:
      throw typeError(type2);
  }
}
function stringifyInteger(value) {
  return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, "_");
}
function stringifyFloat(value) {
  if (value === 1 / 0)
    return "inf";
  if (value === -1 / 0)
    return "-inf";
  if (Object.is(value, NaN))
    return "nan";
  if (Object.is(value, -0))
    return "-0.0";
  var chunks = String(value).split("."), int2 = chunks[0], dec = chunks[1] || 0;
  return stringifyInteger(int2) + "." + dec;
}
function stringifyBoolean(value) {
  return String(value);
}
function stringifyDatetime(value) {
  return value.toISOString();
}
function isNumber$3(type2) {
  return type2 === "float" || type2 === "integer";
}
function arrayType(values) {
  var contentType = tomlType(values[0]);
  return values.every((_2) => tomlType(_2) === contentType) ? contentType : values.every((_2) => isNumber$3(tomlType(_2))) ? "float" : "mixed";
}
function validateArray(values) {
  const type2 = arrayType(values);
  if (type2 === "mixed")
    throw arrayOneTypeError();
  return type2;
}
function stringifyInlineArray(values) {
  values = toJSON(values);
  const type2 = validateArray(values);
  var result = "[", stringified = values.map((_2) => stringifyInline(_2, type2));
  return stringified.join(", ").length > 60 || /\n/.test(stringified) ? result += `
  ` + stringified.join(`,
  `) + `
` : result += " " + stringified.join(", ") + (stringified.length > 0 ? " " : ""), result + "]";
}
function stringifyInlineTable(value) {
  value = toJSON(value);
  var result = [];
  return Object.keys(value).forEach((key2) => {
    result.push(stringifyKey(key2) + " = " + stringifyAnyInline(value[key2], !1));
  }), "{ " + result.join(", ") + (result.length > 0 ? " " : "") + "}";
}
function stringifyComplex(prefix, indent, key2, value) {
  var valueType = tomlType(value);
  if (valueType === "array")
    return stringifyArrayOfTables(prefix, indent, key2, value);
  if (valueType === "table")
    return stringifyComplexTable(prefix, indent, key2, value);
  throw typeError(valueType);
}
function stringifyArrayOfTables(prefix, indent, key2, values) {
  values = toJSON(values), validateArray(values);
  var firstValueType = tomlType(values[0]);
  if (firstValueType !== "table") throw typeError(firstValueType);
  var fullKey = prefix + stringifyKey(key2), result = "";
  return values.forEach((table) => {
    result.length > 0 && (result += `
`), result += indent + "[[" + fullKey + `]]
`, result += stringifyObject(fullKey + ".", indent, table);
  }), result;
}
function stringifyComplexTable(prefix, indent, key2, value) {
  var fullKey = prefix + stringifyKey(key2), result = "";
  return getInlineKeys(value).length > 0 && (result += indent + "[" + fullKey + `]
`), result + stringifyObject(fullKey + ".", indent, value);
}
var stringifyExports = stringify$7.exports;
toml.parse = parseExports;
toml.stringify = stringifyExports;
var dist$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isSpawnError = exports2.normalizeError = exports2.errorToString = exports2.isErrorLike = exports2.isErrnoException = exports2.isError = exports2.isObject = void 0;
  const isObject3 = (obj) => typeof obj == "object" && obj !== null;
  exports2.isObject = isObject3;
  const isError = (error2) => {
    if (!(0, exports2.isObject)(error2))
      return !1;
    if (error2 instanceof Error)
      return !0;
    for (; error2; ) {
      if (Object.prototype.toString.call(error2) === "[object Error]")
        return !0;
      error2 = Object.getPrototypeOf(error2);
    }
    return !1;
  };
  exports2.isError = isError;
  const isErrnoException = (error2) => (0, exports2.isError)(error2) && "code" in error2;
  exports2.isErrnoException = isErrnoException;
  const isErrorLike = (error2) => (0, exports2.isObject)(error2) && "message" in error2;
  exports2.isErrorLike = isErrorLike;
  const errorToString = (error2, fallback2) => (0, exports2.isError)(error2) || (0, exports2.isErrorLike)(error2) ? error2.message : typeof error2 == "string" ? error2 : fallback2 ?? "An unknown error has ocurred.";
  exports2.errorToString = errorToString;
  const normalizeError = (error2) => {
    if ((0, exports2.isError)(error2))
      return error2;
    const errorMessage = (0, exports2.errorToString)(error2);
    return (0, exports2.isErrorLike)(error2) ? Object.assign(new Error(errorMessage), error2) : new Error(errorMessage);
  };
  exports2.normalizeError = normalizeError;
  function isSpawnError(v) {
    return (0, exports2.isErrnoException)(v) && "spawnargs" in v;
  }
  exports2.isSpawnError = isSpawnError;
})(dist$2);
var __importDefault$8 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(readConfigFile$1, "__esModule", { value: !0 });
readConfigFile$1.readConfigFile = void 0;
const js_yaml_1$1 = __importDefault$8(jsYaml$3), toml_1 = __importDefault$8(toml), fs_1$2 = require$$0__default$1.default, error_utils_1$1 = dist$2, { readFile } = fs_1$2.promises;
async function readFileOrNull(file2) {
  try {
    return await readFile(file2);
  } catch (error2) {
    if (!(0, error_utils_1$1.isErrnoException)(error2) || error2.code !== "ENOENT")
      throw error2;
  }
  return null;
}
async function readConfigFile(files) {
  files = Array.isArray(files) ? files : [files];
  for (const name of files) {
    const data = await readFileOrNull(name);
    if (data) {
      const str2 = data.toString("utf8");
      if (name.endsWith(".json"))
        return JSON.parse(str2);
      if (name.endsWith(".toml"))
        return toml_1.default.parse(str2);
      if (name.endsWith(".yaml") || name.endsWith(".yml"))
        return js_yaml_1$1.default.safeLoad(str2, { filename: name });
    }
  }
  return null;
}
readConfigFile$1.readConfigFile = readConfigFile;
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: !0 });
(function(exports2) {
  var __createBinding2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    k2 === void 0 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
      return m[k];
    } }), Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    k2 === void 0 && (k2 = k), o[k2] = m[k];
  }), __exportStar2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.frameworks = void 0;
  const path_12 = require$$0__default.default, fs_12 = require$$0__default$1.default, read_config_file_1 = readConfigFile$1;
  __exportStar2(types$1, exports2);
  const { readdir, readFile: readFile2, unlink } = fs_12.promises;
  exports2.frameworks = [
    {
      name: "Blitz.js (Legacy)",
      slug: "blitzjs",
      demo: "https://blitz-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/blitz.svg",
      tagline: "Blitz.js: The Fullstack React Framework",
      description: "A brand new Blitz.js app - the result of running `npx blitz@0.45.4 new`.",
      website: "https://blitzjs.com",
      envPrefix: "NEXT_PUBLIC_",
      useRuntime: { src: "package.json", use: "@vercel/next" },
      detectors: {
        some: [
          // Intentionally does not detect a package name
          // https://github.com/vercel/vercel/pull/8432
          {
            path: "blitz.config.js"
          },
          {
            path: "blitz.config.ts"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `blitz build`",
          value: "blitz build"
        },
        devCommand: {
          value: "blitz start"
        },
        outputDirectory: {
          placeholder: "Next.js default"
        }
      },
      getOutputDirName: async () => "public"
    },
    {
      name: "Next.js",
      slug: "nextjs",
      demo: "https://nextjs-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/next.svg",
      darkModeLogo: "https://api-frameworks.vercel.sh/framework-logos/next-dark.svg",
      screenshot: "https://assets.vercel.com/image/upload/v1673027027/front/import/nextjs.png",
      tagline: "Next.js makes you productive with React instantly \u2014 whether you want to build static or dynamic sites.",
      description: "A Next.js app and a Serverless Function API.",
      website: "https://nextjs.org",
      sort: 1,
      envPrefix: "NEXT_PUBLIC_",
      useRuntime: { src: "package.json", use: "@vercel/next" },
      detectors: {
        every: [
          {
            matchPackage: "next"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `next build`",
          value: "next build"
        },
        devCommand: {
          value: "next dev --port $PORT",
          placeholder: "next"
        },
        outputDirectory: {
          placeholder: "Next.js default"
        }
      },
      recommendedIntegrations: [
        {
          id: "oac_5lUsiANun1DEzgLg0NZx5Es3",
          dependencies: ["next-plugin-sentry", "next-sentry-source-maps"]
        }
      ],
      getOutputDirName: async () => "public",
      cachePattern: ".next/cache/**"
    },
    {
      name: "Gatsby.js",
      slug: "gatsby",
      demo: "https://gatsby.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/gatsby.svg",
      tagline: "Gatsby helps developers build blazing fast websites and apps with React.",
      description: "A Gatsby starter app with an API Route.",
      website: "https://gatsbyjs.org",
      sort: 5,
      envPrefix: "GATSBY_",
      detectors: {
        every: [
          {
            matchPackage: "gatsby"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `gatsby build`",
          value: "gatsby build"
        },
        devCommand: {
          value: "gatsby develop --port $PORT",
          placeholder: "gatsby develop"
        },
        outputDirectory: {
          value: "public"
        }
      },
      dependency: "gatsby",
      getOutputDirName: async () => "public",
      defaultRoutes: async (dirPrefix) => {
        try {
          const nowRoutesPath = (0, path_12.join)(dirPrefix, "public", "__now_routes_g4t5bY.json"), content = await readFile2(nowRoutesPath, "utf8"), nowRoutes = JSON.parse(content);
          try {
            await unlink(nowRoutesPath);
          } catch {
          }
          return nowRoutes;
        } catch {
          return [
            {
              src: "^/static/(.*)$",
              headers: { "cache-control": "public,max-age=31536000,immutable" },
              continue: !0
            },
            {
              src: "^/.*\\.(js|css)$",
              headers: { "cache-control": "public,max-age=31536000,immutable" },
              continue: !0
            },
            {
              src: "^/(sw\\.js|app-data\\.json|.*\\.html|page-data/.*)$",
              headers: { "cache-control": "public,max-age=0,must-revalidate" },
              continue: !0
            },
            {
              handle: "filesystem"
            },
            {
              src: ".*",
              status: 404,
              dest: "404.html"
            }
          ];
        }
      },
      cachePattern: "{.cache,public}/**"
    },
    {
      name: "Remix",
      slug: "remix",
      demo: "https://remix-run-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/remix-no-shadow.svg",
      tagline: "Build Better Websites",
      description: "A new Remix app \u2014 the result of running `npx create-remix`.",
      website: "https://remix.run",
      sort: 6,
      useRuntime: { src: "package.json", use: "@vercel/remix-builder" },
      ignoreRuntimes: ["@vercel/node"],
      detectors: {
        some: [
          {
            path: "remix.config.js"
          },
          {
            path: "remix.config.mjs"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          value: "remix build",
          placeholder: "`npm run build` or `remix build`"
        },
        devCommand: {
          value: "remix dev",
          placeholder: "remix dev"
        },
        outputDirectory: {
          value: "public"
        }
      },
      dependency: "remix",
      getOutputDirName: async () => "public"
    },
    {
      name: "Astro",
      slug: "astro",
      demo: "https://astro-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/astro.svg",
      darkModeLogo: "https://api-frameworks.vercel.sh/framework-logos/astro-dark.svg",
      tagline: "Astro is a new kind of static site builder for the modern web. Powerful developer experience meets lightweight output.",
      description: "An Astro site, using the basics starter kit.",
      website: "https://astro.build",
      envPrefix: "PUBLIC_",
      detectors: {
        every: [
          {
            matchPackage: "astro"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install` or `npm install`"
        },
        buildCommand: {
          value: "astro build",
          placeholder: "`npm run build` or `astro build`"
        },
        devCommand: {
          value: "astro dev --port $PORT",
          placeholder: "astro dev"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "astro",
      getOutputDirName: async () => "dist",
      defaultRoutes: [
        {
          src: "^/assets/(.*)$",
          headers: { "cache-control": "public, max-age=31536000, immutable" },
          continue: !0
        },
        {
          src: "^/_astro/(.*)$",
          headers: { "cache-control": "public, max-age=31536000, immutable" },
          continue: !0
        }
      ]
    },
    {
      name: "Hexo",
      slug: "hexo",
      demo: "https://hexo-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/hexo.svg",
      tagline: "Hexo is a fast, simple & powerful blog framework powered by Node.js.",
      description: "A Hexo site, created with the Hexo CLI.",
      website: "https://hexo.io",
      detectors: {
        every: [
          {
            matchPackage: "hexo"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `hexo generate`",
          value: "hexo generate"
        },
        devCommand: {
          value: "hexo server --port $PORT",
          placeholder: "hexo server"
        },
        outputDirectory: {
          value: "public"
        }
      },
      dependency: "hexo",
      getOutputDirName: async () => "public"
    },
    {
      name: "Eleventy",
      slug: "eleventy",
      demo: "https://eleventy-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/eleventy.svg",
      tagline: "11ty is a simpler static site generator written in JavaScript, created to be an alternative to Jekyll.",
      description: "An Eleventy site, created with npm init.",
      website: "https://www.11ty.dev",
      detectors: {
        every: [
          {
            matchPackage: "@11ty/eleventy"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `npx @11ty/eleventy`",
          value: "npx @11ty/eleventy"
        },
        devCommand: {
          value: "npx @11ty/eleventy --serve --watch --port $PORT",
          placeholder: "npx @11ty/eleventy --serve"
        },
        outputDirectory: {
          value: "_site"
        }
      },
      dependency: "@11ty/eleventy",
      getOutputDirName: async () => "_site",
      cachePattern: ".cache/**"
    },
    {
      name: "Docusaurus (v2)",
      slug: "docusaurus-2",
      demo: "https://docusaurus-2-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/docusaurus.svg",
      tagline: "Docusaurus makes it easy to maintain Open Source documentation websites.",
      description: "A static Docusaurus site that makes it easy to maintain OSS documentation.",
      website: "https://v2.docusaurus.io",
      detectors: {
        some: [
          {
            matchPackage: "@docusaurus/core"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `docusaurus build`",
          value: "docusaurus build"
        },
        devCommand: {
          value: "docusaurus start --port $PORT",
          placeholder: "docusaurus start"
        },
        outputDirectory: {
          value: "build"
        }
      },
      dependency: "@docusaurus/core",
      getOutputDirName: async (dirPrefix) => {
        const base2 = "build";
        try {
          const location = (0, path_12.join)(dirPrefix, base2), content = await readdir(location, { withFileTypes: !0 });
          if (content.length === 1 && content[0].isDirectory())
            return (0, path_12.join)(base2, content[0].name);
        } catch (error2) {
          console.error("Error detecting output directory: ", error2);
        }
        return base2;
      },
      defaultRoutes: [
        {
          src: "^/[^./]+\\.[0-9a-f]{8}\\.(css|js)$",
          headers: { "cache-control": "max-age=31536000, immutable" },
          continue: !0
        },
        {
          src: "^/assets/images/[^/]+-[0-9a-f]{32}\\.(ico|svg|jpg|jpeg|png|gif|webp)$",
          headers: { "cache-control": "max-age=31536000, immutable" },
          continue: !0
        },
        {
          src: "^/assets/medias/[^/]+-[0-9a-f]{32}\\.(ogv|wav|mp3|m4a|aac|oga|flac)$",
          headers: { "cache-control": "max-age=31536000, immutable" },
          continue: !0
        },
        {
          src: "^/assets/files/[^/]+-[0-9a-f]{32}\\.(pdf|doc|docx|xls|xlsx|zip|rar)$",
          headers: { "cache-control": "max-age=31536000, immutable" },
          continue: !0
        },
        {
          src: "^/ideal-img/[^/]+\\.[0-9a-f]{7}\\.\\d+\\.(png|jpe?g|gif)$",
          headers: { "cache-control": "max-age=31536000, immutable" },
          continue: !0
        },
        {
          handle: "filesystem"
        },
        {
          src: ".*",
          status: 404,
          dest: "404.html"
        }
      ]
    },
    {
      name: "Docusaurus (v1)",
      slug: "docusaurus",
      demo: "https://docusaurus-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/docusaurus.svg",
      tagline: "Docusaurus makes it easy to maintain Open Source documentation websites.",
      description: "A static Docusaurus site that makes it easy to maintain OSS documentation.",
      website: "https://docusaurus.io/",
      detectors: {
        some: [
          {
            matchPackage: "docusaurus"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `docusaurus-build`",
          value: "docusaurus-build"
        },
        devCommand: {
          value: "docusaurus-start --port $PORT",
          placeholder: "docusaurus-start"
        },
        outputDirectory: {
          value: "build"
        }
      },
      dependency: "docusaurus",
      getOutputDirName: async (dirPrefix) => {
        const base2 = "build";
        try {
          const location = (0, path_12.join)(dirPrefix, base2), content = await readdir(location, { withFileTypes: !0 });
          if (content.length === 1 && content[0].isDirectory())
            return (0, path_12.join)(base2, content[0].name);
        } catch (error2) {
          console.error("Error detecting output directory: ", error2);
        }
        return base2;
      }
    },
    {
      name: "Preact",
      slug: "preact",
      demo: "https://preact-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/preact.svg",
      tagline: "Preact is a fast 3kB alternative to React with the same modern API.",
      description: "A Preact app, created with the Preact CLI.",
      website: "https://preactjs.com",
      detectors: {
        every: [
          // Intentionally does not detect "preact" package because that can be
          // used to power other frameworks.
          {
            matchPackage: "preact-cli"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `preact build`",
          value: "preact build"
        },
        devCommand: {
          value: "preact watch --port $PORT",
          placeholder: "preact watch"
        },
        outputDirectory: {
          value: "build"
        }
      },
      dependency: "preact-cli",
      getOutputDirName: async () => "build",
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "SolidStart",
      slug: "solidstart",
      demo: "https://solid-start-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/solid.svg",
      tagline: "Simple and performant reactivity for building user interfaces.",
      description: "A Solid app, created with SolidStart.",
      website: "https://solidjs.com",
      envPrefix: "VITE_",
      detectors: {
        every: [
          {
            matchPackage: "solid-js"
          },
          {
            matchPackage: "solid-start"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `solid-start build`",
          value: "solid-start build"
        },
        devCommand: {
          value: "solid-start dev"
        },
        outputDirectory: {
          value: ".output"
        }
      },
      getOutputDirName: async () => ".output"
    },
    {
      name: "Dojo",
      slug: "dojo",
      demo: "https://dojo-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/dojo.png",
      tagline: "Dojo is a modern progressive, TypeScript first framework.",
      description: "A Dojo app, created with the Dojo CLI's cli-create-app command.",
      website: "https://dojo.io",
      detectors: {
        some: [
          {
            matchPackage: "@dojo/framework"
          },
          {
            path: ".dojorc"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `dojo build`",
          value: "dojo build"
        },
        devCommand: {
          value: "dojo build -m dev -w -s -p $PORT",
          placeholder: "dojo build -m dev -w -s"
        },
        outputDirectory: {
          value: "output/dist"
        }
      },
      dependency: "@dojo/cli",
      getOutputDirName: async () => (0, path_12.join)("output", "dist"),
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/service-worker.js",
          headers: { "cache-control": "s-maxage=0" },
          continue: !0
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ],
      defaulHeaders: [
        {
          source: "/service-worker.js",
          regex: "/service-worker.js",
          headers: { "cache-control": "s-maxage=0" },
          continue: !0
        }
      ]
    },
    {
      name: "Ember.js",
      slug: "ember",
      demo: "https://ember-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/ember.svg",
      tagline: "Ember.js helps webapp developers be more productive out of the box.",
      description: "An Ember app, created with the Ember CLI.",
      website: "https://emberjs.com/",
      detectors: {
        some: [
          {
            matchPackage: "ember-source"
          },
          {
            matchPackage: "ember-cli"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `ember build`",
          value: "ember build"
        },
        devCommand: {
          value: "ember serve --port $PORT",
          placeholder: "ember serve"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "ember-cli",
      getOutputDirName: async () => "dist",
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Vue.js",
      slug: "vue",
      demo: "https://vue-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/vue.svg",
      tagline: "Vue.js is a versatile JavaScript framework that is as approachable as it is performant.",
      description: "A Vue.js app, created with the Vue CLI.",
      website: "https://vuejs.org",
      envPrefix: "VUE_APP_",
      detectors: {
        every: [
          {
            matchPackage: "@vue/cli-service"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `vue-cli-service build`",
          value: "vue-cli-service build"
        },
        devCommand: {
          value: "vue-cli-service serve --port $PORT",
          placeholder: "vue-cli-service serve"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "@vue/cli-service",
      getOutputDirName: async () => "dist",
      defaultRoutes: [
        {
          src: "^/[^/]*\\.(js|txt|ico|json)",
          headers: { "cache-control": "max-age=300" },
          continue: !0
        },
        {
          src: "^/(img|js|css|fonts|media)/[^/]+\\.[0-9a-f]{8}\\.*",
          headers: { "cache-control": "max-age=31536000, immutable" },
          continue: !0
        },
        {
          handle: "filesystem"
        },
        {
          src: "^.*",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Scully",
      slug: "scully",
      demo: "https://scully-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/scullyio-logo.png",
      tagline: "Scully is a static site generator for Angular.",
      description: "The Static Site Generator for Angular apps.",
      website: "https://github.com/scullyio/scully",
      detectors: {
        every: [
          {
            matchPackage: "@scullyio/init"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `ng build && scully`",
          value: "ng build && scully"
        },
        devCommand: {
          value: "ng serve --port $PORT",
          placeholder: "ng serve"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "@scullyio/init",
      getOutputDirName: async () => "dist/static"
    },
    {
      name: "Ionic Angular",
      slug: "ionic-angular",
      demo: "https://ionic-angular-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/ionic.svg",
      tagline: "Ionic Angular allows you to build mobile PWAs with Angular and the Ionic Framework.",
      description: "An Ionic Angular site, created with the Ionic CLI.",
      website: "https://ionicframework.com",
      detectors: {
        every: [
          {
            matchPackage: "@ionic/angular"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `ng build`",
          value: "ng build"
        },
        devCommand: {
          value: "ng serve --port $PORT"
        },
        outputDirectory: {
          value: "www"
        }
      },
      dependency: "@ionic/angular",
      getOutputDirName: async () => "www",
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Angular",
      slug: "angular",
      demo: "https://angular-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/angular.svg",
      tagline: "Angular is a TypeScript-based cross-platform framework from Google.",
      description: "An Angular app, created with the Angular CLI.",
      website: "https://angular.io",
      detectors: {
        every: [
          {
            matchPackage: "@angular/cli"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `ng build`",
          value: "ng build"
        },
        devCommand: {
          value: "ng serve --port $PORT",
          placeholder: "ng serve"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "@angular/cli",
      getOutputDirName: async (dirPrefix) => {
        const base2 = "dist";
        try {
          const location = (0, path_12.join)(dirPrefix, base2), content = await readdir(location, { withFileTypes: !0 });
          if (content.length === 1 && content[0].isDirectory())
            return (0, path_12.join)(base2, content[0].name);
        } catch (error2) {
          console.error("Error detecting output directory: ", error2);
        }
        return base2;
      },
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Polymer",
      slug: "polymer",
      demo: "https://polymer-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/polymer.svg",
      tagline: "Polymer is an open-source webapps library from Google, for building using Web Components.",
      description: "A Polymer app, created with the Polymer CLI.",
      website: "https://www.polymer-project.org/",
      detectors: {
        every: [
          {
            matchPackage: "polymer-cli"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `polymer build`",
          value: "polymer build"
        },
        devCommand: {
          value: "polymer serve --port $PORT",
          placeholder: "polymer serve"
        },
        outputDirectory: {
          value: "build"
        }
      },
      dependency: "polymer-cli",
      getOutputDirName: async (dirPrefix) => {
        const base2 = "build";
        try {
          const location = (0, path_12.join)(dirPrefix, base2), paths = (await readdir(location)).filter((item) => !item.includes("."));
          return (0, path_12.join)(base2, paths[0]);
        } catch (error2) {
          console.error("Error detecting output directory: ", error2);
        }
        return base2;
      },
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Svelte",
      slug: "svelte",
      demo: "https://svelte.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
      tagline: "Svelte lets you write high performance reactive apps with significantly less boilerplate.",
      description: "A basic Svelte app using the default template.",
      website: "https://svelte.dev",
      sort: 3,
      detectors: {
        every: [
          {
            matchPackage: "svelte"
          },
          {
            matchPackage: "sirv-cli"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `rollup -c`",
          value: "rollup -c"
        },
        devCommand: {
          value: "rollup -c -w"
        },
        outputDirectory: {
          value: "public"
        }
      },
      dependency: "sirv-cli",
      getOutputDirName: async () => "public",
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      // TODO: fix detected as "sveltekit-1"
      name: "SvelteKit (v0)",
      slug: "sveltekit",
      demo: "https://sveltekit-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
      screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/sveltekit.png",
      tagline: "SvelteKit is a framework for building web applications of all sizes.",
      description: "A SvelteKit legacy app optimized Edge-first.",
      website: "https://kit.svelte.dev",
      sort: 99,
      envPrefix: "VITE_",
      detectors: {
        every: [
          {
            path: "package.json",
            matchContent: '"(dev)?(d|D)ependencies":\\s*{[^}]*"@sveltejs\\/kit":\\s*"1\\.0\\.0-next\\.(\\d+)"[^}]*}'
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `svelte-kit build`",
          value: "svelte-kit build"
        },
        devCommand: {
          value: "svelte-kit dev --port $PORT",
          placeholder: "svelte-kit dev"
        },
        outputDirectory: {
          value: "public"
        }
      },
      getOutputDirName: async () => "public"
    },
    {
      name: "SvelteKit (v1)",
      slug: "sveltekit-1",
      demo: "https://sveltekit-1-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
      screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/sveltekit.png",
      tagline: "SvelteKit is a framework for building web applications of all sizes.",
      description: "A SvelteKit app optimized Edge-first.",
      website: "https://kit.svelte.dev",
      detectors: {
        every: [
          {
            path: "package.json",
            matchContent: '"(dev)?(d|D)ependencies":\\s*{[^}]*"@sveltejs\\/kit":\\s*".+?"[^}]*}'
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "vite build",
          value: "vite build"
        },
        devCommand: {
          placeholder: "vite dev",
          value: "vite dev --port $PORT"
        },
        outputDirectory: {
          value: "public"
        }
      },
      getOutputDirName: async () => "public"
    },
    {
      name: "Ionic React",
      slug: "ionic-react",
      demo: "https://ionic-react-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/ionic.svg",
      tagline: "Ionic React allows you to build mobile PWAs with React and the Ionic Framework.",
      description: "An Ionic React site, created with the Ionic CLI.",
      website: "https://ionicframework.com",
      detectors: {
        every: [
          {
            matchPackage: "@ionic/react"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `react-scripts build`",
          value: "react-scripts build"
        },
        devCommand: {
          value: "react-scripts start"
        },
        outputDirectory: {
          value: "build"
        }
      },
      dependency: "@ionic/react",
      getOutputDirName: async () => "build",
      defaultRoutes: [
        {
          src: "/static/(.*)",
          headers: { "cache-control": "s-maxage=31536000, immutable" },
          continue: !0
        },
        {
          src: "/service-worker.js",
          headers: { "cache-control": "s-maxage=0" },
          continue: !0
        },
        {
          src: "/sockjs-node/(.*)",
          dest: "/sockjs-node/$1"
        },
        {
          handle: "filesystem"
        },
        { src: "/static/(.*)", status: 404, dest: "/404.html" },
        {
          src: "/(.*)",
          headers: { "cache-control": "s-maxage=0" },
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Create React App",
      slug: "create-react-app",
      demo: "https://create-react-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/react.svg",
      tagline: "Create React App allows you to get going with React in no time.",
      description: "A client-side React app created with create-react-app.",
      website: "https://create-react-app.dev",
      sort: 4,
      envPrefix: "REACT_APP_",
      detectors: {
        some: [
          {
            matchPackage: "react-scripts"
          },
          {
            matchPackage: "react-dev-utils"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `react-scripts build`",
          value: "react-scripts build"
        },
        devCommand: {
          value: "react-scripts start"
        },
        outputDirectory: {
          value: "build"
        }
      },
      dependency: "react-scripts",
      getOutputDirName: async () => "build",
      defaultRoutes: [
        {
          src: "/static/(.*)",
          headers: { "cache-control": "s-maxage=31536000, immutable" },
          continue: !0
        },
        {
          src: "/service-worker.js",
          headers: { "cache-control": "s-maxage=0" },
          continue: !0
        },
        {
          src: "/sockjs-node/(.*)",
          dest: "/sockjs-node/$1"
        },
        {
          handle: "filesystem"
        },
        { src: "/static/(.*)", status: 404, dest: "/404.html" },
        {
          src: "/(.*)",
          headers: { "cache-control": "s-maxage=0" },
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Gridsome",
      slug: "gridsome",
      demo: "https://gridsome-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/gridsome.svg",
      tagline: "Gridsome is a Vue.js-powered framework for building websites & apps that are fast by default.",
      description: "A Gridsome app, created with the Gridsome CLI.",
      website: "https://gridsome.org/",
      detectors: {
        every: [
          {
            matchPackage: "gridsome"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `gridsome build`",
          value: "gridsome build"
        },
        devCommand: {
          value: "gridsome develop -p $PORT",
          placeholder: "gridsome develop"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "gridsome",
      getOutputDirName: async () => "dist"
    },
    {
      name: "UmiJS",
      slug: "umijs",
      demo: "https://umijs-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/umi.svg",
      tagline: "UmiJS is an extensible enterprise-level React application framework.",
      description: "An UmiJS app, created using the Umi CLI.",
      website: "https://umijs.org",
      detectors: {
        every: [
          {
            matchPackage: "umi"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `umi build`",
          value: "umi build"
        },
        devCommand: {
          value: "umi dev --port $PORT",
          placeholder: "umi dev"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "umi",
      getOutputDirName: async () => "dist",
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Sapper",
      slug: "sapper",
      demo: "https://sapper-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
      tagline: "Sapper is a framework for building high-performance universal web apps with Svelte.",
      description: "A Sapper app, using the Sapper template.",
      website: "https://sapper.svelte.dev",
      detectors: {
        every: [
          {
            matchPackage: "sapper"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `sapper export`",
          value: "sapper export"
        },
        devCommand: {
          value: "sapper dev --port $PORT",
          placeholder: "sapper dev"
        },
        outputDirectory: {
          value: "__sapper__/export"
        }
      },
      dependency: "sapper",
      getOutputDirName: async () => "__sapper__/export"
    },
    {
      name: "Saber",
      slug: "saber",
      demo: "https://saber-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/saber.svg",
      tagline: "Saber is a framework for building static sites in Vue.js that supports data from any source.",
      description: "A Saber site, created with npm init.",
      website: "https://saber.egoist.dev",
      detectors: {
        every: [
          {
            matchPackage: "saber"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `saber build`",
          value: "saber build"
        },
        devCommand: {
          value: "saber --port $PORT",
          placeholder: "saber"
        },
        outputDirectory: {
          value: "public"
        }
      },
      dependency: "saber",
      getOutputDirName: async () => "public",
      defaultRoutes: [
        {
          src: "/_saber/.*",
          headers: { "cache-control": "max-age=31536000, immutable" }
        },
        {
          handle: "filesystem"
        },
        {
          src: ".*",
          status: 404,
          dest: "404.html"
        }
      ]
    },
    {
      name: "Stencil",
      slug: "stencil",
      demo: "https://stencil.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/stencil.svg",
      tagline: "Stencil is a powerful toolchain for building Progressive Web Apps and Design Systems.",
      description: "A Stencil site, created with the Stencil CLI.",
      website: "https://stenciljs.com/",
      detectors: {
        every: [
          {
            matchPackage: "@stencil/core"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `stencil build`",
          value: "stencil build"
        },
        devCommand: {
          value: "stencil build --dev --watch --serve --port $PORT",
          placeholder: "stencil build --dev --watch --serve"
        },
        outputDirectory: {
          value: "www"
        }
      },
      dependency: "@stencil/core",
      getOutputDirName: async () => "www",
      defaultRoutes: [
        {
          src: "/assets/(.*)",
          headers: { "cache-control": "max-age=2592000" },
          continue: !0
        },
        {
          src: "/build/p-.*",
          headers: { "cache-control": "max-age=31536000, immutable" },
          continue: !0
        },
        {
          src: "/sw.js",
          headers: { "cache-control": "no-cache" },
          continue: !0
        },
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Nuxt.js",
      slug: "nuxtjs",
      demo: "https://nuxtjs-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/nuxt.svg",
      screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/nuxtjs.png",
      tagline: "Nuxt.js is the web comprehensive framework that lets you dream big with Vue.js.",
      description: "A Nuxt.js app, bootstrapped with create-nuxt-app.",
      website: "https://nuxtjs.org",
      sort: 2,
      envPrefix: "NUXT_ENV_",
      detectors: {
        some: [
          {
            matchPackage: "nuxt"
          },
          {
            matchPackage: "nuxt3"
          },
          {
            matchPackage: "nuxt-edge"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `nuxt generate`",
          value: "nuxt generate"
        },
        devCommand: {
          value: "nuxt"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "nuxt",
      getOutputDirName: async () => "dist",
      cachePattern: ".nuxt/**",
      defaultRoutes: [
        {
          src: "/sw.js",
          headers: { "cache-control": "no-cache" },
          continue: !0
        },
        {
          src: "/_nuxt/(.*)",
          headers: { "cache-control": "public,max-age=31536000,immutable" },
          continue: !0
        },
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/200.html"
        }
      ]
    },
    {
      name: "RedwoodJS",
      slug: "redwoodjs",
      demo: "https://redwood-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/redwoodjs.svg",
      tagline: "RedwoodJS is a full-stack framework for the Jamstack.",
      description: "A RedwoodJS app, bootstraped with create-redwood-app.",
      website: "https://redwoodjs.com",
      envPrefix: "REDWOOD_ENV_",
      useRuntime: { src: "package.json", use: "@vercel/redwood" },
      ignoreRuntimes: ["@vercel/node"],
      detectors: {
        every: [
          {
            matchPackage: "@redwoodjs/core"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          value: "yarn rw deploy vercel"
        },
        devCommand: {
          value: 'yarn rw dev --fwd="--port=$PORT --open=false"',
          placeholder: "yarn rw dev"
        },
        outputDirectory: {
          placeholder: "RedwoodJS default"
        }
      },
      getOutputDirName: async () => "public"
    },
    {
      name: "Hugo",
      slug: "hugo",
      demo: "https://hugo-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/hugo.svg",
      tagline: "Hugo is the world\u2019s fastest framework for building websites, written in Go.",
      description: "A Hugo site, created with the Hugo CLI.",
      website: "https://gohugo.io",
      detectors: {
        some: [
          {
            path: "config.yaml",
            matchContent: "baseURL"
          },
          {
            path: "config.toml",
            matchContent: "baseURL"
          },
          {
            path: "config.json",
            matchContent: "baseURL"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "None"
        },
        buildCommand: {
          placeholder: "`npm run build` or `hugo --gc`",
          value: "hugo --gc"
        },
        devCommand: {
          value: "hugo server -D -w -p $PORT",
          placeholder: "hugo server -D"
        },
        outputDirectory: {
          placeholder: "`public` or `publishDir` from the `config` file"
        }
      },
      getOutputDirName: async (dirPrefix) => {
        const config2 = await (0, read_config_file_1.readConfigFile)(["config.json", "config.yaml", "config.toml"].map((fileName) => (0, path_12.join)(dirPrefix, fileName)));
        return config2 && config2.publishDir || "public";
      },
      defaultVersion: "0.58.2"
      // Must match the build image
    },
    {
      name: "Jekyll",
      slug: "jekyll",
      demo: "https://jekyll-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/jekyll.svg",
      tagline: "Jekyll makes it super easy to transform your plain text into static websites and blogs.",
      description: "A Jekyll site, created with the Jekyll CLI.",
      website: "https://jekyllrb.com/",
      detectors: {
        every: [
          {
            path: "_config.yml"
          }
        ]
      },
      settings: {
        installCommand: {
          value: "bundle install"
        },
        buildCommand: {
          placeholder: "`npm run build` or `jekyll build`",
          value: "jekyll build"
        },
        devCommand: {
          value: "bundle exec jekyll serve --watch --port $PORT",
          placeholder: "bundle exec jekyll serve"
        },
        outputDirectory: {
          placeholder: "`_site` or `destination` from `_config.yml`"
        }
      },
      getOutputDirName: async (dirPrefix) => {
        const config2 = await (0, read_config_file_1.readConfigFile)((0, path_12.join)(dirPrefix, "_config.yml"));
        return config2 && config2.destination || "_site";
      },
      cachePattern: "{vendor/bin,vendor/cache,vendor/bundle}/**"
    },
    {
      name: "Brunch",
      slug: "brunch",
      demo: "https://brunch-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/brunch.svg",
      tagline: "Brunch is a fast and simple webapp build tool with seamless incremental compilation for rapid development.",
      description: "A Brunch app, created with the Brunch CLI.",
      website: "https://brunch.io/",
      detectors: {
        some: [
          {
            matchPackage: "brunch"
          },
          {
            path: "brunch-config.js"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `brunch build --production`",
          value: "brunch build --production"
        },
        devCommand: {
          value: "brunch watch --server --port $PORT",
          placeholder: "brunch watch --server"
        },
        outputDirectory: {
          value: "public"
        }
      },
      getOutputDirName: async () => "public"
    },
    {
      name: "Middleman",
      slug: "middleman",
      demo: "https://middleman-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/middleman.svg",
      tagline: "Middleman is a static site generator that uses all the shortcuts and tools in modern web development.",
      description: "A Middleman app, created with the Middleman CLI.",
      website: "https://middlemanapp.com/",
      detectors: {
        every: [
          {
            path: "config.rb"
          }
        ]
      },
      settings: {
        installCommand: {
          value: "bundle install"
        },
        buildCommand: {
          placeholder: "`npm run build` or `bundle exec middleman build`",
          value: "bundle exec middleman build"
        },
        devCommand: {
          placeholder: "bundle exec middleman server",
          value: "bundle exec middleman server -p $PORT"
        },
        outputDirectory: {
          value: "build"
        }
      },
      getOutputDirName: async () => "build",
      cachePattern: "{vendor/bin,vendor/cache,vendor/bundle}/**"
    },
    {
      name: "Zola",
      slug: "zola",
      demo: "https://zola-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/zola.png",
      tagline: "Everything you need to make a static site engine in one binary.",
      description: 'A Zola app, created with the "Getting Started" tutorial.',
      website: "https://www.getzola.org",
      detectors: {
        every: [
          {
            path: "config.toml",
            matchContent: "base_url"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "None"
        },
        buildCommand: {
          value: "zola build"
        },
        devCommand: {
          placeholder: "zola serve",
          value: "zola serve --port $PORT"
        },
        outputDirectory: {
          value: "public"
        }
      },
      getOutputDirName: async () => "public",
      defaultVersion: "0.13.0"
      // Must match the build image
    },
    {
      name: "Hydrogen (v1)",
      slug: "hydrogen",
      demo: "https://hydrogen-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/hydrogen.svg",
      tagline: "React framework for headless commerce",
      description: "React framework for headless commerce",
      website: "https://hydrogen.shopify.dev",
      useRuntime: { src: "package.json", use: "@vercel/hydrogen" },
      envPrefix: "PUBLIC_",
      detectors: {
        some: [
          {
            matchPackage: "@shopify/hydrogen"
          },
          {
            path: "hydrogen.config.js"
          },
          {
            path: "hydrogen.config.ts"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          value: "shopify hydrogen build",
          placeholder: "`npm run build` or `shopify hydrogen build`"
        },
        devCommand: {
          value: "shopify hydrogen dev",
          placeholder: "shopify hydrogen dev"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "@shopify/hydrogen",
      getOutputDirName: async () => "dist"
    },
    {
      name: "Vite",
      slug: "vite",
      demo: "https://vite-vue-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/vite.svg",
      tagline: "Vite is a new breed of frontend build tool that significantly improves the frontend development experience.",
      description: "A Vue.js app, created with Vite.",
      website: "https://vitejs.dev",
      envPrefix: "VITE_",
      detectors: {
        every: [
          {
            matchPackage: "vite"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `vite build`",
          value: "vite build"
        },
        devCommand: {
          placeholder: "vite",
          value: "vite --port $PORT"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "vite",
      getOutputDirName: async () => "dist"
    },
    {
      name: "VitePress",
      slug: "vitepress",
      demo: "https://vitepress-starter-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/vite.svg",
      tagline: "VitePress is VuePress' little brother, built on top of Vite.",
      description: "VuePress on top of Vite",
      website: "https://vitepress.vuejs.org/",
      detectors: {
        every: [
          {
            matchPackage: "vitepress"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `vitepress build docs`",
          value: "vitepress build docs"
        },
        devCommand: {
          value: "vitepress dev docs --port $PORT"
        },
        outputDirectory: {
          value: "docs/.vitepress/dist"
        }
      },
      getOutputDirName: async () => "docs/.vitepress/dist"
    },
    {
      name: "VuePress",
      slug: "vuepress",
      demo: "https://vuepress-starter-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/vuepress.png",
      tagline: "Vue-powered Static Site Generator",
      description: "Vue-powered Static Site Generator",
      website: "https://vuepress.vuejs.org/",
      detectors: {
        every: [
          {
            matchPackage: "vuepress"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `vuepress build src`",
          value: "vuepress build src"
        },
        devCommand: {
          value: "vuepress dev src --port $PORT"
        },
        outputDirectory: {
          value: "src/.vuepress/dist"
        }
      },
      getOutputDirName: async () => "src/.vuepress/dist"
    },
    {
      name: "Parcel",
      slug: "parcel",
      demo: "https://parcel-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/parcel.png",
      tagline: "Parcel is a zero configuration build tool for the web that scales to projects of any size and complexity.",
      description: "A vanilla web app built with Parcel.",
      website: "https://parceljs.org",
      detectors: {
        every: [
          {
            matchPackage: "parcel"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `parcel build`",
          value: "parcel build"
        },
        devCommand: {
          placeholder: "parcel",
          value: "parcel"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "parcel",
      getOutputDirName: async () => "dist",
      defaultRoutes: [
        {
          src: "^/[^./]+\\.[0-9a-f]{8}\\.(css|js|png|jpg|webp|avif|svg)$",
          headers: { "cache-control": "s-maxage=31536000, immutable" },
          continue: !0
        },
        {
          handle: "filesystem"
        }
      ]
    },
    {
      name: "Sanity",
      slug: "sanity",
      demo: "https://sanity-studio-template.vercel.app",
      logo: "https://api-frameworks.vercel.sh/framework-logos/sanity.svg",
      tagline: "The structured content platform.",
      description: "A Sanity Studio",
      website: "https://www.sanity.io",
      envPrefix: "SANITY_STUDIO_",
      detectors: {
        some: [
          {
            path: "sanity.json"
          },
          {
            path: "sanity.config.js"
          },
          {
            path: "sanity.config.jsx"
          },
          {
            path: "sanity.config.ts"
          },
          {
            path: "sanity.config.tsx"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run build` or `sanity build`",
          value: "sanity build"
        },
        devCommand: {
          value: "sanity start --port $PORT"
        },
        outputDirectory: {
          value: "dist"
        }
      },
      dependency: "@sanity/cli",
      getOutputDirName: async () => "dist",
      defaultRoutes: [
        {
          handle: "filesystem"
        },
        {
          src: "/(.*)",
          dest: "/index.html"
        }
      ]
    },
    {
      name: "Storybook",
      slug: "storybook",
      logo: "https://api-frameworks.vercel.sh/framework-logos/storybook.svg",
      tagline: "Frontend workshop for UI development",
      description: "Storybook is a frontend workshop for building UI components and pages in isolation.",
      website: "https://storybook.js.org",
      ignoreRuntimes: ["@vercel/next", "@vercel/node"],
      disableRootMiddleware: !0,
      detectors: {
        every: [
          {
            matchPackage: "storybook"
          }
        ]
      },
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          value: "storybook build",
          ignorePackageJsonScript: !0
        },
        devCommand: {
          value: "storybook dev -p $PORT"
        },
        outputDirectory: {
          value: "storybook-static"
        }
      },
      getOutputDirName: async () => "storybook-static"
    },
    {
      name: "Other",
      slug: null,
      logo: "https://api-frameworks.vercel.sh/framework-logos/other.svg",
      description: "No framework or an unoptimized framework.",
      settings: {
        installCommand: {
          placeholder: "`yarn install`, `pnpm install`, or `npm install`"
        },
        buildCommand: {
          placeholder: "`npm run vercel-build` or `npm run build`",
          value: null
        },
        devCommand: {
          placeholder: "None",
          value: null
        },
        outputDirectory: {
          placeholder: "`public` if it exists, or `.`"
        }
      },
      getOutputDirName: async () => "public"
    }
  ];
  const def = exports2.frameworks;
  exports2.default = def;
})(frameworks);
var dist$1 = {}, detectBuilders$1 = {}, concatMap$3 = function(xs, fn2) {
  for (var res = [], i2 = 0; i2 < xs.length; i2++) {
    var x = fn2(xs[i2], i2);
    isArray$1(x) ? res.push.apply(res, x) : res.push(x);
  }
  return res;
}, isArray$1 = Array.isArray || function(xs) {
  return Object.prototype.toString.call(xs) === "[object Array]";
}, balancedMatch = balanced$2;
function balanced$2(a, b, str2) {
  a instanceof RegExp && (a = maybeMatch(a, str2)), b instanceof RegExp && (b = maybeMatch(b, str2));
  var r = range$1(a, b, str2);
  return r && {
    start: r[0],
    end: r[1],
    pre: str2.slice(0, r[0]),
    body: str2.slice(r[0] + a.length, r[1]),
    post: str2.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str2) {
  var m = str2.match(reg);
  return m ? m[0] : null;
}
balanced$2.range = range$1;
function range$1(a, b, str2) {
  var begs, beg, left2, right2, result, ai = str2.indexOf(a), bi = str2.indexOf(b, ai + 1), i2 = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b)
      return [ai, bi];
    for (begs = [], left2 = str2.length; i2 >= 0 && !result; )
      i2 == ai ? (begs.push(i2), ai = str2.indexOf(a, i2 + 1)) : begs.length == 1 ? result = [begs.pop(), bi] : (beg = begs.pop(), beg < left2 && (left2 = beg, right2 = bi), bi = str2.indexOf(b, i2 + 1)), i2 = ai < bi && ai >= 0 ? ai : bi;
    begs.length && (result = [left2, right2]);
  }
  return result;
}
var concatMap$2 = concatMap$3, balanced$1 = balancedMatch, braceExpansion$1 = expandTop$1, escSlash$1 = "\0SLASH" + Math.random() + "\0", escOpen$1 = "\0OPEN" + Math.random() + "\0", escClose$1 = "\0CLOSE" + Math.random() + "\0", escComma$1 = "\0COMMA" + Math.random() + "\0", escPeriod$1 = "\0PERIOD" + Math.random() + "\0";
function numeric$1(str2) {
  return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces$1(str2) {
  return str2.split("\\\\").join(escSlash$1).split("\\{").join(escOpen$1).split("\\}").join(escClose$1).split("\\,").join(escComma$1).split("\\.").join(escPeriod$1);
}
function unescapeBraces$1(str2) {
  return str2.split(escSlash$1).join("\\").split(escOpen$1).join("{").split(escClose$1).join("}").split(escComma$1).join(",").split(escPeriod$1).join(".");
}
function parseCommaParts$1(str2) {
  if (!str2)
    return [""];
  var parts = [], m = balanced$1("{", "}", str2);
  if (!m)
    return str2.split(",");
  var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts$1(post);
  return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
}
function expandTop$1(str2) {
  return str2 ? (str2.substr(0, 2) === "{}" && (str2 = "\\{\\}" + str2.substr(2)), expand$7(escapeBraces$1(str2), !0).map(unescapeBraces$1)) : [];
}
function embrace$1(str2) {
  return "{" + str2 + "}";
}
function isPadded$1(el) {
  return /^-?0\d/.test(el);
}
function lte$1(i2, y) {
  return i2 <= y;
}
function gte$1(i2, y) {
  return i2 >= y;
}
function expand$7(str2, isTop) {
  var expansions = [], m = balanced$1("{", "}", str2);
  if (!m || /\$$/.test(m.pre)) return [str2];
  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
  if (!isSequence && !isOptions)
    return m.post.match(/,.*\}/) ? (str2 = m.pre + "{" + m.body + escClose$1 + m.post, expand$7(str2)) : [str2];
  var n;
  if (isSequence)
    n = m.body.split(/\.\./);
  else if (n = parseCommaParts$1(m.body), n.length === 1 && (n = expand$7(n[0], !1).map(embrace$1), n.length === 1)) {
    var post = m.post.length ? expand$7(m.post, !1) : [""];
    return post.map(function(p) {
      return m.pre + n[0] + p;
    });
  }
  var pre = m.pre, post = m.post.length ? expand$7(m.post, !1) : [""], N;
  if (isSequence) {
    var x = numeric$1(n[0]), y = numeric$1(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric$1(n[2])) : 1, test = lte$1, reverse = y < x;
    reverse && (incr *= -1, test = gte$1);
    var pad2 = n.some(isPadded$1);
    N = [];
    for (var i2 = x; test(i2, y); i2 += incr) {
      var c2;
      if (isAlphaSequence)
        c2 = String.fromCharCode(i2), c2 === "\\" && (c2 = "");
      else if (c2 = String(i2), pad2) {
        var need = width - c2.length;
        if (need > 0) {
          var z = new Array(need + 1).join("0");
          i2 < 0 ? c2 = "-" + z + c2.slice(1) : c2 = z + c2;
        }
      }
      N.push(c2);
    }
  } else
    N = concatMap$2(n, function(el) {
      return expand$7(el, !1);
    });
  for (var j = 0; j < N.length; j++)
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      (!isTop || isSequence || expansion) && expansions.push(expansion);
    }
  return expansions;
}
var minimatch_1$2 = minimatch$2;
minimatch$2.Minimatch = Minimatch$2;
var path$j = function() {
  try {
    return require("path");
  } catch {
  }
}() || {
  sep: "/"
};
minimatch$2.sep = path$j.sep;
var GLOBSTAR$1 = minimatch$2.GLOBSTAR = Minimatch$2.GLOBSTAR = {}, expand$6 = braceExpansion$1, plTypes$1 = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
}, qmark$1 = "[^/]", star$2 = qmark$1 + "*?", twoStarDot$1 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot$1 = "(?:(?!(?:\\/|^)\\.).)*?", reSpecials$1 = charSet$1("().*{}+?[]^$\\!");
function charSet$1(s) {
  return s.split("").reduce(function(set2, c2) {
    return set2[c2] = !0, set2;
  }, {});
}
var slashSplit$1 = /\/+/;
minimatch$2.filter = filter$2;
function filter$2(pattern, options2) {
  return options2 = options2 || {}, function(p, i2, list2) {
    return minimatch$2(p, pattern, options2);
  };
}
function ext$1(a, b) {
  b = b || {};
  var t = {};
  return Object.keys(a).forEach(function(k) {
    t[k] = a[k];
  }), Object.keys(b).forEach(function(k) {
    t[k] = b[k];
  }), t;
}
minimatch$2.defaults = function(def) {
  if (!def || typeof def != "object" || !Object.keys(def).length)
    return minimatch$2;
  var orig = minimatch$2, m = function(p, pattern, options2) {
    return orig(p, pattern, ext$1(def, options2));
  };
  return m.Minimatch = function(pattern, options2) {
    return new orig.Minimatch(pattern, ext$1(def, options2));
  }, m.Minimatch.defaults = function(options2) {
    return orig.defaults(ext$1(def, options2)).Minimatch;
  }, m.filter = function(pattern, options2) {
    return orig.filter(pattern, ext$1(def, options2));
  }, m.defaults = function(options2) {
    return orig.defaults(ext$1(def, options2));
  }, m.makeRe = function(pattern, options2) {
    return orig.makeRe(pattern, ext$1(def, options2));
  }, m.braceExpand = function(pattern, options2) {
    return orig.braceExpand(pattern, ext$1(def, options2));
  }, m.match = function(list2, pattern, options2) {
    return orig.match(list2, pattern, ext$1(def, options2));
  }, m;
};
Minimatch$2.defaults = function(def) {
  return minimatch$2.defaults(def).Minimatch;
};
function minimatch$2(p, pattern, options2) {
  return assertValidPattern$1(pattern), options2 || (options2 = {}), !options2.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch$2(pattern, options2).match(p);
}
function Minimatch$2(pattern, options2) {
  if (!(this instanceof Minimatch$2))
    return new Minimatch$2(pattern, options2);
  assertValidPattern$1(pattern), options2 || (options2 = {}), pattern = pattern.trim(), !options2.allowWindowsEscape && path$j.sep !== "/" && (pattern = pattern.split(path$j.sep).join("/")), this.options = options2, this.set = [], this.pattern = pattern, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options2.partial, this.make();
}
Minimatch$2.prototype.debug = function() {
};
Minimatch$2.prototype.make = make;
function make() {
  var pattern = this.pattern, options2 = this.options;
  if (!options2.nocomment && pattern.charAt(0) === "#") {
    this.comment = !0;
    return;
  }
  if (!pattern) {
    this.empty = !0;
    return;
  }
  this.parseNegate();
  var set2 = this.globSet = this.braceExpand();
  options2.debug && (this.debug = function() {
    console.error.apply(console, arguments);
  }), this.debug(this.pattern, set2), set2 = this.globParts = set2.map(function(s) {
    return s.split(slashSplit$1);
  }), this.debug(this.pattern, set2), set2 = set2.map(function(s, si, set3) {
    return s.map(this.parse, this);
  }, this), this.debug(this.pattern, set2), set2 = set2.filter(function(s) {
    return s.indexOf(!1) === -1;
  }), this.debug(this.pattern, set2), this.set = set2;
}
Minimatch$2.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern, negate = !1, options2 = this.options, negateOffset = 0;
  if (!options2.nonegate) {
    for (var i2 = 0, l = pattern.length; i2 < l && pattern.charAt(i2) === "!"; i2++)
      negate = !negate, negateOffset++;
    negateOffset && (this.pattern = pattern.substr(negateOffset)), this.negate = negate;
  }
}
minimatch$2.braceExpand = function(pattern, options2) {
  return braceExpand$1(pattern, options2);
};
Minimatch$2.prototype.braceExpand = braceExpand$1;
function braceExpand$1(pattern, options2) {
  return options2 || (this instanceof Minimatch$2 ? options2 = this.options : options2 = {}), pattern = typeof pattern > "u" ? this.pattern : pattern, assertValidPattern$1(pattern), options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand$6(pattern);
}
var MAX_PATTERN_LENGTH$1 = 1024 * 64, assertValidPattern$1 = function(pattern) {
  if (typeof pattern != "string")
    throw new TypeError("invalid pattern");
  if (pattern.length > MAX_PATTERN_LENGTH$1)
    throw new TypeError("pattern is too long");
};
Minimatch$2.prototype.parse = parse$b;
var SUBPARSE$1 = {};
function parse$b(pattern, isSub) {
  assertValidPattern$1(pattern);
  var options2 = this.options;
  if (pattern === "**")
    if (options2.noglobstar)
      pattern = "*";
    else
      return GLOBSTAR$1;
  if (pattern === "") return "";
  var re = "", hasMagic = !!options2.nocase, escaping = !1, patternListStack = [], negativeLists = [], stateChar, inClass = !1, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", self2 = this;
  function clearStateChar() {
    if (stateChar) {
      switch (stateChar) {
        case "*":
          re += star$2, hasMagic = !0;
          break;
        case "?":
          re += qmark$1, hasMagic = !0;
          break;
        default:
          re += "\\" + stateChar;
          break;
      }
      self2.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
    }
  }
  for (var i2 = 0, len = pattern.length, c2; i2 < len && (c2 = pattern.charAt(i2)); i2++) {
    if (this.debug("%s	%s %s %j", pattern, i2, re, c2), escaping && reSpecials$1[c2]) {
      re += "\\" + c2, escaping = !1;
      continue;
    }
    switch (c2) {
      case "/":
        return !1;
      case "\\":
        clearStateChar(), escaping = !0;
        continue;
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        if (this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re, c2), inClass) {
          this.debug("  in class"), c2 === "!" && i2 === classStart + 1 && (c2 = "^"), re += c2;
          continue;
        }
        self2.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c2, options2.noext && clearStateChar();
        continue;
      case "(":
        if (inClass) {
          re += "(";
          continue;
        }
        if (!stateChar) {
          re += "\\(";
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i2 - 1,
          reStart: re.length,
          open: plTypes$1[stateChar].open,
          close: plTypes$1[stateChar].close
        }), re += stateChar === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", stateChar, re), stateChar = !1;
        continue;
      case ")":
        if (inClass || !patternListStack.length) {
          re += "\\)";
          continue;
        }
        clearStateChar(), hasMagic = !0;
        var pl = patternListStack.pop();
        re += pl.close, pl.type === "!" && negativeLists.push(pl), pl.reEnd = re.length;
        continue;
      case "|":
        if (inClass || !patternListStack.length || escaping) {
          re += "\\|", escaping = !1;
          continue;
        }
        clearStateChar(), re += "|";
        continue;
      case "[":
        if (clearStateChar(), inClass) {
          re += "\\" + c2;
          continue;
        }
        inClass = !0, classStart = i2, reClassStart = re.length, re += c2;
        continue;
      case "]":
        if (i2 === classStart + 1 || !inClass) {
          re += "\\" + c2, escaping = !1;
          continue;
        }
        var cs = pattern.substring(classStart + 1, i2);
        try {
          RegExp("[" + cs + "]");
        } catch {
          var sp = this.parse(cs, SUBPARSE$1);
          re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]", hasMagic = hasMagic || sp[1], inClass = !1;
          continue;
        }
        hasMagic = !0, inClass = !1, re += c2;
        continue;
      default:
        clearStateChar(), escaping ? escaping = !1 : reSpecials$1[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
    }
  }
  for (inClass && (cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE$1), re = re.substr(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
      return $2 || ($2 = "\\"), $1 + $1 + $2 + "|";
    }), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
    var t = pl.type === "*" ? star$2 : pl.type === "?" ? qmark$1 : "\\" + pl.type;
    hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
  }
  clearStateChar(), escaping && (re += "\\\\");
  var addPatternStart = !1;
  switch (re.charAt(0)) {
    case "[":
    case ".":
    case "(":
      addPatternStart = !0;
  }
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8), nlLast = re.slice(nl.reEnd - 8, nl.reEnd), nlAfter = re.slice(nl.reEnd);
    nlLast += nlAfter;
    var openParensBefore = nlBefore.split("(").length - 1, cleanAfter = nlAfter;
    for (i2 = 0; i2 < openParensBefore; i2++)
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
    nlAfter = cleanAfter;
    var dollar = "";
    nlAfter === "" && isSub !== SUBPARSE$1 && (dollar = "$");
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }
  if (re !== "" && hasMagic && (re = "(?=.)" + re), addPatternStart && (re = patternStart + re), isSub === SUBPARSE$1)
    return [re, hasMagic];
  if (!hasMagic)
    return globUnescape$1(pattern);
  var flags = options2.nocase ? "i" : "";
  try {
    var regExp = new RegExp("^" + re + "$", flags);
  } catch {
    return new RegExp("$.");
  }
  return regExp._glob = pattern, regExp._src = re, regExp;
}
minimatch$2.makeRe = function(pattern, options2) {
  return new Minimatch$2(pattern, options2 || {}).makeRe();
};
Minimatch$2.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === !1) return this.regexp;
  var set2 = this.set;
  if (!set2.length)
    return this.regexp = !1, this.regexp;
  var options2 = this.options, twoStar = options2.noglobstar ? star$2 : options2.dot ? twoStarDot$1 : twoStarNoDot$1, flags = options2.nocase ? "i" : "", re = set2.map(function(pattern) {
    return pattern.map(function(p) {
      return p === GLOBSTAR$1 ? twoStar : typeof p == "string" ? regExpEscape$1(p) : p._src;
    }).join("\\/");
  }).join("|");
  re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
  try {
    this.regexp = new RegExp(re, flags);
  } catch {
    this.regexp = !1;
  }
  return this.regexp;
}
minimatch$2.match = function(list2, pattern, options2) {
  options2 = options2 || {};
  var mm = new Minimatch$2(pattern, options2);
  return list2 = list2.filter(function(f2) {
    return mm.match(f2);
  }), mm.options.nonull && !list2.length && list2.push(pattern), list2;
};
Minimatch$2.prototype.match = function match2(f2, partial) {
  if (typeof partial > "u" && (partial = this.partial), this.debug("match", f2, this.pattern), this.comment) return !1;
  if (this.empty) return f2 === "";
  if (f2 === "/" && partial) return !0;
  var options2 = this.options;
  path$j.sep !== "/" && (f2 = f2.split(path$j.sep).join("/")), f2 = f2.split(slashSplit$1), this.debug(this.pattern, "split", f2);
  var set2 = this.set;
  this.debug(this.pattern, "set", set2);
  var filename, i2;
  for (i2 = f2.length - 1; i2 >= 0 && (filename = f2[i2], !filename); i2--)
    ;
  for (i2 = 0; i2 < set2.length; i2++) {
    var pattern = set2[i2], file2 = f2;
    options2.matchBase && pattern.length === 1 && (file2 = [filename]);
    var hit = this.matchOne(file2, pattern, partial);
    if (hit)
      return options2.flipNegate ? !0 : !this.negate;
  }
  return options2.flipNegate ? !1 : this.negate;
};
Minimatch$2.prototype.matchOne = function(file2, pattern, partial) {
  var options2 = this.options;
  this.debug(
    "matchOne",
    { this: this, file: file2, pattern }
  ), this.debug("matchOne", file2.length, pattern.length);
  for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug("matchOne loop");
    var p = pattern[pi], f2 = file2[fi];
    if (this.debug(pattern, p, f2), p === !1) return !1;
    if (p === GLOBSTAR$1) {
      this.debug("GLOBSTAR", [pattern, p, f2]);
      var fr = fi, pr = pi + 1;
      if (pr === pl) {
        for (this.debug("** at the end"); fi < fl; fi++)
          if (file2[fi] === "." || file2[fi] === ".." || !options2.dot && file2[fi].charAt(0) === ".") return !1;
        return !0;
      }
      for (; fr < fl; ) {
        var swallowee = file2[fr];
        if (this.debug(`
globstar while`, file2, fr, pattern, pr, swallowee), this.matchOne(file2.slice(fr), pattern.slice(pr), partial))
          return this.debug("globstar found match!", fr, fl, swallowee), !0;
        if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
          this.debug("dot detected!", file2, fr, pattern, pr);
          break;
        }
        this.debug("globstar swallow a segment, and continue"), fr++;
      }
      return !!(partial && (this.debug(`
>>> no match, partial?`, file2, fr, pattern, pr), fr === fl));
    }
    var hit;
    if (typeof p == "string" ? (hit = f2 === p, this.debug("string match", p, f2, hit)) : (hit = f2.match(p), this.debug("pattern match", p, f2, hit)), !hit) return !1;
  }
  if (fi === fl && pi === pl)
    return !0;
  if (fi === fl)
    return partial;
  if (pi === pl)
    return fi === fl - 1 && file2[fi] === "";
  throw new Error("wtf?");
};
function globUnescape$1(s) {
  return s.replace(/\\(.)/g, "$1");
}
function regExpEscape$1(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
var isOfficialRuntime = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isStaticRuntime = exports2.isOfficialRuntime = void 0;
  const isOfficialRuntime2 = (desired, name) => typeof name != "string" ? !1 : name === `@vercel/${desired}` || name === `@now/${desired}` || name.startsWith(`@vercel/${desired}@`) || name.startsWith(`@now/${desired}@`);
  exports2.isOfficialRuntime = isOfficialRuntime2;
  const isStaticRuntime = (name) => (0, exports2.isOfficialRuntime)("static", name);
  exports2.isStaticRuntime = isStaticRuntime;
})(isOfficialRuntime);
var __importDefault$7 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(detectBuilders$1, "__esModule", { value: !0 });
detectBuilders$1.detectBuilders = detectBuilders$1.detectOutputDirectory = detectBuilders$1.detectApiDirectory = detectBuilders$1.detectApiExtensions = detectBuilders$1.sortFiles = void 0;
const minimatch_1$1 = __importDefault$7(minimatch_1$2), semver_1$1 = semver__default.default, path_1$6 = require$$0__default.default, frameworks_1 = __importDefault$7(frameworks), is_official_runtime_1 = isOfficialRuntime, slugToFramework = new Map(frameworks_1.default.map((f2) => [f2.slug, f2]));
function sortFiles(fileA, fileB) {
  return fileA.localeCompare(fileB);
}
detectBuilders$1.sortFiles = sortFiles;
function detectApiExtensions(builders) {
  return new Set(builders.filter((b) => !!(b.config && b.config.zeroConfig && b.src?.startsWith("api/"))).map((b) => (0, path_1$6.extname)(b.src)).filter(Boolean));
}
detectBuilders$1.detectApiExtensions = detectApiExtensions;
function detectApiDirectory(builders) {
  return builders.some((b) => b.config && b.config.zeroConfig && b.src?.startsWith("api/")) ? "api" : null;
}
detectBuilders$1.detectApiDirectory = detectApiDirectory;
function getPublicBuilder(builders) {
  for (const builder of builders)
    if (typeof builder.src == "string" && (0, is_official_runtime_1.isOfficialRuntime)("static", builder.use) && /^.*\/\*\*\/\*$/.test(builder.src) && builder.config?.zeroConfig === !0)
      return builder;
  return null;
}
function detectOutputDirectory(builders) {
  const publicBuilder = getPublicBuilder(builders);
  return publicBuilder ? publicBuilder.src.replace("/**/*", "") : null;
}
detectBuilders$1.detectOutputDirectory = detectOutputDirectory;
async function detectBuilders(files, pkg, options2 = {}) {
  const errors2 = [], warnings = [];
  let apiBuilders = [], frontendBuilder = null;
  const functionError = validateFunctions(options2);
  if (functionError)
    return {
      builders: null,
      errors: [functionError],
      warnings,
      defaultRoutes: null,
      redirectRoutes: null,
      rewriteRoutes: null,
      errorRoutes: null
    };
  const sortedFiles = files.sort(sortFiles), apiSortedFiles = files.sort(sortFilesBySegmentCount), usedFunctions = /* @__PURE__ */ new Set(), addToUsedFunctions = (builder) => {
    const key2 = Object.keys(builder.config.functions || {})[0];
    key2 && usedFunctions.add(key2);
  }, absolutePathCache = /* @__PURE__ */ new Map(), { projectSettings = {} } = options2, { buildCommand, outputDirectory, framework } = projectSettings, frameworkConfig = slugToFramework.get(framework || ""), ignoreRuntimes = new Set(frameworkConfig?.ignoreRuntimes), withTag = options2.tag ? `@${options2.tag}` : "", apiMatches = getApiMatches().filter((b) => (
    // Root-level middleware is enabled, unless `disableRootMiddleware: true`
    b.config?.middleware && !frameworkConfig?.disableRootMiddleware || // "api" dir runtimes are enabled, unless opted-out via `ignoreRuntimes`
    !ignoreRuntimes.has(b.use)
  )).map((b) => (b.use = `${b.use}${withTag}`, b)), makeFrontendStatic = buildCommand === "" || outputDirectory === "", usedOutputDirectory = outputDirectory || "public";
  let hasUsedOutputDirectory = !1, hasNoneApiFiles = !1, hasNextApiFiles = !1, fallbackEntrypoint = null;
  const apiRoutes = [], dynamicRoutes = [];
  for (const fileName of sortedFiles) {
    const apiBuilder = maybeGetApiBuilder(fileName, apiMatches, options2);
    if (apiBuilder) {
      const { routeError, apiRoute, isDynamic } = getApiRoute(fileName, apiSortedFiles, options2, absolutePathCache);
      if (routeError)
        return {
          builders: null,
          errors: [routeError],
          warnings,
          defaultRoutes: null,
          redirectRoutes: null,
          rewriteRoutes: null,
          errorRoutes: null
        };
      apiRoute && (apiRoutes.push(apiRoute), isDynamic && dynamicRoutes.push(apiRoute)), addToUsedFunctions(apiBuilder), apiBuilders.push(apiBuilder);
      continue;
    }
    !hasUsedOutputDirectory && fileName.startsWith(`${usedOutputDirectory}/`) && (hasUsedOutputDirectory = !0), !hasNoneApiFiles && !fileName.startsWith("api/") && fileName !== "package.json" && (hasNoneApiFiles = !0), !hasNextApiFiles && (fileName.startsWith("pages/api") || fileName.startsWith("src/pages/api")) && (hasNextApiFiles = !0), !fallbackEntrypoint && buildCommand && !fileName.includes("/") && fileName !== "now.json" && fileName !== "vercel.json" && (fallbackEntrypoint = fileName);
  }
  if (!makeFrontendStatic && (hasBuildScript(pkg) || buildCommand || framework))
    frontendBuilder = detectFrontBuilder(pkg, files, usedFunctions, fallbackEntrypoint, options2);
  else {
    if (pkg && !makeFrontendStatic && !apiBuilders.length && !options2.ignoreBuildScript)
      return errors2.push(getMissingBuildScriptError()), {
        errors: errors2,
        warnings,
        builders: null,
        redirectRoutes: null,
        defaultRoutes: null,
        rewriteRoutes: null,
        errorRoutes: null
      };
    hasUsedOutputDirectory && outputDirectory !== "" ? frontendBuilder = {
      use: "@vercel/static",
      src: `${usedOutputDirectory}/**/*`,
      config: {
        zeroConfig: !0,
        outputDirectory: usedOutputDirectory
      }
    } : apiBuilders.length && hasNoneApiFiles && (frontendBuilder = {
      use: "@vercel/static",
      src: "!{api/**,package.json,middleware.[jt]s}",
      config: {
        zeroConfig: !0
      }
    });
  }
  const unusedFunctionError = checkUnusedFunctions(frontendBuilder, usedFunctions, options2);
  if (unusedFunctionError)
    return {
      builders: null,
      errors: [unusedFunctionError],
      warnings,
      redirectRoutes: null,
      defaultRoutes: null,
      rewriteRoutes: null,
      errorRoutes: null
    };
  framework === null && frontendBuilder?.use === "@vercel/next" && apiBuilders.length > 0 && (apiBuilders = apiBuilders.filter((builder) => !(builder.use === "@vercel/node" && builder.config?.middleware)));
  const builders = [];
  apiBuilders.length && builders.push(...apiBuilders), frontendBuilder && (builders.push(frontendBuilder), hasNextApiFiles && apiBuilders.some((b) => (0, is_official_runtime_1.isOfficialRuntime)("node", b.use)) && warnings.push({
    code: "conflicting_files",
    message: "When using Next.js, it is recommended to place JavaScript Functions inside of the `pages/api` (provided by Next.js) directory instead of `api` (provided by Vercel). Other languages (Python, Go, etc) should still go in the `api` directory.",
    link: "https://nextjs.org/docs/api-routes/introduction",
    action: "Learn More"
  }));
  const routesResult = getRouteResult(apiRoutes, dynamicRoutes, usedOutputDirectory, apiBuilders, frontendBuilder, options2);
  return {
    warnings,
    builders: builders.length ? builders : null,
    errors: errors2.length ? errors2 : null,
    redirectRoutes: routesResult.redirectRoutes,
    defaultRoutes: routesResult.defaultRoutes,
    rewriteRoutes: routesResult.rewriteRoutes,
    errorRoutes: routesResult.errorRoutes
  };
}
detectBuilders$1.detectBuilders = detectBuilders;
function maybeGetApiBuilder(fileName, apiMatches, options2) {
  const middleware = fileName === "middleware.js" || fileName === "middleware.ts";
  if (middleware && options2.projectSettings?.framework === "nextjs" || !(fileName.startsWith("api/") || middleware) || fileName.includes("/.") || fileName.includes("/_") || fileName.includes("/node_modules/") || fileName.endsWith(".d.ts"))
    return null;
  const match3 = apiMatches.find(({ src: src2 = "**" }) => src2 === fileName || (0, minimatch_1$1.default)(fileName, src2)), { fnPattern, func } = getFunction(fileName, options2), use = func?.runtime || match3?.use;
  if (!use)
    return null;
  const config2 = { zeroConfig: !0 };
  return middleware && (config2.middleware = !0), fnPattern && func && (config2.functions = { [fnPattern]: func }, func.includeFiles && (config2.includeFiles = func.includeFiles), func.excludeFiles && (config2.excludeFiles = func.excludeFiles)), {
    use,
    src: fileName,
    config: config2
  };
}
function getFunction(fileName, { functions = {} }) {
  const keys = Object.keys(functions);
  if (!keys.length)
    return { fnPattern: null, func: null };
  const func = keys.find((key2) => key2 === fileName || (0, minimatch_1$1.default)(fileName, key2));
  return func ? { fnPattern: func, func: functions[func] } : { fnPattern: null, func: null };
}
function getApiMatches() {
  const config2 = { zeroConfig: !0 };
  return [
    {
      src: "middleware.[jt]s",
      use: "@vercel/node",
      config: { ...config2, middleware: !0 }
    },
    { src: "api/**/*.+(js|mjs|ts|tsx)", use: "@vercel/node", config: config2 },
    { src: "api/**/!(*_test).go", use: "@vercel/go", config: config2 },
    { src: "api/**/*.py", use: "@vercel/python", config: config2 },
    { src: "api/**/*.rb", use: "@vercel/ruby", config: config2 }
  ];
}
function hasBuildScript(pkg) {
  const { scripts = {} } = pkg || {};
  return !!(scripts && scripts.build);
}
function detectFrontBuilder(pkg, files, usedFunctions, fallbackEntrypoint, options2) {
  const { tag, projectSettings = {} } = options2, withTag = tag ? `@${tag}` : "", { createdAt = 0 } = projectSettings;
  let { framework } = projectSettings;
  const config2 = {
    zeroConfig: !0
  };
  framework && (config2.framework = framework), projectSettings.devCommand && (config2.devCommand = projectSettings.devCommand), typeof projectSettings.installCommand == "string" && (config2.installCommand = projectSettings.installCommand), projectSettings.buildCommand && (config2.buildCommand = projectSettings.buildCommand), projectSettings.outputDirectory && (config2.outputDirectory = projectSettings.outputDirectory), pkg && (framework === void 0 || framework !== "storybook" && createdAt < Date.parse("2020-03-01")) && {
    ...pkg.dependencies,
    ...pkg.devDependencies
  }.next && (framework = "nextjs"), options2.functions && Object.entries(options2.functions).forEach(([key2, func]) => {
    usedFunctions.has(key2) || (config2.functions || (config2.functions = {}), config2.functions[key2] = { ...func });
  });
  const f2 = slugToFramework.get(framework || "");
  if (f2 && f2.useRuntime) {
    const { src: src2, use } = f2.useRuntime;
    return { src: src2, use: `${use}${withTag}`, config: config2 };
  }
  const entrypoints = /* @__PURE__ */ new Set([
    "package.json",
    "config.yaml",
    "config.toml",
    "config.json",
    "_config.yml",
    "config.yml",
    "config.rb"
  ]);
  return {
    src: (pkg ? "package.json" : files.find((file2) => entrypoints.has(file2)) || fallbackEntrypoint || "package.json") || "package.json",
    use: `@vercel/static-build${withTag}`,
    config: config2
  };
}
function getMissingBuildScriptError() {
  return {
    code: "missing_build_script",
    message: "Your `package.json` file is missing a `build` property inside the `scripts` property.\nLearn More: https://vercel.link/missing-build-script"
  };
}
function validateFunctions({ functions = {} }) {
  for (const [path2, func] of Object.entries(functions)) {
    if (path2.length > 256)
      return {
        code: "invalid_function_glob",
        message: "Function globs must be less than 256 characters long."
      };
    if (!func || typeof func != "object")
      return {
        code: "invalid_function",
        message: "Function must be an object."
      };
    if (Object.keys(func).length === 0)
      return {
        code: "invalid_function",
        message: "Function must contain at least one property."
      };
    if (func.maxDuration !== void 0 && (func.maxDuration < 1 || func.maxDuration > 900 || !Number.isInteger(func.maxDuration)))
      return {
        code: "invalid_function_duration",
        message: "Functions must have a duration between 1 and 900."
      };
    if (func.memory !== void 0 && (func.memory < 128 || func.memory > 3008))
      return {
        code: "invalid_function_memory",
        message: "Functions must have a memory value between 128 and 3008"
      };
    if (path2.startsWith("/"))
      return {
        code: "invalid_function_source",
        message: `The function path "${path2}" is invalid. The path must be relative to your project root and therefore cannot start with a slash.`
      };
    if (func.runtime !== void 0) {
      const tag = `${func.runtime}`.split("@").pop();
      if (!tag || !(0, semver_1$1.valid)(tag))
        return {
          code: "invalid_function_runtime",
          message: "Function Runtimes must have a valid version, for example `now-php@1.0.0`."
        };
    }
    if (func.includeFiles !== void 0 && typeof func.includeFiles != "string")
      return {
        code: "invalid_function_property",
        message: "The property `includeFiles` must be a string."
      };
    if (func.excludeFiles !== void 0 && typeof func.excludeFiles != "string")
      return {
        code: "invalid_function_property",
        message: "The property `excludeFiles` must be a string."
      };
  }
  return null;
}
function checkUnusedFunctions(frontendBuilder, usedFunctions, options2) {
  const unusedFunctions = new Set(Object.keys(options2.functions || {}).filter((key2) => !usedFunctions.has(key2)));
  if (!unusedFunctions.size)
    return null;
  if (frontendBuilder && (0, is_official_runtime_1.isOfficialRuntime)("next", frontendBuilder.use))
    for (const fnKey of unusedFunctions.values())
      if (fnKey.startsWith("pages/") || fnKey.startsWith("src/pages") || fnKey.startsWith("app/") || fnKey.startsWith("src/app/"))
        unusedFunctions.delete(fnKey);
      else
        return {
          code: "unused_function",
          message: `The pattern "${fnKey}" defined in \`functions\` doesn't match any Serverless Functions.`,
          action: "Learn More",
          link: "https://vercel.link/unmatched-function-pattern"
        };
  if (unusedFunctions.size) {
    const [fnKey] = Array.from(unusedFunctions);
    return {
      code: "unused_function",
      message: `The pattern "${fnKey}" defined in \`functions\` doesn't match any Serverless Functions inside the \`api\` directory.`,
      action: "Learn More",
      link: "https://vercel.link/unmatched-function-pattern"
    };
  }
  return null;
}
function getApiRoute(fileName, sortedFiles, options2, absolutePathCache) {
  const conflictingSegment = getConflictingSegment(fileName);
  if (conflictingSegment)
    return {
      apiRoute: null,
      isDynamic: !1,
      routeError: {
        code: "conflicting_path_segment",
        message: `The segment "${conflictingSegment}" occurs more than one time in your path "${fileName}". Please make sure that every segment in a path is unique.`
      }
    };
  const occurrences = pathOccurrences(fileName, sortedFiles, absolutePathCache);
  if (occurrences.length > 0) {
    const messagePaths = concatArrayOfText(occurrences.map((name) => `"${name}"`));
    return {
      apiRoute: null,
      isDynamic: !1,
      routeError: {
        code: "conflicting_file_path",
        message: `Two or more files have conflicting paths or names. Please make sure path segments and filenames, without their extension, are unique. The path "${fileName}" has conflicts with ${messagePaths}.`
      }
    };
  }
  const out = createRouteFromPath(fileName, !!options2.featHandleMiss, !!options2.cleanUrls);
  return {
    apiRoute: out.route,
    isDynamic: out.isDynamic,
    routeError: null
  };
}
function getConflictingSegment(filePath) {
  const segments = /* @__PURE__ */ new Set();
  for (const segment of filePath.split("/")) {
    const name = getSegmentName(segment);
    if (name !== null && segments.has(name))
      return name;
    name && segments.add(name);
  }
  return null;
}
function getSegmentName(segment) {
  const { name } = (0, path_1$6.parse)(segment);
  return name.startsWith("[") && name.endsWith("]") ? name.slice(1, -1) : null;
}
function getAbsolutePath(unresolvedPath) {
  const { dir, name } = (0, path_1$6.parse)(unresolvedPath);
  return joinPath(dir, name).split("/").map((part) => part.replace(/\[.*\]/, "1")).join("/");
}
function pathOccurrences(fileName, files, absolutePathCache) {
  let currentAbsolutePath = absolutePathCache.get(fileName);
  currentAbsolutePath || (currentAbsolutePath = getAbsolutePath(fileName), absolutePathCache.set(fileName, currentAbsolutePath));
  const prev = [];
  for (const file2 of files) {
    if (file2 === fileName)
      continue;
    let absolutePath = absolutePathCache.get(file2);
    absolutePath || (absolutePath = getAbsolutePath(file2), absolutePathCache.set(file2, absolutePath)), (absolutePath === currentAbsolutePath || partiallyMatches(fileName, file2)) && prev.push(file2);
  }
  return prev;
}
function joinPath(...segments) {
  return segments.join("/").replace(/\/{2,}/g, "/");
}
function escapeName(name) {
  const special = "[]^$.|?*+()".split("");
  for (const char of special)
    name = name.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
  return name;
}
function concatArrayOfText(texts) {
  if (texts.length <= 2)
    return texts.join(" and ");
  const last2 = texts.pop();
  return `${texts.join(", ")}, and ${last2}`;
}
function partiallyMatches(pathA, pathB) {
  const partsA = pathA.split("/"), partsB = pathB.split("/"), long = partsA.length > partsB.length ? partsA : partsB, short = long === partsA ? partsB : partsA;
  let index = 0;
  for (const segmentShort of short) {
    const segmentLong = long[index], nameLong = getSegmentName(segmentLong), nameShort = getSegmentName(segmentShort);
    if (segmentShort !== segmentLong && (!nameLong || !nameShort))
      return !1;
    if (nameLong !== nameShort)
      return !0;
    index += 1;
  }
  return !1;
}
function createRouteFromPath(filePath, featHandleMiss, cleanUrls) {
  const parts = filePath.split("/");
  let counter = 1;
  const query = [];
  let isDynamic = !1;
  const srcParts = parts.map((segment, i2) => {
    const name = getSegmentName(segment), isLast = i2 === parts.length - 1;
    if (name !== null)
      return query.push(`${name}=$${counter++}`), isDynamic = !0, "([^/]+)";
    if (isLast) {
      const { name: fileName2, ext: ext3 } = (0, path_1$6.parse)(segment), isIndex2 = fileName2 === "index", prefix = isIndex2 ? "/" : "";
      return `(${[
        isIndex2 ? prefix : `${fileName2}/`,
        prefix + escapeName(fileName2),
        featHandleMiss && cleanUrls ? "" : prefix + escapeName(fileName2) + escapeName(ext3)
      ].filter(Boolean).join("|")})${isIndex2 ? "?" : ""}`;
    }
    return segment;
  }), { name: fileName, ext: ext2 } = (0, path_1$6.parse)(filePath), isIndex = fileName === "index", queryString = `${query.length ? "?" : ""}${query.join("&")}`, src2 = isIndex ? `^/${srcParts.slice(0, -1).join("/")}${srcParts.slice(-1)[0]}$` : `^/${srcParts.join("/")}$`;
  let route;
  if (featHandleMiss) {
    const extensionless = ext2 ? filePath.slice(0, -ext2.length) : filePath;
    route = {
      src: src2,
      dest: `/${extensionless}${queryString}`,
      check: !0
    };
  } else
    route = {
      src: src2,
      dest: `/${filePath}${queryString}`
    };
  return { route, isDynamic };
}
function getRouteResult(apiRoutes, dynamicRoutes, outputDirectory, apiBuilders, frontendBuilder, options2) {
  const defaultRoutes = [], redirectRoutes = [], rewriteRoutes = [], errorRoutes = [], framework = frontendBuilder?.config?.framework || "", isNextjs = framework === "nextjs" || (0, is_official_runtime_1.isOfficialRuntime)("next", frontendBuilder?.use), ignoreRuntimes = slugToFramework.get(framework)?.ignoreRuntimes;
  if (apiRoutes && apiRoutes.length > 0)
    if (options2.featHandleMiss) {
      const extSet = detectApiExtensions(apiBuilders);
      if (extSet.size > 0) {
        const extGroup = `(?:\\.(?:${Array.from(extSet).map((ext2) => ext2.slice(1)).join("|")}))`;
        options2.cleanUrls ? (redirectRoutes.push({
          src: `^/(api(?:.+)?)/index${extGroup}?/?$`,
          headers: { Location: options2.trailingSlash ? "/$1/" : "/$1" },
          status: 308
        }), redirectRoutes.push({
          src: `^/api/(.+)${extGroup}/?$`,
          headers: {
            Location: options2.trailingSlash ? "/api/$1/" : "/api/$1"
          },
          status: 308
        })) : (defaultRoutes.push({ handle: "miss" }), defaultRoutes.push({
          src: `^/api/(.+)${extGroup}$`,
          dest: "/api/$1",
          check: !0
        }));
      }
      rewriteRoutes.push(...dynamicRoutes);
      const hasApiBuild = apiBuilders.find((builder) => builder.src?.startsWith("api/"));
      typeof ignoreRuntimes > "u" && hasApiBuild && rewriteRoutes.push({
        src: "^/api(/.*)?$",
        status: 404
      });
    } else
      defaultRoutes.push(...apiRoutes), apiRoutes.length && defaultRoutes.push({
        status: 404,
        src: "^/api(/.*)?$"
      });
  return outputDirectory && frontendBuilder && !options2.featHandleMiss && (0, is_official_runtime_1.isOfficialRuntime)("static", frontendBuilder.use) && defaultRoutes.push({
    src: "/(.*)",
    dest: `/${outputDirectory}/$1`
  }), options2.featHandleMiss && !isNextjs && errorRoutes.push({
    status: 404,
    src: "^(?!/api).*$",
    dest: options2.cleanUrls ? "/404" : "/404.html"
  }), {
    defaultRoutes,
    redirectRoutes,
    rewriteRoutes,
    errorRoutes
  };
}
function sortFilesBySegmentCount(fileA, fileB) {
  const lengthA = fileA.split("/").length, lengthB = fileB.split("/").length;
  if (lengthA > lengthB)
    return -1;
  if (lengthA < lengthB)
    return 1;
  const countSegments = (prev, segment) => getSegmentName(segment) ? prev + 1 : 0, segmentLengthA = fileA.split("/").reduce(countSegments, 0), segmentLengthB = fileB.split("/").reduce(countSegments, 0);
  return segmentLengthA > segmentLengthB ? 1 : segmentLengthA < segmentLengthB ? -1 : fileA.localeCompare(fileB);
}
var detectFileSystemApi = {}, hasRequiredDetectFileSystemApi;
function requireDetectFileSystemApi() {
  if (hasRequiredDetectFileSystemApi) return detectFileSystemApi;
  hasRequiredDetectFileSystemApi = 1;
  var __importDefault2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(detectFileSystemApi, "__esModule", { value: !0 }), detectFileSystemApi.detectFileSystemAPI = void 0;
  const semver_12 = __importDefault2(semver__default.default), _1 = requireDist();
  async function detectFileSystemAPI({ files, projectSettings, builders, vercelConfig, pkg, tag, enableFlag = !1 }) {
    const framework = projectSettings.framework || "", deps = Object.assign({}, pkg?.dependencies, pkg?.devDependencies), plugins = Object.keys(deps).filter((dep) => dep.startsWith("vercel-plugin-")), hasDotOutput = Object.keys(files).some((file2) => file2.startsWith(".output/")), hasMiddleware = !!(files["_middleware.js"] || files["_middleware.ts"]), metadata = {
      plugins,
      hasDotOutput,
      hasMiddleware
    };
    if (!(enableFlag || hasMiddleware || hasDotOutput))
      return { metadata, fsApiBuilder: null, reason: "Flag not enabled." };
    if (vercelConfig?.builds && vercelConfig.builds.length > 0)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `builds` in vercel.json. Please remove it in favor of CLI plugins."
      };
    if (Object.values(vercelConfig?.functions || {}).some((fn2) => !!fn2.runtime))
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `functions.runtime` in vercel.json. Please remove it in favor of CLI plugins."
      };
    if (process.env.HUGO_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `HUGO_VERSION` environment variable. Please remove it."
      };
    if (process.env.ZOLA_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `ZOLA_VERSION` environment variable. Please remove it."
      };
    if (process.env.GUTENBERG_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `GUTENBERG_VERSION` environment variable. Please remove it."
      };
    const invalidBuilder = builders.find(({ use }) => !((0, _1.isOfficialRuntime)("go", use) || (0, _1.isOfficialRuntime)("python", use) || (0, _1.isOfficialRuntime)("ruby", use) || (0, _1.isOfficialRuntime)("node", use) || (0, _1.isOfficialRuntime)("next", use) || (0, _1.isOfficialRuntime)("static", use) || (0, _1.isOfficialRuntime)("static-build", use)));
    if (invalidBuilder)
      return {
        metadata,
        fsApiBuilder: null,
        reason: `Detected \`${invalidBuilder.use}\` in vercel.json. Please remove it in favor of CLI plugins.`
      };
    for (const lang of ["go", "python", "ruby"])
      for (const { use } of builders) {
        const plugin = "vercel-plugin-" + lang;
        if ((0, _1.isOfficialRuntime)(lang, use) && !deps[plugin])
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected \`${lang}\` Serverless Function usage without plugin \`${plugin}\`. Please run \`npm i ${plugin}\`.`
          };
      }
    if (framework === "nuxtjs" || framework === "sveltekit" || framework === "redwoodjs")
      return {
        metadata,
        fsApiBuilder: null,
        reason: `Detected framework \`${framework}\` that only supports legacy File System API. Please contact the framework author.`
      };
    if (framework === "nextjs" && !hasDotOutput) {
      if (projectSettings?.outputDirectory)
        return {
          metadata,
          fsApiBuilder: null,
          reason: `Detected Next.js with Output Directory \`${projectSettings.outputDirectory}\` override. Please change it back to the default.`
        };
      const nextVersion = deps.next;
      if (!nextVersion)
        return {
          metadata,
          fsApiBuilder: null,
          reason: "Detected Next.js in Project Settings but missing `next` package.json dependencies. Please run `npm i next`."
        };
      if (nextVersion !== "latest" && nextVersion !== "canary") {
        const fixedVersion = semver_12.default.valid(semver_12.default.coerce(nextVersion) || "");
        if (!fixedVersion || !semver_12.default.gte(fixedVersion, "12.0.0"))
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected legacy Next.js version "${nextVersion}" in package.json. Please run \`npm i next@latest\` to upgrade.`
          };
      }
    }
    if (!hasDotOutput) {
      const vercelCliVersion = deps.vercel;
      if (vercelCliVersion && vercelCliVersion !== "latest" && vercelCliVersion !== "canary") {
        const fixedVersion = semver_12.default.valid(semver_12.default.coerce(vercelCliVersion) || "");
        if (!fixedVersion || !semver_12.default.gte(fixedVersion, "23.1.3-canary.68"))
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected legacy Vercel CLI version "${vercelCliVersion}" in package.json. Please run \`npm i vercel@latest\` to upgrade.`
          };
      }
    }
    const config2 = builders.find(({ use }) => (0, _1.isOfficialRuntime)("next", use) || (0, _1.isOfficialRuntime)("static", use) || (0, _1.isOfficialRuntime)("static-build", use))?.config || {}, fsApiBuilder = {
      use: `@vercelruntimes/file-system-api${tag ? `@${tag}` : ""}`,
      src: "**",
      config: {
        ...config2,
        fileSystemAPI: !0,
        framework: config2.framework || framework || null,
        projectSettings,
        hasMiddleware,
        hasDotOutput
      }
    };
    return { metadata, fsApiBuilder, reason: null };
  }
  return detectFileSystemApi.detectFileSystemAPI = detectFileSystemAPI, detectFileSystemApi;
}
var detectFramework$1 = {};
Object.defineProperty(detectFramework$1, "__esModule", { value: !0 });
detectFramework$1.detectFrameworkVersion = detectFramework$1.detectFrameworkRecord = detectFramework$1.detectFrameworks = detectFramework$1.detectFramework = void 0;
const child_process_1 = require$$0__default$7.default;
async function matches(fs2, framework) {
  const { detectors } = framework;
  if (!detectors)
    return;
  const { every: every2, some } = detectors;
  if (every2 !== void 0 && !Array.isArray(every2) || some !== void 0 && !Array.isArray(some))
    return;
  const check = async ({ path: path2, matchContent, matchPackage }) => {
    if (matchPackage && matchContent)
      throw new Error(`Cannot specify "matchPackage" and "matchContent" in the same detector for "${framework.slug}"`);
    if (matchPackage && path2)
      throw new Error(`Cannot specify "matchPackage" and "path" in the same detector for "${framework.slug}" because "path" is assumed to be "package.json".`);
    if (!path2 && !matchPackage)
      throw new Error(`Must specify either "path" or "matchPackage" in detector for "${framework.slug}".`);
    if (path2 || (path2 = "package.json"), matchPackage && (matchContent = `"(dev)?(d|D)ependencies":\\s*{[^}]*"${matchPackage}":\\s*"(.+?)"[^}]*}`), await fs2.hasPath(path2) !== !1) {
      if (matchContent) {
        if (await fs2.isFile(path2) === !1)
          return;
        const regex = new RegExp(matchContent, "m"), match3 = (await fs2.readFile(path2)).toString().match(regex);
        if (!match3)
          return;
        if (matchPackage && match3[3])
          return {
            framework,
            detectedVersion: match3[3]
          };
      }
      return {
        framework
      };
    }
  }, result = [];
  if (every2) {
    const everyResult = await Promise.all(every2.map((item) => check(item)));
    result.push(...everyResult);
  }
  if (some) {
    let someResult;
    for (const item of some) {
      const itemResult = await check(item);
      if (itemResult) {
        someResult = itemResult;
        break;
      }
    }
    result.push(someResult);
  }
  if (!result.every((res) => !!res))
    return;
  const detectedVersion = result.find((r) => typeof r == "object" && r.detectedVersion)?.detectedVersion;
  return {
    framework,
    detectedVersion
  };
}
async function detectFramework({ fs: fs2, frameworkList }) {
  return (await Promise.all(frameworkList.map(async (frameworkMatch) => await matches(fs2, frameworkMatch) ? frameworkMatch.slug : null))).find((res) => res !== null) ?? null;
}
detectFramework$1.detectFramework = detectFramework;
async function detectFrameworks({ fs: fs2, frameworkList }) {
  return (await Promise.all(frameworkList.map(async (frameworkMatch) => await matches(fs2, frameworkMatch) ? frameworkMatch : null))).filter((res) => res !== null);
}
detectFramework$1.detectFrameworks = detectFrameworks;
async function detectFrameworkRecord({ fs: fs2, frameworkList }) {
  return (await Promise.all(frameworkList.map(async (frameworkMatch) => {
    const matchResult = await matches(fs2, frameworkMatch);
    return matchResult ? {
      ...frameworkMatch,
      detectedVersion: matchResult?.detectedVersion
    } : null;
  }))).find((res) => res !== null) ?? null;
}
detectFramework$1.detectFrameworkRecord = detectFrameworkRecord;
function detectFrameworkVersion(frameworkRecord) {
  const firstMatchPackage = [
    ...frameworkRecord.detectors?.every || [],
    ...frameworkRecord.detectors?.some || []
  ].find((d) => d.matchPackage);
  if (firstMatchPackage?.matchPackage)
    return lookupInstalledVersion(process.execPath, firstMatchPackage.matchPackage);
}
detectFramework$1.detectFrameworkVersion = detectFrameworkVersion;
function lookupInstalledVersion(cwd2, packageName) {
  try {
    const script = `require('${packageName}/package.json').version`;
    return (0, child_process_1.spawnSync)(cwd2, ["-p", script], {
      encoding: "utf-8"
    }).stdout.trim();
  } catch (error2) {
    console.debug(`Error looking up version of installed package "${packageName}": ${error2}`);
  }
}
var getProjectPaths = {};
(function(exports2) {
  var __importDefault2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.getProjectPaths = void 0;
  const detect_framework_12 = detectFramework$1, frameworks_12 = __importDefault2(frameworks), MAX_DEPTH_TRAVERSE2 = 3, getProjectPaths2 = async ({ fs: fs2, path: path2, skipPaths, depth: depth2 = MAX_DEPTH_TRAVERSE2 }) => {
    if (depth2 === 0)
      return [];
    const allPaths = [], topPath = path2 ?? "./";
    if (path2 && skipPaths?.includes(path2))
      return allPaths;
    if (await (0, detect_framework_12.detectFramework)({
      fs: fs2.chdir(topPath),
      frameworkList: frameworks_12.default
    }) !== null && allPaths.push(topPath), depth2 > 1) {
      const childDirectories = (await fs2.readdir(topPath)).filter((stat) => stat.type === "dir" && !skipPaths?.includes(stat.path));
      return [...(await Promise.all(childDirectories.map(({ path: path3 }) => (0, exports2.getProjectPaths)({
        fs: fs2,
        path: path3,
        depth: depth2 - 1,
        skipPaths
      })))).flat(), ...allPaths];
    }
    return allPaths;
  };
  exports2.getProjectPaths = getProjectPaths2;
})(getProjectPaths);
var filesystem = {};
Object.defineProperty(filesystem, "__esModule", { value: !0 });
filesystem.DetectorFilesystem = void 0;
const path_1$5 = require$$0__default.default;
class DetectorFilesystem {
  constructor() {
    this.hasPath = async (path2) => {
      let p = this.pathCache.get(path2);
      return p || (p = this._hasPath(path2), this.pathCache.set(path2, p)), p;
    }, this.isFile = async (name) => {
      let p = this.fileCache.get(name);
      return p || (p = this._isFile(name), this.fileCache.set(name, p)), p;
    }, this.readFile = async (name) => {
      let p = this.readFileCache.get(name);
      return p || (p = this._readFile(name), this.readFileCache.set(name, p)), p;
    }, this.readdir = async (dirPath, options2) => {
      let p = this.readdirCache.get(dirPath);
      p || (p = this._readdir(dirPath), this.readdirCache.set(dirPath, p));
      const directoryContent = await p, directoryFiles = /* @__PURE__ */ new Set();
      for (const file2 of directoryContent)
        file2.type === "file" && (this.fileCache.set(file2.path, Promise.resolve(!0)), this.pathCache.set(file2.path, Promise.resolve(!0)), directoryFiles.add(file2.name));
      if (options2?.potentialFiles) {
        const filesThatDoNotExist = options2.potentialFiles.filter((path2) => !directoryFiles.has(path2));
        for (const filePath of filesThatDoNotExist) {
          const fullFilePath = dirPath === "/" ? filePath : path_1$5.posix.join(dirPath, filePath);
          this.fileCache.set(fullFilePath, Promise.resolve(!1)), this.pathCache.set(fullFilePath, Promise.resolve(!1));
        }
      }
      return p;
    }, this.chdir = (name) => this._chdir(name), this.writeFile = async (name, content) => {
      this.readFileCache.set(name, Promise.resolve(Buffer.from(content))), this.fileCache.set(name, Promise.resolve(!0)), this.pathCache.set(name, Promise.resolve(!0));
    }, this.pathCache = /* @__PURE__ */ new Map(), this.fileCache = /* @__PURE__ */ new Map(), this.readFileCache = /* @__PURE__ */ new Map(), this.readdirCache = /* @__PURE__ */ new Map();
  }
}
filesystem.DetectorFilesystem = DetectorFilesystem;
var localFileSystemDetector = {}, __importDefault$6 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(localFileSystemDetector, "__esModule", { value: !0 });
localFileSystemDetector.LocalFileSystemDetector = void 0;
const promises_1 = __importDefault$6(require$$0__default$8.default), path_1$4 = require$$0__default.default, filesystem_1 = filesystem, error_utils_1 = dist$2;
class LocalFileSystemDetector extends filesystem_1.DetectorFilesystem {
  constructor(rootPath) {
    super(), this.rootPath = rootPath;
  }
  async _hasPath(name) {
    try {
      return await promises_1.default.stat(this.getFilePath(name)), !0;
    } catch (err) {
      if ((0, error_utils_1.isErrnoException)(err) && err.code === "ENOENT")
        return !1;
      throw err;
    }
  }
  _readFile(name) {
    return promises_1.default.readFile(this.getFilePath(name));
  }
  async _isFile(name) {
    return (await promises_1.default.stat(this.getFilePath(name))).isFile();
  }
  async _readdir(dir) {
    const dirPath = this.getFilePath(dir), files = await promises_1.default.readdir(dirPath);
    return Promise.all(files.map(async (name) => {
      const absPath = (0, path_1$4.join)(this.rootPath, dir, name), path2 = (0, path_1$4.join)(this.getRelativeFilePath(dir), name), stat = await promises_1.default.stat(absPath);
      let type2;
      if (stat.isFile())
        type2 = "file";
      else if (stat.isDirectory())
        type2 = "dir";
      else
        throw new Error(`Dirent was neither file nor directory: ${path2}`);
      return { name, path: path2, type: type2 };
    }));
  }
  _chdir(name) {
    return new LocalFileSystemDetector(this.getFilePath(name));
  }
  getRelativeFilePath(name) {
    return name.startsWith(this.rootPath) ? (0, path_1$4.relative)(this.rootPath, name) : name;
  }
  getFilePath(name) {
    return (0, path_1$4.join)(this.rootPath, this.getRelativeFilePath(name));
  }
}
localFileSystemDetector.LocalFileSystemDetector = LocalFileSystemDetector;
var workspaceManagers = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.workspaceManagers = void 0, exports2.workspaceManagers = [
    {
      name: "Yarn",
      slug: "yarn",
      detectors: {
        every: [
          {
            path: "package.json",
            matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
          },
          {
            path: "yarn.lock"
          }
        ]
      }
    },
    {
      name: "pnpm",
      slug: "pnpm",
      detectors: {
        every: [
          {
            path: "pnpm-workspace.yaml"
          }
        ]
      }
    },
    {
      name: "npm",
      slug: "npm",
      detectors: {
        every: [
          {
            path: "package.json",
            matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
          },
          {
            path: "package-lock.json"
          }
        ]
      }
    },
    {
      name: "nx",
      slug: "nx",
      detectors: {
        every: [
          {
            path: "workspace.json",
            matchContent: '"projects":\\s*{[^}]'
          }
        ]
      }
    },
    {
      name: "rush",
      slug: "rush",
      detectors: {
        every: [
          {
            path: "rush.json"
          }
        ]
      }
    },
    {
      name: "default",
      slug: "yarn",
      detectors: {
        every: [
          {
            path: "package.json",
            matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
          }
        ]
      }
    }
  ], exports2.default = exports2.workspaceManagers;
})(workspaceManagers);
var getWorkspaces$1 = {}, __importDefault$5 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(getWorkspaces$1, "__esModule", { value: !0 });
getWorkspaces$1.getWorkspaces = void 0;
const path_1$3 = __importDefault$5(require$$0__default.default), workspace_managers_1 = workspaceManagers, detect_framework_1$1 = detectFramework$1, MAX_DEPTH_TRAVERSE = 3, posixPath$1 = path_1$3.default.posix;
async function getWorkspaces({ fs: fs2, depth: depth2 = MAX_DEPTH_TRAVERSE, cwd: cwd2 = "/" }) {
  if (depth2 === 0)
    return [];
  const workspaceType = await (0, detect_framework_1$1.detectFramework)({
    fs: fs2,
    frameworkList: workspace_managers_1.workspaceManagers
  });
  if (workspaceType === null) {
    const childDirectories = (await fs2.readdir("./")).filter((stat) => stat.type === "dir");
    return (await Promise.all(childDirectories.map((childDirectory) => getWorkspaces({
      fs: fs2.chdir(childDirectory.path),
      depth: depth2 - 1,
      cwd: posixPath$1.join(cwd2, childDirectory.path)
    })))).flat();
  }
  return [
    {
      type: workspaceType,
      rootPath: cwd2
    }
  ];
}
getWorkspaces$1.getWorkspaces = getWorkspaces;
var getWorkspacePackagePaths$1 = {}, jsYaml$2 = {}, loader$3 = {}, common$e = {};
function isNothing$1(subject) {
  return typeof subject > "u" || subject === null;
}
function isObject$6(subject) {
  return typeof subject == "object" && subject !== null;
}
function toArray$2(sequence) {
  return Array.isArray(sequence) ? sequence : isNothing$1(sequence) ? [] : [sequence];
}
function extend$3(target, source2) {
  var index, length, key2, sourceKeys;
  if (source2)
    for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
      key2 = sourceKeys[index], target[key2] = source2[key2];
  return target;
}
function repeat$2(string, count2) {
  var result = "", cycle;
  for (cycle = 0; cycle < count2; cycle += 1)
    result += string;
  return result;
}
function isNegativeZero$1(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
common$e.isNothing = isNothing$1;
common$e.isObject = isObject$6;
common$e.toArray = toArray$2;
common$e.repeat = repeat$2;
common$e.isNegativeZero = isNegativeZero$1;
common$e.extend = extend$3;
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  return exception2.mark ? (exception2.mark.name && (where += 'in "' + exception2.mark.name + '" '), where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")", !compact && exception2.mark.snippet && (where += `

` + exception2.mark.snippet), message + " " + where) : message;
}
function YAMLException$9(reason, mark2) {
  Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = formatError(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
YAMLException$9.prototype = Object.create(Error.prototype);
YAMLException$9.prototype.constructor = YAMLException$9;
YAMLException$9.prototype.toString = function toString4(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception$1 = YAMLException$9, common$d = common$e;
function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
  var head = "", tail = "", maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  return position - lineStart > maxHalfLength && (head = " ... ", lineStart = position - maxHalfLength + head.length), lineEnd - position > maxHalfLength && (tail = " ...", lineEnd = position + maxHalfLength - tail.length), {
    str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max2) {
  return common$d.repeat(" ", max2 - string.length) + string;
}
function makeSnippet$1(mark2, options2) {
  if (options2 = Object.create(options2 || null), !mark2.buffer) return null;
  options2.maxLength || (options2.maxLength = 79), typeof options2.indent != "number" && (options2.indent = 1), typeof options2.linesBefore != "number" && (options2.linesBefore = 3), typeof options2.linesAfter != "number" && (options2.linesAfter = 2);
  for (var re = /\r?\n|\r|\0/g, lineStarts = [0], lineEnds = [], match3, foundLineNo = -1; match3 = re.exec(mark2.buffer); )
    lineEnds.push(match3.index), lineStarts.push(match3.index + match3[0].length), mark2.position <= match3.index && foundLineNo < 0 && (foundLineNo = lineStarts.length - 2);
  foundLineNo < 0 && (foundLineNo = lineStarts.length - 1);
  var result = "", i2, line3, lineNoLength = Math.min(mark2.line + options2.linesAfter, lineEnds.length).toString().length, maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options2.linesBefore && !(foundLineNo - i2 < 0); i2++)
    line3 = getLine(
      mark2.buffer,
      lineStarts[foundLineNo - i2],
      lineEnds[foundLineNo - i2],
      mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
      maxLineLength
    ), result = common$d.repeat(" ", options2.indent) + padStart((mark2.line - i2 + 1).toString(), lineNoLength) + " | " + line3.str + `
` + result;
  for (line3 = getLine(mark2.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark2.position, maxLineLength), result += common$d.repeat(" ", options2.indent) + padStart((mark2.line + 1).toString(), lineNoLength) + " | " + line3.str + `
`, result += common$d.repeat("-", options2.indent + lineNoLength + 3 + line3.pos) + `^
`, i2 = 1; i2 <= options2.linesAfter && !(foundLineNo + i2 >= lineEnds.length); i2++)
    line3 = getLine(
      mark2.buffer,
      lineStarts[foundLineNo + i2],
      lineEnds[foundLineNo + i2],
      mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
      maxLineLength
    ), result += common$d.repeat(" ", options2.indent) + padStart((mark2.line + i2 + 1).toString(), lineNoLength) + " | " + line3.str + `
`;
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet$1, YAMLException$8 = exception$1, TYPE_CONSTRUCTOR_OPTIONS$1 = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], YAML_NODE_KINDS$1 = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases$1(map2) {
  var result = {};
  return map2 !== null && Object.keys(map2).forEach(function(style) {
    map2[style].forEach(function(alias) {
      result[String(alias)] = style;
    });
  }), result;
}
function Type$w(tag, options2) {
  if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS$1.indexOf(name) === -1)
      throw new YAMLException$8('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
  }), this.options = options2, this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
    return !0;
  }, this.construct = options2.construct || function(data) {
    return data;
  }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.representName = options2.representName || null, this.defaultStyle = options2.defaultStyle || null, this.multi = options2.multi || !1, this.styleAliases = compileStyleAliases$1(options2.styleAliases || null), YAML_NODE_KINDS$1.indexOf(this.kind) === -1)
    throw new YAMLException$8('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var type$1 = Type$w, YAMLException$7 = exception$1, Type$v = type$1;
function compileList$1(schema2, name) {
  var result = [];
  return schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi && (newIndex = previousIndex);
    }), result[newIndex] = currentType;
  }), result;
}
function compileMap$1() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    type2.multi ? (result.multi[type2.kind].push(type2), result.multi.fallback.push(type2)) : result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
  }
  for (index = 0, length = arguments.length; index < length; index += 1)
    arguments[index].forEach(collectType);
  return result;
}
function Schema$7(definition) {
  return this.extend(definition);
}
Schema$7.prototype.extend = function extend2(definition) {
  var implicit = [], explicit = [];
  if (definition instanceof Type$v)
    explicit.push(definition);
  else if (Array.isArray(definition))
    explicit = explicit.concat(definition);
  else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit)))
    definition.implicit && (implicit = implicit.concat(definition.implicit)), definition.explicit && (explicit = explicit.concat(definition.explicit));
  else
    throw new YAMLException$7("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  implicit.forEach(function(type2) {
    if (!(type2 instanceof Type$v))
      throw new YAMLException$7("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (type2.loadKind && type2.loadKind !== "scalar")
      throw new YAMLException$7("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (type2.multi)
      throw new YAMLException$7("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), explicit.forEach(function(type2) {
    if (!(type2 instanceof Type$v))
      throw new YAMLException$7("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var result = Object.create(Schema$7.prototype);
  return result.implicit = (this.implicit || []).concat(implicit), result.explicit = (this.explicit || []).concat(explicit), result.compiledImplicit = compileList$1(result, "implicit"), result.compiledExplicit = compileList$1(result, "explicit"), result.compiledTypeMap = compileMap$1(result.compiledImplicit, result.compiledExplicit), result;
};
var schema$1 = Schema$7, Type$u = type$1, str$1 = new Type$u("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
}), Type$t = type$1, seq$1 = new Type$t("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
}), Type$s = type$1, map$2 = new Type$s("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
}), Schema$6 = schema$1, failsafe$1 = new Schema$6({
  explicit: [
    str$1,
    seq$1,
    map$2
  ]
}), Type$r = type$1;
function resolveYamlNull$1(data) {
  if (data === null) return !0;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull$1() {
  return null;
}
function isNull$1(object) {
  return object === null;
}
var _null$1 = new Type$r("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull$1,
  construct: constructYamlNull$1,
  predicate: isNull$1,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
}), Type$q = type$1;
function resolveYamlBoolean$1(data) {
  if (data === null) return !1;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean$1(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean$1(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool$1 = new Type$q("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean$1,
  construct: constructYamlBoolean$1,
  predicate: isBoolean$1,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), common$c = common$e, Type$p = type$1;
function isHexCode$1(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode$1(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode$1(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger$1(data) {
  if (data === null) return !1;
  var max2 = data.length, index = 0, hasDigits = !1, ch;
  if (!max2) return !1;
  if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
    if (index + 1 === max2) return !0;
    if (ch = data[++index], ch === "b") {
      for (index++; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (ch !== "0" && ch !== "1") return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      for (index++; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isHexCode$1(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      for (index++; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isOctCode$1(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return !1;
  for (; index < max2; index++)
    if (ch = data[index], ch !== "_") {
      if (!isDecCode$1(data.charCodeAt(index)))
        return !1;
      hasDigits = !0;
    }
  return !(!hasDigits || ch === "_");
}
function constructYamlInteger$1(data) {
  var value = data, sign2 = 1, ch;
  if (value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign2 * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign2 * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign2 * parseInt(value.slice(2), 8);
  }
  return sign2 * parseInt(value, 10);
}
function isInteger$1(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common$c.isNegativeZero(object);
}
var int$1 = new Type$p("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger$1,
  construct: constructYamlInteger$1,
  predicate: isInteger$1,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), common$b = common$e, Type$o = type$1, YAML_FLOAT_PATTERN$1 = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat$1(data) {
  return !(data === null || !YAML_FLOAT_PATTERN$1.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_");
}
function constructYamlFloat$1(data) {
  var value, sign2;
  return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : sign2 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT$1 = /^[-+]?[0-9]+e/;
function representYamlFloat$1(object, style) {
  var res;
  if (isNaN(object))
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (common$b.isNegativeZero(object))
    return "-0.0";
  return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT$1.test(res) ? res.replace("e", ".e") : res;
}
function isFloat$1(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$b.isNegativeZero(object));
}
var float$1 = new Type$o("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat$1,
  construct: constructYamlFloat$1,
  predicate: isFloat$1,
  represent: representYamlFloat$1,
  defaultStyle: "lowercase"
}), json$1 = failsafe$1.extend({
  implicit: [
    _null$1,
    bool$1,
    int$1,
    float$1
  ]
}), core$5 = json$1, Type$n = type$1, YAML_DATE_REGEXP$1 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), YAML_TIMESTAMP_REGEXP$1 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp$1(data) {
  return data === null ? !1 : YAML_DATE_REGEXP$1.exec(data) !== null || YAML_TIMESTAMP_REGEXP$1.exec(data) !== null;
}
function constructYamlTimestamp$1(data) {
  var match3, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  if (match3 = YAML_DATE_REGEXP$1.exec(data), match3 === null && (match3 = YAML_TIMESTAMP_REGEXP$1.exec(data)), match3 === null) throw new Error("Date resolve error");
  if (year = +match3[1], month = +match3[2] - 1, day = +match3[3], !match3[4])
    return new Date(Date.UTC(year, month, day));
  if (hour = +match3[4], minute = +match3[5], second = +match3[6], match3[7]) {
    for (fraction = match3[7].slice(0, 3); fraction.length < 3; )
      fraction += "0";
    fraction = +fraction;
  }
  return match3[9] && (tz_hour = +match3[10], tz_minute = +(match3[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match3[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
}
function representYamlTimestamp$1(object) {
  return object.toISOString();
}
var timestamp$2 = new Type$n("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp$1,
  construct: constructYamlTimestamp$1,
  instanceOf: Date,
  represent: representYamlTimestamp$1
}), Type$m = type$1;
function resolveYamlMerge$1(data) {
  return data === "<<" || data === null;
}
var merge$3 = new Type$m("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge$1
}), Type$l = type$1, BASE64_MAP$1 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function resolveYamlBinary$1(data) {
  if (data === null) return !1;
  var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP$1;
  for (idx = 0; idx < max2; idx++)
    if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
      if (code < 0) return !1;
      bitlen += 6;
    }
  return bitlen % 8 === 0;
}
function constructYamlBinary$1(data) {
  var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP$1, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++)
    idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
  return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), new Uint8Array(result);
}
function representYamlBinary$1(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP$1;
  for (idx = 0; idx < max2; idx++)
    idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
  return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
}
function isBinary$1(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary$2 = new Type$l("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary$1,
  construct: constructYamlBinary$1,
  predicate: isBinary$1,
  represent: representYamlBinary$1
}), Type$k = type$1, _hasOwnProperty$7 = Object.prototype.hasOwnProperty, _toString$5 = Object.prototype.toString;
function resolveYamlOmap$1(data) {
  if (data === null) return !0;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], pairHasKey = !1, _toString$5.call(pair) !== "[object Object]") return !1;
    for (pairKey in pair)
      if (_hasOwnProperty$7.call(pair, pairKey))
        if (!pairHasKey) pairHasKey = !0;
        else return !1;
    if (!pairHasKey) return !1;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return !1;
  }
  return !0;
}
function constructYamlOmap$1(data) {
  return data !== null ? data : [];
}
var omap$1 = new Type$k("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap$1,
  construct: constructYamlOmap$1
}), Type$j = type$1, _toString$4 = Object.prototype.toString;
function resolveYamlPairs$1(data) {
  if (data === null) return !0;
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], _toString$4.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return !0;
}
function constructYamlPairs$1(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
    pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
  return result;
}
var pairs$2 = new Type$j("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs$1,
  construct: constructYamlPairs$1
}), Type$i = type$1, _hasOwnProperty$6 = Object.prototype.hasOwnProperty;
function resolveYamlSet$1(data) {
  if (data === null) return !0;
  var key2, object = data;
  for (key2 in object)
    if (_hasOwnProperty$6.call(object, key2) && object[key2] !== null)
      return !1;
  return !0;
}
function constructYamlSet$1(data) {
  return data !== null ? data : {};
}
var set$1 = new Type$i("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet$1,
  construct: constructYamlSet$1
}), _default = core$5.extend({
  implicit: [
    timestamp$2,
    merge$3
  ],
  explicit: [
    binary$2,
    omap$1,
    pairs$2,
    set$1
  ]
}), common$a = common$e, YAMLException$6 = exception$1, makeSnippet = snippet, DEFAULT_SCHEMA$1 = _default, _hasOwnProperty$5 = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN$1 = 1, CONTEXT_FLOW_OUT$1 = 2, CONTEXT_BLOCK_IN$1 = 3, CONTEXT_BLOCK_OUT$1 = 4, CHOMPING_CLIP$1 = 1, CHOMPING_STRIP$1 = 2, CHOMPING_KEEP$1 = 3, PATTERN_NON_PRINTABLE$1 = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS$1 = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS$1 = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE$1 = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI$1 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class$1(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL$1(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE$1(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL$1(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR$1(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode$1(c2) {
  var lc;
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
}
function escapedHexLen$1(c2) {
  return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
}
function fromDecimalCode$1(c2) {
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
}
function simpleEscapeSequence$1(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint$1(c2) {
  return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck$1 = new Array(256), simpleEscapeMap$1 = new Array(256);
for (var i$1 = 0; i$1 < 256; i$1++)
  simpleEscapeCheck$1[i$1] = simpleEscapeSequence$1(i$1) ? 1 : 0, simpleEscapeMap$1[i$1] = simpleEscapeSequence$1(i$1);
function State$3(input2, options2) {
  this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_SCHEMA$1, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function generateError$1(state2, message) {
  var mark2 = {
    name: state2.filename,
    buffer: state2.input.slice(0, -1),
    // omit trailing \0
    position: state2.position,
    line: state2.line,
    column: state2.position - state2.lineStart
  };
  return mark2.snippet = makeSnippet(mark2), new YAMLException$6(message, mark2);
}
function throwError$2(state2, message) {
  throw generateError$1(state2, message);
}
function throwWarning$1(state2, message) {
  state2.onWarning && state2.onWarning.call(null, generateError$1(state2, message));
}
var directiveHandlers$1 = {
  YAML: function handleYamlDirective2(state2, name, args) {
    var match3, major, minor;
    state2.version !== null && throwError$2(state2, "duplication of %YAML directive"), args.length !== 1 && throwError$2(state2, "YAML directive accepts exactly one argument"), match3 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match3 === null && throwError$2(state2, "ill-formed argument of the YAML directive"), major = parseInt(match3[1], 10), minor = parseInt(match3[2], 10), major !== 1 && throwError$2(state2, "unacceptable YAML version of the document"), state2.version = args[0], state2.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning$1(state2, "unsupported YAML version of the document");
  },
  TAG: function handleTagDirective2(state2, name, args) {
    var handle, prefix;
    args.length !== 2 && throwError$2(state2, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE$1.test(handle) || throwError$2(state2, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty$5.call(state2.tagMap, handle) && throwError$2(state2, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI$1.test(prefix) || throwError$2(state2, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      prefix = decodeURIComponent(prefix);
    } catch {
      throwError$2(state2, "tag prefix is malformed: " + prefix);
    }
    state2.tagMap[handle] = prefix;
  }
};
function captureSegment$1(state2, start, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start < end2) {
    if (_result = state2.input.slice(start, end2), checkJson)
      for (_position = 0, _length = _result.length; _position < _length; _position += 1)
        _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError$2(state2, "expected valid JSON character");
    else PATTERN_NON_PRINTABLE$1.test(_result) && throwError$2(state2, "the stream contains non-printable characters");
    state2.result += _result;
  }
}
function mergeMappings$1(state2, destination, source2, overridableKeys) {
  var sourceKeys, key2, index, quantity;
  for (common$a.isObject(source2) || throwError$2(state2, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
    key2 = sourceKeys[index], _hasOwnProperty$5.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
}
function storeMappingPair$1(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode))
    for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
      Array.isArray(keyNode[index]) && throwError$2(state2, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class$1(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
  if (typeof keyNode == "object" && _class$1(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
    if (Array.isArray(valueNode))
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
        mergeMappings$1(state2, _result, valueNode[index], overridableKeys);
    else
      mergeMappings$1(state2, _result, valueNode, overridableKeys);
  else
    !state2.json && !_hasOwnProperty$5.call(overridableKeys, keyNode) && _hasOwnProperty$5.call(_result, keyNode) && (state2.line = startLine || state2.line, state2.lineStart = startLineStart || state2.lineStart, state2.position = startPos || state2.position, throwError$2(state2, "duplicated mapping key")), keyNode === "__proto__" ? Object.defineProperty(_result, keyNode, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: valueNode
    }) : _result[keyNode] = valueNode, delete overridableKeys[keyNode];
  return _result;
}
function readLineBreak$1(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position), ch === 10 ? state2.position++ : ch === 13 ? (state2.position++, state2.input.charCodeAt(state2.position) === 10 && state2.position++) : throwError$2(state2, "a line break is expected"), state2.line += 1, state2.lineStart = state2.position, state2.firstTabInLine = -1;
}
function skipSeparationSpace$1(state2, allowComments, checkIndent) {
  for (var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position); ch !== 0; ) {
    for (; is_WHITE_SPACE$1(ch); )
      ch === 9 && state2.firstTabInLine === -1 && (state2.firstTabInLine = state2.position), ch = state2.input.charCodeAt(++state2.position);
    if (allowComments && ch === 35)
      do
        ch = state2.input.charCodeAt(++state2.position);
      while (ch !== 10 && ch !== 13 && ch !== 0);
    if (is_EOL$1(ch))
      for (readLineBreak$1(state2), ch = state2.input.charCodeAt(state2.position), lineBreaks++, state2.lineIndent = 0; ch === 32; )
        state2.lineIndent++, ch = state2.input.charCodeAt(++state2.position);
    else
      break;
  }
  return checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent && throwWarning$1(state2, "deficient indentation"), lineBreaks;
}
function testDocumentSeparator$1(state2) {
  var _position = state2.position, ch;
  return ch = state2.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2) && (_position += 3, ch = state2.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL$1(ch)));
}
function writeFoldedLines$1(state2, count2) {
  count2 === 1 ? state2.result += " " : count2 > 1 && (state2.result += common$a.repeat(`
`, count2 - 1));
}
function readPlainScalar$1(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  if (ch = state2.input.charCodeAt(state2.position), is_WS_OR_EOL$1(ch) || is_FLOW_INDICATOR$1(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL$1(following) || withinFlowCollection && is_FLOW_INDICATOR$1(following)))
    return !1;
  for (state2.kind = "scalar", state2.result = "", captureStart = captureEnd = state2.position, hasPendingContent = !1; ch !== 0; ) {
    if (ch === 58) {
      if (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL$1(following) || withinFlowCollection && is_FLOW_INDICATOR$1(following))
        break;
    } else if (ch === 35) {
      if (preceding = state2.input.charCodeAt(state2.position - 1), is_WS_OR_EOL$1(preceding))
        break;
    } else {
      if (state2.position === state2.lineStart && testDocumentSeparator$1(state2) || withinFlowCollection && is_FLOW_INDICATOR$1(ch))
        break;
      if (is_EOL$1(ch))
        if (_line = state2.line, _lineStart = state2.lineStart, _lineIndent = state2.lineIndent, skipSeparationSpace$1(state2, !1, -1), state2.lineIndent >= nodeIndent) {
          hasPendingContent = !0, ch = state2.input.charCodeAt(state2.position);
          continue;
        } else {
          state2.position = captureEnd, state2.line = _line, state2.lineStart = _lineStart, state2.lineIndent = _lineIndent;
          break;
        }
    }
    hasPendingContent && (captureSegment$1(state2, captureStart, captureEnd, !1), writeFoldedLines$1(state2, state2.line - _line), captureStart = captureEnd = state2.position, hasPendingContent = !1), is_WHITE_SPACE$1(ch) || (captureEnd = state2.position + 1), ch = state2.input.charCodeAt(++state2.position);
  }
  return captureSegment$1(state2, captureStart, captureEnd, !1), state2.result ? !0 : (state2.kind = _kind, state2.result = _result, !1);
}
function readSingleQuotedScalar$1(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 39)
    return !1;
  for (state2.kind = "scalar", state2.result = "", state2.position++, captureStart = captureEnd = state2.position; (ch = state2.input.charCodeAt(state2.position)) !== 0; )
    if (ch === 39)
      if (captureSegment$1(state2, captureStart, state2.position, !0), ch = state2.input.charCodeAt(++state2.position), ch === 39)
        captureStart = state2.position, state2.position++, captureEnd = state2.position;
      else
        return !0;
    else is_EOL$1(ch) ? (captureSegment$1(state2, captureStart, captureEnd, !0), writeFoldedLines$1(state2, skipSeparationSpace$1(state2, !1, nodeIndent)), captureStart = captureEnd = state2.position) : state2.position === state2.lineStart && testDocumentSeparator$1(state2) ? throwError$2(state2, "unexpected end of the document within a single quoted scalar") : (state2.position++, captureEnd = state2.position);
  throwError$2(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar$1(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 34)
    return !1;
  for (state2.kind = "scalar", state2.result = "", state2.position++, captureStart = captureEnd = state2.position; (ch = state2.input.charCodeAt(state2.position)) !== 0; ) {
    if (ch === 34)
      return captureSegment$1(state2, captureStart, state2.position, !0), state2.position++, !0;
    if (ch === 92) {
      if (captureSegment$1(state2, captureStart, state2.position, !0), ch = state2.input.charCodeAt(++state2.position), is_EOL$1(ch))
        skipSeparationSpace$1(state2, !1, nodeIndent);
      else if (ch < 256 && simpleEscapeCheck$1[ch])
        state2.result += simpleEscapeMap$1[ch], state2.position++;
      else if ((tmp2 = escapedHexLen$1(ch)) > 0) {
        for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
          ch = state2.input.charCodeAt(++state2.position), (tmp2 = fromHexCode$1(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError$2(state2, "expected hexadecimal character");
        state2.result += charFromCodepoint$1(hexResult), state2.position++;
      } else
        throwError$2(state2, "unknown escape sequence");
      captureStart = captureEnd = state2.position;
    } else is_EOL$1(ch) ? (captureSegment$1(state2, captureStart, captureEnd, !0), writeFoldedLines$1(state2, skipSeparationSpace$1(state2, !1, nodeIndent)), captureStart = captureEnd = state2.position) : state2.position === state2.lineStart && testDocumentSeparator$1(state2) ? throwError$2(state2, "unexpected end of the document within a double quoted scalar") : (state2.position++, captureEnd = state2.position);
  }
  throwError$2(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection$1(state2, nodeIndent) {
  var readNext = !0, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch === 91)
    terminator = 93, isMapping = !1, _result = [];
  else if (ch === 123)
    terminator = 125, isMapping = !0, _result = {};
  else
    return !1;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(++state2.position); ch !== 0; ) {
    if (skipSeparationSpace$1(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), ch === terminator)
      return state2.position++, state2.tag = _tag, state2.anchor = _anchor, state2.kind = isMapping ? "mapping" : "sequence", state2.result = _result, !0;
    readNext ? ch === 44 && throwError$2(state2, "expected the node content, but found ','") : throwError$2(state2, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL$1(following) && (isPair = isExplicitPair = !0, state2.position++, skipSeparationSpace$1(state2, !0, nodeIndent))), _line = state2.line, _lineStart = state2.lineStart, _pos = state2.position, composeNode$1(state2, nodeIndent, CONTEXT_FLOW_IN$1, !1, !0), keyTag = state2.tag, keyNode = state2.result, skipSeparationSpace$1(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), (isExplicitPair || state2.line === _line) && ch === 58 && (isPair = !0, ch = state2.input.charCodeAt(++state2.position), skipSeparationSpace$1(state2, !0, nodeIndent), composeNode$1(state2, nodeIndent, CONTEXT_FLOW_IN$1, !1, !0), valueNode = state2.result), isMapping ? storeMappingPair$1(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos) : isPair ? _result.push(storeMappingPair$1(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos)) : _result.push(keyNode), skipSeparationSpace$1(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), ch === 44 ? (readNext = !0, ch = state2.input.charCodeAt(++state2.position)) : readNext = !1;
  }
  throwError$2(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar$1(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP$1, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch === 124)
    folding = !1;
  else if (ch === 62)
    folding = !0;
  else
    return !1;
  for (state2.kind = "scalar", state2.result = ""; ch !== 0; )
    if (ch = state2.input.charCodeAt(++state2.position), ch === 43 || ch === 45)
      CHOMPING_CLIP$1 === chomping ? chomping = ch === 43 ? CHOMPING_KEEP$1 : CHOMPING_STRIP$1 : throwError$2(state2, "repeat of a chomping mode identifier");
    else if ((tmp2 = fromDecimalCode$1(ch)) >= 0)
      tmp2 === 0 ? throwError$2(state2, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError$2(state2, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
    else
      break;
  if (is_WHITE_SPACE$1(ch)) {
    do
      ch = state2.input.charCodeAt(++state2.position);
    while (is_WHITE_SPACE$1(ch));
    if (ch === 35)
      do
        ch = state2.input.charCodeAt(++state2.position);
      while (!is_EOL$1(ch) && ch !== 0);
  }
  for (; ch !== 0; ) {
    for (readLineBreak$1(state2), state2.lineIndent = 0, ch = state2.input.charCodeAt(state2.position); (!detectedIndent || state2.lineIndent < textIndent) && ch === 32; )
      state2.lineIndent++, ch = state2.input.charCodeAt(++state2.position);
    if (!detectedIndent && state2.lineIndent > textIndent && (textIndent = state2.lineIndent), is_EOL$1(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      chomping === CHOMPING_KEEP$1 ? state2.result += common$a.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP$1 && didReadContent && (state2.result += `
`);
      break;
    }
    for (folding ? is_WHITE_SPACE$1(ch) ? (atMoreIndented = !0, state2.result += common$a.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state2.result += common$a.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state2.result += " ") : state2.result += common$a.repeat(`
`, emptyLines) : state2.result += common$a.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state2.position; !is_EOL$1(ch) && ch !== 0; )
      ch = state2.input.charCodeAt(++state2.position);
    captureSegment$1(state2, captureStart, state2.position, !1);
  }
  return !0;
}
function readBlockSequence$1(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = !1, ch;
  if (state2.firstTabInLine !== -1) return !1;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(state2.position); ch !== 0 && (state2.firstTabInLine !== -1 && (state2.position = state2.firstTabInLine, throwError$2(state2, "tab characters must not be used in indentation")), !(ch !== 45 || (following = state2.input.charCodeAt(state2.position + 1), !is_WS_OR_EOL$1(following)))); ) {
    if (detected = !0, state2.position++, skipSeparationSpace$1(state2, !0, -1) && state2.lineIndent <= nodeIndent) {
      _result.push(null), ch = state2.input.charCodeAt(state2.position);
      continue;
    }
    if (_line = state2.line, composeNode$1(state2, nodeIndent, CONTEXT_BLOCK_IN$1, !1, !0), _result.push(state2.result), skipSeparationSpace$1(state2, !0, -1), ch = state2.input.charCodeAt(state2.position), (state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0)
      throwError$2(state2, "bad indentation of a sequence entry");
    else if (state2.lineIndent < nodeIndent)
      break;
  }
  return detected ? (state2.tag = _tag, state2.anchor = _anchor, state2.kind = "sequence", state2.result = _result, !0) : !1;
}
function readBlockMapping$1(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
  if (state2.firstTabInLine !== -1) return !1;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(state2.position); ch !== 0; ) {
    if (!atExplicitKey && state2.firstTabInLine !== -1 && (state2.position = state2.firstTabInLine, throwError$2(state2, "tab characters must not be used in indentation")), following = state2.input.charCodeAt(state2.position + 1), _line = state2.line, (ch === 63 || ch === 58) && is_WS_OR_EOL$1(following))
      ch === 63 ? (atExplicitKey && (storeMappingPair$1(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError$2(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state2.position += 1, ch = following;
    else {
      if (_keyLine = state2.line, _keyLineStart = state2.lineStart, _keyPos = state2.position, !composeNode$1(state2, flowIndent, CONTEXT_FLOW_OUT$1, !1, !0))
        break;
      if (state2.line === _line) {
        for (ch = state2.input.charCodeAt(state2.position); is_WHITE_SPACE$1(ch); )
          ch = state2.input.charCodeAt(++state2.position);
        if (ch === 58)
          ch = state2.input.charCodeAt(++state2.position), is_WS_OR_EOL$1(ch) || throwError$2(state2, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair$1(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state2.tag, keyNode = state2.result;
        else if (detected)
          throwError$2(state2, "can not read an implicit mapping pair; a colon is missed");
        else
          return state2.tag = _tag, state2.anchor = _anchor, !0;
      } else if (detected)
        throwError$2(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return state2.tag = _tag, state2.anchor = _anchor, !0;
    }
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && (atExplicitKey && (_keyLine = state2.line, _keyLineStart = state2.lineStart, _keyPos = state2.position), composeNode$1(state2, nodeIndent, CONTEXT_BLOCK_OUT$1, !0, allowCompact) && (atExplicitKey ? keyNode = state2.result : valueNode = state2.result), atExplicitKey || (storeMappingPair$1(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), skipSeparationSpace$1(state2, !0, -1), ch = state2.input.charCodeAt(state2.position)), (state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0)
      throwError$2(state2, "bad indentation of a mapping entry");
    else if (state2.lineIndent < nodeIndent)
      break;
  }
  return atExplicitKey && storeMappingPair$1(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), detected && (state2.tag = _tag, state2.anchor = _anchor, state2.kind = "mapping", state2.result = _result), detected;
}
function readTagProperty$1(state2) {
  var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 33) return !1;
  if (state2.tag !== null && throwError$2(state2, "duplication of a tag property"), ch = state2.input.charCodeAt(++state2.position), ch === 60 ? (isVerbatim = !0, ch = state2.input.charCodeAt(++state2.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state2.input.charCodeAt(++state2.position)) : tagHandle = "!", _position = state2.position, isVerbatim) {
    do
      ch = state2.input.charCodeAt(++state2.position);
    while (ch !== 0 && ch !== 62);
    state2.position < state2.length ? (tagName = state2.input.slice(_position, state2.position), ch = state2.input.charCodeAt(++state2.position)) : throwError$2(state2, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; ch !== 0 && !is_WS_OR_EOL$1(ch); )
      ch === 33 && (isNamed ? throwError$2(state2, "tag suffix cannot contain exclamation marks") : (tagHandle = state2.input.slice(_position - 1, state2.position + 1), PATTERN_TAG_HANDLE$1.test(tagHandle) || throwError$2(state2, "named tag handle cannot contain such characters"), isNamed = !0, _position = state2.position + 1)), ch = state2.input.charCodeAt(++state2.position);
    tagName = state2.input.slice(_position, state2.position), PATTERN_FLOW_INDICATORS$1.test(tagName) && throwError$2(state2, "tag suffix cannot contain flow indicator characters");
  }
  tagName && !PATTERN_TAG_URI$1.test(tagName) && throwError$2(state2, "tag name cannot contain such characters: " + tagName);
  try {
    tagName = decodeURIComponent(tagName);
  } catch {
    throwError$2(state2, "tag name is malformed: " + tagName);
  }
  return isVerbatim ? state2.tag = tagName : _hasOwnProperty$5.call(state2.tagMap, tagHandle) ? state2.tag = state2.tagMap[tagHandle] + tagName : tagHandle === "!" ? state2.tag = "!" + tagName : tagHandle === "!!" ? state2.tag = "tag:yaml.org,2002:" + tagName : throwError$2(state2, 'undeclared tag handle "' + tagHandle + '"'), !0;
}
function readAnchorProperty$1(state2) {
  var _position, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 38) return !1;
  for (state2.anchor !== null && throwError$2(state2, "duplication of an anchor property"), ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL$1(ch) && !is_FLOW_INDICATOR$1(ch); )
    ch = state2.input.charCodeAt(++state2.position);
  return state2.position === _position && throwError$2(state2, "name of an anchor node must contain at least one character"), state2.anchor = state2.input.slice(_position, state2.position), !0;
}
function readAlias$1(state2) {
  var _position, alias, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 42) return !1;
  for (ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL$1(ch) && !is_FLOW_INDICATOR$1(ch); )
    ch = state2.input.charCodeAt(++state2.position);
  return state2.position === _position && throwError$2(state2, "name of an alias node must contain at least one character"), alias = state2.input.slice(_position, state2.position), _hasOwnProperty$5.call(state2.anchorMap, alias) || throwError$2(state2, 'unidentified alias "' + alias + '"'), state2.result = state2.anchorMap[alias], skipSeparationSpace$1(state2, !0, -1), !0;
}
function composeNode$1(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state2.listener !== null && state2.listener("open", state2), state2.tag = null, state2.anchor = null, state2.kind = null, state2.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT$1 === nodeContext || CONTEXT_BLOCK_IN$1 === nodeContext, allowToSeek && skipSeparationSpace$1(state2, !0, -1) && (atNewLine = !0, state2.lineIndent > parentIndent ? indentStatus = 1 : state2.lineIndent === parentIndent ? indentStatus = 0 : state2.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
    for (; readTagProperty$1(state2) || readAnchorProperty$1(state2); )
      skipSeparationSpace$1(state2, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state2.lineIndent > parentIndent ? indentStatus = 1 : state2.lineIndent === parentIndent ? indentStatus = 0 : state2.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
  if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT$1 === nodeContext) && (CONTEXT_FLOW_IN$1 === nodeContext || CONTEXT_FLOW_OUT$1 === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state2.position - state2.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence$1(state2, blockIndent) || readBlockMapping$1(state2, blockIndent, flowIndent)) || readFlowCollection$1(state2, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar$1(state2, flowIndent) || readSingleQuotedScalar$1(state2, flowIndent) || readDoubleQuotedScalar$1(state2, flowIndent) ? hasContent = !0 : readAlias$1(state2) ? (hasContent = !0, (state2.tag !== null || state2.anchor !== null) && throwError$2(state2, "alias node should not have any properties")) : readPlainScalar$1(state2, flowIndent, CONTEXT_FLOW_IN$1 === nodeContext) && (hasContent = !0, state2.tag === null && (state2.tag = "?")), state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence$1(state2, blockIndent))), state2.tag === null)
    state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result);
  else if (state2.tag === "?") {
    for (state2.result !== null && state2.kind !== "scalar" && throwError$2(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"'), typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
      if (type2 = state2.implicitTypes[typeIndex], type2.resolve(state2.result)) {
        state2.result = type2.construct(state2.result), state2.tag = type2.tag, state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result);
        break;
      }
  } else if (state2.tag !== "!") {
    if (_hasOwnProperty$5.call(state2.typeMap[state2.kind || "fallback"], state2.tag))
      type2 = state2.typeMap[state2.kind || "fallback"][state2.tag];
    else
      for (type2 = null, typeList = state2.typeMap.multi[state2.kind || "fallback"], typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1)
        if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
    type2 || throwError$2(state2, "unknown tag !<" + state2.tag + ">"), state2.result !== null && type2.kind !== state2.kind && throwError$2(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"'), type2.resolve(state2.result, state2.tag) ? (state2.result = type2.construct(state2.result, state2.tag), state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result)) : throwError$2(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
  }
  return state2.listener !== null && state2.listener("close", state2), state2.tag !== null || state2.anchor !== null || hasContent;
}
function readDocument$1(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
  for (state2.version = null, state2.checkLineBreaks = state2.legacy, state2.tagMap = /* @__PURE__ */ Object.create(null), state2.anchorMap = /* @__PURE__ */ Object.create(null); (ch = state2.input.charCodeAt(state2.position)) !== 0 && (skipSeparationSpace$1(state2, !0, -1), ch = state2.input.charCodeAt(state2.position), !(state2.lineIndent > 0 || ch !== 37)); ) {
    for (hasDirectives = !0, ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL$1(ch); )
      ch = state2.input.charCodeAt(++state2.position);
    for (directiveName = state2.input.slice(_position, state2.position), directiveArgs = [], directiveName.length < 1 && throwError$2(state2, "directive name must not be less than one character in length"); ch !== 0; ) {
      for (; is_WHITE_SPACE$1(ch); )
        ch = state2.input.charCodeAt(++state2.position);
      if (ch === 35) {
        do
          ch = state2.input.charCodeAt(++state2.position);
        while (ch !== 0 && !is_EOL$1(ch));
        break;
      }
      if (is_EOL$1(ch)) break;
      for (_position = state2.position; ch !== 0 && !is_WS_OR_EOL$1(ch); )
        ch = state2.input.charCodeAt(++state2.position);
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    ch !== 0 && readLineBreak$1(state2), _hasOwnProperty$5.call(directiveHandlers$1, directiveName) ? directiveHandlers$1[directiveName](state2, directiveName, directiveArgs) : throwWarning$1(state2, 'unknown document directive "' + directiveName + '"');
  }
  if (skipSeparationSpace$1(state2, !0, -1), state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45 ? (state2.position += 3, skipSeparationSpace$1(state2, !0, -1)) : hasDirectives && throwError$2(state2, "directives end mark is expected"), composeNode$1(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT$1, !1, !0), skipSeparationSpace$1(state2, !0, -1), state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS$1.test(state2.input.slice(documentStart, state2.position)) && throwWarning$1(state2, "non-ASCII line breaks are interpreted as content"), state2.documents.push(state2.result), state2.position === state2.lineStart && testDocumentSeparator$1(state2)) {
    state2.input.charCodeAt(state2.position) === 46 && (state2.position += 3, skipSeparationSpace$1(state2, !0, -1));
    return;
  }
  if (state2.position < state2.length - 1)
    throwError$2(state2, "end of the stream or a document separator is expected");
  else
    return;
}
function loadDocuments$1(input2, options2) {
  input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
  var state2 = new State$3(input2, options2), nullpos = input2.indexOf("\0");
  for (nullpos !== -1 && (state2.position = nullpos, throwError$2(state2, "null byte is not allowed in input")), state2.input += "\0"; state2.input.charCodeAt(state2.position) === 32; )
    state2.lineIndent += 1, state2.position += 1;
  for (; state2.position < state2.length - 1; )
    readDocument$1(state2);
  return state2.documents;
}
function loadAll$1(input2, iterator2, options2) {
  iterator2 !== null && typeof iterator2 == "object" && typeof options2 > "u" && (options2 = iterator2, iterator2 = null);
  var documents = loadDocuments$1(input2, options2);
  if (typeof iterator2 != "function")
    return documents;
  for (var index = 0, length = documents.length; index < length; index += 1)
    iterator2(documents[index]);
}
function load$1(input2, options2) {
  var documents = loadDocuments$1(input2, options2);
  if (documents.length !== 0) {
    if (documents.length === 1)
      return documents[0];
    throw new YAMLException$6("expected a single document in the stream, but found more");
  }
}
loader$3.loadAll = loadAll$1;
loader$3.load = load$1;
var dumper$3 = {}, common$9 = common$e, YAMLException$5 = exception$1, DEFAULT_SCHEMA = _default, _toString$3 = Object.prototype.toString, _hasOwnProperty$4 = Object.prototype.hasOwnProperty, CHAR_BOM = 65279, CHAR_TAB$1 = 9, CHAR_LINE_FEED$1 = 10, CHAR_CARRIAGE_RETURN$1 = 13, CHAR_SPACE$1 = 32, CHAR_EXCLAMATION$1 = 33, CHAR_DOUBLE_QUOTE$2 = 34, CHAR_SHARP$1 = 35, CHAR_PERCENT$1 = 37, CHAR_AMPERSAND$1 = 38, CHAR_SINGLE_QUOTE$2 = 39, CHAR_ASTERISK$2 = 42, CHAR_COMMA$3 = 44, CHAR_MINUS$1 = 45, CHAR_COLON$1 = 58, CHAR_EQUALS$1 = 61, CHAR_GREATER_THAN$1 = 62, CHAR_QUESTION$1 = 63, CHAR_COMMERCIAL_AT$1 = 64, CHAR_LEFT_SQUARE_BRACKET$3 = 91, CHAR_RIGHT_SQUARE_BRACKET$3 = 93, CHAR_GRAVE_ACCENT$1 = 96, CHAR_LEFT_CURLY_BRACKET$1 = 123, CHAR_VERTICAL_LINE$1 = 124, CHAR_RIGHT_CURLY_BRACKET$1 = 125, ESCAPE_SEQUENCES$1 = {};
ESCAPE_SEQUENCES$1[0] = "\\0";
ESCAPE_SEQUENCES$1[7] = "\\a";
ESCAPE_SEQUENCES$1[8] = "\\b";
ESCAPE_SEQUENCES$1[9] = "\\t";
ESCAPE_SEQUENCES$1[10] = "\\n";
ESCAPE_SEQUENCES$1[11] = "\\v";
ESCAPE_SEQUENCES$1[12] = "\\f";
ESCAPE_SEQUENCES$1[13] = "\\r";
ESCAPE_SEQUENCES$1[27] = "\\e";
ESCAPE_SEQUENCES$1[34] = '\\"';
ESCAPE_SEQUENCES$1[92] = "\\\\";
ESCAPE_SEQUENCES$1[133] = "\\N";
ESCAPE_SEQUENCES$1[160] = "\\_";
ESCAPE_SEQUENCES$1[8232] = "\\L";
ESCAPE_SEQUENCES$1[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX$1 = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap$1(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
    tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty$4.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
  return result;
}
function encodeHex$1(character) {
  var string, handle, length;
  if (string = character.toString(16).toUpperCase(), character <= 255)
    handle = "x", length = 2;
  else if (character <= 65535)
    handle = "u", length = 4;
  else if (character <= 4294967295)
    handle = "U", length = 8;
  else
    throw new YAMLException$5("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + handle + common$9.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State$2(options2) {
  this.schema = options2.schema || DEFAULT_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common$9.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap$1(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.quotingType = options2.quotingType === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE, this.forceQuotes = options2.forceQuotes || !1, this.replacer = typeof options2.replacer == "function" ? options2.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function indentString$1(string, spaces) {
  for (var ind = common$9.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
    next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
  return result;
}
function generateNextLine$1(state2, level) {
  return `
` + common$9.repeat(" ", state2.indent * level);
}
function testImplicitResolving$1(state2, str2) {
  var index, length, type2;
  for (index = 0, length = state2.implicitTypes.length; index < length; index += 1)
    if (type2 = state2.implicitTypes[index], type2.resolve(str2))
      return !0;
  return !1;
}
function isWhitespace$1(c2) {
  return c2 === CHAR_SPACE$1 || c2 === CHAR_TAB$1;
}
function isPrintable$1(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
}
function isNsCharOrWhitespace(c2) {
  return isPrintable$1(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN$1 && c2 !== CHAR_LINE_FEED$1;
}
function isPlainSafe$1(c2, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2), cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace$1(c2);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA$3 && c2 !== CHAR_LEFT_SQUARE_BRACKET$3 && c2 !== CHAR_RIGHT_SQUARE_BRACKET$3 && c2 !== CHAR_LEFT_CURLY_BRACKET$1 && c2 !== CHAR_RIGHT_CURLY_BRACKET$1) && c2 !== CHAR_SHARP$1 && !(prev === CHAR_COLON$1 && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace$1(prev) && c2 === CHAR_SHARP$1 || prev === CHAR_COLON$1 && cIsNsChar
  );
}
function isPlainSafeFirst$1(c2) {
  return isPrintable$1(c2) && c2 !== CHAR_BOM && !isWhitespace$1(c2) && c2 !== CHAR_MINUS$1 && c2 !== CHAR_QUESTION$1 && c2 !== CHAR_COLON$1 && c2 !== CHAR_COMMA$3 && c2 !== CHAR_LEFT_SQUARE_BRACKET$3 && c2 !== CHAR_RIGHT_SQUARE_BRACKET$3 && c2 !== CHAR_LEFT_CURLY_BRACKET$1 && c2 !== CHAR_RIGHT_CURLY_BRACKET$1 && c2 !== CHAR_SHARP$1 && c2 !== CHAR_AMPERSAND$1 && c2 !== CHAR_ASTERISK$2 && c2 !== CHAR_EXCLAMATION$1 && c2 !== CHAR_VERTICAL_LINE$1 && c2 !== CHAR_EQUALS$1 && c2 !== CHAR_GREATER_THAN$1 && c2 !== CHAR_SINGLE_QUOTE$2 && c2 !== CHAR_DOUBLE_QUOTE$2 && c2 !== CHAR_PERCENT$1 && c2 !== CHAR_COMMERCIAL_AT$1 && c2 !== CHAR_GRAVE_ACCENT$1;
}
function isPlainSafeLast(c2) {
  return !isWhitespace$1(c2) && c2 !== CHAR_COLON$1;
}
function codePointAt(string, pos2) {
  var first2 = string.charCodeAt(pos2), second;
  return first2 >= 55296 && first2 <= 56319 && pos2 + 1 < string.length && (second = string.charCodeAt(pos2 + 1), second >= 56320 && second <= 57343) ? (first2 - 55296) * 1024 + second - 56320 + 65536 : first2;
}
function needIndentIndicator$1(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN$1 = 1, STYLE_SINGLE$1 = 2, STYLE_LITERAL$1 = 3, STYLE_FOLDED$1 = 4, STYLE_DOUBLE$1 = 5;
function chooseScalarStyle$1(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2, char = 0, prevChar = null, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst$1(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes)
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      if (char = codePointAt(string, i2), !isPrintable$1(char))
        return STYLE_DOUBLE$1;
      plain = plain && isPlainSafe$1(char, prevChar, inblock), prevChar = char;
    }
  else {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      if (char = codePointAt(string, i2), char === CHAR_LINE_FEED$1)
        hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
        i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i2);
      else if (!isPrintable$1(char))
        return STYLE_DOUBLE$1;
      plain = plain && isPlainSafe$1(char, prevChar, inblock), prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
  }
  return !hasLineBreak && !hasFoldableLine ? plain && !forceQuotes && !testAmbiguousType(string) ? STYLE_PLAIN$1 : quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE$1 : STYLE_SINGLE$1 : indentPerLevel > 9 && needIndentIndicator$1(string) ? STYLE_DOUBLE$1 : forceQuotes ? quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE$1 : STYLE_SINGLE$1 : hasFoldableLine ? STYLE_FOLDED$1 : STYLE_LITERAL$1;
}
function writeScalar$1(state2, string, level, iskey, inblock) {
  state2.dump = function() {
    if (string.length === 0)
      return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    if (!state2.noCompatMode && (DEPRECATED_BOOLEANS_SYNTAX$1.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)))
      return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
    var indent = state2.indent * Math.max(1, level), lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent), singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving$1(state2, string2);
    }
    switch (chooseScalarStyle$1(
      string,
      singleLineOnly,
      state2.indent,
      lineWidth,
      testAmbiguity,
      state2.quotingType,
      state2.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN$1:
        return string;
      case STYLE_SINGLE$1:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL$1:
        return "|" + blockHeader$1(string, state2.indent) + dropEndingNewline$1(indentString$1(string, indent));
      case STYLE_FOLDED$1:
        return ">" + blockHeader$1(string, state2.indent) + dropEndingNewline$1(indentString$1(foldString$1(string, lineWidth), indent));
      case STYLE_DOUBLE$1:
        return '"' + escapeString$1(string) + '"';
      default:
        throw new YAMLException$5("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader$1(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator$1(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + `
`;
}
function dropEndingNewline$1(string) {
  return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
}
function foldString$1(string, width) {
  for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
    var nextLF = string.indexOf(`
`);
    return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine$1(string.slice(0, nextLF), width);
  }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match3; match3 = lineRe.exec(string); ) {
    var prefix = match3[1], line3 = match3[2];
    moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine$1(line3, width), prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine$1(line3, width) {
  if (line3 === "" || line3[0] === " ") return line3;
  for (var breakRe = / [^ ]/g, match3, start = 0, end2, curr = 0, next = 0, result = ""; match3 = breakRe.exec(line3); )
    next = match3.index, next - start > width && (end2 = curr > start ? curr : next, result += `
` + line3.slice(start, end2), start = end2 + 1), curr = next;
  return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
}
function escapeString$1(string) {
  for (var result = "", char = 0, escapeSeq, i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++)
    char = codePointAt(string, i2), escapeSeq = ESCAPE_SEQUENCES$1[char], !escapeSeq && isPrintable$1(char) ? (result += string[i2], char >= 65536 && (result += string[i2 + 1])) : result += escapeSeq || encodeHex$1(char);
  return result;
}
function writeFlowSequence$1(state2, level, object) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1)
    value = object[index], state2.replacer && (value = state2.replacer.call(object, String(index), value)), (writeNode$1(state2, level, value, !1, !1) || typeof value > "u" && writeNode$1(state2, level, null, !1, !1)) && (_result !== "" && (_result += "," + (state2.condenseFlow ? "" : " ")), _result += state2.dump);
  state2.tag = _tag, state2.dump = "[" + _result + "]";
}
function writeBlockSequence$1(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1)
    value = object[index], state2.replacer && (value = state2.replacer.call(object, String(index), value)), (writeNode$1(state2, level + 1, value, !0, !0, !1, !0) || typeof value > "u" && writeNode$1(state2, level + 1, null, !0, !0, !1, !0)) && ((!compact || _result !== "") && (_result += generateNextLine$1(state2, level)), state2.dump && CHAR_LINE_FEED$1 === state2.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state2.dump);
  state2.tag = _tag, state2.dump = _result || "[]";
}
function writeFlowMapping$1(state2, level, object) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1)
    pairBuffer = "", _result !== "" && (pairBuffer += ", "), state2.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], state2.replacer && (objectValue = state2.replacer.call(object, objectKey, objectValue)), writeNode$1(state2, level, objectKey, !1, !1) && (state2.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " "), writeNode$1(state2, level, objectValue, !1, !1) && (pairBuffer += state2.dump, _result += pairBuffer));
  state2.tag = _tag, state2.dump = "{" + _result + "}";
}
function writeBlockMapping$1(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state2.sortKeys === !0)
    objectKeyList.sort();
  else if (typeof state2.sortKeys == "function")
    objectKeyList.sort(state2.sortKeys);
  else if (state2.sortKeys)
    throw new YAMLException$5("sortKeys must be a boolean or a function");
  for (index = 0, length = objectKeyList.length; index < length; index += 1)
    pairBuffer = "", (!compact || _result !== "") && (pairBuffer += generateNextLine$1(state2, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], state2.replacer && (objectValue = state2.replacer.call(object, objectKey, objectValue)), writeNode$1(state2, level + 1, objectKey, !0, !0, !0) && (explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024, explicitPair && (state2.dump && CHAR_LINE_FEED$1 === state2.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state2.dump, explicitPair && (pairBuffer += generateNextLine$1(state2, level)), writeNode$1(state2, level + 1, objectValue, !0, explicitPair) && (state2.dump && CHAR_LINE_FEED$1 === state2.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state2.dump, _result += pairBuffer));
  state2.tag = _tag, state2.dump = _result || "{}";
}
function detectType$1(state2, object, explicit) {
  var _result, typeList, index, length, type2, style;
  for (typeList = explicit ? state2.explicitTypes : state2.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
    if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit ? type2.multi && type2.representName ? state2.tag = type2.representName(object) : state2.tag = type2.tag : state2.tag = "?", type2.represent) {
        if (style = state2.styleMap[type2.tag] || type2.defaultStyle, _toString$3.call(type2.represent) === "[object Function]")
          _result = type2.represent(object, style);
        else if (_hasOwnProperty$4.call(type2.represent, style))
          _result = type2.represent[style](object, style);
        else
          throw new YAMLException$5("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        state2.dump = _result;
      }
      return !0;
    }
  return !1;
}
function writeNode$1(state2, level, object, block, compact, iskey, isblockseq) {
  state2.tag = null, state2.dump = object, detectType$1(state2, object, !1) || detectType$1(state2, object, !0);
  var type2 = _toString$3.call(state2.dump), inblock = block, tagStr;
  block && (block = state2.flowLevel < 0 || state2.flowLevel > level);
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate2;
  if (objectOrArray && (duplicateIndex = state2.duplicates.indexOf(object), duplicate2 = duplicateIndex !== -1), (state2.tag !== null && state2.tag !== "?" || duplicate2 || state2.indent !== 2 && level > 0) && (compact = !1), duplicate2 && state2.usedDuplicates[duplicateIndex])
    state2.dump = "*ref_" + duplicateIndex;
  else {
    if (objectOrArray && duplicate2 && !state2.usedDuplicates[duplicateIndex] && (state2.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
      block && Object.keys(state2.dump).length !== 0 ? (writeBlockMapping$1(state2, level, state2.dump, compact), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + state2.dump)) : (writeFlowMapping$1(state2, level, state2.dump), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + " " + state2.dump));
    else if (type2 === "[object Array]")
      block && state2.dump.length !== 0 ? (state2.noArrayIndent && !isblockseq && level > 0 ? writeBlockSequence$1(state2, level - 1, state2.dump, compact) : writeBlockSequence$1(state2, level, state2.dump, compact), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + state2.dump)) : (writeFlowSequence$1(state2, level, state2.dump), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + " " + state2.dump));
    else if (type2 === "[object String]")
      state2.tag !== "?" && writeScalar$1(state2, state2.dump, level, iskey, inblock);
    else {
      if (type2 === "[object Undefined]")
        return !1;
      if (state2.skipInvalid) return !1;
      throw new YAMLException$5("unacceptable kind of an object to dump " + type2);
    }
    state2.tag !== null && state2.tag !== "?" && (tagStr = encodeURI(
      state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
    ).replace(/!/g, "%21"), state2.tag[0] === "!" ? tagStr = "!" + tagStr : tagStr.slice(0, 18) === "tag:yaml.org,2002:" ? tagStr = "!!" + tagStr.slice(18) : tagStr = "!<" + tagStr + ">", state2.dump = tagStr + " " + state2.dump);
  }
  return !0;
}
function getDuplicateReferences$1(object, state2) {
  var objects = [], duplicatesIndexes = [], index, length;
  for (inspectNode$1(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
    state2.duplicates.push(objects[duplicatesIndexes[index]]);
  state2.usedDuplicates = new Array(length);
}
function inspectNode$1(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object == "object")
    if (index = objects.indexOf(object), index !== -1)
      duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
    else if (objects.push(object), Array.isArray(object))
      for (index = 0, length = object.length; index < length; index += 1)
        inspectNode$1(object[index], objects, duplicatesIndexes);
    else
      for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
        inspectNode$1(object[objectKeyList[index]], objects, duplicatesIndexes);
}
function dump$1(input2, options2) {
  options2 = options2 || {};
  var state2 = new State$2(options2);
  state2.noRefs || getDuplicateReferences$1(input2, state2);
  var value = input2;
  return state2.replacer && (value = state2.replacer.call({ "": value }, "", value)), writeNode$1(state2, 0, value, !0, !0) ? state2.dump + `
` : "";
}
dumper$3.dump = dump$1;
var loader$2 = loader$3, dumper$2 = dumper$3;
function renamed(from2, to) {
  return function() {
    throw new Error("Function yaml." + from2 + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
jsYaml$2.Type = type$1;
jsYaml$2.Schema = schema$1;
jsYaml$2.FAILSAFE_SCHEMA = failsafe$1;
jsYaml$2.JSON_SCHEMA = json$1;
jsYaml$2.CORE_SCHEMA = core$5;
jsYaml$2.DEFAULT_SCHEMA = _default;
jsYaml$2.load = loader$2.load;
jsYaml$2.loadAll = loader$2.loadAll;
jsYaml$2.dump = dumper$2.dump;
jsYaml$2.YAMLException = exception$1;
jsYaml$2.types = {
  binary: binary$2,
  float: float$1,
  map: map$2,
  null: _null$1,
  pairs: pairs$2,
  set: set$1,
  timestamp: timestamp$2,
  bool: bool$1,
  int: int$1,
  merge: merge$3,
  omap: omap$1,
  seq: seq$1,
  str: str$1
};
jsYaml$2.safeLoad = renamed("safeLoad", "load");
jsYaml$2.safeLoadAll = renamed("safeLoadAll", "loadAll");
jsYaml$2.safeDump = renamed("safeDump", "dump");
var old = {}, hasRequiredOld;
function requireOld() {
  if (hasRequiredOld) return old;
  hasRequiredOld = 1;
  var pathModule = require$$0__default.default, isWindows2 = process.platform === "win32", fs2 = require$$0__default$1.default, DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      err && (backtrace.message = err.message, err = backtrace, missingCallback(err));
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          process.traceDeprecation ? console.trace(msg) : console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb == "function" ? cb : rethrow();
  }
  if (isWindows2)
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  else
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  if (isWindows2)
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  else
    var splitRootRe = /^[\/]*/;
  return old.realpathSync = function(p, cache) {
    if (p = pathModule.resolve(p), cache && Object.prototype.hasOwnProperty.call(cache, p))
      return cache[p];
    var original = p, seenLinks = {}, knownHard = {}, pos2, current, base2, previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos2 = m[0].length, current = m[0], base2 = m[0], previous = "", isWindows2 && !knownHard[base2] && (fs2.lstatSync(base2), knownHard[base2] = !0);
    }
    for (; pos2 < p.length; ) {
      nextPartRe.lastIndex = pos2;
      var result = nextPartRe.exec(p);
      if (previous = current, current += result[0], base2 = previous + result[1], pos2 = nextPartRe.lastIndex, !(knownHard[base2] || cache && cache[base2] === base2)) {
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base2))
          resolvedLink = cache[base2];
        else {
          var stat = fs2.lstatSync(base2);
          if (!stat.isSymbolicLink()) {
            knownHard[base2] = !0, cache && (cache[base2] = base2);
            continue;
          }
          var linkTarget = null;
          if (!isWindows2) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            seenLinks.hasOwnProperty(id) && (linkTarget = seenLinks[id]);
          }
          linkTarget === null && (fs2.statSync(base2), linkTarget = fs2.readlinkSync(base2)), resolvedLink = pathModule.resolve(previous, linkTarget), cache && (cache[base2] = resolvedLink), isWindows2 || (seenLinks[id] = linkTarget);
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos2)), start();
      }
    }
    return cache && (cache[original] = p), p;
  }, old.realpath = function(p, cache, cb) {
    if (typeof cb != "function" && (cb = maybeCallback(cache), cache = null), p = pathModule.resolve(p), cache && Object.prototype.hasOwnProperty.call(cache, p))
      return process.nextTick(cb.bind(null, null, cache[p]));
    var original = p, seenLinks = {}, knownHard = {}, pos2, current, base2, previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos2 = m[0].length, current = m[0], base2 = m[0], previous = "", isWindows2 && !knownHard[base2] ? fs2.lstat(base2, function(err) {
        if (err) return cb(err);
        knownHard[base2] = !0, LOOP();
      }) : process.nextTick(LOOP);
    }
    function LOOP() {
      if (pos2 >= p.length)
        return cache && (cache[original] = p), cb(null, p);
      nextPartRe.lastIndex = pos2;
      var result = nextPartRe.exec(p);
      return previous = current, current += result[0], base2 = previous + result[1], pos2 = nextPartRe.lastIndex, knownHard[base2] || cache && cache[base2] === base2 ? process.nextTick(LOOP) : cache && Object.prototype.hasOwnProperty.call(cache, base2) ? gotResolvedLink(cache[base2]) : fs2.lstat(base2, gotStat);
    }
    function gotStat(err, stat) {
      if (err) return cb(err);
      if (!stat.isSymbolicLink())
        return knownHard[base2] = !0, cache && (cache[base2] = base2), process.nextTick(LOOP);
      if (!isWindows2) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id))
          return gotTarget(null, seenLinks[id], base2);
      }
      fs2.stat(base2, function(err2) {
        if (err2) return cb(err2);
        fs2.readlink(base2, function(err3, target) {
          isWindows2 || (seenLinks[id] = target), gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base3) {
      if (err) return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      cache && (cache[base3] = resolvedLink), gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos2)), start();
    }
  }, old;
}
var fs_realpath, hasRequiredFs_realpath;
function requireFs_realpath() {
  if (hasRequiredFs_realpath) return fs_realpath;
  hasRequiredFs_realpath = 1, fs_realpath = realpath, realpath.realpath = realpath, realpath.sync = realpathSync, realpath.realpathSync = realpathSync, realpath.monkeypatch = monkeypatch, realpath.unmonkeypatch = unmonkeypatch;
  var fs2 = require$$0__default$1.default, origRealpath = fs2.realpath, origRealpathSync = fs2.realpathSync, version = process.version, ok = /^v[0-5]\./.test(version), old2 = requireOld();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok)
      return origRealpath(p, cache, cb);
    typeof cache == "function" && (cb = cache, cache = null), origRealpath(p, cache, function(er, result) {
      newError(er) ? old2.realpath(p, cache, cb) : cb(er, result);
    });
  }
  function realpathSync(p, cache) {
    if (ok)
      return origRealpathSync(p, cache);
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er))
        return old2.realpathSync(p, cache);
      throw er;
    }
  }
  function monkeypatch() {
    fs2.realpath = realpath, fs2.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs2.realpath = origRealpath, fs2.realpathSync = origRealpathSync;
  }
  return fs_realpath;
}
const isWindows$2 = typeof process == "object" && process && process.platform === "win32";
var path$i = isWindows$2 ? { sep: "\\" } : { sep: "/" }, balanced = balancedMatch, braceExpansion = expandTop, escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(str2) {
  return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str2) {
  return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str2) {
  if (!str2)
    return [""];
  var parts = [], m = balanced("{", "}", str2);
  if (!m)
    return str2.split(",");
  var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
}
function expandTop(str2) {
  return str2 ? (str2.substr(0, 2) === "{}" && (str2 = "\\{\\}" + str2.substr(2)), expand$5(escapeBraces(str2), !0).map(unescapeBraces)) : [];
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i2, y) {
  return i2 <= y;
}
function gte(i2, y) {
  return i2 >= y;
}
function expand$5(str2, isTop) {
  var expansions = [], m = balanced("{", "}", str2);
  if (!m) return [str2];
  var pre = m.pre, post = m.post.length ? expand$5(m.post, !1) : [""];
  if (/\$$/.test(m.pre))
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions)
      return m.post.match(/,.*\}/) ? (str2 = m.pre + "{" + m.body + escClose + m.post, expand$5(str2)) : [str2];
    var n;
    if (isSequence)
      n = m.body.split(/\.\./);
    else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand$5(n[0], !1).map(embrace), n.length === 1))
      return post.map(function(p) {
        return m.pre + n[0] + p;
      });
    var N;
    if (isSequence) {
      var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
      reverse && (incr *= -1, test = gte);
      var pad2 = n.some(isPadded);
      N = [];
      for (var i2 = x; test(i2, y); i2 += incr) {
        var c2;
        if (isAlphaSequence)
          c2 = String.fromCharCode(i2), c2 === "\\" && (c2 = "");
        else if (c2 = String(i2), pad2) {
          var need = width - c2.length;
          if (need > 0) {
            var z = new Array(need + 1).join("0");
            i2 < 0 ? c2 = "-" + z + c2.slice(1) : c2 = z + c2;
          }
        }
        N.push(c2);
      }
    } else {
      N = [];
      for (var j = 0; j < n.length; j++)
        N.push.apply(N, expand$5(n[j], !1));
    }
    for (var j = 0; j < N.length; j++)
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        (!isTop || isSequence || expansion) && expansions.push(expansion);
      }
  }
  return expansions;
}
const minimatch$1 = minimatch_1 = (p, pattern, options2 = {}) => (assertValidPattern(pattern), !options2.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch$1(pattern, options2).match(p));
var minimatch_1 = minimatch$1;
const path$h = path$i;
minimatch$1.sep = path$h.sep;
const GLOBSTAR = Symbol("globstar **");
minimatch$1.GLOBSTAR = GLOBSTAR;
const expand$4 = braceExpansion, plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
}, qmark = "[^/]", star$1 = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", charSet = (s) => s.split("").reduce((set2, c2) => (set2[c2] = !0, set2), {}), reSpecials = charSet("().*{}+?[]^$\\!"), addPatternStartSet = charSet("[.("), slashSplit = /\/+/;
minimatch$1.filter = (pattern, options2 = {}) => (p, i2, list2) => minimatch$1(p, pattern, options2);
const ext = (a, b = {}) => {
  const t = {};
  return Object.keys(a).forEach((k) => t[k] = a[k]), Object.keys(b).forEach((k) => t[k] = b[k]), t;
};
minimatch$1.defaults = (def) => {
  if (!def || typeof def != "object" || !Object.keys(def).length)
    return minimatch$1;
  const orig = minimatch$1, m = (p, pattern, options2) => orig(p, pattern, ext(def, options2));
  return m.Minimatch = class extends orig.Minimatch {
    constructor(pattern, options2) {
      super(pattern, ext(def, options2));
    }
  }, m.Minimatch.defaults = (options2) => orig.defaults(ext(def, options2)).Minimatch, m.filter = (pattern, options2) => orig.filter(pattern, ext(def, options2)), m.defaults = (options2) => orig.defaults(ext(def, options2)), m.makeRe = (pattern, options2) => orig.makeRe(pattern, ext(def, options2)), m.braceExpand = (pattern, options2) => orig.braceExpand(pattern, ext(def, options2)), m.match = (list2, pattern, options2) => orig.match(list2, pattern, ext(def, options2)), m;
};
minimatch$1.braceExpand = (pattern, options2) => braceExpand(pattern, options2);
const braceExpand = (pattern, options2 = {}) => (assertValidPattern(pattern), options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand$4(pattern)), MAX_PATTERN_LENGTH = 1024 * 64, assertValidPattern = (pattern) => {
  if (typeof pattern != "string")
    throw new TypeError("invalid pattern");
  if (pattern.length > MAX_PATTERN_LENGTH)
    throw new TypeError("pattern is too long");
}, SUBPARSE = Symbol("subparse");
minimatch$1.makeRe = (pattern, options2) => new Minimatch$1(pattern, options2 || {}).makeRe();
minimatch$1.match = (list2, pattern, options2 = {}) => {
  const mm = new Minimatch$1(pattern, options2);
  return list2 = list2.filter((f2) => mm.match(f2)), mm.options.nonull && !list2.length && list2.push(pattern), list2;
};
const globUnescape = (s) => s.replace(/\\(.)/g, "$1"), charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1"), regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
let Minimatch$1 = class {
  constructor(pattern, options2) {
    assertValidPattern(pattern), options2 || (options2 = {}), this.options = options2, this.set = [], this.pattern = pattern, this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options2.partial, this.make();
  }
  debug() {
  }
  make() {
    const pattern = this.pattern, options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!pattern) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    let set2 = this.globSet = this.braceExpand();
    options2.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, set2), set2 = this.globParts = set2.map((s) => s.split(slashSplit)), this.debug(this.pattern, set2), set2 = set2.map((s, si, set3) => s.map(this.parse, this)), this.debug(this.pattern, set2), set2 = set2.filter((s) => s.indexOf(!1) === -1), this.debug(this.pattern, set2), this.set = set2;
  }
  parseNegate() {
    if (this.options.nonegate) return;
    const pattern = this.pattern;
    let negate = !1, negateOffset = 0;
    for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++)
      negate = !negate, negateOffset++;
    negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file2, pattern, partial) {
    var options2 = this.options;
    this.debug(
      "matchOne",
      { this: this, file: file2, pattern }
    ), this.debug("matchOne", file2.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi], f2 = file2[fi];
      if (this.debug(pattern, p, f2), p === !1) return !1;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f2]);
        var fr = fi, pr = pi + 1;
        if (pr === pl) {
          for (this.debug("** at the end"); fi < fl; fi++)
            if (file2[fi] === "." || file2[fi] === ".." || !options2.dot && file2[fi].charAt(0) === ".") return !1;
          return !0;
        }
        for (; fr < fl; ) {
          var swallowee = file2[fr];
          if (this.debug(`
globstar while`, file2, fr, pattern, pr, swallowee), this.matchOne(file2.slice(fr), pattern.slice(pr), partial))
            return this.debug("globstar found match!", fr, fl, swallowee), !0;
          if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file2, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), fr++;
        }
        return !!(partial && (this.debug(`
>>> no match, partial?`, file2, fr, pattern, pr), fr === fl));
      }
      var hit;
      if (typeof p == "string" ? (hit = f2 === p, this.debug("string match", p, f2, hit)) : (hit = f2.match(p), this.debug("pattern match", p, f2, hit)), !hit) return !1;
    }
    if (fi === fl && pi === pl)
      return !0;
    if (fi === fl)
      return partial;
    if (pi === pl)
      return fi === fl - 1 && file2[fi] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern, isSub) {
    assertValidPattern(pattern);
    const options2 = this.options;
    if (pattern === "**")
      if (options2.noglobstar)
        pattern = "*";
      else
        return GLOBSTAR;
    if (pattern === "") return "";
    let re = "", hasMagic = !1, escaping = !1;
    const patternListStack = [], negativeLists = [];
    let stateChar, inClass = !1, reClassStart = -1, classStart = -1, cs, pl, sp, dotTravAllowed = pattern.charAt(0) === ".", dotFileAllowed = options2.dot || dotTravAllowed;
    const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", subPatternStart = (p) => p.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", clearStateChar = () => {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star$1, hasMagic = !0;
            break;
          case "?":
            re += qmark, hasMagic = !0;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        this.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
      }
    };
    for (let i2 = 0, c2; i2 < pattern.length && (c2 = pattern.charAt(i2)); i2++) {
      if (this.debug("%s	%s %s %j", pattern, i2, re, c2), escaping) {
        if (c2 === "/")
          return !1;
        reSpecials[c2] && (re += "\\"), re += c2, escaping = !1;
        continue;
      }
      switch (c2) {
        case "/":
          return !1;
        case "\\":
          if (inClass && pattern.charAt(i2 + 1) === "-") {
            re += c2;
            continue;
          }
          clearStateChar(), escaping = !0;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re, c2), inClass) {
            this.debug("  in class"), c2 === "!" && i2 === classStart + 1 && (c2 = "^"), re += c2;
            continue;
          }
          this.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c2, options2.noext && clearStateChar();
          continue;
        case "(": {
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          const plEntry = {
            type: stateChar,
            start: i2 - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          };
          this.debug(this.pattern, "	", plEntry), patternListStack.push(plEntry), re += plEntry.open, plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i2 + 1))), this.debug("plType %j %j", stateChar, re), stateChar = !1;
          continue;
        }
        case ")": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (inClass || !plEntry) {
            re += "\\)";
            continue;
          }
          patternListStack.pop(), clearStateChar(), hasMagic = !0, pl = plEntry, re += pl.close, pl.type === "!" && negativeLists.push(Object.assign(pl, { reEnd: re.length }));
          continue;
        }
        case "|": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (inClass || !plEntry) {
            re += "\\|";
            continue;
          }
          clearStateChar(), re += "|", plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i2 + 1)));
          continue;
        }
        case "[":
          if (clearStateChar(), inClass) {
            re += "\\" + c2;
            continue;
          }
          inClass = !0, classStart = i2, reClassStart = re.length, re += c2;
          continue;
        case "]":
          if (i2 === classStart + 1 || !inClass) {
            re += "\\" + c2;
            continue;
          }
          cs = pattern.substring(classStart + 1, i2);
          try {
            RegExp("[" + braExpEscape(charUnescape(cs)) + "]"), re += c2;
          } catch {
            re = re.substring(0, reClassStart) + "(?:$.)";
          }
          hasMagic = !0, inClass = !1;
          continue;
        default:
          clearStateChar(), reSpecials[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
          break;
      }
    }
    for (inClass && (cs = pattern.slice(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substring(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail;
      tail = re.slice(pl.reStart + pl.open.length), this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => ($2 || ($2 = "\\"), $1 + $1 + $2 + "|")), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
      const t = pl.type === "*" ? star$1 : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar(), escaping && (re += "\\\\");
    const addPatternStart = addPatternStartSet[re.charAt(0)];
    for (let n = negativeLists.length - 1; n > -1; n--) {
      const nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      let nlAfter = re.slice(nl.reEnd);
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter, closeParensBefore = nlBefore.split(")").length, openParensBefore = nlBefore.split("(").length - closeParensBefore;
      let cleanAfter = nlAfter;
      for (let i2 = 0; i2 < openParensBefore; i2++)
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      nlAfter = cleanAfter;
      const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    }
    if (re !== "" && hasMagic && (re = "(?=.)" + re), addPatternStart && (re = patternStart() + re), isSub === SUBPARSE)
      return [re, hasMagic];
    if (options2.nocase && !hasMagic && (hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()), !hasMagic)
      return globUnescape(pattern);
    const flags = options2.nocase ? "i" : "";
    try {
      return Object.assign(new RegExp("^" + re + "$", flags), {
        _glob: pattern,
        _src: re
      });
    } catch {
      return new RegExp("$.");
    }
  }
  makeRe() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    const set2 = this.set;
    if (!set2.length)
      return this.regexp = !1, this.regexp;
    const options2 = this.options, twoStar = options2.noglobstar ? star$1 : options2.dot ? twoStarDot : twoStarNoDot, flags = options2.nocase ? "i" : "";
    let re = set2.map((pattern) => (pattern = pattern.map(
      (p) => typeof p == "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
    ).reduce((set3, p) => (set3[set3.length - 1] === GLOBSTAR && p === GLOBSTAR || set3.push(p), set3), []), pattern.forEach((p, i2) => {
      p !== GLOBSTAR || pattern[i2 - 1] === GLOBSTAR || (i2 === 0 ? pattern.length > 1 ? pattern[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i2 + 1] : pattern[i2] = twoStar : i2 === pattern.length - 1 ? pattern[i2 - 1] += "(?:\\/|" + twoStar + ")?" : (pattern[i2 - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i2 + 1], pattern[i2 + 1] = GLOBSTAR));
    }), pattern.filter((p) => p !== GLOBSTAR).join("/"))).join("|");
    re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
    try {
      this.regexp = new RegExp(re, flags);
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  match(f2, partial = this.partial) {
    if (this.debug("match", f2, this.pattern), this.comment) return !1;
    if (this.empty) return f2 === "";
    if (f2 === "/" && partial) return !0;
    const options2 = this.options;
    path$h.sep !== "/" && (f2 = f2.split(path$h.sep).join("/")), f2 = f2.split(slashSplit), this.debug(this.pattern, "split", f2);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename;
    for (let i2 = f2.length - 1; i2 >= 0 && (filename = f2[i2], !filename); i2--)
      ;
    for (let i2 = 0; i2 < set2.length; i2++) {
      const pattern = set2[i2];
      let file2 = f2;
      if (options2.matchBase && pattern.length === 1 && (file2 = [filename]), this.matchOne(file2, pattern, partial))
        return options2.flipNegate ? !0 : !this.negate;
    }
    return options2.flipNegate ? !1 : this.negate;
  }
  static defaults(def) {
    return minimatch$1.defaults(def).Minimatch;
  }
};
minimatch$1.Minimatch = Minimatch$1;
var inherits$1 = { exports: {} }, inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(ctor, superCtor) {
    superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
    }
  }), inherits_browser.exports;
}
try {
  var util$6 = require("util");
  if (typeof util$6.inherits != "function") throw "";
  inherits$1.exports = util$6.inherits;
} catch (e) {
  inherits$1.exports = requireInherits_browser();
}
var inheritsExports = inherits$1.exports, common$8 = {};
common$8.setopts = setopts;
common$8.ownProp = ownProp;
common$8.makeAbs = makeAbs;
common$8.finish = finish;
common$8.mark = mark$1;
common$8.isIgnored = isIgnored;
common$8.childrenIgnored = childrenIgnored;
function ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}
var fs$a = require$$0__default$1.default, path$g = require$$0__default.default, minimatch = minimatch_1, isAbsolute = require$$0__default.default.isAbsolute, Minimatch = minimatch.Minimatch;
function alphasort(a, b) {
  return a.localeCompare(b, "en");
}
function setupIgnores(self2, options2) {
  self2.ignore = options2.ignore || [], Array.isArray(self2.ignore) || (self2.ignore = [self2.ignore]), self2.ignore.length && (self2.ignore = self2.ignore.map(ignoreMap));
}
function ignoreMap(pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === "/**") {
    var gpattern = pattern.replace(/(\/\*\*)+$/, "");
    gmatcher = new Minimatch(gpattern, { dot: !0 });
  }
  return {
    matcher: new Minimatch(pattern, { dot: !0 }),
    gmatcher
  };
}
function setopts(self2, pattern, options2) {
  if (options2 || (options2 = {}), options2.matchBase && pattern.indexOf("/") === -1) {
    if (options2.noglobstar)
      throw new Error("base matching requires globstar");
    pattern = "**/" + pattern;
  }
  self2.silent = !!options2.silent, self2.pattern = pattern, self2.strict = options2.strict !== !1, self2.realpath = !!options2.realpath, self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null), self2.follow = !!options2.follow, self2.dot = !!options2.dot, self2.mark = !!options2.mark, self2.nodir = !!options2.nodir, self2.nodir && (self2.mark = !0), self2.sync = !!options2.sync, self2.nounique = !!options2.nounique, self2.nonull = !!options2.nonull, self2.nosort = !!options2.nosort, self2.nocase = !!options2.nocase, self2.stat = !!options2.stat, self2.noprocess = !!options2.noprocess, self2.absolute = !!options2.absolute, self2.fs = options2.fs || fs$a, self2.maxLength = options2.maxLength || 1 / 0, self2.cache = options2.cache || /* @__PURE__ */ Object.create(null), self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null), self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null), setupIgnores(self2, options2), self2.changedCwd = !1;
  var cwd2 = process.cwd();
  ownProp(options2, "cwd") ? (self2.cwd = path$g.resolve(options2.cwd), self2.changedCwd = self2.cwd !== cwd2) : self2.cwd = path$g.resolve(cwd2), self2.root = options2.root || path$g.resolve(self2.cwd, "/"), self2.root = path$g.resolve(self2.root), self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd), self2.nomount = !!options2.nomount, process.platform === "win32" && (self2.root = self2.root.replace(/\\/g, "/"), self2.cwd = self2.cwd.replace(/\\/g, "/"), self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/")), options2.nonegate = !0, options2.nocomment = !0, options2.allowWindowsEscape = !0, self2.minimatch = new Minimatch(pattern, options2), self2.options = self2.minimatch.options;
}
function finish(self2) {
  for (var nou = self2.nounique, all = nou ? [] : /* @__PURE__ */ Object.create(null), i2 = 0, l = self2.matches.length; i2 < l; i2++) {
    var matches2 = self2.matches[i2];
    if (!matches2 || Object.keys(matches2).length === 0) {
      if (self2.nonull) {
        var literal2 = self2.minimatch.globSet[i2];
        nou ? all.push(literal2) : all[literal2] = !0;
      }
    } else {
      var m = Object.keys(matches2);
      nou ? all.push.apply(all, m) : m.forEach(function(m2) {
        all[m2] = !0;
      });
    }
  }
  if (nou || (all = Object.keys(all)), self2.nosort || (all = all.sort(alphasort)), self2.mark) {
    for (var i2 = 0; i2 < all.length; i2++)
      all[i2] = self2._mark(all[i2]);
    self2.nodir && (all = all.filter(function(e) {
      var notDir = !/\/$/.test(e), c2 = self2.cache[e] || self2.cache[makeAbs(self2, e)];
      return notDir && c2 && (notDir = c2 !== "DIR" && !Array.isArray(c2)), notDir;
    }));
  }
  self2.ignore.length && (all = all.filter(function(m2) {
    return !isIgnored(self2, m2);
  })), self2.found = all;
}
function mark$1(self2, p) {
  var abs = makeAbs(self2, p), c2 = self2.cache[abs], m = p;
  if (c2) {
    var isDir = c2 === "DIR" || Array.isArray(c2), slash = p.slice(-1) === "/";
    if (isDir && !slash ? m += "/" : !isDir && slash && (m = m.slice(0, -1)), m !== p) {
      var mabs = makeAbs(self2, m);
      self2.statCache[mabs] = self2.statCache[abs], self2.cache[mabs] = self2.cache[abs];
    }
  }
  return m;
}
function makeAbs(self2, f2) {
  var abs = f2;
  return f2.charAt(0) === "/" ? abs = path$g.join(self2.root, f2) : isAbsolute(f2) || f2 === "" ? abs = f2 : self2.changedCwd ? abs = path$g.resolve(self2.cwd, f2) : abs = path$g.resolve(f2), process.platform === "win32" && (abs = abs.replace(/\\/g, "/")), abs;
}
function isIgnored(self2, path2) {
  return self2.ignore.length ? self2.ignore.some(function(item) {
    return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
  }) : !1;
}
function childrenIgnored(self2, path2) {
  return self2.ignore.length ? self2.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path2));
  }) : !1;
}
var sync$2, hasRequiredSync$1;
function requireSync$1() {
  if (hasRequiredSync$1) return sync$2;
  hasRequiredSync$1 = 1, sync$2 = globSync, globSync.GlobSync = GlobSync;
  var rp = requireFs_realpath(), minimatch2 = minimatch_1;
  requireGlob$1().Glob;
  var path2 = require$$0__default.default, assert2 = require$$5__default.default, isAbsolute2 = require$$0__default.default.isAbsolute, common2 = common$8, setopts2 = common2.setopts, ownProp2 = common2.ownProp, childrenIgnored2 = common2.childrenIgnored, isIgnored2 = common2.isIgnored;
  function globSync(pattern, options2) {
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    return new GlobSync(pattern, options2).found;
  }
  function GlobSync(pattern, options2) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options2);
    if (setopts2(this, pattern, options2), this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i2 = 0; i2 < n; i2++)
      this._process(this.minimatch.set[i2], i2, !1);
    this._finish();
  }
  return GlobSync.prototype._finish = function() {
    if (assert2.ok(this instanceof GlobSync), this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set2 = self2.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset)
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = !0;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = !0;
            else
              throw er;
          }
      });
    }
    common2.finish(this);
  }, GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert2.ok(this instanceof GlobSync);
    for (var n = 0; typeof pattern[n] == "string"; )
      n++;
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n), read2;
    prefix === null ? read2 = "." : ((isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p) {
      return typeof p == "string" ? p : "[*]";
    }).join("/"))) && (!prefix || !isAbsolute2(prefix)) && (prefix = "/" + prefix), read2 = prefix);
    var abs = this._makeAbs(read2);
    if (!childrenIgnored2(this, read2)) {
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar);
    }
  }, GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i2 = 0; i2 < entries.length; i2++) {
        var e = entries[i2];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len !== 0) {
        if (remain.length === 1 && !this.mark && !this.stat) {
          this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
          for (var i2 = 0; i2 < len; i2++) {
            var e = matchedEntries[i2];
            prefix && (prefix.slice(-1) !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i2 = 0; i2 < len; i2++) {
          var e = matchedEntries[i2], newPattern;
          prefix ? newPattern = [prefix, e] : newPattern = [e], this._process(newPattern.concat(remain), index, inGlobStar);
        }
      }
    }
  }, GlobSync.prototype._emitMatch = function(index, e) {
    if (!isIgnored2(this, e)) {
      var abs = this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0, this.stat && this._stat(e);
      }
    }
  }, GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, !1);
    var entries, lstat;
    try {
      lstat = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT")
        return null;
    }
    var isSym = lstat && lstat.isSymbolicLink();
    return this.symlinks[abs] = isSym, !isSym && lstat && !lstat.isDirectory() ? this.cache[abs] = "FILE" : entries = this._readdir(abs, !1), entries;
  }, GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return null;
      if (Array.isArray(c2))
        return c2;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      return this._readdirError(abs, er), null;
    }
  }, GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat)
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e = entries[i2];
        abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
      }
    return this.cache[abs] = entries, entries;
  }, GlobSync.prototype._readdirError = function(f2, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f2);
        if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          throw error2.path = this.cwd, error2.code = er.code, error2;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f2)] = !1;
        break;
      default:
        if (this.cache[this._makeAbs(f2)] = !1, this.strict)
          throw er;
        this.silent || console.error("glob error", er);
        break;
    }
  }, GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, !1);
      var len = entries.length, isSym = this.symlinks[abs];
      if (!(isSym && inGlobStar))
        for (var i2 = 0; i2 < len; i2++) {
          var e = entries[i2];
          if (!(e.charAt(0) === "." && !this.dot)) {
            var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
            this._process(instead, index, !0);
            var below = gspref.concat(entries[i2], remain);
            this._process(below, index, !0);
          }
        }
    }
  }, GlobSync.prototype._processSimple = function(prefix, index) {
    var exists2 = this._stat(prefix);
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !!exists2) {
      if (prefix && isAbsolute2(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
      }
      process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix);
    }
  }, GlobSync.prototype._stat = function(f2) {
    var abs = this._makeAbs(f2), needDir = f2.slice(-1) === "/";
    if (f2.length > this.maxLength)
      return !1;
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return c2;
      if (needDir && c2 === "FILE")
        return !1;
    }
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
          return this.statCache[abs] = !1, !1;
      }
      if (lstat && lstat.isSymbolicLink())
        try {
          stat = this.fs.statSync(abs);
        } catch {
          stat = lstat;
        }
      else
        stat = lstat;
    }
    this.statCache[abs] = stat;
    var c2 = !0;
    return stat && (c2 = stat.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? !1 : c2;
  }, GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, GlobSync.prototype._makeAbs = function(f2) {
    return common2.makeAbs(this, f2);
  }, sync$2;
}
var wrappy_1, hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1, wrappy_1 = wrappy;
  function wrappy(fn2, cb) {
    if (fn2 && cb) return wrappy(fn2)(cb);
    if (typeof fn2 != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(fn2).forEach(function(k) {
      wrapper[k] = fn2[k];
    }), wrapper;
    function wrapper() {
      for (var args = new Array(arguments.length), i2 = 0; i2 < args.length; i2++)
        args[i2] = arguments[i2];
      var ret = fn2.apply(this, args), cb2 = args[args.length - 1];
      return typeof ret == "function" && ret !== cb2 && Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      }), ret;
    }
  }
  return wrappy_1;
}
var once$2 = { exports: {} }, hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once$2.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once$2.exports = wrappy(once2), once$2.exports.strict = wrappy(onceStrict), once2.proto = once2(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once2(this);
      },
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: !0
    });
  });
  function once2(fn2) {
    var f2 = function() {
      return f2.called ? f2.value : (f2.called = !0, f2.value = fn2.apply(this, arguments));
    };
    return f2.called = !1, f2;
  }
  function onceStrict(fn2) {
    var f2 = function() {
      if (f2.called)
        throw new Error(f2.onceError);
      return f2.called = !0, f2.value = fn2.apply(this, arguments);
    }, name = fn2.name || "Function wrapped with `once`";
    return f2.onceError = name + " shouldn't be called more than once", f2.called = !1, f2;
  }
  return once$2.exports;
}
var inflight_1, hasRequiredInflight;
function requireInflight() {
  if (hasRequiredInflight) return inflight_1;
  hasRequiredInflight = 1;
  var wrappy = requireWrappy(), reqs = /* @__PURE__ */ Object.create(null), once2 = requireOnce();
  inflight_1 = wrappy(inflight);
  function inflight(key2, cb) {
    return reqs[key2] ? (reqs[key2].push(cb), null) : (reqs[key2] = [cb], makeres(key2));
  }
  function makeres(key2) {
    return once2(function RES() {
      var cbs = reqs[key2], len = cbs.length, args = slice2(arguments);
      try {
        for (var i2 = 0; i2 < len; i2++)
          cbs[i2].apply(null, args);
      } finally {
        cbs.length > len ? (cbs.splice(0, len), process.nextTick(function() {
          RES.apply(null, args);
        })) : delete reqs[key2];
      }
    });
  }
  function slice2(args) {
    for (var length = args.length, array2 = [], i2 = 0; i2 < length; i2++) array2[i2] = args[i2];
    return array2;
  }
  return inflight_1;
}
var glob_1$2, hasRequiredGlob$1;
function requireGlob$1() {
  if (hasRequiredGlob$1) return glob_1$2;
  hasRequiredGlob$1 = 1, glob_1$2 = glob2;
  var rp = requireFs_realpath(), minimatch2 = minimatch_1, inherits2 = inheritsExports, EE2 = require$$3__default.default.EventEmitter, path2 = require$$0__default.default, assert2 = require$$5__default.default, isAbsolute2 = require$$0__default.default.isAbsolute, globSync = requireSync$1(), common2 = common$8, setopts2 = common2.setopts, ownProp2 = common2.ownProp, inflight = requireInflight(), childrenIgnored2 = common2.childrenIgnored, isIgnored2 = common2.isIgnored, once2 = requireOnce();
  function glob2(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), options2 || (options2 = {}), options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options2);
    }
    return new Glob(pattern, options2, cb);
  }
  glob2.sync = globSync;
  var GlobSync = glob2.GlobSync = globSync.GlobSync;
  glob2.glob = glob2;
  function extend4(origin, add) {
    if (add === null || typeof add != "object")
      return origin;
    for (var keys = Object.keys(add), i2 = keys.length; i2--; )
      origin[keys[i2]] = add[keys[i2]];
    return origin;
  }
  glob2.hasMagic = function(pattern, options_) {
    var options2 = extend4({}, options_);
    options2.noprocess = !0;
    var g = new Glob(pattern, options2), set2 = g.minimatch.set;
    if (!pattern)
      return !1;
    if (set2.length > 1)
      return !0;
    for (var j = 0; j < set2[0].length; j++)
      if (typeof set2[0][j] != "string")
        return !0;
    return !1;
  }, glob2.Glob = Glob, inherits2(Glob, EE2);
  function Glob(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = null), options2 && options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options2);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options2, cb);
    setopts2(this, pattern, options2), this._didRealPath = !1;
    var n = this.minimatch.set.length;
    this.matches = new Array(n), typeof cb == "function" && (cb = once2(cb), this.on("error", cb), this.on("end", function(matches2) {
      cb(null, matches2);
    }));
    var self2 = this;
    if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = !1, this.noprocess)
      return this;
    if (n === 0)
      return done();
    for (var sync2 = !0, i2 = 0; i2 < n; i2++)
      this._process(this.minimatch.set[i2], i2, !1, done);
    sync2 = !1;
    function done() {
      --self2._processing, self2._processing <= 0 && (sync2 ? process.nextTick(function() {
        self2._finish();
      }) : self2._finish());
    }
  }
  Glob.prototype._finish = function() {
    if (assert2(this instanceof Glob), !this.aborted) {
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common2.finish(this), this.emit("end", this.found);
    }
  }, Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = !0;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    for (var self2 = this, i2 = 0; i2 < this.matches.length; i2++)
      this._realpathSet(i2, next);
    function next() {
      --n === 0 && self2._finish();
    }
  }, Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset), self2 = this, n = found.length;
    if (n === 0)
      return cb();
    var set2 = this.matches[index] = /* @__PURE__ */ Object.create(null);
    found.forEach(function(p, i2) {
      p = self2._makeAbs(p), rp.realpath(p, self2.realpathCache, function(er, real) {
        er ? er.syscall === "stat" ? set2[p] = !0 : self2.emit("error", er) : set2[real] = !0, --n === 0 && (self2.matches[index] = set2, cb());
      });
    });
  }, Glob.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, Glob.prototype._makeAbs = function(f2) {
    return common2.makeAbs(this, f2);
  }, Glob.prototype.abort = function() {
    this.aborted = !0, this.emit("abort");
  }, Glob.prototype.pause = function() {
    this.paused || (this.paused = !0, this.emit("pause"));
  }, Glob.prototype.resume = function() {
    if (this.paused) {
      if (this.emit("resume"), this.paused = !1, this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i2 = 0; i2 < eq.length; i2++) {
          var e = eq[i2];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i2 = 0; i2 < pq.length; i2++) {
          var p = pq[i2];
          this._processing--, this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  }, Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    if (assert2(this instanceof Glob), assert2(typeof cb == "function"), !this.aborted) {
      if (this._processing++, this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      for (var n = 0; typeof pattern[n] == "string"; )
        n++;
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n), read2;
      prefix === null ? read2 = "." : ((isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p) {
        return typeof p == "string" ? p : "[*]";
      }).join("/"))) && (!prefix || !isAbsolute2(prefix)) && (prefix = "/" + prefix), read2 = prefix);
      var abs = this._makeAbs(read2);
      if (childrenIgnored2(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar, cb) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar, cb);
    }
  }, Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i2 = 0; i2 < entries.length; i2++) {
      var e = entries[i2];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
      for (var i2 = 0; i2 < len; i2++) {
        var e = matchedEntries[i2];
        prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i2 = 0; i2 < len; i2++) {
      var e = matchedEntries[i2];
      prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  }, Glob.prototype._emitMatch = function(index, e) {
    if (!this.aborted && !isIgnored2(this, e)) {
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute2(e) ? e : this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0;
        var st = this.statCache[abs];
        st && this.emit("stat", e, st), this.emit("match", e);
      }
    }
  }, Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, !1, cb);
    var lstatkey = "lstat\0" + abs, self2 = this, lstatcb = inflight(lstatkey, lstatcb_);
    lstatcb && self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym, !isSym && lstat && !lstat.isDirectory() ? (self2.cache[abs] = "FILE", cb()) : self2._readdir(abs, !1, cb);
    }
  }, Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (!this.aborted && (cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb), !!cb)) {
      if (inGlobStar && !ownProp2(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp2(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return cb();
        if (Array.isArray(c2))
          return cb(null, c2);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    }
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      er ? self2._readdirError(abs, er, cb) : self2._readdirEntries(abs, entries, cb);
    };
  }
  return Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (!this.aborted) {
      if (!this.mark && !this.stat)
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e = entries[i2];
          abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
        }
      return this.cache[abs] = entries, cb(null, entries);
    }
  }, Glob.prototype._readdirError = function(f2, er, cb) {
    if (!this.aborted) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd, error2.code = er.code, this.emit("error", error2), this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = !1;
          break;
        default:
          this.cache[this._makeAbs(f2)] = !1, this.strict && (this.emit("error", er), this.abort()), this.silent || console.error("glob error", er);
          break;
      }
      return cb();
    }
  }, Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, !1, cb);
    var isSym = this.symlinks[abs], len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i2 = 0; i2 < len; i2++) {
      var e = entries[i2];
      if (!(e.charAt(0) === "." && !this.dot)) {
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index, !0, cb);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index, !0, cb);
      }
    }
    cb();
  }, Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists2) {
      self2._processSimple2(prefix, index, er, exists2, cb);
    });
  }, Glob.prototype._processSimple2 = function(prefix, index, er, exists2, cb) {
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !exists2)
      return cb();
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
    }
    process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix), cb();
  }, Glob.prototype._stat = function(f2, cb) {
    var abs = this._makeAbs(f2), needDir = f2.slice(-1) === "/";
    if (f2.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return cb(null, c2);
      if (needDir && c2 === "FILE")
        return cb();
    }
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === !1)
        return cb(null, stat);
      var type2 = stat.isDirectory() ? "DIR" : "FILE";
      return needDir && type2 === "FILE" ? cb() : cb(null, type2, stat);
    }
    var self2 = this, statcb = inflight("stat\0" + abs, lstatcb_);
    statcb && self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink())
        return self2.fs.stat(abs, function(er2, stat2) {
          er2 ? self2._stat2(f2, abs, null, lstat, cb) : self2._stat2(f2, abs, er2, stat2, cb);
        });
      self2._stat2(f2, abs, er, lstat, cb);
    }
  }, Glob.prototype._stat2 = function(f2, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
      return this.statCache[abs] = !1, cb();
    var needDir = f2.slice(-1) === "/";
    if (this.statCache[abs] = stat, abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, !1, stat);
    var c2 = !0;
    return stat && (c2 = stat.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? cb() : cb(null, c2, stat);
  }, glob_1$2;
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, unicode$1 = {
  Space_Separator,
  ID_Start,
  ID_Continue
}, util$5 = {
  isSpaceSeparator(c2) {
    return typeof c2 == "string" && unicode$1.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode$1.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode$1.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 == "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 == "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source, parseState, stack, pos, line$1, column, token, key, root;
var parse$a = function parse2(text, reviver) {
  source = String(text), parseState = "start", stack = [], pos = 0, line$1 = 1, column = 0, token = void 0, key = void 0, root = void 0;
  do
    token = lex(), parseStates[parseState]();
  while (token.type !== "eof");
  return typeof reviver == "function" ? internalize({ "": root }, "", reviver) : root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value == "object")
    if (Array.isArray(value))
      for (let i2 = 0; i2 < value.length; i2++) {
        const key2 = String(i2), replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return reviver.call(holder, name, value);
}
let lexState, buffer$1, doubleQuote, sign, c;
function lex() {
  for (lexState = "default", buffer$1 = "", doubleQuote = !1, sign = 1; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2)
      return token2;
  }
}
function peek() {
  if (source[pos])
    return String.fromCodePoint(source.codePointAt(pos));
}
function read() {
  const c2 = peek();
  return c2 === `
` ? (line$1++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read(), lexState = "comment";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    if (util$5.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineComment";
        return;
      case "/":
        read(), lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read(), lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read(), lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read(), lexState = "default";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        return read(), literal("ull"), newToken("null", null);
      case "t":
        return read(), literal("rue"), newToken("boolean", !0);
      case "f":
        return read(), literal("alse"), newToken("boolean", !1);
      case "-":
      case "+":
        read() === "-" && (sign = -1), lexState = "sign";
        return;
      case ".":
        buffer$1 = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer$1 = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer$1 = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", 1 / 0);
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"', buffer$1 = "", lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util$5.isIdStartChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer$1 += u, lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer$1 += read();
        return;
      case "\\":
        read(), lexState = "identifierNameEscape";
        return;
    }
    if (util$5.isIdContinueChar(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("identifier", buffer$1);
  },
  identifierNameEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util$5.isIdContinueChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer$1 += u, lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer$1 = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer$1 = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer$1 = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer$1 += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer$1 += read(), lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer$1 += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$5.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalPointLeading() {
    if (util$5.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$5.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$5.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer$1 += read(), lexState = "decimalExponentSign";
        return;
    }
    if (util$5.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util$5.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util$5.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  hexadecimal() {
    if (util$5.isHexDigit(c)) {
      buffer$1 += read(), lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util$5.isHexDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  string() {
    switch (c) {
      case "\\":
        read(), buffer$1 += escape$1();
        return;
      case '"':
        if (doubleQuote)
          return read(), newToken("string", buffer$1);
        buffer$1 += read();
        return;
      case "'":
        if (!doubleQuote)
          return read(), newToken("string", buffer$1);
        buffer$1 += read();
        return;
      case `
`:
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer$1 += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer$1 = read(), lexState = "identifierName";
        return;
      case "\\":
        read(), lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"', lexState = "string";
        return;
    }
    if (util$5.isIdStartChar(c)) {
      buffer$1 += read(), lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":")
      return newToken("punctuator", read());
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]")
      return newToken("punctuator", read());
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type2, value) {
  return {
    type: type2,
    value,
    line: line$1,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    if (peek() !== c2)
      throw invalidChar(read());
    read();
  }
}
function escape$1() {
  switch (peek()) {
    case "b":
      return read(), "\b";
    case "f":
      return read(), "\f";
    case "n":
      return read(), `
`;
    case "r":
      return read(), "\r";
    case "t":
      return read(), "	";
    case "v":
      return read(), "\v";
    case "0":
      if (read(), util$5.isDigit(peek()))
        throw invalidChar(read());
      return "\0";
    case "x":
      return read(), hexEscape();
    case "u":
      return read(), unicodeEscape();
    case `
`:
    case "\u2028":
    case "\u2029":
      return read(), "";
    case "\r":
      return read(), peek() === `
` && read(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "", c2 = peek();
  if (!util$5.isHexDigit(c2) || (buffer2 += read(), c2 = peek(), !util$5.isHexDigit(c2)))
    throw invalidChar(read());
  return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "", count2 = 4;
  for (; count2-- > 0; ) {
    const c2 = peek();
    if (!util$5.isHexDigit(c2))
      throw invalidChar(read());
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value, parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof")
      throw invalidEOF();
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0)
    root = value;
  else {
    const parent = stack[stack.length - 1];
    Array.isArray(parent) ? parent.push(value) : Object.defineProperty(parent, key, {
      value,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (value !== null && typeof value == "object")
    stack.push(value), Array.isArray(value) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
  else {
    const current = stack[stack.length - 1];
    current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
}
function invalidChar(c2) {
  return syntaxError$1(c2 === void 0 ? `JSON5: invalid end of input at ${line$1}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line$1}:${column}`);
}
function invalidEOF() {
  return syntaxError$1(`JSON5: invalid end of input at ${line$1}:${column}`);
}
function invalidIdentifier() {
  return column -= 5, syntaxError$1(`JSON5: invalid identifier character at ${line$1}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2])
    return replacements[c2];
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError$1(message) {
  const err = new SyntaxError(message);
  return err.lineNumber = line$1, err.columnNumber = column, err;
}
var stringify$5 = function stringify2(value, replacer, space) {
  const stack2 = [];
  let indent = "", propertyList, replacerFunc, gap = "", quote;
  if (replacer != null && typeof replacer == "object" && !Array.isArray(replacer) && (space = replacer.space, quote = replacer.quote, replacer = replacer.replacer), typeof replacer == "function")
    replacerFunc = replacer;
  else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v of replacer) {
      let item;
      typeof v == "string" ? item = v : (typeof v == "number" || v instanceof String || v instanceof Number) && (item = String(v)), item !== void 0 && propertyList.indexOf(item) < 0 && propertyList.push(item);
    }
  }
  return space instanceof Number ? space = Number(space) : space instanceof String && (space = String(space)), typeof space == "number" ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : typeof space == "string" && (gap = space.substr(0, 10)), serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    switch (value2 != null && (typeof value2.toJSON5 == "function" ? value2 = value2.toJSON5(key2) : typeof value2.toJSON == "function" && (value2 = value2.toJSON(key2))), replacerFunc && (value2 = replacerFunc.call(holder, key2, value2)), value2 instanceof Number ? value2 = Number(value2) : value2 instanceof String ? value2 = String(value2) : value2 instanceof Boolean && (value2 = value2.valueOf()), value2) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof value2 == "string")
      return quoteString(value2);
    if (typeof value2 == "number")
      return String(value2);
    if (typeof value2 == "object")
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    }, replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i2 = 0; i2 < value2.length; i2++) {
      const c2 = value2[i2];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++, product += c2;
          continue;
        case "\0":
          if (util$5.isDigit(value2[i2 + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
    return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys = propertyList || Object.keys(value2), partial = [];
    for (const key2 of keys) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        gap !== "" && (member += " "), member += propertyString, partial.push(member);
      }
    }
    let final;
    if (partial.length === 0)
      final = "{}";
    else {
      let properties;
      if (gap === "")
        properties = partial.join(","), final = "{" + properties + "}";
      else {
        let separator2 = `,
` + indent;
        properties = partial.join(separator2), final = `{
` + indent + properties + `,
` + stepback + "}";
      }
    }
    return stack2.pop(), indent = stepback, final;
  }
  function serializeKey(key2) {
    if (key2.length === 0)
      return quoteString(key2);
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util$5.isIdStartChar(firstChar))
      return quoteString(key2);
    for (let i2 = firstChar.length; i2 < key2.length; i2++)
      if (!util$5.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i2))))
        return quoteString(key2);
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial = [];
    for (let i2 = 0; i2 < value2.length; i2++) {
      const propertyString = serializeProperty(String(i2), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0)
      final = "[]";
    else if (gap === "")
      final = "[" + partial.join(",") + "]";
    else {
      let separator2 = `,
` + indent, properties = partial.join(separator2);
      final = `[
` + indent + properties + `,
` + stepback + "]";
    }
    return stack2.pop(), indent = stepback, final;
  }
};
const JSON5 = {
  parse: parse$a,
  stringify: stringify$5
};
var lib$2 = JSON5, dist = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: lib$2
}), require$$4$2 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(dist), getGlobFs$1 = {}, __importDefault$4 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(getGlobFs$1, "__esModule", { value: !0 });
getGlobFs$1.getGlobFs = void 0;
const fs_1$1 = __importDefault$4(require$$0__default$1.default);
function removeWindowsPrefix(path2) {
  return path2.replace(/^[a-zA-Z]:/, "");
}
function getGlobFs(_fs) {
  const readdir = (path2, callback) => {
    _fs.readdir(removeWindowsPrefix(String(path2))).then((stats) => callback(null, stats.map((stat2) => stat2.name))).catch((err) => callback(err, []));
  }, stat = (path2, callback) => {
    _fs.isFile(removeWindowsPrefix(String(path2))).then((isPathAFile) => {
      callback(null, {
        ino: 0,
        mode: 0,
        nlink: 0,
        uid: 0,
        gid: 0,
        rdev: 0,
        size: 0,
        blksize: 0,
        blocks: 0,
        atimeMs: 0,
        mtimeMs: 0,
        ctimeMs: 0,
        birthtimeMs: 0,
        atime: /* @__PURE__ */ new Date(),
        mtime: /* @__PURE__ */ new Date(),
        ctime: /* @__PURE__ */ new Date(),
        birthtime: /* @__PURE__ */ new Date(),
        dev: 0,
        isBlockDevice: () => !1,
        isCharacterDevice: () => !1,
        isDirectory: () => !isPathAFile,
        isFIFO: () => !1,
        isFile: () => isPathAFile,
        isSocket: () => !1,
        isSymbolicLink: () => !1
      });
    }).catch((err) => callback(err, null));
  };
  return new Proxy(fs_1$1.default, {
    get(_target, prop) {
      switch (prop) {
        case "readdir":
          return readdir;
        case "lstat":
        case "stat":
          return stat;
        default:
          throw new Error("Not Implemented");
      }
    }
  });
}
getGlobFs$1.getGlobFs = getGlobFs;
var __importDefault$3 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(getWorkspacePackagePaths$1, "__esModule", { value: !0 });
getWorkspacePackagePaths$1.getWorkspacePackagePaths = void 0;
const path_1$2 = __importDefault$3(require$$0__default.default), js_yaml_1 = __importDefault$3(jsYaml$2), glob_1$1 = __importDefault$3(requireGlob$1()), json5_1$1 = __importDefault$3(require$$4$2), get_glob_fs_1 = getGlobFs$1, posixPath = path_1$2.default.posix;
async function getWorkspacePackagePaths({ fs: fs2, workspace }) {
  const { type: type2, rootPath } = workspace, workspaceFs = fs2.chdir(rootPath);
  let results = [];
  switch (type2) {
    case "yarn":
    case "npm":
      results = await getPackageJsonWorkspacePackagePaths({ fs: workspaceFs });
      break;
    case "pnpm":
      results = await getPnpmWorkspacePackagePaths({ fs: workspaceFs });
      break;
    case "nx":
      results = await getNxWorkspacePackagePaths({ fs: workspaceFs });
      break;
    case "rush":
      results = await getRushWorkspacePackagePaths({ fs: workspaceFs });
      break;
    default:
      throw new Error(`Unknown workspace implementation: ${type2}`);
  }
  return results.map((packagePath) => posixPath.join(rootPath, posixPath.dirname(packagePath)));
}
getWorkspacePackagePaths$1.getWorkspacePackagePaths = getWorkspacePackagePaths;
const isWin$2 = process.platform === "win32", normalizePath = (p) => isWin$2 ? p.replace(/\\/g, "/") : p;
async function getPackagePaths(packages, fs2) {
  return (await Promise.all(packages.map((packageGlob) => new Promise((resolve2, reject) => {
    (0, glob_1$1.default)(normalizePath(posixPath.join(packageGlob, "package.json")), {
      cwd: "/",
      fs: (0, get_glob_fs_1.getGlobFs)(fs2)
    }, (err, matches2) => {
      err ? reject(err) : resolve2(matches2);
    });
  })))).flat();
}
async function getPackageJsonWorkspacePackagePaths({ fs: fs2 }) {
  const packageJsonAsBuffer = await fs2.readFile("package.json"), { workspaces } = JSON.parse(packageJsonAsBuffer.toString());
  let packages = [];
  return Array.isArray(workspaces) ? packages = workspaces : packages = workspaces?.packages ?? [], getPackagePaths(packages, fs2);
}
async function getNxWorkspacePackagePaths({ fs: fs2 }) {
  const nxWorkspaceJsonAsBuffer = await fs2.readFile("workspace.json"), { projects } = JSON.parse(nxWorkspaceJsonAsBuffer.toString()), packages = Object.values(projects);
  return getPackagePaths(packages, fs2);
}
async function getPnpmWorkspacePackagePaths({ fs: fs2 }) {
  const pnpmWorkspaceAsBuffer = await fs2.readFile("pnpm-workspace.yaml"), { packages = [] } = js_yaml_1.default.load(pnpmWorkspaceAsBuffer.toString());
  return getPackagePaths(packages, fs2);
}
async function getRushWorkspacePackagePaths({ fs: fs2 }) {
  const rushWorkspaceAsBuffer = await fs2.readFile("rush.json"), { projects = [] } = json5_1$1.default.parse(rushWorkspaceAsBuffer.toString());
  if (Array.isArray(projects)) {
    const packages = projects.filter((proj) => proj.projectFolder).map((project) => project.projectFolder);
    return getPackagePaths(packages, fs2);
  } else
    return [];
}
var monorepoManagers = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.monorepoManagers = void 0, exports2.monorepoManagers = [
    {
      name: "Turborepo",
      slug: "turbo",
      logo: "https://api-frameworks.vercel.sh/monorepo-logos/turborepo.svg",
      darkModeLogo: "https://api-frameworks.vercel.sh/monorepo-logos/turborepo-dark.svg",
      detectors: {
        some: [
          {
            path: "turbo.json"
          },
          {
            path: "package.json",
            matchContent: '"turbo":\\s*{[^}]*.+[^}]*}'
          }
        ]
      },
      settings: {
        buildCommand: {
          placeholder: "Turborepo default",
          value: null
        },
        outputDirectory: {
          value: null
        },
        installCommand: {
          value: null
        },
        devCommand: {
          value: null
        }
      }
    },
    {
      name: "Nx",
      slug: "nx",
      logo: "https://api-frameworks.vercel.sh/monorepo-logos/nx.svg",
      detectors: {
        every: [
          {
            path: "nx.json"
          }
        ]
      },
      settings: {
        buildCommand: {
          placeholder: "Nx default",
          value: null
        },
        outputDirectory: {
          value: null
        },
        installCommand: {
          value: null
        },
        devCommand: {
          value: null
        }
      }
    },
    {
      name: "Rush",
      slug: "rush",
      logo: "https://api-frameworks.vercel.sh/monorepo-logos/rush.svg",
      detectors: {
        every: [
          {
            path: "rush.json"
          }
        ]
      },
      settings: {
        buildCommand: {
          placeholder: "Rush default",
          value: null
        },
        outputDirectory: {
          value: null
        },
        installCommand: {
          placeholder: "Rush default"
        },
        devCommand: {
          value: null
        }
      }
    }
  ], exports2.default = exports2.monorepoManagers;
})(monorepoManagers);
var packageManagers = {};
Object.defineProperty(packageManagers, "__esModule", { value: !0 });
packageManagers.packageManagers = void 0;
packageManagers.packageManagers = [
  {
    name: "npm",
    slug: "npm",
    logo: "",
    darkModeLogo: "",
    detectors: {
      some: [
        {
          path: "package-lock.json"
        },
        {
          path: "package.json",
          matchContent: '"packageManager":\\s*"npm@.*"'
        }
      ]
    }
  },
  {
    name: "pnpm",
    slug: "pnpm",
    logo: "",
    darkModeLogo: "",
    detectors: {
      some: [
        {
          path: "pnpm-lock.yaml"
        },
        {
          path: "package.json",
          matchContent: '"packageManager":\\s*"pnpm@.*"'
        }
      ]
    }
  },
  {
    name: "yarn",
    slug: "yarn",
    logo: "",
    darkModeLogo: "",
    detectors: {
      some: [
        {
          path: "yarn.lock"
        },
        {
          path: "package.json",
          matchContent: '"packageManager":\\s*"yarn@.*"'
        },
        {
          path: "package.json"
        }
      ]
    }
  }
];
var getMonorepoDefaultSettings$1 = {}, __importDefault$2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(getMonorepoDefaultSettings$1, "__esModule", { value: !0 });
getMonorepoDefaultSettings$1.getMonorepoDefaultSettings = getMonorepoDefaultSettings$1.MissingBuildTarget = getMonorepoDefaultSettings$1.MissingBuildPipeline = void 0;
const path_1$1 = require$$0__default.default, monorepo_managers_1 = monorepoManagers, package_managers_1 = packageManagers, detect_framework_1 = detectFramework$1, json5_1 = __importDefault$2(require$$4$2), semver_1 = __importDefault$2(semver__default.default);
class MissingBuildPipeline extends Error {
  constructor() {
    super("Missing required `build` pipeline in turbo.json or package.json Turbo configuration.");
  }
}
getMonorepoDefaultSettings$1.MissingBuildPipeline = MissingBuildPipeline;
class MissingBuildTarget extends Error {
  constructor() {
    super("Missing required `build` target in either nx.json, project.json, or package.json Nx configuration.");
  }
}
getMonorepoDefaultSettings$1.MissingBuildTarget = MissingBuildTarget;
function supportsRootCommand(turboSemVer) {
  return !turboSemVer || !semver_1.default.validRange(turboSemVer) ? !1 : !semver_1.default.intersects(turboSemVer, "<1.8.0");
}
async function getMonorepoDefaultSettings(projectName, projectPath, relativeToRoot, detectorFilesystem) {
  const [monorepoManager, packageManager] = await Promise.all([
    (0, detect_framework_1.detectFramework)({
      fs: detectorFilesystem,
      frameworkList: monorepo_managers_1.monorepoManagers
    }),
    (0, detect_framework_1.detectFramework)({
      fs: detectorFilesystem,
      frameworkList: package_managers_1.packageManagers
    })
  ]);
  if (monorepoManager === "turbo") {
    const [turboJSONBuf, packageJSONBuf] = await Promise.all([
      detectorFilesystem.readFile("turbo.json").catch(() => null),
      detectorFilesystem.readFile("package.json").catch(() => null)
    ]);
    let hasBuildPipeline = !1, turboSemVer = null;
    if (turboJSONBuf !== null && json5_1.default.parse(turboJSONBuf.toString("utf-8"))?.pipeline?.build && (hasBuildPipeline = !0), packageJSONBuf !== null) {
      const packageJSON = JSON.parse(packageJSONBuf.toString("utf-8"));
      packageJSON?.turbo?.pipeline?.build && (hasBuildPipeline = !0), turboSemVer = packageJSON?.dependencies?.turbo || packageJSON?.devDependencies?.turbo || null;
    }
    if (!hasBuildPipeline)
      throw new MissingBuildPipeline();
    if (projectPath === "/")
      return {
        monorepoManager: "turbo",
        buildCommand: "turbo run build",
        installCommand: packageManager ? `${packageManager} install` : null,
        commandForIgnoringBuildStep: "npx turbo-ignore"
      };
    let buildCommand = null;
    return projectPath && (supportsRootCommand(turboSemVer) ? buildCommand = "turbo run build" : buildCommand = `cd ${relativeToRoot} && turbo run build --filter={${projectPath}}...`), {
      monorepoManager: "turbo",
      buildCommand,
      installCommand: packageManager === "npm" ? `${packageManager} install --prefix=${relativeToRoot}` : packageManager ? `${packageManager} install` : null,
      commandForIgnoringBuildStep: "npx turbo-ignore"
    };
  } else if (monorepoManager === "nx") {
    const nxJSONBuf = await detectorFilesystem.readFile("nx.json");
    if (!json5_1.default.parse(nxJSONBuf.toString("utf-8"))?.targetDefaults?.build) {
      const [projectJSONBuf, packageJSONBuf] = await Promise.all([
        detectorFilesystem.readFile((0, path_1$1.join)(projectPath, "project.json")).catch(() => null),
        detectorFilesystem.readFile((0, path_1$1.join)(projectPath, "package.json")).catch(() => null)
      ]);
      let hasBuildTarget = !1;
      if (projectJSONBuf && json5_1.default.parse(projectJSONBuf.toString("utf-8"))?.targets?.build && (hasBuildTarget = !0), packageJSONBuf) {
        const packageJSON = json5_1.default.parse(packageJSONBuf.toString("utf-8"));
        packageJSON?.nx && packageJSON.nx.targets?.build && (hasBuildTarget = !0);
      }
      if (!hasBuildTarget)
        throw new MissingBuildTarget();
    }
    return projectPath === "/" ? {
      monorepoManager: "nx",
      buildCommand: "npx nx build",
      installCommand: packageManager ? `${packageManager} install` : null
    } : {
      monorepoManager: "nx",
      buildCommand: projectName ? `cd ${relativeToRoot} && npx nx build ${projectName}` : null,
      installCommand: packageManager === "npm" ? `${packageManager} install --prefix=${relativeToRoot}` : packageManager ? `${packageManager} install` : null
    };
  }
  return null;
}
getMonorepoDefaultSettings$1.getMonorepoDefaultSettings = getMonorepoDefaultSettings;
var hasRequiredDist;
function requireDist() {
  return hasRequiredDist || (hasRequiredDist = 1, function(exports2) {
    var __createBinding2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__exportStar || function(m, exports3) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.packageManagers = exports2.isStaticRuntime = exports2.isOfficialRuntime = exports2.monorepoManagers = exports2.getWorkspacePackagePaths = exports2.getWorkspaces = exports2.workspaceManagers = exports2.LocalFileSystemDetector = exports2.DetectorFilesystem = exports2.getProjectPaths = exports2.detectFrameworkVersion = exports2.detectFrameworkRecord = exports2.detectFrameworks = exports2.detectFramework = exports2.detectFileSystemAPI = exports2.detectApiExtensions = exports2.detectApiDirectory = exports2.detectOutputDirectory = exports2.detectBuilders = void 0;
    var detect_builders_1 = detectBuilders$1;
    Object.defineProperty(exports2, "detectBuilders", { enumerable: !0, get: function() {
      return detect_builders_1.detectBuilders;
    } }), Object.defineProperty(exports2, "detectOutputDirectory", { enumerable: !0, get: function() {
      return detect_builders_1.detectOutputDirectory;
    } }), Object.defineProperty(exports2, "detectApiDirectory", { enumerable: !0, get: function() {
      return detect_builders_1.detectApiDirectory;
    } }), Object.defineProperty(exports2, "detectApiExtensions", { enumerable: !0, get: function() {
      return detect_builders_1.detectApiExtensions;
    } });
    var detect_file_system_api_1 = requireDetectFileSystemApi();
    Object.defineProperty(exports2, "detectFileSystemAPI", { enumerable: !0, get: function() {
      return detect_file_system_api_1.detectFileSystemAPI;
    } });
    var detect_framework_12 = detectFramework$1;
    Object.defineProperty(exports2, "detectFramework", { enumerable: !0, get: function() {
      return detect_framework_12.detectFramework;
    } }), Object.defineProperty(exports2, "detectFrameworks", { enumerable: !0, get: function() {
      return detect_framework_12.detectFrameworks;
    } }), Object.defineProperty(exports2, "detectFrameworkRecord", { enumerable: !0, get: function() {
      return detect_framework_12.detectFrameworkRecord;
    } }), Object.defineProperty(exports2, "detectFrameworkVersion", { enumerable: !0, get: function() {
      return detect_framework_12.detectFrameworkVersion;
    } });
    var get_project_paths_1 = getProjectPaths;
    Object.defineProperty(exports2, "getProjectPaths", { enumerable: !0, get: function() {
      return get_project_paths_1.getProjectPaths;
    } });
    var filesystem_12 = filesystem;
    Object.defineProperty(exports2, "DetectorFilesystem", { enumerable: !0, get: function() {
      return filesystem_12.DetectorFilesystem;
    } });
    var local_file_system_detector_1 = localFileSystemDetector;
    Object.defineProperty(exports2, "LocalFileSystemDetector", { enumerable: !0, get: function() {
      return local_file_system_detector_1.LocalFileSystemDetector;
    } });
    var workspace_managers_12 = workspaceManagers;
    Object.defineProperty(exports2, "workspaceManagers", { enumerable: !0, get: function() {
      return workspace_managers_12.workspaceManagers;
    } });
    var get_workspaces_1 = getWorkspaces$1;
    Object.defineProperty(exports2, "getWorkspaces", { enumerable: !0, get: function() {
      return get_workspaces_1.getWorkspaces;
    } });
    var get_workspace_package_paths_1 = getWorkspacePackagePaths$1;
    Object.defineProperty(exports2, "getWorkspacePackagePaths", { enumerable: !0, get: function() {
      return get_workspace_package_paths_1.getWorkspacePackagePaths;
    } });
    var monorepo_managers_12 = monorepoManagers;
    Object.defineProperty(exports2, "monorepoManagers", { enumerable: !0, get: function() {
      return monorepo_managers_12.monorepoManagers;
    } });
    var is_official_runtime_12 = isOfficialRuntime;
    Object.defineProperty(exports2, "isOfficialRuntime", { enumerable: !0, get: function() {
      return is_official_runtime_12.isOfficialRuntime;
    } }), Object.defineProperty(exports2, "isStaticRuntime", { enumerable: !0, get: function() {
      return is_official_runtime_12.isStaticRuntime;
    } });
    var package_managers_12 = packageManagers;
    Object.defineProperty(exports2, "packageManagers", { enumerable: !0, get: function() {
      return package_managers_12.packageManagers;
    } }), __exportStar2(getMonorepoDefaultSettings$1, exports2);
  }(dist$1)), dist$1;
}
var distExports = requireDist();
const request = require$$1$3.getIt([require$$2$1.promise()]);
async function bootstrapFromTemplate(context, url2) {
  const { prompt: prompt2, workDir } = context, cliVersion = await getCliVersion();
  let inProjectContext = !1;
  try {
    inProjectContext = !!(await readJson(path__default.default.join(workDir, "sanity.json"))).root;
  } catch {
  }
  loadEnv.debug(inProjectContext ? "Project context found" : "Not in project context");
  let zip2;
  try {
    loadEnv.debug("Fetching zip from %s", url2), zip2 = await getZip(url2), loadEnv.debug("Zip finished downloading");
  } catch (err) {
    throw err.message = `Failed to get template: ${err.message}`, err;
  }
  loadEnv.debug("Looking up template manifest from zip");
  const manifest = zip2.find(
    (file2) => path__default.default.basename(file2.path) === "package.json" && !file2.path.includes("node_modules")
  );
  if (!manifest)
    throw new Error("Could not find `package.json` in template");
  const baseDir = `${path__default.default.dirname(manifest.path)}/template`;
  loadEnv.debug("Manifest path resolved to %s", manifest.path), loadEnv.debug("Base directory resolved to %s", baseDir);
  const templateFiles = zip2.filter(
    (file2) => file2.type === "file" && file2.path.indexOf(baseDir) === 0
  );
  loadEnv.debug("%d files found in template", templateFiles.length);
  const tplVars = parseJson(manifest.data.toString())?.sanityTemplate || {}, { minimumBaseVersion, minimumCliVersion } = tplVars;
  if (minimumBaseVersion) {
    loadEnv.debug("Template requires Sanity version %s", minimumBaseVersion);
    const installed = getSanityVersion(workDir, cliVersion);
    if (loadEnv.debug("Installed Sanity version is %s", installed), semver__default.default.lt(installed, minimumBaseVersion))
      throw new Error(
        `Template requires Sanity at version ${minimumBaseVersion}, installed is ${installed}`
      );
  }
  if (minimumCliVersion && (loadEnv.debug("Template requires Sanity CLI version %s", minimumCliVersion), loadEnv.debug("Installed CLI version is %s", cliVersion), semver__default.default.lt(cliVersion, minimumCliVersion)))
    throw new Error(
      `Template requires @sanity/cli at version ${minimumCliVersion}, installed is ${cliVersion}`
    );
  const name = await prompt2.single({
    type: "input",
    message: "Plugin name:",
    default: tplVars.suggestedName || "",
    validate: async (pkgName) => {
      const { validForNewPackages } = validateNpmPackageName__default.default(pkgName);
      if (!validForNewPackages)
        return "Name must be a valid npm package name (https://docs.npmjs.com/files/package.json#name)";
      const outputPath2 = path__default.default.join(workDir, "plugins", pkgName), isEmpty2 = await fs$q.pathIsEmpty(outputPath2);
      return inProjectContext && !isEmpty2 ? "Plugin with given name already exists in project" : !0;
    }
  });
  let outputPath = path__default.default.join(workDir, "plugins", name);
  if (!inProjectContext) {
    const cwdIsEmpty = await fs$q.pathIsEmpty(workDir);
    outputPath = await prompt2.single({
      type: "input",
      message: "Output path:",
      default: cwdIsEmpty ? workDir : path__default.default.join(workDir, name),
      validate: validateEmptyPath$1,
      filter: fs$q.absolutify
    });
  }
  loadEnv.debug("Output path set to %s", outputPath);
  let createConfig = tplVars.requiresConfig;
  return typeof createConfig > "u" && (createConfig = await prompt2.single({
    type: "confirm",
    message: "Does the plugin need a configuration file?",
    default: !1
  })), loadEnv.debug("Ensuring directory exists: %s", outputPath), await fs__default$1.default.mkdir(outputPath, { recursive: !0 }), await Promise.all(
    templateFiles.map((file2) => {
      const filename = file2.path.slice(baseDir.length);
      return loadEnv.debug('Writing template file "%s" to "%s"', filename, outputPath), fs__default$1.default.writeFile(path__default.default.join(outputPath, filename), file2.data);
    })
  ), { name, outputPath, inPluginsPath: inProjectContext, dependencies: tplVars.dependencies };
}
async function validateEmptyPath$1(dir) {
  return await fs$q.pathIsEmpty(dir) ? !0 : "Path is not empty";
}
function getZip(url2) {
  return request({ url: url2, rawBody: !0 }).then(
    (res) => {
      if (res.statusCode > 299) {
        const httpErr = ["HTTP", res.statusCode, res.statusMessage].filter(Boolean).join(" ");
        throw new Error(`${httpErr} trying to download ${url2}`);
      }
      return decompress__default.default(res.body);
    }
  );
}
function parseJson(json2) {
  try {
    return JSON.parse(json2);
  } catch {
    return;
  }
}
function getSanityVersion(workDir, fallback2) {
  const basePkg = resolveFrom$1.silent(workDir, "@sanity/base/package.json");
  return basePkg ? getCliConfig.dynamicRequire(basePkg).version : fallback2;
}
const pluginTemplates = [
  {
    value: "logo",
    name: "Studio logo",
    url: "https://github.com/sanity-io/plugin-template-logo/archive/master.zip"
  },
  {
    value: "tool",
    name: "Basic, empty tool",
    url: "https://github.com/sanity-io/plugin-template-tool/archive/master.zip"
  },
  {
    value: "toolWithRouting",
    name: "Tool with basic routing",
    url: "https://github.com/sanity-io/plugin-template-tool-with-routing/archive/master.zip"
  },
  {
    value: "chessInput",
    name: "Chess board input component w/ block preview",
    url: "https://github.com/sanity-io/plugin-template-chess-input/archive/master.zip"
  },
  {
    value: "dashboardWidget",
    name: "A Dashboard widget with cats",
    url: "https://github.com/sanity-io/plugin-template-dashboard-widget-cats/archive/master.zip"
  },
  {
    value: "assetSource",
    name: "Custom asset source plugin",
    url: "https://github.com/sanity-io/plugin-template-asset-source/archive/master.zip"
  }
];
async function initPlugin(args, context) {
  const { output, prompt: prompt2 } = context, [, specifiedTemplateUrl] = args.argsWithoutOptions;
  if (output.print("This utility will walk you through creating a new Sanity plugin."), output.print(`Press ^C at any time to quit.
`), /^https?:\/\//.test(specifiedTemplateUrl || ""))
    return loadEnv.debug("User provided template URL: %s", specifiedTemplateUrl), bootstrapFromUrl(context, specifiedTemplateUrl);
  let specifiedTemplate = null;
  if (specifiedTemplateUrl && (specifiedTemplate = pluginTemplates.find((tpl) => tpl.value === specifiedTemplateUrl)), specifiedTemplate)
    return loadEnv.debug(
      'User wanted template "%s", match found at %s',
      specifiedTemplateUrl,
      specifiedTemplate.url
    ), bootstrapFromUrl(context, specifiedTemplate.url);
  if (specifiedTemplateUrl)
    throw new Error(`Cannot find template with name "${specifiedTemplateUrl}"`);
  const templateChoices = pluginTemplates.map(({ value, name }) => ({ value, name })), selected = await prompt2.single({
    message: "Select template to use",
    type: "list",
    choices: templateChoices
  });
  if (specifiedTemplate = pluginTemplates.find((tpl) => tpl.value === selected), !specifiedTemplate)
    throw new Error("No template selected");
  return loadEnv.debug("User selected template URL: %s", specifiedTemplate.url), bootstrapFromUrl(context, specifiedTemplate.url);
}
async function bootstrapFromUrl(context, url2) {
  const { output, prompt: prompt2, yarn, workDir } = context;
  loadEnv.debug("Bootstrapping from URL: %s", url2);
  const { name, outputPath, inPluginsPath, dependencies } = await bootstrapFromTemplate(context, url2);
  if (inPluginsPath && await prompt2.single({
    type: "confirm",
    message: "Enable plugin in current Sanity installation?",
    default: !0
  }) && await addPluginToManifest(workDir, name.replace(/^sanity-plugin-/, "")), dependencies) {
    const dependencyString = JSON.stringify(dependencies, null, 2).split(`
`).slice(1, -1).join(`
`).replace(/"/g, "");
    output.print(`
The following dependencies are required for this template:`), output.print(`${dependencyString}
`);
  }
  if (dependencies && inPluginsPath && await prompt2.single({
    type: "confirm",
    message: "Install dependencies in current project?",
    default: !0
  })) {
    const deps = Object.keys(dependencies).map((dep) => `${dep}@${dependencies[dep]}`);
    await yarn(["add"].concat(deps), { ...output, rootDir: workDir }), output.print("Dependencies installed."), output.print("Remember to remove them from `package.json` if you no longer need them!");
  }
  output.print(`
Success! Plugin initialized at ${outputPath}`);
}
async function addPluginToManifest(sanityDir, pluginName) {
  const manifestPath = path__default.default.join(sanityDir, "sanity.json"), manifest = JSON.parse(await fs__default$1.default.readFile(manifestPath, "utf8"));
  return manifest.plugins = manifest.plugins || [], manifest.plugins.indexOf(pluginName) === -1 && manifest.plugins.push(pluginName), await fs__default$1.default.writeFile(manifestPath, JSON.stringify(manifest, null, 2)), manifest;
}
var execa$2 = { exports: {} }, crossSpawn$1 = { exports: {} }, windows, hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows) return windows;
  hasRequiredWindows = 1, windows = isexe2, isexe2.sync = sync2;
  var fs2 = require$$0__default$1.default;
  function checkPathExt(path2, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext || (pathext = pathext.split(";"), pathext.indexOf("") !== -1))
      return !0;
    for (var i2 = 0; i2 < pathext.length; i2++) {
      var p = pathext[i2].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p)
        return !0;
    }
    return !1;
  }
  function checkStat(stat, path2, options2) {
    return !stat.isSymbolicLink() && !stat.isFile() ? !1 : checkPathExt(path2, options2);
  }
  function isexe2(path2, options2, cb) {
    fs2.stat(path2, function(er, stat) {
      cb(er, er ? !1 : checkStat(stat, path2, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), path2, options2);
  }
  return windows;
}
var mode, hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1, mode = isexe2, isexe2.sync = sync2;
  var fs2 = require$$0__default$1.default;
  function isexe2(path2, options2, cb) {
    fs2.stat(path2, function(er, stat) {
      cb(er, er ? !1 : checkStat(stat, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), options2);
  }
  function checkStat(stat, options2) {
    return stat.isFile() && checkMode(stat, options2);
  }
  function checkMode(stat, options2) {
    var mod = stat.mode, uid = stat.uid, gid = stat.gid, myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid(), myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g, ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var core$4;
process.platform === "win32" || loadEnv.commonjsGlobal.TESTING_WINDOWS ? core$4 = requireWindows() : core$4 = requireMode();
var isexe_1 = isexe$1;
isexe$1.sync = sync$1;
function isexe$1(path2, options2, cb) {
  if (typeof options2 == "function" && (cb = options2, options2 = {}), !cb) {
    if (typeof Promise != "function")
      throw new TypeError("callback not provided");
    return new Promise(function(resolve2, reject) {
      isexe$1(path2, options2 || {}, function(er, is) {
        er ? reject(er) : resolve2(is);
      });
    });
  }
  core$4(path2, options2 || {}, function(er, is) {
    er && (er.code === "EACCES" || options2 && options2.ignoreErrors) && (er = null, is = !1), cb(er, is);
  });
}
function sync$1(path2, options2) {
  try {
    return core$4.sync(path2, options2 || {});
  } catch (er) {
    if (options2 && options2.ignoreErrors || er.code === "EACCES")
      return !1;
    throw er;
  }
}
const isWindows$1 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path$f = require$$0__default.default, COLON = isWindows$1 ? ";" : ":", isexe = isexe_1, getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows$1 && cmd.match(/\\/) ? [""] : [
    // windows always checks the cwd first
    ...isWindows$1 ? [process.cwd()] : [],
    ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
    "").split(colon)
  ], pathExtExe = isWindows$1 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows$1 ? pathExtExe.split(colon) : [""];
  return isWindows$1 && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
    pathEnv,
    pathExt,
    pathExtExe
  };
}, which$1 = (cmd, opt, cb) => {
  typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [], step = (i2) => new Promise((resolve2, reject) => {
    if (i2 === pathEnv.length)
      return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
    const ppRaw = pathEnv[i2], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path$f.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    resolve2(subStep(p, i2, 0));
  }), subStep = (p, i2, ii) => new Promise((resolve2, reject) => {
    if (ii === pathExt.length)
      return resolve2(step(i2 + 1));
    const ext2 = pathExt[ii];
    isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is)
        if (opt.all)
          found.push(p + ext2);
        else
          return resolve2(p + ext2);
      return resolve2(subStep(p, i2, ii + 1));
    });
  });
  return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
}, whichSync = (cmd, opt) => {
  opt = opt || {};
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
  for (let i2 = 0; i2 < pathEnv.length; i2++) {
    const ppRaw = pathEnv[i2], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path$f.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    for (let j = 0; j < pathExt.length; j++) {
      const cur = p + pathExt[j];
      try {
        if (isexe.sync(cur, { pathExt: pathExtExe }))
          if (opt.all)
            found.push(cur);
          else
            return cur;
      } catch {
      }
    }
  }
  if (opt.all && found.length)
    return found;
  if (opt.nothrow)
    return null;
  throw getNotFoundError(cmd);
};
var which_1 = which$1;
which$1.sync = whichSync;
var which$2 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(which_1), pathKey$1 = { exports: {} };
const pathKey = (options2 = {}) => {
  const environment = options2.env || process.env;
  return (options2.platform || process.platform) !== "win32" ? "PATH" : Object.keys(environment).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
};
pathKey$1.exports = pathKey;
pathKey$1.exports.default = pathKey;
var pathKeyExports = pathKey$1.exports;
const path$e = require$$0__default.default, which = which_1, getPathKey = pathKeyExports;
function resolveCommandAttempt(parsed, withoutPathExt) {
  const env = parsed.options.env || process.env, cwd2 = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
  if (shouldSwitchCwd)
    try {
      process.chdir(parsed.options.cwd);
    } catch {
    }
  let resolved;
  try {
    resolved = which.sync(parsed.command, {
      path: env[getPathKey({ env })],
      pathExt: withoutPathExt ? path$e.delimiter : void 0
    });
  } catch {
  } finally {
    shouldSwitchCwd && process.chdir(cwd2);
  }
  return resolved && (resolved = path$e.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
}
function resolveCommand$1(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
}
var resolveCommand_1 = resolveCommand$1, _escape = {};
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function escapeCommand(arg) {
  return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
  return arg = `${arg}`, arg = arg.replace(/(\\*)"/g, '$1$1\\"'), arg = arg.replace(/(\\*)$/, "$1$1"), arg = `"${arg}"`, arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
}
_escape.command = escapeCommand;
_escape.argument = escapeArgument;
var shebangRegex$1 = /^#!(.*)/;
const shebangRegex = shebangRegex$1;
var shebangCommand$1 = (string = "") => {
  const match3 = string.match(shebangRegex);
  if (!match3)
    return null;
  const [path2, argument] = match3[0].replace(/#! ?/, "").split(" "), binary2 = path2.split("/").pop();
  return binary2 === "env" ? argument : argument ? `${binary2} ${argument}` : binary2;
};
const fs$9 = require$$0__default$1.default, shebangCommand = shebangCommand$1;
function readShebang$1(command2) {
  const buffer2 = Buffer.alloc(150);
  let fd;
  try {
    fd = fs$9.openSync(command2, "r"), fs$9.readSync(fd, buffer2, 0, 150, 0), fs$9.closeSync(fd);
  } catch {
  }
  return shebangCommand(buffer2.toString());
}
var readShebang_1 = readShebang$1;
const path$d = require$$0__default.default, resolveCommand = resolveCommand_1, escape = _escape, readShebang = readShebang_1, isWin$1 = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  const shebang = parsed.file && readShebang(parsed.file);
  return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
}
function parseNonShell(parsed) {
  if (!isWin$1)
    return parsed;
  const commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
  if (parsed.options.forceShell || needsShell) {
    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
    parsed.command = path$d.normalize(parsed.command), parsed.command = escape.command(parsed.command), parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
  }
  return parsed;
}
function parse$9(command2, args, options2) {
  args && !Array.isArray(args) && (options2 = args, args = null), args = args ? args.slice(0) : [], options2 = Object.assign({}, options2);
  const parsed = {
    command: command2,
    args,
    options: options2,
    file: void 0,
    original: {
      command: command2,
      args
    }
  };
  return options2.shell ? parsed : parseNonShell(parsed);
}
var parse_1$3 = parse$9;
const isWin = process.platform === "win32";
function notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}
function hookChildProcess(cp2, parsed) {
  if (!isWin)
    return;
  const originalEmit = cp2.emit;
  cp2.emit = function(name, arg1) {
    if (name === "exit") {
      const err = verifyENOENT(arg1, parsed);
      if (err)
        return originalEmit.call(cp2, "error", err);
    }
    return originalEmit.apply(cp2, arguments);
  };
}
function verifyENOENT(status, parsed) {
  return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
}
function verifyENOENTSync(status, parsed) {
  return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
}
var enoent$1 = {
  hookChildProcess,
  verifyENOENT,
  verifyENOENTSync,
  notFoundError
};
const cp = require$$0__default$7.default, parse$8 = parse_1$3, enoent = enoent$1;
function spawn(command2, args, options2) {
  const parsed = parse$8(command2, args, options2), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
  return enoent.hookChildProcess(spawned, parsed), spawned;
}
function spawnSync(command2, args, options2) {
  const parsed = parse$8(command2, args, options2), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
  return result.error = result.error || enoent.verifyENOENTSync(result.status, parsed), result;
}
crossSpawn$1.exports = spawn;
crossSpawn$1.exports.spawn = spawn;
crossSpawn$1.exports.sync = spawnSync;
crossSpawn$1.exports._parse = parse$8;
crossSpawn$1.exports._enoent = enoent;
var crossSpawnExports = crossSpawn$1.exports, stripFinalNewline$1 = (input2) => {
  const LF = typeof input2 == "string" ? `
` : 10, CR = typeof input2 == "string" ? "\r" : 13;
  return input2[input2.length - 1] === LF && (input2 = input2.slice(0, input2.length - 1)), input2[input2.length - 1] === CR && (input2 = input2.slice(0, input2.length - 1)), input2;
}, npmRunPath$1 = { exports: {} };
(function(module2) {
  const path2 = require$$0__default.default, pathKey2 = pathKeyExports, npmRunPath2 = (options2) => {
    options2 = {
      cwd: process.cwd(),
      path: process.env[pathKey2()],
      ...options2
    };
    let previous, cwdPath = path2.resolve(options2.cwd);
    const result = [];
    for (; previous !== cwdPath; )
      result.push(path2.join(cwdPath, "node_modules/.bin")), previous = cwdPath, cwdPath = path2.resolve(cwdPath, "..");
    return result.push(path2.dirname(process.execPath)), result.concat(options2.path).join(path2.delimiter);
  };
  module2.exports = npmRunPath2, module2.exports.default = npmRunPath2, module2.exports.env = (options2) => {
    options2 = {
      env: process.env,
      ...options2
    };
    const env = { ...options2.env }, path3 = pathKey2({ env });
    return options2.path = env[path3], env[path3] = module2.exports(options2), env;
  };
})(npmRunPath$1);
var npmRunPathExports = npmRunPath$1.exports, onetime$4 = { exports: {} }, mimicFn$3 = { exports: {} };
const mimicFn$2 = (to, from2) => {
  for (const prop of Reflect.ownKeys(from2))
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from2, prop));
  return to;
};
mimicFn$3.exports = mimicFn$2;
mimicFn$3.exports.default = mimicFn$2;
var mimicFnExports = mimicFn$3.exports;
const mimicFn$1 = mimicFnExports, calledFunctions = /* @__PURE__ */ new WeakMap(), onetime$3 = (function_, options2 = {}) => {
  if (typeof function_ != "function")
    throw new TypeError("Expected a function");
  let returnValue, callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>", onetime2 = function(...arguments_) {
    if (calledFunctions.set(onetime2, ++callCount), callCount === 1)
      returnValue = function_.apply(this, arguments_), function_ = null;
    else if (options2.throw === !0)
      throw new Error(`Function \`${functionName}\` can only be called once`);
    return returnValue;
  };
  return mimicFn$1(onetime2, function_), calledFunctions.set(onetime2, callCount), onetime2;
};
onetime$4.exports = onetime$3;
onetime$4.exports.default = onetime$3;
onetime$4.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_))
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  return calledFunctions.get(function_);
};
var onetimeExports = onetime$4.exports;
const os$3 = require$$0__default$2.default, util$4 = require$$0__default$5.default, getCode = (error2, code) => error2 && error2.code ? [error2.code, os$3.constants.errno[error2.code]] : Number.isInteger(code) ? [util$4.getSystemErrorName(-code), code] : [], getErrorPrefix = ({ timedOut, timeout: timeout2, signal, exitCodeName, exitCode, isCanceled }) => timedOut ? `timed out after ${timeout2} milliseconds` : isCanceled ? "was canceled" : signal ? `was killed with ${signal}` : exitCode !== void 0 ? `failed with exit code ${exitCode} (${exitCodeName})` : "failed", makeError$1 = ({
  stdout,
  stderr,
  all,
  error: error2,
  signal,
  code,
  command: command2,
  timedOut,
  isCanceled,
  killed,
  parsed: { options: { timeout: timeout2 } }
}) => {
  const [exitCodeName, exitCode] = getCode(error2, code), message = `Command ${getErrorPrefix({ timedOut, timeout: timeout2, signal, exitCodeName, exitCode, isCanceled })}: ${command2}`;
  return error2 instanceof Error ? (error2.originalMessage = error2.message, error2.message = `${message}
${error2.message}`) : error2 = new Error(message), error2.command = command2, delete error2.code, error2.exitCode = exitCode, error2.exitCodeName = exitCodeName, error2.stdout = stdout, error2.stderr = stderr, all !== void 0 && (error2.all = all), "bufferedData" in error2 && delete error2.bufferedData, error2.failed = !0, error2.timedOut = !!timedOut, error2.isCanceled = isCanceled, error2.killed = killed && !timedOut, error2.signal = signal || void 0, error2;
};
var error = makeError$1, stdio = { exports: {} };
const aliases = ["stdin", "stdout", "stderr"], hasAlias = (opts) => aliases.some((alias) => opts[alias] !== void 0), normalizeStdio$1 = (opts) => {
  if (!opts)
    return;
  const { stdio: stdio2 } = opts;
  if (stdio2 === void 0)
    return aliases.map((alias) => opts[alias]);
  if (hasAlias(opts))
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
  if (typeof stdio2 == "string")
    return stdio2;
  if (!Array.isArray(stdio2))
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio2}\``);
  const length = Math.max(stdio2.length, aliases.length);
  return Array.from({ length }, (value, index) => stdio2[index]);
};
stdio.exports = normalizeStdio$1;
stdio.exports.node = (opts) => {
  const stdio2 = normalizeStdio$1(opts);
  return stdio2 === "ipc" ? "ipc" : stdio2 === void 0 || typeof stdio2 == "string" ? [stdio2, stdio2, stdio2, "ipc"] : stdio2.includes("ipc") ? stdio2 : [...stdio2, "ipc"];
};
var stdioExports = stdio.exports, pFinally$1 = async (promise2, onFinally = () => {
}) => {
  let value;
  try {
    value = await promise2;
  } catch (error2) {
    throw await onFinally(), error2;
  }
  return await onFinally(), value;
};
const os$2 = require$$0__default$2.default, onExit = signalExitExports, pFinally = pFinally$1, DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5, spawnedKill$1 = (kill2, signal = "SIGTERM", options2 = {}) => {
  const killResult = kill2(signal);
  return setKillTimeout(kill2, signal, options2, killResult), killResult;
}, setKillTimeout = (kill2, signal, options2, killResult) => {
  if (!shouldForceKill(signal, options2, killResult))
    return;
  const timeout2 = getForceKillAfterTimeout(options2);
  setTimeout(() => {
    kill2("SIGKILL");
  }, timeout2).unref();
}, shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== !1 && killResult, isSigterm = (signal) => signal === os$2.constants.signals.SIGTERM || typeof signal == "string" && signal.toUpperCase() === "SIGTERM", getForceKillAfterTimeout = ({ forceKillAfterTimeout = !0 }) => {
  if (forceKillAfterTimeout === !0)
    return DEFAULT_FORCE_KILL_TIMEOUT;
  if (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0)
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
  return forceKillAfterTimeout;
}, spawnedCancel$1 = (spawned, context) => {
  spawned.kill() && (context.isCanceled = !0);
}, timeoutKill = (spawned, signal, reject) => {
  spawned.kill(signal), reject(Object.assign(new Error("Timed out"), { timedOut: !0, signal }));
}, setupTimeout$1 = (spawned, { timeout: timeout2, killSignal = "SIGTERM" }, spawnedPromise) => {
  if (timeout2 === 0 || timeout2 === void 0)
    return spawnedPromise;
  if (!Number.isInteger(timeout2) || timeout2 < 0)
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout2}\` (${typeof timeout2})`);
  let timeoutId;
  const timeoutPromise = new Promise((resolve2, reject) => {
    timeoutId = setTimeout(() => {
      timeoutKill(spawned, killSignal, reject);
    }, timeout2);
  }), safeSpawnedPromise = pFinally(spawnedPromise, () => {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
}, setExitHandler$1 = (spawned, { cleanup, detached }, timedPromise) => {
  if (!cleanup || detached)
    return timedPromise;
  const removeExitHandler = onExit(() => {
    spawned.kill();
  });
  return pFinally(timedPromise, removeExitHandler);
};
var kill = {
  spawnedKill: spawnedKill$1,
  spawnedCancel: spawnedCancel$1,
  setupTimeout: setupTimeout$1,
  setExitHandler: setExitHandler$1
};
const isStream$1 = (stream2) => stream2 !== null && typeof stream2 == "object" && typeof stream2.pipe == "function";
isStream$1.writable = (stream2) => isStream$1(stream2) && stream2.writable !== !1 && typeof stream2._write == "function" && typeof stream2._writableState == "object";
isStream$1.readable = (stream2) => isStream$1(stream2) && stream2.readable !== !1 && typeof stream2._read == "function" && typeof stream2._readableState == "object";
isStream$1.duplex = (stream2) => isStream$1.writable(stream2) && isStream$1.readable(stream2);
isStream$1.transform = (stream2) => isStream$1.duplex(stream2) && typeof stream2._transform == "function";
var isStream_1 = isStream$1, getStream$2 = { exports: {} }, once$1 = requireOnce(), noop$2 = function() {
}, isRequest$1 = function(stream2) {
  return stream2.setHeader && typeof stream2.abort == "function";
}, isChildProcess = function(stream2) {
  return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
}, eos$1 = function(stream2, opts, callback) {
  if (typeof opts == "function") return eos$1(stream2, null, opts);
  opts || (opts = {}), callback = once$1(callback || noop$2);
  var ws = stream2._writableState, rs = stream2._readableState, readable2 = opts.readable || opts.readable !== !1 && stream2.readable, writable = opts.writable || opts.writable !== !1 && stream2.writable, cancelled = !1, onlegacyfinish = function() {
    stream2.writable || onfinish();
  }, onfinish = function() {
    writable = !1, readable2 || callback.call(stream2);
  }, onend = function() {
    readable2 = !1, writable || callback.call(stream2);
  }, onexit = function(exitCode) {
    callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
  }, onerror = function(err) {
    callback.call(stream2, err);
  }, onclose = function() {
    process.nextTick(onclosenexttick);
  }, onclosenexttick = function() {
    if (!cancelled) {
      if (readable2 && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream2, new Error("premature close"));
      if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream2, new Error("premature close"));
    }
  }, onrequest = function() {
    stream2.req.on("finish", onfinish);
  };
  return isRequest$1(stream2) ? (stream2.on("complete", onfinish), stream2.on("abort", onclose), stream2.req ? onrequest() : stream2.on("request", onrequest)) : writable && !ws && (stream2.on("end", onlegacyfinish), stream2.on("close", onlegacyfinish)), isChildProcess(stream2) && stream2.on("exit", onexit), stream2.on("end", onend), stream2.on("finish", onfinish), opts.error !== !1 && stream2.on("error", onerror), stream2.on("close", onclose), function() {
    cancelled = !0, stream2.removeListener("complete", onfinish), stream2.removeListener("abort", onclose), stream2.removeListener("request", onrequest), stream2.req && stream2.req.removeListener("finish", onfinish), stream2.removeListener("end", onlegacyfinish), stream2.removeListener("close", onlegacyfinish), stream2.removeListener("finish", onfinish), stream2.removeListener("exit", onexit), stream2.removeListener("end", onend), stream2.removeListener("error", onerror), stream2.removeListener("close", onclose);
  };
}, endOfStream$1 = eos$1, once = requireOnce(), eos = endOfStream$1, fs$8 = require$$0__default$1.default, noop$1 = function() {
}, ancient = /^v?\.0/.test(process.version), isFn = function(fn2) {
  return typeof fn2 == "function";
}, isFS = function(stream2) {
  return !ancient || !fs$8 ? !1 : (stream2 instanceof (fs$8.ReadStream || noop$1) || stream2 instanceof (fs$8.WriteStream || noop$1)) && isFn(stream2.close);
}, isRequest = function(stream2) {
  return stream2.setHeader && isFn(stream2.abort);
}, destroyer = function(stream2, reading, writing, callback) {
  callback = once(callback);
  var closed = !1;
  stream2.on("close", function() {
    closed = !0;
  }), eos(stream2, { readable: reading, writable: writing }, function(err) {
    if (err) return callback(err);
    closed = !0, callback();
  });
  var destroyed = !1;
  return function(err) {
    if (!closed && !destroyed) {
      if (destroyed = !0, isFS(stream2)) return stream2.close(noop$1);
      if (isRequest(stream2)) return stream2.abort();
      if (isFn(stream2.destroy)) return stream2.destroy();
      callback(err || new Error("stream was destroyed"));
    }
  };
}, call = function(fn2) {
  fn2();
}, pipe$2 = function(from2, to) {
  return from2.pipe(to);
}, pump$1 = function() {
  var streams2 = Array.prototype.slice.call(arguments), callback = isFn(streams2[streams2.length - 1] || noop$1) && streams2.pop() || noop$1;
  if (Array.isArray(streams2[0]) && (streams2 = streams2[0]), streams2.length < 2) throw new Error("pump requires two streams per minimum");
  var error2, destroys = streams2.map(function(stream2, i2) {
    var reading = i2 < streams2.length - 1, writing = i2 > 0;
    return destroyer(stream2, reading, writing, function(err) {
      error2 || (error2 = err), err && destroys.forEach(call), !reading && (destroys.forEach(call), callback(error2));
    });
  });
  return streams2.reduce(pipe$2);
}, pump_1 = pump$1;
const { PassThrough: PassThroughStream } = require$$0__default$4.default;
var bufferStream$1 = (options2) => {
  options2 = { ...options2 };
  const { array: array2 } = options2;
  let { encoding } = options2;
  const isBuffer = encoding === "buffer";
  let objectMode = !1;
  array2 ? objectMode = !(encoding || isBuffer) : encoding = encoding || "utf8", isBuffer && (encoding = null);
  const stream2 = new PassThroughStream({ objectMode });
  encoding && stream2.setEncoding(encoding);
  let length = 0;
  const chunks = [];
  return stream2.on("data", (chunk) => {
    chunks.push(chunk), objectMode ? length = chunks.length : length += chunk.length;
  }), stream2.getBufferedValue = () => array2 ? chunks : isBuffer ? Buffer.concat(chunks, length) : chunks.join(""), stream2.getBufferedLength = () => length, stream2;
};
const { constants: BufferConstants } = require$$0__default$9.default, pump = pump_1, bufferStream = bufferStream$1;
class MaxBufferError extends Error {
  constructor() {
    super("maxBuffer exceeded"), this.name = "MaxBufferError";
  }
}
async function getStream$1(inputStream, options2) {
  if (!inputStream)
    return Promise.reject(new Error("Expected a stream"));
  options2 = {
    maxBuffer: 1 / 0,
    ...options2
  };
  const { maxBuffer } = options2;
  let stream2;
  return await new Promise((resolve2, reject) => {
    const rejectPromise = (error2) => {
      error2 && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH && (error2.bufferedData = stream2.getBufferedValue()), reject(error2);
    };
    stream2 = pump(inputStream, bufferStream(options2), (error2) => {
      if (error2) {
        rejectPromise(error2);
        return;
      }
      resolve2();
    }), stream2.on("data", () => {
      stream2.getBufferedLength() > maxBuffer && rejectPromise(new MaxBufferError());
    });
  }), stream2.getBufferedValue();
}
getStream$2.exports = getStream$1;
getStream$2.exports.default = getStream$1;
getStream$2.exports.buffer = (stream2, options2) => getStream$1(stream2, { ...options2, encoding: "buffer" });
getStream$2.exports.array = (stream2, options2) => getStream$1(stream2, { ...options2, array: !0 });
getStream$2.exports.MaxBufferError = MaxBufferError;
var getStreamExports = getStream$2.exports;
const { PassThrough } = require$$0__default$4.default;
var mergeStream$1 = function() {
  var sources = [], output = new PassThrough({ objectMode: !0 });
  return output.setMaxListeners(0), output.add = add, output.isEmpty = isEmpty2, output.on("unpipe", remove), Array.prototype.slice.call(arguments).forEach(add), output;
  function add(source2) {
    return Array.isArray(source2) ? (source2.forEach(add), this) : (sources.push(source2), source2.once("end", remove.bind(null, source2)), source2.once("error", output.emit.bind(output, "error")), source2.pipe(output, { end: !1 }), this);
  }
  function isEmpty2() {
    return sources.length == 0;
  }
  function remove(source2) {
    sources = sources.filter(function(it) {
      return it !== source2;
    }), !sources.length && output.readable && output.end();
  }
};
const isStream = isStream_1, getStream = getStreamExports, mergeStream = mergeStream$1, handleInput$1 = (spawned, input2) => {
  input2 === void 0 || spawned.stdin === void 0 || (isStream(input2) ? input2.pipe(spawned.stdin) : spawned.stdin.end(input2));
}, makeAllStream$1 = (spawned) => {
  if (!spawned.stdout && !spawned.stderr)
    return;
  const mixed = mergeStream();
  return spawned.stdout && mixed.add(spawned.stdout), spawned.stderr && mixed.add(spawned.stderr), mixed;
}, getBufferedData = async (stream2, streamPromise) => {
  if (stream2) {
    stream2.destroy();
    try {
      return await streamPromise;
    } catch (error2) {
      return error2.bufferedData;
    }
  }
}, getStreamPromise = (stream2, { encoding, buffer: buffer2, maxBuffer }) => {
  if (stream2)
    return buffer2 ? encoding ? getStream(stream2, { encoding, maxBuffer }) : getStream.buffer(stream2, { maxBuffer }) : new Promise((resolve2, reject) => {
      stream2.once("end", resolve2).once("error", reject);
    });
}, getSpawnedResult$1 = async ({ stdout, stderr, all }, { encoding, buffer: buffer2, maxBuffer }, processDone) => {
  const stdoutPromise = getStreamPromise(stdout, { encoding, buffer: buffer2, maxBuffer }), stderrPromise = getStreamPromise(stderr, { encoding, buffer: buffer2, maxBuffer }), allPromise = getStreamPromise(all, { encoding, buffer: buffer2, maxBuffer: maxBuffer * 2 });
  try {
    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
  } catch (error2) {
    return Promise.all([
      { error: error2, code: error2.code, signal: error2.signal, timedOut: error2.timedOut },
      getBufferedData(stdout, stdoutPromise),
      getBufferedData(stderr, stderrPromise),
      getBufferedData(all, allPromise)
    ]);
  }
}, validateInputSync$1 = ({ input: input2 }) => {
  if (isStream(input2))
    throw new TypeError("The `input` option cannot be a stream in sync mode");
};
var stream$1 = {
  handleInput: handleInput$1,
  makeAllStream: makeAllStream$1,
  getSpawnedResult: getSpawnedResult$1,
  validateInputSync: validateInputSync$1
};
const mergePromiseProperty = (spawned, promise2, property) => {
  const value = typeof promise2 == "function" ? (...args) => promise2()[property](...args) : promise2[property].bind(promise2);
  Object.defineProperty(spawned, property, {
    value,
    writable: !0,
    enumerable: !1,
    configurable: !0
  });
}, mergePromise$1 = (spawned, promise2) => (mergePromiseProperty(spawned, promise2, "then"), mergePromiseProperty(spawned, promise2, "catch"), Promise.prototype.finally && mergePromiseProperty(spawned, promise2, "finally"), spawned), getSpawnedPromise$1 = (spawned) => new Promise((resolve2, reject) => {
  spawned.on("exit", (code, signal) => {
    resolve2({ code, signal });
  }), spawned.on("error", (error2) => {
    reject(error2);
  }), spawned.stdin && spawned.stdin.on("error", (error2) => {
    reject(error2);
  });
});
var promise = {
  mergePromise: mergePromise$1,
  getSpawnedPromise: getSpawnedPromise$1
};
const SPACES_REGEXP = / +/g, joinCommand$1 = (file2, args = []) => Array.isArray(args) ? [file2, ...args].join(" ") : file2, handleEscaping = (tokens, token2, index) => {
  if (index === 0)
    return [token2];
  const previousToken = tokens[tokens.length - 1];
  return previousToken.endsWith("\\") ? [...tokens.slice(0, -1), `${previousToken.slice(0, -1)} ${token2}`] : [...tokens, token2];
}, parseCommand$1 = (command2) => command2.trim().split(SPACES_REGEXP).reduce(handleEscaping, []);
var command = {
  joinCommand: joinCommand$1,
  parseCommand: parseCommand$1
};
const path$c = require$$0__default.default, childProcess = require$$0__default$7.default, crossSpawn = crossSpawnExports, stripFinalNewline = stripFinalNewline$1, npmRunPath = npmRunPathExports, onetime$2 = onetimeExports, makeError = error, normalizeStdio = stdioExports, { spawnedKill, spawnedCancel, setupTimeout, setExitHandler } = kill, { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = stream$1, { mergePromise, getSpawnedPromise } = promise, { joinCommand, parseCommand } = command, DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100, getEnv = ({ env: envOption, extendEnv, preferLocal, localDir }) => {
  const env = extendEnv ? { ...process.env, ...envOption } : envOption;
  return preferLocal ? npmRunPath.env({ env, cwd: localDir }) : env;
}, handleArgs = (file2, args, options2 = {}) => {
  const parsed = crossSpawn._parse(file2, args, options2);
  return file2 = parsed.command, args = parsed.args, options2 = parsed.options, options2 = {
    maxBuffer: DEFAULT_MAX_BUFFER,
    buffer: !0,
    stripFinalNewline: !0,
    extendEnv: !0,
    preferLocal: !1,
    localDir: options2.cwd || process.cwd(),
    encoding: "utf8",
    reject: !0,
    cleanup: !0,
    ...options2,
    windowsHide: !0
  }, options2.env = getEnv(options2), options2.stdio = normalizeStdio(options2), process.platform === "win32" && path$c.basename(file2, ".exe") === "cmd" && args.unshift("/q"), { file: file2, args, options: options2, parsed };
}, handleOutput = (options2, value, error2) => typeof value != "string" && !Buffer.isBuffer(value) ? error2 === void 0 ? void 0 : "" : options2.stripFinalNewline ? stripFinalNewline(value) : value, execa = (file2, args, options2) => {
  const parsed = handleArgs(file2, args, options2), command2 = joinCommand(file2, args);
  let spawned;
  try {
    spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error2) {
    const dummySpawned = new childProcess.ChildProcess(), errorPromise = Promise.reject(makeError({
      error: error2,
      stdout: "",
      stderr: "",
      all: "",
      command: command2,
      parsed,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    }));
    return mergePromise(dummySpawned, errorPromise);
  }
  const spawnedPromise = getSpawnedPromise(spawned), timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise), processDone = setExitHandler(spawned, parsed.options, timedPromise), context = { isCanceled: !1 };
  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned)), spawned.cancel = spawnedCancel.bind(null, spawned, context);
  const handlePromiseOnce = onetime$2(async () => {
    const [{ error: error2, code, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone), stdout = handleOutput(parsed.options, stdoutResult), stderr = handleOutput(parsed.options, stderrResult), all = handleOutput(parsed.options, allResult);
    if (error2 || code !== 0 || signal !== null) {
      const returnedError = makeError({
        error: error2,
        code,
        signal,
        stdout,
        stderr,
        all,
        command: command2,
        parsed,
        timedOut,
        isCanceled: context.isCanceled,
        killed: spawned.killed
      });
      if (!parsed.options.reject)
        return returnedError;
      throw returnedError;
    }
    return {
      command: command2,
      exitCode: 0,
      exitCodeName: "SUCCESS",
      stdout,
      stderr,
      all,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    };
  });
  return crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed), handleInput(spawned, parsed.options.input), spawned.all = makeAllStream(spawned), mergePromise(spawned, handlePromiseOnce);
};
execa$2.exports = execa;
execa$2.exports.sync = (file2, args, options2) => {
  const parsed = handleArgs(file2, args, options2), command2 = joinCommand(file2, args);
  validateInputSync(parsed.options);
  let result;
  try {
    result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
  } catch (error2) {
    throw makeError({
      error: error2,
      stdout: "",
      stderr: "",
      all: "",
      command: command2,
      parsed,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    });
  }
  if (result.stdout = handleOutput(parsed.options, result.stdout, result.error), result.stderr = handleOutput(parsed.options, result.stderr, result.error), result.error || result.status !== 0 || result.signal !== null) {
    const error2 = makeError({
      ...result,
      code: result.status,
      command: command2,
      parsed,
      timedOut: result.error && result.error.code === "ETIMEDOUT",
      isCanceled: !1,
      killed: result.signal !== null
    });
    if (!parsed.options.reject)
      return error2;
    throw error2;
  }
  return {
    command: command2,
    exitCode: 0,
    exitCodeName: "SUCCESS",
    stdout: result.stdout,
    stderr: result.stderr,
    failed: !1,
    timedOut: !1,
    isCanceled: !1,
    killed: !1
  };
};
execa$2.exports.command = (command2, options2) => {
  const [file2, ...args] = parseCommand(command2);
  return execa(file2, args, options2);
};
execa$2.exports.commandSync = (command2, options2) => {
  const [file2, ...args] = parseCommand(command2);
  return execa.sync(file2, args, options2);
};
execa$2.exports.node = (scriptPath, args, options2 = {}) => {
  args && !Array.isArray(args) && typeof args == "object" && (options2 = args, args = []);
  const stdio2 = normalizeStdio.node(options2), { nodePath: nodePath2 = process.execPath, nodeOptions = process.execArgv } = options2;
  return execa(
    nodePath2,
    [
      ...nodeOptions,
      scriptPath,
      ...Array.isArray(args) ? args : []
    ],
    {
      ...options2,
      stdin: void 0,
      stdout: void 0,
      stderr: void 0,
      stdio: stdio2,
      shell: !1
    }
  );
};
var execaExports = execa$2.exports, execa$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(execaExports), pFilter$2 = { exports: {} }, pMap$2 = { exports: {} };
const pMap$1 = (iterable, mapper, options2) => new Promise((resolve2, reject) => {
  if (options2 = Object.assign({
    concurrency: 1 / 0
  }, options2), typeof mapper != "function")
    throw new TypeError("Mapper function is required");
  const { concurrency } = options2;
  if (!(typeof concurrency == "number" && concurrency >= 1))
    throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
  const ret = [], iterator2 = iterable[Symbol.iterator]();
  let isRejected = !1, isIterableDone = !1, resolvingCount = 0, currentIndex = 0;
  const next = () => {
    if (isRejected)
      return;
    const nextItem = iterator2.next(), i2 = currentIndex;
    if (currentIndex++, nextItem.done) {
      isIterableDone = !0, resolvingCount === 0 && resolve2(ret);
      return;
    }
    resolvingCount++, Promise.resolve(nextItem.value).then((element) => mapper(element, i2)).then(
      (value) => {
        ret[i2] = value, resolvingCount--, next();
      },
      (error2) => {
        isRejected = !0, reject(error2);
      }
    );
  };
  for (let i2 = 0; i2 < concurrency && (next(), !isIterableDone); i2++)
    ;
});
pMap$2.exports = pMap$1;
pMap$2.exports.default = pMap$1;
var pMapExports = pMap$2.exports;
const pMap = pMapExports, pFilter = async (iterable, filterer, options2) => (await pMap(
  iterable,
  (element, index) => Promise.all([filterer(element, index), element]),
  options2
)).filter((value) => !!value[0]).map((value) => value[1]);
pFilter$2.exports = pFilter;
pFilter$2.exports.default = pFilter;
var pFilterExports = pFilter$2.exports, pFilter$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(pFilterExports);
const CLIInitStepCompleted = telemetry.defineTrace({
  name: "CLI Init Step Completed",
  version: 1,
  description: "User completed a step in the CLI init flow"
});
var core$3 = {}, utils$a = {};
(function(exports2) {
  exports2.isInteger = (num) => typeof num == "number" ? Number.isInteger(num) : typeof num == "string" && num.trim() !== "" ? Number.isInteger(Number(num)) : !1, exports2.find = (node2, type2) => node2.nodes.find((node3) => node3.type === type2), exports2.exceedsLimit = (min2, max2, step = 1, limit) => limit === !1 || !exports2.isInteger(min2) || !exports2.isInteger(max2) ? !1 : (Number(max2) - Number(min2)) / Number(step) >= limit, exports2.escapeNode = (block, n = 0, type2) => {
    let node2 = block.nodes[n];
    node2 && (type2 && node2.type === type2 || node2.type === "open" || node2.type === "close") && node2.escaped !== !0 && (node2.value = "\\" + node2.value, node2.escaped = !0);
  }, exports2.encloseBrace = (node2) => node2.type !== "brace" || node2.commas >> 0 + node2.ranges >> 0 ? !1 : (node2.invalid = !0, !0), exports2.isInvalidBrace = (block) => block.type !== "brace" ? !1 : block.invalid === !0 || block.dollar ? !0 : !(block.commas >> 0 + block.ranges >> 0) || block.open !== !0 || block.close !== !0 ? (block.invalid = !0, !0) : !1, exports2.isOpenOrClose = (node2) => node2.type === "open" || node2.type === "close" ? !0 : node2.open === !0 || node2.close === !0, exports2.reduce = (nodes) => nodes.reduce((acc, node2) => (node2.type === "text" && acc.push(node2.value), node2.type === "range" && (node2.type = "text"), acc), []), exports2.flatten = (...args) => {
    const result = [], flat = (arr) => {
      for (let i2 = 0; i2 < arr.length; i2++) {
        let ele = arr[i2];
        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    return flat(args), result;
  };
})(utils$a);
const utils$9 = utils$a;
var stringify$4 = (ast, options2 = {}) => {
  let stringify3 = (node2, parent = {}) => {
    let invalidBlock = options2.escapeInvalid && utils$9.isInvalidBrace(parent), invalidNode = node2.invalid === !0 && options2.escapeInvalid === !0, output = "";
    if (node2.value)
      return (invalidBlock || invalidNode) && utils$9.isOpenOrClose(node2) ? "\\" + node2.value : node2.value;
    if (node2.value)
      return node2.value;
    if (node2.nodes)
      for (let child of node2.nodes)
        output += stringify3(child);
    return output;
  };
  return stringify3(ast);
};
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var isNumber$2 = function(num) {
  return typeof num == "number" ? num - num === 0 : typeof num == "string" && num.trim() !== "" ? Number.isFinite ? Number.isFinite(+num) : isFinite(+num) : !1;
};
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
const isNumber$1 = isNumber$2, toRegexRange$1 = (min2, max2, options2) => {
  if (isNumber$1(min2) === !1)
    throw new TypeError("toRegexRange: expected the first argument to be a number");
  if (max2 === void 0 || min2 === max2)
    return String(min2);
  if (isNumber$1(max2) === !1)
    throw new TypeError("toRegexRange: expected the second argument to be a number.");
  let opts = { relaxZeros: !0, ...options2 };
  typeof opts.strictZeros == "boolean" && (opts.relaxZeros = opts.strictZeros === !1);
  let relax = String(opts.relaxZeros), shorthand = String(opts.shorthand), capture = String(opts.capture), wrap = String(opts.wrap), cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap;
  if (toRegexRange$1.cache.hasOwnProperty(cacheKey))
    return toRegexRange$1.cache[cacheKey].result;
  let a = Math.min(min2, max2), b = Math.max(min2, max2);
  if (Math.abs(a - b) === 1) {
    let result = min2 + "|" + max2;
    return opts.capture ? `(${result})` : opts.wrap === !1 ? result : `(?:${result})`;
  }
  let isPadded2 = hasPadding(min2) || hasPadding(max2), state2 = { min: min2, max: max2, a, b }, positives = [], negatives = [];
  if (isPadded2 && (state2.isPadded = isPadded2, state2.maxLen = String(state2.max).length), a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state2, opts), a = state2.a = 0;
  }
  return b >= 0 && (positives = splitToPatterns(a, b, state2, opts)), state2.negatives = negatives, state2.positives = positives, state2.result = collatePatterns(negatives, positives), opts.capture === !0 ? state2.result = `(${state2.result})` : opts.wrap !== !1 && positives.length + negatives.length > 1 && (state2.result = `(?:${state2.result})`), toRegexRange$1.cache[cacheKey] = state2, state2.result;
};
function collatePatterns(neg, pos2, options2) {
  let onlyNegative = filterPatterns(neg, pos2, "-", !1) || [], onlyPositive = filterPatterns(pos2, neg, "", !1) || [], intersected = filterPatterns(neg, pos2, "-?", !0) || [];
  return onlyNegative.concat(intersected).concat(onlyPositive).join("|");
}
function splitToRanges(min2, max2) {
  let nines = 1, zeros2 = 1, stop = countNines(min2, nines), stops = /* @__PURE__ */ new Set([max2]);
  for (; min2 <= stop && stop <= max2; )
    stops.add(stop), nines += 1, stop = countNines(min2, nines);
  for (stop = countZeros(max2 + 1, zeros2) - 1; min2 < stop && stop <= max2; )
    stops.add(stop), zeros2 += 1, stop = countZeros(max2 + 1, zeros2) - 1;
  return stops = [...stops], stops.sort(compare), stops;
}
function rangeToPattern(start, stop, options2) {
  if (start === stop)
    return { pattern: start, count: [], digits: 0 };
  let zipped = zip$2(start, stop), digits = zipped.length, pattern = "", count2 = 0;
  for (let i2 = 0; i2 < digits; i2++) {
    let [startDigit, stopDigit] = zipped[i2];
    startDigit === stopDigit ? pattern += startDigit : startDigit !== "0" || stopDigit !== "9" ? pattern += toCharacterClass(startDigit, stopDigit) : count2++;
  }
  return count2 && (pattern += options2.shorthand === !0 ? "\\d" : "[0-9]"), { pattern, count: [count2], digits };
}
function splitToPatterns(min2, max2, tok, options2) {
  let ranges = splitToRanges(min2, max2), tokens = [], start = min2, prev;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let max3 = ranges[i2], obj = rangeToPattern(String(start), String(max3), options2), zeros2 = "";
    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      prev.count.length > 1 && prev.count.pop(), prev.count.push(obj.count[0]), prev.string = prev.pattern + toQuantifier(prev.count), start = max3 + 1;
      continue;
    }
    tok.isPadded && (zeros2 = padZeros(max3, tok, options2)), obj.string = zeros2 + obj.pattern + toQuantifier(obj.count), tokens.push(obj), start = max3 + 1, prev = obj;
  }
  return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options2) {
  let result = [];
  for (let ele of arr) {
    let { string } = ele;
    !intersection && !contains(comparison, "string", string) && result.push(prefix + string), intersection && contains(comparison, "string", string) && result.push(prefix + string);
  }
  return result;
}
function zip$2(a, b) {
  let arr = [];
  for (let i2 = 0; i2 < a.length; i2++) arr.push([a[i2], b[i2]]);
  return arr;
}
function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key2, val) {
  return arr.some((ele) => ele[key2] === val);
}
function countNines(min2, len) {
  return Number(String(min2).slice(0, -len) + "9".repeat(len));
}
function countZeros(integer, zeros2) {
  return integer - integer % Math.pow(10, zeros2);
}
function toQuantifier(digits) {
  let [start = 0, stop = ""] = digits;
  return stop || start > 1 ? `{${start + (stop ? "," + stop : "")}}` : "";
}
function toCharacterClass(a, b, options2) {
  return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
}
function hasPadding(str2) {
  return /^-?(0+)\d/.test(str2);
}
function padZeros(value, tok, options2) {
  if (!tok.isPadded)
    return value;
  let diff = Math.abs(tok.maxLen - String(value).length), relax = options2.relaxZeros !== !1;
  switch (diff) {
    case 0:
      return "";
    case 1:
      return relax ? "0?" : "0";
    case 2:
      return relax ? "0{0,2}" : "00";
    default:
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
  }
}
toRegexRange$1.cache = {};
toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
var toRegexRange_1 = toRegexRange$1;
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
const util$3 = require$$0__default$5.default, toRegexRange = toRegexRange_1, isObject$5 = (val) => val !== null && typeof val == "object" && !Array.isArray(val), transform = (toNumber) => (value) => toNumber === !0 ? Number(value) : String(value), isValidValue = (value) => typeof value == "number" || typeof value == "string" && value !== "", isNumber = (num) => Number.isInteger(+num), zeros = (input2) => {
  let value = `${input2}`, index = -1;
  if (value[0] === "-" && (value = value.slice(1)), value === "0") return !1;
  for (; value[++index] === "0"; ) ;
  return index > 0;
}, stringify$3 = (start, end2, options2) => typeof start == "string" || typeof end2 == "string" ? !0 : options2.stringify === !0, pad = (input2, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input2[0] === "-" ? "-" : "";
    dash && (input2 = input2.slice(1)), input2 = dash + input2.padStart(dash ? maxLength - 1 : maxLength, "0");
  }
  return toNumber === !1 ? String(input2) : input2;
}, toMaxLen = (input2, maxLength) => {
  let negative = input2[0] === "-" ? "-" : "";
  for (negative && (input2 = input2.slice(1), maxLength--); input2.length < maxLength; ) input2 = "0" + input2;
  return negative ? "-" + input2 : input2;
}, toSequence = (parts, options2) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0), parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  let prefix = options2.capture ? "" : "?:", positives = "", negatives = "", result;
  return parts.positives.length && (positives = parts.positives.join("|")), parts.negatives.length && (negatives = `-(${prefix}${parts.negatives.join("|")})`), positives && negatives ? result = `${positives}|${negatives}` : result = positives || negatives, options2.wrap ? `(${prefix}${result})` : result;
}, toRange = (a, b, isNumbers, options2) => {
  if (isNumbers)
    return toRegexRange(a, b, { wrap: !1, ...options2 });
  let start = String.fromCharCode(a);
  if (a === b) return start;
  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
}, toRegex = (start, end2, options2) => {
  if (Array.isArray(start)) {
    let wrap = options2.wrap === !0, prefix = options2.capture ? "" : "?:";
    return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
  }
  return toRegexRange(start, end2, options2);
}, rangeError = (...args) => new RangeError("Invalid range arguments: " + util$3.inspect(...args)), invalidRange = (start, end2, options2) => {
  if (options2.strictRanges === !0) throw rangeError([start, end2]);
  return [];
}, invalidStep = (step, options2) => {
  if (options2.strictRanges === !0)
    throw new TypeError(`Expected step "${step}" to be a number`);
  return [];
}, fillNumbers = (start, end2, step = 1, options2 = {}) => {
  let a = Number(start), b = Number(end2);
  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options2.strictRanges === !0) throw rangeError([start, end2]);
    return [];
  }
  a === 0 && (a = 0), b === 0 && (b = 0);
  let descending = a > b, startString = String(start), endString = String(end2), stepString = String(step);
  step = Math.max(Math.abs(step), 1);
  let padded = zeros(startString) || zeros(endString) || zeros(stepString), maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0, toNumber = padded === !1 && stringify$3(start, end2, options2) === !1, format2 = options2.transform || transform(toNumber);
  if (options2.toRegex && step === 1)
    return toRange(toMaxLen(start, maxLen), toMaxLen(end2, maxLen), !0, options2);
  let parts = { negatives: [], positives: [] }, push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num)), range2 = [], index = 0;
  for (; descending ? a >= b : a <= b; )
    options2.toRegex === !0 && step > 1 ? push2(a) : range2.push(pad(format2(a, index), maxLen, toNumber)), a = descending ? a - step : a + step, index++;
  return options2.toRegex === !0 ? step > 1 ? toSequence(parts, options2) : toRegex(range2, null, { wrap: !1, ...options2 }) : range2;
}, fillLetters = (start, end2, step = 1, options2 = {}) => {
  if (!isNumber(start) && start.length > 1 || !isNumber(end2) && end2.length > 1)
    return invalidRange(start, end2, options2);
  let format2 = options2.transform || ((val) => String.fromCharCode(val)), a = `${start}`.charCodeAt(0), b = `${end2}`.charCodeAt(0), descending = a > b, min2 = Math.min(a, b), max2 = Math.max(a, b);
  if (options2.toRegex && step === 1)
    return toRange(min2, max2, !1, options2);
  let range2 = [], index = 0;
  for (; descending ? a >= b : a <= b; )
    range2.push(format2(a, index)), a = descending ? a - step : a + step, index++;
  return options2.toRegex === !0 ? toRegex(range2, null, { wrap: !1, options: options2 }) : range2;
}, fill$2 = (start, end2, step, options2 = {}) => {
  if (end2 == null && isValidValue(start))
    return [start];
  if (!isValidValue(start) || !isValidValue(end2))
    return invalidRange(start, end2, options2);
  if (typeof step == "function")
    return fill$2(start, end2, 1, { transform: step });
  if (isObject$5(step))
    return fill$2(start, end2, 0, step);
  let opts = { ...options2 };
  return opts.capture === !0 && (opts.wrap = !0), step = step || opts.step || 1, isNumber(step) ? isNumber(start) && isNumber(end2) ? fillNumbers(start, end2, step, opts) : fillLetters(start, end2, Math.max(Math.abs(step), 1), opts) : step != null && !isObject$5(step) ? invalidStep(step, opts) : fill$2(start, end2, 1, step);
};
var fillRange = fill$2;
const fill$1 = fillRange, utils$8 = utils$a, compile$1 = (ast, options2 = {}) => {
  let walk = (node2, parent = {}) => {
    let invalidBlock = utils$8.isInvalidBrace(parent), invalidNode = node2.invalid === !0 && options2.escapeInvalid === !0, invalid = invalidBlock === !0 || invalidNode === !0, prefix = options2.escapeInvalid === !0 ? "\\" : "", output = "";
    if (node2.isOpen === !0 || node2.isClose === !0)
      return prefix + node2.value;
    if (node2.type === "open")
      return invalid ? prefix + node2.value : "(";
    if (node2.type === "close")
      return invalid ? prefix + node2.value : ")";
    if (node2.type === "comma")
      return node2.prev.type === "comma" ? "" : invalid ? node2.value : "|";
    if (node2.value)
      return node2.value;
    if (node2.nodes && node2.ranges > 0) {
      let args = utils$8.reduce(node2.nodes), range2 = fill$1(...args, { ...options2, wrap: !1, toRegex: !0 });
      if (range2.length !== 0)
        return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
    }
    if (node2.nodes)
      for (let child of node2.nodes)
        output += walk(child, node2);
    return output;
  };
  return walk(ast);
};
var compile_1 = compile$1;
const fill = fillRange, stringify$2 = stringify$4, utils$7 = utils$a, append = (queue2 = "", stash = "", enclose = !1) => {
  let result = [];
  if (queue2 = [].concat(queue2), stash = [].concat(stash), !stash.length) return queue2;
  if (!queue2.length)
    return enclose ? utils$7.flatten(stash).map((ele) => `{${ele}}`) : stash;
  for (let item of queue2)
    if (Array.isArray(item))
      for (let value of item)
        result.push(append(value, stash, enclose));
    else
      for (let ele of stash)
        enclose === !0 && typeof ele == "string" && (ele = `{${ele}}`), result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
  return utils$7.flatten(result);
}, expand$3 = (ast, options2 = {}) => {
  let rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit, walk = (node2, parent = {}) => {
    node2.queue = [];
    let p = parent, q = parent.queue;
    for (; p.type !== "brace" && p.type !== "root" && p.parent; )
      p = p.parent, q = p.queue;
    if (node2.invalid || node2.dollar) {
      q.push(append(q.pop(), stringify$2(node2, options2)));
      return;
    }
    if (node2.type === "brace" && node2.invalid !== !0 && node2.nodes.length === 2) {
      q.push(append(q.pop(), ["{}"]));
      return;
    }
    if (node2.nodes && node2.ranges > 0) {
      let args = utils$7.reduce(node2.nodes);
      if (utils$7.exceedsLimit(...args, options2.step, rangeLimit))
        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      let range2 = fill(...args, options2);
      range2.length === 0 && (range2 = stringify$2(node2, options2)), q.push(append(q.pop(), range2)), node2.nodes = [];
      return;
    }
    let enclose = utils$7.encloseBrace(node2), queue2 = node2.queue, block = node2;
    for (; block.type !== "brace" && block.type !== "root" && block.parent; )
      block = block.parent, queue2 = block.queue;
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      if (child.type === "comma" && node2.type === "brace") {
        i2 === 1 && queue2.push(""), queue2.push("");
        continue;
      }
      if (child.type === "close") {
        q.push(append(q.pop(), queue2, enclose));
        continue;
      }
      if (child.value && child.type !== "open") {
        queue2.push(append(queue2.pop(), child.value));
        continue;
      }
      child.nodes && walk(child, node2);
    }
    return queue2;
  };
  return utils$7.flatten(walk(ast));
};
var expand_1 = expand$3, constants$3 = {
  MAX_LENGTH: 1024 * 64,
  // Digits
  CHAR_0: "0",
  /* 0 */
  CHAR_9: "9",
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: "A",
  /* A */
  CHAR_LOWERCASE_A: "a",
  /* a */
  CHAR_UPPERCASE_Z: "Z",
  /* Z */
  CHAR_LOWERCASE_Z: "z",
  /* z */
  CHAR_LEFT_PARENTHESES: "(",
  /* ( */
  CHAR_RIGHT_PARENTHESES: ")",
  /* ) */
  CHAR_ASTERISK: "*",
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: "&",
  /* & */
  CHAR_AT: "@",
  /* @ */
  CHAR_BACKSLASH: "\\",
  /* \ */
  CHAR_BACKTICK: "`",
  /* ` */
  CHAR_CARRIAGE_RETURN: "\r",
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: "^",
  /* ^ */
  CHAR_COLON: ":",
  /* : */
  CHAR_COMMA: ",",
  /* , */
  CHAR_DOLLAR: "$",
  /* . */
  CHAR_DOT: ".",
  /* . */
  CHAR_DOUBLE_QUOTE: '"',
  /* " */
  CHAR_EQUAL: "=",
  /* = */
  CHAR_EXCLAMATION_MARK: "!",
  /* ! */
  CHAR_FORM_FEED: "\f",
  /* \f */
  CHAR_FORWARD_SLASH: "/",
  /* / */
  CHAR_HASH: "#",
  /* # */
  CHAR_HYPHEN_MINUS: "-",
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: "<",
  /* < */
  CHAR_LEFT_CURLY_BRACE: "{",
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: "[",
  /* [ */
  CHAR_LINE_FEED: `
`,
  /* \n */
  CHAR_NO_BREAK_SPACE: "\xA0",
  /* \u00A0 */
  CHAR_PERCENT: "%",
  /* % */
  CHAR_PLUS: "+",
  /* + */
  CHAR_QUESTION_MARK: "?",
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: ">",
  /* > */
  CHAR_RIGHT_CURLY_BRACE: "}",
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: "]",
  /* ] */
  CHAR_SEMICOLON: ";",
  /* ; */
  CHAR_SINGLE_QUOTE: "'",
  /* ' */
  CHAR_SPACE: " ",
  /*   */
  CHAR_TAB: "	",
  /* \t */
  CHAR_UNDERSCORE: "_",
  /* _ */
  CHAR_VERTICAL_LINE: "|",
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  /* \uFEFF */
};
const stringify$1 = stringify$4, {
  MAX_LENGTH: MAX_LENGTH$1,
  CHAR_BACKSLASH,
  /* \ */
  CHAR_BACKTICK,
  /* ` */
  CHAR_COMMA: CHAR_COMMA$2,
  /* , */
  CHAR_DOT: CHAR_DOT$1,
  /* . */
  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
  /* ( */
  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
  /* ) */
  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
  /* { */
  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
  /* } */
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$2,
  /* [ */
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$2,
  /* ] */
  CHAR_DOUBLE_QUOTE: CHAR_DOUBLE_QUOTE$1,
  /* " */
  CHAR_SINGLE_QUOTE: CHAR_SINGLE_QUOTE$1,
  /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$3, parse$7 = (input2, options2 = {}) => {
  if (typeof input2 != "string")
    throw new TypeError("Expected a string");
  let opts = options2 || {}, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  if (input2.length > max2)
    throw new SyntaxError(`Input length (${input2.length}), exceeds max characters (${max2})`);
  let ast = { type: "root", input: input2, nodes: [] }, stack2 = [ast], block = ast, prev = ast, brackets = 0, length = input2.length, index = 0, depth2 = 0, value;
  const advance = () => input2[index++], push2 = (node2) => {
    if (node2.type === "text" && prev.type === "dot" && (prev.type = "text"), prev && prev.type === "text" && node2.type === "text") {
      prev.value += node2.value;
      return;
    }
    return block.nodes.push(node2), node2.parent = block, node2.prev = prev, prev = node2, node2;
  };
  for (push2({ type: "bos" }); index < length; )
    if (block = stack2[stack2.length - 1], value = advance(), !(value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE)) {
      if (value === CHAR_BACKSLASH) {
        push2({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET$2) {
        push2({ type: "text", value: "\\" + value });
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET$2) {
        brackets++;
        let next;
        for (; index < length && (next = advance()); ) {
          if (value += next, next === CHAR_LEFT_SQUARE_BRACKET$2) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET$2 && (brackets--, brackets === 0))
            break;
        }
        push2({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES$1) {
        block = push2({ type: "paren", nodes: [] }), stack2.push(block), push2({ type: "text", value });
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES$1) {
        if (block.type !== "paren") {
          push2({ type: "text", value });
          continue;
        }
        block = stack2.pop(), push2({ type: "text", value }), block = stack2[stack2.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE$1 || value === CHAR_SINGLE_QUOTE$1 || value === CHAR_BACKTICK) {
        let open2 = value, next;
        for (options2.keepQuotes !== !0 && (value = ""); index < length && (next = advance()); ) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open2) {
            options2.keepQuotes === !0 && (value += next);
            break;
          }
          value += next;
        }
        push2({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE$1) {
        depth2++;
        let brace = {
          type: "brace",
          open: !0,
          close: !1,
          dollar: prev.value && prev.value.slice(-1) === "$" || block.dollar === !0,
          depth: depth2,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push2(brace), stack2.push(block), push2({ type: "open", value });
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE$1) {
        if (block.type !== "brace") {
          push2({ type: "text", value });
          continue;
        }
        let type2 = "close";
        block = stack2.pop(), block.close = !0, push2({ type: type2, value }), depth2--, block = stack2[stack2.length - 1];
        continue;
      }
      if (value === CHAR_COMMA$2 && depth2 > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open2 = block.nodes.shift();
          block.nodes = [open2, { type: "text", value: stringify$1(block) }];
        }
        push2({ type: "comma", value }), block.commas++;
        continue;
      }
      if (value === CHAR_DOT$1 && depth2 > 0 && block.commas === 0) {
        let siblings = block.nodes;
        if (depth2 === 0 || siblings.length === 0) {
          push2({ type: "text", value });
          continue;
        }
        if (prev.type === "dot") {
          if (block.range = [], prev.value += value, prev.type = "range", block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = !0, block.ranges = 0, prev.type = "text";
            continue;
          }
          block.ranges++, block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value, prev = before, block.ranges--;
          continue;
        }
        push2({ type: "dot", value });
        continue;
      }
      push2({ type: "text", value });
    }
  do
    if (block = stack2.pop(), block.type !== "root") {
      block.nodes.forEach((node2) => {
        node2.nodes || (node2.type === "open" && (node2.isOpen = !0), node2.type === "close" && (node2.isClose = !0), node2.nodes || (node2.type = "text"), node2.invalid = !0);
      });
      let parent = stack2[stack2.length - 1], index2 = parent.nodes.indexOf(block);
      parent.nodes.splice(index2, 1, ...block.nodes);
    }
  while (stack2.length > 0);
  return push2({ type: "eos" }), ast;
};
var parse_1$2 = parse$7;
const stringify = stringify$4, compile = compile_1, expand$2 = expand_1, parse$6 = parse_1$2, braces$1 = (input2, options2 = {}) => {
  let output = [];
  if (Array.isArray(input2))
    for (let pattern of input2) {
      let result = braces$1.create(pattern, options2);
      Array.isArray(result) ? output.push(...result) : output.push(result);
    }
  else
    output = [].concat(braces$1.create(input2, options2));
  return options2 && options2.expand === !0 && options2.nodupes === !0 && (output = [...new Set(output)]), output;
};
braces$1.parse = (input2, options2 = {}) => parse$6(input2, options2);
braces$1.stringify = (input2, options2 = {}) => stringify(typeof input2 == "string" ? braces$1.parse(input2, options2) : input2, options2);
braces$1.compile = (input2, options2 = {}) => (typeof input2 == "string" && (input2 = braces$1.parse(input2, options2)), compile(input2, options2));
braces$1.expand = (input2, options2 = {}) => {
  typeof input2 == "string" && (input2 = braces$1.parse(input2, options2));
  let result = expand$2(input2, options2);
  return options2.noempty === !0 && (result = result.filter(Boolean)), options2.nodupes === !0 && (result = [...new Set(result)]), result;
};
braces$1.create = (input2, options2 = {}) => input2 === "" || input2.length < 3 ? [input2] : options2.expand !== !0 ? braces$1.compile(input2, options2) : braces$1.expand(input2, options2);
var braces_1 = braces$1, utils$6 = {};
const path$b = require$$0__default.default, WIN_SLASH = "\\\\/", WIN_NO_SLASH = `[^${WIN_SLASH}]`, DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = `(?:${SLASH_LITERAL}|$)`, START_ANCHOR = `(?:^|${SLASH_LITERAL})`, DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`, NO_DOT = `(?!${DOT_LITERAL})`, NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`, NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`, NO_DOTS_SLASH = `(?!${DOTS_SLASH})`, QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`, STAR = `${QMARK}*?`, POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
}, WINDOWS_CHARS = {
  ...POSIX_CHARS,
  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
}, POSIX_REGEX_SOURCE$1 = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var constants$2 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  // Digits
  CHAR_0: 48,
  /* 0 */
  CHAR_9: 57,
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  /* A */
  CHAR_LOWERCASE_A: 97,
  /* a */
  CHAR_UPPERCASE_Z: 90,
  /* Z */
  CHAR_LOWERCASE_Z: 122,
  /* z */
  CHAR_LEFT_PARENTHESES: 40,
  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,
  /* ) */
  CHAR_ASTERISK: 42,
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  /* & */
  CHAR_AT: 64,
  /* @ */
  CHAR_BACKWARD_SLASH: 92,
  /* \ */
  CHAR_CARRIAGE_RETURN: 13,
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,
  /* ^ */
  CHAR_COLON: 58,
  /* : */
  CHAR_COMMA: 44,
  /* , */
  CHAR_DOT: 46,
  /* . */
  CHAR_DOUBLE_QUOTE: 34,
  /* " */
  CHAR_EQUAL: 61,
  /* = */
  CHAR_EXCLAMATION_MARK: 33,
  /* ! */
  CHAR_FORM_FEED: 12,
  /* \f */
  CHAR_FORWARD_SLASH: 47,
  /* / */
  CHAR_GRAVE_ACCENT: 96,
  /* ` */
  CHAR_HASH: 35,
  /* # */
  CHAR_HYPHEN_MINUS: 45,
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,
  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,
  /* [ */
  CHAR_LINE_FEED: 10,
  /* \n */
  CHAR_NO_BREAK_SPACE: 160,
  /* \u00A0 */
  CHAR_PERCENT: 37,
  /* % */
  CHAR_PLUS: 43,
  /* + */
  CHAR_QUESTION_MARK: 63,
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  /* ] */
  CHAR_SEMICOLON: 59,
  /* ; */
  CHAR_SINGLE_QUOTE: 39,
  /* ' */
  CHAR_SPACE: 32,
  /*   */
  CHAR_TAB: 9,
  /* \t */
  CHAR_UNDERSCORE: 95,
  /* _ */
  CHAR_VERTICAL_LINE: 124,
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  /* \uFEFF */
  SEP: path$b.sep,
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(chars) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(win32) {
    return win32 === !0 ? WINDOWS_CHARS : POSIX_CHARS;
  }
};
(function(exports2) {
  const path2 = require$$0__default.default, win32 = process.platform === "win32", {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = constants$2;
  exports2.isObject = (val) => val !== null && typeof val == "object" && !Array.isArray(val), exports2.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2), exports2.isRegexChar = (str2) => str2.length === 1 && exports2.hasRegexChars(str2), exports2.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1"), exports2.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/"), exports2.removeBackslashes = (str2) => str2.replace(REGEX_REMOVE_BACKSLASH, (match3) => match3 === "\\" ? "" : match3), exports2.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    return segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10;
  }, exports2.isWindows = (options2) => options2 && typeof options2.windows == "boolean" ? options2.windows : win32 === !0 || path2.sep === "\\", exports2.escapeLast = (input2, char, lastIdx) => {
    const idx = input2.lastIndexOf(char, lastIdx);
    return idx === -1 ? input2 : input2[idx - 1] === "\\" ? exports2.escapeLast(input2, char, idx - 1) : `${input2.slice(0, idx)}\\${input2.slice(idx)}`;
  }, exports2.removePrefix = (input2, state2 = {}) => {
    let output = input2;
    return output.startsWith("./") && (output = output.slice(2), state2.prefix = "./"), output;
  }, exports2.wrapOutput = (input2, state2 = {}, options2 = {}) => {
    const prepend = options2.contains ? "" : "^", append3 = options2.contains ? "" : "$";
    let output = `${prepend}(?:${input2})${append3}`;
    return state2.negated === !0 && (output = `(?:^(?!${output}).*$)`), output;
  };
})(utils$6);
const utils$5 = utils$6, {
  CHAR_ASTERISK: CHAR_ASTERISK$1,
  /* * */
  CHAR_AT,
  /* @ */
  CHAR_BACKWARD_SLASH,
  /* \ */
  CHAR_COMMA: CHAR_COMMA$1,
  /* , */
  CHAR_DOT,
  /* . */
  CHAR_EXCLAMATION_MARK,
  /* ! */
  CHAR_FORWARD_SLASH,
  /* / */
  CHAR_LEFT_CURLY_BRACE,
  /* { */
  CHAR_LEFT_PARENTHESES,
  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
  /* [ */
  CHAR_PLUS,
  /* + */
  CHAR_QUESTION_MARK,
  /* ? */
  CHAR_RIGHT_CURLY_BRACE,
  /* } */
  CHAR_RIGHT_PARENTHESES,
  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1
  /* ] */
} = constants$2, isPathSeparator = (code) => code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH, depth = (token2) => {
  token2.isPrefix !== !0 && (token2.depth = token2.isGlobstar ? 1 / 0 : 1);
}, scan$2 = (input2, options2) => {
  const opts = options2 || {}, length = input2.length - 1, scanToEnd = opts.parts === !0 || opts.scanToEnd === !0, slashes = [], tokens = [], parts = [];
  let str2 = input2, index = -1, start = 0, lastIndex = 0, isBrace = !1, isBracket = !1, isGlob = !1, isExtglob = !1, isGlobstar = !1, braceEscaped = !1, backslashes = !1, negated = !1, negatedExtglob = !1, finished = !1, braces2 = 0, prev, code, token2 = { value: "", depth: 0, isGlob: !1 };
  const eos2 = () => index >= length, peek2 = () => str2.charCodeAt(index + 1), advance = () => (prev = code, str2.charCodeAt(++index));
  for (; index < length; ) {
    code = advance();
    let next;
    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token2.backslashes = !0, code = advance(), code === CHAR_LEFT_CURLY_BRACE && (braceEscaped = !0);
      continue;
    }
    if (braceEscaped === !0 || code === CHAR_LEFT_CURLY_BRACE) {
      for (braces2++; eos2() !== !0 && (code = advance()); ) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = !0, advance();
          continue;
        }
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          continue;
        }
        if (braceEscaped !== !0 && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (braceEscaped !== !0 && code === CHAR_COMMA$1) {
          if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_RIGHT_CURLY_BRACE && (braces2--, braces2 === 0)) {
          braceEscaped = !1, isBrace = token2.isBrace = !0, finished = !0;
          break;
        }
      }
      if (scanToEnd === !0)
        continue;
      break;
    }
    if (code === CHAR_FORWARD_SLASH) {
      if (slashes.push(index), tokens.push(token2), token2 = { value: "", depth: 0, isGlob: !1 }, finished === !0) continue;
      if (prev === CHAR_DOT && index === start + 1) {
        start += 2;
        continue;
      }
      lastIndex = index + 1;
      continue;
    }
    if (opts.noext !== !0 && (code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK$1 || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK) === !0 && peek2() === CHAR_LEFT_PARENTHESES) {
      if (isGlob = token2.isGlob = !0, isExtglob = token2.isExtglob = !0, finished = !0, code === CHAR_EXCLAMATION_MARK && index === start && (negatedExtglob = !0), scanToEnd === !0) {
        for (; eos2() !== !0 && (code = advance()); ) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token2.backslashes = !0, code = advance();
            continue;
          }
          if (code === CHAR_RIGHT_PARENTHESES) {
            isGlob = token2.isGlob = !0, finished = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (code === CHAR_ASTERISK$1) {
      if (prev === CHAR_ASTERISK$1 && (isGlobstar = token2.isGlobstar = !0), isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
        continue;
      break;
    }
    if (code === CHAR_QUESTION_MARK) {
      if (isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
        continue;
      break;
    }
    if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
      for (; eos2() !== !0 && (next = advance()); ) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = !0, advance();
          continue;
        }
        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
          isBracket = token2.isBracket = !0, isGlob = token2.isGlob = !0, finished = !0;
          break;
        }
      }
      if (scanToEnd === !0)
        continue;
      break;
    }
    if (opts.nonegate !== !0 && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token2.negated = !0, start++;
      continue;
    }
    if (opts.noparen !== !0 && code === CHAR_LEFT_PARENTHESES) {
      if (isGlob = token2.isGlob = !0, scanToEnd === !0) {
        for (; eos2() !== !0 && (code = advance()); ) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token2.backslashes = !0, code = advance();
            continue;
          }
          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (isGlob === !0) {
      if (finished = !0, scanToEnd === !0)
        continue;
      break;
    }
  }
  opts.noext === !0 && (isExtglob = !1, isGlob = !1);
  let base2 = str2, prefix = "", glob2 = "";
  start > 0 && (prefix = str2.slice(0, start), str2 = str2.slice(start), lastIndex -= start), base2 && isGlob === !0 && lastIndex > 0 ? (base2 = str2.slice(0, lastIndex), glob2 = str2.slice(lastIndex)) : isGlob === !0 ? (base2 = "", glob2 = str2) : base2 = str2, base2 && base2 !== "" && base2 !== "/" && base2 !== str2 && isPathSeparator(base2.charCodeAt(base2.length - 1)) && (base2 = base2.slice(0, -1)), opts.unescape === !0 && (glob2 && (glob2 = utils$5.removeBackslashes(glob2)), base2 && backslashes === !0 && (base2 = utils$5.removeBackslashes(base2)));
  const state2 = {
    prefix,
    input: input2,
    start,
    base: base2,
    glob: glob2,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };
  if (opts.tokens === !0 && (state2.maxDepth = 0, isPathSeparator(code) || tokens.push(token2), state2.tokens = tokens), opts.parts === !0 || opts.tokens === !0) {
    let prevIndex;
    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start, i2 = slashes[idx], value = input2.slice(n, i2);
      opts.tokens && (idx === 0 && start !== 0 ? (tokens[idx].isPrefix = !0, tokens[idx].value = prefix) : tokens[idx].value = value, depth(tokens[idx]), state2.maxDepth += tokens[idx].depth), (idx !== 0 || value !== "") && parts.push(value), prevIndex = i2;
    }
    if (prevIndex && prevIndex + 1 < input2.length) {
      const value = input2.slice(prevIndex + 1);
      parts.push(value), opts.tokens && (tokens[tokens.length - 1].value = value, depth(tokens[tokens.length - 1]), state2.maxDepth += tokens[tokens.length - 1].depth);
    }
    state2.slashes = slashes, state2.parts = parts;
  }
  return state2;
};
var scan_1 = scan$2;
const constants$1 = constants$2, utils$4 = utils$6, {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants$1, expandRange = (args, options2) => {
  if (typeof options2.expandRange == "function")
    return options2.expandRange(...args, options2);
  args.sort();
  const value = `[${args.join("-")}]`;
  try {
    new RegExp(value);
  } catch {
    return args.map((v) => utils$4.escapeRegex(v)).join("..");
  }
  return value;
}, syntaxError = (type2, char) => `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`, parse$5 = (input2, options2) => {
  if (typeof input2 != "string")
    throw new TypeError("Expected a string");
  input2 = REPLACEMENTS[input2] || input2;
  const opts = { ...options2 }, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  let len = input2.length;
  if (len > max2)
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
  const bos = { type: "bos", value: "", output: opts.prepend || "" }, tokens = [bos], capture = opts.capture ? "" : "?:", win32 = utils$4.isWindows(options2), PLATFORM_CHARS = constants$1.globChars(win32), EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS), {
    DOT_LITERAL: DOT_LITERAL2,
    PLUS_LITERAL: PLUS_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOT_SLASH: NO_DOT_SLASH2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    QMARK: QMARK2,
    QMARK_NO_DOT: QMARK_NO_DOT2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = PLATFORM_CHARS, globstar = (opts2) => `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`, nodot = opts.dot ? "" : NO_DOT2, qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
  let star3 = opts.bash === !0 ? globstar(opts) : STAR2;
  opts.capture && (star3 = `(${star3})`), typeof opts.noext == "boolean" && (opts.noextglob = opts.noext);
  const state2 = {
    input: input2,
    index: -1,
    start: 0,
    dot: opts.dot === !0,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: !1,
    negated: !1,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: !1,
    tokens
  };
  input2 = utils$4.removePrefix(input2, state2), len = input2.length;
  const extglobs = [], braces2 = [], stack2 = [];
  let prev = bos, value;
  const eos2 = () => state2.index === len - 1, peek2 = state2.peek = (n = 1) => input2[state2.index + n], advance = state2.advance = () => input2[++state2.index] || "", remaining = () => input2.slice(state2.index + 1), consume2 = (value2 = "", num = 0) => {
    state2.consumed += value2, state2.index += num;
  }, append3 = (token2) => {
    state2.output += token2.output != null ? token2.output : token2.value, consume2(token2.value);
  }, negate = () => {
    let count2 = 1;
    for (; peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?"); )
      advance(), state2.start++, count2++;
    return count2 % 2 === 0 ? !1 : (state2.negated = !0, state2.start++, !0);
  }, increment = (type2) => {
    state2[type2]++, stack2.push(type2);
  }, decrement = (type2) => {
    state2[type2]--, stack2.pop();
  }, push2 = (tok) => {
    if (prev.type === "globstar") {
      const isBrace = state2.braces > 0 && (tok.type === "comma" || tok.type === "brace"), isExtglob = tok.extglob === !0 || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
      tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob && (state2.output = state2.output.slice(0, -prev.output.length), prev.type = "star", prev.value = "*", prev.output = star3, state2.output += prev.output);
    }
    if (extglobs.length && tok.type !== "paren" && (extglobs[extglobs.length - 1].inner += tok.value), (tok.value || tok.output) && append3(tok), prev && prev.type === "text" && tok.type === "text") {
      prev.value += tok.value, prev.output = (prev.output || "") + tok.value;
      return;
    }
    tok.prev = prev, tokens.push(tok), prev = tok;
  }, extglobOpen = (type2, value2) => {
    const token2 = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
    token2.prev = prev, token2.parens = state2.parens, token2.output = state2.output;
    const output = (opts.capture ? "(" : "") + token2.open;
    increment("parens"), push2({ type: type2, value: value2, output: state2.output ? "" : ONE_CHAR2 }), push2({ type: "paren", extglob: !0, value: advance(), output }), extglobs.push(token2);
  }, extglobClose = (token2) => {
    let output = token2.close + (opts.capture ? ")" : ""), rest;
    if (token2.type === "negate") {
      let extglobStar = star3;
      if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/") && (extglobStar = globstar(opts)), (extglobStar !== star3 || eos2() || /^\)+$/.test(remaining())) && (output = token2.close = `)$))${extglobStar}`), token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        const expression = parse$5(rest, { ...options2, fastpaths: !1 }).output;
        output = token2.close = `)${expression})${extglobStar})`;
      }
      token2.prev.type === "bos" && (state2.negatedExtglob = !0);
    }
    push2({ type: "paren", extglob: !0, value, output }), decrement("parens");
  };
  if (opts.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(input2)) {
    let backslashes = !1, output = input2.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first2, rest, index) => first2 === "\\" ? (backslashes = !0, m) : first2 === "?" ? esc ? esc + first2 + (rest ? QMARK2.repeat(rest.length) : "") : index === 0 ? qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "") : QMARK2.repeat(chars.length) : first2 === "." ? DOT_LITERAL2.repeat(chars.length) : first2 === "*" ? esc ? esc + first2 + (rest ? star3 : "") : star3 : esc ? m : `\\${m}`);
    return backslashes === !0 && (opts.unescape === !0 ? output = output.replace(/\\/g, "") : output = output.replace(/\\+/g, (m) => m.length % 2 === 0 ? "\\\\" : m ? "\\" : "")), output === input2 && opts.contains === !0 ? (state2.output = input2, state2) : (state2.output = utils$4.wrapOutput(output, state2, options2), state2);
  }
  for (; !eos2(); ) {
    if (value = advance(), value === "\0")
      continue;
    if (value === "\\") {
      const next = peek2();
      if (next === "/" && opts.bash !== !0 || next === "." || next === ";")
        continue;
      if (!next) {
        value += "\\", push2({ type: "text", value });
        continue;
      }
      const match3 = /^\\+/.exec(remaining());
      let slashes = 0;
      if (match3 && match3[0].length > 2 && (slashes = match3[0].length, state2.index += slashes, slashes % 2 !== 0 && (value += "\\")), opts.unescape === !0 ? value = advance() : value += advance(), state2.brackets === 0) {
        push2({ type: "text", value });
        continue;
      }
    }
    if (state2.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
      if (opts.posix !== !1 && value === ":") {
        const inner = prev.value.slice(1);
        if (inner.includes("[") && (prev.posix = !0, inner.includes(":"))) {
          const idx = prev.value.lastIndexOf("["), pre = prev.value.slice(0, idx), rest2 = prev.value.slice(idx + 2), posix = POSIX_REGEX_SOURCE[rest2];
          if (posix) {
            prev.value = pre + posix, state2.backtrack = !0, advance(), !bos.output && tokens.indexOf(prev) === 1 && (bos.output = ONE_CHAR2);
            continue;
          }
        }
      }
      (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") && (value = `\\${value}`), value === "]" && (prev.value === "[" || prev.value === "[^") && (value = `\\${value}`), opts.posix === !0 && value === "!" && prev.value === "[" && (value = "^"), prev.value += value, append3({ value });
      continue;
    }
    if (state2.quotes === 1 && value !== '"') {
      value = utils$4.escapeRegex(value), prev.value += value, append3({ value });
      continue;
    }
    if (value === '"') {
      state2.quotes = state2.quotes === 1 ? 0 : 1, opts.keepQuotes === !0 && push2({ type: "text", value });
      continue;
    }
    if (value === "(") {
      increment("parens"), push2({ type: "paren", value });
      continue;
    }
    if (value === ")") {
      if (state2.parens === 0 && opts.strictBrackets === !0)
        throw new SyntaxError(syntaxError("opening", "("));
      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state2.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }
      push2({ type: "paren", value, output: state2.parens ? ")" : "\\)" }), decrement("parens");
      continue;
    }
    if (value === "[") {
      if (opts.nobracket === !0 || !remaining().includes("]")) {
        if (opts.nobracket !== !0 && opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", "]"));
        value = `\\${value}`;
      } else
        increment("brackets");
      push2({ type: "bracket", value });
      continue;
    }
    if (value === "]") {
      if (opts.nobracket === !0 || prev && prev.type === "bracket" && prev.value.length === 1) {
        push2({ type: "text", value, output: `\\${value}` });
        continue;
      }
      if (state2.brackets === 0) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("opening", "["));
        push2({ type: "text", value, output: `\\${value}` });
        continue;
      }
      decrement("brackets");
      const prevValue = prev.value.slice(1);
      if (prev.posix !== !0 && prevValue[0] === "^" && !prevValue.includes("/") && (value = `/${value}`), prev.value += value, append3({ value }), opts.literalBrackets === !1 || utils$4.hasRegexChars(prevValue))
        continue;
      const escaped = utils$4.escapeRegex(prev.value);
      if (state2.output = state2.output.slice(0, -prev.value.length), opts.literalBrackets === !0) {
        state2.output += escaped, prev.value = escaped;
        continue;
      }
      prev.value = `(${capture}${escaped}|${prev.value})`, state2.output += prev.value;
      continue;
    }
    if (value === "{" && opts.nobrace !== !0) {
      increment("braces");
      const open2 = {
        type: "brace",
        value,
        output: "(",
        outputIndex: state2.output.length,
        tokensIndex: state2.tokens.length
      };
      braces2.push(open2), push2(open2);
      continue;
    }
    if (value === "}") {
      const brace = braces2[braces2.length - 1];
      if (opts.nobrace === !0 || !brace) {
        push2({ type: "text", value, output: value });
        continue;
      }
      let output = ")";
      if (brace.dots === !0) {
        const arr = tokens.slice(), range2 = [];
        for (let i2 = arr.length - 1; i2 >= 0 && (tokens.pop(), arr[i2].type !== "brace"); i2--)
          arr[i2].type !== "dots" && range2.unshift(arr[i2].value);
        output = expandRange(range2, opts), state2.backtrack = !0;
      }
      if (brace.comma !== !0 && brace.dots !== !0) {
        const out = state2.output.slice(0, brace.outputIndex), toks = state2.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = "\\{", value = output = "\\}", state2.output = out;
        for (const t of toks)
          state2.output += t.output || t.value;
      }
      push2({ type: "brace", value, output }), decrement("braces"), braces2.pop();
      continue;
    }
    if (value === "|") {
      extglobs.length > 0 && extglobs[extglobs.length - 1].conditions++, push2({ type: "text", value });
      continue;
    }
    if (value === ",") {
      let output = value;
      const brace = braces2[braces2.length - 1];
      brace && stack2[stack2.length - 1] === "braces" && (brace.comma = !0, output = "|"), push2({ type: "comma", value, output });
      continue;
    }
    if (value === "/") {
      if (prev.type === "dot" && state2.index === state2.start + 1) {
        state2.start = state2.index + 1, state2.consumed = "", state2.output = "", tokens.pop(), prev = bos;
        continue;
      }
      push2({ type: "slash", value, output: SLASH_LITERAL2 });
      continue;
    }
    if (value === ".") {
      if (state2.braces > 0 && prev.type === "dot") {
        prev.value === "." && (prev.output = DOT_LITERAL2);
        const brace = braces2[braces2.length - 1];
        prev.type = "dots", prev.output += value, prev.value += value, brace.dots = !0;
        continue;
      }
      if (state2.braces + state2.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
        push2({ type: "text", value, output: DOT_LITERAL2 });
        continue;
      }
      push2({ type: "dot", value, output: DOT_LITERAL2 });
      continue;
    }
    if (value === "?") {
      if (!(prev && prev.value === "(") && opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
        extglobOpen("qmark", value);
        continue;
      }
      if (prev && prev.type === "paren") {
        const next = peek2();
        let output = value;
        if (next === "<" && !utils$4.supportsLookbehinds())
          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) && (output = `\\${value}`), push2({ type: "text", value, output });
        continue;
      }
      if (opts.dot !== !0 && (prev.type === "slash" || prev.type === "bos")) {
        push2({ type: "qmark", value, output: QMARK_NO_DOT2 });
        continue;
      }
      push2({ type: "qmark", value, output: QMARK2 });
      continue;
    }
    if (value === "!") {
      if (opts.noextglob !== !0 && peek2() === "(" && (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3)))) {
        extglobOpen("negate", value);
        continue;
      }
      if (opts.nonegate !== !0 && state2.index === 0) {
        negate();
        continue;
      }
    }
    if (value === "+") {
      if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
        extglobOpen("plus", value);
        continue;
      }
      if (prev && prev.value === "(" || opts.regex === !1) {
        push2({ type: "plus", value, output: PLUS_LITERAL2 });
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state2.parens > 0) {
        push2({ type: "plus", value });
        continue;
      }
      push2({ type: "plus", value: PLUS_LITERAL2 });
      continue;
    }
    if (value === "@") {
      if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
        push2({ type: "at", extglob: !0, value, output: "" });
        continue;
      }
      push2({ type: "text", value });
      continue;
    }
    if (value !== "*") {
      (value === "$" || value === "^") && (value = `\\${value}`);
      const match3 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      match3 && (value += match3[0], state2.index += match3[0].length), push2({ type: "text", value });
      continue;
    }
    if (prev && (prev.type === "globstar" || prev.star === !0)) {
      prev.type = "star", prev.star = !0, prev.value += value, prev.output = star3, state2.backtrack = !0, state2.globstar = !0, consume2(value);
      continue;
    }
    let rest = remaining();
    if (opts.noextglob !== !0 && /^\([^?]/.test(rest)) {
      extglobOpen("star", value);
      continue;
    }
    if (prev.type === "star") {
      if (opts.noglobstar === !0) {
        consume2(value);
        continue;
      }
      const prior = prev.prev, before = prior.prev, isStart = prior.type === "slash" || prior.type === "bos", afterStar = before && (before.type === "star" || before.type === "globstar");
      if (opts.bash === !0 && (!isStart || rest[0] && rest[0] !== "/")) {
        push2({ type: "star", value, output: "" });
        continue;
      }
      const isBrace = state2.braces > 0 && (prior.type === "comma" || prior.type === "brace"), isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
      if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
        push2({ type: "star", value, output: "" });
        continue;
      }
      for (; rest.slice(0, 3) === "/**"; ) {
        const after = input2[state2.index + 4];
        if (after && after !== "/")
          break;
        rest = rest.slice(3), consume2("/**", 3);
      }
      if (prior.type === "bos" && eos2()) {
        prev.type = "globstar", prev.value += value, prev.output = globstar(opts), state2.output = prev.output, state2.globstar = !0, consume2(value);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos2()) {
        state2.output = state2.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)"), prev.value += value, state2.globstar = !0, state2.output += prior.output + prev.output, consume2(value);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
        const end2 = rest[1] !== void 0 ? "|$" : "";
        state2.output = state2.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end2})`, prev.value += value, state2.output += prior.output + prev.output, state2.globstar = !0, consume2(value + advance()), push2({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (prior.type === "bos" && rest[0] === "/") {
        prev.type = "globstar", prev.value += value, prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`, state2.output = prev.output, state2.globstar = !0, consume2(value + advance()), push2({ type: "slash", value: "/", output: "" });
        continue;
      }
      state2.output = state2.output.slice(0, -prev.output.length), prev.type = "globstar", prev.output = globstar(opts), prev.value += value, state2.output += prev.output, state2.globstar = !0, consume2(value);
      continue;
    }
    const token2 = { type: "star", value, output: star3 };
    if (opts.bash === !0) {
      token2.output = ".*?", (prev.type === "bos" || prev.type === "slash") && (token2.output = nodot + token2.output), push2(token2);
      continue;
    }
    if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === !0) {
      token2.output = value, push2(token2);
      continue;
    }
    (state2.index === state2.start || prev.type === "slash" || prev.type === "dot") && (prev.type === "dot" ? (state2.output += NO_DOT_SLASH2, prev.output += NO_DOT_SLASH2) : opts.dot === !0 ? (state2.output += NO_DOTS_SLASH2, prev.output += NO_DOTS_SLASH2) : (state2.output += nodot, prev.output += nodot), peek2() !== "*" && (state2.output += ONE_CHAR2, prev.output += ONE_CHAR2)), push2(token2);
  }
  for (; state2.brackets > 0; ) {
    if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError("closing", "]"));
    state2.output = utils$4.escapeLast(state2.output, "["), decrement("brackets");
  }
  for (; state2.parens > 0; ) {
    if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError("closing", ")"));
    state2.output = utils$4.escapeLast(state2.output, "("), decrement("parens");
  }
  for (; state2.braces > 0; ) {
    if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError("closing", "}"));
    state2.output = utils$4.escapeLast(state2.output, "{"), decrement("braces");
  }
  if (opts.strictSlashes !== !0 && (prev.type === "star" || prev.type === "bracket") && push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` }), state2.backtrack === !0) {
    state2.output = "";
    for (const token2 of state2.tokens)
      state2.output += token2.output != null ? token2.output : token2.value, token2.suffix && (state2.output += token2.suffix);
  }
  return state2;
};
parse$5.fastpaths = (input2, options2) => {
  const opts = { ...options2 }, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input2.length;
  if (len > max2)
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
  input2 = REPLACEMENTS[input2] || input2;
  const win32 = utils$4.isWindows(options2), {
    DOT_LITERAL: DOT_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOTS: NO_DOTS2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = constants$1.globChars(win32), nodot = opts.dot ? NO_DOTS2 : NO_DOT2, slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2, capture = opts.capture ? "" : "?:", state2 = { negated: !1, prefix: "" };
  let star3 = opts.bash === !0 ? ".*?" : STAR2;
  opts.capture && (star3 = `(${star3})`);
  const globstar = (opts2) => opts2.noglobstar === !0 ? star3 : `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`, create2 = (str2) => {
    switch (str2) {
      case "*":
        return `${nodot}${ONE_CHAR2}${star3}`;
      case ".*":
        return `${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
      case "*.*":
        return `${nodot}${star3}${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
      case "*/*":
        return `${nodot}${star3}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star3}`;
      case "**":
        return nodot + globstar(opts);
      case "**/*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star3}`;
      case "**/*.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star3}${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
      case "**/.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
      default: {
        const match3 = /^(.*?)\.(\w+)$/.exec(str2);
        if (!match3) return;
        const source3 = create2(match3[1]);
        return source3 ? source3 + DOT_LITERAL2 + match3[2] : void 0;
      }
    }
  }, output = utils$4.removePrefix(input2, state2);
  let source2 = create2(output);
  return source2 && opts.strictSlashes !== !0 && (source2 += `${SLASH_LITERAL2}?`), source2;
};
var parse_1$1 = parse$5;
const path$a = require$$0__default.default, scan$1 = scan_1, parse$4 = parse_1$1, utils$3 = utils$6, constants = constants$2, isObject$4 = (val) => val && typeof val == "object" && !Array.isArray(val), picomatch$2 = (glob2, options2, returnState = !1) => {
  if (Array.isArray(glob2)) {
    const fns = glob2.map((input2) => picomatch$2(input2, options2, returnState));
    return (str2) => {
      for (const isMatch of fns) {
        const state3 = isMatch(str2);
        if (state3) return state3;
      }
      return !1;
    };
  }
  const isState = isObject$4(glob2) && glob2.tokens && glob2.input;
  if (glob2 === "" || typeof glob2 != "string" && !isState)
    throw new TypeError("Expected pattern to be a non-empty string");
  const opts = options2 || {}, posix = utils$3.isWindows(options2), regex = isState ? picomatch$2.compileRe(glob2, options2) : picomatch$2.makeRe(glob2, options2, !1, !0), state2 = regex.state;
  delete regex.state;
  let isIgnored2 = () => !1;
  if (opts.ignore) {
    const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
    isIgnored2 = picomatch$2(opts.ignore, ignoreOpts, returnState);
  }
  const matcher = (input2, returnObject = !1) => {
    const { isMatch, match: match3, output } = picomatch$2.test(input2, regex, options2, { glob: glob2, posix }), result = { glob: glob2, state: state2, regex, posix, input: input2, output, match: match3, isMatch };
    return typeof opts.onResult == "function" && opts.onResult(result), isMatch === !1 ? (result.isMatch = !1, returnObject ? result : !1) : isIgnored2(input2) ? (typeof opts.onIgnore == "function" && opts.onIgnore(result), result.isMatch = !1, returnObject ? result : !1) : (typeof opts.onMatch == "function" && opts.onMatch(result), returnObject ? result : !0);
  };
  return returnState && (matcher.state = state2), matcher;
};
picomatch$2.test = (input2, regex, options2, { glob: glob2, posix } = {}) => {
  if (typeof input2 != "string")
    throw new TypeError("Expected input to be a string");
  if (input2 === "")
    return { isMatch: !1, output: "" };
  const opts = options2 || {}, format2 = opts.format || (posix ? utils$3.toPosixSlashes : null);
  let match3 = input2 === glob2, output = match3 && format2 ? format2(input2) : input2;
  return match3 === !1 && (output = format2 ? format2(input2) : input2, match3 = output === glob2), (match3 === !1 || opts.capture === !0) && (opts.matchBase === !0 || opts.basename === !0 ? match3 = picomatch$2.matchBase(input2, regex, options2, posix) : match3 = regex.exec(output)), { isMatch: !!match3, match: match3, output };
};
picomatch$2.matchBase = (input2, glob2, options2, posix = utils$3.isWindows(options2)) => (glob2 instanceof RegExp ? glob2 : picomatch$2.makeRe(glob2, options2)).test(path$a.basename(input2));
picomatch$2.isMatch = (str2, patterns, options2) => picomatch$2(patterns, options2)(str2);
picomatch$2.parse = (pattern, options2) => Array.isArray(pattern) ? pattern.map((p) => picomatch$2.parse(p, options2)) : parse$4(pattern, { ...options2, fastpaths: !1 });
picomatch$2.scan = (input2, options2) => scan$1(input2, options2);
picomatch$2.compileRe = (state2, options2, returnOutput = !1, returnState = !1) => {
  if (returnOutput === !0)
    return state2.output;
  const opts = options2 || {}, prepend = opts.contains ? "" : "^", append3 = opts.contains ? "" : "$";
  let source2 = `${prepend}(?:${state2.output})${append3}`;
  state2 && state2.negated === !0 && (source2 = `^(?!${source2}).*$`);
  const regex = picomatch$2.toRegex(source2, options2);
  return returnState === !0 && (regex.state = state2), regex;
};
picomatch$2.makeRe = (input2, options2 = {}, returnOutput = !1, returnState = !1) => {
  if (!input2 || typeof input2 != "string")
    throw new TypeError("Expected a non-empty string");
  let parsed = { negated: !1, fastpaths: !0 };
  return options2.fastpaths !== !1 && (input2[0] === "." || input2[0] === "*") && (parsed.output = parse$4.fastpaths(input2, options2)), parsed.output || (parsed = parse$4(input2, options2)), picomatch$2.compileRe(parsed, options2, returnOutput, returnState);
};
picomatch$2.toRegex = (source2, options2) => {
  try {
    const opts = options2 || {};
    return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
  } catch (err) {
    if (options2 && options2.debug === !0) throw err;
    return /$^/;
  }
};
picomatch$2.constants = constants;
var picomatch_1 = picomatch$2, picomatch$1 = picomatch_1;
const util$2 = require$$0__default$5.default, braces = braces_1, picomatch = picomatch$1, utils$2 = utils$6, isEmptyString = (val) => val === "" || val === "./", micromatch = (list2, patterns, options2) => {
  patterns = [].concat(patterns), list2 = [].concat(list2);
  let omit = /* @__PURE__ */ new Set(), keep = /* @__PURE__ */ new Set(), items = /* @__PURE__ */ new Set(), negatives = 0, onResult = (state2) => {
    items.add(state2.output), options2 && options2.onResult && options2.onResult(state2);
  };
  for (let i2 = 0; i2 < patterns.length; i2++) {
    let isMatch = picomatch(String(patterns[i2]), { ...options2, onResult }, !0), negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    negated && negatives++;
    for (let item of list2) {
      let matched = isMatch(item, !0);
      (negated ? !matched.isMatch : matched.isMatch) && (negated ? omit.add(matched.output) : (omit.delete(matched.output), keep.add(matched.output)));
    }
  }
  let matches2 = (negatives === patterns.length ? [...items] : [...keep]).filter((item) => !omit.has(item));
  if (options2 && matches2.length === 0) {
    if (options2.failglob === !0)
      throw new Error(`No matches found for "${patterns.join(", ")}"`);
    if (options2.nonull === !0 || options2.nullglob === !0)
      return options2.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
  }
  return matches2;
};
micromatch.match = micromatch;
micromatch.matcher = (pattern, options2) => picomatch(pattern, options2);
micromatch.isMatch = (str2, patterns, options2) => picomatch(patterns, options2)(str2);
micromatch.any = micromatch.isMatch;
micromatch.not = (list2, patterns, options2 = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = /* @__PURE__ */ new Set(), items = [], onResult = (state2) => {
    options2.onResult && options2.onResult(state2), items.push(state2.output);
  }, matches2 = new Set(micromatch(list2, patterns, { ...options2, onResult }));
  for (let item of items)
    matches2.has(item) || result.add(item);
  return [...result];
};
micromatch.contains = (str2, pattern, options2) => {
  if (typeof str2 != "string")
    throw new TypeError(`Expected a string: "${util$2.inspect(str2)}"`);
  if (Array.isArray(pattern))
    return pattern.some((p) => micromatch.contains(str2, p, options2));
  if (typeof pattern == "string") {
    if (isEmptyString(str2) || isEmptyString(pattern))
      return !1;
    if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern))
      return !0;
  }
  return micromatch.isMatch(str2, pattern, { ...options2, contains: !0 });
};
micromatch.matchKeys = (obj, patterns, options2) => {
  if (!utils$2.isObject(obj))
    throw new TypeError("Expected the first argument to be an object");
  let keys = micromatch(Object.keys(obj), patterns, options2), res = {};
  for (let key2 of keys) res[key2] = obj[key2];
  return res;
};
micromatch.some = (list2, patterns, options2) => {
  let items = [].concat(list2);
  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options2);
    if (items.some((item) => isMatch(item)))
      return !0;
  }
  return !1;
};
micromatch.every = (list2, patterns, options2) => {
  let items = [].concat(list2);
  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options2);
    if (!items.every((item) => isMatch(item)))
      return !1;
  }
  return !0;
};
micromatch.all = (str2, patterns, options2) => {
  if (typeof str2 != "string")
    throw new TypeError(`Expected a string: "${util$2.inspect(str2)}"`);
  return [].concat(patterns).every((p) => picomatch(p, options2)(str2));
};
micromatch.capture = (glob2, input2, options2) => {
  let posix = utils$2.isWindows(options2), match3 = picomatch.makeRe(String(glob2), { ...options2, capture: !0 }).exec(posix ? utils$2.toPosixSlashes(input2) : input2);
  if (match3)
    return match3.slice(1).map((v) => v === void 0 ? "" : v);
};
micromatch.makeRe = (...args) => picomatch.makeRe(...args);
micromatch.scan = (...args) => picomatch.scan(...args);
micromatch.parse = (patterns, options2) => {
  let res = [];
  for (let pattern of [].concat(patterns || []))
    for (let str2 of braces(String(pattern), options2))
      res.push(picomatch.parse(str2, options2));
  return res;
};
micromatch.braces = (pattern, options2) => {
  if (typeof pattern != "string") throw new TypeError("Expected a string");
  return options2 && options2.nobrace === !0 || !/\{.*\}/.test(pattern) ? [pattern] : braces(pattern, options2);
};
micromatch.braceExpand = (pattern, options2) => {
  if (typeof pattern != "string") throw new TypeError("Expected a string");
  return micromatch.braces(pattern, { ...options2, expand: !0 });
};
var micromatch_1$1 = micromatch, __importDefault$1 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};
Object.defineProperty(core$3, "__esModule", { value: !0 });
core$3.readPackageJSON = core$3.extractWorkspaces = core$3.isMatchWorkspaces = core$3.checkWorkspaces = core$3.findWorkspaceRoot = void 0;
const path_1 = __importDefault$1(require$$0__default.default), pkg_dir_1 = __importDefault$1(pkgDir__default.default), fs_1 = require$$0__default$1.default, micromatch_1 = __importDefault$1(micromatch_1$1);
function findWorkspaceRoot(initial) {
  initial || (initial = process.cwd());
  let _pkg = pkg_dir_1.default.sync(initial);
  if (!_pkg)
    return null;
  initial = path_1.default.normalize(_pkg);
  let previous = null, current = initial;
  do {
    const manifest = readPackageJSON(current);
    extractWorkspaces(manifest);
    let { done, found } = checkWorkspaces(current, initial);
    if (done)
      return found;
    previous = current, current = path_1.default.dirname(current);
  } while (current !== previous);
  return null;
}
core$3.findWorkspaceRoot = findWorkspaceRoot;
function checkWorkspaces(current, initial) {
  const manifest = readPackageJSON(current), workspaces = extractWorkspaces(manifest);
  let done = !1, found, relativePath;
  return workspaces && (done = !0, relativePath = path_1.default.relative(current, initial), relativePath === "" || isMatchWorkspaces(relativePath, workspaces) ? found = current : found = null), {
    done,
    found,
    relativePath
  };
}
core$3.checkWorkspaces = checkWorkspaces;
function isMatchWorkspaces(relativePath, workspaces) {
  return micromatch_1.default([relativePath], workspaces).length > 0;
}
core$3.isMatchWorkspaces = isMatchWorkspaces;
function extractWorkspaces(manifest) {
  const workspaces = (manifest || {}).workspaces;
  return workspaces && workspaces.packages || (Array.isArray(workspaces) ? workspaces : null);
}
core$3.extractWorkspaces = extractWorkspaces;
function readPackageJSON(dir) {
  const file2 = path_1.default.join(dir, "package.json");
  return fs_1.existsSync(file2) ? JSON.parse(fs_1.readFileSync(file2, "utf8")) : null;
}
core$3.readPackageJSON = readPackageJSON;
findWorkspaceRoot.findWorkspaceRoot = findWorkspaceRoot;
findWorkspaceRoot.readPackageJSON = readPackageJSON;
findWorkspaceRoot.extractWorkspaces = extractWorkspaces;
findWorkspaceRoot.isMatchWorkspaces = isMatchWorkspaces;
findWorkspaceRoot.default = findWorkspaceRoot;
core$3.default = findWorkspaceRoot;
const core_1 = core$3;
var findYarnWorkspaceRoot2 = core_1.findWorkspaceRoot, findUp$1 = { exports: {} }, locatePath = { exports: {} };
class Node {
  /// value;
  /// next;
  constructor(value) {
    this.value = value, this.next = void 0;
  }
}
let Queue$1 = class {
  // TODO: Use private class fields when targeting Node.js 12.
  // #_head;
  // #_tail;
  // #_size;
  constructor() {
    this.clear();
  }
  enqueue(value) {
    const node2 = new Node(value);
    this._head ? (this._tail.next = node2, this._tail = node2) : (this._head = node2, this._tail = node2), this._size++;
  }
  dequeue() {
    const current = this._head;
    if (current)
      return this._head = this._head.next, this._size--, current.value;
  }
  clear() {
    this._head = void 0, this._tail = void 0, this._size = 0;
  }
  get size() {
    return this._size;
  }
  *[Symbol.iterator]() {
    let current = this._head;
    for (; current; )
      yield current.value, current = current.next;
  }
};
var yoctoQueue = Queue$1;
const Queue = yoctoQueue, pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === 1 / 0) && concurrency > 0))
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  const queue2 = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--, queue2.size > 0 && queue2.dequeue()();
  }, run = async (fn2, resolve2, ...args) => {
    activeCount++;
    const result = (async () => fn2(...args))();
    resolve2(result);
    try {
      await result;
    } catch {
    }
    next();
  }, enqueue2 = (fn2, resolve2, ...args) => {
    queue2.enqueue(run.bind(null, fn2, resolve2, ...args)), (async () => (await Promise.resolve(), activeCount < concurrency && queue2.size > 0 && queue2.dequeue()()))();
  }, generator = (fn2, ...args) => new Promise((resolve2) => {
    enqueue2(fn2, resolve2, ...args);
  });
  return Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue2.size
    },
    clearQueue: {
      value: () => {
        queue2.clear();
      }
    }
  }), generator;
};
var pLimit_1 = pLimit$1;
const pLimit = pLimit_1;
class EndError extends Error {
  constructor(value) {
    super(), this.value = value;
  }
}
const testElement = async (element, tester) => tester(await element), finder = async (element) => {
  const values = await Promise.all(element);
  if (values[1] === !0)
    throw new EndError(values[0]);
  return !1;
}, pLocate$1 = async (iterable, tester, options2) => {
  options2 = {
    concurrency: 1 / 0,
    preserveOrder: !0,
    ...options2
  };
  const limit = pLimit(options2.concurrency), items = [...iterable].map((element) => [element, limit(testElement, element, tester)]), checkLimit = pLimit(options2.preserveOrder ? 1 : 1 / 0);
  try {
    await Promise.all(items.map((element) => checkLimit(finder, element)));
  } catch (error2) {
    if (error2 instanceof EndError)
      return error2.value;
    throw error2;
  }
};
var pLocate_1 = pLocate$1;
const path$9 = require$$0__default.default, fs$7 = require$$0__default$1.default, { promisify: promisify$1 } = require$$0__default$5.default, pLocate = pLocate_1, fsStat = promisify$1(fs$7.stat), fsLStat = promisify$1(fs$7.lstat), typeMappings = {
  directory: "isDirectory",
  file: "isFile"
};
function checkType({ type: type2 }) {
  if (!(type2 in typeMappings))
    throw new Error(`Invalid type specified: ${type2}`);
}
const matchType = (type2, stat) => type2 === void 0 || stat[typeMappings[type2]]();
locatePath.exports = async (paths, options2) => {
  options2 = {
    cwd: process.cwd(),
    type: "file",
    allowSymlinks: !0,
    ...options2
  }, checkType(options2);
  const statFn = options2.allowSymlinks ? fsStat : fsLStat;
  return pLocate(paths, async (path_) => {
    try {
      const stat = await statFn(path$9.resolve(options2.cwd, path_));
      return matchType(options2.type, stat);
    } catch {
      return !1;
    }
  }, options2);
};
locatePath.exports.sync = (paths, options2) => {
  options2 = {
    cwd: process.cwd(),
    allowSymlinks: !0,
    type: "file",
    ...options2
  }, checkType(options2);
  const statFn = options2.allowSymlinks ? fs$7.statSync : fs$7.lstatSync;
  for (const path_ of paths)
    try {
      const stat = statFn(path$9.resolve(options2.cwd, path_));
      if (matchType(options2.type, stat))
        return path_;
    } catch {
    }
};
var locatePathExports = locatePath.exports, pathExists$4 = { exports: {} };
const fs$6 = require$$0__default$1.default, { promisify } = require$$0__default$5.default, pAccess = promisify(fs$6.access);
pathExists$4.exports = async (path2) => {
  try {
    return await pAccess(path2), !0;
  } catch {
    return !1;
  }
};
pathExists$4.exports.sync = (path2) => {
  try {
    return fs$6.accessSync(path2), !0;
  } catch {
    return !1;
  }
};
var pathExistsExports = pathExists$4.exports;
(function(module2) {
  const path2 = require$$0__default.default, locatePath2 = locatePathExports, pathExists2 = pathExistsExports, stop = Symbol("findUp.stop");
  module2.exports = async (name, options2 = {}) => {
    let directory = path2.resolve(options2.cwd || "");
    const { root: root2 } = path2.parse(directory), paths = [].concat(name), runMatcher = async (locateOptions) => {
      if (typeof name != "function")
        return locatePath2(paths, locateOptions);
      const foundPath = await name(locateOptions.cwd);
      return typeof foundPath == "string" ? locatePath2([foundPath], locateOptions) : foundPath;
    };
    for (; ; ) {
      const foundPath = await runMatcher({ ...options2, cwd: directory });
      if (foundPath === stop)
        return;
      if (foundPath)
        return path2.resolve(directory, foundPath);
      if (directory === root2)
        return;
      directory = path2.dirname(directory);
    }
  }, module2.exports.sync = (name, options2 = {}) => {
    let directory = path2.resolve(options2.cwd || "");
    const { root: root2 } = path2.parse(directory), paths = [].concat(name), runMatcher = (locateOptions) => {
      if (typeof name != "function")
        return locatePath2.sync(paths, locateOptions);
      const foundPath = name(locateOptions.cwd);
      return typeof foundPath == "string" ? locatePath2.sync([foundPath], locateOptions) : foundPath;
    };
    for (; ; ) {
      const foundPath = runMatcher({ ...options2, cwd: directory });
      if (foundPath === stop)
        return;
      if (foundPath)
        return path2.resolve(directory, foundPath);
      if (directory === root2)
        return;
      directory = path2.dirname(directory);
    }
  }, module2.exports.exists = pathExists2, module2.exports.sync.exists = pathExists2.sync, module2.exports.stop = stop;
})(findUp$1);
var findUpExports = findUp$1.exports, loadYamlFile$1 = { exports: {} };
const processFn = (fn2, options2) => function(...args) {
  const P = options2.promiseModule;
  return new P((resolve2, reject) => {
    options2.multiArgs ? args.push((...result) => {
      options2.errorFirst ? result[0] ? reject(result) : (result.shift(), resolve2(result)) : resolve2(result);
    }) : options2.errorFirst ? args.push((error2, result) => {
      error2 ? reject(error2) : resolve2(result);
    }) : args.push(resolve2), fn2.apply(this, args);
  });
};
var pify$1 = (input2, options2) => {
  options2 = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, options2);
  const objType = typeof input2;
  if (!(input2 !== null && (objType === "object" || objType === "function")))
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input2 === null ? "null" : objType}\``);
  const filter2 = (key2) => {
    const match3 = (pattern) => typeof pattern == "string" ? key2 === pattern : pattern.test(key2);
    return options2.include ? options2.include.some(match3) : !options2.exclude.some(match3);
  };
  let ret;
  objType === "function" ? ret = function(...args) {
    return options2.excludeMain ? input2(...args) : processFn(input2, options2).apply(this, args);
  } : ret = Object.create(Object.getPrototypeOf(input2));
  for (const key2 in input2) {
    const property = input2[key2];
    ret[key2] = typeof property == "function" && filter2(key2) ? processFn(property, options2) : property;
  }
  return ret;
}, stripBom$1 = (x) => {
  if (typeof x != "string")
    throw new TypeError("Expected a string, got " + typeof x);
  return x.charCodeAt(0) === 65279 ? x.slice(1) : x;
}, jsYaml$1 = {}, loader$1 = {}, common$7 = {};
function isNothing(subject) {
  return typeof subject > "u" || subject === null;
}
function isObject$3(subject) {
  return typeof subject == "object" && subject !== null;
}
function toArray$1(sequence) {
  return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
}
function extend$2(target, source2) {
  var index, length, key2, sourceKeys;
  if (source2)
    for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
      key2 = sourceKeys[index], target[key2] = source2[key2];
  return target;
}
function repeat$1(string, count2) {
  var result = "", cycle;
  for (cycle = 0; cycle < count2; cycle += 1)
    result += string;
  return result;
}
function isNegativeZero(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
common$7.isNothing = isNothing;
common$7.isObject = isObject$3;
common$7.toArray = toArray$1;
common$7.repeat = repeat$1;
common$7.isNegativeZero = isNegativeZero;
common$7.extend = extend$2;
function YAMLException$4(reason, mark2) {
  Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString5(compact) {
  var result = this.name + ": ";
  return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
};
var exception = YAMLException$4, common$6 = common$7;
function Mark$1(name, buffer2, position, line3, column2) {
  this.name = name, this.buffer = buffer2, this.position = position, this.line = line3, this.column = column2;
}
Mark$1.prototype.getSnippet = function getSnippet2(indent, maxLength) {
  var head, start, tail, end2, snippet2;
  if (!this.buffer) return null;
  for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
    if (start -= 1, this.position - start > maxLength / 2 - 1) {
      head = " ... ", start += 5;
      break;
    }
  for (tail = "", end2 = this.position; end2 < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end2)) === -1; )
    if (end2 += 1, end2 - this.position > maxLength / 2 - 1) {
      tail = " ... ", end2 -= 5;
      break;
    }
  return snippet2 = this.buffer.slice(start, end2), common$6.repeat(" ", indent) + head + snippet2 + tail + `
` + common$6.repeat(" ", indent + this.position - start + head.length) + "^";
};
Mark$1.prototype.toString = function toString6(compact) {
  var snippet2, where = "";
  return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet2 = this.getSnippet(), snippet2 && (where += `:
` + snippet2)), where;
};
var mark = Mark$1, YAMLException$3 = exception, TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
], YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  return map2 !== null && Object.keys(map2).forEach(function(style) {
    map2[style].forEach(function(alias) {
      result[String(alias)] = style;
    });
  }), result;
}
function Type$h(tag, options2) {
  if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
  }), this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
    return !0;
  }, this.construct = options2.construct || function(data) {
    return data;
  }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.defaultStyle = options2.defaultStyle || null, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var type = Type$h, common$5 = common$7, YAMLException$2 = exception, Type$g = type;
function compileList(schema2, name, result) {
  var exclude = [];
  return schema2.include.forEach(function(includedSchema) {
    result = compileList(includedSchema, name, result);
  }), schema2[name].forEach(function(currentType) {
    result.forEach(function(previousType, previousIndex) {
      previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
    }), result.push(currentType);
  }), result.filter(function(type2, index) {
    return exclude.indexOf(index) === -1;
  });
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, index, length;
  function collectType(type2) {
    result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
  }
  for (index = 0, length = arguments.length; index < length; index += 1)
    arguments[index].forEach(collectType);
  return result;
}
function Schema$5(definition) {
  this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type2) {
    if (type2.loadKind && type2.loadKind !== "scalar")
      throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
  }), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}
Schema$5.DEFAULT = null;
Schema$5.create = function createSchema2() {
  var schemas, types2;
  switch (arguments.length) {
    case 1:
      schemas = Schema$5.DEFAULT, types2 = arguments[0];
      break;
    case 2:
      schemas = arguments[0], types2 = arguments[1];
      break;
    default:
      throw new YAMLException$2("Wrong number of arguments for Schema.create function");
  }
  if (schemas = common$5.toArray(schemas), types2 = common$5.toArray(types2), !schemas.every(function(schema2) {
    return schema2 instanceof Schema$5;
  }))
    throw new YAMLException$2("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  if (!types2.every(function(type2) {
    return type2 instanceof Type$g;
  }))
    throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  return new Schema$5({
    include: schemas,
    explicit: types2
  });
};
var schema = Schema$5, Type$f = type, str = new Type$f("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
}), Type$e = type, seq = new Type$e("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
}), Type$d = type, map$1 = new Type$d("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
}), Schema$4 = schema, failsafe = new Schema$4({
  explicit: [
    str,
    seq,
    map$1
  ]
}), Type$c = type;
function resolveYamlNull(data) {
  if (data === null) return !0;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$c("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
}), Type$b = type;
function resolveYamlBoolean(data) {
  if (data === null) return !1;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new Type$b("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), common$4 = common$7, Type$a = type;
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return !1;
  var max2 = data.length, index = 0, hasDigits = !1, ch;
  if (!max2) return !1;
  if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
    if (index + 1 === max2) return !0;
    if (ch = data[++index], ch === "b") {
      for (index++; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (ch !== "0" && ch !== "1") return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      for (index++; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isHexCode(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (!isOctCode(data.charCodeAt(index))) return !1;
        hasDigits = !0;
      }
    return hasDigits && ch !== "_";
  }
  if (ch === "_") return !1;
  for (; index < max2; index++)
    if (ch = data[index], ch !== "_") {
      if (ch === ":") break;
      if (!isDecCode(data.charCodeAt(index)))
        return !1;
      hasDigits = !0;
    }
  return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
  var value = data, sign2 = 1, ch, base2, digits = [];
  return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign2 * parseInt(value.slice(2), 2) : value[1] === "x" ? sign2 * parseInt(value, 16) : sign2 * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
    digits.unshift(parseInt(v, 10));
  }), value = 0, base2 = 1, digits.forEach(function(d) {
    value += d * base2, base2 *= 60;
  }), sign2 * value) : sign2 * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common$4.isNegativeZero(object);
}
var int = new Type$a("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), common$3 = common$7, Type$9 = type, YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_");
}
function constructYamlFloat(data) {
  var value, sign2, base2, digits;
  return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
    digits.unshift(parseFloat(v, 10));
  }), value = 0, base2 = 1, digits.forEach(function(d) {
    value += d * base2, base2 *= 60;
  }), sign2 * value) : sign2 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object))
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (common$3.isNegativeZero(object))
    return "-0.0";
  return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$3.isNegativeZero(object));
}
var float = new Type$9("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
}), Schema$3 = schema, json = new Schema$3({
  include: [
    failsafe
  ],
  implicit: [
    _null,
    bool,
    int,
    float
  ]
}), Schema$2 = schema, core$2 = new Schema$2({
  include: [
    json
  ]
}), Type$8 = type, YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
}
function constructYamlTimestamp(data) {
  var match3, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  if (match3 = YAML_DATE_REGEXP.exec(data), match3 === null && (match3 = YAML_TIMESTAMP_REGEXP.exec(data)), match3 === null) throw new Error("Date resolve error");
  if (year = +match3[1], month = +match3[2] - 1, day = +match3[3], !match3[4])
    return new Date(Date.UTC(year, month, day));
  if (hour = +match3[4], minute = +match3[5], second = +match3[6], match3[7]) {
    for (fraction = match3[7].slice(0, 3); fraction.length < 3; )
      fraction += "0";
    fraction = +fraction;
  }
  return match3[9] && (tz_hour = +match3[10], tz_minute = +(match3[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match3[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp$1 = new Type$8("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
}), Type$7 = type;
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge$2 = new Type$7("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
}), NodeBuffer;
try {
  var _require$1 = commonjsRequire;
  NodeBuffer = _require$1("buffer").Buffer;
} catch (__) {
}
var Type$6 = type, BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function resolveYamlBinary(data) {
  if (data === null) return !1;
  var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++)
    if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
      if (code < 0) return !1;
      bitlen += 6;
    }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++)
    idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
  return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++)
    idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
  return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
}
function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}
var binary$1 = new Type$6("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
}), Type$5 = type, _hasOwnProperty$3 = Object.prototype.hasOwnProperty, _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return !0;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], pairHasKey = !1, _toString$2.call(pair) !== "[object Object]") return !1;
    for (pairKey in pair)
      if (_hasOwnProperty$3.call(pair, pairKey))
        if (!pairHasKey) pairHasKey = !0;
        else return !1;
    if (!pairHasKey) return !1;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return !1;
  }
  return !0;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$5("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
}), Type$4 = type, _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return !0;
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], _toString$1.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return !0;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
    pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
  return result;
}
var pairs$1 = new Type$4("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
}), Type$3 = type, _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return !0;
  var key2, object = data;
  for (key2 in object)
    if (_hasOwnProperty$2.call(object, key2) && object[key2] !== null)
      return !1;
  return !0;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type$3("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
}), Schema$1 = schema, default_safe = new Schema$1({
  include: [
    core$2
  ],
  implicit: [
    timestamp$1,
    merge$2
  ],
  explicit: [
    binary$1,
    omap,
    pairs$1,
    set
  ]
}), Type$2 = type;
function resolveJavascriptUndefined() {
  return !0;
}
function constructJavascriptUndefined() {
}
function representJavascriptUndefined() {
  return "";
}
function isUndefined(object) {
  return typeof object > "u";
}
var _undefined = new Type$2("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
}), Type$1 = type;
function resolveJavascriptRegExp(data) {
  if (data === null || data.length === 0) return !1;
  var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
  return !(regexp2[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp2[regexp2.length - modifiers.length - 1] !== "/"));
}
function constructJavascriptRegExp(data) {
  var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
  return regexp2[0] === "/" && (tail && (modifiers = tail[1]), regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1)), new RegExp(regexp2, modifiers);
}
function representJavascriptRegExp(object) {
  var result = "/" + object.source + "/";
  return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
}
function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var regexp = new Type$1("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
}), esprima$3;
try {
  var _require = commonjsRequire;
  esprima$3 = _require("esprima");
} catch (_2) {
  typeof window < "u" && (esprima$3 = window.esprima);
}
var Type = type;
function resolveJavascriptFunction(data) {
  if (data === null) return !1;
  try {
    var source2 = "(" + data + ")", ast = esprima$3.parse(source2, { range: !0 });
    return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
  } catch {
    return !1;
  }
}
function constructJavascriptFunction(data) {
  var source2 = "(" + data + ")", ast = esprima$3.parse(source2, { range: !0 }), params = [], body;
  if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
    throw new Error("Failed to resolve function");
  return ast.body[0].expression.params.forEach(function(param) {
    params.push(param.name);
  }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source2.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source2.slice(body[0], body[1]));
}
function representJavascriptFunction(object) {
  return object.toString();
}
function isFunction$1(object) {
  return Object.prototype.toString.call(object) === "[object Function]";
}
var _function = new Type("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction$1,
  represent: representJavascriptFunction
}), Schema = schema, default_full = Schema.DEFAULT = new Schema({
  include: [
    default_safe
  ],
  explicit: [
    _undefined,
    regexp,
    _function
  ]
}), common$2 = common$7, YAMLException$1 = exception, Mark = mark, DEFAULT_SAFE_SCHEMA$1 = default_safe, DEFAULT_FULL_SCHEMA$1 = default_full, _hasOwnProperty$1 = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
}
function escapedHexLen(c2) {
  return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
}
function fromDecimalCode(c2) {
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++)
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
function State$1(input2, options2) {
  this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_FULL_SCHEMA$1, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
}
function generateError(state2, message) {
  return new YAMLException$1(
    message,
    new Mark(state2.filename, state2.input, state2.position, state2.line, state2.position - state2.lineStart)
  );
}
function throwError$1(state2, message) {
  throw generateError(state2, message);
}
function throwWarning(state2, message) {
  state2.onWarning && state2.onWarning.call(null, generateError(state2, message));
}
var directiveHandlers = {
  YAML: function handleYamlDirective3(state2, name, args) {
    var match3, major, minor;
    state2.version !== null && throwError$1(state2, "duplication of %YAML directive"), args.length !== 1 && throwError$1(state2, "YAML directive accepts exactly one argument"), match3 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match3 === null && throwError$1(state2, "ill-formed argument of the YAML directive"), major = parseInt(match3[1], 10), minor = parseInt(match3[2], 10), major !== 1 && throwError$1(state2, "unacceptable YAML version of the document"), state2.version = args[0], state2.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning(state2, "unsupported YAML version of the document");
  },
  TAG: function handleTagDirective3(state2, name, args) {
    var handle, prefix;
    args.length !== 2 && throwError$1(state2, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError$1(state2, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty$1.call(state2.tagMap, handle) && throwError$1(state2, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError$1(state2, "ill-formed tag prefix (second argument) of the TAG directive"), state2.tagMap[handle] = prefix;
  }
};
function captureSegment(state2, start, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start < end2) {
    if (_result = state2.input.slice(start, end2), checkJson)
      for (_position = 0, _length = _result.length; _position < _length; _position += 1)
        _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError$1(state2, "expected valid JSON character");
    else PATTERN_NON_PRINTABLE.test(_result) && throwError$1(state2, "the stream contains non-printable characters");
    state2.result += _result;
  }
}
function mergeMappings(state2, destination, source2, overridableKeys) {
  var sourceKeys, key2, index, quantity;
  for (common$2.isObject(source2) || throwError$1(state2, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
    key2 = sourceKeys[index], _hasOwnProperty$1.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
}
function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode))
    for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
      Array.isArray(keyNode[index]) && throwError$1(state2, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
  if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
    if (Array.isArray(valueNode))
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
        mergeMappings(state2, _result, valueNode[index], overridableKeys);
    else
      mergeMappings(state2, _result, valueNode, overridableKeys);
  else
    !state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode) && (state2.line = startLine || state2.line, state2.position = startPos || state2.position, throwError$1(state2, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
  return _result;
}
function readLineBreak(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position), ch === 10 ? state2.position++ : ch === 13 ? (state2.position++, state2.input.charCodeAt(state2.position) === 10 && state2.position++) : throwError$1(state2, "a line break is expected"), state2.line += 1, state2.lineStart = state2.position;
}
function skipSeparationSpace(state2, allowComments, checkIndent) {
  for (var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position); ch !== 0; ) {
    for (; is_WHITE_SPACE(ch); )
      ch = state2.input.charCodeAt(++state2.position);
    if (allowComments && ch === 35)
      do
        ch = state2.input.charCodeAt(++state2.position);
      while (ch !== 10 && ch !== 13 && ch !== 0);
    if (is_EOL(ch))
      for (readLineBreak(state2), ch = state2.input.charCodeAt(state2.position), lineBreaks++, state2.lineIndent = 0; ch === 32; )
        state2.lineIndent++, ch = state2.input.charCodeAt(++state2.position);
    else
      break;
  }
  return checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent && throwWarning(state2, "deficient indentation"), lineBreaks;
}
function testDocumentSeparator(state2) {
  var _position = state2.position, ch;
  return ch = state2.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2) && (_position += 3, ch = state2.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
}
function writeFoldedLines(state2, count2) {
  count2 === 1 ? state2.result += " " : count2 > 1 && (state2.result += common$2.repeat(`
`, count2 - 1));
}
function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  if (ch = state2.input.charCodeAt(state2.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
    return !1;
  for (state2.kind = "scalar", state2.result = "", captureStart = captureEnd = state2.position, hasPendingContent = !1; ch !== 0; ) {
    if (ch === 58) {
      if (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
        break;
    } else if (ch === 35) {
      if (preceding = state2.input.charCodeAt(state2.position - 1), is_WS_OR_EOL(preceding))
        break;
    } else {
      if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch))
        break;
      if (is_EOL(ch))
        if (_line = state2.line, _lineStart = state2.lineStart, _lineIndent = state2.lineIndent, skipSeparationSpace(state2, !1, -1), state2.lineIndent >= nodeIndent) {
          hasPendingContent = !0, ch = state2.input.charCodeAt(state2.position);
          continue;
        } else {
          state2.position = captureEnd, state2.line = _line, state2.lineStart = _lineStart, state2.lineIndent = _lineIndent;
          break;
        }
    }
    hasPendingContent && (captureSegment(state2, captureStart, captureEnd, !1), writeFoldedLines(state2, state2.line - _line), captureStart = captureEnd = state2.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state2.position + 1), ch = state2.input.charCodeAt(++state2.position);
  }
  return captureSegment(state2, captureStart, captureEnd, !1), state2.result ? !0 : (state2.kind = _kind, state2.result = _result, !1);
}
function readSingleQuotedScalar(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 39)
    return !1;
  for (state2.kind = "scalar", state2.result = "", state2.position++, captureStart = captureEnd = state2.position; (ch = state2.input.charCodeAt(state2.position)) !== 0; )
    if (ch === 39)
      if (captureSegment(state2, captureStart, state2.position, !0), ch = state2.input.charCodeAt(++state2.position), ch === 39)
        captureStart = state2.position, state2.position++, captureEnd = state2.position;
      else
        return !0;
    else is_EOL(ch) ? (captureSegment(state2, captureStart, captureEnd, !0), writeFoldedLines(state2, skipSeparationSpace(state2, !1, nodeIndent)), captureStart = captureEnd = state2.position) : state2.position === state2.lineStart && testDocumentSeparator(state2) ? throwError$1(state2, "unexpected end of the document within a single quoted scalar") : (state2.position++, captureEnd = state2.position);
  throwError$1(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 34)
    return !1;
  for (state2.kind = "scalar", state2.result = "", state2.position++, captureStart = captureEnd = state2.position; (ch = state2.input.charCodeAt(state2.position)) !== 0; ) {
    if (ch === 34)
      return captureSegment(state2, captureStart, state2.position, !0), state2.position++, !0;
    if (ch === 92) {
      if (captureSegment(state2, captureStart, state2.position, !0), ch = state2.input.charCodeAt(++state2.position), is_EOL(ch))
        skipSeparationSpace(state2, !1, nodeIndent);
      else if (ch < 256 && simpleEscapeCheck[ch])
        state2.result += simpleEscapeMap[ch], state2.position++;
      else if ((tmp2 = escapedHexLen(ch)) > 0) {
        for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
          ch = state2.input.charCodeAt(++state2.position), (tmp2 = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError$1(state2, "expected hexadecimal character");
        state2.result += charFromCodepoint(hexResult), state2.position++;
      } else
        throwError$1(state2, "unknown escape sequence");
      captureStart = captureEnd = state2.position;
    } else is_EOL(ch) ? (captureSegment(state2, captureStart, captureEnd, !0), writeFoldedLines(state2, skipSeparationSpace(state2, !1, nodeIndent)), captureStart = captureEnd = state2.position) : state2.position === state2.lineStart && testDocumentSeparator(state2) ? throwError$1(state2, "unexpected end of the document within a double quoted scalar") : (state2.position++, captureEnd = state2.position);
  }
  throwError$1(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state2, nodeIndent) {
  var readNext = !0, _line, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch === 91)
    terminator = 93, isMapping = !1, _result = [];
  else if (ch === 123)
    terminator = 125, isMapping = !0, _result = {};
  else
    return !1;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(++state2.position); ch !== 0; ) {
    if (skipSeparationSpace(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), ch === terminator)
      return state2.position++, state2.tag = _tag, state2.anchor = _anchor, state2.kind = isMapping ? "mapping" : "sequence", state2.result = _result, !0;
    readNext || throwError$1(state2, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state2.input.charCodeAt(state2.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state2.position++, skipSeparationSpace(state2, !0, nodeIndent))), _line = state2.line, composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state2.tag, keyNode = state2.result, skipSeparationSpace(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), (isExplicitPair || state2.line === _line) && ch === 58 && (isPair = !0, ch = state2.input.charCodeAt(++state2.position), skipSeparationSpace(state2, !0, nodeIndent), composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state2.result), isMapping ? storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state2, !0, nodeIndent), ch = state2.input.charCodeAt(state2.position), ch === 44 ? (readNext = !0, ch = state2.input.charCodeAt(++state2.position)) : readNext = !1;
  }
  throwError$1(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch === 124)
    folding = !1;
  else if (ch === 62)
    folding = !0;
  else
    return !1;
  for (state2.kind = "scalar", state2.result = ""; ch !== 0; )
    if (ch = state2.input.charCodeAt(++state2.position), ch === 43 || ch === 45)
      CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError$1(state2, "repeat of a chomping mode identifier");
    else if ((tmp2 = fromDecimalCode(ch)) >= 0)
      tmp2 === 0 ? throwError$1(state2, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError$1(state2, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
    else
      break;
  if (is_WHITE_SPACE(ch)) {
    do
      ch = state2.input.charCodeAt(++state2.position);
    while (is_WHITE_SPACE(ch));
    if (ch === 35)
      do
        ch = state2.input.charCodeAt(++state2.position);
      while (!is_EOL(ch) && ch !== 0);
  }
  for (; ch !== 0; ) {
    for (readLineBreak(state2), state2.lineIndent = 0, ch = state2.input.charCodeAt(state2.position); (!detectedIndent || state2.lineIndent < textIndent) && ch === 32; )
      state2.lineIndent++, ch = state2.input.charCodeAt(++state2.position);
    if (!detectedIndent && state2.lineIndent > textIndent && (textIndent = state2.lineIndent), is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      chomping === CHOMPING_KEEP ? state2.result += common$2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state2.result += `
`);
      break;
    }
    for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state2.result += common$2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state2.result += common$2.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state2.result += " ") : state2.result += common$2.repeat(`
`, emptyLines) : state2.result += common$2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state2.position; !is_EOL(ch) && ch !== 0; )
      ch = state2.input.charCodeAt(++state2.position);
    captureSegment(state2, captureStart, state2.position, !1);
  }
  return !0;
}
function readBlockSequence(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = !1, ch;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(state2.position); ch !== 0 && !(ch !== 45 || (following = state2.input.charCodeAt(state2.position + 1), !is_WS_OR_EOL(following))); ) {
    if (detected = !0, state2.position++, skipSeparationSpace(state2, !0, -1) && state2.lineIndent <= nodeIndent) {
      _result.push(null), ch = state2.input.charCodeAt(state2.position);
      continue;
    }
    if (_line = state2.line, composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state2.result), skipSeparationSpace(state2, !0, -1), ch = state2.input.charCodeAt(state2.position), (state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0)
      throwError$1(state2, "bad indentation of a sequence entry");
    else if (state2.lineIndent < nodeIndent)
      break;
  }
  return detected ? (state2.tag = _tag, state2.anchor = _anchor, state2.kind = "sequence", state2.result = _result, !0) : !1;
}
function readBlockMapping(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _pos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
  for (state2.anchor !== null && (state2.anchorMap[state2.anchor] = _result), ch = state2.input.charCodeAt(state2.position); ch !== 0; ) {
    if (following = state2.input.charCodeAt(state2.position + 1), _line = state2.line, _pos = state2.position, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
      ch === 63 ? (atExplicitKey && (storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError$1(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state2.position += 1, ch = following;
    else if (composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
      if (state2.line === _line) {
        for (ch = state2.input.charCodeAt(state2.position); is_WHITE_SPACE(ch); )
          ch = state2.input.charCodeAt(++state2.position);
        if (ch === 58)
          ch = state2.input.charCodeAt(++state2.position), is_WS_OR_EOL(ch) || throwError$1(state2, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state2.tag, keyNode = state2.result;
        else if (detected)
          throwError$1(state2, "can not read an implicit mapping pair; a colon is missed");
        else
          return state2.tag = _tag, state2.anchor = _anchor, !0;
      } else if (detected)
        throwError$1(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return state2.tag = _tag, state2.anchor = _anchor, !0;
    else
      break;
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state2.result : valueNode = state2.result), atExplicitKey || (storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state2, !0, -1), ch = state2.input.charCodeAt(state2.position)), state2.lineIndent > nodeIndent && ch !== 0)
      throwError$1(state2, "bad indentation of a mapping entry");
    else if (state2.lineIndent < nodeIndent)
      break;
  }
  return atExplicitKey && storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null), detected && (state2.tag = _tag, state2.anchor = _anchor, state2.kind = "mapping", state2.result = _result), detected;
}
function readTagProperty(state2) {
  var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 33) return !1;
  if (state2.tag !== null && throwError$1(state2, "duplication of a tag property"), ch = state2.input.charCodeAt(++state2.position), ch === 60 ? (isVerbatim = !0, ch = state2.input.charCodeAt(++state2.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state2.input.charCodeAt(++state2.position)) : tagHandle = "!", _position = state2.position, isVerbatim) {
    do
      ch = state2.input.charCodeAt(++state2.position);
    while (ch !== 0 && ch !== 62);
    state2.position < state2.length ? (tagName = state2.input.slice(_position, state2.position), ch = state2.input.charCodeAt(++state2.position)) : throwError$1(state2, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; ch !== 0 && !is_WS_OR_EOL(ch); )
      ch === 33 && (isNamed ? throwError$1(state2, "tag suffix cannot contain exclamation marks") : (tagHandle = state2.input.slice(_position - 1, state2.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError$1(state2, "named tag handle cannot contain such characters"), isNamed = !0, _position = state2.position + 1)), ch = state2.input.charCodeAt(++state2.position);
    tagName = state2.input.slice(_position, state2.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError$1(state2, "tag suffix cannot contain flow indicator characters");
  }
  return tagName && !PATTERN_TAG_URI.test(tagName) && throwError$1(state2, "tag name cannot contain such characters: " + tagName), isVerbatim ? state2.tag = tagName : _hasOwnProperty$1.call(state2.tagMap, tagHandle) ? state2.tag = state2.tagMap[tagHandle] + tagName : tagHandle === "!" ? state2.tag = "!" + tagName : tagHandle === "!!" ? state2.tag = "tag:yaml.org,2002:" + tagName : throwError$1(state2, 'undeclared tag handle "' + tagHandle + '"'), !0;
}
function readAnchorProperty(state2) {
  var _position, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 38) return !1;
  for (state2.anchor !== null && throwError$1(state2, "duplication of an anchor property"), ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
    ch = state2.input.charCodeAt(++state2.position);
  return state2.position === _position && throwError$1(state2, "name of an anchor node must contain at least one character"), state2.anchor = state2.input.slice(_position, state2.position), !0;
}
function readAlias(state2) {
  var _position, alias, ch;
  if (ch = state2.input.charCodeAt(state2.position), ch !== 42) return !1;
  for (ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
    ch = state2.input.charCodeAt(++state2.position);
  return state2.position === _position && throwError$1(state2, "name of an alias node must contain at least one character"), alias = state2.input.slice(_position, state2.position), _hasOwnProperty$1.call(state2.anchorMap, alias) || throwError$1(state2, 'unidentified alias "' + alias + '"'), state2.result = state2.anchorMap[alias], skipSeparationSpace(state2, !0, -1), !0;
}
function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
  if (state2.listener !== null && state2.listener("open", state2), state2.tag = null, state2.anchor = null, state2.kind = null, state2.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state2, !0, -1) && (atNewLine = !0, state2.lineIndent > parentIndent ? indentStatus = 1 : state2.lineIndent === parentIndent ? indentStatus = 0 : state2.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
    for (; readTagProperty(state2) || readAnchorProperty(state2); )
      skipSeparationSpace(state2, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state2.lineIndent > parentIndent ? indentStatus = 1 : state2.lineIndent === parentIndent ? indentStatus = 0 : state2.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
  if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state2.position - state2.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent) ? hasContent = !0 : readAlias(state2) ? (hasContent = !0, (state2.tag !== null || state2.anchor !== null) && throwError$1(state2, "alias node should not have any properties")) : readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state2.tag === null && (state2.tag = "?")), state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent))), state2.tag !== null && state2.tag !== "!")
    if (state2.tag === "?") {
      for (state2.result !== null && state2.kind !== "scalar" && throwError$1(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"'), typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
        if (type2 = state2.implicitTypes[typeIndex], type2.resolve(state2.result)) {
          state2.result = type2.construct(state2.result), state2.tag = type2.tag, state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result);
          break;
        }
    } else _hasOwnProperty$1.call(state2.typeMap[state2.kind || "fallback"], state2.tag) ? (type2 = state2.typeMap[state2.kind || "fallback"][state2.tag], state2.result !== null && type2.kind !== state2.kind && throwError$1(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"'), type2.resolve(state2.result) ? (state2.result = type2.construct(state2.result), state2.anchor !== null && (state2.anchorMap[state2.anchor] = state2.result)) : throwError$1(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag")) : throwError$1(state2, "unknown tag !<" + state2.tag + ">");
  return state2.listener !== null && state2.listener("close", state2), state2.tag !== null || state2.anchor !== null || hasContent;
}
function readDocument(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
  for (state2.version = null, state2.checkLineBreaks = state2.legacy, state2.tagMap = {}, state2.anchorMap = {}; (ch = state2.input.charCodeAt(state2.position)) !== 0 && (skipSeparationSpace(state2, !0, -1), ch = state2.input.charCodeAt(state2.position), !(state2.lineIndent > 0 || ch !== 37)); ) {
    for (hasDirectives = !0, ch = state2.input.charCodeAt(++state2.position), _position = state2.position; ch !== 0 && !is_WS_OR_EOL(ch); )
      ch = state2.input.charCodeAt(++state2.position);
    for (directiveName = state2.input.slice(_position, state2.position), directiveArgs = [], directiveName.length < 1 && throwError$1(state2, "directive name must not be less than one character in length"); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch = state2.input.charCodeAt(++state2.position);
      if (ch === 35) {
        do
          ch = state2.input.charCodeAt(++state2.position);
        while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      for (_position = state2.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state2.input.charCodeAt(++state2.position);
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    ch !== 0 && readLineBreak(state2), _hasOwnProperty$1.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state2, directiveName, directiveArgs) : throwWarning(state2, 'unknown document directive "' + directiveName + '"');
  }
  if (skipSeparationSpace(state2, !0, -1), state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45 ? (state2.position += 3, skipSeparationSpace(state2, !0, -1)) : hasDirectives && throwError$1(state2, "directives end mark is expected"), composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state2, !0, -1), state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position)) && throwWarning(state2, "non-ASCII line breaks are interpreted as content"), state2.documents.push(state2.result), state2.position === state2.lineStart && testDocumentSeparator(state2)) {
    state2.input.charCodeAt(state2.position) === 46 && (state2.position += 3, skipSeparationSpace(state2, !0, -1));
    return;
  }
  if (state2.position < state2.length - 1)
    throwError$1(state2, "end of the stream or a document separator is expected");
  else
    return;
}
function loadDocuments(input2, options2) {
  input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
  var state2 = new State$1(input2, options2), nullpos = input2.indexOf("\0");
  for (nullpos !== -1 && (state2.position = nullpos, throwError$1(state2, "null byte is not allowed in input")), state2.input += "\0"; state2.input.charCodeAt(state2.position) === 32; )
    state2.lineIndent += 1, state2.position += 1;
  for (; state2.position < state2.length - 1; )
    readDocument(state2);
  return state2.documents;
}
function loadAll(input2, iterator2, options2) {
  iterator2 !== null && typeof iterator2 == "object" && typeof options2 > "u" && (options2 = iterator2, iterator2 = null);
  var documents = loadDocuments(input2, options2);
  if (typeof iterator2 != "function")
    return documents;
  for (var index = 0, length = documents.length; index < length; index += 1)
    iterator2(documents[index]);
}
function load(input2, options2) {
  var documents = loadDocuments(input2, options2);
  if (documents.length !== 0) {
    if (documents.length === 1)
      return documents[0];
    throw new YAMLException$1("expected a single document in the stream, but found more");
  }
}
function safeLoadAll(input2, iterator2, options2) {
  return typeof iterator2 == "object" && iterator2 !== null && typeof options2 > "u" && (options2 = iterator2, iterator2 = null), loadAll(input2, iterator2, common$2.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options2));
}
function safeLoad(input2, options2) {
  return load(input2, common$2.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options2));
}
loader$1.loadAll = loadAll;
loader$1.load = load;
loader$1.safeLoadAll = safeLoadAll;
loader$1.safeLoad = safeLoad;
var dumper$1 = {}, common$1 = common$7, YAMLException = exception, DEFAULT_FULL_SCHEMA = default_full, DEFAULT_SAFE_SCHEMA = default_safe, _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA = 44, CHAR_MINUS = 45, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
    tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  if (string = character.toString(16).toUpperCase(), character <= 255)
    handle = "x", length = 2;
  else if (character <= 65535)
    handle = "u", length = 4;
  else if (character <= 4294967295)
    handle = "U", length = 8;
  else
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + handle + common$1.repeat("0", length - string.length) + string;
}
function State(options2) {
  this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common$1.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function indentString(string, spaces) {
  for (var ind = common$1.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
    next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
  return result;
}
function generateNextLine(state2, level) {
  return `
` + common$1.repeat(" ", state2.indent * level);
}
function testImplicitResolving(state2, str2) {
  var index, length, type2;
  for (index = 0, length = state2.implicitTypes.length; index < length; index += 1)
    if (type2 = state2.implicitTypes[index], type2.resolve(str2))
      return !0;
  return !1;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
}
function isNsChar(c2) {
  return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev) {
  return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i2, char, prev_char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
  if (singleLineOnly)
    for (i2 = 0; i2 < string.length; i2++) {
      if (char = string.charCodeAt(i2), !isPrintable(char))
        return STYLE_DOUBLE;
      prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null, plain = plain && isPlainSafe(char, prev_char);
    }
  else {
    for (i2 = 0; i2 < string.length; i2++) {
      if (char = string.charCodeAt(i2), char === CHAR_LINE_FEED)
        hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
        i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i2);
      else if (!isPrintable(char))
        return STYLE_DOUBLE;
      prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null, plain = plain && isPlainSafe(char, prev_char);
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
  }
  return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
function writeScalar(state2, string, level, iskey) {
  state2.dump = function() {
    if (string.length === 0)
      return "''";
    if (!state2.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
      return "'" + string + "'";
    var indent = state2.indent * Math.max(1, level), lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent), singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state2, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state2.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new YAMLException("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + `
`;
}
function dropEndingNewline(string) {
  return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
    var nextLF = string.indexOf(`
`);
    return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
  }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match3; match3 = lineRe.exec(string); ) {
    var prefix = match3[1], line3 = match3[2];
    moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine(line3, width), prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line3, width) {
  if (line3 === "" || line3[0] === " ") return line3;
  for (var breakRe = / [^ ]/g, match3, start = 0, end2, curr = 0, next = 0, result = ""; match3 = breakRe.exec(line3); )
    next = match3.index, next - start > width && (end2 = curr > start ? curr : next, result += `
` + line3.slice(start, end2), start = end2 + 1), curr = next;
  return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
}
function escapeString(string) {
  for (var result = "", char, nextChar, escapeSeq, i2 = 0; i2 < string.length; i2++) {
    if (char = string.charCodeAt(i2), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i2 + 1), nextChar >= 56320 && nextChar <= 57343)) {
      result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i2++;
      continue;
    }
    escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string[i2] : escapeSeq || encodeHex(char);
  }
  return result;
}
function writeFlowSequence(state2, level, object) {
  var _result = "", _tag = state2.tag, index, length;
  for (index = 0, length = object.length; index < length; index += 1)
    writeNode(state2, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state2.condenseFlow ? "" : " ")), _result += state2.dump);
  state2.tag = _tag, state2.dump = "[" + _result + "]";
}
function writeBlockSequence(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, index, length;
  for (index = 0, length = object.length; index < length; index += 1)
    writeNode(state2, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine(state2, level)), state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state2.dump);
  state2.tag = _tag, state2.dump = _result || "[]";
}
function writeFlowMapping(state2, level, object) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1)
    pairBuffer = "", index !== 0 && (pairBuffer += ", "), state2.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state2, level, objectKey, !1, !1) && (state2.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " "), writeNode(state2, level, objectValue, !1, !1) && (pairBuffer += state2.dump, _result += pairBuffer));
  state2.tag = _tag, state2.dump = "{" + _result + "}";
}
function writeBlockMapping(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state2.sortKeys === !0)
    objectKeyList.sort();
  else if (typeof state2.sortKeys == "function")
    objectKeyList.sort(state2.sortKeys);
  else if (state2.sortKeys)
    throw new YAMLException("sortKeys must be a boolean or a function");
  for (index = 0, length = objectKeyList.length; index < length; index += 1)
    pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine(state2, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state2, level + 1, objectKey, !0, !0, !0) && (explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024, explicitPair && (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state2.dump, explicitPair && (pairBuffer += generateNextLine(state2, level)), writeNode(state2, level + 1, objectValue, !0, explicitPair) && (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state2.dump, _result += pairBuffer));
  state2.tag = _tag, state2.dump = _result || "{}";
}
function detectType(state2, object, explicit) {
  var _result, typeList, index, length, type2, style;
  for (typeList = explicit ? state2.explicitTypes : state2.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
    if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (state2.tag = explicit ? type2.tag : "?", type2.represent) {
        if (style = state2.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
          _result = type2.represent(object, style);
        else if (_hasOwnProperty.call(type2.represent, style))
          _result = type2.represent[style](object, style);
        else
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        state2.dump = _result;
      }
      return !0;
    }
  return !1;
}
function writeNode(state2, level, object, block, compact, iskey) {
  state2.tag = null, state2.dump = object, detectType(state2, object, !1) || detectType(state2, object, !0);
  var type2 = _toString.call(state2.dump);
  block && (block = state2.flowLevel < 0 || state2.flowLevel > level);
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate2;
  if (objectOrArray && (duplicateIndex = state2.duplicates.indexOf(object), duplicate2 = duplicateIndex !== -1), (state2.tag !== null && state2.tag !== "?" || duplicate2 || state2.indent !== 2 && level > 0) && (compact = !1), duplicate2 && state2.usedDuplicates[duplicateIndex])
    state2.dump = "*ref_" + duplicateIndex;
  else {
    if (objectOrArray && duplicate2 && !state2.usedDuplicates[duplicateIndex] && (state2.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
      block && Object.keys(state2.dump).length !== 0 ? (writeBlockMapping(state2, level, state2.dump, compact), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + state2.dump)) : (writeFlowMapping(state2, level, state2.dump), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + " " + state2.dump));
    else if (type2 === "[object Array]") {
      var arrayLevel = state2.noArrayIndent && level > 0 ? level - 1 : level;
      block && state2.dump.length !== 0 ? (writeBlockSequence(state2, arrayLevel, state2.dump, compact), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + state2.dump)) : (writeFlowSequence(state2, arrayLevel, state2.dump), duplicate2 && (state2.dump = "&ref_" + duplicateIndex + " " + state2.dump));
    } else if (type2 === "[object String]")
      state2.tag !== "?" && writeScalar(state2, state2.dump, level, iskey);
    else {
      if (state2.skipInvalid) return !1;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    state2.tag !== null && state2.tag !== "?" && (state2.dump = "!<" + state2.tag + "> " + state2.dump);
  }
  return !0;
}
function getDuplicateReferences(object, state2) {
  var objects = [], duplicatesIndexes = [], index, length;
  for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
    state2.duplicates.push(objects[duplicatesIndexes[index]]);
  state2.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object == "object")
    if (index = objects.indexOf(object), index !== -1)
      duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
    else if (objects.push(object), Array.isArray(object))
      for (index = 0, length = object.length; index < length; index += 1)
        inspectNode(object[index], objects, duplicatesIndexes);
    else
      for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
        inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
}
function dump(input2, options2) {
  options2 = options2 || {};
  var state2 = new State(options2);
  return state2.noRefs || getDuplicateReferences(input2, state2), writeNode(state2, 0, input2, !0, !0) ? state2.dump + `
` : "";
}
function safeDump(input2, options2) {
  return dump(input2, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
}
dumper$1.dump = dump;
dumper$1.safeDump = safeDump;
var loader = loader$1, dumper = dumper$1;
function deprecated(name) {
  return function() {
    throw new Error("Function " + name + " is deprecated and cannot be used.");
  };
}
jsYaml$1.Type = type;
jsYaml$1.Schema = schema;
jsYaml$1.FAILSAFE_SCHEMA = failsafe;
jsYaml$1.JSON_SCHEMA = json;
jsYaml$1.CORE_SCHEMA = core$2;
jsYaml$1.DEFAULT_SAFE_SCHEMA = default_safe;
jsYaml$1.DEFAULT_FULL_SCHEMA = default_full;
jsYaml$1.load = loader.load;
jsYaml$1.loadAll = loader.loadAll;
jsYaml$1.safeLoad = loader.safeLoad;
jsYaml$1.safeLoadAll = loader.safeLoadAll;
jsYaml$1.dump = dumper.dump;
jsYaml$1.safeDump = dumper.safeDump;
jsYaml$1.YAMLException = exception;
jsYaml$1.MINIMAL_SCHEMA = failsafe;
jsYaml$1.SAFE_SCHEMA = default_safe;
jsYaml$1.DEFAULT_SCHEMA = default_full;
jsYaml$1.scan = deprecated("scan");
jsYaml$1.parse = deprecated("parse");
jsYaml$1.compose = deprecated("compose");
jsYaml$1.addConstructor = deprecated("addConstructor");
var yaml$1 = jsYaml$1, jsYaml = yaml$1;
const fs$5 = gracefulFs, pify = pify$1, stripBom = stripBom$1, yaml = jsYaml, parse$3 = (data) => yaml.safeLoad(stripBom(data));
loadYamlFile$1.exports = (fp) => pify(fs$5.readFile)(fp, "utf8").then((data) => parse$3(data));
loadYamlFile$1.exports.sync = (fp) => parse$3(fs$5.readFileSync(fp, "utf8"));
var loadYamlFileExports = loadYamlFile$1.exports;
const path$8 = require$$0__default.default, pathExists$3 = pathExistsExports, loadYamlFile = loadYamlFileExports;
var whichPm = async function(pkgPath) {
  const modulesPath = path$8.join(pkgPath, "node_modules");
  if (await pathExists$3(path$8.join(modulesPath, ".yarn-integrity"))) return { name: "yarn" };
  try {
    const modules = await loadYamlFile(path$8.join(modulesPath, ".modules.yaml"));
    return toNameAndVersion(modules.packageManager);
  } catch (err) {
    if (err.code !== "ENOENT") throw err;
  }
  return await pathExists$3(modulesPath) ? { name: "npm" } : null;
};
function toNameAndVersion(pkgSpec) {
  if (pkgSpec[0] === "@") {
    const parts2 = pkgSpec.substr(1).split("@");
    return {
      name: `@${parts2[0]}`,
      version: parts2[1]
    };
  }
  const parts = pkgSpec.split("@");
  return {
    name: parts[0],
    version: parts[1]
  };
}
const findYarnWorkspaceRoot = findYarnWorkspaceRoot2, findUp = findUpExports, path$7 = require$$0__default.default, pathExists$2 = pathExistsExports, whichPM = whichPm;
var preferredPm = async function preferredPM2(pkgPath) {
  if (typeof pkgPath != "string")
    throw new TypeError(`pkgPath should be a string, got ${typeof pkgPath}`);
  if (await pathExists$2(path$7.join(pkgPath, "package-lock.json")))
    return {
      name: "npm",
      version: ">=5"
    };
  if (await pathExists$2(path$7.join(pkgPath, "yarn.lock")))
    return {
      name: "yarn",
      version: "*"
    };
  if (await pathExists$2(path$7.join(pkgPath, "pnpm-lock.yaml")))
    return {
      name: "pnpm",
      version: ">=3"
    };
  if (await pathExists$2(path$7.join(pkgPath, "shrinkwrap.yaml")))
    return {
      name: "pnpm",
      version: "1 || 2"
    };
  if (await pathExists$2(path$7.join(pkgPath, "bun.lockb")))
    return {
      name: "bun",
      version: "*"
    };
  if (await findUp("pnpm-lock.yaml", { cwd: pkgPath }))
    return {
      name: "pnpm",
      version: ">=3"
    };
  try {
    const workspaceRoot = findYarnWorkspaceRoot(pkgPath);
    if (typeof workspaceRoot == "string")
      return await pathExists$2(path$7.join(workspaceRoot, "package-lock.json")) ? {
        name: "npm",
        version: ">=7"
      } : {
        name: "yarn",
        version: "*"
      };
  } catch {
  }
  const pm = await whichPM(pkgPath);
  return pm && { name: pm.name, version: pm.version || "*" };
}, preferredPM = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(preferredPm);
const isInteractive$2 = process.stdout.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env), EXPERIMENTAL = ["bun"];
async function getPackageManagerChoice(workDir, options2) {
  const rootDir = workDir || process.cwd(), preferred = (await preferredPM(rootDir))?.name;
  if (preferred && await hasCommand(preferred, rootDir))
    return { chosen: preferred, mostOptimal: preferred };
  const mostLikelyPM = await getMostLikelyInstalledPackageManager(rootDir);
  if (!(typeof options2.interactive == "boolean" ? options2.interactive : isInteractive$2))
    return { chosen: mostLikelyPM || await getFallback(rootDir), mostOptimal: preferred };
  if (!("prompt" in options2))
    throw new Error("Must pass `prompt` when in interactive mode");
  const messageSuffix = preferred ? ` (preferred is ${preferred}, but is not installed)` : "", installed = await getAvailablePackageManagers(rootDir);
  return { chosen: await options2.prompt.single({
    type: "list",
    choices: installed.map((pm) => ({
      value: pm,
      name: EXPERIMENTAL.includes(pm) ? `${pm} (experimental)` : pm
    })),
    default: preferred || mostLikelyPM,
    message: `Package manager to use for installing dependencies?${messageSuffix}`
  }), mostOptimal: preferred };
}
async function getFallback(cwd2) {
  return await hasNpmInstalled(cwd2) ? "npm" : await hasYarnInstalled(cwd2) ? "yarn" : await hasPnpmInstalled(cwd2) ? "pnpm" : await hasBunInstalled(cwd2) ? "bun" : "manual";
}
async function getAvailablePackageManagers(cwd2) {
  const [npm, yarn, pnpm, bun] = await Promise.all([
    hasNpmInstalled(cwd2),
    hasYarnInstalled(cwd2),
    hasPnpmInstalled(cwd2),
    hasBunInstalled(cwd2)
  ]);
  return [npm && "npm", yarn && "yarn", pnpm && "pnpm", bun && "bun", "manual"].filter((pm) => pm !== !1);
}
function hasNpmInstalled(cwd2) {
  return hasCommand("npm", cwd2);
}
function hasYarnInstalled(cwd2) {
  return hasCommand("yarn", cwd2);
}
function hasPnpmInstalled(cwd2) {
  return hasCommand("pnpm", cwd2);
}
function hasBunInstalled(cwd2) {
  return hasCommand("bun", cwd2);
}
function getNpmRunPath(cwd2) {
  let previous, cwdPath = path__default.default.resolve(cwd2);
  const result = [];
  for (; previous !== cwdPath; )
    result.push(path__default.default.join(cwdPath, "node_modules", ".bin")), previous = cwdPath, cwdPath = path__default.default.resolve(cwdPath, "..");
  result.push(path__default.default.resolve(cwd2, process.execPath, ".."));
  const pathEnv = process.env[getPathEnvVarKey()];
  return [...result, pathEnv].join(path__default.default.delimiter);
}
function getPartialEnvWithNpmPath(cwd2) {
  return { [getPathEnvVarKey()]: getNpmRunPath(cwd2) };
}
function getPathEnvVarKey() {
  return process.platform !== "win32" ? "PATH" : Object.keys(process.env).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
}
function getCommandPath(cmd, cwd2) {
  const options2 = cwd2 ? { path: getNpmRunPath(cwd2) } : {};
  return which$2(cmd, options2).catch(() => null);
}
function hasCommand(cmd, cwd2) {
  return getCommandPath(cmd, cwd2).then((cmdPath) => cmdPath !== null);
}
async function getMostLikelyInstalledPackageManager(rootDir) {
  const installed = await getAvailablePackageManagers(rootDir), running = getRunningPackageManager();
  return running && installed.includes(running) ? running : void 0;
}
function getRunningPackageManager() {
  const agent = process.env.npm_config_user_agent || "";
  if (agent.includes("yarn"))
    return "yarn";
  if (agent.includes("pnpm"))
    return "pnpm";
  if (agent.includes("bun"))
    return "bun";
  if (/^npm\/\d/.test(agent))
    return "npm";
}
async function getInstallCommand(options2) {
  const { workDir, depType = "prod", pkgNames } = options2, { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
  if (!pkgNames || pkgNames.length === 0)
    return `${chosen} install`;
  const pkgNameString = pkgNames.join(" ");
  if (chosen === "yarn") {
    const flag = depType === "dev" || depType === "peer" ? ` --${depType}` : "";
    return `yarn add ${pkgNameString}${flag}`;
  } else if (chosen === "pnpm")
    return `pnpm add ${pkgNameString} --save-${depType}`;
  return `npm install ${pkgNameString} --save-${depType}`;
}
var globalDirs$1 = {};
const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype, eol = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`, encode = (obj, opt) => {
  const children = [];
  let out = "";
  typeof opt == "string" ? opt = {
    section: opt,
    whitespace: !1
  } : (opt = opt || /* @__PURE__ */ Object.create(null), opt.whitespace = opt.whitespace === !0);
  const separator2 = opt.whitespace ? " = " : "=";
  for (const k of Object.keys(obj)) {
    const val = obj[k];
    if (val && Array.isArray(val))
      for (const item of val)
        out += safe(k + "[]") + separator2 + safe(item) + `
`;
    else val && typeof val == "object" ? children.push(k) : out += safe(k) + separator2 + safe(val) + eol;
  }
  opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out);
  for (const k of children) {
    const nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, { whitespace } = opt, child = encode(obj[k], {
      section,
      whitespace
    });
    out.length && child.length && (out += eol), out += child;
  }
  return out;
}, dotSplit = (str2) => str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "")), decode = (str2) => {
  const out = /* @__PURE__ */ Object.create(null);
  let p = out, section = null;
  const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines2 = str2.split(/[\r\n]+/g);
  for (const line3 of lines2) {
    if (!line3 || line3.match(/^\s*[;#]/))
      continue;
    const match3 = line3.match(re);
    if (!match3)
      continue;
    if (match3[1] !== void 0) {
      if (section = unsafe(match3[1]), section === "__proto__") {
        p = /* @__PURE__ */ Object.create(null);
        continue;
      }
      p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
      continue;
    }
    const keyRaw = unsafe(match3[2]), isArray2 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]", key2 = isArray2 ? keyRaw.slice(0, -2) : keyRaw;
    if (key2 === "__proto__")
      continue;
    const valueRaw = match3[3] ? unsafe(match3[4]) : !0, value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
    isArray2 && (hasOwnProperty$1.call(p, key2) ? Array.isArray(p[key2]) || (p[key2] = [p[key2]]) : p[key2] = []), Array.isArray(p[key2]) ? p[key2].push(value) : p[key2] = value;
  }
  const remove = [];
  for (const k of Object.keys(out)) {
    if (!hasOwnProperty$1.call(out, k) || typeof out[k] != "object" || Array.isArray(out[k]))
      continue;
    const parts = dotSplit(k);
    let p2 = out;
    const l = parts.pop(), nl = l.replace(/\\\./g, ".");
    for (const part of parts)
      part !== "__proto__" && ((!hasOwnProperty$1.call(p2, part) || typeof p2[part] != "object") && (p2[part] = /* @__PURE__ */ Object.create(null)), p2 = p2[part]);
    p2 === out && nl === l || (p2[nl] = out[k], remove.push(k));
  }
  for (const del of remove)
    delete out[del];
  return out;
}, isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'", safe = (val) => typeof val != "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#"), unsafe = (val, doUnesc) => {
  if (val = (val || "").trim(), isQuoted(val)) {
    val.charAt(0) === "'" && (val = val.substr(1, val.length - 2));
    try {
      val = JSON.parse(val);
    } catch {
    }
  } else {
    let esc = !1, unesc = "";
    for (let i2 = 0, l = val.length; i2 < l; i2++) {
      const c2 = val.charAt(i2);
      if (esc)
        "\\;#".indexOf(c2) !== -1 ? unesc += c2 : unesc += "\\" + c2, esc = !1;
      else {
        if (";#".indexOf(c2) !== -1)
          break;
        c2 === "\\" ? esc = !0 : unesc += c2;
      }
    }
    return esc && (unesc += "\\"), unesc.trim();
  }
  return val;
};
var ini$2 = {
  parse: decode,
  decode,
  stringify: encode,
  encode,
  safe,
  unsafe
};
(function(exports2) {
  const path2 = require$$0__default.default, os2 = require$$0__default$2.default, fs2 = require$$0__default$1.default, ini2 = ini$2, isWindows2 = process.platform === "win32", readRc = (filePath) => {
    try {
      return ini2.parse(fs2.readFileSync(filePath, "utf8")).prefix;
    } catch {
    }
  }, getEnvNpmPrefix = () => Object.keys(process.env).reduce((prefix, name) => /^npm_config_prefix$/i.test(name) ? process.env[name] : prefix, void 0), getGlobalNpmrc = () => {
    if (isWindows2 && process.env.APPDATA)
      return path2.join(process.env.APPDATA, "/npm/etc/npmrc");
    if (process.execPath.includes("/Cellar/node")) {
      const homebrewPrefix = process.execPath.slice(0, process.execPath.indexOf("/Cellar/node"));
      return path2.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
    }
    if (process.execPath.endsWith("/bin/node")) {
      const installDir = path2.dirname(path2.dirname(process.execPath));
      return path2.join(installDir, "/etc/npmrc");
    }
  }, getDefaultNpmPrefix = () => {
    if (isWindows2) {
      const { APPDATA } = process.env;
      return APPDATA ? path2.join(APPDATA, "npm") : path2.dirname(process.execPath);
    }
    return path2.dirname(path2.dirname(process.execPath));
  }, getNpmPrefix = () => {
    const envPrefix = getEnvNpmPrefix();
    if (envPrefix)
      return envPrefix;
    const homePrefix = readRc(path2.join(os2.homedir(), ".npmrc"));
    if (homePrefix)
      return homePrefix;
    if (process.env.PREFIX)
      return process.env.PREFIX;
    const globalPrefix = readRc(getGlobalNpmrc());
    return globalPrefix || getDefaultNpmPrefix();
  }, npmPrefix = path2.resolve(getNpmPrefix()), getYarnWindowsDirectory = () => {
    if (isWindows2 && process.env.LOCALAPPDATA) {
      const dir = path2.join(process.env.LOCALAPPDATA, "Yarn");
      if (fs2.existsSync(dir))
        return dir;
    }
    return !1;
  }, getYarnPrefix = () => {
    if (process.env.PREFIX)
      return process.env.PREFIX;
    const windowsPrefix = getYarnWindowsDirectory();
    if (windowsPrefix)
      return windowsPrefix;
    const configPrefix = path2.join(os2.homedir(), ".config/yarn");
    if (fs2.existsSync(configPrefix))
      return configPrefix;
    const homePrefix = path2.join(os2.homedir(), ".yarn-config");
    return fs2.existsSync(homePrefix) ? homePrefix : npmPrefix;
  };
  exports2.npm = {}, exports2.npm.prefix = npmPrefix, exports2.npm.packages = path2.join(npmPrefix, isWindows2 ? "node_modules" : "lib/node_modules"), exports2.npm.binaries = isWindows2 ? npmPrefix : path2.join(npmPrefix, "bin");
  const yarnPrefix = path2.resolve(getYarnPrefix());
  exports2.yarn = {}, exports2.yarn.prefix = yarnPrefix, exports2.yarn.packages = path2.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules"), exports2.yarn.binaries = path2.join(exports2.yarn.packages, ".bin");
})(globalDirs$1);
const path$6 = require$$0__default.default;
var isPathInside$1 = (childPath, parentPath) => {
  const relation = path$6.relative(parentPath, childPath);
  return !!(relation && relation !== ".." && !relation.startsWith(`..${path$6.sep}`) && relation !== path$6.resolve(childPath));
};
const fs$4 = require$$0__default$1.default, globalDirs = globalDirs$1, isPathInside = isPathInside$1;
var isInstalledGlobally = (() => {
  try {
    return isPathInside(__dirname, globalDirs.yarn.packages) || isPathInside(__dirname, fs$4.realpathSync(globalDirs.npm.packages));
  } catch {
    return !1;
  }
})(), isInstalledGlobally$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(isInstalledGlobally);
const cliPkgName = "@sanity/cli";
async function getCliUpgradeCommand(options2 = {}) {
  let { cwd: cwd2, workDir } = options2;
  if (cwd2 = path__default.default.resolve(cwd2 || process.cwd()), workDir = path__default.default.resolve(workDir || cwd2), isInstalledGlobally$1 && isInstalledUsingYarn())
    return loadEnv.debug("CLI is installed globally with yarn"), `yarn global add ${cliPkgName}`;
  if (isInstalledGlobally$1)
    return loadEnv.debug("CLI is installed globally with npm"), `npm install -g ${cliPkgName}`;
  const cmds = cwd2 === workDir ? [] : [`cd ${path__default.default.relative(cwd2, workDir)}`], { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
  return chosen === "yarn" ? cmds.push(`yarn upgrade ${cliPkgName}`) : chosen === "pnpm" ? cmds.push(`pnpm update ${cliPkgName}`) : cmds.push(`npm update ${cliPkgName}`), cmds.join(" && ");
}
function isInstalledUsingYarn() {
  const yarnPath = process.platform === "win32" ? path__default.default.join("Yarn", "config", "global") : path__default.default.join(".config", "yarn", "global");
  return __dirname.includes(yarnPath);
}
async function installDeclaredPackages(cwd2, packageManager, context) {
  const { output } = context, execOptions = {
    encoding: "utf8",
    env: getPartialEnvWithNpmPath(cwd2),
    cwd: cwd2,
    stdio: "inherit"
  }, npmArgs = ["install", "--legacy-peer-deps"];
  let result;
  if (packageManager === "npm")
    output.print(`Running 'npm ${npmArgs.join(" ")}'`), result = await execa$1("npm", npmArgs, execOptions);
  else if (packageManager === "yarn") {
    const yarnArgs = ["install"];
    output.print(`Running 'yarn ${yarnArgs.join(" ")}'`), result = await execa$1("yarn", yarnArgs, execOptions);
  } else if (packageManager === "pnpm") {
    const pnpmArgs = ["install"];
    output.print(`Running 'pnpm ${pnpmArgs.join(" ")}'`), result = await execa$1("pnpm", pnpmArgs, execOptions);
  } else if (packageManager === "bun") {
    const bunArgs = ["install"];
    output.print(`Running 'bun ${bunArgs.join(" ")}'`), result = await execa$1("bun", bunArgs, execOptions);
  } else packageManager === "manual" && output.print(`Manual installation selected - run 'npm ${npmArgs.join(" ")}' or similar`);
  if (result?.exitCode || result?.failed)
    throw new Error("Dependency installation failed");
}
async function installNewPackages(options2, context) {
  const { packageManager, packages } = options2, { output, workDir } = context, execOptions = {
    encoding: "utf8",
    env: getPartialEnvWithNpmPath(workDir),
    cwd: workDir,
    stdio: "inherit"
  }, npmArgs = ["install", "--legacy-peer-deps", "--save", ...packages];
  let result;
  if (packageManager === "npm")
    output.print(`Running 'npm ${npmArgs.join(" ")}'`), result = await execa$1("npm", npmArgs, execOptions);
  else if (packageManager === "yarn") {
    const yarnArgs = ["add", ...packages];
    output.print(`Running 'yarn ${yarnArgs.join(" ")}'`), result = await execa$1("yarn", yarnArgs, execOptions);
  } else if (packageManager === "pnpm") {
    const pnpmArgs = ["add", "--save-prod", ...packages];
    output.print(`Running 'pnpm ${pnpmArgs.join(" ")}'`), result = await execa$1("pnpm", pnpmArgs, execOptions);
  } else if (packageManager === "bun") {
    const bunArgs = ["add", ...packages];
    output.print(`Running 'bun ${bunArgs.join(" ")}'`), result = await execa$1("bun", bunArgs, execOptions);
  } else packageManager === "manual" && output.print(`Manual installation selected - run 'npm ${npmArgs.join(" ")}' or equivalent`);
  if (result?.exitCode || result?.failed)
    throw new Error("Package installation failed");
}
async function uninstallPackages(options2, context) {
  const { packageManager, packages } = options2, { output, workDir } = context, execOptions = {
    encoding: "utf8",
    env: getPartialEnvWithNpmPath(workDir),
    cwd: workDir,
    stdio: "inherit"
  }, npmArgs = ["uninstall", ...packages];
  let result;
  if (packageManager === "npm")
    output.print(`Running 'npm ${npmArgs.join(" ")}'`), result = await execa$1("npm", npmArgs, execOptions);
  else if (packageManager === "yarn") {
    const yarnArgs = ["remove", ...packages];
    output.print(`Running 'yarn ${yarnArgs.join(" ")}'`), result = await execa$1("yarn", yarnArgs, execOptions);
  } else if (packageManager === "pnpm") {
    const pnpmArgs = ["remove", ...packages];
    output.print(`Running 'pnpm ${pnpmArgs.join(" ")}'`), result = await execa$1("pnpm", pnpmArgs, execOptions);
  } else packageManager === "manual" && output.print(`Manual installation selected - run 'npm ${npmArgs.join(" ")}' or equivalent`);
  if (result?.exitCode || result?.failed)
    throw new Error("Package installation failed");
}
function getYarnStub(context) {
  return async function(args, options2) {
    const workDir = options2?.rootDir || context.workDir, yarnContext = { workDir, output: context.output }, { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 }), [command2, ...packages] = args;
    if (command2 === "add")
      await installNewPackages({ packageManager: chosen, packages }, yarnContext);
    else if (command2 === "remove")
      await uninstallPackages({ packageManager: chosen, packages }, yarnContext);
    else if (command2 === "install")
      await installDeclaredPackages(workDir, chosen, yarnContext);
    else
      throw new Error(`Unsupported package manager command "${command2}"`);
  };
}
const cliPackageManager = {
  getInstallCommand,
  getPackageManagerChoice,
  installNewPackages
}, fs$3 = require$$0__default$1.default.promises, ini$1 = ini$5, path$5 = require$$0__default.default;
var gitconfiglocal = async function gitConfigLocal(dir, options2 = {}) {
  const config2 = await findGit(dir, options2);
  if (!config2) throw new Error("no gitconfig to be found at " + dir);
  const data = await fs$3.readFile(config2);
  return format(ini$1.parse(data.toString()));
};
function format(data) {
  const out = {};
  return Object.keys(data).forEach(function(k) {
    if (k.indexOf('"') > -1) {
      const parts = k.split('"'), parentKey = parts.shift().trim(), childKey = parts.shift().trim();
      out[parentKey] || (out[parentKey] = {}), out[parentKey][childKey] = data[k];
    } else
      out[k] = { ...out[k], ...data[k] };
  }), out;
}
async function findGit(dir, options2) {
  const folder = path$5.resolve(
    dir,
    options2.gitDir || process.env.GIT_DIR || ".git",
    "config"
  );
  return await pathExists$1(folder) ? folder : dir === path$5.resolve(dir, "..") ? !1 : findGit(path$5.resolve(dir, ".."), options2);
}
function pathExists$1(filePath) {
  return fs$3.access(filePath).then(
    () => !0,
    () => !1
  );
}
var getGitConfig = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(gitconfiglocal);
/*!
 * fs-exists-sync (https://github.com/jonschlinkert/fs-exists-sync)
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var fs$2 = require$$0__default$1.default, fsExistsSync = function(filepath) {
  try {
    return (fs$2.accessSync || fs$2.statSync)(filepath), !0;
  } catch {
  }
  return !1;
};
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtendable = function isExtendable2(val) {
  return typeof val < "u" && val !== null && (typeof val == "object" || typeof val == "function");
}, isObject$2 = isExtendable, extendShallow = function extend3(o) {
  isObject$2(o) || (o = {});
  for (var len = arguments.length, i2 = 1; i2 < len; i2++) {
    var obj = arguments[i2];
    isObject$2(obj) && assign(o, obj);
  }
  return o;
};
function assign(a, b) {
  for (var key2 in b)
    hasOwn(b, key2) && (a[key2] = b[key2]);
}
function hasOwn(obj, key2) {
  return Object.prototype.hasOwnProperty.call(obj, key2);
}
var homedirPolyfill = { exports: {} }, parsePasswd, hasRequiredParsePasswd;
function requireParsePasswd() {
  if (hasRequiredParsePasswd) return parsePasswd;
  hasRequiredParsePasswd = 1, parsePasswd = function(content) {
    if (typeof content != "string")
      throw new Error("expected a string");
    return content.split(`
`).map(user).filter(Boolean);
  };
  function user(line3, i2) {
    if (!line3 || !line3.length || line3.charAt(0) === "#")
      return null;
    var fields = line3.split(":");
    return {
      username: fields[0],
      password: fields[1],
      uid: fields[2],
      gid: fields[3],
      // see https://en.wikipedia.org/wiki/Gecos_field for GECOS field descriptions
      gecos: fields[4],
      homedir: fields[5],
      shell: fields[6]
    };
  }
  return parsePasswd;
}
var polyfill, hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var fs2 = require$$0__default$1.default, parse3 = requireParsePasswd();
  function homedir2() {
    if (process.platform === "win32")
      return process.env.USERPROFILE ? process.env.USERPROFILE : process.env.HOMEDRIVE && process.env.HOMEPATH ? process.env.HOMEDRIVE + process.env.HOMEPATH : process.env.HOME ? process.env.HOME : null;
    if (process.env.HOME)
      return process.env.HOME;
    var passwd = tryReadFileSync("/etc/passwd"), home2 = find2(parse3(passwd), getuid());
    if (home2)
      return home2;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    return user ? process.platform === "darwin" ? "/Users/" + user : "/home/" + user : null;
  }
  function find2(arr, uid) {
    for (var len = arr.length, i2 = 0; i2 < len; i2++)
      if (+arr[i2].uid === uid)
        return arr[i2].homedir;
  }
  function getuid() {
    return typeof process.geteuid == "function" ? process.geteuid() : process.getuid();
  }
  function tryReadFileSync(fp) {
    try {
      return fs2.readFileSync(fp, "utf8");
    } catch {
      return "";
    }
  }
  return polyfill = homedir2, polyfill;
}
var os$1 = require$$0__default$2.default;
typeof os$1.homedir < "u" ? homedirPolyfill.exports = os$1.homedir : homedirPolyfill.exports = requirePolyfill();
var homedirPolyfillExports = homedirPolyfill.exports;
/*!
 * git-config-path <https://github.com/jonschlinkert/git-config-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var path$4 = require$$0__default.default, exists$1 = fsExistsSync, extend$1 = extendShallow, homedir = homedirPolyfillExports, gitConfigPath = function(type2, options2) {
  typeof type2 != "string" && (options2 = type2, type2 = null);
  var opts = extend$1({ cwd: process.cwd() }, options2);
  type2 = type2 || opts.type;
  var configPath2 = path$4.resolve(opts.cwd, ".git/config");
  if (type2 === "global" && (configPath2 = path$4.join(homedir(), ".gitconfig")), !exists$1(configPath2)) {
    if (typeof type2 == "string")
      return null;
    configPath2 = path$4.join(homedir(), ".config/git/config");
  }
  return exists$1(configPath2) ? configPath2 : null;
};
/*!
 * parse-git-config <https://github.com/jonschlinkert/parse-git-config>
 *
 * Copyright (c) 2015 Jon Schlinkert.
 * Licensed under the MIT license.
 */
var fs$1 = require$$0__default$1.default, path$3 = require$$0__default.default, exists = fsExistsSync, extend = extendShallow, configPath = gitConfigPath, ini = ini$5;
function parse$2(options2, cb) {
  if (typeof options2 == "function" && (cb = options2, options2 = {}), typeof cb != "function")
    throw new TypeError("parse-git-config async expects a callback function.");
  options2 = options2 || {};
  var filepath = parse$2.resolve(options2);
  fs$1.stat(filepath, function(err, stat) {
    if (err) return cb(err);
    fs$1.readFile(filepath, "utf8", function(err2, str2) {
      if (err2) return cb(err2);
      var parsed = ini.parse(str2);
      cb(null, parsed);
    });
  });
}
parse$2.sync = function parseSync(options2) {
  options2 = options2 || {};
  var filepath = parse$2.resolve(options2);
  if (filepath && exists(filepath)) {
    var str2 = fs$1.readFileSync(filepath, "utf8");
    return ini.parse(str2);
  }
  return {};
};
parse$2.resolve = function resolve(options2) {
  typeof options2 == "string" && (options2 = { type: options2 });
  var opts = extend({ cwd: process.cwd() }, options2), fp = opts.path || configPath(opts.type);
  return fp ? path$3.resolve(opts.cwd, fp) : null;
};
parse$2.keys = function parseKeys(config2) {
  var res = {};
  for (var key2 in config2) {
    var m = /(\S+) "(.*)"/.exec(key2);
    if (m) {
      var prop = m[1];
      res[prop] = res[prop] || {}, res[prop][m[2]] = config2[key2];
    }
  }
  return res;
};
var parseGitConfig = parse$2;
const gitconfig = gitConfigPath, parse$1 = parseGitConfig;
async function getGitUserInfo(options2 = {}) {
  const opts = { cwd: "/", path: gitconfig(), ...options2 }, user = await getUserFromConfig(opts);
  return user || options2.path ? user : getUserFromConfig({ ...opts, path: gitconfig("global") });
}
function getUserFromConfig(options2) {
  return new Promise((resolve2, reject) => {
    if (typeof options2.path != "string")
      return resolve2(null);
    parse$1(options2, (err, config2) => {
      if (err) {
        reject(err);
        return;
      }
      resolve2(config2 && config2.user ? config2.user : null);
    });
  });
}
var gitUserInfo = {
  getGitUserInfo
};
function getProjectDefaults(workDir, { isPlugin, context }) {
  const cwd2 = process.cwd(), isSanityRoot = workDir === cwd2;
  return promiseProps$1({
    license: "UNLICENSED",
    author: getUserInfo(context),
    // Don't try to use git remote from main Sanity project for plugins
    gitRemote: isPlugin && isSanityRoot ? "" : resolveGitRemote(cwd2),
    // Don't try to guess plugin name if we're initing from Sanity root
    projectName: isPlugin && isSanityRoot ? "" : path__default.default.basename(cwd2),
    // If we're initing a plugin, don't use description from Sanity readme
    description: getProjectDescription({ isSanityRoot, isPlugin, outputDir: cwd2 })
  });
}
async function resolveGitRemote(cwd2) {
  try {
    await fs__default$1.default.stat(path__default.default.join(cwd2, ".git"));
    const cfg = await getGitConfig(cwd2);
    return cfg.remote && cfg.remote.origin && cfg.remote.origin.url;
  } catch {
    return;
  }
}
async function getUserInfo(context) {
  const user = await gitUserInfo.getGitUserInfo();
  if (!user)
    return getSanityUserInfo(context);
  if (user.name && user.email)
    return `${user.name} <${user.email}>`;
}
async function getSanityUserInfo(context) {
  if (!getCliToken())
    return;
  const client2 = context.apiClient({ requireUser: !0, requireProject: !1 });
  try {
    const user = await client2.users.getById("me");
    return user ? `${user.name} <${user.email}>` : void 0;
  } catch {
    return;
  }
}
async function getProjectDescription({
  isSanityRoot,
  isPlugin,
  outputDir
}) {
  if (!(isSanityRoot && !isPlugin))
    return Promise.resolve("");
  try {
    const readmePath = path__default.default.join(outputDir, "README.md"), match3 = (await fs__default$1.default.readFile(readmePath, { encoding: "utf8" })).match(/^# .*?\n+(\w.*?)(?:$|\n)/);
    return (match3 && match3[1] || "").replace(/\.$/, "") || "";
  } catch {
    return "";
  }
}
function canLaunchBrowser() {
  return ["win32", "darwin"].includes(os__default.default.platform()) ? !0 : !!(process.env.XDG_CURRENT_DESKTOP || process.env.GDMSESSION);
}
function createExpiringConfig({
  key: key2,
  ttl,
  store,
  fetchValue,
  onRevalidate = () => null,
  onFetch = () => null,
  onCacheHit = () => null
}) {
  let currentFetch = null;
  return {
    async get() {
      const { value, updatedAt } = store.get(key2) ?? {};
      if (value && updatedAt) {
        if (!(Date.now() - updatedAt > ttl))
          return onCacheHit(), value;
        onRevalidate();
      }
      if (currentFetch)
        return currentFetch;
      onFetch(), currentFetch = Promise.resolve(fetchValue());
      const nextValue = await currentFetch;
      return currentFetch = null, store.set(key2, {
        value: nextValue,
        updatedAt: Date.now()
      }), nextValue;
    },
    delete() {
      store.delete(key2);
    }
  };
}
function isTrueish(value) {
  if (value === void 0) return !1;
  if (value.toLowerCase() === "true") return !0;
  if (value.toLowerCase() === "false") return !1;
  const number2 = parseInt(value, 10);
  return isNaN(number2) ? !1 : number2 > 0;
}
const isCi = isTrueish(process.env.CI) || // Travis CI, CircleCI, Gitlab CI, Appveyor, CodeShip
isTrueish(process.env.CONTINUOUS_INTEGRATION) || // Travis CI
process.env.BUILD_NUMBER, debug$1 = loadEnv.debug.extend("telemetry"), FIVE_MINUTES = 1e3 * 60 * 5, LOG_FILE_NAME = "telemetry-events.ndjson", TELEMETRY_CONSENT_CONFIG_KEY = "telemetryConsent", VALID_API_STATUSES = ["granted", "denied", "unset"];
function isValidApiConsentStatus(status) {
  return VALID_API_STATUSES.includes(status);
}
function parseApiConsentStatus(value) {
  if (typeof value == "string" && isValidApiConsentStatus(value))
    return value;
  throw new Error(`Invalid consent status. Must be one of: ${VALID_API_STATUSES.join(", ")}`);
}
function createTelemetryClient(token2) {
  return getClientWrapper(null, "sanity.cli.js")({ requireUser: !1, requireProject: !1 }).config({
    apiVersion: "2023-12-18",
    token: token2,
    useCdn: !1,
    useProjectHostname: !1
  });
}
let _client = null;
function getCachedClient(token2) {
  return _client || (_client = createTelemetryClient(token2)), _client;
}
function resolveConsent({ env }) {
  if (debug$1("Resolving consent\u2026"), isCi)
    return debug$1("CI environment detected, treating telemetry consent as denied"), Promise.resolve({ status: "denied" });
  if (isTrueish(env.DO_NOT_TRACK))
    return debug$1("DO_NOT_TRACK is set, consent is denied"), Promise.resolve({
      status: "denied",
      reason: "localOverride"
    });
  const token2 = getCliToken();
  if (!token2)
    return debug$1("User is not logged in, consent is undetermined"), Promise.resolve({
      status: "undetermined",
      reason: "unauthenticated"
    });
  const client2 = getCachedClient(token2);
  function fetchConsent() {
    return createExpiringConfig({
      store: getUserConfig(),
      key: TELEMETRY_CONSENT_CONFIG_KEY,
      ttl: FIVE_MINUTES,
      fetchValue: () => client2.request({ uri: "/intake/telemetry-status" }),
      onRevalidate() {
        debug$1("Revalidating cached telemetry consent status...");
      },
      onFetch() {
        debug$1("Fetching telemetry consent status...");
      },
      onCacheHit() {
        debug$1("Retrieved telemetry consent status from cache");
      }
    }).get();
  }
  return fetchConsent().then((response) => (debug$1("User consent status is %s", response.status), { status: parseApiConsentStatus(response.status) })).catch((err) => (debug$1('Failed to fetch user consent status, treating it as "undetermined": %s', err.stack), {
    status: "undetermined",
    reason: "fetchError"
  }));
}
function createTelemetryStore({
  env,
  projectId
}) {
  debug$1("Initializing telemetry");
  async function sendEvents(batch) {
    const token2 = getCliToken();
    if (!token2)
      return debug$1("No user token found. Something is not quite right"), Promise.reject(new Error("User is not logged in"));
    isTrueish(env.SANITY_TELEMETRY_INSPECT) && (console.info(`SANITY_TELEMETRY_INSPECT is set, appending events to "${LOG_FILE_NAME}"`), await fs$o.appendFile(LOG_FILE_NAME, `${batch.map((entry) => JSON.stringify(entry)).join(`
`)}
`));
    const client2 = getCachedClient(token2);
    debug$1("Submitting %s telemetry events", batch.length);
    try {
      return await client2.request({
        uri: "/intake/batch",
        method: "POST",
        json: !0,
        body: { projectId, batch }
      });
    } catch (err) {
      const statusCode = err.response && err.response.statusCode;
      throw debug$1(
        "Failed to send telemetry events%s: %s",
        statusCode ? ` (HTTP ${statusCode})` : "",
        err.stack
      ), err;
    }
  }
  const sessionId = telemetry.createSessionId();
  debug$1("session id: %s", sessionId);
  const store = telemetry.createBatchedStore(sessionId, {
    resolveConsent: () => resolveConsent({ env }),
    sendEvents
  });
  return process.once("SIGINT", () => store.flush().finally(() => process.exit(0))), process.once("beforeExit", () => store.flush()), process.once("unhandledRejection", () => store.flush()), process.once("uncaughtException", () => store.flush()), store;
}
const LoginTrace = telemetry.defineTrace({
  name: "CLI Login Step Completed",
  version: 1,
  description: "User completed a step in the CLI login flow"
}), callbackEndpoint = "/callback", debug = loadEnv.debug.extend("auth"), callbackPorts = [4321, 4e3, 3003, 1234, 8080, 13333], platformNames = {
  aix: "AIX",
  android: "Android",
  darwin: "MacOS",
  freebsd: "FreeBSD",
  linux: "Linux",
  openbsd: "OpenBSD",
  sunos: "SunOS",
  win32: "Windows"
};
async function login(args, context) {
  const { prompt: prompt2, output, apiClient, telemetry: telemetry2 } = context, { sso, experimental, open: openFlag, provider: specifiedProvider } = args.extOptions, previousToken = getCliToken(), hasExistingToken = !!previousToken, trace = telemetry2.trace(LoginTrace);
  trace.start();
  const client2 = apiClient({ requireUser: !1, requireProject: !1 }).clone().config({ token: void 0 }), provider = await getProvider({ client: client2, sso, experimental, output, prompt: prompt2, specifiedProvider });
  if (trace.log({ step: "selectProvider", provider: provider?.name }), provider === void 0)
    throw new Error("No authentication providers found");
  const apiHost = client2.config().apiHost || "https://api.sanity.io", { server, token: tokenPromise } = await startServerForTokenCallback({ apiHost, apiClient });
  trace.log({ step: "waitForToken" });
  const serverUrl = server.address();
  if (!serverUrl || typeof serverUrl == "string")
    throw new Error("Failed to start auth callback server");
  const loginUrl = new URL(provider.url), platformName = os__default.default.platform(), platform2 = platformName in platformNames ? platformNames[platformName] : platformName, hostname = os__default.default.hostname().replace(/\.(local|lan)$/g, "");
  loginUrl.searchParams.set("type", "token"), loginUrl.searchParams.set("label", `${hostname} / ${platform2}`), loginUrl.searchParams.set("origin", `http://localhost:${serverUrl.port}${callbackEndpoint}`);
  const shouldLaunchBrowser = canLaunchBrowser() && openFlag !== !1, actionText = shouldLaunchBrowser ? "Opening browser at" : "Please open a browser at";
  output.print(`
${actionText} ${loginUrl.href}
`);
  const spin = output.spinner("Waiting for browser login to complete... Press Ctrl + C to cancel").start();
  shouldLaunchBrowser && open$1(loginUrl.href);
  let authToken;
  try {
    authToken = (await tokenPromise).token, spin.stop();
  } catch (err) {
    throw spin.stop(), trace.error(err), err.message = `Login failed: ${err.message}`, err;
  } finally {
    server.close(), server.unref();
  }
  getUserConfig().set({
    authToken,
    authType: "normal"
  }), getUserConfig().delete(TELEMETRY_CONSENT_CONFIG_KEY), hasExistingToken && await apiClient({ requireUser: !0, requireProject: !1 }).clone().config({ token: previousToken }).request({ uri: "/auth/logout", method: "POST" }).catch((err) => {
    (err && err.response && err.response.statusCode) !== 401 && output.warn("[warn] Failed to log out existing session");
  }), output.print(chalk__default.default.green("Login successful")), trace.complete();
}
function startServerForTokenCallback(options2) {
  const { apiHost, apiClient } = options2, domain = apiHost.includes(".sanity.work") ? "www.sanity.work" : "www.sanity.io", attemptPorts = callbackPorts.slice();
  let callbackPort = attemptPorts.shift(), resolveToken, rejectToken;
  const tokenPromise = new Promise((resolve2, reject) => {
    resolveToken = resolve2, rejectToken = reject;
  });
  return new Promise((resolve2, reject) => {
    const server = http__default.default.createServer(async function(req, res) {
      function failLoginRequest(code = "") {
        res.writeHead(303, "See Other", {
          Location: `https://${domain}/login/error${code ? `?error=${code}` : ""}`
        }), res.end(), server.close();
      }
      const url2 = new URL(req.url || "/", `http://localhost:${callbackPort}`);
      if (url2.pathname !== callbackEndpoint) {
        res.writeHead(404, "Not Found", { "Content-Type": "text/plain" }), res.write("404 Not Found"), res.end();
        return;
      }
      const absoluteTokenUrl = url2.searchParams.get("url");
      if (!absoluteTokenUrl) {
        failLoginRequest();
        return;
      }
      const tokenUrl = new URL(absoluteTokenUrl);
      if (!tokenUrl.searchParams.has("sid")) {
        failLoginRequest("NO_SESSION_ID");
        return;
      }
      let token2;
      try {
        token2 = await apiClient({ requireUser: !1, requireProject: !1 }).clone().request({ uri: `/auth/fetch${tokenUrl.search}` });
      } catch (err) {
        failLoginRequest("UNRESOLVED_SESSION"), rejectToken(err);
        return;
      }
      res.writeHead(303, "See Other", { Location: `https://${domain}/login/success` }), res.end(), server.close(), resolveToken(token2);
    });
    server.on("listening", function() {
      resolve2({ token: tokenPromise, server });
    }), server.on("error", function(err) {
      if ("code" in err && err.code === "EADDRINUSE") {
        if (callbackPort = attemptPorts.shift(), !callbackPort) {
          reject(new Error("Failed to find port number to bind auth callback server to"));
          return;
        }
        debug("Port busy, trying %d", callbackPort), server.listen(callbackPort);
      } else
        reject(err);
    }), debug("Starting callback server on port %d", callbackPort), server.listen(callbackPort);
  });
}
async function getProvider({
  output,
  client: client2,
  sso,
  experimental,
  prompt: prompt2,
  specifiedProvider
}) {
  if (sso)
    return getSSOProvider({ client: client2, prompt: prompt2, slug: sso });
  const spin = output.spinner("Fetching providers...").start();
  let { providers } = await client2.request({ uri: "/auth/providers" });
  experimental && (providers = [...providers, { name: "sso", title: "SSO", url: "_not_used_" }]), spin.stop();
  const providerNames = providers.map((prov) => prov.name);
  if (specifiedProvider && providerNames.includes(specifiedProvider)) {
    const provider2 = providers.find((prov) => prov.name === specifiedProvider);
    if (!provider2)
      throw new Error(`Cannot find login provider with name "${specifiedProvider}"`);
    return provider2;
  }
  const provider = await promptProviders(prompt2, providers);
  if (provider.name === "sso") {
    const slug = await prompt2.single({
      type: "input",
      message: "Organization slug:"
    });
    return getSSOProvider({ client: client2, prompt: prompt2, slug });
  }
  return provider;
}
async function getSSOProvider({
  client: client2,
  prompt: prompt2,
  slug
}) {
  const enabledProviders = (await client2.withConfig({ apiVersion: "2021-10-01" }).request({
    uri: `/auth/organizations/by-slug/${slug}/providers`
  })).filter((candidate) => !candidate.disabled);
  if (enabledProviders.length === 0)
    return;
  if (enabledProviders.length === 1)
    return samlProviderToLoginProvider(enabledProviders[0]);
  const choice2 = await prompt2.single({
    type: "list",
    message: "Select SSO provider",
    choices: enabledProviders.map((provider) => provider.name)
  }), foundProvider = enabledProviders.find((provider) => provider.name === choice2);
  return foundProvider ? samlProviderToLoginProvider(foundProvider) : void 0;
}
async function promptProviders(prompt2, providers) {
  if (providers.length === 1)
    return providers[0];
  const provider = await prompt2.single({
    type: "list",
    message: "Login type",
    choices: providers.map((choice2) => choice2.title)
  });
  return providers.find((prov) => prov.title === provider) || providers[0];
}
function samlProviderToLoginProvider(saml) {
  return {
    name: saml.name,
    title: saml.name,
    url: saml.loginUrl
  };
}
function createProject(apiClient, options2) {
  return apiClient({
    requireUser: !0,
    requireProject: !1
  }).request({
    method: "POST",
    uri: "/projects",
    body: options2
  }).then((response) => ({
    projectId: response.projectId || response.id,
    displayName: options2.displayName || ""
  }));
}
const studioDependencies = {
  // Dependencies for a default Sanity installation
  dependencies: {
    // Official studio dependencies
    sanity: "latest",
    // Official studio plugin dependencies
    "@sanity/vision": "latest",
    // Non-Sanity dependencies
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "styled-components": "^6.1.8"
  },
  devDependencies: {
    // Linting/tooling
    "@sanity/eslint-config-studio": "latest",
    // When using typescript, we'll want the these types too, so might as well install them
    "@types/react": "^18.0.25",
    eslint: "^8.6.0",
    prettier: "^3.0.2",
    typescript: "^5.1.6"
    // Peer dependency of eslint-config-studio (implicitly)
  }
};
async function readdirRecursive(dir) {
  let content = [];
  const currentPath = path__default.default.resolve(dir), dirContent = (await fs__default$1.default.readdir(currentPath)).map((item) => path__default.default.join(currentPath, item));
  for (const subPath of dirContent) {
    const isDir = (await fs__default$1.default.stat(subPath)).isDirectory();
    content.push({ path: subPath, isDir }), isDir && (content = content.concat(await readdirRecursive(subPath)));
  }
  return content;
}
async function copy(srcPath, dstPath, options2) {
  const rename = options2?.rename, content = (await fs__default$1.default.stat(srcPath)).isDirectory() ? await readdirRecursive(srcPath) : [{ path: srcPath, isDir: !1 }], directories = content.filter((entry) => entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map((entry) => entry.path);
  for (const subDir of directories) {
    const relativePath = path__default.default.relative(srcPath, subDir), fullDstPath = path__default.default.join(dstPath, relativePath);
    await fs__default$1.default.mkdir(fullDstPath, { recursive: !0 });
  }
  const files = content.filter((entry) => !entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map((entry) => {
    const relativePath = path__default.default.relative(srcPath, entry.path), baseName = path__default.default.basename(relativePath), dirName = path__default.default.dirname(relativePath), dstName = rename ? rename(baseName) : baseName, fullDstPath = path__default.default.join(dstPath, dirName, dstName);
    return { from: entry.path, to: fullDstPath };
  });
  for (const file2 of files)
    await fs__default$1.default.copyFile(file2.from, file2.to);
  return files.length;
}
function resolveLatestVersions(pkgs) {
  const lookups = {};
  for (const [packageName, range2] of Object.entries(pkgs))
    lookups[packageName] = range2 === "latest" ? latestVersion(packageName, { range: range2 }).then(caretify) : range2;
  return promiseProps$1(lookups);
}
function caretify(version) {
  return version ? `^${version}` : "latest";
}
var main$4 = {}, extendStatics$1 = function(d, b) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
  }, extendStatics$1(d, b);
};
function __extends$1(d, b) {
  if (typeof b != "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++)
      e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]) && (t[p[i2]] = s[p[i2]]);
  return t;
}
function __decorate(decorators, target, key2, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(decorators, target, key2, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) (d = decorators[i2]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key2, r) : d(target, key2)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key2, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 != "function") throw new TypeError("Function expected");
    return f2;
  }
  for (var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor2 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), _2, done = !1, i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor2.get, set: descriptor2.set } : descriptor2[key2], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result != "object") throw new TypeError("Object expected");
      (_2 = accept(result.get)) && (descriptor2.get = _2), (_2 = accept(result.set)) && (descriptor2.set = _2), (_2 = accept(result.init)) && initializers.unshift(_2);
    } else (_2 = accept(result)) && (kind === "field" ? initializers.unshift(_2) : descriptor2[key2] = _2);
  }
  target && Object.defineProperty(target, contextIn.name, descriptor2), done = !0;
}
function __runInitializers(thisArg, initializers, value) {
  for (var useValue = arguments.length > 2, i2 = 0; i2 < initializers.length; i2++)
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x == "symbol" ? x : "".concat(x);
}
function __setFunctionName(f2, name, prefix) {
  return typeof name == "symbol" && (name = name.description ? "[".concat(name.description, "]") : ""), Object.defineProperty(f2, "name", { configurable: !0, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    for (; g && (g = 0, op[0] && (_2 = 0)), _2; ) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          return _2.label++, { value: op[1], done: !1 };
        case 5:
          _2.label++, y = op[1], op = [0];
          continue;
        case 7:
          op = _2.ops.pop(), _2.trys.pop();
          continue;
        default:
          if (t = _2.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1], t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2], _2.ops.push(op);
            break;
          }
          t[2] && _2.ops.pop(), _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e], y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: !0 };
  }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
  k2 === void 0 && (k2 = k);
  var desc = Object.getOwnPropertyDescriptor(m, k);
  (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
    return m[k];
  } }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  k2 === void 0 && (k2 = k), o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(o, p) && __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m) return m.call(o);
  if (o && typeof o.length == "number") return {
    next: function() {
      return o && i2 >= o.length && (o = void 0), { value: o && o[i2++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol == "function" && o[Symbol.iterator];
  if (!m) return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    for (; (n === void 0 || n-- > 0) && !(r = i2.next()).done; ) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      r && !r.done && (m = i2.return) && m.call(i2);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s += arguments[i2].length;
  for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
    for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from2.length, ar; i2 < l; i2++)
    (ar || !(i2 in from2)) && (ar || (ar = Array.prototype.slice.call(from2, 0, i2)), ar[i2] = from2[i2]);
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n) {
    g[n] && (i2[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    });
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v) {
    f2(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p;
  return i2 = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n, f2) {
    i2[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: !1 } : f2 ? f2(v) : v;
    } : f2;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values == "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n) {
    i2[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  return Object.defineProperty ? Object.defineProperty(cooked, "raw", { value: raw }) : cooked.raw = raw, cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: !0, value: v });
} : function(o, v) {
  o.default = v;
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
  return __setModuleDefault(result, mod), result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state2, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 == "function" ? receiver !== state2 || !f2 : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state2.get(receiver);
}
function __classPrivateFieldSet(receiver, state2, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 == "function" ? receiver !== state2 || !f2 : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state2.set(receiver, value), value;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver != "object" && typeof receiver != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 == "function" ? receiver === state2 : state2.has(receiver);
}
function __addDisposableResource(env, value, async2) {
  if (value != null) {
    if (typeof value != "object" && typeof value != "function") throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose != "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async: async2 });
  } else async2 && env.stack.push({ async: !0 });
  return value;
}
var _SuppressedError = typeof SuppressedError == "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e, env.hasError = !0;
  }
  function next() {
    for (; env.stack.length; ) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) {
          return fail(e), next();
        });
      } catch (e) {
        fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}
var tslib_es6 = {
  __extends: __extends$1,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
}, tslib_es6$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends: __extends$1,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}), require$$0$3 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(tslib_es6$1), main$3 = {}, fork = { exports: {} }, types = { exports: {} }, shared = {}, hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared;
  hasRequiredShared = 1, Object.defineProperty(shared, "__esModule", { value: !0 }), shared.maybeSetModuleExports = void 0;
  var tslib_12 = require$$0$3, types_1 = tslib_12.__importDefault(requireTypes());
  function default_1(fork2) {
    var types2 = fork2.use(types_1.default), Type2 = types2.Type, builtin = types2.builtInTypes, isNumber2 = builtin.number;
    function geq(than) {
      return Type2.from(function(value) {
        return isNumber2.check(value) && value >= than;
      }, isNumber2 + " >= " + than);
    }
    var defaults2 = {
      // Functions were used because (among other reasons) that's the most
      // elegant way to allow for the emptyArray one always to give a new
      // array instance.
      null: function() {
        return null;
      },
      emptyArray: function() {
        return [];
      },
      false: function() {
        return !1;
      },
      true: function() {
        return !0;
      },
      undefined: function() {
      },
      "use strict": function() {
        return "use strict";
      }
    }, naiveIsPrimitive = Type2.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined), isPrimitive = Type2.from(function(value) {
      if (value === null)
        return !0;
      var type2 = typeof value;
      return !(type2 === "object" || type2 === "function");
    }, naiveIsPrimitive.toString());
    return {
      geq,
      defaults: defaults2,
      isPrimitive
    };
  }
  shared.default = default_1;
  function maybeSetModuleExports(moduleGetter) {
    try {
      var nodeModule = moduleGetter(), originalExports = nodeModule.exports, defaultExport = originalExports.default;
    } catch {
      return;
    }
    defaultExport && defaultExport !== originalExports && typeof originalExports == "object" && (Object.assign(defaultExport, originalExports, { default: defaultExport }), originalExports.__esModule && Object.defineProperty(defaultExport, "__esModule", { value: !0 }), nodeModule.exports = defaultExport);
  }
  return shared.maybeSetModuleExports = maybeSetModuleExports, shared;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.Def = void 0;
    var tslib_12 = require$$0$3, shared_1 = requireShared(), Op = Object.prototype, objToStr = Op.toString, hasOwn2 = Op.hasOwnProperty, BaseType = (
      /** @class */
      function() {
        function BaseType2() {
        }
        return BaseType2.prototype.assert = function(value, deep) {
          if (!this.check(value, deep)) {
            var str2 = shallowStringify(value);
            throw new Error(str2 + " does not match type " + this);
          }
          return !0;
        }, BaseType2.prototype.arrayOf = function() {
          var elemType = this;
          return new ArrayType(elemType);
        }, BaseType2;
      }()
    ), ArrayType = (
      /** @class */
      function(_super) {
        tslib_12.__extends(ArrayType2, _super);
        function ArrayType2(elemType) {
          var _this = _super.call(this) || this;
          return _this.elemType = elemType, _this.kind = "ArrayType", _this;
        }
        return ArrayType2.prototype.toString = function() {
          return "[" + this.elemType + "]";
        }, ArrayType2.prototype.check = function(value, deep) {
          var _this = this;
          return Array.isArray(value) && value.every(function(elem) {
            return _this.elemType.check(elem, deep);
          });
        }, ArrayType2;
      }(BaseType)
    ), IdentityType = (
      /** @class */
      function(_super) {
        tslib_12.__extends(IdentityType2, _super);
        function IdentityType2(value) {
          var _this = _super.call(this) || this;
          return _this.value = value, _this.kind = "IdentityType", _this;
        }
        return IdentityType2.prototype.toString = function() {
          return String(this.value);
        }, IdentityType2.prototype.check = function(value, deep) {
          var result = value === this.value;
          return !result && typeof deep == "function" && deep(this, value), result;
        }, IdentityType2;
      }(BaseType)
    ), ObjectType = (
      /** @class */
      function(_super) {
        tslib_12.__extends(ObjectType2, _super);
        function ObjectType2(fields) {
          var _this = _super.call(this) || this;
          return _this.fields = fields, _this.kind = "ObjectType", _this;
        }
        return ObjectType2.prototype.toString = function() {
          return "{ " + this.fields.join(", ") + " }";
        }, ObjectType2.prototype.check = function(value, deep) {
          return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
            return field.type.check(value[field.name], deep);
          });
        }, ObjectType2;
      }(BaseType)
    ), OrType = (
      /** @class */
      function(_super) {
        tslib_12.__extends(OrType2, _super);
        function OrType2(types2) {
          var _this = _super.call(this) || this;
          return _this.types = types2, _this.kind = "OrType", _this;
        }
        return OrType2.prototype.toString = function() {
          return this.types.join(" | ");
        }, OrType2.prototype.check = function(value, deep) {
          return this.types.some(function(type2) {
            return type2.check(value, !!deep);
          }) ? !0 : (typeof deep == "function" && deep(this, value), !1);
        }, OrType2;
      }(BaseType)
    ), PredicateType = (
      /** @class */
      function(_super) {
        tslib_12.__extends(PredicateType2, _super);
        function PredicateType2(name, predicate) {
          var _this = _super.call(this) || this;
          return _this.name = name, _this.predicate = predicate, _this.kind = "PredicateType", _this;
        }
        return PredicateType2.prototype.toString = function() {
          return this.name;
        }, PredicateType2.prototype.check = function(value, deep) {
          var result = this.predicate(value, deep);
          return !result && typeof deep == "function" && deep(this, value), result;
        }, PredicateType2;
      }(BaseType)
    ), Def = (
      /** @class */
      function() {
        function Def2(type2, typeName) {
          this.type = type2, this.typeName = typeName, this.baseNames = [], this.ownFields = /* @__PURE__ */ Object.create(null), this.allSupertypes = /* @__PURE__ */ Object.create(null), this.supertypeList = [], this.allFields = /* @__PURE__ */ Object.create(null), this.fieldNames = [], this.finalized = !1, this.buildable = !1, this.buildParams = [];
        }
        return Def2.prototype.isSupertypeOf = function(that) {
          if (that instanceof Def2) {
            if (this.finalized !== !0 || that.finalized !== !0)
              throw new Error("");
            return hasOwn2.call(that.allSupertypes, this.typeName);
          } else
            throw new Error(that + " is not a Def");
        }, Def2.prototype.checkAllFields = function(value, deep) {
          var allFields = this.allFields;
          if (this.finalized !== !0)
            throw new Error("" + this.typeName);
          function checkFieldByName(name) {
            var field = allFields[name], type2 = field.type, child = field.getValue(value);
            return type2.check(child, deep);
          }
          return value !== null && typeof value == "object" && Object.keys(allFields).every(checkFieldByName);
        }, Def2.prototype.bases = function() {
          for (var supertypeNames = [], _i = 0; _i < arguments.length; _i++)
            supertypeNames[_i] = arguments[_i];
          var bases = this.baseNames;
          if (this.finalized) {
            if (supertypeNames.length !== bases.length)
              throw new Error("");
            for (var i2 = 0; i2 < supertypeNames.length; i2++)
              if (supertypeNames[i2] !== bases[i2])
                throw new Error("");
            return this;
          }
          return supertypeNames.forEach(function(baseName) {
            bases.indexOf(baseName) < 0 && bases.push(baseName);
          }), this;
        }, Def2;
      }()
    );
    exports2.Def = Def;
    var Field = (
      /** @class */
      function() {
        function Field2(name, type2, defaultFn, hidden) {
          this.name = name, this.type = type2, this.defaultFn = defaultFn, this.hidden = !!hidden;
        }
        return Field2.prototype.toString = function() {
          return JSON.stringify(this.name) + ": " + this.type;
        }, Field2.prototype.getValue = function(obj) {
          var value = obj[this.name];
          return typeof value < "u" || typeof this.defaultFn == "function" && (value = this.defaultFn.call(obj)), value;
        }, Field2;
      }()
    );
    function shallowStringify(value) {
      return Array.isArray(value) ? "[" + value.map(shallowStringify).join(", ") + "]" : value && typeof value == "object" ? "{ " + Object.keys(value).map(function(key2) {
        return key2 + ": " + value[key2];
      }).join(", ") + " }" : JSON.stringify(value);
    }
    function typesPlugin(_fork) {
      var Type2 = {
        or: function() {
          for (var types2 = [], _i = 0; _i < arguments.length; _i++)
            types2[_i] = arguments[_i];
          return new OrType(types2.map(function(type2) {
            return Type2.from(type2);
          }));
        },
        from: function(value, name) {
          if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType)
            return value;
          if (value instanceof Def)
            return value.type;
          if (isArray2.check(value)) {
            if (value.length !== 1)
              throw new Error("only one element type is permitted for typed arrays");
            return new ArrayType(Type2.from(value[0]));
          }
          if (isObject3.check(value))
            return new ObjectType(Object.keys(value).map(function(name2) {
              return new Field(name2, Type2.from(value[name2], name2));
            }));
          if (typeof value == "function") {
            var bicfIndex = builtInCtorFns.indexOf(value);
            if (bicfIndex >= 0)
              return builtInCtorTypes[bicfIndex];
            if (typeof name != "string")
              throw new Error("missing name");
            return new PredicateType(name, value);
          }
          return new IdentityType(value);
        },
        // Define a type whose name is registered in a namespace (the defCache) so
        // that future definitions will return the same type given the same name.
        // In particular, this system allows for circular and forward definitions.
        // The Def object d returned from Type.def may be used to configure the
        // type d.type by calling methods such as d.bases, d.build, and d.field.
        def: function(typeName) {
          return hasOwn2.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
        },
        hasDef: function(typeName) {
          return hasOwn2.call(defCache, typeName);
        }
      }, builtInCtorFns = [], builtInCtorTypes = [];
      function defBuiltInType(name, example) {
        var objStr = objToStr.call(example), type2 = new PredicateType(name, function(value) {
          return objToStr.call(value) === objStr;
        });
        return example && typeof example.constructor == "function" && (builtInCtorFns.push(example.constructor), builtInCtorTypes.push(type2)), type2;
      }
      var isString = defBuiltInType("string", "truthy"), isFunction2 = defBuiltInType("function", function() {
      }), isArray2 = defBuiltInType("array", []), isObject3 = defBuiltInType("object", {}), isRegExp2 = defBuiltInType("RegExp", /./), isDate2 = defBuiltInType("Date", /* @__PURE__ */ new Date()), isNumber2 = defBuiltInType("number", 3), isBoolean2 = defBuiltInType("boolean", !0), isNull2 = defBuiltInType("null", null), isUndefined2 = defBuiltInType("undefined", void 0), isBigInt = typeof BigInt == "function" ? defBuiltInType("BigInt", BigInt(1234)) : new PredicateType("BigInt", function() {
        return !1;
      }), builtInTypes = {
        string: isString,
        function: isFunction2,
        array: isArray2,
        object: isObject3,
        RegExp: isRegExp2,
        Date: isDate2,
        number: isNumber2,
        boolean: isBoolean2,
        null: isNull2,
        undefined: isUndefined2,
        BigInt: isBigInt
      }, defCache = /* @__PURE__ */ Object.create(null);
      function defFromValue(value) {
        if (value && typeof value == "object") {
          var type2 = value.type;
          if (typeof type2 == "string" && hasOwn2.call(defCache, type2)) {
            var d = defCache[type2];
            if (d.finalized)
              return d;
          }
        }
        return null;
      }
      var DefImpl = (
        /** @class */
        function(_super) {
          tslib_12.__extends(DefImpl2, _super);
          function DefImpl2(typeName) {
            var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
              return _this.check(value, deep);
            }), typeName) || this;
            return _this;
          }
          return DefImpl2.prototype.check = function(value, deep) {
            if (this.finalized !== !0)
              throw new Error("prematurely checking unfinalized type " + this.typeName);
            if (value === null || typeof value != "object")
              return !1;
            var vDef = defFromValue(value);
            return vDef ? deep && vDef === this ? this.checkAllFields(value, deep) : this.isSupertypeOf(vDef) ? deep ? vDef.checkAllFields(value, deep) && this.checkAllFields(value, !1) : !0 : !1 : this.typeName === "SourceLocation" || this.typeName === "Position" ? this.checkAllFields(value, deep) : !1;
          }, DefImpl2.prototype.build = function() {
            for (var _this = this, buildParams = [], _i = 0; _i < arguments.length; _i++)
              buildParams[_i] = arguments[_i];
            if (this.buildParams = buildParams, this.buildable)
              return this;
            this.field("type", String, function() {
              return _this.typeName;
            }), this.buildable = !0;
            var addParam = function(built, param, arg, isArgAvailable) {
              if (!hasOwn2.call(built, param)) {
                var all = _this.allFields;
                if (!hasOwn2.call(all, param))
                  throw new Error("" + param);
                var field = all[param], type2 = field.type, value;
                if (isArgAvailable)
                  value = arg;
                else if (field.defaultFn)
                  value = field.defaultFn.call(built);
                else {
                  var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name) {
                    return all[name];
                  }).join(", ") + ")";
                  throw new Error(message);
                }
                if (!type2.check(value))
                  throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
                built[param] = value;
              }
            }, builder = function() {
              for (var args = [], _i2 = 0; _i2 < arguments.length; _i2++)
                args[_i2] = arguments[_i2];
              var argc = args.length;
              if (!_this.finalized)
                throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
              var built = Object.create(nodePrototype);
              if (_this.buildParams.forEach(function(param, i2) {
                i2 < argc ? addParam(built, param, args[i2], !0) : addParam(built, param, null, !1);
              }), Object.keys(_this.allFields).forEach(function(param) {
                addParam(built, param, null, !1);
              }), built.type !== _this.typeName)
                throw new Error("");
              return built;
            };
            return builder.from = function(obj) {
              if (!_this.finalized)
                throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
              var built = Object.create(nodePrototype);
              if (Object.keys(_this.allFields).forEach(function(param) {
                hasOwn2.call(obj, param) ? addParam(built, param, obj[param], !0) : addParam(built, param, null, !1);
              }), built.type !== _this.typeName)
                throw new Error("");
              return built;
            }, Object.defineProperty(builders, getBuilderName(this.typeName), {
              enumerable: !0,
              value: builder
            }), this;
          }, DefImpl2.prototype.field = function(name, type2, defaultFn, hidden) {
            return this.finalized ? (console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName)), this) : (this.ownFields[name] = new Field(name, Type2.from(type2), defaultFn, hidden), this);
          }, DefImpl2.prototype.finalize = function() {
            var _this = this;
            if (!this.finalized) {
              var allFields = this.allFields, allSupertypes = this.allSupertypes;
              this.baseNames.forEach(function(name) {
                var def = defCache[name];
                if (def instanceof Def)
                  def.finalize(), extend4(allFields, def.allFields), extend4(allSupertypes, def.allSupertypes);
                else {
                  var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(_this.typeName);
                  throw new Error(message);
                }
              }), extend4(allFields, this.ownFields), allSupertypes[this.typeName] = this, this.fieldNames.length = 0;
              for (var fieldName in allFields)
                hasOwn2.call(allFields, fieldName) && !allFields[fieldName].hidden && this.fieldNames.push(fieldName);
              Object.defineProperty(namedTypes2, this.typeName, {
                enumerable: !0,
                value: this.type
              }), this.finalized = !0, populateSupertypeList(this.typeName, this.supertypeList), this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0 && wrapExpressionBuilderWithStatement(this.typeName);
            }
          }, DefImpl2;
        }(Def)
      );
      function getSupertypeNames(typeName) {
        if (!hasOwn2.call(defCache, typeName))
          throw new Error("");
        var d = defCache[typeName];
        if (d.finalized !== !0)
          throw new Error("");
        return d.supertypeList.slice(1);
      }
      function computeSupertypeLookupTable(candidates) {
        for (var table = {}, typeNames = Object.keys(defCache), typeNameCount = typeNames.length, i2 = 0; i2 < typeNameCount; ++i2) {
          var typeName = typeNames[i2], d = defCache[typeName];
          if (d.finalized !== !0)
            throw new Error("" + typeName);
          for (var j = 0; j < d.supertypeList.length; ++j) {
            var superTypeName = d.supertypeList[j];
            if (hasOwn2.call(candidates, superTypeName)) {
              table[typeName] = superTypeName;
              break;
            }
          }
        }
        return table;
      }
      var builders = /* @__PURE__ */ Object.create(null), nodePrototype = {};
      function defineMethod(name, func) {
        var old2 = nodePrototype[name];
        return isUndefined2.check(func) ? delete nodePrototype[name] : (isFunction2.assert(func), Object.defineProperty(nodePrototype, name, {
          enumerable: !0,
          configurable: !0,
          value: func
        })), old2;
      }
      function getBuilderName(typeName) {
        return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
          var len = upperCasePrefix.length;
          switch (len) {
            case 0:
              return "";
            case 1:
              return upperCasePrefix.toLowerCase();
            default:
              return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
          }
        });
      }
      function getStatementBuilderName(typeName) {
        return typeName = getBuilderName(typeName), typeName.replace(/(Expression)?$/, "Statement");
      }
      var namedTypes2 = {};
      function getFieldNames(object) {
        var d = defFromValue(object);
        if (d)
          return d.fieldNames.slice(0);
        if ("type" in object)
          throw new Error("did not recognize object of type " + JSON.stringify(object.type));
        return Object.keys(object);
      }
      function getFieldValue(object, fieldName) {
        var d = defFromValue(object);
        if (d) {
          var field = d.allFields[fieldName];
          if (field)
            return field.getValue(object);
        }
        return object && object[fieldName];
      }
      function eachField(object, callback, context) {
        getFieldNames(object).forEach(function(name) {
          callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function someField(object, callback, context) {
        return getFieldNames(object).some(function(name) {
          return callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function wrapExpressionBuilderWithStatement(typeName) {
        var wrapperName = getStatementBuilderName(typeName);
        if (!builders[wrapperName]) {
          var wrapped = builders[getBuilderName(typeName)];
          if (wrapped) {
            var builder = function() {
              for (var args = [], _i = 0; _i < arguments.length; _i++)
                args[_i] = arguments[_i];
              return builders.expressionStatement(wrapped.apply(builders, args));
            };
            builder.from = function() {
              for (var args = [], _i = 0; _i < arguments.length; _i++)
                args[_i] = arguments[_i];
              return builders.expressionStatement(wrapped.from.apply(builders, args));
            }, builders[wrapperName] = builder;
          }
        }
      }
      function populateSupertypeList(typeName, list2) {
        list2.length = 0, list2.push(typeName);
        for (var lastSeen = /* @__PURE__ */ Object.create(null), pos2 = 0; pos2 < list2.length; ++pos2) {
          typeName = list2[pos2];
          var d = defCache[typeName];
          if (d.finalized !== !0)
            throw new Error("");
          hasOwn2.call(lastSeen, typeName) && delete list2[lastSeen[typeName]], lastSeen[typeName] = pos2, list2.push.apply(list2, d.baseNames);
        }
        for (var to = 0, from2 = to, len = list2.length; from2 < len; ++from2)
          hasOwn2.call(list2, from2) && (list2[to++] = list2[from2]);
        list2.length = to;
      }
      function extend4(into, from2) {
        return Object.keys(from2).forEach(function(name) {
          into[name] = from2[name];
        }), into;
      }
      function finalize2() {
        Object.keys(defCache).forEach(function(name) {
          defCache[name].finalize();
        });
      }
      return {
        Type: Type2,
        builtInTypes,
        getSupertypeNames,
        computeSupertypeLookupTable,
        builders,
        defineMethod,
        getBuilderName,
        getStatementBuilderName,
        namedTypes: namedTypes2,
        getFieldNames,
        getFieldValue,
        eachField,
        someField,
        finalize: finalize2
      };
    }
    exports2.default = typesPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(types, types.exports)), types.exports;
}
var pathVisitor = { exports: {} }, nodePath = { exports: {} }, path$2 = { exports: {} }, hasRequiredPath;
function requirePath() {
  return hasRequiredPath || (hasRequiredPath = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_12.__importDefault(requireTypes()), Op = Object.prototype, hasOwn2 = Op.hasOwnProperty;
    function pathPlugin(fork2) {
      var types2 = fork2.use(types_1.default), isArray2 = types2.builtInTypes.array, isNumber2 = types2.builtInTypes.number, Path = function Path2(value, parentPath, name) {
        if (!(this instanceof Path2))
          throw new Error("Path constructor cannot be invoked without 'new'");
        if (parentPath) {
          if (!(parentPath instanceof Path2))
            throw new Error("");
        } else
          parentPath = null, name = null;
        this.value = value, this.parentPath = parentPath, this.name = name, this.__childCache = null;
      }, Pp = Path.prototype;
      function getChildCache(path2) {
        return path2.__childCache || (path2.__childCache = /* @__PURE__ */ Object.create(null));
      }
      function getChildPath(path2, name) {
        var cache = getChildCache(path2), actualChildValue = path2.getValueProperty(name), childPath = cache[name];
        return (!hasOwn2.call(cache, name) || // Ensure consistency between cache and reality.
        childPath.value !== actualChildValue) && (childPath = cache[name] = new path2.constructor(actualChildValue, path2, name)), childPath;
      }
      Pp.getValueProperty = function(name) {
        return this.value[name];
      }, Pp.get = function() {
        for (var names2 = [], _i = 0; _i < arguments.length; _i++)
          names2[_i] = arguments[_i];
        for (var path2 = this, count2 = names2.length, i2 = 0; i2 < count2; ++i2)
          path2 = getChildPath(path2, names2[i2]);
        return path2;
      }, Pp.each = function(callback, context) {
        for (var childPaths = [], len = this.value.length, i2 = 0, i2 = 0; i2 < len; ++i2)
          hasOwn2.call(this.value, i2) && (childPaths[i2] = this.get(i2));
        for (context = context || this, i2 = 0; i2 < len; ++i2)
          hasOwn2.call(childPaths, i2) && callback.call(context, childPaths[i2]);
      }, Pp.map = function(callback, context) {
        var result = [];
        return this.each(function(childPath) {
          result.push(callback.call(this, childPath));
        }, context), result;
      }, Pp.filter = function(callback, context) {
        var result = [];
        return this.each(function(childPath) {
          callback.call(this, childPath) && result.push(childPath);
        }, context), result;
      };
      function emptyMoves() {
      }
      function getMoves(path2, offset, start, end2) {
        if (isArray2.assert(path2.value), offset === 0)
          return emptyMoves;
        var length = path2.value.length;
        if (length < 1)
          return emptyMoves;
        var argc = arguments.length;
        argc === 2 ? (start = 0, end2 = length) : argc === 3 ? (start = Math.max(start, 0), end2 = length) : (start = Math.max(start, 0), end2 = Math.min(end2, length)), isNumber2.assert(start), isNumber2.assert(end2);
        for (var moves = /* @__PURE__ */ Object.create(null), cache = getChildCache(path2), i2 = start; i2 < end2; ++i2)
          if (hasOwn2.call(path2.value, i2)) {
            var childPath = path2.get(i2);
            if (childPath.name !== i2)
              throw new Error("");
            var newIndex = i2 + offset;
            childPath.name = newIndex, moves[newIndex] = childPath, delete cache[i2];
          }
        return delete cache.length, function() {
          for (var newIndex2 in moves) {
            var childPath2 = moves[newIndex2];
            if (childPath2.name !== +newIndex2)
              throw new Error("");
            cache[newIndex2] = childPath2, path2.value[newIndex2] = childPath2.value;
          }
        };
      }
      Pp.shift = function() {
        var move = getMoves(this, -1), result = this.value.shift();
        return move(), result;
      }, Pp.unshift = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        var move = getMoves(this, args.length), result = this.value.unshift.apply(this.value, args);
        return move(), result;
      }, Pp.push = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return isArray2.assert(this.value), delete getChildCache(this).length, this.value.push.apply(this.value, args);
      }, Pp.pop = function() {
        isArray2.assert(this.value);
        var cache = getChildCache(this);
        return delete cache[this.value.length - 1], delete cache.length, this.value.pop();
      }, Pp.insertAt = function(index) {
        var argc = arguments.length, move = getMoves(this, argc - 1, index);
        if (move === emptyMoves && argc <= 1)
          return this;
        index = Math.max(index, 0);
        for (var i2 = 1; i2 < argc; ++i2)
          this.value[index + i2 - 1] = arguments[i2];
        return move(), this;
      }, Pp.insertBefore = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        for (var pp = this.parentPath, argc = args.length, insertAtArgs = [this.name], i2 = 0; i2 < argc; ++i2)
          insertAtArgs.push(args[i2]);
        return pp.insertAt.apply(pp, insertAtArgs);
      }, Pp.insertAfter = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        for (var pp = this.parentPath, argc = args.length, insertAtArgs = [this.name + 1], i2 = 0; i2 < argc; ++i2)
          insertAtArgs.push(args[i2]);
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      function repairRelationshipWithParent(path2) {
        if (!(path2 instanceof Path))
          throw new Error("");
        var pp = path2.parentPath;
        if (!pp)
          return path2;
        var parentValue = pp.value, parentCache = getChildCache(pp);
        if (parentValue[path2.name] === path2.value)
          parentCache[path2.name] = path2;
        else if (isArray2.check(parentValue)) {
          var i2 = parentValue.indexOf(path2.value);
          i2 >= 0 && (parentCache[path2.name = i2] = path2);
        } else
          parentValue[path2.name] = path2.value, parentCache[path2.name] = path2;
        if (parentValue[path2.name] !== path2.value)
          throw new Error("");
        if (path2.parentPath.get(path2.name) !== path2)
          throw new Error("");
        return path2;
      }
      return Pp.replace = function(replacement) {
        var results = [], parentValue = this.parentPath.value, parentCache = getChildCache(this.parentPath), count2 = arguments.length;
        if (repairRelationshipWithParent(this), isArray2.check(parentValue)) {
          for (var originalLength = parentValue.length, move = getMoves(this.parentPath, count2 - 1, this.name + 1), spliceArgs = [this.name, 1], i2 = 0; i2 < count2; ++i2)
            spliceArgs.push(arguments[i2]);
          var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
          if (splicedOut[0] !== this.value)
            throw new Error("");
          if (parentValue.length !== originalLength - 1 + count2)
            throw new Error("");
          if (move(), count2 === 0)
            delete this.value, delete parentCache[this.name], this.__childCache = null;
          else {
            if (parentValue[this.name] !== replacement)
              throw new Error("");
            for (this.value !== replacement && (this.value = replacement, this.__childCache = null), i2 = 0; i2 < count2; ++i2)
              results.push(this.parentPath.get(this.name + i2));
            if (results[0] !== this)
              throw new Error("");
          }
        } else if (count2 === 1)
          this.value !== replacement && (this.__childCache = null), this.value = parentValue[this.name] = replacement, results.push(this);
        else if (count2 === 0)
          delete parentValue[this.name], delete this.value, this.__childCache = null;
        else
          throw new Error("Could not replace path");
        return results;
      }, Path;
    }
    exports2.default = pathPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(path$2, path$2.exports)), path$2.exports;
}
var scope = { exports: {} }, hasRequiredScope;
function requireScope() {
  return hasRequiredScope || (hasRequiredScope = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_12.__importDefault(requireTypes()), hasOwn2 = Object.prototype.hasOwnProperty;
    function scopePlugin(fork2) {
      var types2 = fork2.use(types_1.default), Type2 = types2.Type, namedTypes2 = types2.namedTypes, Node2 = namedTypes2.Node, Expression = namedTypes2.Expression, isArray2 = types2.builtInTypes.array, b = types2.builders, Scope = function Scope2(path2, parentScope) {
        if (!(this instanceof Scope2))
          throw new Error("Scope constructor cannot be invoked without 'new'");
        TypeParameterScopeType.check(path2.value) || ScopeType.assert(path2.value);
        var depth2;
        if (parentScope) {
          if (!(parentScope instanceof Scope2))
            throw new Error("");
          depth2 = parentScope.depth + 1;
        } else
          parentScope = null, depth2 = 0;
        Object.defineProperties(this, {
          path: { value: path2 },
          node: { value: path2.value },
          isGlobal: { value: !parentScope, enumerable: !0 },
          depth: { value: depth2 },
          parent: { value: parentScope },
          bindings: { value: {} },
          types: { value: {} }
        });
      }, ScopeType = Type2.or(
        // Program nodes introduce global scopes.
        namedTypes2.Program,
        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes2.Function,
        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes2.CatchClause
      ), TypeParameterScopeType = Type2.or(namedTypes2.Function, namedTypes2.ClassDeclaration, namedTypes2.ClassExpression, namedTypes2.InterfaceDeclaration, namedTypes2.TSInterfaceDeclaration, namedTypes2.TypeAlias, namedTypes2.TSTypeAliasDeclaration), FlowOrTSTypeParameterType = Type2.or(namedTypes2.TypeParameter, namedTypes2.TSTypeParameter);
      Scope.isEstablishedBy = function(node2) {
        return ScopeType.check(node2) || TypeParameterScopeType.check(node2);
      };
      var Sp = Scope.prototype;
      Sp.didScan = !1, Sp.declares = function(name) {
        return this.scan(), hasOwn2.call(this.bindings, name);
      }, Sp.declaresType = function(name) {
        return this.scan(), hasOwn2.call(this.types, name);
      }, Sp.declareTemporary = function(prefix) {
        if (prefix) {
          if (!/^[a-z$_]/i.test(prefix))
            throw new Error("");
        } else
          prefix = "t$";
        prefix += this.depth.toString(36) + "$", this.scan();
        for (var index = 0; this.declares(prefix + index); )
          ++index;
        var name = prefix + index;
        return this.bindings[name] = types2.builders.identifier(name);
      }, Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());
        var bodyPath = this.path.get("body");
        return namedTypes2.BlockStatement.check(bodyPath.value) && (bodyPath = bodyPath.get("body")), bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init || null)])), identifier;
      }, Sp.scan = function(force) {
        if (force || !this.didScan) {
          for (var name in this.bindings)
            delete this.bindings[name];
          for (var name in this.types)
            delete this.types[name];
          scanScope(this.path, this.bindings, this.types), this.didScan = !0;
        }
      }, Sp.getBindings = function() {
        return this.scan(), this.bindings;
      }, Sp.getTypes = function() {
        return this.scan(), this.types;
      };
      function scanScope(path2, bindings, scopeTypes) {
        var node2 = path2.value;
        if (TypeParameterScopeType.check(node2)) {
          var params = path2.get("typeParameters", "params");
          isArray2.check(params.value) && params.each(function(childPath) {
            addTypeParameter(childPath, scopeTypes);
          });
        }
        ScopeType.check(node2) && (namedTypes2.CatchClause.check(node2) ? addPattern(path2.get("param"), bindings) : recursiveScanScope(path2, bindings, scopeTypes));
      }
      function recursiveScanScope(path2, bindings, scopeTypes) {
        var node2 = path2.value;
        path2.parent && namedTypes2.FunctionExpression.check(path2.parent.node) && path2.parent.node.id && addPattern(path2.parent.get("id"), bindings), node2 && (isArray2.check(node2) ? path2.each(function(childPath) {
          recursiveScanChild(childPath, bindings, scopeTypes);
        }) : namedTypes2.Function.check(node2) ? (path2.get("params").each(function(paramPath) {
          addPattern(paramPath, bindings);
        }), recursiveScanChild(path2.get("body"), bindings, scopeTypes), recursiveScanScope(path2.get("typeParameters"), bindings, scopeTypes)) : namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node2) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node2) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node2) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node2) ? addTypePattern(path2.get("id"), scopeTypes) : namedTypes2.VariableDeclarator.check(node2) ? (addPattern(path2.get("id"), bindings), recursiveScanChild(path2.get("init"), bindings, scopeTypes)) : node2.type === "ImportSpecifier" || node2.type === "ImportNamespaceSpecifier" || node2.type === "ImportDefaultSpecifier" ? addPattern(
          // Esprima used to use the .name field to refer to the local
          // binding identifier for ImportSpecifier nodes, but .id for
          // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
          // ESTree/Acorn/ESpree use .local for all three node types.
          path2.get(node2.local ? "local" : node2.name ? "name" : "id"),
          bindings
        ) : Node2.check(node2) && !Expression.check(node2) && types2.eachField(node2, function(name, child) {
          var childPath = path2.get(name);
          if (!pathHasValue(childPath, child))
            throw new Error("");
          recursiveScanChild(childPath, bindings, scopeTypes);
        }));
      }
      function pathHasValue(path2, value) {
        return !!(path2.value === value || Array.isArray(path2.value) && path2.value.length === 0 && Array.isArray(value) && value.length === 0);
      }
      function recursiveScanChild(path2, bindings, scopeTypes) {
        var node2 = path2.value;
        if (!(!node2 || Expression.check(node2))) if (namedTypes2.FunctionDeclaration.check(node2) && node2.id !== null)
          addPattern(path2.get("id"), bindings);
        else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node2) && node2.id !== null)
          addPattern(path2.get("id"), bindings), recursiveScanScope(path2.get("typeParameters"), bindings, scopeTypes);
        else if (namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node2) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node2))
          addTypePattern(path2.get("id"), scopeTypes);
        else if (ScopeType.check(node2)) {
          if (namedTypes2.CatchClause.check(node2) && // TODO Broaden this to accept any pattern.
          namedTypes2.Identifier.check(node2.param)) {
            var catchParamName = node2.param.name, hadBinding = hasOwn2.call(bindings, catchParamName);
            recursiveScanScope(path2.get("body"), bindings, scopeTypes), hadBinding || delete bindings[catchParamName];
          }
        } else
          recursiveScanScope(path2, bindings, scopeTypes);
      }
      function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern), namedTypes2.Identifier.check(pattern) ? hasOwn2.call(bindings, pattern.name) ? bindings[pattern.name].push(patternPath) : bindings[pattern.name] = [patternPath] : namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern) ? addPattern(patternPath.get("left"), bindings) : namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern) ? patternPath.get("properties").each(function(propertyPath) {
          var property = propertyPath.value;
          namedTypes2.Pattern.check(property) ? addPattern(propertyPath, bindings) : namedTypes2.Property.check(property) || namedTypes2.ObjectProperty && namedTypes2.ObjectProperty.check(property) ? addPattern(propertyPath.get("value"), bindings) : namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property) && addPattern(propertyPath.get("argument"), bindings);
        }) : namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern) ? patternPath.get("elements").each(function(elementPath) {
          var element = elementPath.value;
          namedTypes2.Pattern.check(element) ? addPattern(elementPath, bindings) : namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element) && addPattern(elementPath.get("argument"), bindings);
        }) : namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern) ? addPattern(patternPath.get("pattern"), bindings) : (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.RestElement && namedTypes2.RestElement.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) && addPattern(patternPath.get("argument"), bindings);
      }
      function addTypePattern(patternPath, types3) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern), namedTypes2.Identifier.check(pattern) && (hasOwn2.call(types3, pattern.name) ? types3[pattern.name].push(patternPath) : types3[pattern.name] = [patternPath]);
      }
      function addTypeParameter(parameterPath, types3) {
        var parameter = parameterPath.value;
        FlowOrTSTypeParameterType.assert(parameter), hasOwn2.call(types3, parameter.name) ? types3[parameter.name].push(parameterPath) : types3[parameter.name] = [parameterPath];
      }
      return Sp.lookup = function(name) {
        for (var scope2 = this; scope2 && !scope2.declares(name); scope2 = scope2.parent)
          ;
        return scope2;
      }, Sp.lookupType = function(name) {
        for (var scope2 = this; scope2 && !scope2.declaresType(name); scope2 = scope2.parent)
          ;
        return scope2;
      }, Sp.getGlobalScope = function() {
        for (var scope2 = this; !scope2.isGlobal; )
          scope2 = scope2.parent;
        return scope2;
      }, Scope;
    }
    exports2.default = scopePlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(scope, scope.exports)), scope.exports;
}
var hasRequiredNodePath;
function requireNodePath() {
  return hasRequiredNodePath || (hasRequiredNodePath = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, types_1 = tslib_12.__importDefault(requireTypes()), path_12 = tslib_12.__importDefault(requirePath()), scope_1 = tslib_12.__importDefault(requireScope()), shared_1 = requireShared();
    function nodePathPlugin(fork2) {
      var types2 = fork2.use(types_1.default), n = types2.namedTypes, b = types2.builders, isNumber2 = types2.builtInTypes.number, isArray2 = types2.builtInTypes.array, Path = fork2.use(path_12.default), Scope = fork2.use(scope_1.default), NodePath = function NodePath2(value, parentPath, name) {
        if (!(this instanceof NodePath2))
          throw new Error("NodePath constructor cannot be invoked without 'new'");
        Path.call(this, value, parentPath, name);
      }, NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
          value: NodePath,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
      Object.defineProperties(NPp, {
        node: {
          get: function() {
            return Object.defineProperty(this, "node", {
              configurable: !0,
              value: this._computeNode()
            }), this.node;
          }
        },
        parent: {
          get: function() {
            return Object.defineProperty(this, "parent", {
              configurable: !0,
              value: this._computeParent()
            }), this.parent;
          }
        },
        scope: {
          get: function() {
            return Object.defineProperty(this, "scope", {
              configurable: !0,
              value: this._computeScope()
            }), this.scope;
          }
        }
      }), NPp.replace = function() {
        return delete this.node, delete this.parent, delete this.scope, Path.prototype.replace.apply(this, arguments);
      }, NPp.prune = function() {
        var remainingNodePath = this.parent;
        return this.replace(), cleanUpNodesAfterPrune(remainingNodePath);
      }, NPp._computeNode = function() {
        var value = this.value;
        if (n.Node.check(value))
          return value;
        var pp = this.parentPath;
        return pp && pp.node || null;
      }, NPp._computeParent = function() {
        var value = this.value, pp = this.parentPath;
        if (!n.Node.check(value)) {
          for (; pp && !n.Node.check(pp.value); )
            pp = pp.parentPath;
          pp && (pp = pp.parentPath);
        }
        for (; pp && !n.Node.check(pp.value); )
          pp = pp.parentPath;
        return pp || null;
      }, NPp._computeScope = function() {
        var value = this.value, pp = this.parentPath, scope2 = pp && pp.scope;
        return n.Node.check(value) && Scope.isEstablishedBy(value) && (scope2 = new Scope(this, scope2)), scope2 || null;
      }, NPp.getValueProperty = function(name) {
        return types2.getFieldValue(this.value, name);
      }, NPp.needsParens = function(assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp)
          return !1;
        var node2 = this.value;
        if (!n.Expression.check(node2) || node2.type === "Identifier")
          return !1;
        for (; !n.Node.check(pp.value); )
          if (pp = pp.parentPath, !pp)
            return !1;
        var parent = pp.value;
        switch (node2.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return parent.type === "MemberExpression" && this.name === "object" && parent.object === node2;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (parent.type) {
              case "CallExpression":
                return this.name === "callee" && parent.callee === node2;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return !0;
              case "MemberExpression":
                return this.name === "object" && parent.object === node2;
              case "BinaryExpression":
              case "LogicalExpression": {
                var n_1 = node2, po = parent.operator, pp_1 = PRECEDENCE[po], no = n_1.operator, np = PRECEDENCE[no];
                if (pp_1 > np)
                  return !0;
                if (pp_1 === np && this.name === "right") {
                  if (parent.right !== n_1)
                    throw new Error("Nodes must be equal");
                  return !0;
                }
              }
              default:
                return !1;
            }
          case "SequenceExpression":
            switch (parent.type) {
              case "ForStatement":
                return !1;
              case "ExpressionStatement":
                return this.name !== "expression";
              default:
                return !0;
            }
          case "YieldExpression":
            switch (parent.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return !0;
              default:
                return !1;
            }
          case "Literal":
            return parent.type === "MemberExpression" && isNumber2.check(node2.value) && this.name === "object" && parent.object === node2;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (parent.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return !0;
              case "CallExpression":
                return this.name === "callee" && parent.callee === node2;
              case "ConditionalExpression":
                return this.name === "test" && parent.test === node2;
              case "MemberExpression":
                return this.name === "object" && parent.object === node2;
              default:
                return !1;
            }
          default:
            if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node2)
              return containsCallExpression(node2);
        }
        return !!(assumeExpressionContext !== !0 && !this.canBeFirstInStatement() && this.firstInStatement());
      };
      function isBinary2(node2) {
        return n.BinaryExpression.check(node2) || n.LogicalExpression.check(node2);
      }
      var PRECEDENCE = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
      ].forEach(function(tier, i2) {
        tier.forEach(function(op) {
          PRECEDENCE[op] = i2;
        });
      });
      function containsCallExpression(node2) {
        return n.CallExpression.check(node2) ? !0 : isArray2.check(node2) ? node2.some(containsCallExpression) : n.Node.check(node2) ? types2.someField(node2, function(_name, child) {
          return containsCallExpression(child);
        }) : !1;
      }
      NPp.canBeFirstInStatement = function() {
        var node2 = this.node;
        return !n.FunctionExpression.check(node2) && !n.ObjectExpression.check(node2);
      }, NPp.firstInStatement = function() {
        return firstInStatement(this);
      };
      function firstInStatement(path2) {
        for (var node2, parent; path2.parent; path2 = path2.parent) {
          if (node2 = path2.node, parent = path2.parent.node, n.BlockStatement.check(parent) && path2.parent.name === "body" && path2.name === 0) {
            if (parent.body[0] !== node2)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (n.ExpressionStatement.check(parent) && path2.name === "expression") {
            if (parent.expression !== node2)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (n.SequenceExpression.check(parent) && path2.parent.name === "expressions" && path2.name === 0) {
            if (parent.expressions[0] !== node2)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.CallExpression.check(parent) && path2.name === "callee") {
            if (parent.callee !== node2)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.MemberExpression.check(parent) && path2.name === "object") {
            if (parent.object !== node2)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.ConditionalExpression.check(parent) && path2.name === "test") {
            if (parent.test !== node2)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (isBinary2(parent) && path2.name === "left") {
            if (parent.left !== node2)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.UnaryExpression.check(parent) && !parent.prefix && path2.name === "argument") {
            if (parent.argument !== node2)
              throw new Error("Nodes must be equal");
            continue;
          }
          return !1;
        }
        return !0;
      }
      function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
          var declarations = remainingNodePath.get("declarations").value;
          if (!declarations || declarations.length === 0)
            return remainingNodePath.prune();
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
          if (!remainingNodePath.get("expression").value)
            return remainingNodePath.prune();
        } else n.IfStatement.check(remainingNodePath.node) && cleanUpIfStatementAfterPrune(remainingNodePath);
        return remainingNodePath;
      }
      function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get("test").value, alternate = ifStatement.get("alternate").value, consequent = ifStatement.get("consequent").value;
        if (!consequent && !alternate) {
          var testExpressionStatement = b.expressionStatement(testExpression);
          ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
          var negatedTestExpression = b.unaryExpression("!", testExpression, !0);
          n.UnaryExpression.check(testExpression) && testExpression.operator === "!" && (negatedTestExpression = testExpression.argument), ifStatement.get("test").replace(negatedTestExpression), ifStatement.get("consequent").replace(alternate), ifStatement.get("alternate").replace();
        }
      }
      return NodePath;
    }
    exports2.default = nodePathPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(nodePath, nodePath.exports)), nodePath.exports;
}
var hasRequiredPathVisitor;
function requirePathVisitor() {
  return hasRequiredPathVisitor || (hasRequiredPathVisitor = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, types_1 = tslib_12.__importDefault(requireTypes()), node_path_1 = tslib_12.__importDefault(requireNodePath()), shared_1 = requireShared(), hasOwn2 = Object.prototype.hasOwnProperty;
    function pathVisitorPlugin(fork2) {
      var types2 = fork2.use(types_1.default), NodePath = fork2.use(node_path_1.default), isArray2 = types2.builtInTypes.array, isObject3 = types2.builtInTypes.object, isFunction2 = types2.builtInTypes.function, undefined$1, PathVisitor = function PathVisitor2() {
        if (!(this instanceof PathVisitor2))
          throw new Error("PathVisitor constructor cannot be invoked without 'new'");
        this._reusableContextStack = [], this._methodNameTable = computeMethodNameTable(this), this._shouldVisitComments = hasOwn2.call(this._methodNameTable, "Block") || hasOwn2.call(this._methodNameTable, "Line"), this.Context = makeContextConstructor(this), this._visiting = !1, this._changeReported = !1;
      };
      function computeMethodNameTable(visitor) {
        var typeNames = /* @__PURE__ */ Object.create(null);
        for (var methodName in visitor)
          /^visit[A-Z]/.test(methodName) && (typeNames[methodName.slice(5)] = !0);
        for (var supertypeTable = types2.computeSupertypeLookupTable(typeNames), methodNameTable = /* @__PURE__ */ Object.create(null), typeNameKeys = Object.keys(supertypeTable), typeNameCount = typeNameKeys.length, i2 = 0; i2 < typeNameCount; ++i2) {
          var typeName = typeNameKeys[i2];
          methodName = "visit" + supertypeTable[typeName], isFunction2.check(visitor[methodName]) && (methodNameTable[typeName] = methodName);
        }
        return methodNameTable;
      }
      PathVisitor.fromMethodsObject = function(methods) {
        if (methods instanceof PathVisitor)
          return methods;
        if (!isObject3.check(methods))
          return new PathVisitor();
        var Visitor = function Visitor2() {
          if (!(this instanceof Visitor2))
            throw new Error("Visitor constructor cannot be invoked without 'new'");
          PathVisitor.call(this);
        }, Vp = Visitor.prototype = Object.create(PVp);
        return Vp.constructor = Visitor, extend4(Vp, methods), extend4(Visitor, PathVisitor), isFunction2.assert(Visitor.fromMethodsObject), isFunction2.assert(Visitor.visit), new Visitor();
      };
      function extend4(target, source2) {
        for (var property in source2)
          hasOwn2.call(source2, property) && (target[property] = source2[property]);
        return target;
      }
      PathVisitor.visit = function(node2, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node2);
      };
      var PVp = PathVisitor.prototype;
      PVp.visit = function() {
        if (this._visiting)
          throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
        this._visiting = !0, this._changeReported = !1, this._abortRequested = !1;
        for (var argc = arguments.length, args = new Array(argc), i2 = 0; i2 < argc; ++i2)
          args[i2] = arguments[i2];
        args[0] instanceof NodePath || (args[0] = new NodePath({ root: args[0] }).get("root")), this.reset.apply(this, args);
        var didNotThrow;
        try {
          var root2 = this.visitWithoutReset(args[0]);
          didNotThrow = !0;
        } finally {
          if (this._visiting = !1, !didNotThrow && this._abortRequested)
            return args[0].value;
        }
        return root2;
      }, PVp.AbortRequest = function() {
      }, PVp.abort = function() {
        var visitor = this;
        visitor._abortRequested = !0;
        var request2 = new visitor.AbortRequest();
        throw request2.cancel = function() {
          visitor._abortRequested = !1;
        }, request2;
      }, PVp.reset = function(_path) {
      }, PVp.visitWithoutReset = function(path2) {
        if (this instanceof this.Context)
          return this.visitor.visitWithoutReset(path2);
        if (!(path2 instanceof NodePath))
          throw new Error("");
        var value = path2.value, methodName = value && typeof value == "object" && typeof value.type == "string" && this._methodNameTable[value.type];
        if (methodName) {
          var context = this.acquireContext(path2);
          try {
            return context.invokeVisitorMethod(methodName);
          } finally {
            this.releaseContext(context);
          }
        } else
          return visitChildren(path2, this);
      };
      function visitChildren(path2, visitor) {
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(visitor instanceof PathVisitor))
          throw new Error("");
        var value = path2.value;
        if (isArray2.check(value))
          path2.each(visitor.visitWithoutReset, visitor);
        else if (isObject3.check(value)) {
          var childNames = types2.getFieldNames(value);
          visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0 && childNames.push("comments");
          for (var childCount = childNames.length, childPaths = [], i2 = 0; i2 < childCount; ++i2) {
            var childName = childNames[i2];
            hasOwn2.call(value, childName) || (value[childName] = types2.getFieldValue(value, childName)), childPaths.push(path2.get(childName));
          }
          for (var i2 = 0; i2 < childCount; ++i2)
            visitor.visitWithoutReset(childPaths[i2]);
        }
        return path2.value;
      }
      PVp.acquireContext = function(path2) {
        return this._reusableContextStack.length === 0 ? new this.Context(path2) : this._reusableContextStack.pop().reset(path2);
      }, PVp.releaseContext = function(context) {
        if (!(context instanceof this.Context))
          throw new Error("");
        this._reusableContextStack.push(context), context.currentPath = null;
      }, PVp.reportChanged = function() {
        this._changeReported = !0;
      }, PVp.wasChangeReported = function() {
        return this._changeReported;
      };
      function makeContextConstructor(visitor) {
        function Context2(path2) {
          if (!(this instanceof Context2))
            throw new Error("");
          if (!(this instanceof PathVisitor))
            throw new Error("");
          if (!(path2 instanceof NodePath))
            throw new Error("");
          Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: !1,
            enumerable: !0,
            configurable: !1
          }), this.currentPath = path2, this.needToCallTraverse = !0, Object.seal(this);
        }
        if (!(visitor instanceof PathVisitor))
          throw new Error("");
        var Cp = Context2.prototype = Object.create(visitor);
        return Cp.constructor = Context2, extend4(Cp, sharedContextProtoMethods), Context2;
      }
      var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);
      return sharedContextProtoMethods.reset = function(path2) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        return this.currentPath = path2, this.needToCallTraverse = !0, this;
      }, sharedContextProtoMethods.invokeVisitorMethod = function(methodName) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        var result = this.visitor[methodName].call(this, this.currentPath);
        if (result === !1 ? this.needToCallTraverse = !1 : result !== undefined$1 && (this.currentPath = this.currentPath.replace(result)[0], this.needToCallTraverse && this.traverse(this.currentPath)), this.needToCallTraverse !== !1)
          throw new Error("Must either call this.traverse or return false in " + methodName);
        var path2 = this.currentPath;
        return path2 && path2.value;
      }, sharedContextProtoMethods.traverse = function(path2, newVisitor) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        return this.needToCallTraverse = !1, visitChildren(path2, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
      }, sharedContextProtoMethods.visit = function(path2, newVisitor) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        return this.needToCallTraverse = !1, PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path2);
      }, sharedContextProtoMethods.reportChanged = function() {
        this.visitor.reportChanged();
      }, sharedContextProtoMethods.abort = function() {
        this.needToCallTraverse = !1, this.visitor.abort();
      }, PathVisitor;
    }
    exports2.default = pathVisitorPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(pathVisitor, pathVisitor.exports)), pathVisitor.exports;
}
var equiv = { exports: {} }, hasRequiredEquiv;
function requireEquiv() {
  return hasRequiredEquiv || (hasRequiredEquiv = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_12.__importDefault(requireTypes());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), getFieldNames = types2.getFieldNames, getFieldValue = types2.getFieldValue, isArray2 = types2.builtInTypes.array, isObject3 = types2.builtInTypes.object, isDate2 = types2.builtInTypes.Date, isRegExp2 = types2.builtInTypes.RegExp, hasOwn2 = Object.prototype.hasOwnProperty;
      function astNodesAreEquivalent(a, b, problemPath) {
        return isArray2.check(problemPath) ? problemPath.length = 0 : problemPath = null, areEquivalent(a, b, problemPath);
      }
      astNodesAreEquivalent.assert = function(a, b) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a, b, problemPath))
          if (problemPath.length === 0) {
            if (a !== b)
              throw new Error("Nodes must be equal");
          } else
            throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
      };
      function subscriptForProperty(property) {
        return /[_$a-z][_$a-z0-9]*/i.test(property) ? "." + property : "[" + JSON.stringify(property) + "]";
      }
      function areEquivalent(a, b, problemPath) {
        return a === b ? !0 : isArray2.check(a) ? arraysAreEquivalent(a, b, problemPath) : isObject3.check(a) ? objectsAreEquivalent(a, b, problemPath) : isDate2.check(a) ? isDate2.check(b) && +a == +b : isRegExp2.check(a) ? isRegExp2.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase : a == b;
      }
      function arraysAreEquivalent(a, b, problemPath) {
        isArray2.assert(a);
        var aLength = a.length;
        if (!isArray2.check(b) || b.length !== aLength)
          return problemPath && problemPath.push("length"), !1;
        for (var i2 = 0; i2 < aLength; ++i2) {
          if (problemPath && problemPath.push(i2), i2 in a != i2 in b || !areEquivalent(a[i2], b[i2], problemPath))
            return !1;
          if (problemPath) {
            var problemPathTail = problemPath.pop();
            if (problemPathTail !== i2)
              throw new Error("" + problemPathTail);
          }
        }
        return !0;
      }
      function objectsAreEquivalent(a, b, problemPath) {
        if (isObject3.assert(a), !isObject3.check(b))
          return !1;
        if (a.type !== b.type)
          return problemPath && problemPath.push("type"), !1;
        var aNames = getFieldNames(a), aNameCount = aNames.length, bNames = getFieldNames(b), bNameCount = bNames.length;
        if (aNameCount === bNameCount) {
          for (var i2 = 0; i2 < aNameCount; ++i2) {
            var name = aNames[i2], aChild = getFieldValue(a, name), bChild = getFieldValue(b, name);
            if (problemPath && problemPath.push(name), !areEquivalent(aChild, bChild, problemPath))
              return !1;
            if (problemPath) {
              var problemPathTail = problemPath.pop();
              if (problemPathTail !== name)
                throw new Error("" + problemPathTail);
            }
          }
          return !0;
        }
        if (!problemPath)
          return !1;
        var seenNames = /* @__PURE__ */ Object.create(null);
        for (i2 = 0; i2 < aNameCount; ++i2)
          seenNames[aNames[i2]] = !0;
        for (i2 = 0; i2 < bNameCount; ++i2) {
          if (name = bNames[i2], !hasOwn2.call(seenNames, name))
            return problemPath.push(name), !1;
          delete seenNames[name];
        }
        for (name in seenNames) {
          problemPath.push(name);
          break;
        }
        return !1;
      }
      return astNodesAreEquivalent;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(equiv, equiv.exports)), equiv.exports;
}
var hasRequiredFork;
function requireFork() {
  return hasRequiredFork || (hasRequiredFork = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, types_1 = tslib_12.__importDefault(requireTypes()), path_visitor_1 = tslib_12.__importDefault(requirePathVisitor()), equiv_1 = tslib_12.__importDefault(requireEquiv()), path_12 = tslib_12.__importDefault(requirePath()), node_path_1 = tslib_12.__importDefault(requireNodePath()), shared_1 = requireShared();
    function default_1(plugins) {
      var fork2 = createFork(), types2 = fork2.use(types_1.default);
      plugins.forEach(fork2.use), types2.finalize();
      var PathVisitor = fork2.use(path_visitor_1.default);
      return {
        Type: types2.Type,
        builtInTypes: types2.builtInTypes,
        namedTypes: types2.namedTypes,
        builders: types2.builders,
        defineMethod: types2.defineMethod,
        getFieldNames: types2.getFieldNames,
        getFieldValue: types2.getFieldValue,
        eachField: types2.eachField,
        someField: types2.someField,
        getSupertypeNames: types2.getSupertypeNames,
        getBuilderName: types2.getBuilderName,
        astNodesAreEquivalent: fork2.use(equiv_1.default),
        finalize: types2.finalize,
        Path: fork2.use(path_12.default),
        NodePath: fork2.use(node_path_1.default),
        PathVisitor,
        use: fork2.use,
        visit: PathVisitor.visit
      };
    }
    exports2.default = default_1;
    function createFork() {
      var used = [], usedResult = [];
      function use(plugin) {
        var idx = used.indexOf(plugin);
        return idx === -1 && (idx = used.length, used.push(plugin), usedResult[idx] = plugin(fork2)), usedResult[idx];
      }
      var fork2 = { use };
      return fork2;
    }
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(fork, fork.exports)), fork.exports;
}
var esProposals = { exports: {} }, es2022 = { exports: {} }, es2021$1 = { exports: {} }, es2021 = { exports: {} }, es2020$1 = { exports: {} }, es2016$1 = { exports: {} }, core$1 = { exports: {} }, hasRequiredCore$1;
function requireCore$1() {
  return hasRequiredCore$1 || (hasRequiredCore$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var shared_1 = requireShared();
    function default_1() {
      return {
        BinaryOperators: [
          "==",
          "!=",
          "===",
          "!==",
          "<",
          "<=",
          ">",
          ">=",
          "<<",
          ">>",
          ">>>",
          "+",
          "-",
          "*",
          "/",
          "%",
          "&",
          "|",
          "^",
          "in",
          "instanceof"
        ],
        AssignmentOperators: [
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "<<=",
          ">>=",
          ">>>=",
          "|=",
          "^=",
          "&="
        ],
        LogicalOperators: [
          "||",
          "&&"
        ]
      };
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(core$1, core$1.exports)), core$1.exports;
}
var hasRequiredEs2016$1;
function requireEs2016$1() {
  return hasRequiredEs2016$1 || (hasRequiredEs2016$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, shared_1 = requireShared(), core_12 = tslib_12.__importDefault(requireCore$1());
    function default_1(fork2) {
      var result = fork2.use(core_12.default);
      return result.BinaryOperators.indexOf("**") < 0 && result.BinaryOperators.push("**"), result.AssignmentOperators.indexOf("**=") < 0 && result.AssignmentOperators.push("**="), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2016$1, es2016$1.exports)), es2016$1.exports;
}
var hasRequiredEs2020$1;
function requireEs2020$1() {
  return hasRequiredEs2020$1 || (hasRequiredEs2020$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, shared_1 = requireShared(), es2016_1 = tslib_12.__importDefault(requireEs2016$1());
    function default_1(fork2) {
      var result = fork2.use(es2016_1.default);
      return result.LogicalOperators.indexOf("??") < 0 && result.LogicalOperators.push("??"), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2020$1, es2020$1.exports)), es2020$1.exports;
}
var hasRequiredEs2021$1;
function requireEs2021$1() {
  return hasRequiredEs2021$1 || (hasRequiredEs2021$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, shared_1 = requireShared(), es2020_1 = tslib_12.__importDefault(requireEs2020$1());
    function default_1(fork2) {
      var result = fork2.use(es2020_1.default);
      return result.LogicalOperators.forEach(function(op) {
        var assignOp = op + "=";
        result.AssignmentOperators.indexOf(assignOp) < 0 && result.AssignmentOperators.push(assignOp);
      }), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2021, es2021.exports)), es2021.exports;
}
var es2020 = { exports: {} }, es2019 = { exports: {} }, es2018 = { exports: {} }, es2017 = { exports: {} }, es2016 = { exports: {} }, es6 = { exports: {} }, core = { exports: {} }, hasRequiredCore;
function requireCore() {
  return hasRequiredCore || (hasRequiredCore = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, core_12 = tslib_12.__importDefault(requireCore$1()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), Type2 = types2.Type, def = Type2.def, or = Type2.or, shared2 = fork2.use(shared_1.default), defaults2 = shared2.defaults, geq = shared2.geq, _a = fork2.use(core_12.default), BinaryOperators = _a.BinaryOperators, AssignmentOperators = _a.AssignmentOperators, LogicalOperators = _a.LogicalOperators;
      def("Printable").field("loc", or(def("SourceLocation"), null), defaults2.null, !0), def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults2.null, !0), def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults2.null), def("Position").field("line", geq(1)).field("column", geq(0)), def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults2.null), def("Program").bases("Node").build("body").field("body", [def("Statement")]), def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults2.null).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults2.false).field("async", Boolean, defaults2.false), def("Statement").bases("Node"), def("EmptyStatement").bases("Statement").build(), def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]), def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression")), def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults2.null), def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement")), def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2.null), def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2.null), def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement")), def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults2.false), def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null)), def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression")), def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
      }).field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
      }, !0).field("guardedHandlers", [def("CatchClause")], defaults2.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults2.null), def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults2.null).field("body", def("BlockStatement")), def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement")), def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression")), def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement")), def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement")), def("DebuggerStatement").bases("Statement").build(), def("Declaration").bases("Statement"), def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier")), def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body"), def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]), def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults2.null), def("Expression").bases("Node"), def("ThisExpression").bases("Expression").build(), def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]), def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]), def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression")), def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
      var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
      def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults2.true);
      var BinaryOperator = or.apply(void 0, BinaryOperators);
      def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
      var AssignmentOperator = or.apply(void 0, AssignmentOperators);
      def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
      var UpdateOperator = or("++", "--");
      def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
      var LogicalOperator = or.apply(void 0, LogicalOperators);
      def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression")), def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression")), def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]), def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]), def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
        var type2 = this.property.type;
        return type2 === "Literal" || type2 === "MemberExpression" || type2 === "BinaryExpression";
      }), def("Pattern").bases("Node"), def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]), def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults2.false), def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp, BigInt)), def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults2.true).field("trailing", Boolean, defaults2.false);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(core, core.exports)), core.exports;
}
var hasRequiredEs6;
function requireEs6() {
  return hasRequiredEs6 || (hasRequiredEs6 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, core_12 = tslib_12.__importDefault(requireCore()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(core_12.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("Function").field("generator", Boolean, defaults2.false).field("expression", Boolean, defaults2.false).field("defaults", [or(def("Expression"), null)], defaults2.emptyArray).field("rest", or(def("Identifier"), null), defaults2.null), def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field(
        "typeAnnotation",
        // for Babylon. Flow parser puts it on the identifier
        or(def("TypeAnnotation"), def("TSTypeAnnotation"), null),
        defaults2.null
      ), def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern")), def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or(def("Identifier"), null)), def("FunctionExpression").build("id", "params", "body", "generator", "expression"), def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults2.null).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", !1, defaults2.false), def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement")), def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults2.false), def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null)), def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null)), def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean), def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults2.false).field("shorthand", Boolean, defaults2.false).field("computed", Boolean, defaults2.false), def("ObjectProperty").field("shorthand", Boolean, defaults2.false), def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults2.false), def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]), def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]), def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression")), def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]), def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]), def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]), def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression")), def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults2.false).field("static", Boolean, defaults2.false);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("StaticBlock"));
      def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults2.false), def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement), def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]), def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults2.null), def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults2.null).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults2.null), def("Super").bases("Expression").build(), def("Specifier").bases("Node"), def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults2.null).field("id", or(def("Identifier"), null), defaults2.null).field("name", or(def("Identifier"), null), defaults2.null), def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier")), def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local"), def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local"), def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults2.emptyArray).field("source", def("Literal")).field("importKind", or("value", "type"), function() {
        return "value";
      }), def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2.null), def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier")), def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression"))), def("ExportAllDeclaration").bases("Declaration").build("source").field("source", def("Literal")), def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral")), def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]), def("TemplateElement").bases("Node").build("value", "tail").field("value", { cooked: String, raw: String }).field("tail", Boolean), def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es6, es6.exports)), es6.exports;
}
var hasRequiredEs2016;
function requireEs2016() {
  return hasRequiredEs2016 || (hasRequiredEs2016 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es2016_1 = tslib_12.__importDefault(requireEs2016$1()), es6_1 = tslib_12.__importDefault(requireEs6()), shared_1 = requireShared();
    function default_1(fork2) {
      fork2.use(es2016_1.default), fork2.use(es6_1.default);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2016, es2016.exports)), es2016.exports;
}
var hasRequiredEs2017;
function requireEs2017() {
  return hasRequiredEs2017 || (hasRequiredEs2017 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es2016_1 = tslib_12.__importDefault(requireEs2016()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2016_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, defaults2 = fork2.use(shared_1.default).defaults;
      def("Function").field("async", Boolean, defaults2.false), def("AwaitExpression").bases("Expression").build("argument").field("argument", def("Expression"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2017, es2017.exports)), es2017.exports;
}
var hasRequiredEs2018;
function requireEs2018() {
  return hasRequiredEs2018 || (hasRequiredEs2018 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es2017_1 = tslib_12.__importDefault(requireEs2017()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2017_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("ForOfStatement").field("await", Boolean, defaults2.false), def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression")), def("ObjectExpression").field("properties", [or(
        def("Property"),
        def("SpreadProperty"),
        // Legacy
        def("SpreadElement")
      )]), def("TemplateElement").field("value", { cooked: or(String, null), raw: String }), def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern")), def("ObjectPattern").field("properties", [or(def("PropertyPattern"), def("Property"), def("RestElement"), def("SpreadPropertyPattern"))]);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2018, es2018.exports)), es2018.exports;
}
var hasRequiredEs2019;
function requireEs2019() {
  return hasRequiredEs2019 || (hasRequiredEs2019 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es2018_1 = tslib_12.__importDefault(requireEs2018()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2018_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("CatchClause").field("param", or(def("Pattern"), null), defaults2.null);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2019, es2019.exports)), es2019.exports;
}
var hasRequiredEs2020;
function requireEs2020() {
  return hasRequiredEs2020 || (hasRequiredEs2020 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es2020_1 = tslib_12.__importDefault(requireEs2020$1()), es2019_1 = tslib_12.__importDefault(requireEs2019()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es2020_1.default), fork2.use(es2019_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, shared2 = fork2.use(shared_1.default), defaults2 = shared2.defaults;
      def("ImportExpression").bases("Expression").build("source").field("source", def("Expression")), def("ExportAllDeclaration").bases("Declaration").build("source", "exported").field("source", def("Literal")).field("exported", or(def("Identifier"), null, void 0), defaults2.null), def("ChainElement").bases("Node").field("optional", Boolean, defaults2.false), def("CallExpression").bases("Expression", "ChainElement"), def("MemberExpression").bases("Expression", "ChainElement"), def("ChainExpression").bases("Expression").build("expression").field("expression", def("ChainElement")), def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults2.true), def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults2.true);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2020, es2020.exports)), es2020.exports;
}
var hasRequiredEs2021;
function requireEs2021() {
  return hasRequiredEs2021 || (hasRequiredEs2021 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es2021_1 = tslib_12.__importDefault(requireEs2021$1()), es2020_1 = tslib_12.__importDefault(requireEs2020()), shared_1 = requireShared();
    function default_1(fork2) {
      fork2.use(es2021_1.default), fork2.use(es2020_1.default);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2021$1, es2021$1.exports)), es2021$1.exports;
}
var hasRequiredEs2022;
function requireEs2022() {
  return hasRequiredEs2022 || (hasRequiredEs2022 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es2021_1 = tslib_12.__importDefault(requireEs2021()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = requireShared();
    function default_1(fork2) {
      fork2.use(es2021_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def;
      def("StaticBlock").bases("Declaration").build("body").field("body", [def("Statement")]);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2022, es2022.exports)), es2022.exports;
}
var hasRequiredEsProposals;
function requireEsProposals() {
  return hasRequiredEsProposals || (hasRequiredEsProposals = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared()), es2022_1 = tslib_12.__importDefault(requireEs2022());
    function default_1(fork2) {
      fork2.use(es2022_1.default);
      var types2 = fork2.use(types_1.default), Type2 = types2.Type, def = types2.Type.def, or = Type2.or, shared2 = fork2.use(shared_1.default), defaults2 = shared2.defaults;
      def("AwaitExpression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults2.false), def("Decorator").bases("Node").build("expression").field("expression", def("Expression")), def("Property").field("decorators", or([def("Decorator")], null), defaults2.null), def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults2.null), def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier")), def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or(def("Expression"), null), defaults2.null), def("ImportAttribute").bases("Node").build("key", "value").field("key", or(def("Identifier"), def("Literal"))).field("value", def("Expression")), [
        "ImportDeclaration",
        "ExportAllDeclaration",
        "ExportNamedDeclaration"
      ].forEach(function(decl) {
        def(decl).field("assertions", [def("ImportAttribute")], defaults2.emptyArray);
      }), def("RecordExpression").bases("Expression").build("properties").field("properties", [or(def("ObjectProperty"), def("ObjectMethod"), def("SpreadElement"))]), def("TupleExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), def("SpreadElement"), null)]), def("ModuleExpression").bases("Node").build("body").field("body", def("Program"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(esProposals, esProposals.exports)), esProposals.exports;
}
var jsx = { exports: {} }, hasRequiredJsx;
function requireJsx() {
  return hasRequiredJsx || (hasRequiredJsx = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es_proposals_1 = tslib_12.__importDefault(requireEsProposals()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es_proposals_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(
        def("Literal"),
        // attr="value"
        def("JSXExpressionContainer"),
        // attr={value}
        def("JSXElement"),
        // attr=<div />
        def("JSXFragment"),
        // attr=<></>
        null
        // attr= or just attr
      ), defaults2.null), def("JSXIdentifier").bases("Identifier").build("name").field("name", String), def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier")), def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults2.false);
      var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
      def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
      var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
      def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", or(def("Expression"), def("JSXEmptyExpression")));
      var JSXChildren = [or(
        def("JSXText"),
        def("JSXExpressionContainer"),
        def("JSXSpreadChild"),
        def("JSXElement"),
        def("JSXFragment"),
        def("Literal")
        // Legacy: Esprima should return JSXText instead.
      )];
      def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults2.null).field("children", JSXChildren, defaults2.emptyArray).field("name", JSXElementName, function() {
        return this.openingElement.name;
      }, !0).field("selfClosing", Boolean, function() {
        return this.openingElement.selfClosing;
      }, !0).field("attributes", JSXAttributes, function() {
        return this.openingElement.attributes;
      }, !0), def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults2.emptyArray).field("selfClosing", Boolean, defaults2.false), def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName), def("JSXFragment").bases("Expression").build("openingFragment", "closingFragment", "children").field("openingFragment", def("JSXOpeningFragment")).field("closingFragment", def("JSXClosingFragment")).field("children", JSXChildren, defaults2.emptyArray), def("JSXOpeningFragment").bases("Node").build(), def("JSXClosingFragment").bases("Node").build(), def("JSXText").bases("Literal").build("value", "raw").field("value", String).field("raw", String, function() {
        return this.value;
      }), def("JSXEmptyExpression").bases("Node").build(), def("JSXSpreadChild").bases("Node").build("expression").field("expression", def("Expression"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(jsx, jsx.exports)), jsx.exports;
}
var flow = { exports: {} }, typeAnnotations = { exports: {} }, hasRequiredTypeAnnotations;
function requireTypeAnnotations() {
  return hasRequiredTypeAnnotations || (hasRequiredTypeAnnotations = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults, TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null), TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
      def("Identifier").field("typeAnnotation", TypeAnnotation, defaults2.null), def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults2.null), def("Function").field("returnType", TypeAnnotation, defaults2.null).field("typeParameters", TypeParamDecl, defaults2.null), def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("static", Boolean, defaults2.false).field("typeAnnotation", TypeAnnotation, defaults2.null), [
        "ClassDeclaration",
        "ClassExpression"
      ].forEach(function(typeName) {
        def(typeName).field("typeParameters", TypeParamDecl, defaults2.null).field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults2.null).field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults2.emptyArray);
      });
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(typeAnnotations, typeAnnotations.exports)), typeAnnotations.exports;
}
var hasRequiredFlow;
function requireFlow() {
  return hasRequiredFlow || (hasRequiredFlow = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es_proposals_1 = tslib_12.__importDefault(requireEsProposals()), type_annotations_1 = tslib_12.__importDefault(requireTypeAnnotations()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es_proposals_1.default), fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("Flow").bases("Node"), def("FlowType").bases("Flow"), def("AnyTypeAnnotation").bases("FlowType").build(), def("EmptyTypeAnnotation").bases("FlowType").build(), def("MixedTypeAnnotation").bases("FlowType").build(), def("VoidTypeAnnotation").bases("FlowType").build(), def("SymbolTypeAnnotation").bases("FlowType").build(), def("NumberTypeAnnotation").bases("FlowType").build(), def("BigIntTypeAnnotation").bases("FlowType").build(), def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String), def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String), def("BigIntLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", null).field("raw", String), def("StringTypeAnnotation").bases("FlowType").build(), def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String), def("BooleanTypeAnnotation").bases("FlowType").build(), def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String), def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType")), def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType")), def("NullLiteralTypeAnnotation").bases("FlowType").build(), def("NullTypeAnnotation").bases("FlowType").build(), def("ThisTypeAnnotation").bases("FlowType").build(), def("ExistsTypeAnnotation").bases("FlowType").build(), def("ExistentialTypeParam").bases("FlowType").build(), def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null)), def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", or(def("Identifier"), null)).field("typeAnnotation", def("FlowType")).field("optional", Boolean), def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType")), def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [
        or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))
      ]).field("indexers", [def("ObjectTypeIndexer")], defaults2.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults2.emptyArray).field("inexact", or(Boolean, void 0), defaults2.undefined).field("exact", Boolean, defaults2.false).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults2.emptyArray), def("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
      var LegacyVariance = or(def("Variance"), "plus", "minus", null);
      def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults2.null), def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults2.null).field("static", Boolean, defaults2.false), def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults2.false), def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier")), def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null)), def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation"))), def("IndexedAccessType").bases("FlowType").build("objectType", "indexType").field("objectType", def("FlowType")).field("indexType", def("FlowType")), def("OptionalIndexedAccessType").bases("FlowType").build("objectType", "indexType", "optional").field("objectType", def("FlowType")).field("indexType", def("FlowType")).field("optional", Boolean), def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]), def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]), def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType")), def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType")), def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean), def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]), def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]), def("TypeParameter").bases("FlowType").build("name", "variance", "bound", "default").field("name", String).field("variance", LegacyVariance, defaults2.null).field("bound", or(def("TypeAnnotation"), null), defaults2.null).field("default", or(def("FlowType"), null), defaults2.null), def("ClassProperty").field("variance", LegacyVariance, defaults2.null), def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults2.null).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults2.null), def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or([def("InterfaceExtends")], null), defaults2.null), def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults2.null).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]), def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends"), def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults2.null), def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("FlowType")), def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right"), def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", or(def("FlowType"), null)), def("DeclareOpaqueType").bases("OpaqueType").build("id", "typeParameters", "supertype").field("impltype", or(def("FlowType"), null)), def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation")), def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]), def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier")), def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier")).field("predicate", or(def("FlowPredicate"), null), defaults2.null), def("DeclareClass").bases("InterfaceDeclaration").build("id"), def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement")), def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation")), def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("FlowType"),
        // Implies default.
        def("TypeAlias"),
        // Implies named type
        def("DeclareOpaqueType"),
        // Implies named opaque type
        def("InterfaceDeclaration"),
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2.null), def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def("Literal"), null), defaults2.null), def("ImportDeclaration").field("importKind", or("value", "type", "typeof"), function() {
        return "value";
      }), def("FlowPredicate").bases("Flow"), def("InferredPredicate").bases("FlowPredicate").build(), def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression")), def("Function").field("predicate", or(def("FlowPredicate"), null), defaults2.null), def("CallExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults2.null), def("NewExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults2.null), def("EnumDeclaration").bases("Declaration").build("id", "body").field("id", def("Identifier")).field("body", or(def("EnumBooleanBody"), def("EnumNumberBody"), def("EnumStringBody"), def("EnumSymbolBody"))), def("EnumBooleanBody").build("members", "explicitType").field("members", [def("EnumBooleanMember")]).field("explicitType", Boolean), def("EnumNumberBody").build("members", "explicitType").field("members", [def("EnumNumberMember")]).field("explicitType", Boolean), def("EnumStringBody").build("members", "explicitType").field("members", or([def("EnumStringMember")], [def("EnumDefaultedMember")])).field("explicitType", Boolean), def("EnumSymbolBody").build("members").field("members", [def("EnumDefaultedMember")]), def("EnumBooleanMember").build("id", "init").field("id", def("Identifier")).field("init", or(def("Literal"), Boolean)), def("EnumNumberMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal")), def("EnumStringMember").build("id", "init").field("id", def("Identifier")).field("init", def("Literal")), def("EnumDefaultedMember").build("id").field("id", def("Identifier"));
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(flow, flow.exports)), flow.exports;
}
var esprima$2 = { exports: {} }, hasRequiredEsprima$2;
function requireEsprima$2() {
  return hasRequiredEsprima$2 || (hasRequiredEsprima$2 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es_proposals_1 = tslib_12.__importDefault(requireEsProposals()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(es_proposals_1.default);
      var types2 = fork2.use(types_1.default), defaults2 = fork2.use(shared_1.default).defaults, def = types2.Type.def, or = types2.Type.or;
      def("VariableDeclaration").field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier")
        // Esprima deviation.
      )]), def("Property").field("value", or(
        def("Expression"),
        def("Pattern")
        // Esprima deviation.
      )), def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]), def("ObjectPattern").field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty")
        // Used by Esprima.
      )]), def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name"), def("ExportBatchSpecifier").bases("Specifier").build(), def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("Declaration"),
        def("Expression"),
        // Implies default.
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2.null), def("Block").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), def("Line").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(esprima$2, esprima$2.exports)), esprima$2.exports;
}
var babel$1 = { exports: {} }, babelCore = { exports: {} }, hasRequiredBabelCore;
function requireBabelCore() {
  return hasRequiredBabelCore || (hasRequiredBabelCore = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, es_proposals_1 = tslib_12.__importDefault(requireEsProposals()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      var _a, _b, _c, _d, _e;
      fork2.use(es_proposals_1.default);
      var types2 = fork2.use(types_1.default), defaults2 = fork2.use(shared_1.default).defaults, def = types2.Type.def, or = types2.Type.or, isUndefined2 = types2.builtInTypes.undefined;
      def("Noop").bases("Statement").build(), def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]), def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression")), def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression")), def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier")), def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier")), def("CommentBlock").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), def("CommentLine").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      ), def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral")), def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults2["use strict"]), def("InterpreterDirective").bases("Node").build("value").field("value", String), def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults2.emptyArray), def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults2.emptyArray).field("interpreter", or(def("InterpreterDirective"), null), defaults2.null);
      function makeLiteralExtra(rawValueType, toRaw) {
        return rawValueType === void 0 && (rawValueType = String), [
          "extra",
          {
            rawValue: rawValueType,
            raw: String
          },
          function() {
            var value = types2.getFieldValue(this, "value");
            return {
              rawValue: value,
              raw: toRaw ? toRaw(value) : String(value)
            };
          }
        ];
      }
      (_a = def("StringLiteral").bases("Literal").build("value").field("value", String)).field.apply(_a, makeLiteralExtra(String, function(val) {
        return JSON.stringify(val);
      })), (_b = def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults2.null)).field.apply(_b, makeLiteralExtra(Number)), (_c = def("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number))).field.apply(_c, makeLiteralExtra(String, function(val) {
        return val + "n";
      })), (_d = def("DecimalLiteral").bases("Literal").build("value").field("value", String)).field.apply(_d, makeLiteralExtra(String, function(val) {
        return val + "m";
      })), def("NullLiteral").bases("Literal").build().field("value", null, defaults2.null), def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean), (_e = def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
        return new RegExp(this.pattern, this.flags);
      })).field.apply(_e, makeLiteralExtra(or(RegExp, isUndefined2), function(exp) {
        return "/".concat(exp.pattern, "/").concat(exp.flags || "");
      })).field("regex", {
        pattern: String,
        flags: String
      }, function() {
        return {
          pattern: this.pattern,
          flags: this.flags
        };
      });
      var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]), def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults2.false).field("generator", Boolean, defaults2.false).field("async", Boolean, defaults2.false).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults2.null
      ).field("decorators", or([def("Decorator")], null), defaults2.null), def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults2.null
      ).field("computed", Boolean, defaults2.false);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"), def("ClassAccessorProperty"), def("StaticBlock"));
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]), def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("Expression"))), def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName")), def("ClassAccessorProperty").bases("Declaration").build("key", "value", "decorators", "computed", "static").field("key", or(
        def("Literal"),
        def("Identifier"),
        def("PrivateName"),
        // Only when .computed is true (TODO enforce this)
        def("Expression")
      )).field("value", or(def("Expression"), null), defaults2.null), [
        "ClassMethod",
        "ClassPrivateMethod"
      ].forEach(function(typeName) {
        def(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
          return "method";
        }).field("body", def("BlockStatement")).field("access", or("public", "private", "protected", null), defaults2.null);
      }), [
        "ClassMethod",
        "ClassPrivateMethod",
        "ClassAccessorProperty"
      ].forEach(function(typeName) {
        def(typeName).field("computed", Boolean, defaults2.false).field("static", Boolean, defaults2.false).field("abstract", Boolean, defaults2.false).field("accessibility", or("public", "private", "protected", null), defaults2.null).field("decorators", or([def("Decorator")], null), defaults2.null).field("definite", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("override", Boolean, defaults2.false).field("readonly", Boolean, defaults2.false);
      });
      var ObjectPatternProperty = or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty"),
        // Used by Esprima
        def("ObjectProperty"),
        // Babel 6
        def("RestProperty"),
        // Babel 6
        def("RestElement")
      );
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults2.null), def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression")), def("RestProperty").bases("Node").build("argument").field("argument", def("Expression")), def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement")), def("Import").bases("Expression").build();
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(babelCore, babelCore.exports)), babelCore.exports;
}
var hasRequiredBabel;
function requireBabel() {
  return hasRequiredBabel || (hasRequiredBabel = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, types_1 = tslib_12.__importDefault(requireTypes()), babel_core_1 = tslib_12.__importDefault(requireBabelCore()), flow_1 = tslib_12.__importDefault(requireFlow()), shared_1 = requireShared();
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), def = types2.Type.def;
      fork2.use(babel_core_1.default), fork2.use(flow_1.default), def("V8IntrinsicIdentifier").bases("Expression").build("name").field("name", String), def("TopicReference").bases("Expression").build();
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(babel$1, babel$1.exports)), babel$1.exports;
}
var typescript$1 = { exports: {} }, hasRequiredTypescript;
function requireTypescript() {
  return hasRequiredTypescript || (hasRequiredTypescript = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_12 = require$$0$3, babel_core_1 = tslib_12.__importDefault(requireBabelCore()), type_annotations_1 = tslib_12.__importDefault(requireTypeAnnotations()), types_1 = tslib_12.__importDefault(requireTypes()), shared_1 = tslib_12.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(babel_core_1.default), fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default), n = types2.namedTypes, def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults, StringLiteral = types2.Type.from(function(value, deep) {
        return !!(n.StringLiteral && n.StringLiteral.check(value, deep) || n.Literal && n.Literal.check(value, deep) && typeof value.value == "string");
      }, "StringLiteral");
      def("TSType").bases("Node");
      var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
      def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName), def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults2.null), def("TSHasOptionalTypeParameters").field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults2.null), def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults2.null), def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName), def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults2.null), def("TSTypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")), def("TSSatisfiesExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")), def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression")), [
        "TSAnyKeyword",
        "TSBigIntKeyword",
        "TSBooleanKeyword",
        "TSNeverKeyword",
        "TSNullKeyword",
        "TSNumberKeyword",
        "TSObjectKeyword",
        "TSStringKeyword",
        "TSSymbolKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword",
        "TSVoidKeyword",
        "TSIntrinsicKeyword",
        "TSThisType"
      ].forEach(function(keywordType) {
        def(keywordType).bases("TSType").build();
      }), def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType")), def("TSLiteralType").bases("TSType").build("literal").field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression"), def("BigIntLiteral"))), def("TemplateLiteral").field("expressions", or([def("Expression")], [def("TSType")])), [
        "TSUnionType",
        "TSIntersectionType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
      }), def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType")), def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter")), def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
      [
        "TSFunctionType",
        "TSConstructorType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
      }), def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults2.false).field("async", Boolean, defaults2.false).field("generator", Boolean, defaults2.false).field("id", or(def("Identifier"), null), defaults2.null).field("params", [def("Pattern")]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults2.null), def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults2.false).field("generator", Boolean, defaults2.false).field("params", [def("Pattern")]).field("abstract", Boolean, defaults2.false).field("accessibility", or("public", "private", "protected", void 0), defaults2.undefined).field("static", Boolean, defaults2.false).field("computed", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("key", or(
        def("Identifier"),
        def("StringLiteral"),
        def("NumericLiteral"),
        // Only allowed if .computed is true.
        def("Expression")
      )).field("kind", or("get", "set", "method", "constructor"), function() {
        return "method";
      }).field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults2.undefined
      ).field("decorators", or([def("Decorator")], null), defaults2.null).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults2.null), def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults2.false).field("typeParameter", def("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults2.false).field("typeAnnotation", or(def("TSType"), null), defaults2.null), def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]), def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults2.false).field("elementType", def("TSType")), def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType")), def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType")), def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType")), def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType")), def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation"))), def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults2.false), def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults2.false).field("readonly", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("initializer", or(def("Expression"), null), defaults2.null), def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults2.false).field("optional", Boolean, defaults2.false).field("parameters", ParametersType), def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults2.null).field("asserts", Boolean, defaults2.false), [
        "TSCallSignatureDeclaration",
        "TSConstructSignatureDeclaration"
      ].forEach(function(typeName) {
        def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
      }), def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def("Identifier"), StringLiteral)).field("initializer", or(def("Expression"), null), defaults2.null), def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def("TSImportType")));
      var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
      def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]), def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", or(def("Identifier"), String)).field("constraint", or(def("TSType"), void 0), defaults2.undefined).field("default", or(def("TSType"), void 0), defaults2.undefined), def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults2.null), def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]), def("TSInstantiationExpression").bases("Expression", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", def("Expression")), def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]), def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults2.false).field("declare", Boolean, defaults2.false).field("members", [def("TSEnumMember")]).field("initializer", or(def("Expression"), null), defaults2.null), def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults2.false).field("typeAnnotation", def("TSType")), def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]), def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults2.false).field("global", Boolean, defaults2.false).field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults2.null), def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults2.undefined), def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults2.false).field("moduleReference", or(TSEntityName, def("TSExternalModuleReference"))), def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral), def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression")), def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier")), def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]), def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName), def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults2.false).field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults2.null).field("body", def("TSInterfaceBody")), def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults2.undefined).field("readonly", Boolean, defaults2.false).field("parameter", or(def("Identifier"), def("AssignmentPattern"))), def("ClassProperty").field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults2.undefined
      ), def("ClassAccessorProperty").bases("Declaration", "TSHasOptionalTypeAnnotation"), def("ClassBody").field("body", [or(
        def("MethodDefinition"),
        def("VariableDeclarator"),
        def("ClassPropertyDefinition"),
        def("ClassProperty"),
        def("ClassPrivateProperty"),
        def("ClassAccessorProperty"),
        def("ClassMethod"),
        def("ClassPrivateMethod"),
        def("StaticBlock"),
        // Just need to add these types:
        def("TSDeclareMethod"),
        TSTypeMember
      )]);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(typescript$1, typescript$1.exports)), typescript$1.exports;
}
var namedTypes = {}, hasRequiredNamedTypes;
function requireNamedTypes() {
  return hasRequiredNamedTypes || (hasRequiredNamedTypes = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.namedTypes = void 0, exports2.namedTypes || (exports2.namedTypes = {});
  }(namedTypes)), namedTypes;
}
var hasRequiredMain$1;
function requireMain$1() {
  return hasRequiredMain$1 || (hasRequiredMain$1 = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.visit = exports2.use = exports2.Type = exports2.someField = exports2.PathVisitor = exports2.Path = exports2.NodePath = exports2.namedTypes = exports2.getSupertypeNames = exports2.getFieldValue = exports2.getFieldNames = exports2.getBuilderName = exports2.finalize = exports2.eachField = exports2.defineMethod = exports2.builtInTypes = exports2.builders = exports2.astNodesAreEquivalent = void 0;
    var tslib_12 = require$$0$3, fork_1 = tslib_12.__importDefault(requireFork()), es_proposals_1 = tslib_12.__importDefault(requireEsProposals()), jsx_1 = tslib_12.__importDefault(requireJsx()), flow_1 = tslib_12.__importDefault(requireFlow()), esprima_1 = tslib_12.__importDefault(requireEsprima$2()), babel_12 = tslib_12.__importDefault(requireBabel()), typescript_1 = tslib_12.__importDefault(requireTypescript()), namedTypes_1 = requireNamedTypes();
    Object.defineProperty(exports2, "namedTypes", { enumerable: !0, get: function() {
      return namedTypes_1.namedTypes;
    } });
    var _a = (0, fork_1.default)([
      // Feel free to add to or remove from this list of extension modules to
      // configure the precise type hierarchy that you need.
      es_proposals_1.default,
      jsx_1.default,
      flow_1.default,
      esprima_1.default,
      babel_12.default,
      typescript_1.default
    ]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize2 = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n = _a.namedTypes, NodePath = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type2 = _a.Type, use = _a.use, visit = _a.visit;
    exports2.astNodesAreEquivalent = astNodesAreEquivalent, exports2.builders = builders, exports2.builtInTypes = builtInTypes, exports2.defineMethod = defineMethod, exports2.eachField = eachField, exports2.finalize = finalize2, exports2.getBuilderName = getBuilderName, exports2.getFieldNames = getFieldNames, exports2.getFieldValue = getFieldValue, exports2.getSupertypeNames = getSupertypeNames, exports2.NodePath = NodePath, exports2.Path = Path, exports2.PathVisitor = PathVisitor, exports2.someField = someField, exports2.Type = Type2, exports2.use = use, exports2.visit = visit, Object.assign(namedTypes_1.namedTypes, n);
  }(main$3)), main$3;
}
var parser$1 = {}, tinyInvariant_cjs, hasRequiredTinyInvariant_cjs;
function requireTinyInvariant_cjs() {
  if (hasRequiredTinyInvariant_cjs) return tinyInvariant_cjs;
  hasRequiredTinyInvariant_cjs = 1;
  var isProduction = process.env.NODE_ENV === "production", prefix = "Invariant failed";
  function invariant(condition, message) {
    if (!condition) {
      if (isProduction)
        throw new Error(prefix);
      var provided = typeof message == "function" ? message() : message, value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
    }
  }
  return tinyInvariant_cjs = invariant, tinyInvariant_cjs;
}
var options$1 = {}, util$1 = {}, sourceMap = {}, sourceMapGenerator = {}, base64Vlq = {}, base64 = {}, hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return base64.encode = function(number2) {
    if (0 <= number2 && number2 < intToCharMap.length)
      return intToCharMap[number2];
    throw new TypeError("Must be between 0 and 63: " + number2);
  }, base64.decode = function(charCode) {
    var bigA = 65, bigZ = 90, littleA = 97, littleZ = 122, zero = 48, nine = 57, plus = 43, slash = 47, littleOffset = 26, numberOffset = 52;
    return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
  }, base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base642 = requireBase64(), VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1, shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  return base64Vlq.encode = function(aValue) {
    var encoded = "", digit, vlq = toVLQSigned(aValue);
    do
      digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base642.encode(digit);
    while (vlq > 0);
    return encoded;
  }, base64Vlq.decode = function(aStr, aIndex, aOutParam) {
    var strLen = aStr.length, result = 0, shift = 0, continuation, digit;
    do {
      if (aIndex >= strLen)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (digit = base642.decode(aStr.charCodeAt(aIndex++)), digit === -1)
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift), shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
  }, base64Vlq;
}
var util = {}, hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs)
        return aArgs[aName];
      if (arguments.length === 3)
        return aDefaultValue;
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match3 = aUrl.match(urlRegexp);
      return match3 ? {
        scheme: match3[1],
        auth: match3[2],
        host: match3[3],
        port: match3[4],
        path: match3[5]
      } : null;
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      return aParsedUrl.scheme && (url2 += aParsedUrl.scheme + ":"), url2 += "//", aParsedUrl.auth && (url2 += aParsedUrl.auth + "@"), aParsedUrl.host && (url2 += aParsedUrl.host), aParsedUrl.port && (url2 += ":" + aParsedUrl.port), aParsedUrl.path && (url2 += aParsedUrl.path), url2;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize2(aPath) {
      var path2 = aPath, url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path)
          return aPath;
        path2 = url2.path;
      }
      for (var isAbsolute2 = exports2.isAbsolute(path2), parts = path2.split(/\/+/), part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--)
        part = parts[i2], part === "." ? parts.splice(i2, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i2 + 1, up), up = 0) : (parts.splice(i2, 2), up--));
      return path2 = parts.join("/"), path2 === "" && (path2 = isAbsolute2 ? "/" : "."), url2 ? (url2.path = path2, urlGenerate(url2)) : path2;
    }
    exports2.normalize = normalize2;
    function join2(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
      var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
      if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
        return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
      if (aPathUrl || aPath.match(dataUrlRegexp))
        return aPath;
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
        return aRootUrl.host = aPath, urlGenerate(aRootUrl);
      var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
      return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
    }
    exports2.join = join2, exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
      for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0 || (aRoot = aRoot.slice(0, index), aRoot.match(/^([^\/]+:\/)?\/*$/)))
          return aPath;
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity2(s) {
      return s;
    }
    function toSetString(aStr) {
      return isProtoString(aStr) ? "$" + aStr : aStr;
    }
    exports2.toSetString = supportsNullProto ? identity2 : toSetString;
    function fromSetString(aStr) {
      return isProtoString(aStr) ? aStr.slice(1) : aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity2 : fromSetString;
    function isProtoString(s) {
      if (!s)
        return !1;
      var length = s.length;
      if (length < 9 || s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95)
        return !1;
      for (var i2 = length - 10; i2 >= 0; i2--)
        if (s.charCodeAt(i2) !== 36)
          return !1;
      return !0;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp2 = strcmp(mappingA.source, mappingB.source);
      return cmp2 !== 0 || (cmp2 = mappingA.originalLine - mappingB.originalLine, cmp2 !== 0) || (cmp2 = mappingA.originalColumn - mappingB.originalColumn, cmp2 !== 0 || onlyCompareOriginal) || (cmp2 = mappingA.generatedColumn - mappingB.generatedColumn, cmp2 !== 0) || (cmp2 = mappingA.generatedLine - mappingB.generatedLine, cmp2 !== 0) ? cmp2 : strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      return cmp2 !== 0 || (cmp2 = mappingA.generatedColumn - mappingB.generatedColumn, cmp2 !== 0 || onlyCompareGenerated) || (cmp2 = strcmp(mappingA.source, mappingB.source), cmp2 !== 0) || (cmp2 = mappingA.originalLine - mappingB.originalLine, cmp2 !== 0) || (cmp2 = mappingA.originalColumn - mappingB.originalColumn, cmp2 !== 0) ? cmp2 : strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      return cmp2 !== 0 || (cmp2 = mappingA.generatedColumn - mappingB.generatedColumn, cmp2 !== 0) || (cmp2 = strcmp(mappingA.source, mappingB.source), cmp2 !== 0) || (cmp2 = mappingA.originalLine - mappingB.originalLine, cmp2 !== 0) || (cmp2 = mappingA.originalColumn - mappingB.originalColumn, cmp2 !== 0) ? cmp2 : strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str2) {
      return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed)
          throw new Error("sourceMapURL could not be parsed");
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          index >= 0 && (parsed.path = parsed.path.substring(0, index + 1));
        }
        sourceURL = join2(urlGenerate(parsed), sourceURL);
      }
      return normalize2(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }(util)), util;
}
var arraySet = {}, hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  var util2 = requireUtil$1(), has = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map < "u";
  function ArraySet() {
    this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return ArraySet.fromArray = function(aArray, aAllowDuplicates) {
    for (var set2 = new ArraySet(), i2 = 0, len = aArray.length; i2 < len; i2++)
      set2.add(aArray[i2], aAllowDuplicates);
    return set2;
  }, ArraySet.prototype.size = function() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util2.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr), idx = this._array.length;
    (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
  }, ArraySet.prototype.has = function(aStr) {
    if (hasNativeMap)
      return this._set.has(aStr);
    var sStr = util2.toSetString(aStr);
    return has.call(this._set, sStr);
  }, ArraySet.prototype.indexOf = function(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0)
        return idx;
    } else {
      var sStr = util2.toSetString(aStr);
      if (has.call(this._set, sStr))
        return this._set[sStr];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  }, ArraySet.prototype.at = function(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length)
      return this._array[aIdx];
    throw new Error("No element indexed by " + aIdx);
  }, ArraySet.prototype.toArray = function() {
    return this._array.slice();
  }, arraySet.ArraySet = ArraySet, arraySet;
}
var mappingList = {}, hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  var util2 = requireUtil$1();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  }, MappingList.prototype.add = function(aMapping) {
    generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
  }, MappingList.prototype.toArray = function() {
    return this._sorted || (this._array.sort(util2.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, mappingList.MappingList = MappingList, mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq(), util2 = requireUtil$1(), ArraySet = requireArraySet().ArraySet, MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    aArgs || (aArgs = {}), this._file = util2.getArg(aArgs, "file", null), this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null), this._skipValidation = util2.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
  }
  return SourceMapGenerator.prototype._version = 3, SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    return aSourceMapConsumer.eachMapping(function(mapping2) {
      var newMapping = {
        generated: {
          line: mapping2.generatedLine,
          column: mapping2.generatedColumn
        }
      };
      mapping2.source != null && (newMapping.source = mapping2.source, sourceRoot != null && (newMapping.source = util2.relative(sourceRoot, newMapping.source)), newMapping.original = {
        line: mapping2.originalLine,
        column: mapping2.originalColumn
      }, mapping2.name != null && (newMapping.name = mapping2.name)), generator.addMapping(newMapping);
    }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      sourceRoot !== null && (sourceRelative = util2.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && generator.setSourceContent(sourceFile, content);
    }), generator;
  }, SourceMapGenerator.prototype.addMapping = function(aArgs) {
    var generated = util2.getArg(aArgs, "generated"), original = util2.getArg(aArgs, "original", null), source2 = util2.getArg(aArgs, "source", null), name = util2.getArg(aArgs, "name", null);
    this._skipValidation || this._validateMapping(generated, original, source2, name), source2 != null && (source2 = String(source2), this._sources.has(source2) || this._sources.add(source2)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source2,
      name
    });
  }, SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
    var source2 = aSourceFile;
    this._sourceRoot != null && (source2 = util2.relative(this._sourceRoot, source2)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util2.toSetString(source2)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util2.toSetString(source2)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    sourceRoot != null && (sourceFile = util2.relative(sourceRoot, sourceFile));
    var newSources = new ArraySet(), newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping2) {
      if (mapping2.source === sourceFile && mapping2.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping2.originalLine,
          column: mapping2.originalColumn
        });
        original.source != null && (mapping2.source = original.source, aSourceMapPath != null && (mapping2.source = util2.join(aSourceMapPath, mapping2.source)), sourceRoot != null && (mapping2.source = util2.relative(sourceRoot, mapping2.source)), mapping2.originalLine = original.line, mapping2.originalColumn = original.column, original.name != null && (mapping2.name = original.name));
      }
      var source2 = mapping2.source;
      source2 != null && !newSources.has(source2) && newSources.add(source2);
      var name = mapping2.name;
      name != null && !newNames.has(name) && newNames.add(name);
    }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      content != null && (aSourceMapPath != null && (sourceFile2 = util2.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util2.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
    }, this);
  }, SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  }, SourceMapGenerator.prototype._serializeMappings = function() {
    for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping2, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i2 = 0, len = mappings.length; i2 < len; i2++) {
      if (mapping2 = mappings[i2], next = "", mapping2.generatedLine !== previousGeneratedLine)
        for (previousGeneratedColumn = 0; mapping2.generatedLine !== previousGeneratedLine; )
          next += ";", previousGeneratedLine++;
      else if (i2 > 0) {
        if (!util2.compareByGeneratedPositionsInflated(mapping2, mappings[i2 - 1]))
          continue;
        next += ",";
      }
      next += base64VLQ.encode(mapping2.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping2.generatedColumn, mapping2.source != null && (sourceIdx = this._sources.indexOf(mapping2.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping2.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping2.originalLine - 1, next += base64VLQ.encode(mapping2.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping2.originalColumn, mapping2.name != null && (nameIdx = this._names.indexOf(mapping2.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
    }
    return result;
  }, SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
    return aSources.map(function(source2) {
      if (!this._sourcesContents)
        return null;
      aSourceRoot != null && (source2 = util2.relative(aSourceRoot, source2));
      var key2 = util2.toSetString(source2);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key2) ? this._sourcesContents[key2] : null;
    }, this);
  }, SourceMapGenerator.prototype.toJSON = function() {
    var map2 = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (map2.file = this._file), this._sourceRoot != null && (map2.sourceRoot = this._sourceRoot), this._sourcesContents && (map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot)), map2;
  }, SourceMapGenerator.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, sourceMapGenerator.SourceMapGenerator = SourceMapGenerator, sourceMapGenerator;
}
var sourceMapConsumer = {}, binarySearch = {}, hasRequiredBinarySearch;
function requireBinarySearch() {
  return hasRequiredBinarySearch || (hasRequiredBinarySearch = 1, function(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1, exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp2 = aCompare(aNeedle, aHaystack[mid], !0);
      return cmp2 === 0 ? mid : cmp2 > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
    }
    exports2.search = function(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0)
        return -1;
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0)
        return -1;
      for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], !0) === 0; )
        --index;
      return index;
    };
  }(binarySearch)), binarySearch;
}
var quickSort = {}, hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y], ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r), i2 = p - 1;
      swap(ary, pivotIndex, r);
      for (var pivot = ary[r], j = p; j < r; j++)
        comparator(ary[j], pivot) <= 0 && (i2 += 1, swap(ary, i2, j));
      swap(ary, i2 + 1, j);
      var q = i2 + 1;
      doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
    }
  }
  return quickSort.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  }, quickSort;
}
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  var util2 = requireUtil$1(), binarySearch2 = requireBinarySearch(), ArraySet = requireArraySet().ArraySet, base64VLQ = requireBase64Vlq(), quickSort2 = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    return typeof aSourceMap == "string" && (sourceMap2 = util2.parseSourceMapInput(aSourceMap)), sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  }, SourceMapConsumer.prototype._version = 3, SourceMapConsumer.prototype.__generatedMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), SourceMapConsumer.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
    var c2 = aStr.charAt(index);
    return c2 === ";" || c2 === ",";
  }, SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  }, SourceMapConsumer.GENERATED_ORDER = 1, SourceMapConsumer.ORIGINAL_ORDER = 2, SourceMapConsumer.GREATEST_LOWER_BOUND = 1, SourceMapConsumer.LEAST_UPPER_BOUND = 2, SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
    var context = aContext || null, order = aOrder || SourceMapConsumer.GENERATED_ORDER, mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping2) {
      var source2 = mapping2.source === null ? null : this._sources.at(mapping2.source);
      return source2 = util2.computeSourceURL(sourceRoot, source2, this._sourceMapURL), {
        source: source2,
        generatedLine: mapping2.generatedLine,
        generatedColumn: mapping2.generatedColumn,
        originalLine: mapping2.originalLine,
        originalColumn: mapping2.originalColumn,
        name: mapping2.name === null ? null : this._names.at(mapping2.name)
      };
    }, this).forEach(aCallback, context);
  }, SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
    var line3 = util2.getArg(aArgs, "line"), needle = {
      source: util2.getArg(aArgs, "source"),
      originalLine: line3,
      originalColumn: util2.getArg(aArgs, "column", 0)
    };
    if (needle.source = this._findSourceIndex(needle.source), needle.source < 0)
      return [];
    var mappings = [], index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      binarySearch2.LEAST_UPPER_BOUND
    );
    if (index >= 0) {
      var mapping2 = this._originalMappings[index];
      if (aArgs.column === void 0)
        for (var originalLine = mapping2.originalLine; mapping2 && mapping2.originalLine === originalLine; )
          mappings.push({
            line: util2.getArg(mapping2, "generatedLine", null),
            column: util2.getArg(mapping2, "generatedColumn", null),
            lastColumn: util2.getArg(mapping2, "lastGeneratedColumn", null)
          }), mapping2 = this._originalMappings[++index];
      else
        for (var originalColumn = mapping2.originalColumn; mapping2 && mapping2.originalLine === line3 && mapping2.originalColumn == originalColumn; )
          mappings.push({
            line: util2.getArg(mapping2, "generatedLine", null),
            column: util2.getArg(mapping2, "generatedColumn", null),
            lastColumn: util2.getArg(mapping2, "lastGeneratedColumn", null)
          }), mapping2 = this._originalMappings[++index];
    }
    return mappings;
  }, sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    typeof aSourceMap == "string" && (sourceMap2 = util2.parseSourceMapInput(aSourceMap));
    var version = util2.getArg(sourceMap2, "version"), sources = util2.getArg(sourceMap2, "sources"), names2 = util2.getArg(sourceMap2, "names", []), sourceRoot = util2.getArg(sourceMap2, "sourceRoot", null), sourcesContent = util2.getArg(sourceMap2, "sourcesContent", null), mappings = util2.getArg(sourceMap2, "mappings"), file2 = util2.getArg(sourceMap2, "file", null);
    if (version != this._version)
      throw new Error("Unsupported version: " + version);
    sourceRoot && (sourceRoot = util2.normalize(sourceRoot)), sources = sources.map(String).map(util2.normalize).map(function(source2) {
      return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source2) ? util2.relative(sourceRoot, source2) : source2;
    }), this._names = ArraySet.fromArray(names2.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), this._absoluteSources = this._sources.toArray().map(function(s) {
      return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
    }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file2;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer, BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null && (relativeSource = util2.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource))
      return this._sources.indexOf(relativeSource);
    var i2;
    for (i2 = 0; i2 < this._absoluteSources.length; ++i2)
      if (this._absoluteSources[i2] == aSource)
        return i2;
    return -1;
  }, BasicSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype), names2 = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
    smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(
      smc._sources.toArray(),
      smc.sourceRoot
    ), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
      var srcMapping = generatedMappings[i2], destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names2.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
    }
    return quickSort2(smc.__originalMappings, util2.compareByOriginalPositions), smc;
  }, BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping2, str2, segment, end2, value; index < length; )
      if (aStr.charAt(index) === ";")
        generatedLine++, index++, previousGeneratedColumn = 0;
      else if (aStr.charAt(index) === ",")
        index++;
      else {
        for (mapping2 = new Mapping(), mapping2.generatedLine = generatedLine, end2 = index; end2 < length && !this._charIsMappingSeparator(aStr, end2); end2++)
          ;
        if (str2 = aStr.slice(index, end2), segment = cachedSegments[str2], segment)
          index += str2.length;
        else {
          for (segment = []; index < end2; )
            base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
          if (segment.length === 2)
            throw new Error("Found a source, but no line and column");
          if (segment.length === 3)
            throw new Error("Found a source and line, but no column");
          cachedSegments[str2] = segment;
        }
        mapping2.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping2.generatedColumn, segment.length > 1 && (mapping2.source = previousSource + segment[1], previousSource += segment[1], mapping2.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping2.originalLine, mapping2.originalLine += 1, mapping2.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping2.originalColumn, segment.length > 4 && (mapping2.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping2), typeof mapping2.originalLine == "number" && originalMappings.push(mapping2);
      }
    quickSort2(generatedMappings, util2.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort2(originalMappings, util2.compareByOriginalPositions), this.__originalMappings = originalMappings;
  }, BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    if (aNeedle[aColumnName] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
  }, BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping2 = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping2.generatedLine === nextMapping.generatedLine) {
          mapping2.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping2.lastGeneratedColumn = 1 / 0;
    }
  }, BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    }, index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util2.compareByGeneratedPositionsDeflated,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index >= 0) {
      var mapping2 = this._generatedMappings[index];
      if (mapping2.generatedLine === needle.generatedLine) {
        var source2 = util2.getArg(mapping2, "source", null);
        source2 !== null && (source2 = this._sources.at(source2), source2 = util2.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL));
        var name = util2.getArg(mapping2, "name", null);
        return name !== null && (name = this._names.at(name)), {
          source: source2,
          line: util2.getArg(mapping2, "originalLine", null),
          column: util2.getArg(mapping2, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    }) : !1;
  }, BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
    if (!this.sourcesContent)
      return null;
    var index = this._findSourceIndex(aSource);
    if (index >= 0)
      return this.sourcesContent[index];
    var relativeSource = aSource;
    this.sourceRoot != null && (relativeSource = util2.relative(this.sourceRoot, relativeSource));
    var url2;
    if (this.sourceRoot != null && (url2 = util2.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url2.scheme == "file" && this._sources.has(fileUriAbsPath))
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource))
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
    if (nullOnMissing)
      return null;
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }, BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
    var source2 = util2.getArg(aArgs, "source");
    if (source2 = this._findSourceIndex(source2), source2 < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var needle = {
      source: source2,
      originalLine: util2.getArg(aArgs, "line"),
      originalColumn: util2.getArg(aArgs, "column")
    }, index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index >= 0) {
      var mapping2 = this._originalMappings[index];
      if (mapping2.source === needle.source)
        return {
          line: util2.getArg(mapping2, "generatedLine", null),
          column: util2.getArg(mapping2, "generatedColumn", null),
          lastColumn: util2.getArg(mapping2, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    typeof aSourceMap == "string" && (sourceMap2 = util2.parseSourceMapInput(aSourceMap));
    var version = util2.getArg(sourceMap2, "version"), sections = util2.getArg(sourceMap2, "sections");
    if (version != this._version)
      throw new Error("Unsupported version: " + version);
    this._sources = new ArraySet(), this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url)
        throw new Error("Support for url field in sections not implemented.");
      var offset = util2.getArg(s, "offset"), offsetLine = util2.getArg(offset, "line"), offsetColumn = util2.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return lastOffset = offset, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  return IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer, IndexedSourceMapConsumer.prototype._version = 3, Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      for (var sources = [], i2 = 0; i2 < this._sections.length; i2++)
        for (var j = 0; j < this._sections[i2].consumer.sources.length; j++)
          sources.push(this._sections[i2].consumer.sources[j]);
      return sources;
    }
  }), IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    }, sectionIndex = binarySearch2.search(
      needle,
      this._sections,
      function(needle2, section2) {
        var cmp2 = needle2.generatedLine - section2.generatedOffset.generatedLine;
        return cmp2 || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      }
    ), section = this._sections[sectionIndex];
    return section ? section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  }, IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
    for (var i2 = 0; i2 < this._sections.length; i2++) {
      var section = this._sections[i2], content = section.consumer.sourceContentFor(aSource, !0);
      if (content)
        return content;
    }
    if (nullOnMissing)
      return null;
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }, IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
    for (var i2 = 0; i2 < this._sections.length; i2++) {
      var section = this._sections[i2];
      if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) !== -1) {
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var i2 = 0; i2 < this._sections.length; i2++)
      for (var section = this._sections[i2], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
        var mapping2 = sectionMappings[j], source2 = section.consumer._sources.at(mapping2.source);
        source2 = util2.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL), this._sources.add(source2), source2 = this._sources.indexOf(source2);
        var name = null;
        mapping2.name && (name = section.consumer._names.at(mapping2.name), this._names.add(name), name = this._names.indexOf(name));
        var adjustedMapping = {
          source: source2,
          generatedLine: mapping2.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping2.generatedColumn + (section.generatedOffset.generatedLine === mapping2.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping2.originalLine,
          originalColumn: mapping2.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
      }
    quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated), quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
  }, sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer, sourceMapConsumer;
}
var sourceNode = {}, hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator, util2 = requireUtil$1(), REGEX_NEWLINE = /(\r?\n)/, NEWLINE_CODE = 10, isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
  }
  return SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node2 = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
      var lineContents = getNextLine(), newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
    return aSourceMapConsumer.eachMapping(function(mapping2) {
      if (lastMapping !== null)
        if (lastGeneratedLine < mapping2.generatedLine)
          addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
        else {
          var nextLine = remainingLines[remainingLinesIndex] || "", code = nextLine.substr(0, mapping2.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping2.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping2;
          return;
        }
      for (; lastGeneratedLine < mapping2.generatedLine; )
        node2.add(shiftNextLine()), lastGeneratedLine++;
      if (lastGeneratedColumn < mapping2.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node2.add(nextLine.substr(0, mapping2.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping2.generatedColumn), lastGeneratedColumn = mapping2.generatedColumn;
      }
      lastMapping = mapping2;
    }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node2.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && (aRelativePath != null && (sourceFile = util2.join(aRelativePath, sourceFile)), node2.setSourceContent(sourceFile, content));
    }), node2;
    function addMappingWithCode(mapping2, code) {
      if (mapping2 === null || mapping2.source === void 0)
        node2.add(code);
      else {
        var source2 = aRelativePath ? util2.join(aRelativePath, mapping2.source) : mapping2.source;
        node2.add(new SourceNode(
          mapping2.originalLine,
          mapping2.originalColumn,
          source2,
          code,
          mapping2.name
        ));
      }
    }
  }, SourceNode.prototype.add = function(aChunk) {
    if (Array.isArray(aChunk))
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    else if (aChunk[isSourceNode] || typeof aChunk == "string")
      aChunk && this.children.push(aChunk);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    return this;
  }, SourceNode.prototype.prepend = function(aChunk) {
    if (Array.isArray(aChunk))
      for (var i2 = aChunk.length - 1; i2 >= 0; i2--)
        this.prepend(aChunk[i2]);
    else if (aChunk[isSourceNode] || typeof aChunk == "string")
      this.children.unshift(aChunk);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    return this;
  }, SourceNode.prototype.walk = function(aFn) {
    for (var chunk, i2 = 0, len = this.children.length; i2 < len; i2++)
      chunk = this.children[i2], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, SourceNode.prototype.join = function(aSep) {
    var newChildren, i2, len = this.children.length;
    if (len > 0) {
      for (newChildren = [], i2 = 0; i2 < len - 1; i2++)
        newChildren.push(this.children[i2]), newChildren.push(aSep);
      newChildren.push(this.children[i2]), this.children = newChildren;
    }
    return this;
  }, SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
  }, SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
    this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
  }, SourceNode.prototype.walkSourceContents = function(aFn) {
    for (var i2 = 0, len = this.children.length; i2 < len; i2++)
      this.children[i2][isSourceNode] && this.children[i2].walkSourceContents(aFn);
    for (var sources = Object.keys(this.sourceContents), i2 = 0, len = sources.length; i2 < len; i2++)
      aFn(util2.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
  }, SourceNode.prototype.toString = function() {
    var str2 = "";
    return this.walk(function(chunk) {
      str2 += chunk;
    }), str2;
  }, SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    }, map2 = new SourceMapGenerator(aArgs), sourceMappingActive = !1, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
    return this.walk(function(chunk, original) {
      generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map2.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map2.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      }), lastOriginalSource = null, sourceMappingActive = !1);
      for (var idx = 0, length = chunk.length; idx < length; idx++)
        chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map2.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        })) : generated.column++;
    }), this.walkSourceContents(function(sourceFile, sourceContent) {
      map2.setSourceContent(sourceFile, sourceContent);
    }), { code: generated.code, map: map2 };
  }, sourceNode.SourceNode = SourceNode, sourceNode;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  return hasRequiredSourceMap || (hasRequiredSourceMap = 1, sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator, sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer, sourceMap.SourceNode = requireSourceNode().SourceNode), sourceMap;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$1;
  hasRequiredUtil = 1, Object.defineProperty(util$1, "__esModule", { value: !0 }), util$1.isTrailingCommaEnabled = util$1.getParentExportDeclaration = util$1.isExportDeclaration = util$1.fixFaultyLocations = util$1.getTrueLoc = util$1.composeSourceMaps = util$1.copyPos = util$1.comparePos = util$1.getUnionOfKeys = util$1.getOption = util$1.isBrowser = util$1.getLineTerminator = void 0;
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), types2 = tslib_12.__importStar(requireMain$1()), n = types2.namedTypes, source_map_1 = tslib_12.__importDefault(requireSourceMap()), SourceMapConsumer = source_map_1.default.SourceMapConsumer, SourceMapGenerator = source_map_1.default.SourceMapGenerator, hasOwn2 = Object.prototype.hasOwnProperty;
  function getLineTerminator() {
    return isBrowser() ? `
` : require$$0__default$2.default.EOL || `
`;
  }
  util$1.getLineTerminator = getLineTerminator;
  function isBrowser() {
    return typeof window < "u" && typeof window.document < "u";
  }
  util$1.isBrowser = isBrowser;
  function getOption(options2, key2, defaultValue) {
    return options2 && hasOwn2.call(options2, key2) ? options2[key2] : defaultValue;
  }
  util$1.getOption = getOption;
  function getUnionOfKeys() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    for (var result = {}, argc = args.length, i2 = 0; i2 < argc; ++i2)
      for (var keys = Object.keys(args[i2]), keyCount = keys.length, j = 0; j < keyCount; ++j)
        result[keys[j]] = !0;
    return result;
  }
  util$1.getUnionOfKeys = getUnionOfKeys;
  function comparePos(pos1, pos2) {
    return pos1.line - pos2.line || pos1.column - pos2.column;
  }
  util$1.comparePos = comparePos;
  function copyPos(pos2) {
    return {
      line: pos2.line,
      column: pos2.column
    };
  }
  util$1.copyPos = copyPos;
  function composeSourceMaps(formerMap, latterMap) {
    if (formerMap) {
      if (!latterMap)
        return formerMap;
    } else
      return latterMap || null;
    var smcFormer = new SourceMapConsumer(formerMap), smcLatter = new SourceMapConsumer(latterMap), smg = new SourceMapGenerator({
      file: latterMap.file,
      sourceRoot: latterMap.sourceRoot
    }), sourcesToContents = {};
    return smcLatter.eachMapping(function(mapping2) {
      var origPos = smcFormer.originalPositionFor({
        line: mapping2.originalLine,
        column: mapping2.originalColumn
      }), sourceName = origPos.source;
      if (sourceName !== null) {
        smg.addMapping({
          source: sourceName,
          original: copyPos(origPos),
          generated: {
            line: mapping2.generatedLine,
            column: mapping2.generatedColumn
          },
          name: mapping2.name
        });
        var sourceContent = smcFormer.sourceContentFor(sourceName);
        sourceContent && !hasOwn2.call(sourcesToContents, sourceName) && (sourcesToContents[sourceName] = sourceContent, smg.setSourceContent(sourceName, sourceContent));
      }
    }), smg.toJSON();
  }
  util$1.composeSourceMaps = composeSourceMaps;
  function getTrueLoc(node2, lines2) {
    if (!node2.loc)
      return null;
    var result = {
      start: node2.loc.start,
      end: node2.loc.end
    };
    function include(node3) {
      expandLoc(result, node3.loc);
    }
    return node2.declaration && node2.declaration.decorators && isExportDeclaration(node2) && node2.declaration.decorators.forEach(include), comparePos(result.start, result.end) < 0 && (result.start = copyPos(result.start), lines2.skipSpaces(result.start, !1, !0), comparePos(result.start, result.end) < 0 && (result.end = copyPos(result.end), lines2.skipSpaces(result.end, !0, !0))), node2.comments && node2.comments.forEach(include), result;
  }
  util$1.getTrueLoc = getTrueLoc;
  function expandLoc(parentLoc, childLoc) {
    parentLoc && childLoc && (comparePos(childLoc.start, parentLoc.start) < 0 && (parentLoc.start = childLoc.start), comparePos(parentLoc.end, childLoc.end) < 0 && (parentLoc.end = childLoc.end));
  }
  function fixFaultyLocations(node2, lines2) {
    var loc = node2.loc;
    if (loc && (loc.start.line < 1 && (loc.start.line = 1), loc.end.line < 1 && (loc.end.line = 1)), node2.type === "File" && (loc.start = lines2.firstPos(), loc.end = lines2.lastPos()), fixForLoopHead(node2, lines2), fixTemplateLiteral(node2, lines2), loc && node2.decorators)
      node2.decorators.forEach(function(decorator) {
        expandLoc(loc, decorator.loc);
      });
    else if (node2.declaration && isExportDeclaration(node2)) {
      node2.declaration.loc = null;
      var decorators = node2.declaration.decorators;
      decorators && decorators.forEach(function(decorator) {
        expandLoc(loc, decorator.loc);
      });
    } else if (n.MethodDefinition && n.MethodDefinition.check(node2) || n.Property.check(node2) && (node2.method || node2.shorthand))
      node2.value.loc = null, n.FunctionExpression.check(node2.value) && (node2.value.id = null);
    else if (node2.type === "ObjectTypeProperty") {
      var loc_1 = node2.loc, end2 = loc_1 && loc_1.end;
      end2 && (end2 = copyPos(end2), lines2.prevPos(end2) && lines2.charAt(end2) === "," && (end2 = lines2.skipSpaces(end2, !0, !0)) && (loc_1.end = end2));
    }
  }
  util$1.fixFaultyLocations = fixFaultyLocations;
  function fixForLoopHead(node2, lines2) {
    if (node2.type !== "ForStatement")
      return;
    function fix(child) {
      for (var loc = child && child.loc, start = loc && loc.start, end2 = loc && copyPos(loc.end); start && end2 && comparePos(start, end2) < 0 && (lines2.prevPos(end2), lines2.charAt(end2) === ";"); )
        loc.end.line = end2.line, loc.end.column = end2.column;
    }
    fix(node2.init), fix(node2.test), fix(node2.update);
  }
  function fixTemplateLiteral(node2, lines2) {
    if (node2.type === "TemplateLiteral" && node2.quasis.length !== 0) {
      if (node2.loc) {
        var afterLeftBackTickPos = copyPos(node2.loc.start);
        (0, tiny_invariant_1.default)(lines2.charAt(afterLeftBackTickPos) === "`"), (0, tiny_invariant_1.default)(lines2.nextPos(afterLeftBackTickPos));
        var firstQuasi = node2.quasis[0];
        comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0 && (firstQuasi.loc.start = afterLeftBackTickPos);
        var rightBackTickPos = copyPos(node2.loc.end);
        (0, tiny_invariant_1.default)(lines2.prevPos(rightBackTickPos)), (0, tiny_invariant_1.default)(lines2.charAt(rightBackTickPos) === "`");
        var lastQuasi = node2.quasis[node2.quasis.length - 1];
        comparePos(rightBackTickPos, lastQuasi.loc.end) < 0 && (lastQuasi.loc.end = rightBackTickPos);
      }
      node2.expressions.forEach(function(expr, i2) {
        var dollarCurlyPos = lines2.skipSpaces(expr.loc.start, !0, !1);
        if (lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "{" && lines2.prevPos(dollarCurlyPos) && lines2.charAt(dollarCurlyPos) === "$") {
          var quasiBefore = node2.quasis[i2];
          comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0 && (quasiBefore.loc.end = dollarCurlyPos);
        }
        var rightCurlyPos = lines2.skipSpaces(expr.loc.end, !1, !1);
        if (lines2.charAt(rightCurlyPos) === "}") {
          (0, tiny_invariant_1.default)(lines2.nextPos(rightCurlyPos));
          var quasiAfter = node2.quasis[i2 + 1];
          comparePos(quasiAfter.loc.start, rightCurlyPos) < 0 && (quasiAfter.loc.start = rightCurlyPos);
        }
      });
    }
  }
  function isExportDeclaration(node2) {
    if (node2)
      switch (node2.type) {
        case "ExportDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportDefaultSpecifier":
        case "DeclareExportDeclaration":
        case "ExportNamedDeclaration":
        case "ExportAllDeclaration":
          return !0;
      }
    return !1;
  }
  util$1.isExportDeclaration = isExportDeclaration;
  function getParentExportDeclaration(path2) {
    var parentNode = path2.getParentNode();
    return path2.getName() === "declaration" && isExportDeclaration(parentNode) ? parentNode : null;
  }
  util$1.getParentExportDeclaration = getParentExportDeclaration;
  function isTrailingCommaEnabled(options2, context) {
    var trailingComma = options2.trailingComma;
    return typeof trailingComma == "object" ? !!trailingComma[context] : !!trailingComma;
  }
  return util$1.isTrailingCommaEnabled = isTrailingCommaEnabled, util$1;
}
var esprima$1 = {}, esprima = { exports: {} }, hasRequiredEsprima$1;
function requireEsprima$1() {
  return hasRequiredEsprima$1 || (hasRequiredEsprima$1 = 1, function(module2, exports2) {
    (function(root2, factory) {
      module2.exports = factory();
    })(loadEnv.commonjsGlobal, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module3 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: !1
              /******/
            };
            return modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__), module3.loaded = !0, module3.exports;
          }
          return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var comment_handler_1 = __webpack_require__(1), jsx_parser_1 = __webpack_require__(3), parser_1 = __webpack_require__(8), tokenizer_1 = __webpack_require__(15);
            function parse3(code, options2, delegate) {
              var commentHandler = null, proxyDelegate = function(node2, metadata) {
                delegate && delegate(node2, metadata), commentHandler && commentHandler.visit(node2, metadata);
              }, parserDelegate = typeof delegate == "function" ? proxyDelegate : null, collectComment = !1;
              if (options2) {
                collectComment = typeof options2.comment == "boolean" && options2.comment;
                var attachComment = typeof options2.attachComment == "boolean" && options2.attachComment;
                (collectComment || attachComment) && (commentHandler = new comment_handler_1.CommentHandler(), commentHandler.attach = attachComment, options2.comment = !0, parserDelegate = proxyDelegate);
              }
              var isModule = !1;
              options2 && typeof options2.sourceType == "string" && (isModule = options2.sourceType === "module");
              var parser2;
              options2 && typeof options2.jsx == "boolean" && options2.jsx ? parser2 = new jsx_parser_1.JSXParser(code, options2, parserDelegate) : parser2 = new parser_1.Parser(code, options2, parserDelegate);
              var program = isModule ? parser2.parseModule() : parser2.parseScript(), ast = program;
              return collectComment && commentHandler && (ast.comments = commentHandler.comments), parser2.config.tokens && (ast.tokens = parser2.tokens), parser2.config.tolerant && (ast.errors = parser2.errorHandler.errors), ast;
            }
            exports3.parse = parse3;
            function parseModule(code, options2, delegate) {
              var parsingOptions = options2 || {};
              return parsingOptions.sourceType = "module", parse3(code, parsingOptions, delegate);
            }
            exports3.parseModule = parseModule;
            function parseScript(code, options2, delegate) {
              var parsingOptions = options2 || {};
              return parsingOptions.sourceType = "script", parse3(code, parsingOptions, delegate);
            }
            exports3.parseScript = parseScript;
            function tokenize(code, options2, delegate) {
              var tokenizer = new tokenizer_1.Tokenizer(code, options2), tokens;
              tokens = [];
              try {
                for (; ; ) {
                  var token2 = tokenizer.getNextToken();
                  if (!token2)
                    break;
                  delegate && (token2 = delegate(token2)), tokens.push(token2);
                }
              } catch (e) {
                tokenizer.errorHandler.tolerate(e);
              }
              return tokenizer.errorHandler.tolerant && (tokens.errors = tokenizer.errors()), tokens;
            }
            exports3.tokenize = tokenize;
            var syntax_1 = __webpack_require__(2);
            exports3.Syntax = syntax_1.Syntax, exports3.version = "4.0.1";
          },
          /* 1 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var syntax_1 = __webpack_require__(2), CommentHandler = function() {
              function CommentHandler2() {
                this.attach = !1, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
              }
              return CommentHandler2.prototype.insertInnerComments = function(node2, metadata) {
                if (node2.type === syntax_1.Syntax.BlockStatement && node2.body.length === 0) {
                  for (var innerComments = [], i2 = this.leading.length - 1; i2 >= 0; --i2) {
                    var entry = this.leading[i2];
                    metadata.end.offset >= entry.start && (innerComments.unshift(entry.comment), this.leading.splice(i2, 1), this.trailing.splice(i2, 1));
                  }
                  innerComments.length && (node2.innerComments = innerComments);
                }
              }, CommentHandler2.prototype.findTrailingComments = function(metadata) {
                var trailingComments = [];
                if (this.trailing.length > 0) {
                  for (var i2 = this.trailing.length - 1; i2 >= 0; --i2) {
                    var entry_1 = this.trailing[i2];
                    entry_1.start >= metadata.end.offset && trailingComments.unshift(entry_1.comment);
                  }
                  return this.trailing.length = 0, trailingComments;
                }
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.node.trailingComments) {
                  var firstComment = entry.node.trailingComments[0];
                  firstComment && firstComment.range[0] >= metadata.end.offset && (trailingComments = entry.node.trailingComments, delete entry.node.trailingComments);
                }
                return trailingComments;
              }, CommentHandler2.prototype.findLeadingComments = function(metadata) {
                for (var leadingComments = [], target; this.stack.length > 0; ) {
                  var entry = this.stack[this.stack.length - 1];
                  if (entry && entry.start >= metadata.start.offset)
                    target = entry.node, this.stack.pop();
                  else
                    break;
                }
                if (target) {
                  for (var count2 = target.leadingComments ? target.leadingComments.length : 0, i2 = count2 - 1; i2 >= 0; --i2) {
                    var comment = target.leadingComments[i2];
                    comment.range[1] <= metadata.start.offset && (leadingComments.unshift(comment), target.leadingComments.splice(i2, 1));
                  }
                  return target.leadingComments && target.leadingComments.length === 0 && delete target.leadingComments, leadingComments;
                }
                for (var i2 = this.leading.length - 1; i2 >= 0; --i2) {
                  var entry = this.leading[i2];
                  entry.start <= metadata.start.offset && (leadingComments.unshift(entry.comment), this.leading.splice(i2, 1));
                }
                return leadingComments;
              }, CommentHandler2.prototype.visitNode = function(node2, metadata) {
                if (!(node2.type === syntax_1.Syntax.Program && node2.body.length > 0)) {
                  this.insertInnerComments(node2, metadata);
                  var trailingComments = this.findTrailingComments(metadata), leadingComments = this.findLeadingComments(metadata);
                  leadingComments.length > 0 && (node2.leadingComments = leadingComments), trailingComments.length > 0 && (node2.trailingComments = trailingComments), this.stack.push({
                    node: node2,
                    start: metadata.start.offset
                  });
                }
              }, CommentHandler2.prototype.visitComment = function(node2, metadata) {
                var type2 = node2.type[0] === "L" ? "Line" : "Block", comment = {
                  type: type2,
                  value: node2.value
                };
                if (node2.range && (comment.range = node2.range), node2.loc && (comment.loc = node2.loc), this.comments.push(comment), this.attach) {
                  var entry = {
                    comment: {
                      type: type2,
                      value: node2.value,
                      range: [metadata.start.offset, metadata.end.offset]
                    },
                    start: metadata.start.offset
                  };
                  node2.loc && (entry.comment.loc = node2.loc), node2.type = type2, this.leading.push(entry), this.trailing.push(entry);
                }
              }, CommentHandler2.prototype.visit = function(node2, metadata) {
                node2.type === "LineComment" ? this.visitComment(node2, metadata) : node2.type === "BlockComment" ? this.visitComment(node2, metadata) : this.attach && this.visitNode(node2, metadata);
              }, CommentHandler2;
            }();
            exports3.CommentHandler = CommentHandler;
          },
          /* 2 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.Syntax = {
              AssignmentExpression: "AssignmentExpression",
              AssignmentPattern: "AssignmentPattern",
              ArrayExpression: "ArrayExpression",
              ArrayPattern: "ArrayPattern",
              ArrowFunctionExpression: "ArrowFunctionExpression",
              AwaitExpression: "AwaitExpression",
              BlockStatement: "BlockStatement",
              BinaryExpression: "BinaryExpression",
              BreakStatement: "BreakStatement",
              CallExpression: "CallExpression",
              CatchClause: "CatchClause",
              ClassBody: "ClassBody",
              ClassDeclaration: "ClassDeclaration",
              ClassExpression: "ClassExpression",
              ConditionalExpression: "ConditionalExpression",
              ContinueStatement: "ContinueStatement",
              DoWhileStatement: "DoWhileStatement",
              DebuggerStatement: "DebuggerStatement",
              EmptyStatement: "EmptyStatement",
              ExportAllDeclaration: "ExportAllDeclaration",
              ExportDefaultDeclaration: "ExportDefaultDeclaration",
              ExportNamedDeclaration: "ExportNamedDeclaration",
              ExportSpecifier: "ExportSpecifier",
              ExpressionStatement: "ExpressionStatement",
              ForStatement: "ForStatement",
              ForOfStatement: "ForOfStatement",
              ForInStatement: "ForInStatement",
              FunctionDeclaration: "FunctionDeclaration",
              FunctionExpression: "FunctionExpression",
              Identifier: "Identifier",
              IfStatement: "IfStatement",
              ImportDeclaration: "ImportDeclaration",
              ImportDefaultSpecifier: "ImportDefaultSpecifier",
              ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
              ImportSpecifier: "ImportSpecifier",
              Literal: "Literal",
              LabeledStatement: "LabeledStatement",
              LogicalExpression: "LogicalExpression",
              MemberExpression: "MemberExpression",
              MetaProperty: "MetaProperty",
              MethodDefinition: "MethodDefinition",
              NewExpression: "NewExpression",
              ObjectExpression: "ObjectExpression",
              ObjectPattern: "ObjectPattern",
              Program: "Program",
              Property: "Property",
              RestElement: "RestElement",
              ReturnStatement: "ReturnStatement",
              SequenceExpression: "SequenceExpression",
              SpreadElement: "SpreadElement",
              Super: "Super",
              SwitchCase: "SwitchCase",
              SwitchStatement: "SwitchStatement",
              TaggedTemplateExpression: "TaggedTemplateExpression",
              TemplateElement: "TemplateElement",
              TemplateLiteral: "TemplateLiteral",
              ThisExpression: "ThisExpression",
              ThrowStatement: "ThrowStatement",
              TryStatement: "TryStatement",
              UnaryExpression: "UnaryExpression",
              UpdateExpression: "UpdateExpression",
              VariableDeclaration: "VariableDeclaration",
              VariableDeclarator: "VariableDeclarator",
              WhileStatement: "WhileStatement",
              WithStatement: "WithStatement",
              YieldExpression: "YieldExpression"
            };
          },
          /* 3 */
          /***/
          function(module3, exports3, __webpack_require__) {
            var __extends2 = this && this.__extends || function() {
              var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
              };
              return function(d, b) {
                extendStatics2(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var character_1 = __webpack_require__(4), JSXNode = __webpack_require__(5), jsx_syntax_1 = __webpack_require__(6), Node2 = __webpack_require__(7), parser_1 = __webpack_require__(8), token_1 = __webpack_require__(13), xhtml_entities_1 = __webpack_require__(14);
            token_1.TokenName[
              100
              /* Identifier */
            ] = "JSXIdentifier", token_1.TokenName[
              101
              /* Text */
            ] = "JSXText";
            function getQualifiedElementName(elementName) {
              var qualifiedName;
              switch (elementName.type) {
                case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                  var id = elementName;
                  qualifiedName = id.name;
                  break;
                case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                  var ns = elementName;
                  qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                  break;
                case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                  var expr = elementName;
                  qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                  break;
              }
              return qualifiedName;
            }
            var JSXParser = function(_super) {
              __extends2(JSXParser2, _super);
              function JSXParser2(code, options2, delegate) {
                return _super.call(this, code, options2, delegate) || this;
              }
              return JSXParser2.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
              }, JSXParser2.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              }, JSXParser2.prototype.finishJSX = function() {
                this.nextToken();
              }, JSXParser2.prototype.reenterJSX = function() {
                this.startJSX(), this.expectJSX("}"), this.config.tokens && this.tokens.pop();
              }, JSXParser2.prototype.createJSXNode = function() {
                return this.collectComments(), {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }, JSXParser2.prototype.createJSXChildNode = function() {
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }, JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                for (var result = "&", valid = !0, terminated = !1, numeric2 = !1, hex = !1; !this.scanner.eof() && valid && !terminated; ) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === quote)
                    break;
                  if (terminated = ch === ";", result += ch, ++this.scanner.index, !terminated)
                    switch (result.length) {
                      case 2:
                        numeric2 = ch === "#";
                        break;
                      case 3:
                        numeric2 && (hex = ch === "x", valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0)), numeric2 = numeric2 && !hex);
                        break;
                      default:
                        valid = valid && !(numeric2 && !character_1.Character.isDecimalDigit(ch.charCodeAt(0))), valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                        break;
                    }
                }
                if (valid && terminated && result.length > 2) {
                  var str2 = result.substr(1, result.length - 2);
                  numeric2 && str2.length > 1 ? result = String.fromCharCode(parseInt(str2.substr(1), 10)) : hex && str2.length > 2 ? result = String.fromCharCode(parseInt("0" + str2.substr(1), 16)) : !numeric2 && !hex && xhtml_entities_1.XHTMLEntities[str2] && (result = xhtml_entities_1.XHTMLEntities[str2]);
                }
                return result;
              }, JSXParser2.prototype.lexJSX = function() {
                var cp2 = this.scanner.source.charCodeAt(this.scanner.index);
                if (cp2 === 60 || cp2 === 62 || cp2 === 47 || cp2 === 58 || cp2 === 61 || cp2 === 123 || cp2 === 125) {
                  var value = this.scanner.source[this.scanner.index++];
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index - 1,
                    end: this.scanner.index
                  };
                }
                if (cp2 === 34 || cp2 === 39) {
                  for (var start = this.scanner.index, quote = this.scanner.source[this.scanner.index++], str2 = ""; !this.scanner.eof(); ) {
                    var ch = this.scanner.source[this.scanner.index++];
                    if (ch === quote)
                      break;
                    ch === "&" ? str2 += this.scanXHTMLEntity(quote) : str2 += ch;
                  }
                  return {
                    type: 8,
                    value: str2,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp2 === 46) {
                  var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1), n2 = this.scanner.source.charCodeAt(this.scanner.index + 2), value = n1 === 46 && n2 === 46 ? "..." : ".", start = this.scanner.index;
                  return this.scanner.index += value.length, {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp2 === 96)
                  return {
                    type: 10,
                    value: "",
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index,
                    end: this.scanner.index
                  };
                if (character_1.Character.isIdentifierStart(cp2) && cp2 !== 92) {
                  var start = this.scanner.index;
                  for (++this.scanner.index; !this.scanner.eof(); ) {
                    var ch = this.scanner.source.charCodeAt(this.scanner.index);
                    if (character_1.Character.isIdentifierPart(ch) && ch !== 92)
                      ++this.scanner.index;
                    else if (ch === 45)
                      ++this.scanner.index;
                    else
                      break;
                  }
                  var id = this.scanner.source.slice(start, this.scanner.index);
                  return {
                    type: 100,
                    value: id,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                return this.scanner.lex();
              }, JSXParser2.prototype.nextJSXToken = function() {
                this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var token2 = this.lexJSX();
                return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(token2)), token2;
              }, JSXParser2.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                for (var start = this.scanner.index, text = ""; !this.scanner.eof(); ) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === "{" || ch === "<")
                    break;
                  ++this.scanner.index, text += ch, character_1.Character.isLineTerminator(ch.charCodeAt(0)) && (++this.scanner.lineNumber, ch === "\r" && this.scanner.source[this.scanner.index] === `
` && ++this.scanner.index, this.scanner.lineStart = this.scanner.index);
                }
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var token2 = {
                  type: 101,
                  value: text,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
                return text.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(token2)), token2;
              }, JSXParser2.prototype.peekJSXToken = function() {
                var state2 = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.lexJSX();
                return this.scanner.restoreState(state2), next;
              }, JSXParser2.prototype.expectJSX = function(value) {
                var token2 = this.nextJSXToken();
                (token2.type !== 7 || token2.value !== value) && this.throwUnexpectedToken(token2);
              }, JSXParser2.prototype.matchJSX = function(value) {
                var next = this.peekJSXToken();
                return next.type === 7 && next.value === value;
              }, JSXParser2.prototype.parseJSXIdentifier = function() {
                var node2 = this.createJSXNode(), token2 = this.nextJSXToken();
                return token2.type !== 100 && this.throwUnexpectedToken(token2), this.finalize(node2, new JSXNode.JSXIdentifier(token2.value));
              }, JSXParser2.prototype.parseJSXElementName = function() {
                var node2 = this.createJSXNode(), elementName = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = elementName;
                  this.expectJSX(":");
                  var name_1 = this.parseJSXIdentifier();
                  elementName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_1));
                } else if (this.matchJSX("."))
                  for (; this.matchJSX("."); ) {
                    var object = elementName;
                    this.expectJSX(".");
                    var property = this.parseJSXIdentifier();
                    elementName = this.finalize(node2, new JSXNode.JSXMemberExpression(object, property));
                  }
                return elementName;
              }, JSXParser2.prototype.parseJSXAttributeName = function() {
                var node2 = this.createJSXNode(), attributeName, identifier = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = identifier;
                  this.expectJSX(":");
                  var name_2 = this.parseJSXIdentifier();
                  attributeName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_2));
                } else
                  attributeName = identifier;
                return attributeName;
              }, JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                var node2 = this.createJSXNode(), token2 = this.nextJSXToken();
                token2.type !== 8 && this.throwUnexpectedToken(token2);
                var raw = this.getTokenRaw(token2);
                return this.finalize(node2, new Node2.Literal(token2.value, raw));
              }, JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                var node2 = this.createJSXNode();
                this.expectJSX("{"), this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                var expression = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
              }, JSXParser2.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              }, JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                var node2 = this.createJSXNode(), name = this.parseJSXAttributeName(), value = null;
                return this.matchJSX("=") && (this.expectJSX("="), value = this.parseJSXAttributeValue()), this.finalize(node2, new JSXNode.JSXAttribute(name, value));
              }, JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                var node2 = this.createJSXNode();
                this.expectJSX("{"), this.expectJSX("..."), this.finishJSX();
                var argument = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(node2, new JSXNode.JSXSpreadAttribute(argument));
              }, JSXParser2.prototype.parseJSXAttributes = function() {
                for (var attributes = []; !this.matchJSX("/") && !this.matchJSX(">"); ) {
                  var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  attributes.push(attribute);
                }
                return attributes;
              }, JSXParser2.prototype.parseJSXOpeningElement = function() {
                var node2 = this.createJSXNode();
                this.expectJSX("<");
                var name = this.parseJSXElementName(), attributes = this.parseJSXAttributes(), selfClosing = this.matchJSX("/");
                return selfClosing && this.expectJSX("/"), this.expectJSX(">"), this.finalize(node2, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              }, JSXParser2.prototype.parseJSXBoundaryElement = function() {
                var node2 = this.createJSXNode();
                if (this.expectJSX("<"), this.matchJSX("/")) {
                  this.expectJSX("/");
                  var name_3 = this.parseJSXElementName();
                  return this.expectJSX(">"), this.finalize(node2, new JSXNode.JSXClosingElement(name_3));
                }
                var name = this.parseJSXElementName(), attributes = this.parseJSXAttributes(), selfClosing = this.matchJSX("/");
                return selfClosing && this.expectJSX("/"), this.expectJSX(">"), this.finalize(node2, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              }, JSXParser2.prototype.parseJSXEmptyExpression = function() {
                var node2 = this.createJSXChildNode();
                return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(node2, new JSXNode.JSXEmptyExpression());
              }, JSXParser2.prototype.parseJSXExpressionContainer = function() {
                var node2 = this.createJSXNode();
                this.expectJSX("{");
                var expression;
                return this.matchJSX("}") ? (expression = this.parseJSXEmptyExpression(), this.expectJSX("}")) : (this.finishJSX(), expression = this.parseAssignmentExpression(), this.reenterJSX()), this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
              }, JSXParser2.prototype.parseJSXChildren = function() {
                for (var children = []; !this.scanner.eof(); ) {
                  var node2 = this.createJSXChildNode(), token2 = this.nextJSXText();
                  if (token2.start < token2.end) {
                    var raw = this.getTokenRaw(token2), child = this.finalize(node2, new JSXNode.JSXText(token2.value, raw));
                    children.push(child);
                  }
                  if (this.scanner.source[this.scanner.index] === "{") {
                    var container = this.parseJSXExpressionContainer();
                    children.push(container);
                  } else
                    break;
                }
                return children;
              }, JSXParser2.prototype.parseComplexJSXElement = function(el) {
                for (var stack2 = []; !this.scanner.eof(); ) {
                  el.children = el.children.concat(this.parseJSXChildren());
                  var node2 = this.createJSXChildNode(), element = this.parseJSXBoundaryElement();
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                    var opening = element;
                    if (opening.selfClosing) {
                      var child = this.finalize(node2, new JSXNode.JSXElement(opening, [], null));
                      el.children.push(child);
                    } else
                      stack2.push(el), el = { node: node2, opening, closing: null, children: [] };
                  }
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                    el.closing = element;
                    var open_12 = getQualifiedElementName(el.opening.name), close_1 = getQualifiedElementName(el.closing.name);
                    if (open_12 !== close_1 && this.tolerateError("Expected corresponding JSX closing tag for %0", open_12), stack2.length > 0) {
                      var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                      el = stack2[stack2.length - 1], el.children.push(child), stack2.pop();
                    } else
                      break;
                  }
                }
                return el;
              }, JSXParser2.prototype.parseJSXElement = function() {
                var node2 = this.createJSXNode(), opening = this.parseJSXOpeningElement(), children = [], closing = null;
                if (!opening.selfClosing) {
                  var el = this.parseComplexJSXElement({ node: node2, opening, closing, children });
                  children = el.children, closing = el.closing;
                }
                return this.finalize(node2, new JSXNode.JSXElement(opening, children, closing));
              }, JSXParser2.prototype.parseJSXRoot = function() {
                this.config.tokens && this.tokens.pop(), this.startJSX();
                var element = this.parseJSXElement();
                return this.finishJSX(), element;
              }, JSXParser2.prototype.isStartOfExpression = function() {
                return _super.prototype.isStartOfExpression.call(this) || this.match("<");
              }, JSXParser2;
            }(parser_1.Parser);
            exports3.JSXParser = JSXParser;
          },
          /* 4 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var Regex = {
              // Unicode v8.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
              // Unicode v8.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            exports3.Character = {
              /* tslint:disable:no-bitwise */
              fromCodePoint: function(cp2) {
                return cp2 < 65536 ? String.fromCharCode(cp2) : String.fromCharCode(55296 + (cp2 - 65536 >> 10)) + String.fromCharCode(56320 + (cp2 - 65536 & 1023));
              },
              // https://tc39.github.io/ecma262/#sec-white-space
              isWhiteSpace: function(cp2) {
                return cp2 === 32 || cp2 === 9 || cp2 === 11 || cp2 === 12 || cp2 === 160 || cp2 >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp2) >= 0;
              },
              // https://tc39.github.io/ecma262/#sec-line-terminators
              isLineTerminator: function(cp2) {
                return cp2 === 10 || cp2 === 13 || cp2 === 8232 || cp2 === 8233;
              },
              // https://tc39.github.io/ecma262/#sec-names-and-keywords
              isIdentifierStart: function(cp2) {
                return cp2 === 36 || cp2 === 95 || cp2 >= 65 && cp2 <= 90 || cp2 >= 97 && cp2 <= 122 || cp2 === 92 || cp2 >= 128 && Regex.NonAsciiIdentifierStart.test(exports3.Character.fromCodePoint(cp2));
              },
              isIdentifierPart: function(cp2) {
                return cp2 === 36 || cp2 === 95 || cp2 >= 65 && cp2 <= 90 || cp2 >= 97 && cp2 <= 122 || cp2 >= 48 && cp2 <= 57 || cp2 === 92 || cp2 >= 128 && Regex.NonAsciiIdentifierPart.test(exports3.Character.fromCodePoint(cp2));
              },
              // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
              isDecimalDigit: function(cp2) {
                return cp2 >= 48 && cp2 <= 57;
              },
              isHexDigit: function(cp2) {
                return cp2 >= 48 && cp2 <= 57 || cp2 >= 65 && cp2 <= 70 || cp2 >= 97 && cp2 <= 102;
              },
              isOctalDigit: function(cp2) {
                return cp2 >= 48 && cp2 <= 55;
              }
            };
          },
          /* 5 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var jsx_syntax_1 = __webpack_require__(6), JSXClosingElement = /* @__PURE__ */ function() {
              function JSXClosingElement2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement, this.name = name;
              }
              return JSXClosingElement2;
            }();
            exports3.JSXClosingElement = JSXClosingElement;
            var JSXElement = /* @__PURE__ */ function() {
              function JSXElement2(openingElement, children, closingElement) {
                this.type = jsx_syntax_1.JSXSyntax.JSXElement, this.openingElement = openingElement, this.children = children, this.closingElement = closingElement;
              }
              return JSXElement2;
            }();
            exports3.JSXElement = JSXElement;
            var JSXEmptyExpression = /* @__PURE__ */ function() {
              function JSXEmptyExpression2() {
                this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
              }
              return JSXEmptyExpression2;
            }();
            exports3.JSXEmptyExpression = JSXEmptyExpression;
            var JSXExpressionContainer = /* @__PURE__ */ function() {
              function JSXExpressionContainer2(expression) {
                this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer, this.expression = expression;
              }
              return JSXExpressionContainer2;
            }();
            exports3.JSXExpressionContainer = JSXExpressionContainer;
            var JSXIdentifier = /* @__PURE__ */ function() {
              function JSXIdentifier2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier, this.name = name;
              }
              return JSXIdentifier2;
            }();
            exports3.JSXIdentifier = JSXIdentifier;
            var JSXMemberExpression = /* @__PURE__ */ function() {
              function JSXMemberExpression2(object, property) {
                this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression, this.object = object, this.property = property;
              }
              return JSXMemberExpression2;
            }();
            exports3.JSXMemberExpression = JSXMemberExpression;
            var JSXAttribute = /* @__PURE__ */ function() {
              function JSXAttribute2(name, value) {
                this.type = jsx_syntax_1.JSXSyntax.JSXAttribute, this.name = name, this.value = value;
              }
              return JSXAttribute2;
            }();
            exports3.JSXAttribute = JSXAttribute;
            var JSXNamespacedName = /* @__PURE__ */ function() {
              function JSXNamespacedName2(namespace, name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName, this.namespace = namespace, this.name = name;
              }
              return JSXNamespacedName2;
            }();
            exports3.JSXNamespacedName = JSXNamespacedName;
            var JSXOpeningElement = /* @__PURE__ */ function() {
              function JSXOpeningElement2(name, selfClosing, attributes) {
                this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement, this.name = name, this.selfClosing = selfClosing, this.attributes = attributes;
              }
              return JSXOpeningElement2;
            }();
            exports3.JSXOpeningElement = JSXOpeningElement;
            var JSXSpreadAttribute = /* @__PURE__ */ function() {
              function JSXSpreadAttribute2(argument) {
                this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute, this.argument = argument;
              }
              return JSXSpreadAttribute2;
            }();
            exports3.JSXSpreadAttribute = JSXSpreadAttribute;
            var JSXText = /* @__PURE__ */ function() {
              function JSXText2(value, raw) {
                this.type = jsx_syntax_1.JSXSyntax.JSXText, this.value = value, this.raw = raw;
              }
              return JSXText2;
            }();
            exports3.JSXText = JSXText;
          },
          /* 6 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.JSXSyntax = {
              JSXAttribute: "JSXAttribute",
              JSXClosingElement: "JSXClosingElement",
              JSXElement: "JSXElement",
              JSXEmptyExpression: "JSXEmptyExpression",
              JSXExpressionContainer: "JSXExpressionContainer",
              JSXIdentifier: "JSXIdentifier",
              JSXMemberExpression: "JSXMemberExpression",
              JSXNamespacedName: "JSXNamespacedName",
              JSXOpeningElement: "JSXOpeningElement",
              JSXSpreadAttribute: "JSXSpreadAttribute",
              JSXText: "JSXText"
            };
          },
          /* 7 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var syntax_1 = __webpack_require__(2), ArrayExpression = /* @__PURE__ */ function() {
              function ArrayExpression2(elements) {
                this.type = syntax_1.Syntax.ArrayExpression, this.elements = elements;
              }
              return ArrayExpression2;
            }();
            exports3.ArrayExpression = ArrayExpression;
            var ArrayPattern = /* @__PURE__ */ function() {
              function ArrayPattern2(elements) {
                this.type = syntax_1.Syntax.ArrayPattern, this.elements = elements;
              }
              return ArrayPattern2;
            }();
            exports3.ArrayPattern = ArrayPattern;
            var ArrowFunctionExpression = /* @__PURE__ */ function() {
              function ArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression, this.id = null, this.params = params, this.body = body, this.generator = !1, this.expression = expression, this.async = !1;
              }
              return ArrowFunctionExpression2;
            }();
            exports3.ArrowFunctionExpression = ArrowFunctionExpression;
            var AssignmentExpression = /* @__PURE__ */ function() {
              function AssignmentExpression2(operator, left2, right2) {
                this.type = syntax_1.Syntax.AssignmentExpression, this.operator = operator, this.left = left2, this.right = right2;
              }
              return AssignmentExpression2;
            }();
            exports3.AssignmentExpression = AssignmentExpression;
            var AssignmentPattern = /* @__PURE__ */ function() {
              function AssignmentPattern2(left2, right2) {
                this.type = syntax_1.Syntax.AssignmentPattern, this.left = left2, this.right = right2;
              }
              return AssignmentPattern2;
            }();
            exports3.AssignmentPattern = AssignmentPattern;
            var AsyncArrowFunctionExpression = /* @__PURE__ */ function() {
              function AsyncArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression, this.id = null, this.params = params, this.body = body, this.generator = !1, this.expression = expression, this.async = !0;
              }
              return AsyncArrowFunctionExpression2;
            }();
            exports3.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
            var AsyncFunctionDeclaration = /* @__PURE__ */ function() {
              function AsyncFunctionDeclaration2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionDeclaration, this.id = id, this.params = params, this.body = body, this.generator = !1, this.expression = !1, this.async = !0;
              }
              return AsyncFunctionDeclaration2;
            }();
            exports3.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
            var AsyncFunctionExpression = /* @__PURE__ */ function() {
              function AsyncFunctionExpression2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionExpression, this.id = id, this.params = params, this.body = body, this.generator = !1, this.expression = !1, this.async = !0;
              }
              return AsyncFunctionExpression2;
            }();
            exports3.AsyncFunctionExpression = AsyncFunctionExpression;
            var AwaitExpression = /* @__PURE__ */ function() {
              function AwaitExpression2(argument) {
                this.type = syntax_1.Syntax.AwaitExpression, this.argument = argument;
              }
              return AwaitExpression2;
            }();
            exports3.AwaitExpression = AwaitExpression;
            var BinaryExpression = /* @__PURE__ */ function() {
              function BinaryExpression2(operator, left2, right2) {
                var logical = operator === "||" || operator === "&&";
                this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression, this.operator = operator, this.left = left2, this.right = right2;
              }
              return BinaryExpression2;
            }();
            exports3.BinaryExpression = BinaryExpression;
            var BlockStatement = /* @__PURE__ */ function() {
              function BlockStatement2(body) {
                this.type = syntax_1.Syntax.BlockStatement, this.body = body;
              }
              return BlockStatement2;
            }();
            exports3.BlockStatement = BlockStatement;
            var BreakStatement = /* @__PURE__ */ function() {
              function BreakStatement2(label) {
                this.type = syntax_1.Syntax.BreakStatement, this.label = label;
              }
              return BreakStatement2;
            }();
            exports3.BreakStatement = BreakStatement;
            var CallExpression = /* @__PURE__ */ function() {
              function CallExpression2(callee, args) {
                this.type = syntax_1.Syntax.CallExpression, this.callee = callee, this.arguments = args;
              }
              return CallExpression2;
            }();
            exports3.CallExpression = CallExpression;
            var CatchClause = /* @__PURE__ */ function() {
              function CatchClause2(param, body) {
                this.type = syntax_1.Syntax.CatchClause, this.param = param, this.body = body;
              }
              return CatchClause2;
            }();
            exports3.CatchClause = CatchClause;
            var ClassBody = /* @__PURE__ */ function() {
              function ClassBody2(body) {
                this.type = syntax_1.Syntax.ClassBody, this.body = body;
              }
              return ClassBody2;
            }();
            exports3.ClassBody = ClassBody;
            var ClassDeclaration = /* @__PURE__ */ function() {
              function ClassDeclaration2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassDeclaration, this.id = id, this.superClass = superClass, this.body = body;
              }
              return ClassDeclaration2;
            }();
            exports3.ClassDeclaration = ClassDeclaration;
            var ClassExpression = /* @__PURE__ */ function() {
              function ClassExpression2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassExpression, this.id = id, this.superClass = superClass, this.body = body;
              }
              return ClassExpression2;
            }();
            exports3.ClassExpression = ClassExpression;
            var ComputedMemberExpression = /* @__PURE__ */ function() {
              function ComputedMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression, this.computed = !0, this.object = object, this.property = property;
              }
              return ComputedMemberExpression2;
            }();
            exports3.ComputedMemberExpression = ComputedMemberExpression;
            var ConditionalExpression = /* @__PURE__ */ function() {
              function ConditionalExpression2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.ConditionalExpression, this.test = test, this.consequent = consequent, this.alternate = alternate;
              }
              return ConditionalExpression2;
            }();
            exports3.ConditionalExpression = ConditionalExpression;
            var ContinueStatement = /* @__PURE__ */ function() {
              function ContinueStatement2(label) {
                this.type = syntax_1.Syntax.ContinueStatement, this.label = label;
              }
              return ContinueStatement2;
            }();
            exports3.ContinueStatement = ContinueStatement;
            var DebuggerStatement = /* @__PURE__ */ function() {
              function DebuggerStatement2() {
                this.type = syntax_1.Syntax.DebuggerStatement;
              }
              return DebuggerStatement2;
            }();
            exports3.DebuggerStatement = DebuggerStatement;
            var Directive = /* @__PURE__ */ function() {
              function Directive2(expression, directive) {
                this.type = syntax_1.Syntax.ExpressionStatement, this.expression = expression, this.directive = directive;
              }
              return Directive2;
            }();
            exports3.Directive = Directive;
            var DoWhileStatement = /* @__PURE__ */ function() {
              function DoWhileStatement2(body, test) {
                this.type = syntax_1.Syntax.DoWhileStatement, this.body = body, this.test = test;
              }
              return DoWhileStatement2;
            }();
            exports3.DoWhileStatement = DoWhileStatement;
            var EmptyStatement = /* @__PURE__ */ function() {
              function EmptyStatement2() {
                this.type = syntax_1.Syntax.EmptyStatement;
              }
              return EmptyStatement2;
            }();
            exports3.EmptyStatement = EmptyStatement;
            var ExportAllDeclaration = /* @__PURE__ */ function() {
              function ExportAllDeclaration2(source2) {
                this.type = syntax_1.Syntax.ExportAllDeclaration, this.source = source2;
              }
              return ExportAllDeclaration2;
            }();
            exports3.ExportAllDeclaration = ExportAllDeclaration;
            var ExportDefaultDeclaration = /* @__PURE__ */ function() {
              function ExportDefaultDeclaration2(declaration) {
                this.type = syntax_1.Syntax.ExportDefaultDeclaration, this.declaration = declaration;
              }
              return ExportDefaultDeclaration2;
            }();
            exports3.ExportDefaultDeclaration = ExportDefaultDeclaration;
            var ExportNamedDeclaration = /* @__PURE__ */ function() {
              function ExportNamedDeclaration2(declaration, specifiers, source2) {
                this.type = syntax_1.Syntax.ExportNamedDeclaration, this.declaration = declaration, this.specifiers = specifiers, this.source = source2;
              }
              return ExportNamedDeclaration2;
            }();
            exports3.ExportNamedDeclaration = ExportNamedDeclaration;
            var ExportSpecifier = /* @__PURE__ */ function() {
              function ExportSpecifier2(local, exported) {
                this.type = syntax_1.Syntax.ExportSpecifier, this.exported = exported, this.local = local;
              }
              return ExportSpecifier2;
            }();
            exports3.ExportSpecifier = ExportSpecifier;
            var ExpressionStatement = /* @__PURE__ */ function() {
              function ExpressionStatement2(expression) {
                this.type = syntax_1.Syntax.ExpressionStatement, this.expression = expression;
              }
              return ExpressionStatement2;
            }();
            exports3.ExpressionStatement = ExpressionStatement;
            var ForInStatement = /* @__PURE__ */ function() {
              function ForInStatement2(left2, right2, body) {
                this.type = syntax_1.Syntax.ForInStatement, this.left = left2, this.right = right2, this.body = body, this.each = !1;
              }
              return ForInStatement2;
            }();
            exports3.ForInStatement = ForInStatement;
            var ForOfStatement = /* @__PURE__ */ function() {
              function ForOfStatement2(left2, right2, body) {
                this.type = syntax_1.Syntax.ForOfStatement, this.left = left2, this.right = right2, this.body = body;
              }
              return ForOfStatement2;
            }();
            exports3.ForOfStatement = ForOfStatement;
            var ForStatement = /* @__PURE__ */ function() {
              function ForStatement2(init, test, update, body) {
                this.type = syntax_1.Syntax.ForStatement, this.init = init, this.test = test, this.update = update, this.body = body;
              }
              return ForStatement2;
            }();
            exports3.ForStatement = ForStatement;
            var FunctionDeclaration = /* @__PURE__ */ function() {
              function FunctionDeclaration2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionDeclaration, this.id = id, this.params = params, this.body = body, this.generator = generator, this.expression = !1, this.async = !1;
              }
              return FunctionDeclaration2;
            }();
            exports3.FunctionDeclaration = FunctionDeclaration;
            var FunctionExpression = /* @__PURE__ */ function() {
              function FunctionExpression2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionExpression, this.id = id, this.params = params, this.body = body, this.generator = generator, this.expression = !1, this.async = !1;
              }
              return FunctionExpression2;
            }();
            exports3.FunctionExpression = FunctionExpression;
            var Identifier = /* @__PURE__ */ function() {
              function Identifier2(name) {
                this.type = syntax_1.Syntax.Identifier, this.name = name;
              }
              return Identifier2;
            }();
            exports3.Identifier = Identifier;
            var IfStatement = /* @__PURE__ */ function() {
              function IfStatement2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.IfStatement, this.test = test, this.consequent = consequent, this.alternate = alternate;
              }
              return IfStatement2;
            }();
            exports3.IfStatement = IfStatement;
            var ImportDeclaration = /* @__PURE__ */ function() {
              function ImportDeclaration2(specifiers, source2) {
                this.type = syntax_1.Syntax.ImportDeclaration, this.specifiers = specifiers, this.source = source2;
              }
              return ImportDeclaration2;
            }();
            exports3.ImportDeclaration = ImportDeclaration;
            var ImportDefaultSpecifier = /* @__PURE__ */ function() {
              function ImportDefaultSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportDefaultSpecifier, this.local = local;
              }
              return ImportDefaultSpecifier2;
            }();
            exports3.ImportDefaultSpecifier = ImportDefaultSpecifier;
            var ImportNamespaceSpecifier = /* @__PURE__ */ function() {
              function ImportNamespaceSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportNamespaceSpecifier, this.local = local;
              }
              return ImportNamespaceSpecifier2;
            }();
            exports3.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            var ImportSpecifier = /* @__PURE__ */ function() {
              function ImportSpecifier2(local, imported) {
                this.type = syntax_1.Syntax.ImportSpecifier, this.local = local, this.imported = imported;
              }
              return ImportSpecifier2;
            }();
            exports3.ImportSpecifier = ImportSpecifier;
            var LabeledStatement = /* @__PURE__ */ function() {
              function LabeledStatement2(label, body) {
                this.type = syntax_1.Syntax.LabeledStatement, this.label = label, this.body = body;
              }
              return LabeledStatement2;
            }();
            exports3.LabeledStatement = LabeledStatement;
            var Literal = /* @__PURE__ */ function() {
              function Literal2(value, raw) {
                this.type = syntax_1.Syntax.Literal, this.value = value, this.raw = raw;
              }
              return Literal2;
            }();
            exports3.Literal = Literal;
            var MetaProperty = /* @__PURE__ */ function() {
              function MetaProperty2(meta, property) {
                this.type = syntax_1.Syntax.MetaProperty, this.meta = meta, this.property = property;
              }
              return MetaProperty2;
            }();
            exports3.MetaProperty = MetaProperty;
            var MethodDefinition = /* @__PURE__ */ function() {
              function MethodDefinition2(key2, computed, value, kind, isStatic) {
                this.type = syntax_1.Syntax.MethodDefinition, this.key = key2, this.computed = computed, this.value = value, this.kind = kind, this.static = isStatic;
              }
              return MethodDefinition2;
            }();
            exports3.MethodDefinition = MethodDefinition;
            var Module2 = /* @__PURE__ */ function() {
              function Module3(body) {
                this.type = syntax_1.Syntax.Program, this.body = body, this.sourceType = "module";
              }
              return Module3;
            }();
            exports3.Module = Module2;
            var NewExpression = /* @__PURE__ */ function() {
              function NewExpression2(callee, args) {
                this.type = syntax_1.Syntax.NewExpression, this.callee = callee, this.arguments = args;
              }
              return NewExpression2;
            }();
            exports3.NewExpression = NewExpression;
            var ObjectExpression = /* @__PURE__ */ function() {
              function ObjectExpression2(properties) {
                this.type = syntax_1.Syntax.ObjectExpression, this.properties = properties;
              }
              return ObjectExpression2;
            }();
            exports3.ObjectExpression = ObjectExpression;
            var ObjectPattern = /* @__PURE__ */ function() {
              function ObjectPattern2(properties) {
                this.type = syntax_1.Syntax.ObjectPattern, this.properties = properties;
              }
              return ObjectPattern2;
            }();
            exports3.ObjectPattern = ObjectPattern;
            var Property = /* @__PURE__ */ function() {
              function Property2(kind, key2, computed, value, method, shorthand) {
                this.type = syntax_1.Syntax.Property, this.key = key2, this.computed = computed, this.value = value, this.kind = kind, this.method = method, this.shorthand = shorthand;
              }
              return Property2;
            }();
            exports3.Property = Property;
            var RegexLiteral = /* @__PURE__ */ function() {
              function RegexLiteral2(value, raw, pattern, flags) {
                this.type = syntax_1.Syntax.Literal, this.value = value, this.raw = raw, this.regex = { pattern, flags };
              }
              return RegexLiteral2;
            }();
            exports3.RegexLiteral = RegexLiteral;
            var RestElement = /* @__PURE__ */ function() {
              function RestElement2(argument) {
                this.type = syntax_1.Syntax.RestElement, this.argument = argument;
              }
              return RestElement2;
            }();
            exports3.RestElement = RestElement;
            var ReturnStatement = /* @__PURE__ */ function() {
              function ReturnStatement2(argument) {
                this.type = syntax_1.Syntax.ReturnStatement, this.argument = argument;
              }
              return ReturnStatement2;
            }();
            exports3.ReturnStatement = ReturnStatement;
            var Script = /* @__PURE__ */ function() {
              function Script2(body) {
                this.type = syntax_1.Syntax.Program, this.body = body, this.sourceType = "script";
              }
              return Script2;
            }();
            exports3.Script = Script;
            var SequenceExpression = /* @__PURE__ */ function() {
              function SequenceExpression2(expressions) {
                this.type = syntax_1.Syntax.SequenceExpression, this.expressions = expressions;
              }
              return SequenceExpression2;
            }();
            exports3.SequenceExpression = SequenceExpression;
            var SpreadElement = /* @__PURE__ */ function() {
              function SpreadElement2(argument) {
                this.type = syntax_1.Syntax.SpreadElement, this.argument = argument;
              }
              return SpreadElement2;
            }();
            exports3.SpreadElement = SpreadElement;
            var StaticMemberExpression = /* @__PURE__ */ function() {
              function StaticMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression, this.computed = !1, this.object = object, this.property = property;
              }
              return StaticMemberExpression2;
            }();
            exports3.StaticMemberExpression = StaticMemberExpression;
            var Super = /* @__PURE__ */ function() {
              function Super2() {
                this.type = syntax_1.Syntax.Super;
              }
              return Super2;
            }();
            exports3.Super = Super;
            var SwitchCase = /* @__PURE__ */ function() {
              function SwitchCase2(test, consequent) {
                this.type = syntax_1.Syntax.SwitchCase, this.test = test, this.consequent = consequent;
              }
              return SwitchCase2;
            }();
            exports3.SwitchCase = SwitchCase;
            var SwitchStatement = /* @__PURE__ */ function() {
              function SwitchStatement2(discriminant, cases) {
                this.type = syntax_1.Syntax.SwitchStatement, this.discriminant = discriminant, this.cases = cases;
              }
              return SwitchStatement2;
            }();
            exports3.SwitchStatement = SwitchStatement;
            var TaggedTemplateExpression = /* @__PURE__ */ function() {
              function TaggedTemplateExpression2(tag, quasi) {
                this.type = syntax_1.Syntax.TaggedTemplateExpression, this.tag = tag, this.quasi = quasi;
              }
              return TaggedTemplateExpression2;
            }();
            exports3.TaggedTemplateExpression = TaggedTemplateExpression;
            var TemplateElement = /* @__PURE__ */ function() {
              function TemplateElement2(value, tail) {
                this.type = syntax_1.Syntax.TemplateElement, this.value = value, this.tail = tail;
              }
              return TemplateElement2;
            }();
            exports3.TemplateElement = TemplateElement;
            var TemplateLiteral = /* @__PURE__ */ function() {
              function TemplateLiteral2(quasis, expressions) {
                this.type = syntax_1.Syntax.TemplateLiteral, this.quasis = quasis, this.expressions = expressions;
              }
              return TemplateLiteral2;
            }();
            exports3.TemplateLiteral = TemplateLiteral;
            var ThisExpression = /* @__PURE__ */ function() {
              function ThisExpression2() {
                this.type = syntax_1.Syntax.ThisExpression;
              }
              return ThisExpression2;
            }();
            exports3.ThisExpression = ThisExpression;
            var ThrowStatement = /* @__PURE__ */ function() {
              function ThrowStatement2(argument) {
                this.type = syntax_1.Syntax.ThrowStatement, this.argument = argument;
              }
              return ThrowStatement2;
            }();
            exports3.ThrowStatement = ThrowStatement;
            var TryStatement = /* @__PURE__ */ function() {
              function TryStatement2(block, handler, finalizer) {
                this.type = syntax_1.Syntax.TryStatement, this.block = block, this.handler = handler, this.finalizer = finalizer;
              }
              return TryStatement2;
            }();
            exports3.TryStatement = TryStatement;
            var UnaryExpression = /* @__PURE__ */ function() {
              function UnaryExpression2(operator, argument) {
                this.type = syntax_1.Syntax.UnaryExpression, this.operator = operator, this.argument = argument, this.prefix = !0;
              }
              return UnaryExpression2;
            }();
            exports3.UnaryExpression = UnaryExpression;
            var UpdateExpression = /* @__PURE__ */ function() {
              function UpdateExpression2(operator, argument, prefix) {
                this.type = syntax_1.Syntax.UpdateExpression, this.operator = operator, this.argument = argument, this.prefix = prefix;
              }
              return UpdateExpression2;
            }();
            exports3.UpdateExpression = UpdateExpression;
            var VariableDeclaration = /* @__PURE__ */ function() {
              function VariableDeclaration2(declarations, kind) {
                this.type = syntax_1.Syntax.VariableDeclaration, this.declarations = declarations, this.kind = kind;
              }
              return VariableDeclaration2;
            }();
            exports3.VariableDeclaration = VariableDeclaration;
            var VariableDeclarator = /* @__PURE__ */ function() {
              function VariableDeclarator2(id, init) {
                this.type = syntax_1.Syntax.VariableDeclarator, this.id = id, this.init = init;
              }
              return VariableDeclarator2;
            }();
            exports3.VariableDeclarator = VariableDeclarator;
            var WhileStatement = /* @__PURE__ */ function() {
              function WhileStatement2(test, body) {
                this.type = syntax_1.Syntax.WhileStatement, this.test = test, this.body = body;
              }
              return WhileStatement2;
            }();
            exports3.WhileStatement = WhileStatement;
            var WithStatement = /* @__PURE__ */ function() {
              function WithStatement2(object, body) {
                this.type = syntax_1.Syntax.WithStatement, this.object = object, this.body = body;
              }
              return WithStatement2;
            }();
            exports3.WithStatement = WithStatement;
            var YieldExpression = /* @__PURE__ */ function() {
              function YieldExpression2(argument, delegate) {
                this.type = syntax_1.Syntax.YieldExpression, this.argument = argument, this.delegate = delegate;
              }
              return YieldExpression2;
            }();
            exports3.YieldExpression = YieldExpression;
          },
          /* 8 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var assert_1 = __webpack_require__(9), error_handler_1 = __webpack_require__(10), messages_1 = __webpack_require__(11), Node2 = __webpack_require__(7), scanner_1 = __webpack_require__(12), syntax_1 = __webpack_require__(2), token_1 = __webpack_require__(13), ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder", Parser2 = function() {
              function Parser3(code, options2, delegate) {
                options2 === void 0 && (options2 = {}), this.config = {
                  range: typeof options2.range == "boolean" && options2.range,
                  loc: typeof options2.loc == "boolean" && options2.loc,
                  source: null,
                  tokens: typeof options2.tokens == "boolean" && options2.tokens,
                  comment: typeof options2.comment == "boolean" && options2.comment,
                  tolerant: typeof options2.tolerant == "boolean" && options2.tolerant
                }, this.config.loc && options2.source && options2.source !== null && (this.config.source = String(options2.source)), this.delegate = delegate, this.errorHandler = new error_handler_1.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new scanner_1.Scanner(code, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = {
                  ")": 0,
                  ";": 0,
                  ",": 0,
                  "=": 0,
                  "]": 0,
                  "||": 1,
                  "&&": 2,
                  "|": 3,
                  "^": 4,
                  "&": 5,
                  "==": 6,
                  "!=": 6,
                  "===": 6,
                  "!==": 6,
                  "<": 7,
                  ">": 7,
                  "<=": 7,
                  ">=": 7,
                  "<<": 8,
                  ">>": 8,
                  ">>>": 8,
                  "+": 9,
                  "-": 9,
                  "*": 11,
                  "/": 11,
                  "%": 11
                }, this.lookahead = {
                  type: 2,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: 0,
                  start: 0,
                  end: 0
                }, this.hasLineTerminator = !1, this.context = {
                  isModule: !1,
                  await: !1,
                  allowIn: !0,
                  allowStrictDirective: !0,
                  allowYield: !0,
                  firstCoverInitializedNameError: null,
                  isAssignmentTarget: !1,
                  isBindingElement: !1,
                  inFunctionBody: !1,
                  inIteration: !1,
                  inSwitch: !1,
                  labelSet: {},
                  strict: !1
                }, this.tokens = [], this.startMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                }, this.lastMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                }, this.nextToken(), this.lastMarker = {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }
              return Parser3.prototype.throwError = function(messageFormat) {
                var args = Array.prototype.slice.call(arguments, 1), msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                  return assert_1.assert(idx < args.length, "Message reference must be in range"), args[idx];
                }), index = this.lastMarker.index, line3 = this.lastMarker.line, column2 = this.lastMarker.column + 1;
                throw this.errorHandler.createError(index, line3, column2, msg);
              }, Parser3.prototype.tolerateError = function(messageFormat) {
                var args = Array.prototype.slice.call(arguments, 1), msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                  return assert_1.assert(idx < args.length, "Message reference must be in range"), args[idx];
                }), index = this.lastMarker.index, line3 = this.scanner.lineNumber, column2 = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(index, line3, column2, msg);
              }, Parser3.prototype.unexpectedTokenError = function(token2, message) {
                var msg = message || messages_1.Messages.UnexpectedToken, value;
                if (token2 ? (message || (msg = token2.type === 2 ? messages_1.Messages.UnexpectedEOS : token2.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token2.type === 6 ? messages_1.Messages.UnexpectedNumber : token2.type === 8 ? messages_1.Messages.UnexpectedString : token2.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken, token2.type === 4 && (this.scanner.isFutureReservedWord(token2.value) ? msg = messages_1.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(token2.value) && (msg = messages_1.Messages.StrictReservedWord))), value = token2.value) : value = "ILLEGAL", msg = msg.replace("%0", value), token2 && typeof token2.lineNumber == "number") {
                  var index = token2.start, line3 = token2.lineNumber, lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column, column2 = token2.start - lastMarkerLineStart + 1;
                  return this.errorHandler.createError(index, line3, column2, msg);
                } else {
                  var index = this.lastMarker.index, line3 = this.lastMarker.line, column2 = this.lastMarker.column + 1;
                  return this.errorHandler.createError(index, line3, column2, msg);
                }
              }, Parser3.prototype.throwUnexpectedToken = function(token2, message) {
                throw this.unexpectedTokenError(token2, message);
              }, Parser3.prototype.tolerateUnexpectedToken = function(token2, message) {
                this.errorHandler.tolerate(this.unexpectedTokenError(token2, message));
              }, Parser3.prototype.collectComments = function() {
                if (!this.config.comment)
                  this.scanner.scanComments();
                else {
                  var comments2 = this.scanner.scanComments();
                  if (comments2.length > 0 && this.delegate)
                    for (var i2 = 0; i2 < comments2.length; ++i2) {
                      var e = comments2[i2], node2 = void 0;
                      node2 = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
                      }, this.config.range && (node2.range = e.range), this.config.loc && (node2.loc = e.loc);
                      var metadata = {
                        start: {
                          line: e.loc.start.line,
                          column: e.loc.start.column,
                          offset: e.range[0]
                        },
                        end: {
                          line: e.loc.end.line,
                          column: e.loc.end.column,
                          offset: e.range[1]
                        }
                      };
                      this.delegate(node2, metadata);
                    }
                }
              }, Parser3.prototype.getTokenRaw = function(token2) {
                return this.scanner.source.slice(token2.start, token2.end);
              }, Parser3.prototype.convertToken = function(token2) {
                var t = {
                  type: token_1.TokenName[token2.type],
                  value: this.getTokenRaw(token2)
                };
                if (this.config.range && (t.range = [token2.start, token2.end]), this.config.loc && (t.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                }), token2.type === 9) {
                  var pattern = token2.pattern, flags = token2.flags;
                  t.regex = { pattern, flags };
                }
                return t;
              }, Parser3.prototype.nextToken = function() {
                var token2 = this.lookahead;
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart);
                var next = this.scanner.lex();
                return this.hasLineTerminator = token2.lineNumber !== next.lineNumber, next && this.context.strict && next.type === 3 && this.scanner.isStrictModeReservedWord(next.value) && (next.type = 4), this.lookahead = next, this.config.tokens && next.type !== 2 && this.tokens.push(this.convertToken(next)), token2;
              }, Parser3.prototype.nextRegexToken = function() {
                this.collectComments();
                var token2 = this.scanner.scanRegExp();
                return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(token2))), this.lookahead = token2, this.nextToken(), token2;
              }, Parser3.prototype.createNode = function() {
                return {
                  index: this.startMarker.index,
                  line: this.startMarker.line,
                  column: this.startMarker.column
                };
              }, Parser3.prototype.startNode = function(token2, lastLineStart) {
                lastLineStart === void 0 && (lastLineStart = 0);
                var column2 = token2.start - token2.lineStart, line3 = token2.lineNumber;
                return column2 < 0 && (column2 += lastLineStart, line3--), {
                  index: token2.start,
                  line: line3,
                  column: column2
                };
              }, Parser3.prototype.finalize = function(marker, node2) {
                if (this.config.range && (node2.range = [marker.index, this.lastMarker.index]), this.config.loc && (node2.loc = {
                  start: {
                    line: marker.line,
                    column: marker.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                }, this.config.source && (node2.loc.source = this.config.source)), this.delegate) {
                  var metadata = {
                    start: {
                      line: marker.line,
                      column: marker.column,
                      offset: marker.index
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column,
                      offset: this.lastMarker.index
                    }
                  };
                  this.delegate(node2, metadata);
                }
                return node2;
              }, Parser3.prototype.expect = function(value) {
                var token2 = this.nextToken();
                (token2.type !== 7 || token2.value !== value) && this.throwUnexpectedToken(token2);
              }, Parser3.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var token2 = this.lookahead;
                  token2.type === 7 && token2.value === "," ? this.nextToken() : token2.type === 7 && token2.value === ";" ? (this.nextToken(), this.tolerateUnexpectedToken(token2)) : this.tolerateUnexpectedToken(token2, messages_1.Messages.UnexpectedToken);
                } else
                  this.expect(",");
              }, Parser3.prototype.expectKeyword = function(keyword) {
                var token2 = this.nextToken();
                (token2.type !== 4 || token2.value !== keyword) && this.throwUnexpectedToken(token2);
              }, Parser3.prototype.match = function(value) {
                return this.lookahead.type === 7 && this.lookahead.value === value;
              }, Parser3.prototype.matchKeyword = function(keyword) {
                return this.lookahead.type === 4 && this.lookahead.value === keyword;
              }, Parser3.prototype.matchContextualKeyword = function(keyword) {
                return this.lookahead.type === 3 && this.lookahead.value === keyword;
              }, Parser3.prototype.matchAssign = function() {
                if (this.lookahead.type !== 7)
                  return !1;
                var op = this.lookahead.value;
                return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
              }, Parser3.prototype.isolateCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement, previousIsAssignmentTarget = this.context.isAssignmentTarget, previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                return this.context.firstCoverInitializedNameError !== null && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = previousIsBindingElement, this.context.isAssignmentTarget = previousIsAssignmentTarget, this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError, result;
              }, Parser3.prototype.inheritCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement, previousIsAssignmentTarget = this.context.isAssignmentTarget, previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                return this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement, this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget, this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError, result;
              }, Parser3.prototype.consumeSemicolon = function() {
                this.match(";") ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type !== 2 && !this.match("}") && this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column);
              }, Parser3.prototype.parsePrimaryExpression = function() {
                var node2 = this.createNode(), expr, token2, raw;
                switch (this.lookahead.type) {
                  case 3:
                    (this.context.isModule || this.context.await) && this.lookahead.value === "await" && this.tolerateUnexpectedToken(this.lookahead), expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node2, new Node2.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token2 = this.nextToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node2, new Node2.Literal(token2.value, raw));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token2 = this.nextToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node2, new Node2.Literal(token2.value === "true", raw));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, token2 = this.nextToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node2, new Node2.Literal(null, raw));
                    break;
                  case 10:
                    expr = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = !1, expr = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.scanner.index = this.startMarker.index, token2 = this.nextRegexToken(), raw = this.getTokenRaw(token2), expr = this.finalize(node2, new Node2.RegexLiteral(token2.regex, raw, token2.pattern, token2.flags));
                        break;
                      default:
                        expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    !this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? expr = this.parseIdentifierName() : !this.context.strict && this.matchKeyword("let") ? expr = this.finalize(node2, new Node2.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.matchKeyword("function") ? expr = this.parseFunctionExpression() : this.matchKeyword("this") ? (this.nextToken(), expr = this.finalize(node2, new Node2.ThisExpression())) : this.matchKeyword("class") ? expr = this.parseClassExpression() : expr = this.throwUnexpectedToken(this.nextToken()));
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                return expr;
              }, Parser3.prototype.parseSpreadElement = function() {
                var node2 = this.createNode();
                this.expect("...");
                var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(node2, new Node2.SpreadElement(arg));
              }, Parser3.prototype.parseArrayInitializer = function() {
                var node2 = this.createNode(), elements = [];
                for (this.expect("["); !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), elements.push(null);
                  else if (this.match("...")) {
                    var element = this.parseSpreadElement();
                    this.match("]") || (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.expect(",")), elements.push(element);
                  } else
                    elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(",");
                return this.expect("]"), this.finalize(node2, new Node2.ArrayExpression(elements));
              }, Parser3.prototype.parsePropertyMethod = function(params) {
                this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = params.simple;
                var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                return this.context.strict && params.firstRestricted && this.tolerateUnexpectedToken(params.firstRestricted, params.message), this.context.strict && params.stricted && this.tolerateUnexpectedToken(params.stricted, params.message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, body;
              }, Parser3.prototype.parsePropertyMethodFunction = function() {
                var isGenerator = !1, node2 = this.createNode(), previousAllowYield = this.context.allowYield;
                this.context.allowYield = !0;
                var params = this.parseFormalParameters(), method = this.parsePropertyMethod(params);
                return this.context.allowYield = previousAllowYield, this.finalize(node2, new Node2.FunctionExpression(null, params.params, method, isGenerator));
              }, Parser3.prototype.parsePropertyMethodAsyncFunction = function() {
                var node2 = this.createNode(), previousAllowYield = this.context.allowYield, previousAwait = this.context.await;
                this.context.allowYield = !1, this.context.await = !0;
                var params = this.parseFormalParameters(), method = this.parsePropertyMethod(params);
                return this.context.allowYield = previousAllowYield, this.context.await = previousAwait, this.finalize(node2, new Node2.AsyncFunctionExpression(null, params.params, method));
              }, Parser3.prototype.parseObjectPropertyKey = function() {
                var node2 = this.createNode(), token2 = this.nextToken(), key2;
                switch (token2.type) {
                  case 8:
                  case 6:
                    this.context.strict && token2.octal && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictOctalLiteral);
                    var raw = this.getTokenRaw(token2);
                    key2 = this.finalize(node2, new Node2.Literal(token2.value, raw));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    key2 = this.finalize(node2, new Node2.Identifier(token2.value));
                    break;
                  case 7:
                    token2.value === "[" ? (key2 = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : key2 = this.throwUnexpectedToken(token2);
                    break;
                  default:
                    key2 = this.throwUnexpectedToken(token2);
                }
                return key2;
              }, Parser3.prototype.isPropertyKey = function(key2, value) {
                return key2.type === syntax_1.Syntax.Identifier && key2.name === value || key2.type === syntax_1.Syntax.Literal && key2.value === value;
              }, Parser3.prototype.parseObjectProperty = function(hasProto) {
                var node2 = this.createNode(), token2 = this.lookahead, kind, key2 = null, value = null, computed = !1, method = !1, shorthand = !1, isAsync = !1;
                if (token2.type === 3) {
                  var id = token2.value;
                  this.nextToken(), computed = this.match("["), isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(","), key2 = isAsync ? this.parseObjectPropertyKey() : this.finalize(node2, new Node2.Identifier(id));
                } else this.match("*") ? this.nextToken() : (computed = this.match("["), key2 = this.parseObjectPropertyKey());
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token2.type === 3 && !isAsync && token2.value === "get" && lookaheadPropertyKey)
                  kind = "get", computed = this.match("["), key2 = this.parseObjectPropertyKey(), this.context.allowYield = !1, value = this.parseGetterMethod();
                else if (token2.type === 3 && !isAsync && token2.value === "set" && lookaheadPropertyKey)
                  kind = "set", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseSetterMethod();
                else if (token2.type === 7 && token2.value === "*" && lookaheadPropertyKey)
                  kind = "init", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseGeneratorMethod(), method = !0;
                else if (key2 || this.throwUnexpectedToken(this.lookahead), kind = "init", this.match(":") && !isAsync)
                  !computed && this.isPropertyKey(key2, "__proto__") && (hasProto.value && this.tolerateError(messages_1.Messages.DuplicateProtoProperty), hasProto.value = !0), this.nextToken(), value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                else if (this.match("("))
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), method = !0;
                else if (token2.type === 3) {
                  var id = this.finalize(node2, new Node2.Identifier(token2.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), shorthand = !0;
                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value = this.finalize(node2, new Node2.AssignmentPattern(id, init));
                  } else
                    shorthand = !0, value = id;
                } else
                  this.throwUnexpectedToken(this.nextToken());
                return this.finalize(node2, new Node2.Property(kind, key2, computed, value, method, shorthand));
              }, Parser3.prototype.parseObjectInitializer = function() {
                var node2 = this.createNode();
                this.expect("{");
                for (var properties = [], hasProto = { value: !1 }; !this.match("}"); )
                  properties.push(this.parseObjectProperty(hasProto)), this.match("}") || this.expectCommaSeparator();
                return this.expect("}"), this.finalize(node2, new Node2.ObjectExpression(properties));
              }, Parser3.prototype.parseTemplateHead = function() {
                assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
                var node2 = this.createNode(), token2 = this.nextToken(), raw = token2.value, cooked = token2.cooked;
                return this.finalize(node2, new Node2.TemplateElement({ raw, cooked }, token2.tail));
              }, Parser3.prototype.parseTemplateElement = function() {
                this.lookahead.type !== 10 && this.throwUnexpectedToken();
                var node2 = this.createNode(), token2 = this.nextToken(), raw = token2.value, cooked = token2.cooked;
                return this.finalize(node2, new Node2.TemplateElement({ raw, cooked }, token2.tail));
              }, Parser3.prototype.parseTemplateLiteral = function() {
                var node2 = this.createNode(), expressions = [], quasis = [], quasi = this.parseTemplateHead();
                for (quasis.push(quasi); !quasi.tail; )
                  expressions.push(this.parseExpression()), quasi = this.parseTemplateElement(), quasis.push(quasi);
                return this.finalize(node2, new Node2.TemplateLiteral(quasis, expressions));
              }, Parser3.prototype.reinterpretExpressionAsPattern = function(expr) {
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                  case syntax_1.Syntax.MemberExpression:
                  case syntax_1.Syntax.RestElement:
                  case syntax_1.Syntax.AssignmentPattern:
                    break;
                  case syntax_1.Syntax.SpreadElement:
                    expr.type = syntax_1.Syntax.RestElement, this.reinterpretExpressionAsPattern(expr.argument);
                    break;
                  case syntax_1.Syntax.ArrayExpression:
                    expr.type = syntax_1.Syntax.ArrayPattern;
                    for (var i2 = 0; i2 < expr.elements.length; i2++)
                      expr.elements[i2] !== null && this.reinterpretExpressionAsPattern(expr.elements[i2]);
                    break;
                  case syntax_1.Syntax.ObjectExpression:
                    expr.type = syntax_1.Syntax.ObjectPattern;
                    for (var i2 = 0; i2 < expr.properties.length; i2++)
                      this.reinterpretExpressionAsPattern(expr.properties[i2].value);
                    break;
                  case syntax_1.Syntax.AssignmentExpression:
                    expr.type = syntax_1.Syntax.AssignmentPattern, delete expr.operator, this.reinterpretExpressionAsPattern(expr.left);
                    break;
                }
              }, Parser3.prototype.parseGroupExpression = function() {
                var expr;
                if (this.expect("("), this.match(")"))
                  this.nextToken(), this.match("=>") || this.expect("=>"), expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [],
                    async: !1
                  };
                else {
                  var startToken = this.lookahead, params = [];
                  if (this.match("..."))
                    expr = this.parseRestElement(params), this.expect(")"), this.match("=>") || this.expect("=>"), expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [expr],
                      async: !1
                    };
                  else {
                    var arrow4 = !1;
                    if (this.context.isBindingElement = !0, expr = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) {
                      var expressions = [];
                      for (this.context.isAssignmentTarget = !1, expressions.push(expr); this.lookahead.type !== 2 && this.match(","); ) {
                        if (this.nextToken(), this.match(")")) {
                          this.nextToken();
                          for (var i2 = 0; i2 < expressions.length; i2++)
                            this.reinterpretExpressionAsPattern(expressions[i2]);
                          arrow4 = !0, expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: !1
                          };
                        } else if (this.match("...")) {
                          this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), expressions.push(this.parseRestElement(params)), this.expect(")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = !1;
                          for (var i2 = 0; i2 < expressions.length; i2++)
                            this.reinterpretExpressionAsPattern(expressions[i2]);
                          arrow4 = !0, expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: !1
                          };
                        } else
                          expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        if (arrow4)
                          break;
                      }
                      arrow4 || (expr = this.finalize(this.startNode(startToken), new Node2.SequenceExpression(expressions)));
                    }
                    if (!arrow4) {
                      if (this.expect(")"), this.match("=>") && (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield" && (arrow4 = !0, expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [expr],
                        async: !1
                      }), !arrow4)) {
                        if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), expr.type === syntax_1.Syntax.SequenceExpression)
                          for (var i2 = 0; i2 < expr.expressions.length; i2++)
                            this.reinterpretExpressionAsPattern(expr.expressions[i2]);
                        else
                          this.reinterpretExpressionAsPattern(expr);
                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: parameters,
                          async: !1
                        };
                      }
                      this.context.isBindingElement = !1;
                    }
                  }
                }
                return expr;
              }, Parser3.prototype.parseArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (args.push(expr), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                      break;
                  }
                return this.expect(")"), args;
              }, Parser3.prototype.isIdentifierName = function(token2) {
                return token2.type === 3 || token2.type === 4 || token2.type === 1 || token2.type === 5;
              }, Parser3.prototype.parseIdentifierName = function() {
                var node2 = this.createNode(), token2 = this.nextToken();
                return this.isIdentifierName(token2) || this.throwUnexpectedToken(token2), this.finalize(node2, new Node2.Identifier(token2.value));
              }, Parser3.prototype.parseNewExpression = function() {
                var node2 = this.createNode(), id = this.parseIdentifierName();
                assert_1.assert(id.name === "new", "New expression must start with `new`");
                var expr;
                if (this.match("."))
                  if (this.nextToken(), this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                    var property = this.parseIdentifierName();
                    expr = new Node2.MetaProperty(id, property);
                  } else
                    this.throwUnexpectedToken(this.lookahead);
                else {
                  var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression), args = this.match("(") ? this.parseArguments() : [];
                  expr = new Node2.NewExpression(callee, args), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                }
                return this.finalize(node2, expr);
              }, Parser3.prototype.parseAsyncArgument = function() {
                var arg = this.parseAssignmentExpression();
                return this.context.firstCoverInitializedNameError = null, arg;
              }, Parser3.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                    if (args.push(expr), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                      break;
                  }
                return this.expect(")"), args;
              }, Parser3.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var startToken = this.lookahead, maybeAsync = this.matchContextualKeyword("async"), previousAllowIn = this.context.allowIn;
                this.context.allowIn = !0;
                var expr;
                for (this.matchKeyword("super") && this.context.inFunctionBody ? (expr = this.createNode(), this.nextToken(), expr = this.finalize(expr, new Node2.Super()), !this.match("(") && !this.match(".") && !this.match("[") && this.throwUnexpectedToken(this.lookahead)) : expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match(".")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(this.startNode(startToken), new Node2.StaticMemberExpression(expr, property));
                  } else if (this.match("(")) {
                    var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !1;
                    var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                    if (expr = this.finalize(this.startNode(startToken), new Node2.CallExpression(expr, args)), asyncArrow && this.match("=>")) {
                      for (var i2 = 0; i2 < args.length; ++i2)
                        this.reinterpretExpressionAsPattern(args[i2]);
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: args,
                        async: !0
                      };
                    }
                  } else if (this.match("[")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]"), expr = this.finalize(this.startNode(startToken), new Node2.ComputedMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(this.startNode(startToken), new Node2.TaggedTemplateExpression(expr, quasi));
                  } else
                    break;
                return this.context.allowIn = previousAllowIn, expr;
              }, Parser3.prototype.parseSuper = function() {
                var node2 = this.createNode();
                return this.expectKeyword("super"), !this.match("[") && !this.match(".") && this.throwUnexpectedToken(this.lookahead), this.finalize(node2, new Node2.Super());
              }, Parser3.prototype.parseLeftHandSideExpression = function() {
                assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                for (var node2 = this.startNode(this.lookahead), expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match("[")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]"), expr = this.finalize(node2, new Node2.ComputedMemberExpression(expr, property));
                  } else if (this.match(".")) {
                    this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(node2, new Node2.StaticMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(node2, new Node2.TaggedTemplateExpression(expr, quasi));
                  } else
                    break;
                return expr;
              }, Parser3.prototype.parseUpdateExpression = function() {
                var expr, startToken = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var node2 = this.startNode(startToken), token2 = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name) && this.tolerateError(messages_1.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  var prefix = !0;
                  expr = this.finalize(node2, new Node2.UpdateExpression(token2.value, expr, prefix)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                } else if (expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.type === 7 && (this.match("++") || this.match("--"))) {
                  this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name) && this.tolerateError(messages_1.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  var operator = this.nextToken().value, prefix = !1;
                  expr = this.finalize(this.startNode(startToken), new Node2.UpdateExpression(operator, expr, prefix));
                }
                return expr;
              }, Parser3.prototype.parseAwaitExpression = function() {
                var node2 = this.createNode();
                this.nextToken();
                var argument = this.parseUnaryExpression();
                return this.finalize(node2, new Node2.AwaitExpression(argument));
              }, Parser3.prototype.parseUnaryExpression = function() {
                var expr;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var node2 = this.startNode(this.lookahead), token2 = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression), expr = this.finalize(node2, new Node2.UnaryExpression(token2.value, expr)), this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier && this.tolerateError(messages_1.Messages.StrictDelete), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                } else this.context.await && this.matchContextualKeyword("await") ? expr = this.parseAwaitExpression() : expr = this.parseUpdateExpression();
                return expr;
              }, Parser3.prototype.parseExponentiationExpression = function() {
                var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  var left2 = expr, right2 = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  expr = this.finalize(this.startNode(startToken), new Node2.BinaryExpression("**", left2, right2));
                }
                return expr;
              }, Parser3.prototype.binaryPrecedence = function(token2) {
                var op = token2.value, precedence;
                return token2.type === 7 ? precedence = this.operatorPrecedence[op] || 0 : token2.type === 4 ? precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0 : precedence = 0, precedence;
              }, Parser3.prototype.parseBinaryExpression = function() {
                var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseExponentiationExpression), token2 = this.lookahead, prec = this.binaryPrecedence(token2);
                if (prec > 0) {
                  this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  for (var markers = [startToken, this.lookahead], left2 = expr, right2 = this.isolateCoverGrammar(this.parseExponentiationExpression), stack2 = [left2, token2.value, right2], precedences = [prec]; prec = this.binaryPrecedence(this.lookahead), !(prec <= 0); ) {
                    for (; stack2.length > 2 && prec <= precedences[precedences.length - 1]; ) {
                      right2 = stack2.pop();
                      var operator = stack2.pop();
                      precedences.pop(), left2 = stack2.pop(), markers.pop();
                      var node2 = this.startNode(markers[markers.length - 1]);
                      stack2.push(this.finalize(node2, new Node2.BinaryExpression(operator, left2, right2)));
                    }
                    stack2.push(this.nextToken().value), precedences.push(prec), markers.push(this.lookahead), stack2.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var i2 = stack2.length - 1;
                  expr = stack2[i2];
                  for (var lastMarker = markers.pop(); i2 > 1; ) {
                    var marker = markers.pop(), lastLineStart = lastMarker && lastMarker.lineStart, node2 = this.startNode(marker, lastLineStart), operator = stack2[i2 - 1];
                    expr = this.finalize(node2, new Node2.BinaryExpression(operator, stack2[i2 - 2], expr)), i2 -= 2, lastMarker = marker;
                  }
                }
                return expr;
              }, Parser3.prototype.parseConditionalExpression = function() {
                var startToken = this.lookahead, expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = !0;
                  var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn, this.expect(":");
                  var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node2.ConditionalExpression(expr, consequent, alternate)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                }
                return expr;
              }, Parser3.prototype.checkPatternParam = function(options2, param) {
                switch (param.type) {
                  case syntax_1.Syntax.Identifier:
                    this.validateParam(options2, param, param.name);
                    break;
                  case syntax_1.Syntax.RestElement:
                    this.checkPatternParam(options2, param.argument);
                    break;
                  case syntax_1.Syntax.AssignmentPattern:
                    this.checkPatternParam(options2, param.left);
                    break;
                  case syntax_1.Syntax.ArrayPattern:
                    for (var i2 = 0; i2 < param.elements.length; i2++)
                      param.elements[i2] !== null && this.checkPatternParam(options2, param.elements[i2]);
                    break;
                  case syntax_1.Syntax.ObjectPattern:
                    for (var i2 = 0; i2 < param.properties.length; i2++)
                      this.checkPatternParam(options2, param.properties[i2].value);
                    break;
                }
                options2.simple = options2.simple && param instanceof Node2.Identifier;
              }, Parser3.prototype.reinterpretAsCoverFormalsList = function(expr) {
                var params = [expr], options2, asyncArrow = !1;
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                    break;
                  case ArrowParameterPlaceHolder:
                    params = expr.params, asyncArrow = expr.async;
                    break;
                  default:
                    return null;
                }
                options2 = {
                  simple: !0,
                  paramSet: {}
                };
                for (var i2 = 0; i2 < params.length; ++i2) {
                  var param = params[i2];
                  param.type === syntax_1.Syntax.AssignmentPattern ? param.right.type === syntax_1.Syntax.YieldExpression && (param.right.argument && this.throwUnexpectedToken(this.lookahead), param.right.type = syntax_1.Syntax.Identifier, param.right.name = "yield", delete param.right.argument, delete param.right.delegate) : asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await" && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(options2, param), params[i2] = param;
                }
                if (this.context.strict || !this.context.allowYield)
                  for (var i2 = 0; i2 < params.length; ++i2) {
                    var param = params[i2];
                    param.type === syntax_1.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead);
                  }
                if (options2.message === messages_1.Messages.StrictParamDupe) {
                  var token2 = this.context.strict ? options2.stricted : options2.firstRestricted;
                  this.throwUnexpectedToken(token2, options2.message);
                }
                return {
                  simple: options2.simple,
                  params,
                  stricted: options2.stricted,
                  firstRestricted: options2.firstRestricted,
                  message: options2.message
                };
              }, Parser3.prototype.parseAssignmentExpression = function() {
                var expr;
                if (!this.context.allowYield && this.matchKeyword("yield"))
                  expr = this.parseYieldExpression();
                else {
                  var startToken = this.lookahead, token2 = startToken;
                  if (expr = this.parseConditionalExpression(), token2.type === 3 && token2.lineNumber === this.lookahead.lineNumber && token2.value === "async" && (this.lookahead.type === 3 || this.matchKeyword("yield"))) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg), expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [arg],
                      async: !0
                    };
                  }
                  if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                    this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                    var isAsync = expr.async, list2 = this.reinterpretAsCoverFormalsList(expr);
                    if (list2) {
                      this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null;
                      var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = list2.simple;
                      var previousAllowYield = this.context.allowYield, previousAwait = this.context.await;
                      this.context.allowYield = !0, this.context.await = isAsync;
                      var node2 = this.startNode(startToken);
                      this.expect("=>");
                      var body = void 0;
                      if (this.match("{")) {
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = !0, body = this.parseFunctionSourceElements(), this.context.allowIn = previousAllowIn;
                      } else
                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      var expression = body.type !== syntax_1.Syntax.BlockStatement;
                      this.context.strict && list2.firstRestricted && this.throwUnexpectedToken(list2.firstRestricted, list2.message), this.context.strict && list2.stricted && this.tolerateUnexpectedToken(list2.stricted, list2.message), expr = isAsync ? this.finalize(node2, new Node2.AsyncArrowFunctionExpression(list2.params, body, expression)) : this.finalize(node2, new Node2.ArrowFunctionExpression(list2.params, body, expression)), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.allowYield = previousAllowYield, this.context.await = previousAwait;
                    }
                  } else if (this.matchAssign()) {
                    if (this.context.isAssignmentTarget || this.tolerateError(messages_1.Messages.InvalidLHSInAssignment), this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                      var id = expr;
                      this.scanner.isRestrictedWord(id.name) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(id.name) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord);
                    }
                    this.match("=") ? this.reinterpretExpressionAsPattern(expr) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1), token2 = this.nextToken();
                    var operator = token2.value, right2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node2.AssignmentExpression(operator, expr, right2)), this.context.firstCoverInitializedNameError = null;
                  }
                }
                return expr;
              }, Parser3.prototype.parseExpression = function() {
                var startToken = this.lookahead, expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  for (expressions.push(expr); this.lookahead.type !== 2 && this.match(","); )
                    this.nextToken(), expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  expr = this.finalize(this.startNode(startToken), new Node2.SequenceExpression(expressions));
                }
                return expr;
              }, Parser3.prototype.parseStatementListItem = function() {
                var statement;
                if (this.context.isAssignmentTarget = !0, this.context.isBindingElement = !0, this.lookahead.type === 4)
                  switch (this.lookahead.value) {
                    case "export":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration), statement = this.parseExportDeclaration();
                      break;
                    case "import":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration), statement = this.parseImportDeclaration();
                      break;
                    case "const":
                      statement = this.parseLexicalDeclaration({ inFor: !1 });
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "class":
                      statement = this.parseClassDeclaration();
                      break;
                    case "let":
                      statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: !1 }) : this.parseStatement();
                      break;
                    default:
                      statement = this.parseStatement();
                      break;
                  }
                else
                  statement = this.parseStatement();
                return statement;
              }, Parser3.prototype.parseBlock = function() {
                var node2 = this.createNode();
                this.expect("{");
                for (var block = []; !this.match("}"); )
                  block.push(this.parseStatementListItem());
                return this.expect("}"), this.finalize(node2, new Node2.BlockStatement(block));
              }, Parser3.prototype.parseLexicalBinding = function(kind, options2) {
                var node2 = this.createNode(), params = [], id = this.parsePattern(params, kind);
                this.context.strict && id.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(id.name) && this.tolerateError(messages_1.Messages.StrictVarName);
                var init = null;
                return kind === "const" ? !this.matchKeyword("in") && !this.matchContextualKeyword("of") && (this.match("=") ? (this.nextToken(), init = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const")) : (!options2.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) && (this.expect("="), init = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(node2, new Node2.VariableDeclarator(id, init));
              }, Parser3.prototype.parseBindingList = function(kind, options2) {
                for (var list2 = [this.parseLexicalBinding(kind, options2)]; this.match(","); )
                  this.nextToken(), list2.push(this.parseLexicalBinding(kind, options2));
                return list2;
              }, Parser3.prototype.isLexicalDeclaration = function() {
                var state2 = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                return this.scanner.restoreState(state2), next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
              }, Parser3.prototype.parseLexicalDeclaration = function(options2) {
                var node2 = this.createNode(), kind = this.nextToken().value;
                assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                var declarations = this.parseBindingList(kind, options2);
                return this.consumeSemicolon(), this.finalize(node2, new Node2.VariableDeclaration(declarations, kind));
              }, Parser3.prototype.parseBindingRestElement = function(params, kind) {
                var node2 = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params, kind);
                return this.finalize(node2, new Node2.RestElement(arg));
              }, Parser3.prototype.parseArrayPattern = function(params, kind) {
                var node2 = this.createNode();
                this.expect("[");
                for (var elements = []; !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), elements.push(null);
                  else {
                    if (this.match("...")) {
                      elements.push(this.parseBindingRestElement(params, kind));
                      break;
                    } else
                      elements.push(this.parsePatternWithDefault(params, kind));
                    this.match("]") || this.expect(",");
                  }
                return this.expect("]"), this.finalize(node2, new Node2.ArrayPattern(elements));
              }, Parser3.prototype.parsePropertyPattern = function(params, kind) {
                var node2 = this.createNode(), computed = !1, shorthand = !1, method = !1, key2, value;
                if (this.lookahead.type === 3) {
                  var keyToken = this.lookahead;
                  key2 = this.parseVariableIdentifier();
                  var init = this.finalize(node2, new Node2.Identifier(keyToken.value));
                  if (this.match("=")) {
                    params.push(keyToken), shorthand = !0, this.nextToken();
                    var expr = this.parseAssignmentExpression();
                    value = this.finalize(this.startNode(keyToken), new Node2.AssignmentPattern(init, expr));
                  } else this.match(":") ? (this.expect(":"), value = this.parsePatternWithDefault(params, kind)) : (params.push(keyToken), shorthand = !0, value = init);
                } else
                  computed = this.match("["), key2 = this.parseObjectPropertyKey(), this.expect(":"), value = this.parsePatternWithDefault(params, kind);
                return this.finalize(node2, new Node2.Property("init", key2, computed, value, method, shorthand));
              }, Parser3.prototype.parseObjectPattern = function(params, kind) {
                var node2 = this.createNode(), properties = [];
                for (this.expect("{"); !this.match("}"); )
                  properties.push(this.parsePropertyPattern(params, kind)), this.match("}") || this.expect(",");
                return this.expect("}"), this.finalize(node2, new Node2.ObjectPattern(properties));
              }, Parser3.prototype.parsePattern = function(params, kind) {
                var pattern;
                return this.match("[") ? pattern = this.parseArrayPattern(params, kind) : this.match("{") ? pattern = this.parseObjectPattern(params, kind) : (this.matchKeyword("let") && (kind === "const" || kind === "let") && this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding), params.push(this.lookahead), pattern = this.parseVariableIdentifier(kind)), pattern;
              }, Parser3.prototype.parsePatternWithDefault = function(params, kind) {
                var startToken = this.lookahead, pattern = this.parsePattern(params, kind);
                if (this.match("=")) {
                  this.nextToken();
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = !0;
                  var right2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = previousAllowYield, pattern = this.finalize(this.startNode(startToken), new Node2.AssignmentPattern(pattern, right2));
                }
                return pattern;
              }, Parser3.prototype.parseVariableIdentifier = function(kind) {
                var node2 = this.createNode(), token2 = this.nextToken();
                return token2.type === 4 && token2.value === "yield" ? this.context.strict ? this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord) : this.context.allowYield || this.throwUnexpectedToken(token2) : token2.type !== 3 ? this.context.strict && token2.type === 4 && this.scanner.isStrictModeReservedWord(token2.value) ? this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord) : (this.context.strict || token2.value !== "let" || kind !== "var") && this.throwUnexpectedToken(token2) : (this.context.isModule || this.context.await) && token2.type === 3 && token2.value === "await" && this.tolerateUnexpectedToken(token2), this.finalize(node2, new Node2.Identifier(token2.value));
              }, Parser3.prototype.parseVariableDeclaration = function(options2) {
                var node2 = this.createNode(), params = [], id = this.parsePattern(params, "var");
                this.context.strict && id.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(id.name) && this.tolerateError(messages_1.Messages.StrictVarName);
                var init = null;
                return this.match("=") ? (this.nextToken(), init = this.isolateCoverGrammar(this.parseAssignmentExpression)) : id.type !== syntax_1.Syntax.Identifier && !options2.inFor && this.expect("="), this.finalize(node2, new Node2.VariableDeclarator(id, init));
              }, Parser3.prototype.parseVariableDeclarationList = function(options2) {
                var opt = { inFor: options2.inFor }, list2 = [];
                for (list2.push(this.parseVariableDeclaration(opt)); this.match(","); )
                  this.nextToken(), list2.push(this.parseVariableDeclaration(opt));
                return list2;
              }, Parser3.prototype.parseVariableStatement = function() {
                var node2 = this.createNode();
                this.expectKeyword("var");
                var declarations = this.parseVariableDeclarationList({ inFor: !1 });
                return this.consumeSemicolon(), this.finalize(node2, new Node2.VariableDeclaration(declarations, "var"));
              }, Parser3.prototype.parseEmptyStatement = function() {
                var node2 = this.createNode();
                return this.expect(";"), this.finalize(node2, new Node2.EmptyStatement());
              }, Parser3.prototype.parseExpressionStatement = function() {
                var node2 = this.createNode(), expr = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(node2, new Node2.ExpressionStatement(expr));
              }, Parser3.prototype.parseIfClause = function() {
                return this.context.strict && this.matchKeyword("function") && this.tolerateError(messages_1.Messages.StrictFunction), this.parseStatement();
              }, Parser3.prototype.parseIfStatement = function() {
                var node2 = this.createNode(), consequent, alternate = null;
                this.expectKeyword("if"), this.expect("(");
                var test = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), consequent = this.finalize(this.createNode(), new Node2.EmptyStatement())) : (this.expect(")"), consequent = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), alternate = this.parseIfClause())), this.finalize(node2, new Node2.IfStatement(test, consequent, alternate));
              }, Parser3.prototype.parseDoWhileStatement = function() {
                var node2 = this.createNode();
                this.expectKeyword("do");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = !0;
                var body = this.parseStatement();
                this.context.inIteration = previousInIteration, this.expectKeyword("while"), this.expect("(");
                var test = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(")"), this.match(";") && this.nextToken()), this.finalize(node2, new Node2.DoWhileStatement(body, test));
              }, Parser3.prototype.parseWhileStatement = function() {
                var node2 = this.createNode(), body;
                this.expectKeyword("while"), this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node2.EmptyStatement());
                else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = !0, body = this.parseStatement(), this.context.inIteration = previousInIteration;
                }
                return this.finalize(node2, new Node2.WhileStatement(test, body));
              }, Parser3.prototype.parseForStatement = function() {
                var init = null, test = null, update = null, forIn = !0, left2, right2, node2 = this.createNode();
                if (this.expectKeyword("for"), this.expect("("), this.match(";"))
                  this.nextToken();
                else if (this.matchKeyword("var")) {
                  init = this.createNode(), this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = !1;
                  var declarations = this.parseVariableDeclarationList({ inFor: !0 });
                  if (this.context.allowIn = previousAllowIn, declarations.length === 1 && this.matchKeyword("in")) {
                    var decl = declarations[0];
                    decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in"), init = this.finalize(init, new Node2.VariableDeclaration(declarations, "var")), this.nextToken(), left2 = init, right2 = this.parseExpression(), init = null;
                  } else declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of") ? (init = this.finalize(init, new Node2.VariableDeclaration(declarations, "var")), this.nextToken(), left2 = init, right2 = this.parseAssignmentExpression(), init = null, forIn = !1) : (init = this.finalize(init, new Node2.VariableDeclaration(declarations, "var")), this.expect(";"));
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  init = this.createNode();
                  var kind = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in")
                    init = this.finalize(init, new Node2.Identifier(kind)), this.nextToken(), left2 = init, right2 = this.parseExpression(), init = null;
                  else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = !1;
                    var declarations = this.parseBindingList(kind, { inFor: !0 });
                    this.context.allowIn = previousAllowIn, declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in") ? (init = this.finalize(init, new Node2.VariableDeclaration(declarations, kind)), this.nextToken(), left2 = init, right2 = this.parseExpression(), init = null) : declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of") ? (init = this.finalize(init, new Node2.VariableDeclaration(declarations, kind)), this.nextToken(), left2 = init, right2 = this.parseAssignmentExpression(), init = null, forIn = !1) : (this.consumeSemicolon(), init = this.finalize(init, new Node2.VariableDeclaration(declarations, kind)));
                  }
                } else {
                  var initStartToken = this.lookahead, previousAllowIn = this.context.allowIn;
                  if (this.context.allowIn = !1, init = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = previousAllowIn, this.matchKeyword("in"))
                    (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) && this.tolerateError(messages_1.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(init), left2 = init, right2 = this.parseExpression(), init = null;
                  else if (this.matchContextualKeyword("of"))
                    (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) && this.tolerateError(messages_1.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(init), left2 = init, right2 = this.parseAssignmentExpression(), init = null, forIn = !1;
                  else {
                    if (this.match(",")) {
                      for (var initSeq = [init]; this.match(","); )
                        this.nextToken(), initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      init = this.finalize(this.startNode(initStartToken), new Node2.SequenceExpression(initSeq));
                    }
                    this.expect(";");
                  }
                }
                typeof left2 > "u" && (this.match(";") || (test = this.parseExpression()), this.expect(";"), this.match(")") || (update = this.parseExpression()));
                var body;
                if (!this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node2.EmptyStatement());
                else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = !0, body = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = previousInIteration;
                }
                return typeof left2 > "u" ? this.finalize(node2, new Node2.ForStatement(init, test, update, body)) : forIn ? this.finalize(node2, new Node2.ForInStatement(left2, right2, body)) : this.finalize(node2, new Node2.ForOfStatement(left2, right2, body));
              }, Parser3.prototype.parseContinueStatement = function() {
                var node2 = this.createNode();
                this.expectKeyword("continue");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  label = id;
                  var key2 = "$" + id.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, key2) || this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
                return this.consumeSemicolon(), label === null && !this.context.inIteration && this.throwError(messages_1.Messages.IllegalContinue), this.finalize(node2, new Node2.ContinueStatement(label));
              }, Parser3.prototype.parseBreakStatement = function() {
                var node2 = this.createNode();
                this.expectKeyword("break");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier(), key2 = "$" + id.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, key2) || this.throwError(messages_1.Messages.UnknownLabel, id.name), label = id;
                }
                return this.consumeSemicolon(), label === null && !this.context.inIteration && !this.context.inSwitch && this.throwError(messages_1.Messages.IllegalBreak), this.finalize(node2, new Node2.BreakStatement(label));
              }, Parser3.prototype.parseReturnStatement = function() {
                this.context.inFunctionBody || this.tolerateError(messages_1.Messages.IllegalReturn);
                var node2 = this.createNode();
                this.expectKeyword("return");
                var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10, argument = hasArgument ? this.parseExpression() : null;
                return this.consumeSemicolon(), this.finalize(node2, new Node2.ReturnStatement(argument));
              }, Parser3.prototype.parseWithStatement = function() {
                this.context.strict && this.tolerateError(messages_1.Messages.StrictModeWith);
                var node2 = this.createNode(), body;
                this.expectKeyword("with"), this.expect("(");
                var object = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), body = this.finalize(this.createNode(), new Node2.EmptyStatement())) : (this.expect(")"), body = this.parseStatement()), this.finalize(node2, new Node2.WithStatement(object, body));
              }, Parser3.prototype.parseSwitchCase = function() {
                var node2 = this.createNode(), test;
                this.matchKeyword("default") ? (this.nextToken(), test = null) : (this.expectKeyword("case"), test = this.parseExpression()), this.expect(":");
                for (var consequent = []; !(this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")); )
                  consequent.push(this.parseStatementListItem());
                return this.finalize(node2, new Node2.SwitchCase(test, consequent));
              }, Parser3.prototype.parseSwitchStatement = function() {
                var node2 = this.createNode();
                this.expectKeyword("switch"), this.expect("(");
                var discriminant = this.parseExpression();
                this.expect(")");
                var previousInSwitch = this.context.inSwitch;
                this.context.inSwitch = !0;
                var cases = [], defaultFound = !1;
                for (this.expect("{"); !this.match("}"); ) {
                  var clause = this.parseSwitchCase();
                  clause.test === null && (defaultFound && this.throwError(messages_1.Messages.MultipleDefaultsInSwitch), defaultFound = !0), cases.push(clause);
                }
                return this.expect("}"), this.context.inSwitch = previousInSwitch, this.finalize(node2, new Node2.SwitchStatement(discriminant, cases));
              }, Parser3.prototype.parseLabelledStatement = function() {
                var node2 = this.createNode(), expr = this.parseExpression(), statement;
                if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var id = expr, key2 = "$" + id.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, key2) && this.throwError(messages_1.Messages.Redeclaration, "Label", id.name), this.context.labelSet[key2] = !0;
                  var body = void 0;
                  if (this.matchKeyword("class"))
                    this.tolerateUnexpectedToken(this.lookahead), body = this.parseClassDeclaration();
                  else if (this.matchKeyword("function")) {
                    var token2 = this.lookahead, declaration = this.parseFunctionDeclaration();
                    this.context.strict ? this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunction) : declaration.generator && this.tolerateUnexpectedToken(token2, messages_1.Messages.GeneratorInLegacyContext), body = declaration;
                  } else
                    body = this.parseStatement();
                  delete this.context.labelSet[key2], statement = new Node2.LabeledStatement(id, body);
                } else
                  this.consumeSemicolon(), statement = new Node2.ExpressionStatement(expr);
                return this.finalize(node2, statement);
              }, Parser3.prototype.parseThrowStatement = function() {
                var node2 = this.createNode();
                this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(messages_1.Messages.NewlineAfterThrow);
                var argument = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(node2, new Node2.ThrowStatement(argument));
              }, Parser3.prototype.parseCatchClause = function() {
                var node2 = this.createNode();
                this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead);
                for (var params = [], param = this.parsePattern(params), paramMap = {}, i2 = 0; i2 < params.length; i2++) {
                  var key2 = "$" + params[i2].value;
                  Object.prototype.hasOwnProperty.call(paramMap, key2) && this.tolerateError(messages_1.Messages.DuplicateBinding, params[i2].value), paramMap[key2] = !0;
                }
                this.context.strict && param.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(param.name) && this.tolerateError(messages_1.Messages.StrictCatchVariable), this.expect(")");
                var body = this.parseBlock();
                return this.finalize(node2, new Node2.CatchClause(param, body));
              }, Parser3.prototype.parseFinallyClause = function() {
                return this.expectKeyword("finally"), this.parseBlock();
              }, Parser3.prototype.parseTryStatement = function() {
                var node2 = this.createNode();
                this.expectKeyword("try");
                var block = this.parseBlock(), handler = this.matchKeyword("catch") ? this.parseCatchClause() : null, finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                return !handler && !finalizer && this.throwError(messages_1.Messages.NoCatchOrFinally), this.finalize(node2, new Node2.TryStatement(block, handler, finalizer));
              }, Parser3.prototype.parseDebuggerStatement = function() {
                var node2 = this.createNode();
                return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(node2, new Node2.DebuggerStatement());
              }, Parser3.prototype.parseStatement = function() {
                var statement;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    statement = this.parseExpressionStatement();
                    break;
                  case 7:
                    var value = this.lookahead.value;
                    value === "{" ? statement = this.parseBlock() : value === "(" ? statement = this.parseExpressionStatement() : value === ";" ? statement = this.parseEmptyStatement() : statement = this.parseExpressionStatement();
                    break;
                  case 3:
                    statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        statement = this.parseBreakStatement();
                        break;
                      case "continue":
                        statement = this.parseContinueStatement();
                        break;
                      case "debugger":
                        statement = this.parseDebuggerStatement();
                        break;
                      case "do":
                        statement = this.parseDoWhileStatement();
                        break;
                      case "for":
                        statement = this.parseForStatement();
                        break;
                      case "function":
                        statement = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        statement = this.parseIfStatement();
                        break;
                      case "return":
                        statement = this.parseReturnStatement();
                        break;
                      case "switch":
                        statement = this.parseSwitchStatement();
                        break;
                      case "throw":
                        statement = this.parseThrowStatement();
                        break;
                      case "try":
                        statement = this.parseTryStatement();
                        break;
                      case "var":
                        statement = this.parseVariableStatement();
                        break;
                      case "while":
                        statement = this.parseWhileStatement();
                        break;
                      case "with":
                        statement = this.parseWithStatement();
                        break;
                      default:
                        statement = this.parseExpressionStatement();
                        break;
                    }
                    break;
                  default:
                    statement = this.throwUnexpectedToken(this.lookahead);
                }
                return statement;
              }, Parser3.prototype.parseFunctionSourceElements = function() {
                var node2 = this.createNode();
                this.expect("{");
                var body = this.parseDirectivePrologues(), previousLabelSet = this.context.labelSet, previousInIteration = this.context.inIteration, previousInSwitch = this.context.inSwitch, previousInFunctionBody = this.context.inFunctionBody;
                for (this.context.labelSet = {}, this.context.inIteration = !1, this.context.inSwitch = !1, this.context.inFunctionBody = !0; this.lookahead.type !== 2 && !this.match("}"); )
                  body.push(this.parseStatementListItem());
                return this.expect("}"), this.context.labelSet = previousLabelSet, this.context.inIteration = previousInIteration, this.context.inSwitch = previousInSwitch, this.context.inFunctionBody = previousInFunctionBody, this.finalize(node2, new Node2.BlockStatement(body));
              }, Parser3.prototype.validateParam = function(options2, param, name) {
                var key2 = "$" + name;
                this.context.strict ? (this.scanner.isRestrictedWord(name) && (options2.stricted = param, options2.message = messages_1.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(options2.paramSet, key2) && (options2.stricted = param, options2.message = messages_1.Messages.StrictParamDupe)) : options2.firstRestricted || (this.scanner.isRestrictedWord(name) ? (options2.firstRestricted = param, options2.message = messages_1.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(name) ? (options2.firstRestricted = param, options2.message = messages_1.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(options2.paramSet, key2) && (options2.stricted = param, options2.message = messages_1.Messages.StrictParamDupe)), typeof Object.defineProperty == "function" ? Object.defineProperty(options2.paramSet, key2, { value: !0, enumerable: !0, writable: !0, configurable: !0 }) : options2.paramSet[key2] = !0;
              }, Parser3.prototype.parseRestElement = function(params) {
                var node2 = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params);
                return this.match("=") && this.throwError(messages_1.Messages.DefaultRestParameter), this.match(")") || this.throwError(messages_1.Messages.ParameterAfterRestParameter), this.finalize(node2, new Node2.RestElement(arg));
              }, Parser3.prototype.parseFormalParameter = function(options2) {
                for (var params = [], param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params), i2 = 0; i2 < params.length; i2++)
                  this.validateParam(options2, params[i2], params[i2].value);
                options2.simple = options2.simple && param instanceof Node2.Identifier, options2.params.push(param);
              }, Parser3.prototype.parseFormalParameters = function(firstRestricted) {
                var options2;
                if (options2 = {
                  simple: !0,
                  params: [],
                  firstRestricted
                }, this.expect("("), !this.match(")"))
                  for (options2.paramSet = {}; this.lookahead.type !== 2 && (this.parseFormalParameter(options2), !(this.match(")") || (this.expect(","), this.match(")")))); )
                    ;
                return this.expect(")"), {
                  simple: options2.simple,
                  params: options2.params,
                  stricted: options2.stricted,
                  firstRestricted: options2.firstRestricted,
                  message: options2.message
                };
              }, Parser3.prototype.matchAsyncFunction = function() {
                var match3 = this.matchContextualKeyword("async");
                if (match3) {
                  var state2 = this.scanner.saveState();
                  this.scanner.scanComments();
                  var next = this.scanner.lex();
                  this.scanner.restoreState(state2), match3 = state2.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                }
                return match3;
              }, Parser3.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                var node2 = this.createNode(), isAsync = this.matchContextualKeyword("async");
                isAsync && this.nextToken(), this.expectKeyword("function");
                var isGenerator = isAsync ? !1 : this.match("*");
                isGenerator && this.nextToken();
                var message, id = null, firstRestricted = null;
                if (!identifierIsOptional || !this.match("(")) {
                  var token2 = this.lookahead;
                  id = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(token2.value) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(token2.value) ? (firstRestricted = token2, message = messages_1.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(token2.value) && (firstRestricted = token2, message = messages_1.Messages.StrictReservedWord);
                }
                var previousAllowAwait = this.context.await, previousAllowYield = this.context.allowYield;
                this.context.await = isAsync, this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters(firstRestricted), params = formalParameters.params, stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted, formalParameters.message && (message = formalParameters.message);
                var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                return this.context.strict && firstRestricted && this.throwUnexpectedToken(firstRestricted, message), this.context.strict && stricted && this.tolerateUnexpectedToken(stricted, message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.await = previousAllowAwait, this.context.allowYield = previousAllowYield, isAsync ? this.finalize(node2, new Node2.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node2, new Node2.FunctionDeclaration(id, params, body, isGenerator));
              }, Parser3.prototype.parseFunctionExpression = function() {
                var node2 = this.createNode(), isAsync = this.matchContextualKeyword("async");
                isAsync && this.nextToken(), this.expectKeyword("function");
                var isGenerator = isAsync ? !1 : this.match("*");
                isGenerator && this.nextToken();
                var message, id = null, firstRestricted, previousAllowAwait = this.context.await, previousAllowYield = this.context.allowYield;
                if (this.context.await = isAsync, this.context.allowYield = !isGenerator, !this.match("(")) {
                  var token2 = this.lookahead;
                  id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(token2.value) && this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(token2.value) ? (firstRestricted = token2, message = messages_1.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(token2.value) && (firstRestricted = token2, message = messages_1.Messages.StrictReservedWord);
                }
                var formalParameters = this.parseFormalParameters(firstRestricted), params = formalParameters.params, stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted, formalParameters.message && (message = formalParameters.message);
                var previousStrict = this.context.strict, previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                return this.context.strict && firstRestricted && this.throwUnexpectedToken(firstRestricted, message), this.context.strict && stricted && this.tolerateUnexpectedToken(stricted, message), this.context.strict = previousStrict, this.context.allowStrictDirective = previousAllowStrictDirective, this.context.await = previousAllowAwait, this.context.allowYield = previousAllowYield, isAsync ? this.finalize(node2, new Node2.AsyncFunctionExpression(id, params, body)) : this.finalize(node2, new Node2.FunctionExpression(id, params, body, isGenerator));
              }, Parser3.prototype.parseDirective = function() {
                var token2 = this.lookahead, node2 = this.createNode(), expr = this.parseExpression(), directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token2).slice(1, -1) : null;
                return this.consumeSemicolon(), this.finalize(node2, directive ? new Node2.Directive(expr, directive) : new Node2.ExpressionStatement(expr));
              }, Parser3.prototype.parseDirectivePrologues = function() {
                for (var firstRestricted = null, body = []; ; ) {
                  var token2 = this.lookahead;
                  if (token2.type !== 8)
                    break;
                  var statement = this.parseDirective();
                  body.push(statement);
                  var directive = statement.directive;
                  if (typeof directive != "string")
                    break;
                  directive === "use strict" ? (this.context.strict = !0, firstRestricted && this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral), this.context.allowStrictDirective || this.tolerateUnexpectedToken(token2, messages_1.Messages.IllegalLanguageModeDirective)) : !firstRestricted && token2.octal && (firstRestricted = token2);
                }
                return body;
              }, Parser3.prototype.qualifiedPropertyName = function(token2) {
                switch (token2.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return !0;
                  case 7:
                    return token2.value === "[";
                }
                return !1;
              }, Parser3.prototype.parseGetterMethod = function() {
                var node2 = this.createNode(), isGenerator = !1, previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                formalParameters.params.length > 0 && this.tolerateError(messages_1.Messages.BadGetterArity);
                var method = this.parsePropertyMethod(formalParameters);
                return this.context.allowYield = previousAllowYield, this.finalize(node2, new Node2.FunctionExpression(null, formalParameters.params, method, isGenerator));
              }, Parser3.prototype.parseSetterMethod = function() {
                var node2 = this.createNode(), isGenerator = !1, previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                formalParameters.params.length !== 1 ? this.tolerateError(messages_1.Messages.BadSetterArity) : formalParameters.params[0] instanceof Node2.RestElement && this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                var method = this.parsePropertyMethod(formalParameters);
                return this.context.allowYield = previousAllowYield, this.finalize(node2, new Node2.FunctionExpression(null, formalParameters.params, method, isGenerator));
              }, Parser3.prototype.parseGeneratorMethod = function() {
                var node2 = this.createNode(), isGenerator = !0, previousAllowYield = this.context.allowYield;
                this.context.allowYield = !0;
                var params = this.parseFormalParameters();
                this.context.allowYield = !1;
                var method = this.parsePropertyMethod(params);
                return this.context.allowYield = previousAllowYield, this.finalize(node2, new Node2.FunctionExpression(null, params.params, method, isGenerator));
              }, Parser3.prototype.isStartOfExpression = function() {
                var start = !0, value = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                    break;
                  case 4:
                    start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                    break;
                }
                return start;
              }, Parser3.prototype.parseYieldExpression = function() {
                var node2 = this.createNode();
                this.expectKeyword("yield");
                var argument = null, delegate = !1;
                if (!this.hasLineTerminator) {
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = !1, delegate = this.match("*"), delegate ? (this.nextToken(), argument = this.parseAssignmentExpression()) : this.isStartOfExpression() && (argument = this.parseAssignmentExpression()), this.context.allowYield = previousAllowYield;
                }
                return this.finalize(node2, new Node2.YieldExpression(argument, delegate));
              }, Parser3.prototype.parseClassElement = function(hasConstructor) {
                var token2 = this.lookahead, node2 = this.createNode(), kind = "", key2 = null, value = null, computed = !1, method = !1, isStatic = !1, isAsync = !1;
                if (this.match("*"))
                  this.nextToken();
                else {
                  computed = this.match("["), key2 = this.parseObjectPropertyKey();
                  var id = key2;
                  if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (token2 = this.lookahead, isStatic = !0, computed = this.match("["), this.match("*") ? this.nextToken() : key2 = this.parseObjectPropertyKey()), token2.type === 3 && !this.hasLineTerminator && token2.value === "async") {
                    var punctuator = this.lookahead.value;
                    punctuator !== ":" && punctuator !== "(" && punctuator !== "*" && (isAsync = !0, token2 = this.lookahead, key2 = this.parseObjectPropertyKey(), token2.type === 3 && token2.value === "constructor" && this.tolerateUnexpectedToken(token2, messages_1.Messages.ConstructorIsAsync));
                  }
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                return token2.type === 3 ? token2.value === "get" && lookaheadPropertyKey ? (kind = "get", computed = this.match("["), key2 = this.parseObjectPropertyKey(), this.context.allowYield = !1, value = this.parseGetterMethod()) : token2.value === "set" && lookaheadPropertyKey && (kind = "set", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseSetterMethod()) : token2.type === 7 && token2.value === "*" && lookaheadPropertyKey && (kind = "init", computed = this.match("["), key2 = this.parseObjectPropertyKey(), value = this.parseGeneratorMethod(), method = !0), !kind && key2 && this.match("(") && (kind = "init", value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), method = !0), kind || this.throwUnexpectedToken(this.lookahead), kind === "init" && (kind = "method"), computed || (isStatic && this.isPropertyKey(key2, "prototype") && this.throwUnexpectedToken(token2, messages_1.Messages.StaticPrototype), !isStatic && this.isPropertyKey(key2, "constructor") && ((kind !== "method" || !method || value && value.generator) && this.throwUnexpectedToken(token2, messages_1.Messages.ConstructorSpecialMethod), hasConstructor.value ? this.throwUnexpectedToken(token2, messages_1.Messages.DuplicateConstructor) : hasConstructor.value = !0, kind = "constructor")), this.finalize(node2, new Node2.MethodDefinition(key2, computed, value, kind, isStatic));
              }, Parser3.prototype.parseClassElementList = function() {
                var body = [], hasConstructor = { value: !1 };
                for (this.expect("{"); !this.match("}"); )
                  this.match(";") ? this.nextToken() : body.push(this.parseClassElement(hasConstructor));
                return this.expect("}"), body;
              }, Parser3.prototype.parseClassBody = function() {
                var node2 = this.createNode(), elementList = this.parseClassElementList();
                return this.finalize(node2, new Node2.ClassBody(elementList));
              }, Parser3.prototype.parseClassDeclaration = function(identifierIsOptional) {
                var node2 = this.createNode(), previousStrict = this.context.strict;
                this.context.strict = !0, this.expectKeyword("class");
                var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier(), superClass = null;
                this.matchKeyword("extends") && (this.nextToken(), superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var classBody = this.parseClassBody();
                return this.context.strict = previousStrict, this.finalize(node2, new Node2.ClassDeclaration(id, superClass, classBody));
              }, Parser3.prototype.parseClassExpression = function() {
                var node2 = this.createNode(), previousStrict = this.context.strict;
                this.context.strict = !0, this.expectKeyword("class");
                var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null, superClass = null;
                this.matchKeyword("extends") && (this.nextToken(), superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var classBody = this.parseClassBody();
                return this.context.strict = previousStrict, this.finalize(node2, new Node2.ClassExpression(id, superClass, classBody));
              }, Parser3.prototype.parseModule = function() {
                this.context.strict = !0, this.context.isModule = !0, this.scanner.isModule = !0;
                for (var node2 = this.createNode(), body = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                  body.push(this.parseStatementListItem());
                return this.finalize(node2, new Node2.Module(body));
              }, Parser3.prototype.parseScript = function() {
                for (var node2 = this.createNode(), body = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                  body.push(this.parseStatementListItem());
                return this.finalize(node2, new Node2.Script(body));
              }, Parser3.prototype.parseModuleSpecifier = function() {
                var node2 = this.createNode();
                this.lookahead.type !== 8 && this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                var token2 = this.nextToken(), raw = this.getTokenRaw(token2);
                return this.finalize(node2, new Node2.Literal(token2.value, raw));
              }, Parser3.prototype.parseImportSpecifier = function() {
                var node2 = this.createNode(), imported, local;
                return this.lookahead.type === 3 ? (imported = this.parseVariableIdentifier(), local = imported, this.matchContextualKeyword("as") && (this.nextToken(), local = this.parseVariableIdentifier())) : (imported = this.parseIdentifierName(), local = imported, this.matchContextualKeyword("as") ? (this.nextToken(), local = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(node2, new Node2.ImportSpecifier(local, imported));
              }, Parser3.prototype.parseNamedImports = function() {
                this.expect("{");
                for (var specifiers = []; !this.match("}"); )
                  specifiers.push(this.parseImportSpecifier()), this.match("}") || this.expect(",");
                return this.expect("}"), specifiers;
              }, Parser3.prototype.parseImportDefaultSpecifier = function() {
                var node2 = this.createNode(), local = this.parseIdentifierName();
                return this.finalize(node2, new Node2.ImportDefaultSpecifier(local));
              }, Parser3.prototype.parseImportNamespaceSpecifier = function() {
                var node2 = this.createNode();
                this.expect("*"), this.matchContextualKeyword("as") || this.throwError(messages_1.Messages.NoAsAfterImportNamespace), this.nextToken();
                var local = this.parseIdentifierName();
                return this.finalize(node2, new Node2.ImportNamespaceSpecifier(local));
              }, Parser3.prototype.parseImportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(messages_1.Messages.IllegalImportDeclaration);
                var node2 = this.createNode();
                this.expectKeyword("import");
                var src2, specifiers = [];
                if (this.lookahead.type === 8)
                  src2 = this.parseModuleSpecifier();
                else {
                  if (this.match("{") ? specifiers = specifiers.concat(this.parseNamedImports()) : this.match("*") ? specifiers.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (specifiers.push(this.parseImportDefaultSpecifier()), this.match(",") && (this.nextToken(), this.match("*") ? specifiers.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? specifiers = specifiers.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken(), src2 = this.parseModuleSpecifier();
                }
                return this.consumeSemicolon(), this.finalize(node2, new Node2.ImportDeclaration(specifiers, src2));
              }, Parser3.prototype.parseExportSpecifier = function() {
                var node2 = this.createNode(), local = this.parseIdentifierName(), exported = local;
                return this.matchContextualKeyword("as") && (this.nextToken(), exported = this.parseIdentifierName()), this.finalize(node2, new Node2.ExportSpecifier(local, exported));
              }, Parser3.prototype.parseExportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(messages_1.Messages.IllegalExportDeclaration);
                var node2 = this.createNode();
                this.expectKeyword("export");
                var exportDeclaration;
                if (this.matchKeyword("default"))
                  if (this.nextToken(), this.matchKeyword("function")) {
                    var declaration = this.parseFunctionDeclaration(!0);
                    exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                  } else if (this.matchKeyword("class")) {
                    var declaration = this.parseClassDeclaration(!0);
                    exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                  } else if (this.matchContextualKeyword("async")) {
                    var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(!0) : this.parseAssignmentExpression();
                    exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                  } else {
                    this.matchContextualKeyword("from") && this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                    var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                    this.consumeSemicolon(), exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                  }
                else if (this.match("*")) {
                  if (this.nextToken(), !this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  var src2 = this.parseModuleSpecifier();
                  this.consumeSemicolon(), exportDeclaration = this.finalize(node2, new Node2.ExportAllDeclaration(src2));
                } else if (this.lookahead.type === 4) {
                  var declaration = void 0;
                  switch (this.lookahead.value) {
                    case "let":
                    case "const":
                      declaration = this.parseLexicalDeclaration({ inFor: !1 });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      declaration = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(declaration, [], null));
                } else if (this.matchAsyncFunction()) {
                  var declaration = this.parseFunctionDeclaration();
                  exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(declaration, [], null));
                } else {
                  var specifiers = [], source2 = null, isExportFromIdentifier = !1;
                  for (this.expect("{"); !this.match("}"); )
                    isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default"), specifiers.push(this.parseExportSpecifier()), this.match("}") || this.expect(",");
                  if (this.expect("}"), this.matchContextualKeyword("from"))
                    this.nextToken(), source2 = this.parseModuleSpecifier(), this.consumeSemicolon();
                  else if (isExportFromIdentifier) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  } else
                    this.consumeSemicolon();
                  exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(null, specifiers, source2));
                }
                return exportDeclaration;
              }, Parser3;
            }();
            exports3.Parser = Parser2;
          },
          /* 9 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            function assert2(condition, message) {
              if (!condition)
                throw new Error("ASSERT: " + message);
            }
            exports3.assert = assert2;
          },
          /* 10 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var ErrorHandler = function() {
              function ErrorHandler2() {
                this.errors = [], this.tolerant = !1;
              }
              return ErrorHandler2.prototype.recordError = function(error2) {
                this.errors.push(error2);
              }, ErrorHandler2.prototype.tolerate = function(error2) {
                if (this.tolerant)
                  this.recordError(error2);
                else
                  throw error2;
              }, ErrorHandler2.prototype.constructError = function(msg, column2) {
                var error2 = new Error(msg);
                try {
                  throw error2;
                } catch (base2) {
                  Object.create && Object.defineProperty && (error2 = Object.create(base2), Object.defineProperty(error2, "column", { value: column2 }));
                }
                return error2;
              }, ErrorHandler2.prototype.createError = function(index, line3, col, description2) {
                var msg = "Line " + line3 + ": " + description2, error2 = this.constructError(msg, col);
                return error2.index = index, error2.lineNumber = line3, error2.description = description2, error2;
              }, ErrorHandler2.prototype.throwError = function(index, line3, col, description2) {
                throw this.createError(index, line3, col, description2);
              }, ErrorHandler2.prototype.tolerateError = function(index, line3, col, description2) {
                var error2 = this.createError(index, line3, col, description2);
                if (this.tolerant)
                  this.recordError(error2);
                else
                  throw error2;
              }, ErrorHandler2;
            }();
            exports3.ErrorHandler = ErrorHandler;
          },
          /* 11 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.Messages = {
              BadGetterArity: "Getter must not have any formal parameters",
              BadSetterArity: "Setter must have exactly one formal parameter",
              BadSetterRestParameter: "Setter function argument must not be a rest parameter",
              ConstructorIsAsync: "Class constructor may not be an async method",
              ConstructorSpecialMethod: "Class constructor may not be an accessor",
              DeclarationMissingInitializer: "Missing initializer in %0 declaration",
              DefaultRestParameter: "Unexpected token =",
              DuplicateBinding: "Duplicate binding %0",
              DuplicateConstructor: "A class may only have one constructor",
              DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
              ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
              GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
              IllegalBreak: "Illegal break statement",
              IllegalContinue: "Illegal continue statement",
              IllegalExportDeclaration: "Unexpected token",
              IllegalImportDeclaration: "Unexpected token",
              IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
              IllegalReturn: "Illegal return statement",
              InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
              InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
              InvalidLHSInAssignment: "Invalid left-hand side in assignment",
              InvalidLHSInForIn: "Invalid left-hand side in for-in",
              InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
              InvalidModuleSpecifier: "Unexpected token",
              InvalidRegExp: "Invalid regular expression",
              LetInLexicalBinding: "let is disallowed as a lexically bound name",
              MissingFromClause: "Unexpected token",
              MultipleDefaultsInSwitch: "More than one default clause in switch statement",
              NewlineAfterThrow: "Illegal newline after throw",
              NoAsAfterImportNamespace: "Unexpected token",
              NoCatchOrFinally: "Missing catch or finally after try",
              ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
              Redeclaration: "%0 '%1' has already been declared",
              StaticPrototype: "Classes may not have static property named prototype",
              StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
              StrictDelete: "Delete of an unqualified identifier in strict mode.",
              StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
              StrictFunctionName: "Function name may not be eval or arguments in strict mode",
              StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
              StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
              StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
              StrictModeWith: "Strict mode code may not include a with statement",
              StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
              StrictParamDupe: "Strict mode function may not have duplicate parameter names",
              StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
              StrictReservedWord: "Use of future reserved word in strict mode",
              StrictVarName: "Variable name may not be eval or arguments in strict mode",
              TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
              UnexpectedEOS: "Unexpected end of input",
              UnexpectedIdentifier: "Unexpected identifier",
              UnexpectedNumber: "Unexpected number",
              UnexpectedReserved: "Unexpected reserved word",
              UnexpectedString: "Unexpected string",
              UnexpectedTemplate: "Unexpected quasi %0",
              UnexpectedToken: "Unexpected token %0",
              UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
              UnknownLabel: "Undefined label '%0'",
              UnterminatedRegExp: "Invalid regular expression: missing /"
            };
          },
          /* 12 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var assert_1 = __webpack_require__(9), character_1 = __webpack_require__(4), messages_1 = __webpack_require__(11);
            function hexValue(ch) {
              return "0123456789abcdef".indexOf(ch.toLowerCase());
            }
            function octalValue(ch) {
              return "01234567".indexOf(ch);
            }
            var Scanner = function() {
              function Scanner2(code, handler) {
                this.source = code, this.errorHandler = handler, this.trackComment = !1, this.isModule = !1, this.length = code.length, this.index = 0, this.lineNumber = code.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
              }
              return Scanner2.prototype.saveState = function() {
                return {
                  index: this.index,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart
                };
              }, Scanner2.prototype.restoreState = function(state2) {
                this.index = state2.index, this.lineNumber = state2.lineNumber, this.lineStart = state2.lineStart;
              }, Scanner2.prototype.eof = function() {
                return this.index >= this.length;
              }, Scanner2.prototype.throwUnexpectedToken = function(message) {
                return message === void 0 && (message = messages_1.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              }, Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                message === void 0 && (message = messages_1.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              }, Scanner2.prototype.skipSingleLineComment = function(offset) {
                var comments2 = [], start, loc;
                for (this.trackComment && (comments2 = [], start = this.index - offset, loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                  },
                  end: {}
                }); !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (++this.index, character_1.Character.isLineTerminator(ch)) {
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart - 1
                      };
                      var entry = {
                        multiLine: !1,
                        slice: [start + offset, this.index - 1],
                        range: [start, this.index - 1],
                        loc
                      };
                      comments2.push(entry);
                    }
                    return ch === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, comments2;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: !1,
                    slice: [start + offset, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments2.push(entry);
                }
                return comments2;
              }, Scanner2.prototype.skipMultiLineComment = function() {
                var comments2 = [], start, loc;
                for (this.trackComment && (comments2 = [], start = this.index - 2, loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                }); !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isLineTerminator(ch))
                    ch === 13 && this.source.charCodeAt(this.index + 1) === 10 && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index;
                  else if (ch === 42) {
                    if (this.source.charCodeAt(this.index + 1) === 47) {
                      if (this.index += 2, this.trackComment) {
                        loc.end = {
                          line: this.lineNumber,
                          column: this.index - this.lineStart
                        };
                        var entry = {
                          multiLine: !0,
                          slice: [start + 2, this.index - 2],
                          range: [start, this.index],
                          loc
                        };
                        comments2.push(entry);
                      }
                      return comments2;
                    }
                    ++this.index;
                  } else
                    ++this.index;
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: !0,
                    slice: [start + 2, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments2.push(entry);
                }
                return this.tolerateUnexpectedToken(), comments2;
              }, Scanner2.prototype.scanComments = function() {
                var comments2;
                this.trackComment && (comments2 = []);
                for (var start = this.index === 0; !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isWhiteSpace(ch))
                    ++this.index;
                  else if (character_1.Character.isLineTerminator(ch))
                    ++this.index, ch === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index, start = !0;
                  else if (ch === 47)
                    if (ch = this.source.charCodeAt(this.index + 1), ch === 47) {
                      this.index += 2;
                      var comment = this.skipSingleLineComment(2);
                      this.trackComment && (comments2 = comments2.concat(comment)), start = !0;
                    } else if (ch === 42) {
                      this.index += 2;
                      var comment = this.skipMultiLineComment();
                      this.trackComment && (comments2 = comments2.concat(comment));
                    } else
                      break;
                  else if (start && ch === 45)
                    if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                      this.index += 3;
                      var comment = this.skipSingleLineComment(3);
                      this.trackComment && (comments2 = comments2.concat(comment));
                    } else
                      break;
                  else if (ch === 60 && !this.isModule)
                    if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                      this.index += 4;
                      var comment = this.skipSingleLineComment(4);
                      this.trackComment && (comments2 = comments2.concat(comment));
                    } else
                      break;
                  else
                    break;
                }
                return comments2;
              }, Scanner2.prototype.isFutureReservedWord = function(id) {
                switch (id) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return !0;
                  default:
                    return !1;
                }
              }, Scanner2.prototype.isStrictModeReservedWord = function(id) {
                switch (id) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return !0;
                  default:
                    return !1;
                }
              }, Scanner2.prototype.isRestrictedWord = function(id) {
                return id === "eval" || id === "arguments";
              }, Scanner2.prototype.isKeyword = function(id) {
                switch (id.length) {
                  case 2:
                    return id === "if" || id === "in" || id === "do";
                  case 3:
                    return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                  case 4:
                    return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                  case 5:
                    return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                  case 6:
                    return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                  case 7:
                    return id === "default" || id === "finally" || id === "extends";
                  case 8:
                    return id === "function" || id === "continue" || id === "debugger";
                  case 10:
                    return id === "instanceof";
                  default:
                    return !1;
                }
              }, Scanner2.prototype.codePointAt = function(i2) {
                var cp2 = this.source.charCodeAt(i2);
                if (cp2 >= 55296 && cp2 <= 56319) {
                  var second = this.source.charCodeAt(i2 + 1);
                  if (second >= 56320 && second <= 57343) {
                    var first2 = cp2;
                    cp2 = (first2 - 55296) * 1024 + second - 56320 + 65536;
                  }
                }
                return cp2;
              }, Scanner2.prototype.scanHexEscape = function(prefix) {
                for (var len = prefix === "u" ? 4 : 2, code = 0, i2 = 0; i2 < len; ++i2)
                  if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index)))
                    code = code * 16 + hexValue(this.source[this.index++]);
                  else
                    return null;
                return String.fromCharCode(code);
              }, Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                var ch = this.source[this.index], code = 0;
                for (ch === "}" && this.throwUnexpectedToken(); !this.eof() && (ch = this.source[this.index++], !!character_1.Character.isHexDigit(ch.charCodeAt(0))); )
                  code = code * 16 + hexValue(ch);
                return (code > 1114111 || ch !== "}") && this.throwUnexpectedToken(), character_1.Character.fromCodePoint(code);
              }, Scanner2.prototype.getIdentifier = function() {
                for (var start = this.index++; !this.eof(); ) {
                  var ch = this.source.charCodeAt(this.index);
                  if (ch === 92)
                    return this.index = start, this.getComplexIdentifier();
                  if (ch >= 55296 && ch < 57343)
                    return this.index = start, this.getComplexIdentifier();
                  if (character_1.Character.isIdentifierPart(ch))
                    ++this.index;
                  else
                    break;
                }
                return this.source.slice(start, this.index);
              }, Scanner2.prototype.getComplexIdentifier = function() {
                var cp2 = this.codePointAt(this.index), id = character_1.Character.fromCodePoint(cp2);
                this.index += id.length;
                var ch;
                for (cp2 === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, ch = this.scanUnicodeCodePointEscape()) : (ch = this.scanHexEscape("u"), (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) && this.throwUnexpectedToken()), id = ch); !this.eof() && (cp2 = this.codePointAt(this.index), !!character_1.Character.isIdentifierPart(cp2)); )
                  ch = character_1.Character.fromCodePoint(cp2), id += ch, this.index += ch.length, cp2 === 92 && (id = id.substr(0, id.length - 1), this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, ch = this.scanUnicodeCodePointEscape()) : (ch = this.scanHexEscape("u"), (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) && this.throwUnexpectedToken()), id += ch);
                return id;
              }, Scanner2.prototype.octalToDecimal = function(ch) {
                var octal = ch !== "0", code = octalValue(ch);
                return !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (octal = !0, code = code * 8 + octalValue(this.source[this.index++]), "0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (code = code * 8 + octalValue(this.source[this.index++]))), {
                  code,
                  octal
                };
              }, Scanner2.prototype.scanIdentifier = function() {
                var type2, start = this.index, id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                if (id.length === 1 ? type2 = 3 : this.isKeyword(id) ? type2 = 4 : id === "null" ? type2 = 5 : id === "true" || id === "false" ? type2 = 1 : type2 = 3, type2 !== 3 && start + id.length !== this.index) {
                  var restore = this.index;
                  this.index = start, this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord), this.index = restore;
                }
                return {
                  type: type2,
                  value: id,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanPunctuator = function() {
                var start = this.index, str2 = this.source[this.index];
                switch (str2) {
                  case "(":
                  case "{":
                    str2 === "{" && this.curlyStack.push("{"), ++this.index;
                    break;
                  case ".":
                    ++this.index, this.source[this.index] === "." && this.source[this.index + 1] === "." && (this.index += 2, str2 = "...");
                    break;
                  case "}":
                    ++this.index, this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    str2 = this.source.substr(this.index, 4), str2 === ">>>=" ? this.index += 4 : (str2 = str2.substr(0, 3), str2 === "===" || str2 === "!==" || str2 === ">>>" || str2 === "<<=" || str2 === ">>=" || str2 === "**=" ? this.index += 3 : (str2 = str2.substr(0, 2), str2 === "&&" || str2 === "||" || str2 === "==" || str2 === "!=" || str2 === "+=" || str2 === "-=" || str2 === "*=" || str2 === "/=" || str2 === "++" || str2 === "--" || str2 === "<<" || str2 === ">>" || str2 === "&=" || str2 === "|=" || str2 === "^=" || str2 === "%=" || str2 === "<=" || str2 === ">=" || str2 === "=>" || str2 === "**" ? this.index += 2 : (str2 = this.source[this.index], "<>=!+-*%&|^/".indexOf(str2) >= 0 && ++this.index)));
                }
                return this.index === start && this.throwUnexpectedToken(), {
                  type: 7,
                  value: str2,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanHexLiteral = function(start) {
                for (var num = ""; !this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index)); )
                  num += this.source[this.index++];
                return num.length === 0 && this.throwUnexpectedToken(), character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseInt("0x" + num, 16),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanBinaryLiteral = function(start) {
                for (var num = "", ch; !this.eof() && (ch = this.source[this.index], !(ch !== "0" && ch !== "1")); )
                  num += this.source[this.index++];
                return num.length === 0 && this.throwUnexpectedToken(), this.eof() || (ch = this.source.charCodeAt(this.index), (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) && this.throwUnexpectedToken()), {
                  type: 6,
                  value: parseInt(num, 2),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
                var num = "", octal = !1;
                for (character_1.Character.isOctalDigit(prefix.charCodeAt(0)) ? (octal = !0, num = "0" + this.source[this.index++]) : ++this.index; !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index)); )
                  num += this.source[this.index++];
                return !octal && num.length === 0 && this.throwUnexpectedToken(), (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseInt(num, 8),
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.isImplicitOctalLiteral = function() {
                for (var i2 = this.index + 1; i2 < this.length; ++i2) {
                  var ch = this.source[i2];
                  if (ch === "8" || ch === "9")
                    return !1;
                  if (!character_1.Character.isOctalDigit(ch.charCodeAt(0)))
                    return !0;
                }
                return !0;
              }, Scanner2.prototype.scanNumericLiteral = function() {
                var start = this.index, ch = this.source[start];
                assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                var num = "";
                if (ch !== ".") {
                  if (num = this.source[this.index++], ch = this.source[this.index], num === "0") {
                    if (ch === "x" || ch === "X")
                      return ++this.index, this.scanHexLiteral(start);
                    if (ch === "b" || ch === "B")
                      return ++this.index, this.scanBinaryLiteral(start);
                    if (ch === "o" || ch === "O")
                      return this.scanOctalLiteral(ch, start);
                    if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0)) && this.isImplicitOctalLiteral())
                      return this.scanOctalLiteral(ch, start);
                  }
                  for (; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    num += this.source[this.index++];
                  ch = this.source[this.index];
                }
                if (ch === ".") {
                  for (num += this.source[this.index++]; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    num += this.source[this.index++];
                  ch = this.source[this.index];
                }
                if (ch === "e" || ch === "E")
                  if (num += this.source[this.index++], ch = this.source[this.index], (ch === "+" || ch === "-") && (num += this.source[this.index++]), character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)))
                    for (; character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                      num += this.source[this.index++];
                  else
                    this.throwUnexpectedToken();
                return character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
                  type: 6,
                  value: parseFloat(num),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanStringLiteral = function() {
                var start = this.index, quote = this.source[start];
                assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote"), ++this.index;
                for (var octal = !1, str2 = ""; !this.eof(); ) {
                  var ch = this.source[this.index++];
                  if (ch === quote) {
                    quote = "";
                    break;
                  } else if (ch === "\\")
                    if (ch = this.source[this.index++], !ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                      switch (ch) {
                        case "u":
                          if (this.source[this.index] === "{")
                            ++this.index, str2 += this.scanUnicodeCodePointEscape();
                          else {
                            var unescaped_1 = this.scanHexEscape(ch);
                            unescaped_1 === null && this.throwUnexpectedToken(), str2 += unescaped_1;
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          unescaped === null && this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence), str2 += unescaped;
                          break;
                        case "n":
                          str2 += `
`;
                          break;
                        case "r":
                          str2 += "\r";
                          break;
                        case "t":
                          str2 += "	";
                          break;
                        case "b":
                          str2 += "\b";
                          break;
                        case "f":
                          str2 += "\f";
                          break;
                        case "v":
                          str2 += "\v";
                          break;
                        case "8":
                        case "9":
                          str2 += ch, this.tolerateUnexpectedToken();
                          break;
                        default:
                          if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            var octToDec = this.octalToDecimal(ch);
                            octal = octToDec.octal || octal, str2 += String.fromCharCode(octToDec.code);
                          } else
                            str2 += ch;
                          break;
                      }
                    else
                      ++this.lineNumber, ch === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                  else {
                    if (character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                      break;
                    str2 += ch;
                  }
                }
                return quote !== "" && (this.index = start, this.throwUnexpectedToken()), {
                  type: 8,
                  value: str2,
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.scanTemplate = function() {
                var cooked = "", terminated = !1, start = this.index, head = this.source[start] === "`", tail = !1, rawOffset = 2;
                for (++this.index; !this.eof(); ) {
                  var ch = this.source[this.index++];
                  if (ch === "`") {
                    rawOffset = 1, tail = !0, terminated = !0;
                    break;
                  } else if (ch === "$") {
                    if (this.source[this.index] === "{") {
                      this.curlyStack.push("${"), ++this.index, terminated = !0;
                      break;
                    }
                    cooked += ch;
                  } else if (ch === "\\")
                    if (ch = this.source[this.index++], character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                      ++this.lineNumber, ch === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                    else
                      switch (ch) {
                        case "n":
                          cooked += `
`;
                          break;
                        case "r":
                          cooked += "\r";
                          break;
                        case "t":
                          cooked += "	";
                          break;
                        case "u":
                          if (this.source[this.index] === "{")
                            ++this.index, cooked += this.scanUnicodeCodePointEscape();
                          else {
                            var restore = this.index, unescaped_2 = this.scanHexEscape(ch);
                            unescaped_2 !== null ? cooked += unescaped_2 : (this.index = restore, cooked += ch);
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          unescaped === null && this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence), cooked += unescaped;
                          break;
                        case "b":
                          cooked += "\b";
                          break;
                        case "f":
                          cooked += "\f";
                          break;
                        case "v":
                          cooked += "\v";
                          break;
                        default:
                          ch === "0" ? (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral), cooked += "\0") : character_1.Character.isOctalDigit(ch.charCodeAt(0)) ? this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral) : cooked += ch;
                          break;
                      }
                  else character_1.Character.isLineTerminator(ch.charCodeAt(0)) ? (++this.lineNumber, ch === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index, cooked += `
`) : cooked += ch;
                }
                return terminated || this.throwUnexpectedToken(), head || this.curlyStack.pop(), {
                  type: 10,
                  value: this.source.slice(start + 1, this.index - rawOffset),
                  cooked,
                  head,
                  tail,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.testRegExp = function(pattern, flags) {
                var astralSubstitute = "\uFFFF", tmp2 = pattern, self2 = this;
                flags.indexOf("u") >= 0 && (tmp2 = tmp2.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                  var codePoint = parseInt($1 || $2, 16);
                  return codePoint > 1114111 && self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp), codePoint <= 65535 ? String.fromCharCode(codePoint) : astralSubstitute;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute));
                try {
                  RegExp(tmp2);
                } catch {
                  this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(pattern, flags);
                } catch {
                  return null;
                }
              }, Scanner2.prototype.scanRegExpBody = function() {
                var ch = this.source[this.index];
                assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
                for (var str2 = this.source[this.index++], classMarker = !1, terminated = !1; !this.eof(); )
                  if (ch = this.source[this.index++], str2 += ch, ch === "\\")
                    ch = this.source[this.index++], character_1.Character.isLineTerminator(ch.charCodeAt(0)) && this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp), str2 += ch;
                  else if (character_1.Character.isLineTerminator(ch.charCodeAt(0)))
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  else if (classMarker)
                    ch === "]" && (classMarker = !1);
                  else if (ch === "/") {
                    terminated = !0;
                    break;
                  } else ch === "[" && (classMarker = !0);
                return terminated || this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp), str2.substr(1, str2.length - 2);
              }, Scanner2.prototype.scanRegExpFlags = function() {
                for (var str2 = "", flags = ""; !this.eof(); ) {
                  var ch = this.source[this.index];
                  if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0)))
                    break;
                  if (++this.index, ch === "\\" && !this.eof())
                    if (ch = this.source[this.index], ch === "u") {
                      ++this.index;
                      var restore = this.index, char = this.scanHexEscape("u");
                      if (char !== null)
                        for (flags += char, str2 += "\\u"; restore < this.index; ++restore)
                          str2 += this.source[restore];
                      else
                        this.index = restore, flags += "u", str2 += "\\u";
                      this.tolerateUnexpectedToken();
                    } else
                      str2 += "\\", this.tolerateUnexpectedToken();
                  else
                    flags += ch, str2 += ch;
                }
                return flags;
              }, Scanner2.prototype.scanRegExp = function() {
                var start = this.index, pattern = this.scanRegExpBody(), flags = this.scanRegExpFlags(), value = this.testRegExp(pattern, flags);
                return {
                  type: 9,
                  value: "",
                  pattern,
                  flags,
                  regex: value,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              }, Scanner2.prototype.lex = function() {
                if (this.eof())
                  return {
                    type: 2,
                    value: "",
                    lineNumber: this.lineNumber,
                    lineStart: this.lineStart,
                    start: this.index,
                    end: this.index
                  };
                var cp2 = this.source.charCodeAt(this.index);
                return character_1.Character.isIdentifierStart(cp2) ? this.scanIdentifier() : cp2 === 40 || cp2 === 41 || cp2 === 59 ? this.scanPunctuator() : cp2 === 39 || cp2 === 34 ? this.scanStringLiteral() : cp2 === 46 ? character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : character_1.Character.isDecimalDigit(cp2) ? this.scanNumericLiteral() : cp2 === 96 || cp2 === 125 && this.curlyStack[this.curlyStack.length - 1] === "${" ? this.scanTemplate() : cp2 >= 55296 && cp2 < 57343 && character_1.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
              }, Scanner2;
            }();
            exports3.Scanner = Scanner;
          },
          /* 13 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.TokenName = {}, exports3.TokenName[
              1
              /* BooleanLiteral */
            ] = "Boolean", exports3.TokenName[
              2
              /* EOF */
            ] = "<end>", exports3.TokenName[
              3
              /* Identifier */
            ] = "Identifier", exports3.TokenName[
              4
              /* Keyword */
            ] = "Keyword", exports3.TokenName[
              5
              /* NullLiteral */
            ] = "Null", exports3.TokenName[
              6
              /* NumericLiteral */
            ] = "Numeric", exports3.TokenName[
              7
              /* Punctuator */
            ] = "Punctuator", exports3.TokenName[
              8
              /* StringLiteral */
            ] = "String", exports3.TokenName[
              9
              /* RegularExpression */
            ] = "RegularExpression", exports3.TokenName[
              10
              /* Template */
            ] = "Template";
          },
          /* 14 */
          /***/
          function(module3, exports3) {
            Object.defineProperty(exports3, "__esModule", { value: !0 }), exports3.XHTMLEntities = {
              quot: '"',
              amp: "&",
              apos: "'",
              gt: ">",
              nbsp: "\xA0",
              iexcl: "\xA1",
              cent: "\xA2",
              pound: "\xA3",
              curren: "\xA4",
              yen: "\xA5",
              brvbar: "\xA6",
              sect: "\xA7",
              uml: "\xA8",
              copy: "\xA9",
              ordf: "\xAA",
              laquo: "\xAB",
              not: "\xAC",
              shy: "\xAD",
              reg: "\xAE",
              macr: "\xAF",
              deg: "\xB0",
              plusmn: "\xB1",
              sup2: "\xB2",
              sup3: "\xB3",
              acute: "\xB4",
              micro: "\xB5",
              para: "\xB6",
              middot: "\xB7",
              cedil: "\xB8",
              sup1: "\xB9",
              ordm: "\xBA",
              raquo: "\xBB",
              frac14: "\xBC",
              frac12: "\xBD",
              frac34: "\xBE",
              iquest: "\xBF",
              Agrave: "\xC0",
              Aacute: "\xC1",
              Acirc: "\xC2",
              Atilde: "\xC3",
              Auml: "\xC4",
              Aring: "\xC5",
              AElig: "\xC6",
              Ccedil: "\xC7",
              Egrave: "\xC8",
              Eacute: "\xC9",
              Ecirc: "\xCA",
              Euml: "\xCB",
              Igrave: "\xCC",
              Iacute: "\xCD",
              Icirc: "\xCE",
              Iuml: "\xCF",
              ETH: "\xD0",
              Ntilde: "\xD1",
              Ograve: "\xD2",
              Oacute: "\xD3",
              Ocirc: "\xD4",
              Otilde: "\xD5",
              Ouml: "\xD6",
              times: "\xD7",
              Oslash: "\xD8",
              Ugrave: "\xD9",
              Uacute: "\xDA",
              Ucirc: "\xDB",
              Uuml: "\xDC",
              Yacute: "\xDD",
              THORN: "\xDE",
              szlig: "\xDF",
              agrave: "\xE0",
              aacute: "\xE1",
              acirc: "\xE2",
              atilde: "\xE3",
              auml: "\xE4",
              aring: "\xE5",
              aelig: "\xE6",
              ccedil: "\xE7",
              egrave: "\xE8",
              eacute: "\xE9",
              ecirc: "\xEA",
              euml: "\xEB",
              igrave: "\xEC",
              iacute: "\xED",
              icirc: "\xEE",
              iuml: "\xEF",
              eth: "\xF0",
              ntilde: "\xF1",
              ograve: "\xF2",
              oacute: "\xF3",
              ocirc: "\xF4",
              otilde: "\xF5",
              ouml: "\xF6",
              divide: "\xF7",
              oslash: "\xF8",
              ugrave: "\xF9",
              uacute: "\xFA",
              ucirc: "\xFB",
              uuml: "\xFC",
              yacute: "\xFD",
              thorn: "\xFE",
              yuml: "\xFF",
              OElig: "\u0152",
              oelig: "\u0153",
              Scaron: "\u0160",
              scaron: "\u0161",
              Yuml: "\u0178",
              fnof: "\u0192",
              circ: "\u02C6",
              tilde: "\u02DC",
              Alpha: "\u0391",
              Beta: "\u0392",
              Gamma: "\u0393",
              Delta: "\u0394",
              Epsilon: "\u0395",
              Zeta: "\u0396",
              Eta: "\u0397",
              Theta: "\u0398",
              Iota: "\u0399",
              Kappa: "\u039A",
              Lambda: "\u039B",
              Mu: "\u039C",
              Nu: "\u039D",
              Xi: "\u039E",
              Omicron: "\u039F",
              Pi: "\u03A0",
              Rho: "\u03A1",
              Sigma: "\u03A3",
              Tau: "\u03A4",
              Upsilon: "\u03A5",
              Phi: "\u03A6",
              Chi: "\u03A7",
              Psi: "\u03A8",
              Omega: "\u03A9",
              alpha: "\u03B1",
              beta: "\u03B2",
              gamma: "\u03B3",
              delta: "\u03B4",
              epsilon: "\u03B5",
              zeta: "\u03B6",
              eta: "\u03B7",
              theta: "\u03B8",
              iota: "\u03B9",
              kappa: "\u03BA",
              lambda: "\u03BB",
              mu: "\u03BC",
              nu: "\u03BD",
              xi: "\u03BE",
              omicron: "\u03BF",
              pi: "\u03C0",
              rho: "\u03C1",
              sigmaf: "\u03C2",
              sigma: "\u03C3",
              tau: "\u03C4",
              upsilon: "\u03C5",
              phi: "\u03C6",
              chi: "\u03C7",
              psi: "\u03C8",
              omega: "\u03C9",
              thetasym: "\u03D1",
              upsih: "\u03D2",
              piv: "\u03D6",
              ensp: "\u2002",
              emsp: "\u2003",
              thinsp: "\u2009",
              zwnj: "\u200C",
              zwj: "\u200D",
              lrm: "\u200E",
              rlm: "\u200F",
              ndash: "\u2013",
              mdash: "\u2014",
              lsquo: "\u2018",
              rsquo: "\u2019",
              sbquo: "\u201A",
              ldquo: "\u201C",
              rdquo: "\u201D",
              bdquo: "\u201E",
              dagger: "\u2020",
              Dagger: "\u2021",
              bull: "\u2022",
              hellip: "\u2026",
              permil: "\u2030",
              prime: "\u2032",
              Prime: "\u2033",
              lsaquo: "\u2039",
              rsaquo: "\u203A",
              oline: "\u203E",
              frasl: "\u2044",
              euro: "\u20AC",
              image: "\u2111",
              weierp: "\u2118",
              real: "\u211C",
              trade: "\u2122",
              alefsym: "\u2135",
              larr: "\u2190",
              uarr: "\u2191",
              rarr: "\u2192",
              darr: "\u2193",
              harr: "\u2194",
              crarr: "\u21B5",
              lArr: "\u21D0",
              uArr: "\u21D1",
              rArr: "\u21D2",
              dArr: "\u21D3",
              hArr: "\u21D4",
              forall: "\u2200",
              part: "\u2202",
              exist: "\u2203",
              empty: "\u2205",
              nabla: "\u2207",
              isin: "\u2208",
              notin: "\u2209",
              ni: "\u220B",
              prod: "\u220F",
              sum: "\u2211",
              minus: "\u2212",
              lowast: "\u2217",
              radic: "\u221A",
              prop: "\u221D",
              infin: "\u221E",
              ang: "\u2220",
              and: "\u2227",
              or: "\u2228",
              cap: "\u2229",
              cup: "\u222A",
              int: "\u222B",
              there4: "\u2234",
              sim: "\u223C",
              cong: "\u2245",
              asymp: "\u2248",
              ne: "\u2260",
              equiv: "\u2261",
              le: "\u2264",
              ge: "\u2265",
              sub: "\u2282",
              sup: "\u2283",
              nsub: "\u2284",
              sube: "\u2286",
              supe: "\u2287",
              oplus: "\u2295",
              otimes: "\u2297",
              perp: "\u22A5",
              sdot: "\u22C5",
              lceil: "\u2308",
              rceil: "\u2309",
              lfloor: "\u230A",
              rfloor: "\u230B",
              loz: "\u25CA",
              spades: "\u2660",
              clubs: "\u2663",
              hearts: "\u2665",
              diams: "\u2666",
              lang: "\u27E8",
              rang: "\u27E9"
            };
          },
          /* 15 */
          /***/
          function(module3, exports3, __webpack_require__) {
            Object.defineProperty(exports3, "__esModule", { value: !0 });
            var error_handler_1 = __webpack_require__(10), scanner_1 = __webpack_require__(12), token_1 = __webpack_require__(13), Reader = function() {
              function Reader2() {
                this.values = [], this.curly = this.paren = -1;
              }
              return Reader2.prototype.beforeFunctionExpression = function(t) {
                return [
                  "(",
                  "{",
                  "[",
                  "in",
                  "typeof",
                  "instanceof",
                  "new",
                  "return",
                  "case",
                  "delete",
                  "throw",
                  "void",
                  // assignment operators
                  "=",
                  "+=",
                  "-=",
                  "*=",
                  "**=",
                  "/=",
                  "%=",
                  "<<=",
                  ">>=",
                  ">>>=",
                  "&=",
                  "|=",
                  "^=",
                  ",",
                  // binary/unary operators
                  "+",
                  "-",
                  "*",
                  "**",
                  "/",
                  "%",
                  "++",
                  "--",
                  "<<",
                  ">>",
                  ">>>",
                  "&",
                  "|",
                  "^",
                  "!",
                  "~",
                  "&&",
                  "||",
                  "?",
                  ":",
                  "===",
                  "==",
                  ">=",
                  "<=",
                  "<",
                  ">",
                  "!=",
                  "!=="
                ].indexOf(t) >= 0;
              }, Reader2.prototype.isRegexStart = function() {
                var previous = this.values[this.values.length - 1], regex = previous !== null;
                switch (previous) {
                  case "this":
                  case "]":
                    regex = !1;
                    break;
                  case ")":
                    var keyword = this.values[this.paren - 1];
                    regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                    break;
                  case "}":
                    if (regex = !1, this.values[this.curly - 3] === "function") {
                      var check = this.values[this.curly - 4];
                      regex = check ? !this.beforeFunctionExpression(check) : !1;
                    } else if (this.values[this.curly - 4] === "function") {
                      var check = this.values[this.curly - 5];
                      regex = check ? !this.beforeFunctionExpression(check) : !0;
                    }
                    break;
                }
                return regex;
              }, Reader2.prototype.push = function(token2) {
                token2.type === 7 || token2.type === 4 ? (token2.value === "{" ? this.curly = this.values.length : token2.value === "(" && (this.paren = this.values.length), this.values.push(token2.value)) : this.values.push(null);
              }, Reader2;
            }(), Tokenizer = function() {
              function Tokenizer2(code, config2) {
                this.errorHandler = new error_handler_1.ErrorHandler(), this.errorHandler.tolerant = config2 ? typeof config2.tolerant == "boolean" && config2.tolerant : !1, this.scanner = new scanner_1.Scanner(code, this.errorHandler), this.scanner.trackComment = config2 ? typeof config2.comment == "boolean" && config2.comment : !1, this.trackRange = config2 ? typeof config2.range == "boolean" && config2.range : !1, this.trackLoc = config2 ? typeof config2.loc == "boolean" && config2.loc : !1, this.buffer = [], this.reader = new Reader();
              }
              return Tokenizer2.prototype.errors = function() {
                return this.errorHandler.errors;
              }, Tokenizer2.prototype.getNextToken = function() {
                if (this.buffer.length === 0) {
                  var comments2 = this.scanner.scanComments();
                  if (this.scanner.trackComment)
                    for (var i2 = 0; i2 < comments2.length; ++i2) {
                      var e = comments2[i2], value = this.scanner.source.slice(e.slice[0], e.slice[1]), comment = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value
                      };
                      this.trackRange && (comment.range = e.range), this.trackLoc && (comment.loc = e.loc), this.buffer.push(comment);
                    }
                  if (!this.scanner.eof()) {
                    var loc = void 0;
                    this.trackLoc && (loc = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    });
                    var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart(), token2 = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(token2);
                    var entry = {
                      type: token_1.TokenName[token2.type],
                      value: this.scanner.source.slice(token2.start, token2.end)
                    };
                    if (this.trackRange && (entry.range = [token2.start, token2.end]), this.trackLoc && (loc.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    }, entry.loc = loc), token2.type === 9) {
                      var pattern = token2.pattern, flags = token2.flags;
                      entry.regex = { pattern, flags };
                    }
                    this.buffer.push(entry);
                  }
                }
                return this.buffer.shift();
              }, Tokenizer2;
            }();
            exports3.Tokenizer = Tokenizer;
          }
          /******/
        ])
      );
    });
  }(esprima)), esprima.exports;
}
var hasRequiredEsprima;
function requireEsprima() {
  if (hasRequiredEsprima) return esprima$1;
  hasRequiredEsprima = 1, Object.defineProperty(esprima$1, "__esModule", { value: !0 }), esprima$1.parse = void 0;
  var util_1 = requireUtil();
  function parse3(source2, options2) {
    var comments2 = [], ast = requireEsprima$1().parse(source2, {
      loc: !0,
      locations: !0,
      comment: !0,
      onComment: comments2,
      range: (0, util_1.getOption)(options2, "range", !1),
      tolerant: (0, util_1.getOption)(options2, "tolerant", !0),
      tokens: !0,
      jsx: (0, util_1.getOption)(options2, "jsx", !1),
      sourceType: (0, util_1.getOption)(options2, "sourceType", "module")
    });
    return Array.isArray(ast.comments) || (ast.comments = comments2), ast;
  }
  return esprima$1.parse = parse3, esprima$1;
}
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options$1;
  hasRequiredOptions = 1, Object.defineProperty(options$1, "__esModule", { value: !0 }), options$1.normalize = void 0;
  var util_1 = requireUtil(), defaults2 = {
    parser: requireEsprima(),
    tabWidth: 4,
    useTabs: !1,
    reuseWhitespace: !0,
    lineTerminator: (0, util_1.getLineTerminator)(),
    wrapColumn: 74,
    sourceFileName: null,
    sourceMapName: null,
    sourceRoot: null,
    inputSourceMap: null,
    range: !1,
    tolerant: !0,
    quote: null,
    trailingComma: !1,
    arrayBracketSpacing: !1,
    objectCurlySpacing: !0,
    arrowParensAlways: !1,
    flowObjectCommas: !0,
    tokens: !0
  }, hasOwn2 = defaults2.hasOwnProperty;
  function normalize2(opts) {
    var options2 = opts || defaults2;
    function get2(key2) {
      return hasOwn2.call(options2, key2) ? options2[key2] : defaults2[key2];
    }
    return {
      tabWidth: +get2("tabWidth"),
      useTabs: !!get2("useTabs"),
      reuseWhitespace: !!get2("reuseWhitespace"),
      lineTerminator: get2("lineTerminator"),
      wrapColumn: Math.max(get2("wrapColumn"), 0),
      sourceFileName: get2("sourceFileName"),
      sourceMapName: get2("sourceMapName"),
      sourceRoot: get2("sourceRoot"),
      inputSourceMap: get2("inputSourceMap"),
      parser: get2("esprima") || get2("parser"),
      range: get2("range"),
      tolerant: get2("tolerant"),
      quote: get2("quote"),
      trailingComma: get2("trailingComma"),
      arrayBracketSpacing: get2("arrayBracketSpacing"),
      objectCurlySpacing: get2("objectCurlySpacing"),
      arrowParensAlways: get2("arrowParensAlways"),
      flowObjectCommas: get2("flowObjectCommas"),
      tokens: !!get2("tokens")
    };
  }
  return options$1.normalize = normalize2, options$1;
}
var lines = {}, mapping = {}, hasRequiredMapping;
function requireMapping() {
  if (hasRequiredMapping) return mapping;
  hasRequiredMapping = 1, Object.defineProperty(mapping, "__esModule", { value: !0 });
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), util_1 = requireUtil(), Mapping = (
    /** @class */
    function() {
      function Mapping2(sourceLines, sourceLoc, targetLoc) {
        targetLoc === void 0 && (targetLoc = sourceLoc), this.sourceLines = sourceLines, this.sourceLoc = sourceLoc, this.targetLoc = targetLoc;
      }
      return Mapping2.prototype.slice = function(lines2, start, end2) {
        end2 === void 0 && (end2 = lines2.lastPos());
        var sourceLines = this.sourceLines, sourceLoc = this.sourceLoc, targetLoc = this.targetLoc;
        function skip2(name) {
          var sourceFromPos = sourceLoc[name], targetFromPos = targetLoc[name], targetToPos = start;
          return name === "end" ? targetToPos = end2 : (0, tiny_invariant_1.default)(name === "start"), skipChars(sourceLines, sourceFromPos, lines2, targetFromPos, targetToPos);
        }
        if ((0, util_1.comparePos)(start, targetLoc.start) <= 0)
          if ((0, util_1.comparePos)(targetLoc.end, end2) <= 0)
            targetLoc = {
              start: subtractPos(targetLoc.start, start.line, start.column),
              end: subtractPos(targetLoc.end, start.line, start.column)
            };
          else {
            if ((0, util_1.comparePos)(end2, targetLoc.start) <= 0)
              return null;
            sourceLoc = {
              start: sourceLoc.start,
              end: skip2("end")
            }, targetLoc = {
              start: subtractPos(targetLoc.start, start.line, start.column),
              end: subtractPos(end2, start.line, start.column)
            };
          }
        else {
          if ((0, util_1.comparePos)(targetLoc.end, start) <= 0)
            return null;
          (0, util_1.comparePos)(targetLoc.end, end2) <= 0 ? (sourceLoc = {
            start: skip2("start"),
            end: sourceLoc.end
          }, targetLoc = {
            // Same as subtractPos(start, start.line, start.column):
            start: { line: 1, column: 0 },
            end: subtractPos(targetLoc.end, start.line, start.column)
          }) : (sourceLoc = {
            start: skip2("start"),
            end: skip2("end")
          }, targetLoc = {
            // Same as subtractPos(start, start.line, start.column):
            start: { line: 1, column: 0 },
            end: subtractPos(end2, start.line, start.column)
          });
        }
        return new Mapping2(this.sourceLines, sourceLoc, targetLoc);
      }, Mapping2.prototype.add = function(line3, column2) {
        return new Mapping2(this.sourceLines, this.sourceLoc, {
          start: addPos(this.targetLoc.start, line3, column2),
          end: addPos(this.targetLoc.end, line3, column2)
        });
      }, Mapping2.prototype.subtract = function(line3, column2) {
        return new Mapping2(this.sourceLines, this.sourceLoc, {
          start: subtractPos(this.targetLoc.start, line3, column2),
          end: subtractPos(this.targetLoc.end, line3, column2)
        });
      }, Mapping2.prototype.indent = function(by, skipFirstLine, noNegativeColumns) {
        if (skipFirstLine === void 0 && (skipFirstLine = !1), noNegativeColumns === void 0 && (noNegativeColumns = !1), by === 0)
          return this;
        var targetLoc = this.targetLoc, startLine = targetLoc.start.line, endLine = targetLoc.end.line;
        if (skipFirstLine && startLine === 1 && endLine === 1)
          return this;
        if (targetLoc = {
          start: targetLoc.start,
          end: targetLoc.end
        }, !skipFirstLine || startLine > 1) {
          var startColumn = targetLoc.start.column + by;
          targetLoc.start = {
            line: startLine,
            column: noNegativeColumns ? Math.max(0, startColumn) : startColumn
          };
        }
        if (!skipFirstLine || endLine > 1) {
          var endColumn = targetLoc.end.column + by;
          targetLoc.end = {
            line: endLine,
            column: noNegativeColumns ? Math.max(0, endColumn) : endColumn
          };
        }
        return new Mapping2(this.sourceLines, this.sourceLoc, targetLoc);
      }, Mapping2;
    }()
  );
  mapping.default = Mapping;
  function addPos(toPos, line3, column2) {
    return {
      line: toPos.line + line3 - 1,
      column: toPos.line === 1 ? toPos.column + column2 : toPos.column
    };
  }
  function subtractPos(fromPos, line3, column2) {
    return {
      line: fromPos.line - line3 + 1,
      column: fromPos.line === line3 ? fromPos.column - column2 : fromPos.column
    };
  }
  function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
    var targetComparison = (0, util_1.comparePos)(targetFromPos, targetToPos);
    if (targetComparison === 0)
      return sourceFromPos;
    var sourceCursor, targetCursor;
    if (targetComparison < 0) {
      sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos(), targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
      var lineDiff = targetToPos.line - targetCursor.line;
      for (sourceCursor.line += lineDiff, targetCursor.line += lineDiff, lineDiff > 0 ? (sourceCursor.column = 0, targetCursor.column = 0) : (0, tiny_invariant_1.default)(lineDiff === 0); (0, util_1.comparePos)(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, !0); )
        (0, tiny_invariant_1.default)(sourceLines.nextPos(sourceCursor, !0)), (0, tiny_invariant_1.default)(sourceLines.charAt(sourceCursor) === targetLines.charAt(targetCursor));
    } else {
      sourceCursor = sourceLines.skipSpaces(sourceFromPos, !0) || sourceLines.firstPos(), targetCursor = targetLines.skipSpaces(targetFromPos, !0) || targetLines.firstPos();
      var lineDiff = targetToPos.line - targetCursor.line;
      for (sourceCursor.line += lineDiff, targetCursor.line += lineDiff, lineDiff < 0 ? (sourceCursor.column = sourceLines.getLineLength(sourceCursor.line), targetCursor.column = targetLines.getLineLength(targetCursor.line)) : (0, tiny_invariant_1.default)(lineDiff === 0); (0, util_1.comparePos)(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, !0); )
        (0, tiny_invariant_1.default)(sourceLines.prevPos(sourceCursor, !0)), (0, tiny_invariant_1.default)(sourceLines.charAt(sourceCursor) === targetLines.charAt(targetCursor));
    }
    return sourceCursor;
  }
  return mapping;
}
var hasRequiredLines;
function requireLines() {
  if (hasRequiredLines) return lines;
  hasRequiredLines = 1, Object.defineProperty(lines, "__esModule", { value: !0 }), lines.concat = lines.fromString = lines.countSpaces = lines.Lines = void 0;
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), source_map_1 = tslib_12.__importDefault(requireSourceMap()), options_1 = requireOptions(), util_1 = requireUtil(), mapping_1 = tslib_12.__importDefault(requireMapping()), Lines = (
    /** @class */
    function() {
      function Lines2(infos, sourceFileName) {
        sourceFileName === void 0 && (sourceFileName = null), this.infos = infos, this.mappings = [], this.cachedSourceMap = null, this.cachedTabWidth = void 0, (0, tiny_invariant_1.default)(infos.length > 0), this.length = infos.length, this.name = sourceFileName || null, this.name && this.mappings.push(new mapping_1.default(this, {
          start: this.firstPos(),
          end: this.lastPos()
        }));
      }
      return Lines2.prototype.toString = function(options2) {
        return this.sliceString(this.firstPos(), this.lastPos(), options2);
      }, Lines2.prototype.getSourceMap = function(sourceMapName, sourceRoot) {
        if (!sourceMapName)
          return null;
        var targetLines = this;
        function updateJSON(json2) {
          return json2 = json2 || {}, json2.file = sourceMapName, sourceRoot && (json2.sourceRoot = sourceRoot), json2;
        }
        if (targetLines.cachedSourceMap)
          return updateJSON(targetLines.cachedSourceMap.toJSON());
        var smg = new source_map_1.default.SourceMapGenerator(updateJSON()), sourcesToContents = {};
        return targetLines.mappings.forEach(function(mapping2) {
          for (var sourceCursor = mapping2.sourceLines.skipSpaces(mapping2.sourceLoc.start) || mapping2.sourceLines.lastPos(), targetCursor = targetLines.skipSpaces(mapping2.targetLoc.start) || targetLines.lastPos(); (0, util_1.comparePos)(sourceCursor, mapping2.sourceLoc.end) < 0 && (0, util_1.comparePos)(targetCursor, mapping2.targetLoc.end) < 0; ) {
            var sourceChar = mapping2.sourceLines.charAt(sourceCursor), targetChar = targetLines.charAt(targetCursor);
            (0, tiny_invariant_1.default)(sourceChar === targetChar);
            var sourceName = mapping2.sourceLines.name;
            if (smg.addMapping({
              source: sourceName,
              original: { line: sourceCursor.line, column: sourceCursor.column },
              generated: { line: targetCursor.line, column: targetCursor.column }
            }), !hasOwn2.call(sourcesToContents, sourceName)) {
              var sourceContent = mapping2.sourceLines.toString();
              smg.setSourceContent(sourceName, sourceContent), sourcesToContents[sourceName] = sourceContent;
            }
            targetLines.nextPos(targetCursor, !0), mapping2.sourceLines.nextPos(sourceCursor, !0);
          }
        }), targetLines.cachedSourceMap = smg, smg.toJSON();
      }, Lines2.prototype.bootstrapCharAt = function(pos2) {
        (0, tiny_invariant_1.default)(typeof pos2 == "object"), (0, tiny_invariant_1.default)(typeof pos2.line == "number"), (0, tiny_invariant_1.default)(typeof pos2.column == "number");
        var line3 = pos2.line, column2 = pos2.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line3 - 1];
        return typeof string > "u" ? "" : column2 === string.length && line3 < strings.length ? `
` : column2 >= string.length ? "" : string.charAt(column2);
      }, Lines2.prototype.charAt = function(pos2) {
        (0, tiny_invariant_1.default)(typeof pos2 == "object"), (0, tiny_invariant_1.default)(typeof pos2.line == "number"), (0, tiny_invariant_1.default)(typeof pos2.column == "number");
        var line3 = pos2.line, column2 = pos2.column, secret = this, infos = secret.infos, info = infos[line3 - 1], c2 = column2;
        if (typeof info > "u" || c2 < 0)
          return "";
        var indent = this.getIndentAt(line3);
        return c2 < indent ? " " : (c2 += info.sliceStart - indent, c2 === info.sliceEnd && line3 < this.length ? `
` : c2 >= info.sliceEnd ? "" : info.line.charAt(c2));
      }, Lines2.prototype.stripMargin = function(width, skipFirstLine) {
        if (width === 0)
          return this;
        if ((0, tiny_invariant_1.default)(width > 0, "negative margin: " + width), skipFirstLine && this.length === 1)
          return this;
        var lines2 = new Lines2(this.infos.map(function(info, i2) {
          return info.line && (i2 > 0 || !skipFirstLine) && (info = tslib_12.__assign(tslib_12.__assign({}, info), { indent: Math.max(0, info.indent - width) })), info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_1 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_1.length === 0), this.mappings.forEach(function(mapping2) {
            newMappings_1.push(mapping2.indent(width, skipFirstLine, !0));
          });
        }
        return lines2;
      }, Lines2.prototype.indent = function(by) {
        if (by === 0)
          return this;
        var lines2 = new Lines2(this.infos.map(function(info) {
          return info.line && !info.locked && (info = tslib_12.__assign(tslib_12.__assign({}, info), { indent: info.indent + by })), info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_2 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_2.length === 0), this.mappings.forEach(function(mapping2) {
            newMappings_2.push(mapping2.indent(by));
          });
        }
        return lines2;
      }, Lines2.prototype.indentTail = function(by) {
        if (by === 0)
          return this;
        if (this.length < 2)
          return this;
        var lines2 = new Lines2(this.infos.map(function(info, i2) {
          return i2 > 0 && info.line && !info.locked && (info = tslib_12.__assign(tslib_12.__assign({}, info), { indent: info.indent + by })), info;
        }));
        if (this.mappings.length > 0) {
          var newMappings_3 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_3.length === 0), this.mappings.forEach(function(mapping2) {
            newMappings_3.push(mapping2.indent(by, !0));
          });
        }
        return lines2;
      }, Lines2.prototype.lockIndentTail = function() {
        return this.length < 2 ? this : new Lines2(this.infos.map(function(info, i2) {
          return tslib_12.__assign(tslib_12.__assign({}, info), { locked: i2 > 0 });
        }));
      }, Lines2.prototype.getIndentAt = function(line3) {
        return (0, tiny_invariant_1.default)(line3 >= 1, "no line " + line3 + " (line numbers start from 1)"), Math.max(this.infos[line3 - 1].indent, 0);
      }, Lines2.prototype.guessTabWidth = function() {
        if (typeof this.cachedTabWidth == "number")
          return this.cachedTabWidth;
        for (var counts = [], lastIndent = 0, line3 = 1, last2 = this.length; line3 <= last2; ++line3) {
          var info = this.infos[line3 - 1], sliced = info.line.slice(info.sliceStart, info.sliceEnd);
          if (!isOnlyWhitespace(sliced)) {
            var diff = Math.abs(info.indent - lastIndent);
            counts[diff] = ~~counts[diff] + 1, lastIndent = info.indent;
          }
        }
        for (var maxCount = -1, result = 2, tabWidth = 1; tabWidth < counts.length; tabWidth += 1)
          hasOwn2.call(counts, tabWidth) && counts[tabWidth] > maxCount && (maxCount = counts[tabWidth], result = tabWidth);
        return this.cachedTabWidth = result;
      }, Lines2.prototype.startsWithComment = function() {
        if (this.infos.length === 0)
          return !1;
        var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
        return firstLine.length === 0 || firstLine.slice(0, 2) === "//" || firstLine.slice(0, 2) === "/*";
      }, Lines2.prototype.isOnlyWhitespace = function() {
        return isOnlyWhitespace(this.toString());
      }, Lines2.prototype.isPrecededOnlyByWhitespace = function(pos2) {
        var info = this.infos[pos2.line - 1], indent = Math.max(info.indent, 0), diff = pos2.column - indent;
        if (diff <= 0)
          return !0;
        var start = info.sliceStart, end2 = Math.min(start + diff, info.sliceEnd), prefix = info.line.slice(start, end2);
        return isOnlyWhitespace(prefix);
      }, Lines2.prototype.getLineLength = function(line3) {
        var info = this.infos[line3 - 1];
        return this.getIndentAt(line3) + info.sliceEnd - info.sliceStart;
      }, Lines2.prototype.nextPos = function(pos2, skipSpaces) {
        skipSpaces === void 0 && (skipSpaces = !1);
        var l = Math.max(pos2.line, 0), c2 = Math.max(pos2.column, 0);
        return c2 < this.getLineLength(l) ? (pos2.column += 1, skipSpaces ? !!this.skipSpaces(pos2, !1, !0) : !0) : l < this.length ? (pos2.line += 1, pos2.column = 0, skipSpaces ? !!this.skipSpaces(pos2, !1, !0) : !0) : !1;
      }, Lines2.prototype.prevPos = function(pos2, skipSpaces) {
        skipSpaces === void 0 && (skipSpaces = !1);
        var l = pos2.line, c2 = pos2.column;
        if (c2 < 1) {
          if (l -= 1, l < 1)
            return !1;
          c2 = this.getLineLength(l);
        } else
          c2 = Math.min(c2 - 1, this.getLineLength(l));
        return pos2.line = l, pos2.column = c2, skipSpaces ? !!this.skipSpaces(pos2, !0, !0) : !0;
      }, Lines2.prototype.firstPos = function() {
        return { line: 1, column: 0 };
      }, Lines2.prototype.lastPos = function() {
        return {
          line: this.length,
          column: this.getLineLength(this.length)
        };
      }, Lines2.prototype.skipSpaces = function(pos2, backward, modifyInPlace) {
        if (backward === void 0 && (backward = !1), modifyInPlace === void 0 && (modifyInPlace = !1), pos2 ? pos2 = modifyInPlace ? pos2 : {
          line: pos2.line,
          column: pos2.column
        } : backward ? pos2 = this.lastPos() : pos2 = this.firstPos(), backward) {
          for (; this.prevPos(pos2); )
            if (!isOnlyWhitespace(this.charAt(pos2)) && this.nextPos(pos2))
              return pos2;
          return null;
        } else {
          for (; isOnlyWhitespace(this.charAt(pos2)); )
            if (!this.nextPos(pos2))
              return null;
          return pos2;
        }
      }, Lines2.prototype.trimLeft = function() {
        var pos2 = this.skipSpaces(this.firstPos(), !1, !0);
        return pos2 ? this.slice(pos2) : emptyLines;
      }, Lines2.prototype.trimRight = function() {
        var pos2 = this.skipSpaces(this.lastPos(), !0, !0);
        return pos2 ? this.slice(this.firstPos(), pos2) : emptyLines;
      }, Lines2.prototype.trim = function() {
        var start = this.skipSpaces(this.firstPos(), !1, !0);
        if (start === null)
          return emptyLines;
        var end2 = this.skipSpaces(this.lastPos(), !0, !0);
        return end2 === null ? emptyLines : this.slice(start, end2);
      }, Lines2.prototype.eachPos = function(callback, startPos, skipSpaces) {
        startPos === void 0 && (startPos = this.firstPos()), skipSpaces === void 0 && (skipSpaces = !1);
        var pos2 = this.firstPos();
        if (startPos && (pos2.line = startPos.line, pos2.column = startPos.column), !(skipSpaces && !this.skipSpaces(pos2, !1, !0)))
          do
            callback.call(this, pos2);
          while (this.nextPos(pos2, skipSpaces));
      }, Lines2.prototype.bootstrapSlice = function(start, end2) {
        var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end2.line);
        return strings.length > 0 && (strings.push(strings.pop().slice(0, end2.column)), strings[0] = strings[0].slice(start.column)), fromString(strings.join(`
`));
      }, Lines2.prototype.slice = function(start, end2) {
        if (!end2) {
          if (!start)
            return this;
          end2 = this.lastPos();
        }
        if (!start)
          throw new Error("cannot slice with end but not start");
        var sliced = this.infos.slice(start.line - 1, end2.line);
        start.line === end2.line ? sliced[0] = sliceInfo(sliced[0], start.column, end2.column) : ((0, tiny_invariant_1.default)(start.line < end2.line), sliced[0] = sliceInfo(sliced[0], start.column), sliced.push(sliceInfo(sliced.pop(), 0, end2.column)));
        var lines2 = new Lines2(sliced);
        if (this.mappings.length > 0) {
          var newMappings_4 = lines2.mappings;
          (0, tiny_invariant_1.default)(newMappings_4.length === 0), this.mappings.forEach(function(mapping2) {
            var sliced2 = mapping2.slice(this, start, end2);
            sliced2 && newMappings_4.push(sliced2);
          }, this);
        }
        return lines2;
      }, Lines2.prototype.bootstrapSliceString = function(start, end2, options2) {
        return this.slice(start, end2).toString(options2);
      }, Lines2.prototype.sliceString = function(start, end2, options2) {
        start === void 0 && (start = this.firstPos()), end2 === void 0 && (end2 = this.lastPos());
        for (var _a = (0, options_1.normalize)(options2), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator, parts = [], line3 = start.line; line3 <= end2.line; ++line3) {
          var info = this.infos[line3 - 1];
          line3 === start.line ? line3 === end2.line ? info = sliceInfo(info, start.column, end2.column) : info = sliceInfo(info, start.column) : line3 === end2.line && (info = sliceInfo(info, 0, end2.column));
          var indent = Math.max(info.indent, 0), before_1 = info.line.slice(0, info.sliceStart);
          if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {
            parts.push(info.line.slice(0, info.sliceEnd));
            continue;
          }
          var tabs = 0, spaces = indent;
          useTabs && (tabs = Math.floor(indent / tabWidth), spaces -= tabs * tabWidth);
          var result = "";
          tabs > 0 && (result += new Array(tabs + 1).join("	")), spaces > 0 && (result += new Array(spaces + 1).join(" ")), result += info.line.slice(info.sliceStart, info.sliceEnd), parts.push(result);
        }
        return parts.join(lineTerminator);
      }, Lines2.prototype.isEmpty = function() {
        return this.length < 2 && this.getLineLength(1) < 1;
      }, Lines2.prototype.join = function(elements) {
        var separator2 = this, infos = [], mappings = [], prevInfo;
        function appendLines(linesOrNull) {
          if (linesOrNull !== null) {
            if (prevInfo) {
              var info = linesOrNull.infos[0], indent = new Array(info.indent + 1).join(" "), prevLine_1 = infos.length, prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;
              prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd), prevInfo.locked = prevInfo.locked || info.locked, prevInfo.sliceEnd = prevInfo.line.length, linesOrNull.mappings.length > 0 && linesOrNull.mappings.forEach(function(mapping2) {
                mappings.push(mapping2.add(prevLine_1, prevColumn_1));
              });
            } else linesOrNull.mappings.length > 0 && mappings.push.apply(mappings, linesOrNull.mappings);
            linesOrNull.infos.forEach(function(info2, i2) {
              (!prevInfo || i2 > 0) && (prevInfo = tslib_12.__assign({}, info2), infos.push(prevInfo));
            });
          }
        }
        function appendWithSeparator(linesOrNull, i2) {
          i2 > 0 && appendLines(separator2), appendLines(linesOrNull);
        }
        if (elements.map(function(elem) {
          var lines3 = fromString(elem);
          return lines3.isEmpty() ? null : lines3;
        }).forEach(function(linesOrNull, i2) {
          separator2.isEmpty() ? appendLines(linesOrNull) : appendWithSeparator(linesOrNull, i2);
        }), infos.length < 1)
          return emptyLines;
        var lines2 = new Lines2(infos);
        return lines2.mappings = mappings, lines2;
      }, Lines2.prototype.concat = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        var list2 = [this];
        return list2.push.apply(list2, args), (0, tiny_invariant_1.default)(list2.length === args.length + 1), emptyLines.join(list2);
      }, Lines2;
    }()
  );
  lines.Lines = Lines;
  var fromStringCache = {}, hasOwn2 = fromStringCache.hasOwnProperty, maxCacheKeyLen = 10;
  function countSpaces(spaces, tabWidth) {
    for (var count2 = 0, len = spaces.length, i2 = 0; i2 < len; ++i2)
      switch (spaces.charCodeAt(i2)) {
        case 9: {
          (0, tiny_invariant_1.default)(typeof tabWidth == "number"), (0, tiny_invariant_1.default)(tabWidth > 0);
          var next = Math.ceil(count2 / tabWidth) * tabWidth;
          next === count2 ? count2 += tabWidth : count2 = next;
          break;
        }
        case 11:
        case 12:
        case 13:
        case 65279:
          break;
        case 32:
        default:
          count2 += 1;
          break;
      }
    return count2;
  }
  lines.countSpaces = countSpaces;
  var leadingSpaceExp = /^\s*/, lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
  function fromString(string, options2) {
    if (string instanceof Lines)
      return string;
    string += "";
    var tabWidth = options2 && options2.tabWidth, tabless = string.indexOf("	") < 0, cacheable = !options2 && tabless && string.length <= maxCacheKeyLen;
    if ((0, tiny_invariant_1.default)(tabWidth || tabless, `No tab width specified but encountered tabs in string
` + string), cacheable && hasOwn2.call(fromStringCache, string))
      return fromStringCache[string];
    var lines2 = new Lines(string.split(lineTerminatorSeqExp).map(function(line3) {
      var spaces = leadingSpaceExp.exec(line3)[0];
      return {
        line: line3,
        indent: countSpaces(spaces, tabWidth),
        // Boolean indicating whether this line can be reindented.
        locked: !1,
        sliceStart: spaces.length,
        sliceEnd: line3.length
      };
    }), (0, options_1.normalize)(options2).sourceFileName);
    return cacheable && (fromStringCache[string] = lines2), lines2;
  }
  lines.fromString = fromString;
  function isOnlyWhitespace(string) {
    return !/\S/.test(string);
  }
  function sliceInfo(info, startCol, endCol) {
    var sliceStart = info.sliceStart, sliceEnd = info.sliceEnd, indent = Math.max(info.indent, 0), lineLength = indent + sliceEnd - sliceStart;
    return typeof endCol > "u" && (endCol = lineLength), startCol = Math.max(startCol, 0), endCol = Math.min(endCol, lineLength), endCol = Math.max(endCol, startCol), endCol < indent ? (indent = endCol, sliceEnd = sliceStart) : sliceEnd -= lineLength - endCol, lineLength = endCol, lineLength -= startCol, startCol < indent ? indent -= startCol : (startCol -= indent, indent = 0, sliceStart += startCol), (0, tiny_invariant_1.default)(indent >= 0), (0, tiny_invariant_1.default)(sliceStart <= sliceEnd), (0, tiny_invariant_1.default)(lineLength === indent + sliceEnd - sliceStart), info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd ? info : {
      line: info.line,
      indent,
      // A destructive slice always unlocks indentation.
      locked: !1,
      sliceStart,
      sliceEnd
    };
  }
  function concat2(elements) {
    return emptyLines.join(elements);
  }
  lines.concat = concat2;
  var emptyLines = fromString("");
  return lines;
}
var comments = {}, hasRequiredComments;
function requireComments() {
  if (hasRequiredComments) return comments;
  hasRequiredComments = 1, Object.defineProperty(comments, "__esModule", { value: !0 }), comments.printComments = comments.attach = void 0;
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), types2 = tslib_12.__importStar(requireMain$1()), n = types2.namedTypes, isArray2 = types2.builtInTypes.array, isObject3 = types2.builtInTypes.object, lines_1 = requireLines(), util_1 = requireUtil(), childNodesCache = /* @__PURE__ */ new WeakMap();
  function getSortedChildNodes(node2, lines2, resultArray) {
    if (!node2)
      return resultArray;
    if ((0, util_1.fixFaultyLocations)(node2, lines2), resultArray) {
      if (n.Node.check(node2) && n.SourceLocation.check(node2.loc)) {
        for (var i2 = resultArray.length - 1; i2 >= 0; --i2) {
          var child = resultArray[i2];
          if (child && child.loc && (0, util_1.comparePos)(child.loc.end, node2.loc.start) <= 0)
            break;
        }
        return resultArray.splice(i2 + 1, 0, node2), resultArray;
      }
    } else {
      var childNodes = childNodesCache.get(node2);
      if (childNodes)
        return childNodes;
    }
    var names2;
    if (isArray2.check(node2))
      names2 = Object.keys(node2);
    else if (isObject3.check(node2))
      names2 = types2.getFieldNames(node2);
    else
      return resultArray;
    resultArray || childNodesCache.set(node2, resultArray = []);
    for (var i2 = 0, nameCount = names2.length; i2 < nameCount; ++i2)
      getSortedChildNodes(node2[names2[i2]], lines2, resultArray);
    return resultArray;
  }
  function decorateComment(node2, comment, lines2) {
    for (var childNodes = getSortedChildNodes(node2, lines2), left2 = 0, right2 = childNodes && childNodes.length, precedingNode, followingNode; typeof right2 == "number" && left2 < right2; ) {
      var middle = left2 + right2 >> 1, child = childNodes[middle];
      if ((0, util_1.comparePos)(child.loc.start, comment.loc.start) <= 0 && (0, util_1.comparePos)(comment.loc.end, child.loc.end) <= 0) {
        decorateComment(comment.enclosingNode = child, comment, lines2);
        return;
      }
      if ((0, util_1.comparePos)(child.loc.end, comment.loc.start) <= 0) {
        precedingNode = child, left2 = middle + 1;
        continue;
      }
      if ((0, util_1.comparePos)(comment.loc.end, child.loc.start) <= 0) {
        followingNode = child, right2 = middle;
        continue;
      }
      throw new Error("Comment location overlaps with node location");
    }
    precedingNode && (comment.precedingNode = precedingNode), followingNode && (comment.followingNode = followingNode);
  }
  function attach(comments2, ast, lines2) {
    if (isArray2.check(comments2)) {
      var tiesToBreak = [];
      comments2.forEach(function(comment) {
        comment.loc.lines = lines2, decorateComment(ast, comment, lines2);
        var pn = comment.precedingNode, en = comment.enclosingNode, fn2 = comment.followingNode;
        if (pn && fn2) {
          var tieCount = tiesToBreak.length;
          if (tieCount > 0) {
            var lastTie = tiesToBreak[tieCount - 1];
            (0, tiny_invariant_1.default)(lastTie.precedingNode === comment.precedingNode == (lastTie.followingNode === comment.followingNode)), lastTie.followingNode !== comment.followingNode && breakTies(tiesToBreak, lines2);
          }
          tiesToBreak.push(comment);
        } else if (pn)
          breakTies(tiesToBreak, lines2), addTrailingComment(pn, comment);
        else if (fn2)
          breakTies(tiesToBreak, lines2), addLeadingComment(fn2, comment);
        else if (en)
          breakTies(tiesToBreak, lines2), addDanglingComment(en, comment);
        else
          throw new Error("AST contains no nodes at all?");
      }), breakTies(tiesToBreak, lines2), comments2.forEach(function(comment) {
        delete comment.precedingNode, delete comment.enclosingNode, delete comment.followingNode;
      });
    }
  }
  comments.attach = attach;
  function breakTies(tiesToBreak, lines2) {
    var tieCount = tiesToBreak.length;
    if (tieCount !== 0) {
      for (var pn = tiesToBreak[0].precedingNode, fn2 = tiesToBreak[0].followingNode, gapEndPos = fn2.loc.start, indexOfFirstLeadingComment = tieCount, comment; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
        comment = tiesToBreak[indexOfFirstLeadingComment - 1], (0, tiny_invariant_1.default)(comment.precedingNode === pn), (0, tiny_invariant_1.default)(comment.followingNode === fn2);
        var gap = lines2.sliceString(comment.loc.end, gapEndPos);
        if (/\S/.test(gap))
          break;
        gapEndPos = comment.loc.start;
      }
      for (; indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && // If the comment is a //-style comment and indented more
      // deeply than the node itself, reconsider it as trailing.
      (comment.type === "Line" || comment.type === "CommentLine") && comment.loc.start.column > fn2.loc.start.column; )
        ++indexOfFirstLeadingComment;
      if (indexOfFirstLeadingComment) {
        var enclosingNode = tiesToBreak[indexOfFirstLeadingComment - 1].enclosingNode;
        enclosingNode?.type === "CallExpression" && --indexOfFirstLeadingComment;
      }
      tiesToBreak.forEach(function(comment2, i2) {
        i2 < indexOfFirstLeadingComment ? addTrailingComment(pn, comment2) : addLeadingComment(fn2, comment2);
      }), tiesToBreak.length = 0;
    }
  }
  function addCommentHelper(node2, comment) {
    var comments2 = node2.comments || (node2.comments = []);
    comments2.push(comment);
  }
  function addLeadingComment(node2, comment) {
    comment.leading = !0, comment.trailing = !1, addCommentHelper(node2, comment);
  }
  function addDanglingComment(node2, comment) {
    comment.leading = !1, comment.trailing = !1, addCommentHelper(node2, comment);
  }
  function addTrailingComment(node2, comment) {
    comment.leading = !1, comment.trailing = !0, addCommentHelper(node2, comment);
  }
  function printLeadingComment(commentPath, print) {
    var comment = commentPath.getValue();
    n.Comment.assert(comment);
    var loc = comment.loc, lines2 = loc && loc.lines, parts = [print(commentPath)];
    if (comment.trailing)
      parts.push(`
`);
    else if (lines2 instanceof lines_1.Lines) {
      var trailingSpace = lines2.slice(loc.end, lines2.skipSpaces(loc.end) || lines2.lastPos());
      trailingSpace.length === 1 ? parts.push(trailingSpace) : parts.push(new Array(trailingSpace.length).join(`
`));
    } else
      parts.push(`
`);
    return (0, lines_1.concat)(parts);
  }
  function printTrailingComment(commentPath, print) {
    var comment = commentPath.getValue(commentPath);
    n.Comment.assert(comment);
    var loc = comment.loc, lines2 = loc && loc.lines, parts = [];
    if (lines2 instanceof lines_1.Lines) {
      var fromPos = lines2.skipSpaces(loc.start, !0) || lines2.firstPos(), leadingSpace = lines2.slice(fromPos, loc.start);
      leadingSpace.length === 1 ? parts.push(leadingSpace) : parts.push(new Array(leadingSpace.length).join(`
`));
    }
    return parts.push(print(commentPath)), (0, lines_1.concat)(parts);
  }
  function printComments(path2, print) {
    var value = path2.getValue(), innerLines = print(path2), comments2 = n.Node.check(value) && types2.getFieldValue(value, "comments");
    if (!comments2 || comments2.length === 0)
      return innerLines;
    var leadingParts = [], trailingParts = [innerLines];
    return path2.each(function(commentPath) {
      var comment = commentPath.getValue(), leading = types2.getFieldValue(comment, "leading"), trailing = types2.getFieldValue(comment, "trailing");
      leading || trailing && !(n.Statement.check(value) || comment.type === "Block" || comment.type === "CommentBlock") ? leadingParts.push(printLeadingComment(commentPath, print)) : trailing && trailingParts.push(printTrailingComment(commentPath, print));
    }, "comments"), leadingParts.push.apply(leadingParts, trailingParts), (0, lines_1.concat)(leadingParts);
  }
  return comments.printComments = printComments, comments;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser$1;
  hasRequiredParser = 1, Object.defineProperty(parser$1, "__esModule", { value: !0 }), parser$1.parse = void 0;
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), types2 = tslib_12.__importStar(requireMain$1()), b = types2.builders, isObject3 = types2.builtInTypes.object, isArray2 = types2.builtInTypes.array, options_1 = requireOptions(), lines_1 = requireLines(), comments_1 = requireComments(), util2 = tslib_12.__importStar(requireUtil());
  function parse3(source2, options2) {
    options2 = (0, options_1.normalize)(options2);
    var lines2 = (0, lines_1.fromString)(source2, options2), sourceWithoutTabs = lines2.toString({
      tabWidth: options2.tabWidth,
      reuseWhitespace: !1,
      useTabs: !1
    }), comments2 = [], ast = options2.parser.parse(sourceWithoutTabs, {
      jsx: !0,
      loc: !0,
      locations: !0,
      range: options2.range,
      comment: !0,
      onComment: comments2,
      tolerant: util2.getOption(options2, "tolerant", !0),
      ecmaVersion: 6,
      sourceType: util2.getOption(options2, "sourceType", "module")
    }), tokens = Array.isArray(ast.tokens) ? ast.tokens : requireEsprima$1().tokenize(sourceWithoutTabs, {
      loc: !0
    });
    delete ast.tokens, tokens.forEach(function(token2) {
      typeof token2.value != "string" && (token2.value = lines2.sliceString(token2.loc.start, token2.loc.end));
    }), Array.isArray(ast.comments) && (comments2 = ast.comments, delete ast.comments), ast.loc ? util2.fixFaultyLocations(ast, lines2) : ast.loc = {
      start: lines2.firstPos(),
      end: lines2.lastPos()
    }, ast.loc.lines = lines2, ast.loc.indent = 0;
    var file2, program;
    ast.type === "Program" ? (program = ast, file2 = b.file(ast, options2.sourceFileName || null), file2.loc = {
      start: lines2.firstPos(),
      end: lines2.lastPos(),
      lines: lines2,
      indent: 0
    }) : ast.type === "File" && (file2 = ast, program = file2.program), options2.tokens && (file2.tokens = tokens);
    var trueProgramLoc = util2.getTrueLoc({
      type: program.type,
      loc: program.loc,
      body: [],
      comments: comments2
    }, lines2);
    return program.loc.start = trueProgramLoc.start, program.loc.end = trueProgramLoc.end, (0, comments_1.attach)(comments2, program.body.length ? file2.program : file2, lines2), new TreeCopier(lines2, tokens).copy(file2);
  }
  parser$1.parse = parse3;
  var TreeCopier = function TreeCopier2(lines2, tokens) {
    (0, tiny_invariant_1.default)(this instanceof TreeCopier2), this.lines = lines2, this.tokens = tokens, this.startTokenIndex = 0, this.endTokenIndex = tokens.length, this.indent = 0, this.seen = /* @__PURE__ */ new Map();
  }, TCp = TreeCopier.prototype;
  return TCp.copy = function(node2) {
    if (this.seen.has(node2))
      return this.seen.get(node2);
    if (isArray2.check(node2)) {
      var copy_1 = new Array(node2.length);
      return this.seen.set(node2, copy_1), node2.forEach(function(item, i3) {
        copy_1[i3] = this.copy(item);
      }, this), copy_1;
    }
    if (!isObject3.check(node2))
      return node2;
    util2.fixFaultyLocations(node2, this.lines);
    var copy3 = Object.create(Object.getPrototypeOf(node2), {
      original: {
        // Provide a link from the copy to the original.
        value: node2,
        configurable: !1,
        enumerable: !1,
        writable: !0
      }
    });
    this.seen.set(node2, copy3);
    var loc = node2.loc, oldIndent = this.indent, newIndent = oldIndent, oldStartTokenIndex = this.startTokenIndex, oldEndTokenIndex = this.endTokenIndex;
    loc && ((node2.type === "Block" || node2.type === "Line" || node2.type === "CommentBlock" || node2.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(loc.start)) && (newIndent = this.indent = loc.start.column), loc.lines = this.lines, loc.tokens = this.tokens, loc.indent = newIndent, this.findTokenRange(loc));
    for (var keys = Object.keys(node2), keyCount = keys.length, i2 = 0; i2 < keyCount; ++i2) {
      var key2 = keys[i2];
      key2 === "loc" || key2 === "tokens" && node2.type === "File" ? copy3[key2] = node2[key2] : copy3[key2] = this.copy(node2[key2]);
    }
    return this.indent = oldIndent, this.startTokenIndex = oldStartTokenIndex, this.endTokenIndex = oldEndTokenIndex, copy3;
  }, TCp.findTokenRange = function(loc) {
    for (; this.startTokenIndex > 0; ) {
      var token2 = loc.tokens[this.startTokenIndex];
      if (util2.comparePos(loc.start, token2.loc.start) < 0)
        --this.startTokenIndex;
      else
        break;
    }
    for (; this.endTokenIndex < loc.tokens.length; ) {
      var token2 = loc.tokens[this.endTokenIndex];
      if (util2.comparePos(token2.loc.end, loc.end) < 0)
        ++this.endTokenIndex;
      else
        break;
    }
    for (; this.startTokenIndex < this.endTokenIndex; ) {
      var token2 = loc.tokens[this.startTokenIndex];
      if (util2.comparePos(token2.loc.start, loc.start) < 0)
        ++this.startTokenIndex;
      else
        break;
    }
    for (loc.start.token = this.startTokenIndex; this.endTokenIndex > this.startTokenIndex; ) {
      var token2 = loc.tokens[this.endTokenIndex - 1];
      if (util2.comparePos(loc.end, token2.loc.end) < 0)
        --this.endTokenIndex;
      else
        break;
    }
    loc.end.token = this.endTokenIndex;
  }, parser$1;
}
var printer = {}, fastPath = {}, hasRequiredFastPath;
function requireFastPath() {
  if (hasRequiredFastPath) return fastPath;
  hasRequiredFastPath = 1, Object.defineProperty(fastPath, "__esModule", { value: !0 });
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), types2 = tslib_12.__importStar(requireMain$1()), util2 = tslib_12.__importStar(requireUtil()), n = types2.namedTypes, isArray2 = types2.builtInTypes.array, isNumber2 = types2.builtInTypes.number, PRECEDENCE = {};
  [
    ["??"],
    ["||"],
    ["&&"],
    ["|"],
    ["^"],
    ["&"],
    ["==", "===", "!=", "!=="],
    ["<", ">", "<=", ">=", "in", "instanceof"],
    [">>", "<<", ">>>"],
    ["+", "-"],
    ["*", "/", "%"],
    ["**"]
  ].forEach(function(tier, i2) {
    tier.forEach(function(op) {
      PRECEDENCE[op] = i2;
    });
  });
  var FastPath = function FastPath2(value) {
    (0, tiny_invariant_1.default)(this instanceof FastPath2), this.stack = [value];
  }, FPp = FastPath.prototype;
  FastPath.from = function(obj) {
    if (obj instanceof FastPath)
      return obj.copy();
    if (obj instanceof types2.NodePath) {
      for (var copy3 = Object.create(FastPath.prototype), stack2 = [obj.value], pp = void 0; pp = obj.parentPath; obj = pp)
        stack2.push(obj.name, pp.value);
      return copy3.stack = stack2.reverse(), copy3;
    }
    return new FastPath(obj);
  }, FPp.copy = function() {
    var copy4 = Object.create(FastPath.prototype);
    return copy4.stack = this.stack.slice(0), copy4;
  }, FPp.getName = function() {
    var s = this.stack, len = s.length;
    return len > 1 ? s[len - 2] : null;
  }, FPp.getValue = function() {
    var s = this.stack;
    return s[s.length - 1];
  }, FPp.valueIsDuplicate = function() {
    var s = this.stack, valueIndex = s.length - 1;
    return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
  };
  function getNodeHelper(path2, count2) {
    for (var s = path2.stack, i2 = s.length - 1; i2 >= 0; i2 -= 2) {
      var value = s[i2];
      if (n.Node.check(value) && --count2 < 0)
        return value;
    }
    return null;
  }
  FPp.getNode = function(count2) {
    return count2 === void 0 && (count2 = 0), getNodeHelper(this, ~~count2);
  }, FPp.getParentNode = function(count2) {
    return count2 === void 0 && (count2 = 0), getNodeHelper(this, ~~count2 + 1);
  }, FPp.getRootValue = function() {
    var s = this.stack;
    return s.length % 2 === 0 ? s[1] : s[0];
  }, FPp.call = function(callback) {
    for (var s = this.stack, origLen = s.length, value = s[origLen - 1], argc = arguments.length, i2 = 1; i2 < argc; ++i2) {
      var name = arguments[i2];
      value = value[name], s.push(name, value);
    }
    var result = callback(this);
    return s.length = origLen, result;
  }, FPp.each = function(callback) {
    for (var s = this.stack, origLen = s.length, value = s[origLen - 1], argc = arguments.length, i2 = 1; i2 < argc; ++i2) {
      var name = arguments[i2];
      value = value[name], s.push(name, value);
    }
    for (var i2 = 0; i2 < value.length; ++i2)
      i2 in value && (s.push(i2, value[i2]), callback(this), s.length -= 2);
    s.length = origLen;
  }, FPp.map = function(callback) {
    for (var s = this.stack, origLen = s.length, value = s[origLen - 1], argc = arguments.length, i2 = 1; i2 < argc; ++i2) {
      var name = arguments[i2];
      value = value[name], s.push(name, value);
    }
    for (var result = new Array(value.length), i2 = 0; i2 < value.length; ++i2)
      i2 in value && (s.push(i2, value[i2]), result[i2] = callback(this, i2), s.length -= 2);
    return s.length = origLen, result;
  }, FPp.hasParens = function() {
    var node2 = this.getNode(), prevToken = this.getPrevToken(node2);
    if (!prevToken)
      return !1;
    var nextToken = this.getNextToken(node2);
    if (!nextToken)
      return !1;
    if (prevToken.value === "(") {
      if (nextToken.value === ")")
        return !0;
      var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(!0);
      if (justNeedsOpeningParen)
        return !0;
    }
    return !1;
  }, FPp.getPrevToken = function(node2) {
    node2 = node2 || this.getNode();
    var loc = node2 && node2.loc, tokens = loc && loc.tokens;
    if (tokens && loc.start.token > 0) {
      var token2 = tokens[loc.start.token - 1];
      if (token2) {
        var rootLoc = this.getRootValue().loc;
        if (util2.comparePos(rootLoc.start, token2.loc.start) <= 0)
          return token2;
      }
    }
    return null;
  }, FPp.getNextToken = function(node2) {
    node2 = node2 || this.getNode();
    var loc = node2 && node2.loc, tokens = loc && loc.tokens;
    if (tokens && loc.end.token < tokens.length) {
      var token2 = tokens[loc.end.token];
      if (token2) {
        var rootLoc = this.getRootValue().loc;
        if (util2.comparePos(token2.loc.end, rootLoc.end) <= 0)
          return token2;
      }
    }
    return null;
  }, FPp.needsParens = function(assumeExpressionContext) {
    var node2 = this.getNode();
    if (node2.type === "AssignmentExpression" && node2.left.type === "ObjectPattern")
      return !0;
    var parent = this.getParentNode(), name = this.getName();
    if (this.getValue() !== node2 || n.Statement.check(node2) || node2.type === "Identifier" || parent && parent.type === "ParenthesizedExpression")
      return !1;
    if (node2.extra && node2.extra.parenthesized)
      return !0;
    if (!parent)
      return !1;
    if (node2.type === "UnaryExpression" && parent.type === "BinaryExpression" && name === "left" && parent.left === node2 && parent.operator === "**")
      return !0;
    switch (node2.type) {
      case "UnaryExpression":
      case "SpreadElement":
      case "SpreadProperty":
        return parent.type === "MemberExpression" && name === "object" && parent.object === node2;
      case "BinaryExpression":
      case "LogicalExpression":
        switch (parent.type) {
          case "CallExpression":
            return name === "callee" && parent.callee === node2;
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return !0;
          case "MemberExpression":
            return name === "object" && parent.object === node2;
          case "BinaryExpression":
          case "LogicalExpression": {
            var po = parent.operator, pp = PRECEDENCE[po], no = node2.operator, np = PRECEDENCE[no];
            if (pp > np)
              return !0;
            if (pp === np && name === "right")
              return (0, tiny_invariant_1.default)(parent.right === node2), !0;
            break;
          }
          default:
            return !1;
        }
        break;
      case "SequenceExpression":
        switch (parent.type) {
          case "ReturnStatement":
            return !1;
          case "ForStatement":
            return !1;
          case "ExpressionStatement":
            return name !== "expression";
          default:
            return !0;
        }
      case "OptionalIndexedAccessType":
        return node2.optional && parent.type === "IndexedAccessType";
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return parent.type === "NullableTypeAnnotation";
      case "Literal":
        return parent.type === "MemberExpression" && isNumber2.check(node2.value) && name === "object" && parent.object === node2;
      case "NumericLiteral":
        return parent.type === "MemberExpression" && name === "object" && parent.object === node2;
      case "YieldExpression":
      case "AwaitExpression":
      case "AssignmentExpression":
      case "ConditionalExpression":
        switch (parent.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
            return !0;
          case "CallExpression":
          case "NewExpression":
            return name === "callee" && parent.callee === node2;
          case "ConditionalExpression":
            return name === "test" && parent.test === node2;
          case "MemberExpression":
            return name === "object" && parent.object === node2;
          default:
            return !1;
        }
      case "ArrowFunctionExpression":
        return n.CallExpression.check(parent) && name === "callee" && parent.callee === node2 || n.MemberExpression.check(parent) && name === "object" && parent.object === node2 || n.TSAsExpression && n.TSAsExpression.check(parent) && name === "expression" && parent.expression === node2 ? !0 : isBinary2(parent);
      case "ObjectExpression":
        if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node2)
          return !0;
        break;
      case "TSAsExpression":
        if (parent.type === "ArrowFunctionExpression" && name === "body" && parent.body === node2 && node2.expression.type === "ObjectExpression")
          return !0;
        break;
      case "CallExpression":
        if (name === "declaration" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node2.callee))
          return !0;
    }
    return parent.type === "NewExpression" && name === "callee" && parent.callee === node2 ? containsCallExpression(node2) : !!(assumeExpressionContext !== !0 && !this.canBeFirstInStatement() && this.firstInStatement());
  };
  function isBinary2(node2) {
    return n.BinaryExpression.check(node2) || n.LogicalExpression.check(node2);
  }
  function containsCallExpression(node2) {
    return n.CallExpression.check(node2) ? !0 : isArray2.check(node2) ? node2.some(containsCallExpression) : n.Node.check(node2) ? types2.someField(node2, function(_name, child) {
      return containsCallExpression(child);
    }) : !1;
  }
  return FPp.canBeFirstInStatement = function() {
    var node2 = this.getNode();
    return !(n.FunctionExpression.check(node2) || n.ObjectExpression.check(node2) || n.ClassExpression.check(node2));
  }, FPp.firstInStatement = function() {
    for (var s = this.stack, parentName, parent, childName, child, i2 = s.length - 1; i2 >= 0; i2 -= 2)
      if (n.Node.check(s[i2]) && (childName = parentName, child = parent, parentName = s[i2 - 1], parent = s[i2]), !(!parent || !child)) {
        if (n.BlockStatement.check(parent) && parentName === "body" && childName === 0)
          return (0, tiny_invariant_1.default)(parent.body[0] === child), !0;
        if (n.ExpressionStatement.check(parent) && childName === "expression")
          return (0, tiny_invariant_1.default)(parent.expression === child), !0;
        if (n.AssignmentExpression.check(parent) && childName === "left")
          return (0, tiny_invariant_1.default)(parent.left === child), !0;
        if (n.ArrowFunctionExpression.check(parent) && childName === "body")
          return (0, tiny_invariant_1.default)(parent.body === child), !0;
        if (n.SequenceExpression.check(parent) && s[i2 + 1] === "expressions" && childName === 0) {
          (0, tiny_invariant_1.default)(parent.expressions[0] === child);
          continue;
        }
        if (n.CallExpression.check(parent) && childName === "callee") {
          (0, tiny_invariant_1.default)(parent.callee === child);
          continue;
        }
        if (n.MemberExpression.check(parent) && childName === "object") {
          (0, tiny_invariant_1.default)(parent.object === child);
          continue;
        }
        if (n.ConditionalExpression.check(parent) && childName === "test") {
          (0, tiny_invariant_1.default)(parent.test === child);
          continue;
        }
        if (isBinary2(parent) && childName === "left") {
          (0, tiny_invariant_1.default)(parent.left === child);
          continue;
        }
        if (n.UnaryExpression.check(parent) && !parent.prefix && childName === "argument") {
          (0, tiny_invariant_1.default)(parent.argument === child);
          continue;
        }
        return !1;
      }
    return !0;
  }, fastPath.default = FastPath, fastPath;
}
var patcher = {}, hasRequiredPatcher;
function requirePatcher() {
  if (hasRequiredPatcher) return patcher;
  hasRequiredPatcher = 1, Object.defineProperty(patcher, "__esModule", { value: !0 }), patcher.getReprinter = patcher.Patcher = void 0;
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), linesModule = tslib_12.__importStar(requireLines()), types2 = tslib_12.__importStar(requireMain$1()), Printable = types2.namedTypes.Printable, Expression = types2.namedTypes.Expression, ReturnStatement = types2.namedTypes.ReturnStatement, SourceLocation = types2.namedTypes.SourceLocation, util_1 = requireUtil(), fast_path_1 = tslib_12.__importDefault(requireFastPath()), isObject3 = types2.builtInTypes.object, isArray2 = types2.builtInTypes.array, isString = types2.builtInTypes.string, riskyAdjoiningCharExp = /[0-9a-z_$]/i, Patcher = function Patcher2(lines2) {
    (0, tiny_invariant_1.default)(this instanceof Patcher2), (0, tiny_invariant_1.default)(lines2 instanceof linesModule.Lines);
    var self2 = this, replacements = [];
    self2.replace = function(loc, lines3) {
      isString.check(lines3) && (lines3 = linesModule.fromString(lines3)), replacements.push({
        lines: lines3,
        start: loc.start,
        end: loc.end
      });
    }, self2.get = function(loc) {
      loc = loc || {
        start: { line: 1, column: 0 },
        end: { line: lines2.length, column: lines2.getLineLength(lines2.length) }
      };
      var sliceFrom = loc.start, toConcat = [];
      function pushSlice(from2, to) {
        (0, tiny_invariant_1.default)((0, util_1.comparePos)(from2, to) <= 0), toConcat.push(lines2.slice(from2, to));
      }
      return replacements.sort(function(a, b) {
        return (0, util_1.comparePos)(a.start, b.start);
      }).forEach(function(rep) {
        (0, util_1.comparePos)(sliceFrom, rep.start) > 0 || (pushSlice(sliceFrom, rep.start), toConcat.push(rep.lines), sliceFrom = rep.end);
      }), pushSlice(sliceFrom, loc.end), linesModule.concat(toConcat);
    };
  };
  patcher.Patcher = Patcher;
  var Pp = Patcher.prototype;
  Pp.tryToReprintComments = function(newNode, oldNode, print) {
    var patcher2 = this;
    if (!newNode.comments && !oldNode.comments)
      return !0;
    var newPath = fast_path_1.default.from(newNode), oldPath = fast_path_1.default.from(oldNode);
    newPath.stack.push("comments", getSurroundingComments(newNode)), oldPath.stack.push("comments", getSurroundingComments(oldNode));
    var reprints = [], ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
    return ableToReprintComments && reprints.length > 0 && reprints.forEach(function(reprint) {
      var oldComment = reprint.oldPath.getValue();
      (0, tiny_invariant_1.default)(oldComment.leading || oldComment.trailing), patcher2.replace(
        oldComment.loc,
        // Comments can't have .comments, so it doesn't matter whether we
        // print with comments or without.
        print(reprint.newPath).indentTail(oldComment.loc.indent)
      );
    }), ableToReprintComments;
  };
  function getSurroundingComments(node2) {
    var result = [];
    return node2.comments && node2.comments.length > 0 && node2.comments.forEach(function(comment) {
      (comment.leading || comment.trailing) && result.push(comment);
    }), result;
  }
  Pp.deleteComments = function(node2) {
    if (node2.comments) {
      var patcher2 = this;
      node2.comments.forEach(function(comment) {
        comment.leading ? patcher2.replace({
          start: comment.loc.start,
          end: node2.loc.lines.skipSpaces(comment.loc.end, !1, !1)
        }, "") : comment.trailing && patcher2.replace({
          start: node2.loc.lines.skipSpaces(comment.loc.start, !0, !1),
          end: comment.loc.end
        }, "");
      });
    }
  };
  function getReprinter(path2) {
    (0, tiny_invariant_1.default)(path2 instanceof fast_path_1.default);
    var node2 = path2.getValue();
    if (Printable.check(node2)) {
      var orig = node2.original, origLoc = orig && orig.loc, lines2 = origLoc && origLoc.lines, reprints = [];
      if (!(!lines2 || !findReprints(path2, reprints)))
        return function(print) {
          var patcher2 = new Patcher(lines2);
          reprints.forEach(function(reprint) {
            var newNode = reprint.newPath.getValue(), oldNode = reprint.oldPath.getValue();
            SourceLocation.assert(oldNode.loc, !0);
            var needToPrintNewPathWithComments = !patcher2.tryToReprintComments(newNode, oldNode, print);
            needToPrintNewPathWithComments && patcher2.deleteComments(oldNode);
            var newLines = print(reprint.newPath, {
              includeComments: needToPrintNewPathWithComments,
              // If the oldNode we're replacing already had parentheses, we may
              // not need to print the new node with any extra parentheses,
              // because the existing parentheses will suffice. However, if the
              // newNode has a different type than the oldNode, let the printer
              // decide if reprint.newPath needs parentheses, as usual.
              avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()
            }).indentTail(oldNode.loc.indent), nls = needsLeadingSpace(lines2, oldNode.loc, newLines), nts = needsTrailingSpace(lines2, oldNode.loc, newLines);
            if (nls || nts) {
              var newParts = [];
              nls && newParts.push(" "), newParts.push(newLines), nts && newParts.push(" "), newLines = linesModule.concat(newParts);
            }
            patcher2.replace(oldNode.loc, newLines);
          });
          var patchedLines = patcher2.get(origLoc).indentTail(-orig.loc.indent);
          return path2.needsParens() ? linesModule.concat(["(", patchedLines, ")"]) : patchedLines;
        };
    }
  }
  patcher.getReprinter = getReprinter;
  function needsLeadingSpace(oldLines, oldLoc, newLines) {
    var posBeforeOldLoc = (0, util_1.copyPos)(oldLoc.start), charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc), newFirstChar = newLines.charAt(newLines.firstPos());
    return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);
  }
  function needsTrailingSpace(oldLines, oldLoc, newLines) {
    var charAfterOldLoc = oldLines.charAt(oldLoc.end), newLastPos = newLines.lastPos(), newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
    return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);
  }
  function findReprints(newPath, reprints) {
    var newNode = newPath.getValue();
    Printable.assert(newNode);
    var oldNode = newNode.original;
    if (Printable.assert(oldNode), (0, tiny_invariant_1.default)(reprints.length === 0), newNode.type !== oldNode.type)
      return !1;
    var oldPath = new fast_path_1.default(oldNode), canReprint = findChildReprints(newPath, oldPath, reprints);
    return canReprint || (reprints.length = 0), canReprint;
  }
  function findAnyReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue(), oldNode = oldPath.getValue();
    return newNode === oldNode ? !0 : isArray2.check(newNode) ? findArrayReprints(newPath, oldPath, reprints) : isObject3.check(newNode) ? findObjectReprints(newPath, oldPath, reprints) : !1;
  }
  function findArrayReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue(), oldNode = oldPath.getValue();
    if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate())
      return !0;
    isArray2.assert(newNode);
    var len = newNode.length;
    if (!(isArray2.check(oldNode) && oldNode.length === len))
      return !1;
    for (var i2 = 0; i2 < len; ++i2) {
      newPath.stack.push(i2, newNode[i2]), oldPath.stack.push(i2, oldNode[i2]);
      var canReprint = findAnyReprints(newPath, oldPath, reprints);
      if (newPath.stack.length -= 2, oldPath.stack.length -= 2, !canReprint)
        return !1;
    }
    return !0;
  }
  function findObjectReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue();
    if (isObject3.assert(newNode), newNode.original === null)
      return !1;
    var oldNode = oldPath.getValue();
    if (!isObject3.check(oldNode))
      return !1;
    if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate())
      return !0;
    if (Printable.check(newNode)) {
      if (!Printable.check(oldNode))
        return !1;
      var newParentNode = newPath.getParentNode(), oldParentNode = oldPath.getParentNode();
      if (oldParentNode !== null && oldParentNode.type === "FunctionTypeAnnotation" && newParentNode !== null && newParentNode.type === "FunctionTypeAnnotation") {
        var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name, newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
        if (!oldNeedsParens && newNeedParens)
          return !1;
      }
      if (newNode.type === oldNode.type) {
        var childReprints = [];
        if (findChildReprints(newPath, oldPath, childReprints))
          reprints.push.apply(reprints, childReprints);
        else if (oldNode.loc)
          reprints.push({
            oldPath: oldPath.copy(),
            newPath: newPath.copy()
          });
        else
          return !1;
        return !0;
      }
      return Expression.check(newNode) && Expression.check(oldNode) && // If we have no .loc information for oldNode, then we won't be
      // able to reprint it.
      oldNode.loc ? (reprints.push({
        oldPath: oldPath.copy(),
        newPath: newPath.copy()
      }), !0) : !1;
    }
    return findChildReprints(newPath, oldPath, reprints);
  }
  function findChildReprints(newPath, oldPath, reprints) {
    var newNode = newPath.getValue(), oldNode = oldPath.getValue();
    if (isObject3.assert(newNode), isObject3.assert(oldNode), newNode.original === null || newPath.needsParens() && !oldPath.hasParens())
      return !1;
    var keys = (0, util_1.getUnionOfKeys)(oldNode, newNode);
    (oldNode.type === "File" || newNode.type === "File") && delete keys.tokens, delete keys.loc;
    var originalReprintCount = reprints.length;
    for (var k in keys)
      if (k.charAt(0) !== "_") {
        newPath.stack.push(k, types2.getFieldValue(newNode, k)), oldPath.stack.push(k, types2.getFieldValue(oldNode, k));
        var canReprint = findAnyReprints(newPath, oldPath, reprints);
        if (newPath.stack.length -= 2, oldPath.stack.length -= 2, !canReprint)
          return !1;
      }
    return !(ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount);
  }
  return patcher;
}
var hasRequiredPrinter;
function requirePrinter() {
  if (hasRequiredPrinter) return printer;
  hasRequiredPrinter = 1, Object.defineProperty(printer, "__esModule", { value: !0 }), printer.Printer = void 0;
  var tslib_12 = require$$0$3, tiny_invariant_1 = tslib_12.__importDefault(requireTinyInvariant_cjs()), types2 = tslib_12.__importStar(requireMain$1()), comments_1 = requireComments(), fast_path_1 = tslib_12.__importDefault(requireFastPath()), lines_1 = requireLines(), options_1 = requireOptions(), patcher_1 = requirePatcher(), util2 = tslib_12.__importStar(requireUtil()), namedTypes2 = types2.namedTypes, isString = types2.builtInTypes.string, isObject3 = types2.builtInTypes.object, PrintResult = function PrintResult2(code, sourceMap2) {
    (0, tiny_invariant_1.default)(this instanceof PrintResult2), isString.assert(code), this.code = code, sourceMap2 && (isObject3.assert(sourceMap2), this.map = sourceMap2);
  }, PRp = PrintResult.prototype, warnedAboutToString = !1;
  PRp.toString = function() {
    return warnedAboutToString || (console.warn("Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged."), warnedAboutToString = !0), this.code;
  };
  var emptyPrintResult = new PrintResult(""), Printer = function Printer2(config2) {
    (0, tiny_invariant_1.default)(this instanceof Printer2);
    var explicitTabWidth = config2 && config2.tabWidth;
    config2 = (0, options_1.normalize)(config2), config2.sourceFileName = null;
    function makePrintFunctionWith(options2, overrides) {
      return options2 = Object.assign({}, options2, overrides), function(path2) {
        return print(path2, options2);
      };
    }
    function print(path2, options2) {
      if ((0, tiny_invariant_1.default)(path2 instanceof fast_path_1.default), options2 = options2 || {}, options2.includeComments)
        return (0, comments_1.printComments)(path2, makePrintFunctionWith(options2, {
          includeComments: !1
        }));
      var oldTabWidth = config2.tabWidth;
      if (!explicitTabWidth) {
        var loc = path2.getNode().loc;
        loc && loc.lines && loc.lines.guessTabWidth && (config2.tabWidth = loc.lines.guessTabWidth());
      }
      var reprinter = (0, patcher_1.getReprinter)(path2), lines2 = reprinter ? (
        // Since the print function that we pass to the reprinter will
        // be used to print "new" nodes, it's tempting to think we
        // should pass printRootGenerically instead of print, to avoid
        // calling maybeReprint again, but that would be a mistake
        // because the new nodes might not be entirely new, but merely
        // moved from elsewhere in the AST. The print function is the
        // right choice because it gives us the opportunity to reprint
        // such nodes using their original source.
        reprinter(print)
      ) : genericPrint(path2, config2, options2, makePrintFunctionWith(options2, {
        includeComments: !0,
        avoidRootParens: !1
      }));
      return config2.tabWidth = oldTabWidth, lines2;
    }
    this.print = function(ast) {
      if (!ast)
        return emptyPrintResult;
      var lines2 = print(fast_path_1.default.from(ast), {
        includeComments: !0,
        avoidRootParens: !1
      });
      return new PrintResult(lines2.toString(config2), util2.composeSourceMaps(config2.inputSourceMap, lines2.getSourceMap(config2.sourceMapName, config2.sourceRoot)));
    }, this.printGenerically = function(ast) {
      if (!ast)
        return emptyPrintResult;
      function printGenerically(path3) {
        return (0, comments_1.printComments)(path3, function(path4) {
          return genericPrint(path4, config2, {
            includeComments: !0,
            avoidRootParens: !1
          }, printGenerically);
        });
      }
      var path2 = fast_path_1.default.from(ast), oldReuseWhitespace = config2.reuseWhitespace;
      config2.reuseWhitespace = !1;
      var pr = new PrintResult(printGenerically(path2).toString(config2));
      return config2.reuseWhitespace = oldReuseWhitespace, pr;
    };
  };
  printer.Printer = Printer;
  function genericPrint(path2, config2, options2, printPath) {
    (0, tiny_invariant_1.default)(path2 instanceof fast_path_1.default);
    var node2 = path2.getValue(), parts = [], linesWithoutParens = genericPrintNoParens(path2, config2, printPath);
    if (!node2 || linesWithoutParens.isEmpty())
      return linesWithoutParens;
    var shouldAddParens = !1, decoratorsLines = printDecorators(path2, printPath);
    return decoratorsLines.isEmpty() ? options2.avoidRootParens || (shouldAddParens = path2.needsParens()) : parts.push(decoratorsLines), shouldAddParens && parts.unshift("("), parts.push(linesWithoutParens), shouldAddParens && parts.push(")"), (0, lines_1.concat)(parts);
  }
  function genericPrintNoParens(path2, options2, print) {
    var n = path2.getValue();
    if (!n)
      return (0, lines_1.fromString)("");
    if (typeof n == "string")
      return (0, lines_1.fromString)(n, options2);
    namedTypes2.Printable.assert(n);
    var parts = [];
    switch (n.type) {
      case "File":
        return path2.call(print, "program");
      case "Program":
        return n.directives && path2.each(function(childPath) {
          parts.push(print(childPath), `;
`);
        }, "directives"), n.interpreter && parts.push(path2.call(print, "interpreter")), parts.push(path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body")), (0, lines_1.concat)(parts);
      case "Noop":
      case "EmptyStatement":
        return (0, lines_1.fromString)("");
      case "ExpressionStatement":
        return (0, lines_1.concat)([path2.call(print, "expression"), ";"]);
      case "ParenthesizedExpression":
        return (0, lines_1.concat)(["(", path2.call(print, "expression"), ")"]);
      case "BinaryExpression":
      case "LogicalExpression":
      case "AssignmentExpression":
        return (0, lines_1.fromString)(" ").join([
          path2.call(print, "left"),
          n.operator,
          path2.call(print, "right")
        ]);
      case "AssignmentPattern":
        return (0, lines_1.concat)([
          path2.call(print, "left"),
          " = ",
          path2.call(print, "right")
        ]);
      case "MemberExpression":
      case "OptionalMemberExpression": {
        parts.push(path2.call(print, "object"));
        var property = path2.call(print, "property"), optional = types2.getFieldValue(n, "optional");
        return n.computed ? parts.push(optional ? "?.[" : "[", property, "]") : parts.push(optional ? "?." : ".", property), (0, lines_1.concat)(parts);
      }
      case "ChainExpression":
        return path2.call(print, "expression");
      case "MetaProperty":
        return (0, lines_1.concat)([
          path2.call(print, "meta"),
          ".",
          path2.call(print, "property")
        ]);
      case "BindExpression":
        return n.object && parts.push(path2.call(print, "object")), parts.push("::", path2.call(print, "callee")), (0, lines_1.concat)(parts);
      case "Path":
        return (0, lines_1.fromString)(".").join(n.body);
      case "Identifier":
        return (0, lines_1.concat)([
          (0, lines_1.fromString)(n.name, options2),
          n.optional ? "?" : "",
          path2.call(print, "typeAnnotation")
        ]);
      case "SpreadElement":
      case "SpreadElementPattern":
      case "RestProperty":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "ObjectTypeSpreadProperty":
      case "RestElement":
        return (0, lines_1.concat)([
          "...",
          path2.call(print, "argument"),
          path2.call(print, "typeAnnotation")
        ]);
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "TSDeclareFunction":
        return n.declare && parts.push("declare "), n.async && parts.push("async "), parts.push("function"), n.generator && parts.push("*"), n.id ? parts.push(" ", path2.call(print, "id"), path2.call(print, "typeParameters")) : n.typeParameters && parts.push(path2.call(print, "typeParameters")), parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType")), n.body && parts.push(" ", path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "ArrowFunctionExpression":
        return n.async && parts.push("async "), n.typeParameters && parts.push(path2.call(print, "typeParameters")), !options2.arrowParensAlways && n.params.length === 1 && !n.rest && n.params[0].type === "Identifier" && !n.params[0].typeAnnotation && !n.returnType ? parts.push(path2.call(print, "params", 0)) : parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType")), parts.push(" => ", path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "MethodDefinition":
        return printMethod(path2, options2, print);
      case "YieldExpression":
        return parts.push("yield"), n.delegate && parts.push("*"), n.argument && parts.push(" ", path2.call(print, "argument")), (0, lines_1.concat)(parts);
      case "AwaitExpression":
        return parts.push("await"), n.all && parts.push("*"), n.argument && parts.push(" ", path2.call(print, "argument")), (0, lines_1.concat)(parts);
      case "ModuleExpression":
        return (0, lines_1.concat)([
          `module {
`,
          path2.call(print, "body").indent(options2.tabWidth),
          `
}`
        ]);
      case "ModuleDeclaration":
        return parts.push("module", path2.call(print, "id")), n.source ? ((0, tiny_invariant_1.default)(!n.body), parts.push("from", path2.call(print, "source"))) : parts.push(path2.call(print, "body")), (0, lines_1.fromString)(" ").join(parts);
      case "ImportSpecifier":
        return n.importKind && n.importKind !== "value" && parts.push(n.importKind + " "), n.imported ? (parts.push(path2.call(print, "imported")), n.local && n.local.name !== n.imported.name && parts.push(" as ", path2.call(print, "local"))) : n.id && (parts.push(path2.call(print, "id")), n.name && parts.push(" as ", path2.call(print, "name"))), (0, lines_1.concat)(parts);
      case "ExportSpecifier":
        return n.exportKind && n.exportKind !== "value" && parts.push(n.exportKind + " "), n.local ? (parts.push(path2.call(print, "local")), n.exported && n.exported.name !== n.local.name && parts.push(" as ", path2.call(print, "exported"))) : n.id && (parts.push(path2.call(print, "id")), n.name && parts.push(" as ", path2.call(print, "name"))), (0, lines_1.concat)(parts);
      case "ExportBatchSpecifier":
        return (0, lines_1.fromString)("*");
      case "ImportNamespaceSpecifier":
        return parts.push("* as "), n.local ? parts.push(path2.call(print, "local")) : n.id && parts.push(path2.call(print, "id")), (0, lines_1.concat)(parts);
      case "ImportDefaultSpecifier":
        return n.local ? path2.call(print, "local") : path2.call(print, "id");
      case "TSExportAssignment":
        return (0, lines_1.concat)(["export = ", path2.call(print, "expression")]);
      case "ExportDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return printExportDeclaration(path2, options2, print);
      case "ExportAllDeclaration":
        return parts.push("export *"), n.exported && parts.push(" as ", path2.call(print, "exported")), parts.push(" from ", path2.call(print, "source"), ";"), (0, lines_1.concat)(parts);
      case "TSNamespaceExportDeclaration":
        return parts.push("export as namespace ", path2.call(print, "id")), maybeAddSemicolon((0, lines_1.concat)(parts));
      case "ExportNamespaceSpecifier":
        return (0, lines_1.concat)(["* as ", path2.call(print, "exported")]);
      case "ExportDefaultSpecifier":
        return path2.call(print, "exported");
      case "Import":
        return (0, lines_1.fromString)("import", options2);
      case "ImportExpression":
        return (0, lines_1.concat)(["import(", path2.call(print, "source"), ")"]);
      case "ImportDeclaration": {
        if (parts.push("import "), n.importKind && n.importKind !== "value" && parts.push(n.importKind + " "), n.specifiers && n.specifiers.length > 0) {
          var unbracedSpecifiers_1 = [], bracedSpecifiers_1 = [];
          if (path2.each(function(specifierPath) {
            var spec = specifierPath.getValue();
            spec.type === "ImportSpecifier" ? bracedSpecifiers_1.push(print(specifierPath)) : (spec.type === "ImportDefaultSpecifier" || spec.type === "ImportNamespaceSpecifier") && unbracedSpecifiers_1.push(print(specifierPath));
          }, "specifiers"), unbracedSpecifiers_1.forEach(function(lines3, i2) {
            i2 > 0 && parts.push(", "), parts.push(lines3);
          }), bracedSpecifiers_1.length > 0) {
            var lines2 = (0, lines_1.fromString)(", ").join(bracedSpecifiers_1);
            lines2.getLineLength(1) > options2.wrapColumn && (lines2 = (0, lines_1.concat)([
              (0, lines_1.fromString)(`,
`).join(bracedSpecifiers_1).indent(options2.tabWidth),
              ","
            ])), unbracedSpecifiers_1.length > 0 && parts.push(", "), lines2.length > 1 ? parts.push(`{
`, lines2, `
}`) : options2.objectCurlySpacing ? parts.push("{ ", lines2, " }") : parts.push("{", lines2, "}");
          }
          parts.push(" from ");
        }
        return parts.push(path2.call(print, "source"), maybePrintImportAssertions(path2, options2, print), ";"), (0, lines_1.concat)(parts);
      }
      case "ImportAttribute":
        return (0, lines_1.concat)([path2.call(print, "key"), ": ", path2.call(print, "value")]);
      case "StaticBlock":
        parts.push("static ");
      case "BlockStatement": {
        var naked_1 = path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body");
        return naked_1.isEmpty() && (!n.directives || n.directives.length === 0) ? (parts.push("{}"), (0, lines_1.concat)(parts)) : (parts.push(`{
`), n.directives && path2.each(function(childPath) {
          parts.push(maybeAddSemicolon(print(childPath).indent(options2.tabWidth)), n.directives.length > 1 || !naked_1.isEmpty() ? `
` : "");
        }, "directives"), parts.push(naked_1.indent(options2.tabWidth)), parts.push(`
}`), (0, lines_1.concat)(parts));
      }
      case "ReturnStatement": {
        if (parts.push("return"), n.argument) {
          var argLines = path2.call(print, "argument");
          argLines.startsWithComment() || argLines.length > 1 && namedTypes2.JSXElement && namedTypes2.JSXElement.check(n.argument) ? parts.push(` (
`, argLines.indent(options2.tabWidth), `
)`) : parts.push(" ", argLines);
        }
        return parts.push(";"), (0, lines_1.concat)(parts);
      }
      case "CallExpression":
      case "OptionalCallExpression":
        return parts.push(path2.call(print, "callee")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), n.typeArguments && parts.push(path2.call(print, "typeArguments")), types2.getFieldValue(n, "optional") && parts.push("?."), parts.push(printArgumentsList(path2, options2, print)), (0, lines_1.concat)(parts);
      case "RecordExpression":
        parts.push("#");
      case "ObjectExpression":
      case "ObjectPattern":
      case "ObjectTypeAnnotation": {
        var isTypeAnnotation_1 = n.type === "ObjectTypeAnnotation", separator_1 = options2.flowObjectCommas ? "," : isTypeAnnotation_1 ? ";" : ",", fields = [], allowBreak_1 = !1;
        isTypeAnnotation_1 && (fields.push("indexers", "callProperties"), n.internalSlots != null && fields.push("internalSlots")), fields.push("properties");
        var len_1 = 0;
        fields.forEach(function(field) {
          len_1 += n[field].length;
        });
        var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0, leftBrace = n.exact ? "{|" : "{", rightBrace = n.exact ? "|}" : "}";
        parts.push(oneLine_1 ? leftBrace : leftBrace + `
`);
        var leftBraceIndex = parts.length - 1, i_1 = 0;
        if (fields.forEach(function(field) {
          path2.each(function(childPath) {
            var lines3 = print(childPath);
            oneLine_1 || (lines3 = lines3.indent(options2.tabWidth));
            var multiLine = !isTypeAnnotation_1 && lines3.length > 1;
            multiLine && allowBreak_1 && parts.push(`
`), parts.push(lines3), i_1 < len_1 - 1 ? (parts.push(separator_1 + (multiLine ? `

` : `
`)), allowBreak_1 = !multiLine) : (len_1 !== 1 && isTypeAnnotation_1 || !oneLine_1 && util2.isTrailingCommaEnabled(options2, "objects") && childPath.getValue().type !== "RestElement") && parts.push(separator_1), i_1++;
          }, field);
        }), n.inexact) {
          var line3 = (0, lines_1.fromString)("...", options2);
          oneLine_1 ? (len_1 > 0 && parts.push(separator_1, " "), parts.push(line3)) : parts.push(`
`, line3.indent(options2.tabWidth));
        }
        return parts.push(oneLine_1 ? rightBrace : `
` + rightBrace), i_1 !== 0 && oneLine_1 && options2.objectCurlySpacing && (parts[leftBraceIndex] = leftBrace + " ", parts[parts.length - 1] = " " + rightBrace), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "PropertyPattern":
        return (0, lines_1.concat)([
          path2.call(print, "key"),
          ": ",
          path2.call(print, "pattern")
        ]);
      case "ObjectProperty":
      case "Property": {
        if (n.method || n.kind === "get" || n.kind === "set")
          return printMethod(path2, options2, print);
        if (n.shorthand && n.value.type === "AssignmentPattern")
          return path2.call(print, "value");
        var key2 = path2.call(print, "key");
        return n.computed ? parts.push("[", key2, "]") : parts.push(key2), (!n.shorthand || n.key.name !== n.value.name) && parts.push(": ", path2.call(print, "value")), (0, lines_1.concat)(parts);
      }
      case "ClassMethod":
      case "ObjectMethod":
      case "ClassPrivateMethod":
      case "TSDeclareMethod":
        return printMethod(path2, options2, print);
      case "PrivateName":
        return (0, lines_1.concat)(["#", path2.call(print, "id")]);
      case "Decorator":
        return (0, lines_1.concat)(["@", path2.call(print, "expression")]);
      case "TupleExpression":
        parts.push("#");
      case "ArrayExpression":
      case "ArrayPattern": {
        var elems = n.elements, len_2 = elems.length, printed_1 = path2.map(print, "elements"), joined = (0, lines_1.fromString)(", ").join(printed_1), oneLine_2 = joined.getLineLength(1) <= options2.wrapColumn;
        return oneLine_2 ? options2.arrayBracketSpacing ? parts.push("[ ") : parts.push("[") : parts.push(`[
`), path2.each(function(elemPath) {
          var i2 = elemPath.getName(), elem = elemPath.getValue();
          if (!elem)
            parts.push(",");
          else {
            var lines3 = printed_1[i2];
            oneLine_2 ? i2 > 0 && parts.push(" ") : lines3 = lines3.indent(options2.tabWidth), parts.push(lines3), (i2 < len_2 - 1 || !oneLine_2 && util2.isTrailingCommaEnabled(options2, "arrays")) && parts.push(","), oneLine_2 || parts.push(`
`);
          }
        }, "elements"), oneLine_2 && options2.arrayBracketSpacing ? parts.push(" ]") : parts.push("]"), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "SequenceExpression":
        return (0, lines_1.fromString)(", ").join(path2.map(print, "expressions"));
      case "ThisExpression":
        return (0, lines_1.fromString)("this");
      case "Super":
        return (0, lines_1.fromString)("super");
      case "NullLiteral":
        return (0, lines_1.fromString)("null");
      case "RegExpLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || "/".concat(n.pattern, "/").concat(n.flags || ""), options2);
      case "BigIntLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "n", options2);
      case "NumericLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || n.value, options2);
      case "DecimalLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "m", options2);
      case "StringLiteral":
        return (0, lines_1.fromString)(nodeStr(n.value, options2));
      case "BooleanLiteral":
      case "Literal":
        return (0, lines_1.fromString)(getPossibleRaw(n) || (typeof n.value == "string" ? nodeStr(n.value, options2) : n.value), options2);
      case "Directive":
        return path2.call(print, "value");
      case "DirectiveLiteral":
        return (0, lines_1.fromString)(getPossibleRaw(n) || nodeStr(n.value, options2), options2);
      case "InterpreterDirective":
        return (0, lines_1.fromString)("#!".concat(n.value, `
`), options2);
      case "ModuleSpecifier":
        if (n.local)
          throw new Error("The ESTree ModuleSpecifier type should be abstract");
        return (0, lines_1.fromString)(nodeStr(n.value, options2), options2);
      case "UnaryExpression":
        return parts.push(n.operator), /[a-z]$/.test(n.operator) && parts.push(" "), parts.push(path2.call(print, "argument")), (0, lines_1.concat)(parts);
      case "UpdateExpression":
        return parts.push(path2.call(print, "argument"), n.operator), n.prefix && parts.reverse(), (0, lines_1.concat)(parts);
      case "ConditionalExpression":
        return (0, lines_1.concat)([
          path2.call(print, "test"),
          " ? ",
          path2.call(print, "consequent"),
          " : ",
          path2.call(print, "alternate")
        ]);
      case "NewExpression": {
        parts.push("new ", path2.call(print, "callee")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), n.typeArguments && parts.push(path2.call(print, "typeArguments"));
        var args = n.arguments;
        return args && parts.push(printArgumentsList(path2, options2, print)), (0, lines_1.concat)(parts);
      }
      case "VariableDeclaration": {
        n.declare && parts.push("declare "), parts.push(n.kind, " ");
        var maxLen_1 = 0, printed = path2.map(function(childPath) {
          var lines3 = print(childPath);
          return maxLen_1 = Math.max(lines3.length, maxLen_1), lines3;
        }, "declarations");
        maxLen_1 === 1 ? parts.push((0, lines_1.fromString)(", ").join(printed)) : printed.length > 1 ? parts.push((0, lines_1.fromString)(`,
`).join(printed).indentTail(n.kind.length + 1)) : parts.push(printed[0]);
        var parentNode = path2.getParentNode();
        return !namedTypes2.ForStatement.check(parentNode) && !namedTypes2.ForInStatement.check(parentNode) && !(namedTypes2.ForOfStatement && namedTypes2.ForOfStatement.check(parentNode)) && !(namedTypes2.ForAwaitStatement && namedTypes2.ForAwaitStatement.check(parentNode)) && parts.push(";"), (0, lines_1.concat)(parts);
      }
      case "VariableDeclarator":
        return n.init ? (0, lines_1.fromString)(" = ").join([
          path2.call(print, "id"),
          path2.call(print, "init")
        ]) : path2.call(print, "id");
      case "WithStatement":
        return (0, lines_1.concat)([
          "with (",
          path2.call(print, "object"),
          ") ",
          path2.call(print, "body")
        ]);
      case "IfStatement": {
        var con = adjustClause(path2.call(print, "consequent"), options2);
        return parts.push("if (", path2.call(print, "test"), ")", con), n.alternate && parts.push(endsWithBrace(con) ? " else" : `
else`, adjustClause(path2.call(print, "alternate"), options2)), (0, lines_1.concat)(parts);
      }
      case "ForStatement": {
        var init = path2.call(print, "init"), sep = init.length > 1 ? `;
` : "; ", forParen = "for (", indented = (0, lines_1.fromString)(sep).join([init, path2.call(print, "test"), path2.call(print, "update")]).indentTail(forParen.length), head = (0, lines_1.concat)([forParen, indented, ")"]), clause = adjustClause(path2.call(print, "body"), options2);
        return parts.push(head), head.length > 1 && (parts.push(`
`), clause = clause.trimLeft()), parts.push(clause), (0, lines_1.concat)(parts);
      }
      case "WhileStatement":
        return (0, lines_1.concat)([
          "while (",
          path2.call(print, "test"),
          ")",
          adjustClause(path2.call(print, "body"), options2)
        ]);
      case "ForInStatement":
        return (0, lines_1.concat)([
          n.each ? "for each (" : "for (",
          path2.call(print, "left"),
          " in ",
          path2.call(print, "right"),
          ")",
          adjustClause(path2.call(print, "body"), options2)
        ]);
      case "ForOfStatement":
      case "ForAwaitStatement":
        return parts.push("for "), (n.await || n.type === "ForAwaitStatement") && parts.push("await "), parts.push("(", path2.call(print, "left"), " of ", path2.call(print, "right"), ")", adjustClause(path2.call(print, "body"), options2)), (0, lines_1.concat)(parts);
      case "DoWhileStatement": {
        var doBody = (0, lines_1.concat)([
          "do",
          adjustClause(path2.call(print, "body"), options2)
        ]);
        return parts.push(doBody), endsWithBrace(doBody) ? parts.push(" while") : parts.push(`
while`), parts.push(" (", path2.call(print, "test"), ");"), (0, lines_1.concat)(parts);
      }
      case "DoExpression": {
        var statements = path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body");
        return (0, lines_1.concat)([`do {
`, statements.indent(options2.tabWidth), `
}`]);
      }
      case "BreakStatement":
        return parts.push("break"), n.label && parts.push(" ", path2.call(print, "label")), parts.push(";"), (0, lines_1.concat)(parts);
      case "ContinueStatement":
        return parts.push("continue"), n.label && parts.push(" ", path2.call(print, "label")), parts.push(";"), (0, lines_1.concat)(parts);
      case "LabeledStatement":
        return (0, lines_1.concat)([
          path2.call(print, "label"),
          `:
`,
          path2.call(print, "body")
        ]);
      case "TryStatement":
        return parts.push("try ", path2.call(print, "block")), n.handler ? parts.push(" ", path2.call(print, "handler")) : n.handlers && path2.each(function(handlerPath) {
          parts.push(" ", print(handlerPath));
        }, "handlers"), n.finalizer && parts.push(" finally ", path2.call(print, "finalizer")), (0, lines_1.concat)(parts);
      case "CatchClause":
        return parts.push("catch "), n.param && parts.push("(", path2.call(print, "param")), n.guard && parts.push(" if ", path2.call(print, "guard")), n.param && parts.push(") "), parts.push(path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "ThrowStatement":
        return (0, lines_1.concat)(["throw ", path2.call(print, "argument"), ";"]);
      case "SwitchStatement":
        return (0, lines_1.concat)([
          "switch (",
          path2.call(print, "discriminant"),
          `) {
`,
          (0, lines_1.fromString)(`
`).join(path2.map(print, "cases")),
          `
}`
        ]);
      case "SwitchCase":
        return n.test ? parts.push("case ", path2.call(print, "test"), ":") : parts.push("default:"), n.consequent.length > 0 && parts.push(`
`, path2.call(function(consequentPath) {
          return printStatementSequence(consequentPath, options2, print);
        }, "consequent").indent(options2.tabWidth)), (0, lines_1.concat)(parts);
      case "DebuggerStatement":
        return (0, lines_1.fromString)("debugger;");
      case "JSXAttribute":
        return parts.push(path2.call(print, "name")), n.value && parts.push("=", path2.call(print, "value")), (0, lines_1.concat)(parts);
      case "JSXIdentifier":
        return (0, lines_1.fromString)(n.name, options2);
      case "JSXNamespacedName":
        return (0, lines_1.fromString)(":").join([
          path2.call(print, "namespace"),
          path2.call(print, "name")
        ]);
      case "JSXMemberExpression":
        return (0, lines_1.fromString)(".").join([
          path2.call(print, "object"),
          path2.call(print, "property")
        ]);
      case "JSXSpreadAttribute":
        return (0, lines_1.concat)(["{...", path2.call(print, "argument"), "}"]);
      case "JSXSpreadChild":
        return (0, lines_1.concat)(["{...", path2.call(print, "expression"), "}"]);
      case "JSXExpressionContainer":
        return (0, lines_1.concat)(["{", path2.call(print, "expression"), "}"]);
      case "JSXElement":
      case "JSXFragment": {
        var openingPropName = "opening" + (n.type === "JSXElement" ? "Element" : "Fragment"), closingPropName = "closing" + (n.type === "JSXElement" ? "Element" : "Fragment"), openingLines = path2.call(print, openingPropName);
        if (n[openingPropName].selfClosing)
          return (0, tiny_invariant_1.default)(!n[closingPropName], "unexpected " + closingPropName + " element in self-closing " + n.type), openingLines;
        var childLines = (0, lines_1.concat)(path2.map(function(childPath) {
          var child = childPath.getValue();
          if (namedTypes2.Literal.check(child) && typeof child.value == "string") {
            if (/\S/.test(child.value))
              return child.value.replace(/^\s+|\s+$/g, "");
            if (/\n/.test(child.value))
              return `
`;
          }
          return print(childPath);
        }, "children")).indentTail(options2.tabWidth), closingLines = path2.call(print, closingPropName);
        return (0, lines_1.concat)([openingLines, childLines, closingLines]);
      }
      case "JSXOpeningElement": {
        parts.push("<", path2.call(print, "name"));
        var typeDefPart = path2.call(print, "typeParameters");
        typeDefPart.length && parts.push(typeDefPart);
        var attrParts_1 = [];
        path2.each(function(attrPath) {
          attrParts_1.push(" ", print(attrPath));
        }, "attributes");
        var attrLines = (0, lines_1.concat)(attrParts_1), needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options2.wrapColumn;
        return needLineWrap && (attrParts_1.forEach(function(part, i2) {
          part === " " && ((0, tiny_invariant_1.default)(i2 % 2 === 0), attrParts_1[i2] = `
`);
        }), attrLines = (0, lines_1.concat)(attrParts_1).indentTail(options2.tabWidth)), parts.push(attrLines, n.selfClosing ? " />" : ">"), (0, lines_1.concat)(parts);
      }
      case "JSXClosingElement":
        return (0, lines_1.concat)(["</", path2.call(print, "name"), ">"]);
      case "JSXOpeningFragment":
        return (0, lines_1.fromString)("<>");
      case "JSXClosingFragment":
        return (0, lines_1.fromString)("</>");
      case "JSXText":
        return (0, lines_1.fromString)(n.value, options2);
      case "JSXEmptyExpression":
        return (0, lines_1.fromString)("");
      case "TypeAnnotatedIdentifier":
        return (0, lines_1.concat)([
          path2.call(print, "annotation"),
          " ",
          path2.call(print, "identifier")
        ]);
      case "ClassBody":
        return n.body.length === 0 ? (0, lines_1.fromString)("{}") : (0, lines_1.concat)([
          `{
`,
          path2.call(function(bodyPath) {
            return printStatementSequence(bodyPath, options2, print);
          }, "body").indent(options2.tabWidth),
          `
}`
        ]);
      case "ClassPropertyDefinition":
        return parts.push("static ", path2.call(print, "definition")), namedTypes2.MethodDefinition.check(n.definition) || parts.push(";"), (0, lines_1.concat)(parts);
      case "ClassProperty": {
        n.declare && parts.push("declare ");
        var access = n.accessibility || n.access;
        typeof access == "string" && parts.push(access, " "), n.static && parts.push("static "), n.abstract && parts.push("abstract "), n.readonly && parts.push("readonly ");
        var key2 = path2.call(print, "key");
        return n.computed && (key2 = (0, lines_1.concat)(["[", key2, "]"])), n.variance && (key2 = (0, lines_1.concat)([printVariance(path2, print), key2])), parts.push(key2), n.optional && parts.push("?"), n.definite && parts.push("!"), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), n.value && parts.push(" = ", path2.call(print, "value")), parts.push(";"), (0, lines_1.concat)(parts);
      }
      case "ClassPrivateProperty":
        return n.static && parts.push("static "), parts.push(path2.call(print, "key")), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), n.value && parts.push(" = ", path2.call(print, "value")), parts.push(";"), (0, lines_1.concat)(parts);
      case "ClassAccessorProperty":
        return parts.push.apply(parts, tslib_12.__spreadArray(tslib_12.__spreadArray([], printClassMemberModifiers(n), !1), ["accessor "], !1)), n.computed ? parts.push("[", path2.call(print, "key"), "]") : parts.push(path2.call(print, "key")), n.optional && parts.push("?"), n.definite && parts.push("!"), n.typeAnnotation && parts.push(path2.call(print, "typeAnnotation")), n.value && parts.push(" = ", path2.call(print, "value")), parts.push(";"), (0, lines_1.concat)(parts);
      case "ClassDeclaration":
      case "ClassExpression":
      case "DeclareClass":
        return n.declare && parts.push("declare "), n.abstract && parts.push("abstract "), parts.push("class"), n.id && parts.push(" ", path2.call(print, "id")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), n.superClass && parts.push(" extends ", path2.call(print, "superClass"), path2.call(print, "superTypeParameters")), n.extends && n.extends.length > 0 && parts.push(" extends ", (0, lines_1.fromString)(", ").join(path2.map(print, "extends"))), n.implements && n.implements.length > 0 && parts.push(" implements ", (0, lines_1.fromString)(", ").join(path2.map(print, "implements"))), parts.push(" ", path2.call(print, "body")), n.type === "DeclareClass" ? printFlowDeclaration(path2, parts) : (0, lines_1.concat)(parts);
      case "TemplateElement":
        return (0, lines_1.fromString)(n.value.raw, options2).lockIndentTail();
      case "TemplateLiteral": {
        var expressions_1 = path2.map(print, "expressions");
        return parts.push("`"), path2.each(function(childPath) {
          var i2 = childPath.getName();
          parts.push(print(childPath)), i2 < expressions_1.length && parts.push("${", expressions_1[i2], "}");
        }, "quasis"), parts.push("`"), (0, lines_1.concat)(parts).lockIndentTail();
      }
      case "TaggedTemplateExpression":
        return (0, lines_1.concat)([path2.call(print, "tag"), path2.call(print, "quasi")]);
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "Flow":
      case "FlowType":
      case "FlowPredicate":
      case "MemberTypeAnnotation":
      case "Type":
      case "TSHasOptionalTypeParameterInstantiation":
      case "TSHasOptionalTypeParameters":
      case "TSHasOptionalTypeAnnotation":
      case "ChainElement":
        throw new Error("unprintable type: " + JSON.stringify(n.type));
      case "CommentBlock":
      case "Block":
        return (0, lines_1.concat)(["/*", (0, lines_1.fromString)(n.value, options2), "*/"]);
      case "CommentLine":
      case "Line":
        return (0, lines_1.concat)(["//", (0, lines_1.fromString)(n.value, options2)]);
      case "TypeAnnotation":
        return n.typeAnnotation ? (n.typeAnnotation.type !== "FunctionTypeAnnotation" && parts.push(": "), parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts)) : (0, lines_1.fromString)("");
      case "ExistentialTypeParam":
      case "ExistsTypeAnnotation":
        return (0, lines_1.fromString)("*", options2);
      case "EmptyTypeAnnotation":
        return (0, lines_1.fromString)("empty", options2);
      case "AnyTypeAnnotation":
        return (0, lines_1.fromString)("any", options2);
      case "MixedTypeAnnotation":
        return (0, lines_1.fromString)("mixed", options2);
      case "ArrayTypeAnnotation":
        return (0, lines_1.concat)([path2.call(print, "elementType"), "[]"]);
      case "TupleTypeAnnotation": {
        var printed_2 = path2.map(print, "types"), joined = (0, lines_1.fromString)(", ").join(printed_2), oneLine_3 = joined.getLineLength(1) <= options2.wrapColumn;
        return oneLine_3 ? options2.arrayBracketSpacing ? parts.push("[ ") : parts.push("[") : parts.push(`[
`), path2.each(function(elemPath) {
          var i2 = elemPath.getName(), elem = elemPath.getValue();
          if (!elem)
            parts.push(",");
          else {
            var lines3 = printed_2[i2];
            oneLine_3 ? i2 > 0 && parts.push(" ") : lines3 = lines3.indent(options2.tabWidth), parts.push(lines3), (i2 < n.types.length - 1 || !oneLine_3 && util2.isTrailingCommaEnabled(options2, "arrays")) && parts.push(","), oneLine_3 || parts.push(`
`);
          }
        }, "types"), oneLine_3 && options2.arrayBracketSpacing ? parts.push(" ]") : parts.push("]"), (0, lines_1.concat)(parts);
      }
      case "BooleanTypeAnnotation":
        return (0, lines_1.fromString)("boolean", options2);
      case "BooleanLiteralTypeAnnotation":
        return (0, tiny_invariant_1.default)(typeof n.value == "boolean"), (0, lines_1.fromString)("" + n.value, options2);
      case "InterfaceTypeAnnotation":
        return parts.push("interface"), n.extends && n.extends.length > 0 && parts.push(" extends ", (0, lines_1.fromString)(", ").join(path2.map(print, "extends"))), parts.push(" ", path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "DeclareFunction":
        return printFlowDeclaration(path2, [
          "function ",
          path2.call(print, "id"),
          ";"
        ]);
      case "DeclareModule":
        return printFlowDeclaration(path2, [
          "module ",
          path2.call(print, "id"),
          " ",
          path2.call(print, "body")
        ]);
      case "DeclareModuleExports":
        return printFlowDeclaration(path2, [
          "module.exports",
          path2.call(print, "typeAnnotation")
        ]);
      case "DeclareVariable":
        return printFlowDeclaration(path2, ["var ", path2.call(print, "id"), ";"]);
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
        return (0, lines_1.concat)(["declare ", printExportDeclaration(path2, options2, print)]);
      case "EnumDeclaration":
        return (0, lines_1.concat)([
          "enum ",
          path2.call(print, "id"),
          path2.call(print, "body")
        ]);
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        return (n.type === "EnumSymbolBody" || n.explicitType) && parts.push(
          " of ",
          // EnumBooleanBody => boolean, etc.
          n.type.slice(4, -4).toLowerCase()
        ), parts.push(` {
`, (0, lines_1.fromString)(`
`).join(path2.map(print, "members")).indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts);
      case "EnumDefaultedMember":
        return (0, lines_1.concat)([path2.call(print, "id"), ","]);
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return (0, lines_1.concat)([
          path2.call(print, "id"),
          " = ",
          path2.call(print, "init"),
          ","
        ]);
      case "InferredPredicate":
        return (0, lines_1.fromString)("%checks", options2);
      case "DeclaredPredicate":
        return (0, lines_1.concat)(["%checks(", path2.call(print, "value"), ")"]);
      case "FunctionTypeAnnotation": {
        var parent = path2.getParentNode(0), isArrowFunctionTypeAnnotation = !(namedTypes2.ObjectTypeCallProperty.check(parent) || namedTypes2.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes2.DeclareFunction.check(path2.getParentNode(2))), needsColon = isArrowFunctionTypeAnnotation && !namedTypes2.FunctionTypeParam.check(parent) && !namedTypes2.TypeAlias.check(parent);
        needsColon && parts.push(": ");
        var hasTypeParameters = !!n.typeParameters, needsParens = hasTypeParameters || n.params.length !== 1 || n.params[0].name;
        return parts.push(hasTypeParameters ? path2.call(print, "typeParameters") : "", needsParens ? "(" : "", printFunctionParams(path2, options2, print), needsParens ? ")" : ""), n.returnType && parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path2.call(print, "returnType")), (0, lines_1.concat)(parts);
      }
      case "FunctionTypeParam": {
        var name = path2.call(print, "name");
        return parts.push(name), n.optional && parts.push("?"), name.infos[0].line && parts.push(": "), parts.push(path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "GenericTypeAnnotation":
        return (0, lines_1.concat)([
          path2.call(print, "id"),
          path2.call(print, "typeParameters")
        ]);
      case "DeclareInterface":
        parts.push("declare ");
      case "InterfaceDeclaration":
      case "TSInterfaceDeclaration":
        return n.declare && parts.push("declare "), parts.push("interface ", path2.call(print, "id"), path2.call(print, "typeParameters"), " "), n.extends && n.extends.length > 0 && parts.push("extends ", (0, lines_1.fromString)(", ").join(path2.map(print, "extends")), " "), n.body && parts.push(path2.call(print, "body")), (0, lines_1.concat)(parts);
      case "ClassImplements":
      case "InterfaceExtends":
        return (0, lines_1.concat)([
          path2.call(print, "id"),
          path2.call(print, "typeParameters")
        ]);
      case "IntersectionTypeAnnotation":
        return (0, lines_1.fromString)(" & ").join(path2.map(print, "types"));
      case "NullableTypeAnnotation":
        return (0, lines_1.concat)(["?", path2.call(print, "typeAnnotation")]);
      case "NullLiteralTypeAnnotation":
        return (0, lines_1.fromString)("null", options2);
      case "ThisTypeAnnotation":
        return (0, lines_1.fromString)("this", options2);
      case "NumberTypeAnnotation":
        return (0, lines_1.fromString)("number", options2);
      case "ObjectTypeCallProperty":
        return path2.call(print, "value");
      case "ObjectTypeIndexer":
        return n.static && parts.push("static "), parts.push(printVariance(path2, print), "["), n.id && parts.push(path2.call(print, "id"), ": "), parts.push(path2.call(print, "key"), "]: ", path2.call(print, "value")), (0, lines_1.concat)(parts);
      case "ObjectTypeProperty":
        return (0, lines_1.concat)([
          printVariance(path2, print),
          path2.call(print, "key"),
          n.optional ? "?" : "",
          ": ",
          path2.call(print, "value")
        ]);
      case "ObjectTypeInternalSlot":
        return (0, lines_1.concat)([
          n.static ? "static " : "",
          "[[",
          path2.call(print, "id"),
          "]]",
          n.optional ? "?" : "",
          n.value.type !== "FunctionTypeAnnotation" ? ": " : "",
          path2.call(print, "value")
        ]);
      case "QualifiedTypeIdentifier":
        return (0, lines_1.concat)([
          path2.call(print, "qualification"),
          ".",
          path2.call(print, "id")
        ]);
      case "StringLiteralTypeAnnotation":
        return (0, lines_1.fromString)(nodeStr(n.value, options2), options2);
      case "NumberLiteralTypeAnnotation":
      case "NumericLiteralTypeAnnotation":
        return (0, tiny_invariant_1.default)(typeof n.value == "number"), (0, lines_1.fromString)(JSON.stringify(n.value), options2);
      case "BigIntLiteralTypeAnnotation":
        return (0, lines_1.fromString)(n.raw, options2);
      case "StringTypeAnnotation":
        return (0, lines_1.fromString)("string", options2);
      case "DeclareTypeAlias":
        parts.push("declare ");
      case "TypeAlias":
        return (0, lines_1.concat)([
          "type ",
          path2.call(print, "id"),
          path2.call(print, "typeParameters"),
          " = ",
          path2.call(print, "right"),
          ";"
        ]);
      case "DeclareOpaqueType":
        parts.push("declare ");
      case "OpaqueType":
        return parts.push("opaque type ", path2.call(print, "id"), path2.call(print, "typeParameters")), n.supertype && parts.push(": ", path2.call(print, "supertype")), n.impltype && parts.push(" = ", path2.call(print, "impltype")), parts.push(";"), (0, lines_1.concat)(parts);
      case "TypeCastExpression":
        return (0, lines_1.concat)([
          "(",
          path2.call(print, "expression"),
          path2.call(print, "typeAnnotation"),
          ")"
        ]);
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
        return (0, lines_1.concat)([
          "<",
          (0, lines_1.fromString)(", ").join(path2.map(print, "params")),
          ">"
        ]);
      case "Variance":
        return n.kind === "plus" ? (0, lines_1.fromString)("+") : n.kind === "minus" ? (0, lines_1.fromString)("-") : (0, lines_1.fromString)("");
      case "TypeParameter":
        return n.variance && parts.push(printVariance(path2, print)), parts.push(path2.call(print, "name")), n.bound && parts.push(path2.call(print, "bound")), n.default && parts.push("=", path2.call(print, "default")), (0, lines_1.concat)(parts);
      case "TypeofTypeAnnotation":
        return (0, lines_1.concat)([
          (0, lines_1.fromString)("typeof ", options2),
          path2.call(print, "argument")
        ]);
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return (0, lines_1.concat)([
          path2.call(print, "objectType"),
          n.optional ? "?." : "",
          "[",
          path2.call(print, "indexType"),
          "]"
        ]);
      case "UnionTypeAnnotation":
        return (0, lines_1.fromString)(" | ").join(path2.map(print, "types"));
      case "VoidTypeAnnotation":
        return (0, lines_1.fromString)("void", options2);
      case "NullTypeAnnotation":
        return (0, lines_1.fromString)("null", options2);
      case "SymbolTypeAnnotation":
        return (0, lines_1.fromString)("symbol", options2);
      case "BigIntTypeAnnotation":
        return (0, lines_1.fromString)("bigint", options2);
      case "TSType":
        throw new Error("unprintable type: " + JSON.stringify(n.type));
      case "TSNumberKeyword":
        return (0, lines_1.fromString)("number", options2);
      case "TSBigIntKeyword":
        return (0, lines_1.fromString)("bigint", options2);
      case "TSObjectKeyword":
        return (0, lines_1.fromString)("object", options2);
      case "TSBooleanKeyword":
        return (0, lines_1.fromString)("boolean", options2);
      case "TSStringKeyword":
        return (0, lines_1.fromString)("string", options2);
      case "TSSymbolKeyword":
        return (0, lines_1.fromString)("symbol", options2);
      case "TSAnyKeyword":
        return (0, lines_1.fromString)("any", options2);
      case "TSVoidKeyword":
        return (0, lines_1.fromString)("void", options2);
      case "TSIntrinsicKeyword":
        return (0, lines_1.fromString)("intrinsic", options2);
      case "TSThisType":
        return (0, lines_1.fromString)("this", options2);
      case "TSNullKeyword":
        return (0, lines_1.fromString)("null", options2);
      case "TSUndefinedKeyword":
        return (0, lines_1.fromString)("undefined", options2);
      case "TSUnknownKeyword":
        return (0, lines_1.fromString)("unknown", options2);
      case "TSNeverKeyword":
        return (0, lines_1.fromString)("never", options2);
      case "TSArrayType":
        return (0, lines_1.concat)([path2.call(print, "elementType"), "[]"]);
      case "TSLiteralType":
        return path2.call(print, "literal");
      case "TSUnionType":
        return (0, lines_1.fromString)(" | ").join(path2.map(print, "types"));
      case "TSIntersectionType":
        return (0, lines_1.fromString)(" & ").join(path2.map(print, "types"));
      case "TSConditionalType":
        return parts.push(path2.call(print, "checkType"), " extends ", path2.call(print, "extendsType"), " ? ", path2.call(print, "trueType"), " : ", path2.call(print, "falseType")), (0, lines_1.concat)(parts);
      case "TSInferType":
        return parts.push("infer ", path2.call(print, "typeParameter")), (0, lines_1.concat)(parts);
      case "TSParenthesizedType":
        return (0, lines_1.concat)(["(", path2.call(print, "typeAnnotation"), ")"]);
      case "TSFunctionType":
        return (0, lines_1.concat)([
          path2.call(print, "typeParameters"),
          "(",
          printFunctionParams(path2, options2, print),
          ") => ",
          path2.call(print, "typeAnnotation", "typeAnnotation")
        ]);
      case "TSConstructorType":
        return (0, lines_1.concat)([
          "new ",
          path2.call(print, "typeParameters"),
          "(",
          printFunctionParams(path2, options2, print),
          ") => ",
          path2.call(print, "typeAnnotation", "typeAnnotation")
        ]);
      case "TSMappedType":
        return parts.push(n.readonly ? "readonly " : "", "[", path2.call(print, "typeParameter"), "]", n.optional ? "?" : ""), n.typeAnnotation && parts.push(": ", path2.call(print, "typeAnnotation"), ";"), (0, lines_1.concat)([`{
`, (0, lines_1.concat)(parts).indent(options2.tabWidth), `
}`]);
      case "TSTupleType":
        return (0, lines_1.concat)([
          "[",
          (0, lines_1.fromString)(", ").join(path2.map(print, "elementTypes")),
          "]"
        ]);
      case "TSNamedTupleMember":
        return parts.push(path2.call(print, "label")), n.optional && parts.push("?"), parts.push(": ", path2.call(print, "elementType")), (0, lines_1.concat)(parts);
      case "TSRestType":
        return (0, lines_1.concat)(["...", path2.call(print, "typeAnnotation")]);
      case "TSOptionalType":
        return (0, lines_1.concat)([path2.call(print, "typeAnnotation"), "?"]);
      case "TSIndexedAccessType":
        return (0, lines_1.concat)([
          path2.call(print, "objectType"),
          "[",
          path2.call(print, "indexType"),
          "]"
        ]);
      case "TSTypeOperator":
        return (0, lines_1.concat)([
          path2.call(print, "operator"),
          " ",
          path2.call(print, "typeAnnotation")
        ]);
      case "TSTypeLiteral": {
        var members = (0, lines_1.fromString)(`
`).join(path2.map(print, "members").map(function(member) {
          return lastNonSpaceCharacter(member) !== ";" ? member.concat(";") : member;
        }));
        return members.isEmpty() ? (0, lines_1.fromString)("{}", options2) : (parts.push(`{
`, members.indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts));
      }
      case "TSEnumMember":
        return parts.push(path2.call(print, "id")), n.initializer && parts.push(" = ", path2.call(print, "initializer")), (0, lines_1.concat)(parts);
      case "TSTypeQuery":
        return (0, lines_1.concat)(["typeof ", path2.call(print, "exprName")]);
      case "TSParameterProperty":
        return n.accessibility && parts.push(n.accessibility, " "), n.export && parts.push("export "), n.static && parts.push("static "), n.readonly && parts.push("readonly "), parts.push(path2.call(print, "parameter")), (0, lines_1.concat)(parts);
      case "TSTypeReference":
        return (0, lines_1.concat)([
          path2.call(print, "typeName"),
          path2.call(print, "typeParameters")
        ]);
      case "TSQualifiedName":
        return (0, lines_1.concat)([path2.call(print, "left"), ".", path2.call(print, "right")]);
      case "TSAsExpression":
      case "TSSatisfiesExpression": {
        var expression = path2.call(print, "expression");
        return parts.push(expression, n.type === "TSSatisfiesExpression" ? " satisfies " : " as ", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      }
      case "TSTypeCastExpression":
        return (0, lines_1.concat)([
          path2.call(print, "expression"),
          path2.call(print, "typeAnnotation")
        ]);
      case "TSNonNullExpression":
        return (0, lines_1.concat)([path2.call(print, "expression"), "!"]);
      case "TSTypeAnnotation":
        return (0, lines_1.concat)([": ", path2.call(print, "typeAnnotation")]);
      case "TSIndexSignature":
        return (0, lines_1.concat)([
          n.readonly ? "readonly " : "",
          "[",
          path2.map(print, "parameters"),
          "]",
          path2.call(print, "typeAnnotation")
        ]);
      case "TSPropertySignature":
        return parts.push(printVariance(path2, print), n.readonly ? "readonly " : ""), n.computed ? parts.push("[", path2.call(print, "key"), "]") : parts.push(path2.call(print, "key")), parts.push(n.optional ? "?" : "", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSMethodSignature":
        return n.computed ? parts.push("[", path2.call(print, "key"), "]") : parts.push(path2.call(print, "key")), n.optional && parts.push("?"), parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSTypePredicate":
        return n.asserts && parts.push("asserts "), parts.push(path2.call(print, "parameterName")), n.typeAnnotation && parts.push(" is ", path2.call(print, "typeAnnotation", "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSCallSignatureDeclaration":
        return (0, lines_1.concat)([
          path2.call(print, "typeParameters"),
          "(",
          printFunctionParams(path2, options2, print),
          ")",
          path2.call(print, "typeAnnotation")
        ]);
      case "TSConstructSignatureDeclaration":
        return n.typeParameters ? parts.push("new", path2.call(print, "typeParameters")) : parts.push("new "), parts.push("(", printFunctionParams(path2, options2, print), ")", path2.call(print, "typeAnnotation")), (0, lines_1.concat)(parts);
      case "TSTypeAliasDeclaration":
        return (0, lines_1.concat)([
          n.declare ? "declare " : "",
          "type ",
          path2.call(print, "id"),
          path2.call(print, "typeParameters"),
          " = ",
          path2.call(print, "typeAnnotation"),
          ";"
        ]);
      case "TSTypeParameter": {
        parts.push(path2.call(print, "name"));
        var parent = path2.getParentNode(0), isInMappedType = namedTypes2.TSMappedType.check(parent);
        return n.constraint && parts.push(isInMappedType ? " in " : " extends ", path2.call(print, "constraint")), n.default && parts.push(" = ", path2.call(print, "default")), (0, lines_1.concat)(parts);
      }
      case "TSTypeAssertion":
        return parts.push("<", path2.call(print, "typeAnnotation"), "> ", path2.call(print, "expression")), (0, lines_1.concat)(parts);
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return (0, lines_1.concat)([
          "<",
          (0, lines_1.fromString)(", ").join(path2.map(print, "params")),
          ">"
        ]);
      case "TSEnumDeclaration": {
        parts.push(n.declare ? "declare " : "", n.const ? "const " : "", "enum ", path2.call(print, "id"));
        var memberLines = (0, lines_1.fromString)(`,
`).join(path2.map(print, "members"));
        return memberLines.isEmpty() ? parts.push(" {}") : parts.push(` {
`, memberLines.indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts);
      }
      case "TSExpressionWithTypeArguments":
        return (0, lines_1.concat)([
          path2.call(print, "expression"),
          path2.call(print, "typeParameters")
        ]);
      case "TSInterfaceBody": {
        var lines2 = (0, lines_1.fromString)(`
`).join(path2.map(print, "body").map(function(element) {
          return lastNonSpaceCharacter(element) !== ";" ? element.concat(";") : element;
        }));
        return lines2.isEmpty() ? (0, lines_1.fromString)("{}", options2) : (0, lines_1.concat)([`{
`, lines2.indent(options2.tabWidth), `
}`]);
      }
      case "TSImportType":
        return parts.push("import(", path2.call(print, "argument"), ")"), n.qualifier && parts.push(".", path2.call(print, "qualifier")), n.typeParameters && parts.push(path2.call(print, "typeParameters")), (0, lines_1.concat)(parts);
      case "TSImportEqualsDeclaration":
        return n.isExport && parts.push("export "), parts.push("import ", path2.call(print, "id"), " = ", path2.call(print, "moduleReference")), maybeAddSemicolon((0, lines_1.concat)(parts));
      case "TSExternalModuleReference":
        return (0, lines_1.concat)(["require(", path2.call(print, "expression"), ")"]);
      case "TSModuleDeclaration": {
        var parent = path2.getParentNode();
        if (parent.type === "TSModuleDeclaration")
          parts.push(".");
        else if (n.declare && parts.push("declare "), !n.global) {
          var isExternal = n.id.type === "StringLiteral" || n.id.type === "Literal" && typeof n.id.value == "string";
          if (isExternal)
            parts.push("module ");
          else if (n.loc && n.loc.lines && n.id.loc) {
            var prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);
            prefix.indexOf("module") >= 0 ? parts.push("module ") : parts.push("namespace ");
          } else
            parts.push("namespace ");
        }
        return parts.push(path2.call(print, "id")), n.body && (parts.push(" "), parts.push(path2.call(print, "body"))), (0, lines_1.concat)(parts);
      }
      case "TSModuleBlock": {
        var naked = path2.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options2, print);
        }, "body");
        return naked.isEmpty() ? parts.push("{}") : parts.push(`{
`, naked.indent(options2.tabWidth), `
}`), (0, lines_1.concat)(parts);
      }
      case "TSInstantiationExpression":
        return parts.push(path2.call(print, "expression"), path2.call(print, "typeParameters")), (0, lines_1.concat)(parts);
      case "V8IntrinsicIdentifier":
        return (0, lines_1.concat)(["%", path2.call(print, "name")]);
      case "TopicReference":
        return (0, lines_1.fromString)("#");
      case "ClassHeritage":
      case "ComprehensionBlock":
      case "ComprehensionExpression":
      case "Glob":
      case "GeneratorExpression":
      case "LetStatement":
      case "LetExpression":
      case "GraphExpression":
      case "GraphIndexExpression":
      case "XMLDefaultDeclaration":
      case "XMLAnyName":
      case "XMLQualifiedIdentifier":
      case "XMLFunctionQualifiedIdentifier":
      case "XMLAttributeSelector":
      case "XMLFilterExpression":
      case "XML":
      case "XMLElement":
      case "XMLList":
      case "XMLEscape":
      case "XMLText":
      case "XMLStartTag":
      case "XMLEndTag":
      case "XMLPointTag":
      case "XMLName":
      case "XMLAttribute":
      case "XMLCdata":
      case "XMLComment":
      case "XMLProcessingInstruction":
      default:
        debugger;
        throw new Error("unknown type: " + JSON.stringify(n.type));
    }
  }
  function printDecorators(path2, printPath) {
    var parts = [], node2 = path2.getValue();
    return node2.decorators && node2.decorators.length > 0 && // If the parent node is an export declaration, it will be
    // responsible for printing node.decorators.
    !util2.getParentExportDeclaration(path2) ? path2.each(function(decoratorPath) {
      parts.push(printPath(decoratorPath), `
`);
    }, "decorators") : util2.isExportDeclaration(node2) && node2.declaration && node2.declaration.decorators && path2.each(function(decoratorPath) {
      parts.push(printPath(decoratorPath), `
`);
    }, "declaration", "decorators"), (0, lines_1.concat)(parts);
  }
  function printStatementSequence(path2, options2, print) {
    var filtered = [], sawComment = !1, sawStatement = !1;
    path2.each(function(stmtPath) {
      var stmt = stmtPath.getValue();
      stmt && (stmt.type === "EmptyStatement" && !(stmt.comments && stmt.comments.length > 0) || (namedTypes2.Comment.check(stmt) ? sawComment = !0 : namedTypes2.Statement.check(stmt) ? sawStatement = !0 : isString.assert(stmt), filtered.push({
        node: stmt,
        printed: print(stmtPath)
      })));
    }), sawComment && (0, tiny_invariant_1.default)(sawStatement === !1, "Comments may appear as statements in otherwise empty statement lists, but may not coexist with non-Comment nodes.");
    var prevTrailingSpace = null, len = filtered.length, parts = [];
    return filtered.forEach(function(info, i2) {
      var printed = info.printed, stmt = info.node, multiLine = printed.length > 1, notFirst = i2 > 0, notLast = i2 < len - 1, leadingSpace, trailingSpace, lines2 = stmt && stmt.loc && stmt.loc.lines, trueLoc = lines2 && options2.reuseWhitespace && util2.getTrueLoc(stmt, lines2);
      if (notFirst)
        if (trueLoc) {
          var beforeStart = lines2.skipSpaces(trueLoc.start, !0), beforeStartLine = beforeStart ? beforeStart.line : 1, leadingGap = trueLoc.start.line - beforeStartLine;
          leadingSpace = Array(leadingGap + 1).join(`
`);
        } else
          leadingSpace = multiLine ? `

` : `
`;
      else
        leadingSpace = "";
      if (notLast)
        if (trueLoc) {
          var afterEnd = lines2.skipSpaces(trueLoc.end), afterEndLine = afterEnd ? afterEnd.line : lines2.length, trailingGap = afterEndLine - trueLoc.end.line;
          trailingSpace = Array(trailingGap + 1).join(`
`);
        } else
          trailingSpace = multiLine ? `

` : `
`;
      else
        trailingSpace = "";
      parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed), notLast ? prevTrailingSpace = trailingSpace : trailingSpace && parts.push(trailingSpace);
    }), (0, lines_1.concat)(parts);
  }
  function maxSpace(s1, s2) {
    if (!s1 && !s2)
      return (0, lines_1.fromString)("");
    if (!s1)
      return (0, lines_1.fromString)(s2);
    if (!s2)
      return (0, lines_1.fromString)(s1);
    var spaceLines1 = (0, lines_1.fromString)(s1), spaceLines2 = (0, lines_1.fromString)(s2);
    return spaceLines2.length > spaceLines1.length ? spaceLines2 : spaceLines1;
  }
  function printClassMemberModifiers(node2) {
    var parts = [];
    node2.declare && parts.push("declare ");
    var access = node2.accessibility || node2.access;
    return typeof access == "string" && parts.push(access, " "), node2.static && parts.push("static "), node2.override && parts.push("override "), node2.abstract && parts.push("abstract "), node2.readonly && parts.push("readonly "), parts;
  }
  function printMethod(path2, options2, print) {
    var node2 = path2.getNode(), kind = node2.kind, parts = [], nodeValue = node2.value;
    namedTypes2.FunctionExpression.check(nodeValue) || (nodeValue = node2), parts.push.apply(parts, printClassMemberModifiers(node2)), nodeValue.async && parts.push("async "), nodeValue.generator && parts.push("*"), (kind === "get" || kind === "set") && parts.push(kind, " ");
    var key2 = path2.call(print, "key");
    return node2.computed && (key2 = (0, lines_1.concat)(["[", key2, "]"])), parts.push(key2), node2.optional && parts.push("?"), node2 === nodeValue ? (parts.push(path2.call(print, "typeParameters"), "(", printFunctionParams(path2, options2, print), ")", path2.call(print, "returnType")), node2.body ? parts.push(" ", path2.call(print, "body")) : parts.push(";")) : (parts.push(path2.call(print, "value", "typeParameters"), "(", path2.call(function(valuePath) {
      return printFunctionParams(valuePath, options2, print);
    }, "value"), ")", path2.call(print, "value", "returnType")), nodeValue.body ? parts.push(" ", path2.call(print, "value", "body")) : parts.push(";")), (0, lines_1.concat)(parts);
  }
  function printArgumentsList(path2, options2, print) {
    var printed = path2.map(print, "arguments"), trailingComma = util2.isTrailingCommaEnabled(options2, "parameters"), joined = (0, lines_1.fromString)(", ").join(printed);
    return joined.getLineLength(1) > options2.wrapColumn ? (joined = (0, lines_1.fromString)(`,
`).join(printed), (0, lines_1.concat)([
      `(
`,
      joined.indent(options2.tabWidth),
      trailingComma ? `,
)` : `
)`
    ])) : (0, lines_1.concat)(["(", joined, ")"]);
  }
  function printFunctionParams(path2, options2, print) {
    var fun = path2.getValue(), params, printed = [];
    fun.params ? (params = fun.params, printed = path2.map(print, "params")) : fun.parameters && (params = fun.parameters, printed = path2.map(print, "parameters")), fun.defaults && path2.each(function(defExprPath) {
      var i2 = defExprPath.getName(), p = printed[i2];
      p && defExprPath.getValue() && (printed[i2] = (0, lines_1.concat)([p, " = ", print(defExprPath)]));
    }, "defaults"), fun.rest && printed.push((0, lines_1.concat)(["...", path2.call(print, "rest")]));
    var joined = (0, lines_1.fromString)(", ").join(printed);
    return joined.length > 1 || joined.getLineLength(1) > options2.wrapColumn ? (joined = (0, lines_1.fromString)(`,
`).join(printed), util2.isTrailingCommaEnabled(options2, "parameters") && !fun.rest && params[params.length - 1].type !== "RestElement" ? joined = (0, lines_1.concat)([joined, `,
`]) : joined = (0, lines_1.concat)([joined, `
`]), (0, lines_1.concat)([`
`, joined.indent(options2.tabWidth)])) : joined;
  }
  function maybePrintImportAssertions(path2, options2, print) {
    var n = path2.getValue();
    if (n.assertions && n.assertions.length > 0) {
      var parts = [" assert {"], printed = path2.map(print, "assertions"), flat = (0, lines_1.fromString)(", ").join(printed);
      return flat.length > 1 || flat.getLineLength(1) > options2.wrapColumn ? parts.push(`
`, (0, lines_1.fromString)(`,
`).join(printed).indent(options2.tabWidth), `
}`) : parts.push(" ", flat, " }"), (0, lines_1.concat)(parts);
    }
    return (0, lines_1.fromString)("");
  }
  function printExportDeclaration(path2, options2, print) {
    var decl = path2.getValue(), parts = ["export "];
    decl.exportKind && decl.exportKind === "type" && (decl.declaration || parts.push("type "));
    var shouldPrintSpaces = options2.objectCurlySpacing;
    if (namedTypes2.Declaration.assert(decl), (decl.default || decl.type === "ExportDefaultDeclaration") && parts.push("default "), decl.declaration)
      parts.push(path2.call(print, "declaration"));
    else if (decl.specifiers) {
      if (decl.specifiers.length === 1 && decl.specifiers[0].type === "ExportBatchSpecifier")
        parts.push("*");
      else if (decl.specifiers.length === 0)
        parts.push("{}");
      else if (decl.specifiers[0].type === "ExportDefaultSpecifier" || decl.specifiers[0].type === "ExportNamespaceSpecifier") {
        var unbracedSpecifiers_2 = [], bracedSpecifiers_2 = [];
        if (path2.each(function(specifierPath) {
          var spec = specifierPath.getValue();
          spec.type === "ExportDefaultSpecifier" || spec.type === "ExportNamespaceSpecifier" ? unbracedSpecifiers_2.push(print(specifierPath)) : bracedSpecifiers_2.push(print(specifierPath));
        }, "specifiers"), unbracedSpecifiers_2.forEach(function(lines3, i2) {
          i2 > 0 && parts.push(", "), parts.push(lines3);
        }), bracedSpecifiers_2.length > 0) {
          var lines_2 = (0, lines_1.fromString)(", ").join(bracedSpecifiers_2);
          lines_2.getLineLength(1) > options2.wrapColumn && (lines_2 = (0, lines_1.concat)([
            (0, lines_1.fromString)(`,
`).join(bracedSpecifiers_2).indent(options2.tabWidth),
            ","
          ])), unbracedSpecifiers_2.length > 0 && parts.push(", "), lines_2.length > 1 ? parts.push(`{
`, lines_2, `
}`) : options2.objectCurlySpacing ? parts.push("{ ", lines_2, " }") : parts.push("{", lines_2, "}");
        }
      } else
        parts.push(shouldPrintSpaces ? "{ " : "{", (0, lines_1.fromString)(", ").join(path2.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
      decl.source && parts.push(" from ", path2.call(print, "source"), maybePrintImportAssertions(path2, options2, print));
    }
    var lines2 = (0, lines_1.concat)(parts);
    return lastNonSpaceCharacter(lines2) !== ";" && !(decl.declaration && (decl.declaration.type === "FunctionDeclaration" || decl.declaration.type === "ClassDeclaration" || decl.declaration.type === "TSModuleDeclaration" || decl.declaration.type === "TSInterfaceDeclaration" || decl.declaration.type === "TSEnumDeclaration")) && (lines2 = (0, lines_1.concat)([lines2, ";"])), lines2;
  }
  function printFlowDeclaration(path2, parts) {
    var parentExportDecl = util2.getParentExportDeclaration(path2);
    return parentExportDecl ? (0, tiny_invariant_1.default)(parentExportDecl.type === "DeclareExportDeclaration") : parts.unshift("declare "), (0, lines_1.concat)(parts);
  }
  function printVariance(path2, print) {
    return path2.call(function(variancePath) {
      var value = variancePath.getValue();
      return value ? value === "plus" ? (0, lines_1.fromString)("+") : value === "minus" ? (0, lines_1.fromString)("-") : print(variancePath) : (0, lines_1.fromString)("");
    }, "variance");
  }
  function adjustClause(clause, options2) {
    return clause.length > 1 ? (0, lines_1.concat)([" ", clause]) : (0, lines_1.concat)([`
`, maybeAddSemicolon(clause).indent(options2.tabWidth)]);
  }
  function lastNonSpaceCharacter(lines2) {
    var pos2 = lines2.lastPos();
    do {
      var ch = lines2.charAt(pos2);
      if (/\S/.test(ch))
        return ch;
    } while (lines2.prevPos(pos2));
  }
  function endsWithBrace(lines2) {
    return lastNonSpaceCharacter(lines2) === "}";
  }
  function swapQuotes(str2) {
    return str2.replace(/['"]/g, function(m) {
      return m === '"' ? "'" : '"';
    });
  }
  function getPossibleRaw(node2) {
    var value = types2.getFieldValue(node2, "value"), extra = types2.getFieldValue(node2, "extra");
    if (extra && typeof extra.raw == "string" && value == extra.rawValue)
      return extra.raw;
    if (node2.type === "Literal") {
      var raw = node2.raw;
      if (typeof raw == "string" && value == raw)
        return raw;
    }
  }
  function jsSafeStringify(str2) {
    return JSON.stringify(str2).replace(/[\u2028\u2029]/g, function(m) {
      return "\\u" + m.charCodeAt(0).toString(16);
    });
  }
  function nodeStr(str2, options2) {
    switch (isString.assert(str2), options2.quote) {
      case "auto": {
        var double2 = jsSafeStringify(str2), single2 = swapQuotes(jsSafeStringify(swapQuotes(str2)));
        return double2.length > single2.length ? single2 : double2;
      }
      case "single":
        return swapQuotes(jsSafeStringify(swapQuotes(str2)));
      case "double":
      default:
        return jsSafeStringify(str2);
    }
  }
  function maybeAddSemicolon(lines2) {
    var eoc = lastNonSpaceCharacter(lines2);
    return !eoc || `
};`.indexOf(eoc) < 0 ? (0, lines_1.concat)([lines2, ";"]) : lines2;
  }
  return printer;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.run = exports2.prettyPrint = exports2.print = exports2.visit = exports2.types = exports2.parse = void 0;
  var tslib_12 = require$$0$3, fs_12 = tslib_12.__importDefault(require$$0__default$1.default), types2 = tslib_12.__importStar(requireMain$1());
  exports2.types = types2;
  var parser_1 = requireParser();
  Object.defineProperty(exports2, "parse", { enumerable: !0, get: function() {
    return parser_1.parse;
  } });
  var printer_1 = requirePrinter(), ast_types_1 = requireMain$1();
  Object.defineProperty(exports2, "visit", { enumerable: !0, get: function() {
    return ast_types_1.visit;
  } });
  function print(node2, options2) {
    return new printer_1.Printer(options2).print(node2);
  }
  exports2.print = print;
  function prettyPrint(node2, options2) {
    return new printer_1.Printer(options2).printGenerically(node2);
  }
  exports2.prettyPrint = prettyPrint;
  function run(transformer, options2) {
    return runFile(process.argv[2], transformer, options2);
  }
  exports2.run = run;
  function runFile(path2, transformer, options2) {
    fs_12.default.readFile(path2, "utf-8", function(err, code) {
      if (err) {
        console.error(err);
        return;
      }
      runString(code, transformer, options2);
    });
  }
  function defaultWriteback(output) {
    process.stdout.write(output);
  }
  function runString(code, transformer, options2) {
    var writeback = options2 && options2.writeback || defaultWriteback;
    transformer((0, parser_1.parse)(code, options2), function(node2) {
      writeback(print(node2, options2).code);
    });
  }
})(main$4);
var typescript = {}, babel = {}, _babel_options = {}, hasRequired_babel_options;
function require_babel_options() {
  if (hasRequired_babel_options) return _babel_options;
  hasRequired_babel_options = 1, Object.defineProperty(_babel_options, "__esModule", { value: !0 });
  var util_1 = requireUtil();
  function getBabelOptions(options2) {
    return {
      sourceType: (0, util_1.getOption)(options2, "sourceType", "module"),
      strictMode: (0, util_1.getOption)(options2, "strictMode", !1),
      allowImportExportEverywhere: !0,
      allowReturnOutsideFunction: !0,
      startLine: 1,
      tokens: !0,
      plugins: [
        "asyncGenerators",
        "bigInt",
        "classPrivateMethods",
        "classPrivateProperties",
        "classProperties",
        "classStaticBlock",
        "decimal",
        "decorators-legacy",
        "doExpressions",
        "dynamicImport",
        "exportDefaultFrom",
        "exportExtensions",
        "exportNamespaceFrom",
        "functionBind",
        "functionSent",
        "importAssertions",
        "importMeta",
        "nullishCoalescingOperator",
        "numericSeparator",
        "objectRestSpread",
        "optionalCatchBinding",
        "optionalChaining",
        [
          "pipelineOperator",
          {
            proposal: "minimal"
          }
        ],
        [
          "recordAndTuple",
          {
            syntaxType: "hash"
          }
        ],
        "throwExpressions",
        "topLevelAwait",
        "v8intrinsic"
      ]
    };
  }
  return _babel_options.default = getBabelOptions, _babel_options;
}
var lib$1 = {}, hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1, Object.defineProperty(lib$1, "__esModule", {
    value: !0
  });
  function _objectWithoutPropertiesLoose(source2, excluded) {
    if (source2 == null) return {};
    var target = {}, sourceKeys = Object.keys(source2), key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++)
      key2 = sourceKeys[i2], !(excluded.indexOf(key2) >= 0) && (target[key2] = source2[key2]);
    return target;
  }
  class Position {
    constructor(line3, col, index) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = line3, this.column = col, this.index = index;
    }
  }
  class SourceLocation {
    constructor(start, end2) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = start, this.end = end2;
    }
  }
  function createPositionWithColumnOffset(position, columnOffset) {
    const {
      line: line3,
      column: column2,
      index
    } = position;
    return new Position(line3, column2 + columnOffset, index + columnOffset);
  }
  const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var ModuleErrors = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code
    }
  };
  const NodeDescriptions = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, toNodeDescription = (node2) => node2.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node2.prefix}`] : NodeDescriptions[node2.type];
  var StandardErrors = {
    AccessorIsGenerator: ({
      kind
    }) => `A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({
      kind
    }) => `Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({
      exportName
    }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: ({
      phase
    }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({
      localName,
      exportName
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({
      type: type2
    }) => `'${type2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({
      type: type2
    }) => `Unsyntactic ${type2 === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: ({
      importName
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: ({
      maxArgumentCount
    }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({
      radix
    }) => `Expected number in radix ${radix}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({
      reservedWord
    }) => `Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({
      identifierName
    }) => `Invalid identifier ${identifierName}.`,
    InvalidLhs: ({
      ancestor
    }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({
      ancestor
    }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsOptionalChaining: ({
      ancestor
    }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({
      unexpected
    }) => `Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({
      identifierName
    }) => `Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({
      labelName
    }) => `Label '${labelName}' is already declared.`,
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({
      missingPlugin
    }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingOneOfPlugins: ({
      missingPlugin
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({
      key: key2
    }) => `Duplicate key "${key2}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({
      surrogateCharCode
    }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({
      localName
    }) => `Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({
      identifierName
    }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({
      identifierName
    }) => `Duplicate private name #${identifierName}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({
      keyword
    }) => `Unexpected keyword '${keyword}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({
      reservedWord
    }) => `Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({
      expected,
      unexpected
    }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({
      target,
      onlyValidPropertyName
    }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({
      identifierName
    }) => `Identifier '${identifierName}' has already been declared.`,
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, StrictModeErrors = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({
      referenceName
    }) => `Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({
      bindingName
    }) => `Binding '${bindingName}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  };
  const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var PipelineOperatorErrors = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({
      token: token2
    }) => `Invalid topic token ${token2}. In order to use ${token2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token2}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({
      type: type2
    }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
      type: type2
    })}; please wrap it in parentheses.`,
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  };
  const _excluded = ["toMessage"], _excluded2 = ["message"];
  function defineHidden(obj, key2, value) {
    Object.defineProperty(obj, key2, {
      enumerable: !1,
      configurable: !0,
      value
    });
  }
  function toParseErrorConstructor(_ref) {
    let {
      toMessage
    } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded);
    return function constructor(loc, details) {
      const error2 = new SyntaxError();
      return Object.assign(error2, properties, {
        loc,
        pos: loc.index
      }), "missingPlugin" in details && Object.assign(error2, {
        missingPlugin: details.missingPlugin
      }), defineHidden(error2, "clone", function(overrides = {}) {
        var _overrides$loc;
        const {
          line: line3,
          column: column2,
          index
        } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
        return constructor(new Position(line3, column2, index), Object.assign({}, details, overrides.details));
      }), defineHidden(error2, "details", details), Object.defineProperty(error2, "message", {
        configurable: !0,
        get() {
          const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
          return this.message = message, message;
        },
        set(value) {
          Object.defineProperty(this, "message", {
            value,
            writable: !0
          });
        }
      }), error2;
    };
  }
  function ParseErrorEnum(argument, syntaxPlugin) {
    if (Array.isArray(argument))
      return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
    const ParseErrorConstructors = {};
    for (const reasonCode of Object.keys(argument)) {
      const template = argument[reasonCode], _ref2 = typeof template == "string" ? {
        message: () => template
      } : typeof template == "function" ? {
        message: template
      } : template, {
        message
      } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2), toMessage = typeof message == "string" ? () => message : message;
      ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode,
        toMessage
      }, syntaxPlugin ? {
        syntaxPlugin
      } : {}, rest));
    }
    return ParseErrorConstructors;
  }
  const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors)), {
    defineProperty: defineProperty2
  } = Object, toUnenumerable = (object, key2) => defineProperty2(object, key2, {
    enumerable: !1,
    value: object[key2]
  });
  function toESTreeLocation(node2) {
    return node2.loc.start && toUnenumerable(node2.loc.start, "index"), node2.loc.end && toUnenumerable(node2.loc.end, "index"), node2;
  }
  var estree = (superClass) => class extends superClass {
    parse() {
      const file2 = toESTreeLocation(super.parse());
      return this.options.tokens && (file2.tokens = file2.tokens.map(toESTreeLocation)), file2;
    }
    parseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex = null;
      try {
        regex = new RegExp(pattern, flags);
      } catch {
      }
      const node2 = this.estreeParseLiteral(regex);
      return node2.regex = {
        pattern,
        flags
      }, node2;
    }
    parseBigIntLiteral(value) {
      let bigInt;
      try {
        bigInt = BigInt(value);
      } catch {
        bigInt = null;
      }
      const node2 = this.estreeParseLiteral(bigInt);
      return node2.bigint = String(node2.value || value), node2;
    }
    parseDecimalLiteral(value) {
      const node2 = this.estreeParseLiteral(null);
      return node2.decimal = String(node2.value || value), node2;
    }
    estreeParseLiteral(value) {
      return this.parseLiteral(value, "Literal");
    }
    parseStringLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    directiveToStmt(directive) {
      const expression = directive.value;
      delete directive.value, expression.type = "Literal", expression.raw = expression.extra.raw, expression.value = expression.extra.expressionValue;
      const stmt = directive;
      return stmt.type = "ExpressionStatement", stmt.expression = expression, stmt.directive = expression.extra.rawValue, delete expression.extra, stmt;
    }
    initFunction(node2, isAsync) {
      super.initFunction(node2, isAsync), node2.expression = !1;
    }
    checkDeclaration(node2) {
      node2 != null && this.isObjectProperty(node2) ? this.checkDeclaration(node2.value) : super.checkDeclaration(node2);
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params;
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr;
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value == "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    }
    parseBlockBody(node2, allowDirectives, topLevel, end2, afterBlockParse) {
      super.parseBlockBody(node2, allowDirectives, topLevel, end2, afterBlockParse);
      const directiveStatements = node2.directives.map((d) => this.directiveToStmt(d));
      node2.body = directiveStatements.concat(node2.body), delete node2.directives;
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0), method.typeParameters && (method.value.typeParameters = method.typeParameters, delete method.typeParameters), classBody.body.push(method);
    }
    parsePrivateName() {
      const node2 = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(node2) : node2;
    }
    convertPrivateNameToPrivateIdentifier(node2) {
      const name = super.getPrivateNameSV(node2);
      return node2 = node2, delete node2.id, node2.name = name, node2.type = "PrivateIdentifier", node2;
    }
    isPrivateName(node2) {
      return this.getPluginOption("estree", "classFeatures") ? node2.type === "PrivateIdentifier" : super.isPrivateName(node2);
    }
    getPrivateNameSV(node2) {
      return this.getPluginOption("estree", "classFeatures") ? node2.name : super.getPrivateNameSV(node2);
    }
    parseLiteral(value, type2) {
      const node2 = super.parseLiteral(value, type2);
      return node2.raw = node2.extra.raw, delete node2.extra, node2;
    }
    parseFunctionBody(node2, allowExpression, isMethod = !1) {
      super.parseFunctionBody(node2, allowExpression, isMethod), node2.expression = node2.body.type !== "BlockStatement";
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope = !1) {
      let funcNode = this.startNode();
      return funcNode.kind = node2.kind, funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope), funcNode.type = "FunctionExpression", delete funcNode.kind, node2.value = funcNode, type2 === "ClassPrivateMethod" && (node2.computed = !1), this.finishNode(node2, "MethodDefinition");
    }
    nameIsConstructor(key2) {
      return key2.type === "Literal" ? key2.value === "constructor" : super.nameIsConstructor(key2);
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args);
      return this.getPluginOption("estree", "classFeatures") && (propertyNode.type = "PropertyDefinition"), propertyNode;
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args);
      return this.getPluginOption("estree", "classFeatures") && (propertyNode.type = "PropertyDefinition", propertyNode.computed = !1), propertyNode;
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      const node2 = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
      return node2 && (node2.type = "Property", node2.kind === "method" && (node2.kind = "init"), node2.shorthand = !1), node2;
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      const node2 = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      return node2 && (node2.kind = "init", node2.type = "Property"), node2;
    }
    isValidLVal(type2, isUnparenthesizedInAssign, binding) {
      return type2 === "Property" ? "value" : super.isValidLVal(type2, isUnparenthesizedInAssign, binding);
    }
    isAssignable(node2, isBinding) {
      return node2 != null && this.isObjectProperty(node2) ? this.isAssignable(node2.value, isBinding) : super.isAssignable(node2, isBinding);
    }
    toAssignable(node2, isLHS = !1) {
      if (node2 != null && this.isObjectProperty(node2)) {
        const {
          key: key2,
          value
        } = node2;
        this.isPrivateName(key2) && this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start), this.toAssignable(value, isLHS);
      } else
        super.toAssignable(node2, isLHS);
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      prop.type === "Property" && (prop.kind === "get" || prop.kind === "set") ? this.raise(Errors.PatternHasAccessor, prop.key) : prop.type === "Property" && prop.method ? this.raise(Errors.PatternHasMethod, prop.key) : super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
    }
    finishCallExpression(unfinished, optional) {
      const node2 = super.finishCallExpression(unfinished, optional);
      if (node2.callee.type === "Import") {
        if (node2.type = "ImportExpression", node2.source = node2.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var _ref, _ref2;
          node2.options = (_ref = node2.arguments[1]) != null ? _ref : null, node2.attributes = (_ref2 = node2.arguments[1]) != null ? _ref2 : null;
        }
        delete node2.arguments, delete node2.callee;
      }
      return node2;
    }
    toReferencedArguments(node2) {
      node2.type !== "ImportExpression" && super.toReferencedArguments(node2);
    }
    parseExport(unfinished, decorators) {
      const exportStartLoc = this.state.lastTokStartLoc, node2 = super.parseExport(unfinished, decorators);
      switch (node2.type) {
        case "ExportAllDeclaration":
          node2.exported = null;
          break;
        case "ExportNamedDeclaration":
          node2.specifiers.length === 1 && node2.specifiers[0].type === "ExportNamespaceSpecifier" && (node2.type = "ExportAllDeclaration", node2.exported = node2.specifiers[0].exported, delete node2.specifiers);
        case "ExportDefaultDeclaration":
          {
            var _declaration$decorato;
            const {
              declaration
            } = node2;
            declaration?.type === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node2.start && this.resetStartLocation(node2, exportStartLoc);
          }
          break;
      }
      return node2;
    }
    parseSubscript(base2, startLoc, noCalls, state2) {
      const node2 = super.parseSubscript(base2, startLoc, noCalls, state2);
      if (state2.optionalChainMember) {
        if ((node2.type === "OptionalMemberExpression" || node2.type === "OptionalCallExpression") && (node2.type = node2.type.substring(8)), state2.stop) {
          const chain = this.startNodeAtNode(node2);
          return chain.expression = node2, this.finishNode(chain, "ChainExpression");
        }
      } else (node2.type === "MemberExpression" || node2.type === "CallExpression") && (node2.optional = !1);
      return node2;
    }
    isOptionalMemberExpression(node2) {
      return node2.type === "ChainExpression" ? node2.expression.type === "MemberExpression" : super.isOptionalMemberExpression(node2);
    }
    hasPropertyAsPrivateName(node2) {
      return node2.type === "ChainExpression" && (node2 = node2.expression), super.hasPropertyAsPrivateName(node2);
    }
    isObjectProperty(node2) {
      return node2.type === "Property" && node2.kind === "init" && !node2.method;
    }
    isObjectMethod(node2) {
      return node2.type === "Property" && (node2.method || node2.kind === "get" || node2.kind === "set");
    }
    finishNodeAt(node2, type2, endLoc) {
      return toESTreeLocation(super.finishNodeAt(node2, type2, endLoc));
    }
    resetStartLocation(node2, startLoc) {
      super.resetStartLocation(node2, startLoc), toESTreeLocation(node2);
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      super.resetEndLocation(node2, endLoc), toESTreeLocation(node2);
    }
  };
  class TokContext {
    constructor(token2, preserveSpace) {
      this.token = void 0, this.preserveSpace = void 0, this.token = token2, this.preserveSpace = !!preserveSpace;
    }
  }
  const types2 = {
    brace: new TokContext("{"),
    j_oTag: new TokContext("<tag"),
    j_cTag: new TokContext("</tag"),
    j_expr: new TokContext("<tag>...</tag>", !0)
  };
  types2.template = new TokContext("`", !0);
  const beforeExpr = !0, startsExpr = !0, isLoop = !0, isAssign = !0, prefix = !0, postfix = !0;
  class ExportedTokenType {
    constructor(label, conf2 = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = label, this.keyword = conf2.keyword, this.beforeExpr = !!conf2.beforeExpr, this.startsExpr = !!conf2.startsExpr, this.rightAssociative = !!conf2.rightAssociative, this.isLoop = !!conf2.isLoop, this.isAssign = !!conf2.isAssign, this.prefix = !!conf2.prefix, this.postfix = !!conf2.postfix, this.binop = conf2.binop != null ? conf2.binop : null, this.updateContext = null;
    }
  }
  const keywords$1 = /* @__PURE__ */ new Map();
  function createKeyword(name, options2 = {}) {
    options2.keyword = name;
    const token2 = createToken(name, options2);
    return keywords$1.set(name, token2), token2;
  }
  function createBinop(name, binop) {
    return createToken(name, {
      beforeExpr,
      binop
    });
  }
  let tokenTypeCounter = -1;
  const tokenTypes = [], tokenLabels = [], tokenBinops = [], tokenBeforeExprs = [], tokenStartsExprs = [], tokenPrefixes = [];
  function createToken(name, options2 = {}) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    return ++tokenTypeCounter, tokenLabels.push(name), tokenBinops.push((_options$binop = options2.binop) != null ? _options$binop : -1), tokenBeforeExprs.push((_options$beforeExpr = options2.beforeExpr) != null ? _options$beforeExpr : !1), tokenStartsExprs.push((_options$startsExpr = options2.startsExpr) != null ? _options$startsExpr : !1), tokenPrefixes.push((_options$prefix = options2.prefix) != null ? _options$prefix : !1), tokenTypes.push(new ExportedTokenType(name, options2)), tokenTypeCounter;
  }
  function createKeywordLike(name, options2 = {}) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    return ++tokenTypeCounter, keywords$1.set(name, tokenTypeCounter), tokenLabels.push(name), tokenBinops.push((_options$binop2 = options2.binop) != null ? _options$binop2 : -1), tokenBeforeExprs.push((_options$beforeExpr2 = options2.beforeExpr) != null ? _options$beforeExpr2 : !1), tokenStartsExprs.push((_options$startsExpr2 = options2.startsExpr) != null ? _options$startsExpr2 : !1), tokenPrefixes.push((_options$prefix2 = options2.prefix) != null ? _options$prefix2 : !1), tokenTypes.push(new ExportedTokenType("name", options2)), tokenTypeCounter;
  }
  const tt = {
    bracketL: createToken("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: createToken("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: createToken("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: createToken("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: createToken("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: createToken("}"),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
      beforeExpr
    }),
    semi: createToken(";", {
      beforeExpr
    }),
    colon: createToken(":", {
      beforeExpr
    }),
    doubleColon: createToken("::", {
      beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
      beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
      beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
      beforeExpr
    }),
    backQuote: createToken("`", {
      startsExpr
    }),
    dollarBraceL: createToken("${", {
      beforeExpr,
      startsExpr
    }),
    templateTail: createToken("...`", {
      startsExpr
    }),
    templateNonTail: createToken("...${", {
      beforeExpr,
      startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
      startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
      beforeExpr,
      isAssign
    }),
    assign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    slashAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    xorAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    moduloAssign: createToken("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: createToken("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: createToken("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: createToken("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    doubleCaret: createToken("^^", {
      startsExpr
    }),
    doubleAt: createToken("@@", {
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    bitShiftL: createBinop("<</>>/>>>", 8),
    bitShiftR: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: createToken("%", {
      binop: 10,
      startsExpr
    }),
    star: createToken("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: !0
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _do: createKeyword("do", {
      isLoop,
      beforeExpr
    }),
    _for: createKeyword("for", {
      isLoop
    }),
    _while: createKeyword("while", {
      isLoop
    }),
    _as: createKeywordLike("as", {
      startsExpr
    }),
    _assert: createKeywordLike("assert", {
      startsExpr
    }),
    _async: createKeywordLike("async", {
      startsExpr
    }),
    _await: createKeywordLike("await", {
      startsExpr
    }),
    _defer: createKeywordLike("defer", {
      startsExpr
    }),
    _from: createKeywordLike("from", {
      startsExpr
    }),
    _get: createKeywordLike("get", {
      startsExpr
    }),
    _let: createKeywordLike("let", {
      startsExpr
    }),
    _meta: createKeywordLike("meta", {
      startsExpr
    }),
    _of: createKeywordLike("of", {
      startsExpr
    }),
    _sent: createKeywordLike("sent", {
      startsExpr
    }),
    _set: createKeywordLike("set", {
      startsExpr
    }),
    _source: createKeywordLike("source", {
      startsExpr
    }),
    _static: createKeywordLike("static", {
      startsExpr
    }),
    _using: createKeywordLike("using", {
      startsExpr
    }),
    _yield: createKeywordLike("yield", {
      startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
      startsExpr
    }),
    _checks: createKeywordLike("checks", {
      startsExpr
    }),
    _exports: createKeywordLike("exports", {
      startsExpr
    }),
    _global: createKeywordLike("global", {
      startsExpr
    }),
    _implements: createKeywordLike("implements", {
      startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
      startsExpr
    }),
    _infer: createKeywordLike("infer", {
      startsExpr
    }),
    _is: createKeywordLike("is", {
      startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
      startsExpr
    }),
    _proto: createKeywordLike("proto", {
      startsExpr
    }),
    _require: createKeywordLike("require", {
      startsExpr
    }),
    _satisfies: createKeywordLike("satisfies", {
      startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
      startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
      startsExpr
    }),
    _unique: createKeywordLike("unique", {
      startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
      startsExpr
    }),
    _declare: createKeywordLike("declare", {
      startsExpr
    }),
    _enum: createKeywordLike("enum", {
      startsExpr
    }),
    _module: createKeywordLike("module", {
      startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
      startsExpr
    }),
    _interface: createKeywordLike("interface", {
      startsExpr
    }),
    _type: createKeywordLike("type", {
      startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
      startsExpr
    }),
    name: createToken("name", {
      startsExpr
    }),
    string: createToken("string", {
      startsExpr
    }),
    num: createToken("num", {
      startsExpr
    }),
    bigint: createToken("bigint", {
      startsExpr
    }),
    decimal: createToken("decimal", {
      startsExpr
    }),
    regexp: createToken("regexp", {
      startsExpr
    }),
    privateName: createToken("#name", {
      startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: createToken("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: createToken("jsxTagEnd"),
    placeholder: createToken("%%", {
      startsExpr: !0
    })
  };
  function tokenIsIdentifier(token2) {
    return token2 >= 93 && token2 <= 132;
  }
  function tokenKeywordOrIdentifierIsKeyword(token2) {
    return token2 <= 92;
  }
  function tokenIsKeywordOrIdentifier(token2) {
    return token2 >= 58 && token2 <= 132;
  }
  function tokenIsLiteralPropertyName(token2) {
    return token2 >= 58 && token2 <= 136;
  }
  function tokenComesBeforeExpression(token2) {
    return tokenBeforeExprs[token2];
  }
  function tokenCanStartExpression(token2) {
    return tokenStartsExprs[token2];
  }
  function tokenIsAssignment(token2) {
    return token2 >= 29 && token2 <= 33;
  }
  function tokenIsFlowInterfaceOrTypeOrOpaque(token2) {
    return token2 >= 129 && token2 <= 131;
  }
  function tokenIsLoop(token2) {
    return token2 >= 90 && token2 <= 92;
  }
  function tokenIsKeyword(token2) {
    return token2 >= 58 && token2 <= 92;
  }
  function tokenIsOperator(token2) {
    return token2 >= 39 && token2 <= 59;
  }
  function tokenIsPostfix(token2) {
    return token2 === 34;
  }
  function tokenIsPrefix(token2) {
    return tokenPrefixes[token2];
  }
  function tokenIsTSTypeOperator(token2) {
    return token2 >= 121 && token2 <= 123;
  }
  function tokenIsTSDeclarationStart(token2) {
    return token2 >= 124 && token2 <= 130;
  }
  function tokenLabelName(token2) {
    return tokenLabels[token2];
  }
  function tokenOperatorPrecedence(token2) {
    return tokenBinops[token2];
  }
  function tokenIsRightAssociative(token2) {
    return token2 === 57;
  }
  function tokenIsTemplate(token2) {
    return token2 >= 24 && token2 <= 25;
  }
  function getExportedToken(token2) {
    return tokenTypes[token2];
  }
  tokenTypes[8].updateContext = (context) => {
    context.pop();
  }, tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
    context.push(types2.brace);
  }, tokenTypes[22].updateContext = (context) => {
    context[context.length - 1] === types2.template ? context.pop() : context.push(types2.template);
  }, tokenTypes[142].updateContext = (context) => {
    context.push(types2.j_expr, types2.j_oTag);
  };
  let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code2, set2) {
    let pos2 = 65536;
    for (let i2 = 0, length = set2.length; i2 < length; i2 += 2) {
      if (pos2 += set2[i2], pos2 > code2) return !1;
      if (pos2 += set2[i2 + 1], pos2 >= code2) return !0;
    }
    return !1;
  }
  function isIdentifierStart(code2) {
    return code2 < 65 ? code2 === 36 : code2 <= 90 ? !0 : code2 < 97 ? code2 === 95 : code2 <= 122 ? !0 : code2 <= 65535 ? code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2)) : isInAstralSet(code2, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code2) {
    return code2 < 48 ? code2 === 36 : code2 < 58 ? !0 : code2 < 65 ? !1 : code2 <= 90 ? !0 : code2 < 97 ? code2 === 95 : code2 <= 122 ? !0 : code2 <= 65535 ? code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2)) : isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
  }
  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
  function isIteratorStart(current, next, next2) {
    return current === 64 && next === 64 && isIdentifierStart(next2);
  }
  const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
  }
  class Scope {
    constructor(flags) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = flags;
    }
  }
  class ScopeHandler {
    constructor(parser2, inModule) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = parser2, this.inModule = inModule;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const flags = this.currentThisScopeFlags();
      return (flags & 64) > 0 && (flags & 2) === 0;
    }
    get inStaticBlock() {
      for (let i2 = this.scopeStack.length - 1; ; i2--) {
        const {
          flags
        } = this.scopeStack[i2];
        if (flags & 128)
          return !0;
        if (flags & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
      return new Scope(flags);
    }
    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(scope2) {
      return !!(scope2.flags & 130 || !this.parser.inModule && scope2.flags & 1);
    }
    declareName(name, bindingType, loc) {
      let scope2 = this.currentScope();
      if (bindingType & 8 || bindingType & 16) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc);
        let type2 = scope2.names.get(name) || 0;
        bindingType & 16 ? type2 = type2 | 4 : (scope2.firstLexicalName || (scope2.firstLexicalName = name), type2 = type2 | 2), scope2.names.set(name, type2), bindingType & 8 && this.maybeExportDefined(scope2, name);
      } else if (bindingType & 4)
        for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (scope2 = this.scopeStack[i2], this.checkRedeclarationInScope(scope2, name, bindingType, loc), scope2.names.set(name, (scope2.names.get(name) || 0) | 1), this.maybeExportDefined(scope2, name), !(scope2.flags & 387)); --i2)
          ;
      this.parser.inModule && scope2.flags & 1 && this.undefinedExports.delete(name);
    }
    maybeExportDefined(scope2, name) {
      this.parser.inModule && scope2.flags & 1 && this.undefinedExports.delete(name);
    }
    checkRedeclarationInScope(scope2, name, bindingType, loc) {
      this.isRedeclaredInScope(scope2, name, bindingType) && this.parser.raise(Errors.VarRedeclaration, loc, {
        identifierName: name
      });
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      if (!(bindingType & 1)) return !1;
      if (bindingType & 8)
        return scope2.names.has(name);
      const type2 = scope2.names.get(name);
      return bindingType & 16 ? (type2 & 2) > 0 || !this.treatFunctionsAsVarInScope(scope2) && (type2 & 1) > 0 : (type2 & 2) > 0 && !(scope2.flags & 8 && scope2.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope2) && (type2 & 4) > 0;
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      this.scopeStack[0].names.has(name) || this.undefinedExports.set(name, id.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let i2 = this.scopeStack.length - 1; ; i2--) {
        const {
          flags
        } = this.scopeStack[i2];
        if (flags & 387)
          return flags;
      }
    }
    currentThisScopeFlags() {
      for (let i2 = this.scopeStack.length - 1; ; i2--) {
        const {
          flags
        } = this.scopeStack[i2];
        if (flags & 451 && !(flags & 4))
          return flags;
      }
    }
  }
  class FlowScope extends Scope {
    constructor(...args) {
      super(...args), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }
    declareName(name, bindingType, loc) {
      const scope2 = this.currentScope();
      if (bindingType & 2048) {
        this.checkRedeclarationInScope(scope2, name, bindingType, loc), this.maybeExportDefined(scope2, name), scope2.declareFunctions.add(name);
        return;
      }
      super.declareName(name, bindingType, loc);
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      if (super.isRedeclaredInScope(scope2, name, bindingType)) return !0;
      if (bindingType & 2048 && !scope2.declareFunctions.has(name)) {
        const type2 = scope2.names.get(name);
        return (type2 & 4) > 0 || (type2 & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(id) {
      this.scopeStack[0].declareFunctions.has(id.name) || super.checkLocalExport(id);
    }
  }
  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(pluginConfig) {
      if (typeof pluginConfig == "string")
        return this.plugins.has(pluginConfig);
      {
        const [pluginName, pluginOptions] = pluginConfig;
        if (!this.hasPlugin(pluginName))
          return !1;
        const actualOptions = this.plugins.get(pluginName);
        for (const key2 of Object.keys(pluginOptions))
          if (actualOptions?.[key2] !== pluginOptions[key2])
            return !1;
        return !0;
      }
    }
    getPluginOption(plugin, name) {
      var _this$plugins$get;
      return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
    }
  }
  function setTrailingComments(node2, comments2) {
    node2.trailingComments === void 0 ? node2.trailingComments = comments2 : node2.trailingComments.unshift(...comments2);
  }
  function setLeadingComments(node2, comments2) {
    node2.leadingComments === void 0 ? node2.leadingComments = comments2 : node2.leadingComments.unshift(...comments2);
  }
  function setInnerComments(node2, comments2) {
    node2.innerComments === void 0 ? node2.innerComments = comments2 : node2.innerComments.unshift(...comments2);
  }
  function adjustInnerComments(node2, elements, commentWS) {
    let lastElement = null, i2 = elements.length;
    for (; lastElement === null && i2 > 0; )
      lastElement = elements[--i2];
    lastElement === null || lastElement.start > commentWS.start ? setInnerComments(node2, commentWS.comments) : setTrailingComments(lastElement, commentWS.comments);
  }
  class CommentsParser extends BaseParser {
    addComment(comment) {
      this.filename && (comment.loc.filename = this.filename);
      const {
        commentsLen
      } = this.state;
      this.comments.length !== commentsLen && (this.comments.length = commentsLen), this.comments.push(comment), this.state.commentsLen++;
    }
    processComment(node2) {
      const {
        commentStack
      } = this.state, commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      let i2 = commentStackLength - 1;
      const lastCommentWS = commentStack[i2];
      lastCommentWS.start === node2.end && (lastCommentWS.leadingNode = node2, i2--);
      const {
        start: nodeStart
      } = node2;
      for (; i2 >= 0; i2--) {
        const commentWS = commentStack[i2], commentEnd = commentWS.end;
        if (commentEnd > nodeStart)
          commentWS.containingNode = node2, this.finalizeComment(commentWS), commentStack.splice(i2, 1);
        else {
          commentEnd === nodeStart && (commentWS.trailingNode = node2);
          break;
        }
      }
    }
    finalizeComment(commentWS) {
      const {
        comments: comments2
      } = commentWS;
      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null)
        commentWS.leadingNode !== null && setTrailingComments(commentWS.leadingNode, comments2), commentWS.trailingNode !== null && setLeadingComments(commentWS.trailingNode, comments2);
      else {
        const {
          containingNode: node2,
          start: commentStart
        } = commentWS;
        if (this.input.charCodeAt(commentStart - 1) === 44)
          switch (node2.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node2, node2.properties, commentWS);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node2, node2.arguments, commentWS);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node2, node2.params, commentWS);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node2, node2.elements, commentWS);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node2, node2.specifiers, commentWS);
              break;
            default:
              setInnerComments(node2, comments2);
          }
        else
          setInnerComments(node2, comments2);
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack
      } = this.state;
      for (let i2 = commentStack.length - 1; i2 >= 0; i2--)
        this.finalizeComment(commentStack[i2]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node2) {
      const {
        commentStack
      } = this.state, {
        length
      } = commentStack;
      if (length === 0) return;
      const commentWS = commentStack[length - 1];
      commentWS.leadingNode === node2 && (commentWS.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(node2) {
      const {
        commentStack
      } = this.state, {
        length
      } = commentStack;
      length !== 0 && (commentStack[length - 1].trailingNode === node2 ? commentStack[length - 1].trailingNode = null : length >= 2 && commentStack[length - 2].trailingNode === node2 && (commentStack[length - 2].trailingNode = null));
    }
    takeSurroundingComments(node2, start, end2) {
      const {
        commentStack
      } = this.state, commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      let i2 = commentStackLength - 1;
      for (; i2 >= 0; i2--) {
        const commentWS = commentStack[i2], commentEnd = commentWS.end;
        if (commentWS.start === end2)
          commentWS.leadingNode = node2;
        else if (commentEnd === start)
          commentWS.trailingNode = node2;
        else if (commentEnd < start)
          break;
      }
    }
  }
  const lineBreak = /\r\n?|[\n\u2028\u2029]/, lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code2) {
    switch (code2) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function isWhitespace2(code2) {
    switch (code2) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  class State3 {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [types2.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(value) {
      value ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode,
      sourceType,
      startLine,
      startColumn
    }) {
      this.strict = strictMode === !1 ? !1 : strictMode === !0 ? !0 : sourceType === "module", this.curLine = startLine, this.lineStart = -startColumn, this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(value) {
      value ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(value) {
      value ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(value) {
      value ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(value) {
      value ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(value) {
      value ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(value) {
      value ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(value) {
      value ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(value) {
      value ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(value) {
      value ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(value) {
      value ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(value) {
      value ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      const state2 = new State3();
      return state2.flags = this.flags, state2.curLine = this.curLine, state2.lineStart = this.lineStart, state2.startLoc = this.startLoc, state2.endLoc = this.endLoc, state2.errors = this.errors.slice(), state2.potentialArrowAt = this.potentialArrowAt, state2.noArrowAt = this.noArrowAt.slice(), state2.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), state2.topicContext = this.topicContext, state2.labels = this.labels.slice(), state2.commentsLen = this.commentsLen, state2.commentStack = this.commentStack.slice(), state2.pos = this.pos, state2.type = this.type, state2.value = this.value, state2.start = this.start, state2.end = this.end, state2.lastTokEndLoc = this.lastTokEndLoc, state2.lastTokStartLoc = this.lastTokStartLoc, state2.context = this.context.slice(), state2.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, state2.strictErrors = this.strictErrors, state2.tokensLength = this.tokensLength, state2;
    }
  }
  var _isDigit = function(code2) {
    return code2 >= 48 && code2 <= 57;
  };
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
  };
  function readStringContents(type2, input2, pos2, lineStart, curLine, errors2) {
    const initialPos = pos2, initialLineStart = lineStart, initialCurLine = curLine;
    let out = "", firstInvalidLoc = null, chunkStart = pos2;
    const {
      length
    } = input2;
    for (; ; ) {
      if (pos2 >= length) {
        errors2.unterminated(initialPos, initialLineStart, initialCurLine), out += input2.slice(chunkStart, pos2);
        break;
      }
      const ch = input2.charCodeAt(pos2);
      if (isStringEnd(type2, ch, input2, pos2)) {
        out += input2.slice(chunkStart, pos2);
        break;
      }
      if (ch === 92) {
        out += input2.slice(chunkStart, pos2);
        const res = readEscapedChar(input2, pos2, lineStart, curLine, type2 === "template", errors2);
        res.ch === null && !firstInvalidLoc ? firstInvalidLoc = {
          pos: pos2,
          lineStart,
          curLine
        } : out += res.ch, {
          pos: pos2,
          lineStart,
          curLine
        } = res, chunkStart = pos2;
      } else ch === 8232 || ch === 8233 ? (++pos2, ++curLine, lineStart = pos2) : ch === 10 || ch === 13 ? type2 === "template" ? (out += input2.slice(chunkStart, pos2) + `
`, ++pos2, ch === 13 && input2.charCodeAt(pos2) === 10 && ++pos2, ++curLine, chunkStart = lineStart = pos2) : errors2.unterminated(initialPos, initialLineStart, initialCurLine) : ++pos2;
    }
    return {
      pos: pos2,
      str: out,
      firstInvalidLoc,
      lineStart,
      curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type2, ch, input2, pos2) {
    return type2 === "template" ? ch === 96 || ch === 36 && input2.charCodeAt(pos2 + 1) === 123 : ch === (type2 === "double" ? 34 : 39);
  }
  function readEscapedChar(input2, pos2, lineStart, curLine, inTemplate, errors2) {
    const throwOnInvalid = !inTemplate;
    pos2++;
    const res = (ch2) => ({
      pos: pos2,
      ch: ch2,
      lineStart,
      curLine
    }), ch = input2.charCodeAt(pos2++);
    switch (ch) {
      case 110:
        return res(`
`);
      case 114:
        return res("\r");
      case 120: {
        let code2;
        return {
          code: code2,
          pos: pos2
        } = readHexChar(input2, pos2, lineStart, curLine, 2, !1, throwOnInvalid, errors2), res(code2 === null ? null : String.fromCharCode(code2));
      }
      case 117: {
        let code2;
        return {
          code: code2,
          pos: pos2
        } = readCodePoint(input2, pos2, lineStart, curLine, throwOnInvalid, errors2), res(code2 === null ? null : String.fromCodePoint(code2));
      }
      case 116:
        return res("	");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        input2.charCodeAt(pos2) === 10 && ++pos2;
      case 10:
        lineStart = pos2, ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate)
          return res(null);
        errors2.strictNumericEscape(pos2 - 1, lineStart, curLine);
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos2 - 1;
          let octalStr = input2.slice(startPos, pos2 + 2).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
          octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), pos2 += octalStr.length - 1;
          const next = input2.charCodeAt(pos2);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate)
              return res(null);
            errors2.strictNumericEscape(startPos, lineStart, curLine);
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input2, pos2, lineStart, curLine, len, forceLen, throwOnInvalid, errors2) {
    const initialPos = pos2;
    let n;
    return {
      n,
      pos: pos2
    } = readInt(input2, pos2, lineStart, curLine, 16, len, forceLen, !1, errors2, !throwOnInvalid), n === null && (throwOnInvalid ? errors2.invalidEscapeSequence(initialPos, lineStart, curLine) : pos2 = initialPos - 1), {
      code: n,
      pos: pos2
    };
  }
  function readInt(input2, pos2, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors2, bailOnError) {
    const start = pos2, forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = !1, total = 0;
    for (let i2 = 0, e = len ?? 1 / 0; i2 < e; ++i2) {
      const code2 = input2.charCodeAt(pos2);
      let val;
      if (code2 === 95 && allowNumSeparator !== "bail") {
        const prev = input2.charCodeAt(pos2 - 1), next = input2.charCodeAt(pos2 + 1);
        if (allowNumSeparator) {
          if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos: pos2
            };
            errors2.unexpectedNumericSeparator(pos2, lineStart, curLine);
          }
        } else {
          if (bailOnError) return {
            n: null,
            pos: pos2
          };
          errors2.numericSeparatorInEscapeSequence(pos2, lineStart, curLine);
        }
        ++pos2;
        continue;
      }
      if (code2 >= 97 ? val = code2 - 97 + 10 : code2 >= 65 ? val = code2 - 65 + 10 : _isDigit(code2) ? val = code2 - 48 : val = 1 / 0, val >= radix) {
        if (val <= 9 && bailOnError)
          return {
            n: null,
            pos: pos2
          };
        if (val <= 9 && errors2.invalidDigit(pos2, lineStart, curLine, radix))
          val = 0;
        else if (forceLen)
          val = 0, invalid = !0;
        else
          break;
      }
      ++pos2, total = total * radix + val;
    }
    return pos2 === start || len != null && pos2 - start !== len || invalid ? {
      n: null,
      pos: pos2
    } : {
      n: total,
      pos: pos2
    };
  }
  function readCodePoint(input2, pos2, lineStart, curLine, throwOnInvalid, errors2) {
    const ch = input2.charCodeAt(pos2);
    let code2;
    if (ch === 123) {
      if (++pos2, {
        code: code2,
        pos: pos2
      } = readHexChar(input2, pos2, lineStart, curLine, input2.indexOf("}", pos2) - pos2, !0, throwOnInvalid, errors2), ++pos2, code2 !== null && code2 > 1114111)
        if (throwOnInvalid)
          errors2.invalidCodePoint(pos2, lineStart, curLine);
        else
          return {
            code: null,
            pos: pos2
          };
    } else
      ({
        code: code2,
        pos: pos2
      } = readHexChar(input2, pos2, lineStart, curLine, 4, !1, throwOnInvalid, errors2));
    return {
      code: code2,
      pos: pos2
    };
  }
  function buildPosition(pos2, lineStart, curLine) {
    return new Position(curLine, pos2 - lineStart, pos2);
  }
  const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class Token {
    constructor(state2) {
      this.type = state2.type, this.value = state2.value, this.start = state2.start, this.end = state2.end, this.loc = new SourceLocation(state2.startLoc, state2.endLoc);
    }
  }
  class Tokenizer extends CommentsParser {
    constructor(options2, input2) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: (pos2, lineStart, curLine, radix) => this.options.errorRecovery ? (this.raise(Errors.InvalidDigit, buildPosition(pos2, lineStart, curLine), {
          radix
        }), !0) : !1,
        numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: (pos2, lineStart, curLine) => {
          this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos2, lineStart, curLine));
        },
        unterminated: (pos2, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedString, buildPosition(pos2 - 1, lineStart, curLine));
        }
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
        unterminated: (pos2, lineStart, curLine) => {
          throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos2, lineStart, curLine));
        }
      }), this.state = new State3(), this.state.init(options2), this.input = input2, this.length = input2.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(token2) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(token2), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(type2) {
      return this.match(type2) ? (this.next(), !0) : !1;
    }
    match(type2) {
      return this.state.type === type2;
    }
    createLookaheadState(state2) {
      return {
        pos: state2.pos,
        value: null,
        type: state2.type,
        start: state2.start,
        end: state2.end,
        context: [this.curContext()],
        inType: state2.inType,
        startLoc: state2.startLoc,
        lastTokEndLoc: state2.lastTokEndLoc,
        curLine: state2.curLine,
        lineStart: state2.lineStart,
        curPosition: state2.curPosition
      };
    }
    lookahead() {
      const old2 = this.state;
      this.state = this.createLookaheadState(old2), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      const curr = this.state;
      return this.state = old2, curr;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos2) {
      return skipWhiteSpace.lastIndex = pos2, skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos2;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(pos2) {
      return skipWhiteSpaceInLine.lastIndex = pos2, skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos2;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(pos2) {
      let cp2 = this.input.charCodeAt(pos2);
      if ((cp2 & 64512) === 55296 && ++pos2 < this.input.length) {
        const trail = this.input.charCodeAt(pos2);
        (trail & 64512) === 56320 && (cp2 = 65536 + ((cp2 & 1023) << 10) + (trail & 1023));
      }
      return cp2;
    }
    setStrict(strict) {
      this.state.strict = strict, strict && (this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(commentEnd) {
      let startLoc;
      this.isLookahead || (startLoc = this.state.curPosition());
      const start = this.state.pos, end2 = this.input.indexOf(commentEnd, start + 2);
      if (end2 === -1)
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = end2 + commentEnd.length, lineBreakG.lastIndex = start + 2; lineBreakG.test(this.input) && lineBreakG.lastIndex <= end2; )
        ++this.state.curLine, this.state.lineStart = lineBreakG.lastIndex;
      if (this.isLookahead) return;
      const comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end2),
        start,
        end: end2 + commentEnd.length,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(comment), comment;
    }
    skipLineComment(startSkip) {
      const start = this.state.pos;
      let startLoc;
      this.isLookahead || (startLoc = this.state.curPosition());
      let ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length)
        for (; !isNewLine(ch) && ++this.state.pos < this.length; )
          ch = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      const end2 = this.state.pos, comment = {
        type: "CommentLine",
        value: this.input.slice(start + startSkip, end2),
        start,
        end: end2,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(comment), comment;
    }
    skipSpace() {
      const spaceStart = this.state.pos, comments2 = [];
      loop: for (; this.state.pos < this.length; ) {
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const comment = this.skipBlockComment("*/");
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
                break;
              }
              case 47: {
                const comment = this.skipLineComment(2);
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
                break;
              }
              default:
                break loop;
            }
            break;
          default:
            if (isWhitespace2(ch))
              ++this.state.pos;
            else if (ch === 45 && !this.inModule && this.options.annexB) {
              const pos2 = this.state.pos;
              if (this.input.charCodeAt(pos2 + 1) === 45 && this.input.charCodeAt(pos2 + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                const comment = this.skipLineComment(3);
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
              } else
                break loop;
            } else if (ch === 60 && !this.inModule && this.options.annexB) {
              const pos2 = this.state.pos;
              if (this.input.charCodeAt(pos2 + 1) === 33 && this.input.charCodeAt(pos2 + 2) === 45 && this.input.charCodeAt(pos2 + 3) === 45) {
                const comment = this.skipLineComment(4);
                comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments2.push(comment));
              } else
                break loop;
            } else
              break loop;
        }
      }
      if (comments2.length > 0) {
        const end2 = this.state.pos, commentWhitespace = {
          start: spaceStart,
          end: end2,
          comments: comments2,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(commentWhitespace);
      }
    }
    finishToken(type2, val) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type2, this.state.value = val, this.isLookahead || this.updateContext(prevType);
    }
    replaceToken(type2) {
      this.state.type = type2, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      const nextPos = this.state.pos + 1, next = this.codePointAtPos(nextPos);
      if (next >= 48 && next <= 57)
        throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, next === 123 ? this.finishToken(7) : this.finishToken(1);
      } else isIdentifierStart(next) ? (++this.state.pos, this.finishToken(138, this.readWord1(next))) : next === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        this.readNumber(!0);
        return;
      }
      next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return !1;
      const start = this.state.pos;
      for (this.state.pos += 1; !isNewLine(ch) && ++this.state.pos < this.length; )
        ch = this.input.charCodeAt(this.state.pos);
      const value = this.input.slice(start + 2, this.state.pos);
      return this.finishToken(28, value), !0;
    }
    readToken_mult_modulo(code2) {
      let type2 = code2 === 42 ? 55 : 54, width = 1, next = this.input.charCodeAt(this.state.pos + 1);
      code2 === 42 && next === 42 && (width++, next = this.input.charCodeAt(this.state.pos + 2), type2 = 57), next === 61 && !this.state.inType && (width++, type2 = code2 === 37 ? 33 : 30), this.finishOp(type2, width);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(code2 === 124 ? 41 : 42, 2);
        return;
      }
      if (code2 === 124) {
        if (next === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (next === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(code2 === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      next === 61 && !this.state.inType ? this.finishOp(32, 2) : next === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code2) {
        this.finishOp(34, 2);
        return;
      }
      next === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      const {
        pos: pos2
      } = this.state, next = this.input.charCodeAt(pos2 + 1);
      if (next === 60) {
        if (this.input.charCodeAt(pos2 + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      const {
        pos: pos2
      } = this.state, next = this.input.charCodeAt(pos2 + 1);
      if (next === 62) {
        const size = this.input.charCodeAt(pos2 + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(pos2 + size) === 61) {
          this.finishOp(30, size + 1);
          return;
        }
        this.finishOp(52, size);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (code2 === 61 && next === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(code2 === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1), next2 = this.input.charCodeAt(this.state.pos + 2);
      next === 63 ? next2 === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : next === 46 && !(next2 >= 48 && next2 <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(code2) {
      switch (code2) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(code2);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(code2);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(code2);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(code2);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(code2);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (isIdentifierStart(code2)) {
            this.readWord(code2);
            return;
          }
      }
      throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(code2)
      });
    }
    finishOp(type2, size) {
      const str2 = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size, this.finishToken(type2, str2);
    }
    readRegexp() {
      const startLoc = this.state.startLoc, start = this.state.start + 1;
      let escaped, inClass, {
        pos: pos2
      } = this.state;
      for (; ; ++pos2) {
        if (pos2 >= this.length)
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        const ch = this.input.charCodeAt(pos2);
        if (isNewLine(ch))
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        if (escaped)
          escaped = !1;
        else {
          if (ch === 91)
            inClass = !0;
          else if (ch === 93 && inClass)
            inClass = !1;
          else if (ch === 47 && !inClass)
            break;
          escaped = ch === 92;
        }
      }
      const content = this.input.slice(start, pos2);
      ++pos2;
      let mods2 = "";
      const nextPos = () => createPositionWithColumnOffset(startLoc, pos2 + 2 - start);
      for (; pos2 < this.length; ) {
        const cp2 = this.codePointAtPos(pos2), char = String.fromCharCode(cp2);
        if (VALID_REGEX_FLAGS.has(cp2))
          cp2 === 118 ? mods2.includes("u") && this.raise(Errors.IncompatibleRegExpUVFlags, nextPos()) : cp2 === 117 && mods2.includes("v") && this.raise(Errors.IncompatibleRegExpUVFlags, nextPos()), mods2.includes(char) && this.raise(Errors.DuplicateRegExpFlags, nextPos());
        else if (isIdentifierChar(cp2) || cp2 === 92)
          this.raise(Errors.MalformedRegExpFlags, nextPos());
        else
          break;
        ++pos2, mods2 += char;
      }
      this.state.pos = pos2, this.finishToken(137, {
        pattern: content,
        flags: mods2
      });
    }
    readInt(radix, len, forceLen = !1, allowNumSeparator = !0) {
      const {
        n,
        pos: pos2
      } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, !1);
      return this.state.pos = pos2, n;
    }
    readRadixNumber(radix) {
      const startLoc = this.state.curPosition();
      let isBigInt = !1;
      this.state.pos += 2;
      const val = this.readInt(radix);
      val == null && this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
        radix
      });
      const next = this.input.charCodeAt(this.state.pos);
      if (next === 110)
        ++this.state.pos, isBigInt = !0;
      else if (next === 109)
        throw this.raise(Errors.InvalidDecimal, startLoc);
      if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      if (isBigInt) {
        const str2 = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, str2);
        return;
      }
      this.finishToken(134, val);
    }
    readNumber(startsWithDot) {
      const start = this.state.pos, startLoc = this.state.curPosition();
      let isFloat2 = !1, isBigInt = !1, isDecimal = !1, hasExponent = !1, isOctal = !1;
      !startsWithDot && this.readInt(10) === null && this.raise(Errors.InvalidNumber, this.state.curPosition());
      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        if (this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc), !this.state.strict) {
          const underscorePos = integer.indexOf("_");
          underscorePos > 0 && this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
        }
        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }
      let next = this.input.charCodeAt(this.state.pos);
      if (next === 46 && !isOctal && (++this.state.pos, this.readInt(10), isFloat2 = !0, next = this.input.charCodeAt(this.state.pos)), (next === 69 || next === 101) && !isOctal && (next = this.input.charCodeAt(++this.state.pos), (next === 43 || next === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(Errors.InvalidOrMissingExponent, startLoc), isFloat2 = !0, hasExponent = !0, next = this.input.charCodeAt(this.state.pos)), next === 110 && ((isFloat2 || hasLeadingZero) && this.raise(Errors.InvalidBigIntLiteral, startLoc), ++this.state.pos, isBigInt = !0), next === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (hasExponent || hasLeadingZero) && this.raise(Errors.InvalidDecimal, startLoc), ++this.state.pos, isDecimal = !0), isIdentifierStart(this.codePointAtPos(this.state.pos)))
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      const str2 = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
      if (isBigInt) {
        this.finishToken(135, str2);
        return;
      }
      if (isDecimal) {
        this.finishToken(136, str2);
        return;
      }
      const val = isOctal ? parseInt(str2, 8) : parseFloat(str2);
      this.finishToken(134, val);
    }
    readCodePoint(throwOnInvalid) {
      const {
        code: code2,
        pos: pos2
      } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
      return this.state.pos = pos2, code2;
    }
    readString(quote) {
      const {
        str: str2,
        pos: pos2,
        curLine,
        lineStart
      } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = pos2 + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, this.finishToken(133, str2);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const opening = this.input[this.state.pos], {
        str: str2,
        firstInvalidLoc,
        pos: pos2,
        curLine,
        lineStart
      } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = pos2 + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, firstInvalidLoc && (this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos)), this.input.codePointAt(pos2) === 96 ? this.finishToken(24, firstInvalidLoc ? null : opening + str2 + "`") : (this.state.pos++, this.finishToken(25, firstInvalidLoc ? null : opening + str2 + "${"));
    }
    recordStrictModeErrors(toParseError, at) {
      const index = at.index;
      this.state.strict && !this.state.strictErrors.has(index) ? this.raise(toParseError, at) : this.state.strictErrors.set(index, [toParseError, at]);
    }
    readWord1(firstCode) {
      this.state.containsEsc = !1;
      let word = "";
      const start = this.state.pos;
      let chunkStart = this.state.pos;
      for (firstCode !== void 0 && (this.state.pos += firstCode <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const ch = this.codePointAtPos(this.state.pos);
        if (isIdentifierChar(ch))
          this.state.pos += ch <= 65535 ? 1 : 2;
        else if (ch === 92) {
          this.state.containsEsc = !0, word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.curPosition(), identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Errors.MissingUnicodeEscape, this.state.curPosition()), chunkStart = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const esc = this.readCodePoint(!0);
          esc !== null && (identifierCheck(esc) || this.raise(Errors.EscapedCharNotAnIdentifier, escStart), word += String.fromCodePoint(esc)), chunkStart = this.state.pos;
        } else
          break;
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode) {
      const word = this.readWord1(firstCode), type2 = keywords$1.get(word);
      type2 !== void 0 ? this.finishToken(type2, tokenLabelName(type2)) : this.finishToken(132, word);
    }
    checkKeywordEscapes() {
      const {
        type: type2
      } = this.state;
      tokenIsKeyword(type2) && this.state.containsEsc && this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: tokenLabelName(type2)
      });
    }
    raise(toParseError, at, details = {}) {
      const loc = at instanceof Position ? at : at.loc.start, error2 = toParseError(loc, details);
      if (!this.options.errorRecovery) throw error2;
      return this.isLookahead || this.state.errors.push(error2), error2;
    }
    raiseOverwrite(toParseError, at, details = {}) {
      const loc = at instanceof Position ? at : at.loc.start, pos2 = loc.index, errors2 = this.state.errors;
      for (let i2 = errors2.length - 1; i2 >= 0; i2--) {
        const error2 = errors2[i2];
        if (error2.loc.index === pos2)
          return errors2[i2] = toParseError(loc, details);
        if (error2.loc.index < pos2) break;
      }
      return this.raise(toParseError, at, details);
    }
    updateContext(prevType) {
    }
    unexpected(loc, type2) {
      throw this.raise(Errors.UnexpectedToken, loc ?? this.state.startLoc, {
        expected: type2 ? tokenLabelName(type2) : null
      });
    }
    expectPlugin(pluginName, loc) {
      if (this.hasPlugin(pluginName))
        return !0;
      throw this.raise(Errors.MissingPlugin, loc ?? this.state.startLoc, {
        missingPlugin: [pluginName]
      });
    }
    expectOnePlugin(pluginNames) {
      if (!pluginNames.some((name) => this.hasPlugin(name)))
        throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: pluginNames
        });
    }
    errorBuilder(error2) {
      return (pos2, lineStart, curLine) => {
        this.raise(error2, buildPosition(pos2, lineStart, curLine));
      };
    }
  }
  class ClassScope {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class ClassScopeHandler {
    constructor(parser2) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = parser2;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ClassScope());
    }
    exit() {
      const oldClassScope = this.stack.pop(), current = this.current();
      for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames))
        current ? current.undefinedPrivateNames.has(name) || current.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
          identifierName: name
        });
    }
    declarePrivateName(name, elementType, loc) {
      const {
        privateNames,
        loneAccessors,
        undefinedPrivateNames
      } = this.current();
      let redefined = privateNames.has(name);
      if (elementType & 3) {
        const accessor = redefined && loneAccessors.get(name);
        if (accessor) {
          const oldStatic = accessor & 4, newStatic = elementType & 4, oldKind = accessor & 3, newKind = elementType & 3;
          redefined = oldKind === newKind || oldStatic !== newStatic, redefined || loneAccessors.delete(name);
        } else redefined || loneAccessors.set(name, elementType);
      }
      redefined && this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
        identifierName: name
      }), privateNames.add(name), undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, loc) {
      let classScope;
      for (classScope of this.stack)
        if (classScope.privateNames.has(name)) return;
      classScope ? classScope.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
        identifierName: name
      });
    }
  }
  class ExpressionScope {
    constructor(type2 = 0) {
      this.type = type2;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }
  class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type2) {
      super(type2), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(ParsingErrorClass, at) {
      const index = at.index;
      this.declarationErrors.set(index, [ParsingErrorClass, at]);
    }
    clearDeclarationError(index) {
      this.declarationErrors.delete(index);
    }
    iterateErrors(iterator2) {
      this.declarationErrors.forEach(iterator2);
    }
  }
  class ExpressionScopeHandler {
    constructor(parser2) {
      this.parser = void 0, this.stack = [new ExpressionScope()], this.parser = parser2;
    }
    enter(scope2) {
      this.stack.push(scope2);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(toParseError, node2) {
      const origin = node2.loc.start, {
        stack: stack2
      } = this;
      let i2 = stack2.length - 1, scope2 = stack2[i2];
      for (; !scope2.isCertainlyParameterDeclaration(); ) {
        if (scope2.canBeArrowParameterDeclaration())
          scope2.recordDeclarationError(toParseError, origin);
        else
          return;
        scope2 = stack2[--i2];
      }
      this.parser.raise(toParseError, origin);
    }
    recordArrowParameterBindingError(error2, node2) {
      const {
        stack: stack2
      } = this, scope2 = stack2[stack2.length - 1], origin = node2.loc.start;
      if (scope2.isCertainlyParameterDeclaration())
        this.parser.raise(error2, origin);
      else if (scope2.canBeArrowParameterDeclaration())
        scope2.recordDeclarationError(error2, origin);
      else
        return;
    }
    recordAsyncArrowParametersError(at) {
      const {
        stack: stack2
      } = this;
      let i2 = stack2.length - 1, scope2 = stack2[i2];
      for (; scope2.canBeArrowParameterDeclaration(); )
        scope2.type === 2 && scope2.recordDeclarationError(Errors.AwaitBindingIdentifier, at), scope2 = stack2[--i2];
    }
    validateAsPattern() {
      const {
        stack: stack2
      } = this, currentScope = stack2[stack2.length - 1];
      currentScope.canBeArrowParameterDeclaration() && currentScope.iterateErrors(([toParseError, loc]) => {
        this.parser.raise(toParseError, loc);
        let i2 = stack2.length - 2, scope2 = stack2[i2];
        for (; scope2.canBeArrowParameterDeclaration(); )
          scope2.clearDeclarationError(loc.index), scope2 = stack2[--i2];
      });
    }
  }
  function newParameterDeclarationScope() {
    return new ExpressionScope(3);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(1);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(2);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }
  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }
    enter(flags) {
      this.stacks.push(flags);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  }
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
  }
  class UtilParser extends Tokenizer {
    addExtra(node2, key2, value, enumerable = !0) {
      if (!node2) return;
      const extra = node2.extra = node2.extra || {};
      enumerable ? extra[key2] = value : Object.defineProperty(extra, key2, {
        enumerable,
        value
      });
    }
    isContextual(token2) {
      return this.state.type === token2 && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      if (this.input.slice(nameStart, nameEnd) === name) {
        const nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
    eatContextual(token2) {
      return this.isContextual(token2) ? (this.next(), !0) : !1;
    }
    expectContextual(token2, toParseError) {
      if (!this.eatContextual(token2)) {
        if (toParseError != null)
          throw this.raise(toParseError, this.state.startLoc);
        this.unexpected(null, token2);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return skipWhiteSpaceToLineBreak.lastIndex = this.state.end, skipWhiteSpaceToLineBreak.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = !0) {
      (allowAsi ? this.isLineTerminator() : this.eat(13)) || this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(type2, loc) {
      this.eat(type2) || this.unexpected(loc, type2);
    }
    tryParse(fn2, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };
      try {
        const node2 = fn2((node3 = null) => {
          throw abortSignal.node = node3, abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          return this.state = oldState, this.state.tokensLength = failState.tokensLength, {
            node: node2,
            error: failState.errors[oldState.errors.length],
            thrown: !1,
            aborted: !1,
            failState
          };
        }
        return {
          node: node2,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (error2) {
        const failState = this.state;
        if (this.state = oldState, error2 instanceof SyntaxError)
          return {
            node: null,
            error: error2,
            thrown: !0,
            aborted: !1,
            failState
          };
        if (error2 === abortSignal)
          return {
            node: abortSignal.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState
          };
        throw error2;
      }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return !1;
      const {
        shorthandAssignLoc,
        doubleProtoLoc,
        privateKeyLoc,
        optionalParametersLoc
      } = refExpressionErrors, hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
      if (!andThrow)
        return hasErrors;
      shorthandAssignLoc != null && this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc), doubleProtoLoc != null && this.raise(Errors.DuplicateProto, doubleProtoLoc), privateKeyLoc != null && this.raise(Errors.UnexpectedPrivateField, privateKeyLoc), optionalParametersLoc != null && this.unexpected(optionalParametersLoc);
    }
    isLiteralPropertyName() {
      return tokenIsLiteralPropertyName(this.state.type);
    }
    isPrivateName(node2) {
      return node2.type === "PrivateName";
    }
    getPrivateNameSV(node2) {
      return node2.id.name;
    }
    hasPropertyAsPrivateName(node2) {
      return (node2.type === "MemberExpression" || node2.type === "OptionalMemberExpression") && this.isPrivateName(node2.property);
    }
    isObjectProperty(node2) {
      return node2.type === "ObjectProperty";
    }
    isObjectMethod(node2) {
      return node2.type === "ObjectMethod";
    }
    initializeScopes(inModule = this.options.sourceType === "module") {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope, ScopeHandler2 = this.getScopeHandler();
      this.scope = new ScopeHandler2(this, inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this);
      const oldExpressionScope = this.expressionScope;
      return this.expressionScope = new ExpressionScopeHandler(this), () => {
        this.state.labels = oldLabels, this.exportedIdentifiers = oldExportedIdentifiers, this.inModule = oldInModule, this.scope = oldScope, this.prodParam = oldProdParam, this.classScope = oldClassScope, this.expressionScope = oldExpressionScope;
      };
    }
    enterInitialScopes() {
      let paramFlags = 0;
      this.inModule && (paramFlags |= 2), this.scope.enter(1), this.prodParam.enter(paramFlags);
    }
    checkDestructuringPrivate(refExpressionErrors) {
      const {
        privateKeyLoc
      } = refExpressionErrors;
      privateKeyLoc !== null && this.expectPlugin("destructuringPrivate", privateKeyLoc);
    }
  }
  class ExpressionErrors {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class Node2 {
    constructor(parser2, pos2, loc) {
      this.type = "", this.start = pos2, this.end = 0, this.loc = new SourceLocation(loc), parser2 != null && parser2.options.ranges && (this.range = [pos2, 0]), parser2 != null && parser2.filename && (this.loc.filename = parser2.filename);
    }
  }
  const NodePrototype = Node2.prototype;
  NodePrototype.__clone = function() {
    const newNode = new Node2(void 0, this.start, this.loc.start), keys = Object.keys(this);
    for (let i2 = 0, length = keys.length; i2 < length; i2++) {
      const key2 = keys[i2];
      key2 !== "leadingComments" && key2 !== "trailingComments" && key2 !== "innerComments" && (newNode[key2] = this[key2]);
    }
    return newNode;
  };
  function clonePlaceholder(node2) {
    return cloneIdentifier(node2);
  }
  function cloneIdentifier(node2) {
    const {
      type: type2,
      start,
      end: end2,
      loc,
      range: range2,
      extra,
      name
    } = node2, cloned = Object.create(NodePrototype);
    return cloned.type = type2, cloned.start = start, cloned.end = end2, cloned.loc = loc, cloned.range = range2, cloned.extra = extra, cloned.name = name, type2 === "Placeholder" && (cloned.expectedNode = node2.expectedNode), cloned;
  }
  function cloneStringLiteral(node2) {
    const {
      type: type2,
      start,
      end: end2,
      loc,
      range: range2,
      extra
    } = node2;
    if (type2 === "Placeholder")
      return clonePlaceholder(node2);
    const cloned = Object.create(NodePrototype);
    return cloned.type = type2, cloned.start = start, cloned.end = end2, cloned.loc = loc, cloned.range = range2, node2.raw !== void 0 ? cloned.raw = node2.raw : cloned.extra = extra, cloned.value = node2.value, cloned;
  }
  class NodeUtils extends UtilParser {
    startNode() {
      const loc = this.state.startLoc;
      return new Node2(this, loc.index, loc);
    }
    startNodeAt(loc) {
      return new Node2(this, loc.index, loc);
    }
    startNodeAtNode(type2) {
      return this.startNodeAt(type2.loc.start);
    }
    finishNode(node2, type2) {
      return this.finishNodeAt(node2, type2, this.state.lastTokEndLoc);
    }
    finishNodeAt(node2, type2, endLoc) {
      return node2.type = type2, node2.end = endLoc.index, node2.loc.end = endLoc, this.options.ranges && (node2.range[1] = endLoc.index), this.options.attachComment && this.processComment(node2), node2;
    }
    resetStartLocation(node2, startLoc) {
      node2.start = startLoc.index, node2.loc.start = startLoc, this.options.ranges && (node2.range[0] = startLoc.index);
    }
    resetEndLocation(node2, endLoc = this.state.lastTokEndLoc) {
      node2.end = endLoc.index, node2.loc.end = endLoc, this.options.ranges && (node2.range[1] = endLoc.index);
    }
    resetStartLocationFromNode(node2, locationNode) {
      this.resetStartLocation(node2, locationNode.loc.start);
    }
  }
  const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), FlowErrors = ParseErrorEnum`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({
      reservedType
    }) => `Cannot overwrite reserved type ${reservedType}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({
      memberName,
      enumName
    }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
    EnumDuplicateMemberName: ({
      memberName,
      enumName
    }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
    EnumInconsistentMemberValues: ({
      enumName
    }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({
      invalidEnumType,
      enumName
    }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({
      enumName
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({
      enumName,
      memberName,
      explicitType
    }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({
      enumName,
      memberName
    }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({
      enumName,
      memberName
    }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
    EnumInvalidMemberName: ({
      enumName,
      memberName,
      suggestion
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
    EnumNumberMemberNotInitialized: ({
      enumName,
      memberName
    }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
    EnumStringMemberInconsistentlyInitialized: ({
      enumName
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({
      reservedType
    }) => `Unexpected reserved type ${reservedType}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({
      unsupportedExportKind,
      suggestion
    }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }
  function hasTypeImportKind(node2) {
    return node2.importKind === "type" || node2.importKind === "typeof";
  }
  const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function partition2(list2, test) {
    const list1 = [], list22 = [];
    for (let i2 = 0; i2 < list2.length; i2++)
      (test(list2[i2], i2, list2) ? list1 : list22).push(list2[i2]);
    return [list1, list22];
  }
  const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow2 = (superClass) => class extends superClass {
    constructor(...args) {
      super(...args), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return FlowScopeHandler;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(type2, val) {
      type2 !== 133 && type2 !== 13 && type2 !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(type2, val);
    }
    addComment(comment) {
      if (this.flowPragma === void 0) {
        const matches2 = FLOW_PRAGMA_REGEX.exec(comment.value);
        if (matches2) if (matches2[1] === "flow")
          this.flowPragma = "flow";
        else if (matches2[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(comment);
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = !0, this.expect(tok || 14);
      const type2 = this.flowParseType();
      return this.state.inType = oldInType, type2;
    }
    flowParsePredicate() {
      const node2 = this.startNode(), moduloLoc = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > moduloLoc.index + 1 && this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc), this.eat(10) ? (node2.value = super.parseExpression(), this.expect(11), this.finishNode(node2, "DeclaredPredicate")) : this.finishNode(node2, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let type2 = null, predicate = null;
      return this.match(54) ? (this.state.inType = oldInType, predicate = this.flowParsePredicate()) : (type2 = this.flowParseType(), this.state.inType = oldInType, this.match(54) && (predicate = this.flowParsePredicate())), [type2, predicate];
    }
    flowParseDeclareClass(node2) {
      return this.next(), this.flowParseInterfaceish(node2, !0), this.finishNode(node2, "DeclareClass");
    }
    flowParseDeclareFunction(node2) {
      this.next();
      const id = node2.id = this.parseIdentifier(), typeNode = this.startNode(), typeContainer = this.startNode();
      this.match(47) ? typeNode.typeParameters = this.flowParseTypeParameterDeclaration() : typeNode.typeParameters = null, this.expect(10);
      const tmp2 = this.flowParseFunctionTypeParams();
      return typeNode.params = tmp2.params, typeNode.rest = tmp2.rest, typeNode.this = tmp2._this, this.expect(11), [typeNode.returnType, node2.predicate] = this.flowParseTypeAndPredicateInitialiser(), typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"), id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"), this.resetEndLocation(id), this.semicolon(), this.scope.declareName(node2.id.name, 2048, node2.id.loc.start), this.finishNode(node2, "DeclareFunction");
    }
    flowParseDeclare(node2, insideModule) {
      if (this.match(80))
        return this.flowParseDeclareClass(node2);
      if (this.match(68))
        return this.flowParseDeclareFunction(node2);
      if (this.match(74))
        return this.flowParseDeclareVariable(node2);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(node2) : (insideModule && this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(node2));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(node2);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(node2);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(node2);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(node2, insideModule);
      this.unexpected();
    }
    flowParseDeclareVariable(node2) {
      return this.next(), node2.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(node2.id.name, 5, node2.id.loc.start), this.semicolon(), this.finishNode(node2, "DeclareVariable");
    }
    flowParseDeclareModule(node2) {
      this.scope.enter(0), this.match(133) ? node2.id = super.parseExprAtom() : node2.id = this.parseIdentifier();
      const bodyNode = node2.body = this.startNode(), body = bodyNode.body = [];
      for (this.expect(5); !this.match(8); ) {
        let bodyNode2 = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(bodyNode2)) : (this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule), bodyNode2 = this.flowParseDeclare(bodyNode2, !0)), body.push(bodyNode2);
      }
      this.scope.exit(), this.expect(8), this.finishNode(bodyNode, "BlockStatement");
      let kind = null, hasModuleExport = !1;
      return body.forEach((bodyElement) => {
        isEsModuleType(bodyElement) ? (kind === "CommonJS" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement), kind = "ES") : bodyElement.type === "DeclareModuleExports" && (hasModuleExport && this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement), kind === "ES" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement), kind = "CommonJS", hasModuleExport = !0);
      }), node2.kind = kind || "CommonJS", this.finishNode(node2, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(node2, insideModule) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? node2.declaration = this.flowParseDeclare(this.startNode()) : (node2.declaration = this.flowParseType(), this.semicolon()), node2.default = !0, this.finishNode(node2, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
        const label = this.state.value;
        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: label,
          suggestion: exportSuggestions[label]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return node2.declaration = this.flowParseDeclare(this.startNode()), node2.default = !1, this.finishNode(node2, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return node2 = this.parseExport(node2, null), node2.type === "ExportNamedDeclaration" && (node2.type = "ExportDeclaration", node2.default = !1, delete node2.exportKind), node2.type = "Declare" + node2.type, node2;
      this.unexpected();
    }
    flowParseDeclareModuleExports(node2) {
      return this.next(), this.expectContextual(111), node2.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(node2, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(node2) {
      this.next();
      const finished = this.flowParseTypeAlias(node2);
      return finished.type = "DeclareTypeAlias", finished;
    }
    flowParseDeclareOpaqueType(node2) {
      this.next();
      const finished = this.flowParseOpaqueType(node2, !0);
      return finished.type = "DeclareOpaqueType", finished;
    }
    flowParseDeclareInterface(node2) {
      return this.next(), this.flowParseInterfaceish(node2, !1), this.finishNode(node2, "DeclareInterface");
    }
    flowParseInterfaceish(node2, isClass) {
      if (node2.id = this.flowParseRestrictedIdentifier(!isClass, !0), this.scope.declareName(node2.id.name, isClass ? 17 : 8201, node2.id.loc.start), this.match(47) ? node2.typeParameters = this.flowParseTypeParameterDeclaration() : node2.typeParameters = null, node2.extends = [], this.eat(81))
        do
          node2.extends.push(this.flowParseInterfaceExtends());
        while (!isClass && this.eat(12));
      if (isClass) {
        if (node2.implements = [], node2.mixins = [], this.eatContextual(117))
          do
            node2.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            node2.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      node2.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: !1,
        allowSpread: !1,
        allowProto: isClass,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      const node2 = this.startNode();
      return node2.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? node2.typeParameters = this.flowParseTypeParameterInstantiation() : node2.typeParameters = null, this.finishNode(node2, "InterfaceExtends");
    }
    flowParseInterface(node2) {
      return this.flowParseInterfaceish(node2, !1), this.finishNode(node2, "InterfaceDeclaration");
    }
    checkNotUnderscore(word) {
      word === "_" && this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(word, startLoc, declaration) {
      reservedTypes.has(word) && this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
        reservedType: word
      });
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      return this.checkReservedType(this.state.value, this.state.startLoc, declaration), this.parseIdentifier(liberal);
    }
    flowParseTypeAlias(node2) {
      return node2.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(node2.id.name, 8201, node2.id.loc.start), this.match(47) ? node2.typeParameters = this.flowParseTypeParameterDeclaration() : node2.typeParameters = null, node2.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(node2, "TypeAlias");
    }
    flowParseOpaqueType(node2, declare) {
      return this.expectContextual(130), node2.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(node2.id.name, 8201, node2.id.loc.start), this.match(47) ? node2.typeParameters = this.flowParseTypeParameterDeclaration() : node2.typeParameters = null, node2.supertype = null, this.match(14) && (node2.supertype = this.flowParseTypeInitialiser(14)), node2.impltype = null, declare || (node2.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(node2, "OpaqueType");
    }
    flowParseTypeParameter(requireDefault = !1) {
      const nodeStartLoc = this.state.startLoc, node2 = this.startNode(), variance = this.flowParseVariance(), ident = this.flowParseTypeAnnotatableIdentifier();
      return node2.name = ident.name, node2.variance = variance, node2.bound = ident.typeAnnotation, this.match(29) ? (this.eat(29), node2.default = this.flowParseType()) : requireDefault && this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc), this.finishNode(node2, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType, node2 = this.startNode();
      node2.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let defaultRequired = !1;
      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node2.params.push(typeParameter), typeParameter.default && (defaultRequired = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = oldInType, this.finishNode(node2, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const node2 = this.startNode(), oldInType = this.state.inType;
      node2.params = [], this.state.inType = !0, this.expect(47);
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        node2.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = oldNoAnonFunctionType, this.expect(48), this.state.inType = oldInType, this.finishNode(node2, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const node2 = this.startNode(), oldInType = this.state.inType;
      for (node2.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        node2.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = oldInType, this.finishNode(node2, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const node2 = this.startNode();
      if (this.expectContextual(129), node2.extends = [], this.eat(81))
        do
          node2.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return node2.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(node2, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(node2, isStatic, variance) {
      return node2.static = isStatic, this.lookahead().type === 14 ? (node2.id = this.flowParseObjectPropertyKey(), node2.key = this.flowParseTypeInitialiser()) : (node2.id = null, node2.key = this.flowParseType()), this.expect(3), node2.value = this.flowParseTypeInitialiser(), node2.variance = variance, this.finishNode(node2, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(node2, isStatic) {
      return node2.static = isStatic, node2.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (node2.method = !0, node2.optional = !1, node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start))) : (node2.method = !1, this.eat(17) && (node2.optional = !0), node2.value = this.flowParseTypeInitialiser()), this.finishNode(node2, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(node2) {
      for (node2.params = [], node2.rest = null, node2.typeParameters = null, node2.this = null, this.match(47) && (node2.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (node2.this = this.flowParseFunctionTypeParam(!0), node2.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        node2.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (node2.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), node2.returnType = this.flowParseTypeInitialiser(), this.finishNode(node2, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(node2, isStatic) {
      const valueNode = this.startNode();
      return node2.static = isStatic, node2.value = this.flowParseObjectTypeMethodish(valueNode), this.finishNode(node2, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = !0;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [], nodeStart.properties = [], nodeStart.indexers = [], nodeStart.internalSlots = [];
      let endDelim, exact, inexact = !1;
      for (allowExact && this.match(6) ? (this.expect(6), endDelim = 9, exact = !0) : (this.expect(5), endDelim = 8, exact = !1), nodeStart.exact = exact; !this.match(endDelim); ) {
        let isStatic = !1, protoStartLoc = null, inexactStartLoc = null;
        const node2 = this.startNode();
        if (allowProto && this.isContextual(118)) {
          const lookahead = this.lookahead();
          lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), protoStartLoc = this.state.startLoc, allowStatic = !1);
        }
        if (allowStatic && this.isContextual(106)) {
          const lookahead = this.lookahead();
          lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), isStatic = !0);
        }
        const variance = this.flowParseVariance();
        if (this.eat(0))
          protoStartLoc != null && this.unexpected(protoStartLoc), this.eat(0) ? (variance && this.unexpected(variance.loc.start), nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node2, isStatic))) : nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node2, isStatic, variance));
        else if (this.match(10) || this.match(47))
          protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node2, isStatic));
        else {
          let kind = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            const lookahead = this.lookahead();
            tokenIsLiteralPropertyName(lookahead.type) && (kind = this.state.value, this.next());
          }
          const propOrInexact = this.flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact ?? !exact);
          propOrInexact === null ? (inexact = !0, inexactStartLoc = this.state.lastTokStartLoc) : nodeStart.properties.push(propOrInexact);
        }
        this.flowObjectTypeSemicolon(), inexactStartLoc && !this.match(8) && !this.match(9) && this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
      }
      this.expect(endDelim), allowSpread && (nodeStart.inexact = inexact);
      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      return this.state.inType = oldInType, out;
    }
    flowParseObjectTypeProperty(node2, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (allowSpread ? allowInexact || this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc), variance && this.raise(FlowErrors.InexactVariance, variance), null) : (allowSpread || this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc), protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.raise(FlowErrors.SpreadVariance, variance), node2.argument = this.flowParseType(), this.finishNode(node2, "ObjectTypeSpreadProperty"));
      {
        node2.key = this.flowParseObjectPropertyKey(), node2.static = isStatic, node2.proto = protoStartLoc != null, node2.kind = kind;
        let optional = !1;
        return this.match(47) || this.match(10) ? (node2.method = !0, protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), node2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node2.loc.start)), (kind === "get" || kind === "set") && this.flowCheckGetterSetterParams(node2), !allowSpread && node2.key.name === "constructor" && node2.value.this && this.raise(FlowErrors.ThisParamBannedInConstructor, node2.value.this)) : (kind !== "init" && this.unexpected(), node2.method = !1, this.eat(17) && (optional = !0), node2.value = this.flowParseTypeInitialiser(), node2.variance = variance), node2.optional = optional, this.finishNode(node2, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === "get" ? 0 : 1, length = property.value.params.length + (property.value.rest ? 1 : 0);
      property.value.this && this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this), length !== paramCount && this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property), property.kind === "set" && property.value.rest && this.raise(Errors.BadSetterRestParameter, property);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(startLoc, id) {
      var _startLoc;
      (_startLoc = startLoc) != null || (startLoc = this.state.startLoc);
      let node2 = id || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        const node22 = this.startNodeAt(startLoc);
        node22.qualification = node2, node22.id = this.flowParseRestrictedIdentifier(!0), node2 = this.finishNode(node22, "QualifiedTypeIdentifier");
      }
      return node2;
    }
    flowParseGenericType(startLoc, id) {
      const node2 = this.startNodeAt(startLoc);
      return node2.typeParameters = null, node2.id = this.flowParseQualifiedTypeIdentifier(startLoc, id), this.match(47) && (node2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(node2, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const node2 = this.startNode();
      return this.expect(87), node2.argument = this.flowParsePrimaryType(), this.finishNode(node2, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const node2 = this.startNode();
      for (node2.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (node2.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(node2, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(first2) {
      let name = null, optional = !1, typeAnnotation = null;
      const node2 = this.startNode(), lh = this.lookahead(), isThis = this.state.type === 78;
      return lh.type === 14 || lh.type === 17 ? (isThis && !first2 && this.raise(FlowErrors.ThisParamMustBeFirst, node2), name = this.parseIdentifier(isThis), this.eat(17) && (optional = !0, isThis && this.raise(FlowErrors.ThisParamMayNotBeOptional, node2)), typeAnnotation = this.flowParseTypeInitialiser()) : typeAnnotation = this.flowParseType(), node2.name = name, node2.optional = optional, node2.typeAnnotation = typeAnnotation, this.finishNode(node2, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(type2) {
      const node2 = this.startNodeAt(type2.loc.start);
      return node2.name = null, node2.optional = !1, node2.typeAnnotation = type2, this.finishNode(node2, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null, _this = null;
      for (this.match(78) && (_this = this.flowParseFunctionTypeParam(!0), _this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (rest = this.flowParseFunctionTypeParam(!1)), {
        params,
        rest,
        _this
      };
    }
    flowIdentToTypeAnnotation(startLoc, node2, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node2, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node2, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node2, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node2, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node2, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node2, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(node2, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(id.name), this.flowParseGenericType(startLoc, id);
      }
    }
    flowParsePrimaryType() {
      const startLoc = this.state.startLoc, node2 = this.startNode();
      let tmp2, type2, isGroupedType = !1;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, type2 = this.flowParseTupleType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, type2;
        case 47: {
          const node3 = this.startNode();
          return node3.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), tmp2 = this.flowParseFunctionTypeParams(), node3.params = tmp2.params, node3.rest = tmp2.rest, node3.this = tmp2._this, this.expect(11), this.expect(19), node3.returnType = this.flowParseType(), this.finishNode(node3, "FunctionTypeAnnotation");
        }
        case 10: {
          const node3 = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
              const token2 = this.lookahead().type;
              isGroupedType = token2 !== 17 && token2 !== 14;
            } else
              isGroupedType = !0;
          if (isGroupedType) {
            if (this.state.noAnonFunctionType = !1, type2 = this.flowParseType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), type2;
            this.eat(12);
          }
          return type2 ? tmp2 = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type2)]) : tmp2 = this.flowParseFunctionTypeParams(), node3.params = tmp2.params, node3.rest = tmp2.rest, node3.this = tmp2._this, this.expect(11), this.expect(19), node3.returnType = this.flowParseType(), node3.typeParameters = null, this.finishNode(node3, "FunctionTypeAnnotation");
        }
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return node2.value = this.match(85), this.next(), this.finishNode(node2, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node2);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node2);
            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(node2, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(node2, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(node2, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(node2, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (tokenIsKeyword(this.state.type)) {
            const label = tokenLabelName(this.state.type);
            return this.next(), super.createIdentifier(node2, label);
          } else if (tokenIsIdentifier(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(startLoc, node2, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const startLoc = this.state.startLoc;
      let type2 = this.flowParsePrimaryType(), seenOptionalIndexedAccess = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const node2 = this.startNodeAt(startLoc), optional = this.eat(18);
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional, this.expect(0), !optional && this.match(3) ? (node2.elementType = type2, this.next(), type2 = this.finishNode(node2, "ArrayTypeAnnotation")) : (node2.objectType = type2, node2.indexType = this.flowParseType(), this.expect(3), seenOptionalIndexedAccess ? (node2.optional = optional, type2 = this.finishNode(node2, "OptionalIndexedAccessType")) : type2 = this.finishNode(node2, "IndexedAccessType"));
      }
      return type2;
    }
    flowParsePrefixType() {
      const node2 = this.startNode();
      return this.eat(17) ? (node2.typeAnnotation = this.flowParsePrefixType(), this.finishNode(node2, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const node2 = this.startNodeAt(param.loc.start);
        return node2.params = [this.reinterpretTypeAsFunctionTypeParam(param)], node2.rest = null, node2.this = null, node2.returnType = this.flowParseType(), node2.typeParameters = null, this.finishNode(node2, "FunctionTypeAnnotation");
      }
      return param;
    }
    flowParseIntersectionType() {
      const node2 = this.startNode();
      this.eat(45);
      const type2 = this.flowParseAnonFunctionWithoutParens();
      for (node2.types = [type2]; this.eat(45); )
        node2.types.push(this.flowParseAnonFunctionWithoutParens());
      return node2.types.length === 1 ? type2 : this.finishNode(node2, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const node2 = this.startNode();
      this.eat(43);
      const type2 = this.flowParseIntersectionType();
      for (node2.types = [type2]; this.eat(43); )
        node2.types.push(this.flowParseIntersectionType());
      return node2.types.length === 1 ? type2 : this.finishNode(node2, "UnionTypeAnnotation");
    }
    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = !0;
      const type2 = this.flowParseUnionType();
      return this.state.inType = oldInType, type2;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        const startLoc = this.state.startLoc, node2 = this.parseIdentifier();
        return this.flowParseGenericType(startLoc, node2);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const node2 = this.startNode();
      return node2.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(node2, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (ident.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(ident)), ident;
    }
    typeCastToParameter(node2) {
      return node2.expression.typeAnnotation = node2.typeAnnotation, this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end), node2.expression;
    }
    flowParseVariance() {
      let variance = null;
      return this.match(53) ? (variance = this.startNode(), this.state.value === "+" ? variance.kind = "plus" : variance.kind = "minus", this.next(), this.finishNode(variance, "Variance")) : variance;
    }
    parseFunctionBody(node2, allowExpressionBody, isMethod = !1) {
      if (allowExpressionBody) {
        this.forwardNoArrowParamsConversionAt(node2, () => super.parseFunctionBody(node2, !0, isMethod));
        return;
      }
      super.parseFunctionBody(node2, !1, isMethod);
    }
    parseFunctionBodyAndFinish(node2, type2, isMethod = !1) {
      if (this.match(14)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser(), node2.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(node2, type2, isMethod);
    }
    parseStatementLike(flags) {
      if (this.state.strict && this.isContextual(129)) {
        const lookahead = this.lookahead();
        if (tokenIsKeywordOrIdentifier(lookahead.type)) {
          const node2 = this.startNode();
          return this.next(), this.flowParseInterface(node2);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        const node2 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(node2);
      }
      const stmt = super.parseStatementLike(flags);
      return this.flowPragma === void 0 && !this.isValidDirective(stmt) && (this.flowPragma = null), stmt;
    }
    parseExpressionStatement(node2, expr, decorators) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(node2);
        } else if (tokenIsIdentifier(this.state.type)) {
          if (expr.name === "interface")
            return this.flowParseInterface(node2);
          if (expr.name === "type")
            return this.flowParseTypeAlias(node2);
          if (expr.name === "opaque")
            return this.flowParseOpaqueType(node2, !1);
        }
      }
      return super.parseExpressionStatement(node2, expr, decorators);
    }
    shouldParseExportDeclaration() {
      const {
        type: type2
      } = this.state;
      return tokenIsFlowInterfaceOrTypeOrOpaque(type2) || this.shouldParseEnums() && type2 === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const {
        type: type2
      } = this.state;
      return tokenIsFlowInterfaceOrTypeOrOpaque(type2) || this.shouldParseEnums() && type2 === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        const node2 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(node2);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.match(17)) return expr;
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode();
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41)
          return this.setOptionalParametersError(refExpressionErrors), expr;
      }
      this.expect(17);
      const state2 = this.state.clone(), originalNoArrowAt = this.state.noArrowAt, node2 = this.startNodeAt(startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent(), [valid, invalid] = this.getArrowLikeExpressions(consequent);
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];
        if (invalid.length > 0) {
          this.state = state2, this.state.noArrowAt = noArrowAt;
          for (let i2 = 0; i2 < invalid.length; i2++)
            noArrowAt.push(invalid[i2].start);
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent()), [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }
        failed && valid.length > 1 && this.raise(FlowErrors.AmbiguousConditionalArrow, state2.startLoc), failed && valid.length === 1 && (this.state = state2, noArrowAt.push(valid[0].start), this.state.noArrowAt = noArrowAt, {
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(consequent, !0), this.state.noArrowAt = originalNoArrowAt, this.expect(14), node2.test = expr, node2.consequent = consequent, node2.alternate = this.forwardNoArrowParamsConversionAt(node2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(node2, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn(), failed = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent,
        failed
      };
    }
    getArrowLikeExpressions(node2, disallowInvalid) {
      const stack2 = [node2], arrows = [];
      for (; stack2.length !== 0; ) {
        const node3 = stack2.pop();
        node3.type === "ArrowFunctionExpression" && node3.body.type !== "BlockStatement" ? (node3.typeParameters || !node3.returnType ? this.finishArrowValidation(node3) : arrows.push(node3), stack2.push(node3.body)) : node3.type === "ConditionalExpression" && (stack2.push(node3.consequent), stack2.push(node3.alternate));
      }
      return disallowInvalid ? (arrows.forEach((node3) => this.finishArrowValidation(node3)), [arrows, []]) : partition2(arrows, (node3) => node3.params.every((param) => this.isAssignable(param, !0)));
    }
    finishArrowValidation(node2) {
      var _node$extra;
      this.toAssignableList(node2.params, (_node$extra = node2.extra) == null ? void 0 : _node$extra.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(node2, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(node2, parse4) {
      let result;
      return this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), result = parse4(), this.state.noArrowParamsConversionAt.pop()) : result = parse4(), result;
    }
    parseParenItem(node2, startLoc) {
      const newNode = super.parseParenItem(node2, startLoc);
      if (this.eat(17) && (newNode.optional = !0, this.resetEndLocation(node2)), this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        return typeCastNode.expression = newNode, typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(typeCastNode, "TypeCastExpression");
      }
      return newNode;
    }
    assertModuleNodeAllowed(node2) {
      node2.type === "ImportDeclaration" && (node2.importKind === "type" || node2.importKind === "typeof") || node2.type === "ExportNamedDeclaration" && node2.exportKind === "type" || node2.type === "ExportAllDeclaration" && node2.exportKind === "type" || super.assertModuleNodeAllowed(node2);
    }
    parseExportDeclaration(node2) {
      if (this.isContextual(130)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        return this.next(), this.match(5) ? (node2.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(node2), null) : this.flowParseTypeAlias(declarationNode);
      } else if (this.isContextual(131)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        return this.next(), this.flowParseOpaqueType(declarationNode, !1);
      } else if (this.isContextual(129)) {
        node2.exportKind = "type";
        const declarationNode = this.startNode();
        return this.next(), this.flowParseInterface(declarationNode);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        node2.exportKind = "value";
        const declarationNode = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(declarationNode);
      } else
        return super.parseExportDeclaration(node2);
    }
    eatExportStar(node2) {
      return super.eatExportStar(node2) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (node2.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(node2) {
      const {
        startLoc
      } = this.state, hasNamespace = super.maybeParseExportNamespaceSpecifier(node2);
      return hasNamespace && node2.exportKind === "type" && this.unexpected(startLoc), hasNamespace;
    }
    parseClassId(node2, isStatement, optionalId) {
      super.parseClassId(node2, isStatement, optionalId), this.match(47) && (node2.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(classBody, member, state2) {
      const {
        startLoc
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(classBody, member))
          return;
        member.declare = !0;
      }
      super.parseClassMember(classBody, member, state2), member.declare && (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition" ? this.raise(FlowErrors.DeclareClassElement, startLoc) : member.value && this.raise(FlowErrors.DeclareClassFieldInitializer, member.value));
    }
    isIterator(word) {
      return word === "iterator" || word === "asyncIterator";
    }
    readIterator() {
      const word = super.readWord1(), fullWord = "@@" + word;
      (!this.isIterator(word) || !this.state.inType) && this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
        identifierName: fullWord
      }), this.finishToken(132, fullWord);
    }
    getTokenFromCode(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      code2 === 123 && next === 124 ? this.finishOp(6, 2) : this.state.inType && (code2 === 62 || code2 === 60) ? this.finishOp(code2 === 62 ? 48 : 47, 1) : this.state.inType && code2 === 63 ? next === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(code2);
    }
    isAssignable(node2, isBinding) {
      return node2.type === "TypeCastExpression" ? this.isAssignable(node2.expression, isBinding) : super.isAssignable(node2, isBinding);
    }
    toAssignable(node2, isLHS = !1) {
      !isLHS && node2.type === "AssignmentExpression" && node2.left.type === "TypeCastExpression" && (node2.left = this.typeCastToParameter(node2.left)), super.toAssignable(node2, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i2 = 0; i2 < exprList.length; i2++) {
        const expr = exprList[i2];
        expr?.type === "TypeCastExpression" && (exprList[i2] = this.typeCastToParameter(expr));
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i2 = 0; i2 < exprList.length; i2++) {
        var _expr$extra;
        const expr = exprList[i2];
        expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr) && this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
      }
      return exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      return canBePattern && !this.state.maybeInArrowParameters && this.toReferencedList(node2.elements), node2;
    }
    isValidLVal(type2, isParenthesized, binding) {
      return type2 === "TypeCastExpression" || super.isValidLVal(type2, isParenthesized, binding);
    }
    parseClassProperty(node2) {
      return this.match(14) && (node2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(node2);
    }
    parseClassPrivateProperty(node2) {
      return this.match(14) && (node2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(node2);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(method) {
      return !this.match(14) && super.isNonstaticConstructor(method);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper), method.params && isConstructor) {
        const params = method.params;
        params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, method);
      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
        const params = method.value.params;
        params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, method);
      }
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    parseClassSuper(node2) {
      if (super.parseClassSuper(node2), node2.superClass && this.match(47) && (node2.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        const implemented = node2.implements = [];
        do {
          const node3 = this.startNode();
          node3.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? node3.typeParameters = this.flowParseTypeParameterInstantiation() : node3.typeParameters = null, implemented.push(this.finishNode(node3, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length > 0) {
        const param = params[0];
        this.isThisParam(param) && method.kind === "get" ? this.raise(FlowErrors.GetterMayNotHaveThisParam, param) : this.isThisParam(param) && this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
      }
    }
    parsePropertyNamePrefixOperator(node2) {
      node2.variance = this.flowParseVariance();
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      prop.variance && this.unexpected(prop.variance.loc.start), delete prop.variance;
      let typeParameters;
      this.match(47) && !isAccessor && (typeParameters = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return typeParameters && ((result.value || result).typeParameters = typeParameters), result;
    }
    parseAssignableListItemTypes(param) {
      return this.eat(17) && (param.type !== "Identifier" && this.raise(FlowErrors.PatternIsOptional, param), this.isThisParam(param) && this.raise(FlowErrors.ThisParamMayNotBeOptional, param), param.optional = !0), this.match(14) ? param.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(param) && this.raise(FlowErrors.ThisParamAnnotationRequired, param), this.match(29) && this.isThisParam(param) && this.raise(FlowErrors.ThisParamNoDefault, param), this.resetEndLocation(param), param;
    }
    parseMaybeDefault(startLoc, left2) {
      const node2 = super.parseMaybeDefault(startLoc, left2);
      return node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start && this.raise(FlowErrors.TypeBeforeInitializer, node2.typeAnnotation), node2;
    }
    checkImportReflection(node2) {
      super.checkImportReflection(node2), node2.module && node2.importKind !== "value" && this.raise(FlowErrors.ImportReflectionHasImportType, node2.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(node2, specifier, type2) {
      specifier.local = hasTypeImportKind(node2) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), node2.specifiers.push(this.finishImportSpecifier(specifier, type2));
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport)) return !0;
      if (this.isContextual(130)) {
        if (!isExport) return !0;
        const ch = this.lookaheadCharCode();
        return ch === 123 || ch === 42;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      if (super.applyImportPhase(node2, isExport, phase, loc), isExport) {
        if (!phase && this.match(65))
          return;
        node2.exportKind = phase === "type" ? phase : "value";
      } else
        phase === "type" && this.match(55) && this.unexpected(), node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      const firstIdent = specifier.imported;
      let specifierTypeKind = null;
      firstIdent.type === "Identifier" && (firstIdent.name === "type" ? specifierTypeKind = "type" : firstIdent.name === "typeof" && (specifierTypeKind = "typeof"));
      let isBinding = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(!0);
        specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type) ? (specifier.imported = as_ident, specifier.importKind = specifierTypeKind, specifier.local = cloneIdentifier(as_ident)) : (specifier.imported = firstIdent, specifier.importKind = null, specifier.local = this.parseIdentifier());
      } else {
        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type))
          specifier.imported = this.parseIdentifier(!0), specifier.importKind = specifierTypeKind;
        else {
          if (importedIsString)
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: firstIdent.value
            });
          specifier.imported = firstIdent, specifier.importKind = null;
        }
        this.eatContextual(93) ? specifier.local = this.parseIdentifier() : (isBinding = !0, specifier.local = cloneIdentifier(specifier.imported));
      }
      const specifierIsTypeImport = hasTypeImportKind(specifier);
      return isInTypeOnlyImport && specifierIsTypeImport && this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier), (isInTypeOnlyImport || specifierIsTypeImport) && this.checkReservedType(specifier.local.name, specifier.local.loc.start, !0), isBinding && !isInTypeOnlyImport && !specifierIsTypeImport && this.checkReservedWord(specifier.local.name, specifier.loc.start, !0, !0), this.finishImportSpecifier(specifier, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(node2, isConstructor) {
      const kind = node2.kind;
      kind !== "get" && kind !== "set" && this.match(47) && (node2.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(node2, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind), this.match(14) && (decl.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(decl.id));
    }
    parseAsyncArrowFromCallExpression(node2, call2) {
      if (this.match(14)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, node2.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
      return super.parseAsyncArrowFromCallExpression(node2, call2);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx;
      let state2 = null, jsx3;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (state2 = this.state.clone(), jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state2), !jsx3.error) return jsx3.node;
        const {
          context
        } = this.state, currentContext = context[context.length - 1];
        (currentContext === types2.j_oTag || currentContext === types2.j_expr) && context.pop();
      }
      if ((_jsx = jsx3) != null && _jsx.error || this.match(47)) {
        var _jsx2, _jsx3;
        state2 = state2 || this.state.clone();
        let typeParameters;
        const arrow4 = this.tryParse((abort) => {
          var _arrowExpression$extr;
          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            return this.resetStartLocationFromNode(result, typeParameters), result;
          });
          (_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized && abort();
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
          return expr.type !== "ArrowFunctionExpression" && abort(), expr.typeParameters = typeParameters, this.resetStartLocationFromNode(expr, typeParameters), arrowExpression2;
        }, state2);
        let arrowExpression = null;
        if (arrow4.node && this.maybeUnwrapTypeCastExpression(arrow4.node).type === "ArrowFunctionExpression") {
          if (!arrow4.error && !arrow4.aborted)
            return arrow4.node.async && this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters), arrow4.node;
          arrowExpression = arrow4.node;
        }
        if ((_jsx2 = jsx3) != null && _jsx2.node)
          return this.state = jsx3.failState, jsx3.node;
        if (arrowExpression)
          return this.state = arrow4.failState, arrowExpression;
        throw (_jsx3 = jsx3) != null && _jsx3.thrown ? jsx3.error : arrow4.thrown ? arrow4.error : this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          const typeNode = this.startNode();
          return [typeNode.typeAnnotation, node2.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), typeNode;
        });
        if (result.thrown) return null;
        result.error && (this.state = result.failState), node2.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(node2);
    }
    shouldParseArrow(params) {
      return this.match(14) || super.shouldParseArrow(params);
    }
    setArrowFunctionParameters(node2, params) {
      this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1 ? node2.params = params : super.setArrowFunctionParameters(node2, params);
    }
    checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
      if (!(isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node2.start) !== -1)) {
        for (let i2 = 0; i2 < node2.params.length; i2++)
          this.isThisParam(node2.params[i2]) && i2 > 0 && this.raise(FlowErrors.ThisParamMustBeFirst, node2.params[i2]);
        super.checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged);
      }
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(base2, startLoc, noCalls) {
      if (base2.type === "Identifier" && base2.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
        this.next();
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base2, node2.arguments = super.parseCallExpressionArguments(11, !1), base2 = this.finishNode(node2, "CallExpression");
      } else if (base2.type === "Identifier" && base2.name === "async" && this.match(47)) {
        const state2 = this.state.clone(), arrow4 = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state2);
        if (!arrow4.error && !arrow4.aborted) return arrow4.node;
        const result = this.tryParse(() => super.parseSubscripts(base2, startLoc, noCalls), state2);
        if (result.node && !result.error) return result.node;
        if (arrow4.node)
          return this.state = arrow4.failState, arrow4.node;
        if (result.node)
          return this.state = result.failState, result.node;
        throw arrow4.error || result.error;
      }
      return super.parseSubscripts(base2, startLoc, noCalls);
    }
    parseSubscript(base2, startLoc, noCalls, subscriptState) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (subscriptState.optionalChainMember = !0, noCalls)
          return subscriptState.stop = !0, base2;
        this.next();
        const node2 = this.startNodeAt(startLoc);
        return node2.callee = base2, node2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), node2.arguments = this.parseCallExpressionArguments(11, !1), node2.optional = !0, this.finishCallExpression(node2, !0);
      } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
        const node2 = this.startNodeAt(startLoc);
        node2.callee = base2;
        const result = this.tryParse(() => (node2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), node2.arguments = super.parseCallExpressionArguments(11, !1), subscriptState.optionalChainMember && (node2.optional = !1), this.finishCallExpression(node2, subscriptState.optionalChainMember)));
        if (result.node)
          return result.error && (this.state = result.failState), result.node;
      }
      return super.parseSubscript(base2, startLoc, noCalls, subscriptState);
    }
    parseNewCallee(node2) {
      super.parseNewCallee(node2);
      let targs = null;
      this.shouldParseTypes() && this.match(47) && (targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), node2.typeArguments = targs;
    }
    parseAsyncArrowWithTypeParameters(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      if (this.parseFunctionParams(node2, !1), !!this.parseArrow(node2))
        return super.parseArrowExpression(node2, void 0, !0);
    }
    readToken_mult_modulo(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(code2);
    }
    readToken_pipe_amp(code2) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code2 === 124 && next === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(code2);
    }
    parseTopLevel(file2, program) {
      const fileNode = super.parseTopLevel(file2, program);
      return this.state.hasFlowComment && this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition()), fileNode;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const commentSkip = this.skipFlowComment();
        commentSkip && (this.state.pos += commentSkip, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      const {
        pos: pos2
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;
      for (; [32, 9].includes(this.input.charCodeAt(pos2 + shiftToFirstNonWhiteSpace)); )
        shiftToFirstNonWhiteSpace++;
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos2), ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos2 + 1);
      return ch2 === 58 && ch3 === 58 ? shiftToFirstNonWhiteSpace + 2 : this.input.slice(shiftToFirstNonWhiteSpace + pos2, shiftToFirstNonWhiteSpace + pos2 + 12) === "flow-include" ? shiftToFirstNonWhiteSpace + 12 : ch2 === 58 && ch3 !== 58 ? shiftToFirstNonWhiteSpace : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(loc, {
      enumName,
      memberName
    }) {
      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
        memberName,
        enumName
      });
    }
    flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
      return this.raise(enumContext.explicitType ? enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType : FlowErrors.EnumInvalidMemberInitializerUnknownType, loc, enumContext);
    }
    flowEnumErrorNumberMemberNotInitialized(loc, details) {
      this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(node2, details) {
      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node2, details);
    }
    flowEnumMemberInit() {
      const startLoc = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          const literal2 = this.parseNumericLiteral(this.state.value);
          return endOfInit() ? {
            type: "number",
            loc: literal2.loc.start,
            value: literal2
          } : {
            type: "invalid",
            loc: startLoc
          };
        }
        case 133: {
          const literal2 = this.parseStringLiteral(this.state.value);
          return endOfInit() ? {
            type: "string",
            loc: literal2.loc.start,
            value: literal2
          } : {
            type: "invalid",
            loc: startLoc
          };
        }
        case 85:
        case 86: {
          const literal2 = this.parseBooleanLiteral(this.match(85));
          return endOfInit() ? {
            type: "boolean",
            loc: literal2.loc.start,
            value: literal2
          } : {
            type: "invalid",
            loc: startLoc
          };
        }
        default:
          return {
            type: "invalid",
            loc: startLoc
          };
      }
    }
    flowEnumMemberRaw() {
      const loc = this.state.startLoc, id = this.parseIdentifier(!0), init = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc
      };
      return {
        id,
        init
      };
    }
    flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
      const {
        explicitType
      } = context;
      explicitType !== null && explicitType !== expectedType && this.flowEnumErrorInvalidMemberInitializer(loc, context);
    }
    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = /* @__PURE__ */ new Set(), members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let hasUnknownMembers = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          hasUnknownMembers = !0;
          break;
        }
        const memberNode = this.startNode(), {
          id,
          init
        } = this.flowEnumMemberRaw(), memberName = id.name;
        if (memberName === "")
          continue;
        /^[a-z]/.test(memberName) && this.raise(FlowErrors.EnumInvalidMemberName, id, {
          memberName,
          suggestion: memberName[0].toUpperCase() + memberName.slice(1),
          enumName
        }), seenNames.has(memberName) && this.raise(FlowErrors.EnumDuplicateMemberName, id, {
          memberName,
          enumName
        }), seenNames.add(memberName);
        const context = {
          enumName,
          explicitType,
          memberName
        };
        switch (memberNode.id = id, init.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean"), memberNode.init = init.value, members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number"), memberNode.init = init.value, members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string"), memberNode.init = init.value, members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
          case "none":
            switch (explicitType) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                break;
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members,
        hasUnknownMembers
      };
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0)
        return defaultedMembers;
      if (defaultedMembers.length === 0)
        return initializedMembers;
      if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        return defaultedMembers;
      } else {
        for (const member of defaultedMembers)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
            enumName
          });
        return initializedMembers;
      }
    }
    flowEnumParseExplicitType({
      enumName
    }) {
      if (!this.eatContextual(102)) return null;
      if (!tokenIsIdentifier(this.state.type))
        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName
        });
      const {
        value
      } = this.state;
      return this.next(), value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol" && this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
        enumName,
        invalidEnumType: value
      }), value;
    }
    flowEnumBody(node2, id) {
      const enumName = id.name, nameLoc = id.loc.start, explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(5);
      const {
        members,
        hasUnknownMembers
      } = this.flowEnumMembers({
        enumName,
        explicitType
      });
      switch (node2.hasUnknownMembers = hasUnknownMembers, explicitType) {
        case "boolean":
          return node2.explicitType = !0, node2.members = members.booleanMembers, this.expect(8), this.finishNode(node2, "EnumBooleanBody");
        case "number":
          return node2.explicitType = !0, node2.members = members.numberMembers, this.expect(8), this.finishNode(node2, "EnumNumberBody");
        case "string":
          return node2.explicitType = !0, node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          }), this.expect(8), this.finishNode(node2, "EnumStringBody");
        case "symbol":
          return node2.members = members.defaultedMembers, this.expect(8), this.finishNode(node2, "EnumSymbolBody");
        default: {
          const empty2 = () => (node2.members = [], this.expect(8), this.finishNode(node2, "EnumStringBody"));
          node2.explicitType = !1;
          const boolsLen = members.booleanMembers.length, numsLen = members.numberMembers.length, strsLen = members.stringMembers.length, defaultedLen = members.defaultedMembers.length;
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen)
            return empty2();
          if (!boolsLen && !numsLen)
            return node2.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            }), this.expect(8), this.finishNode(node2, "EnumStringBody");
          if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            return node2.members = members.booleanMembers, this.expect(8), this.finishNode(node2, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                enumName,
                memberName: member.id.name
              });
            return node2.members = members.numberMembers, this.expect(8), this.finishNode(node2, "EnumNumberBody");
          } else
            return this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
              enumName
            }), empty2();
        }
      }
    }
    flowParseEnumDeclaration(node2) {
      const id = this.parseIdentifier();
      return node2.id = id, node2.body = this.flowEnumBody(this.startNode(), id), this.finishNode(node2, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart();
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(node2) {
      return node2.type === "TypeCastExpression" ? node2.expression : node2;
    }
  };
  const entities = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({
      openingTagName
    }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({
      unexpected,
      HTMLEntity
    }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : !1;
  }
  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier")
      return object.name;
    if (object.type === "JSXNamespacedName")
      return object.namespace.name + ":" + object.name.name;
    if (object.type === "JSXMemberExpression")
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    throw new Error("Node had unexpected type: " + object.type);
  }
  var jsx2 = (superClass) => class extends superClass {
    jsxReadToken() {
      let out = "", chunkStart = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              ch === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(ch);
              return;
            }
            out += this.input.slice(chunkStart, this.state.pos), this.finishToken(141, out);
            return;
          case 38:
            out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!0), chunkStart = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      return ++this.state.pos, ch === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, out = normalizeCRLF ? `
` : `\r
`) : out = String.fromCharCode(ch), ++this.state.curLine, this.state.lineStart = this.state.pos, out;
    }
    jsxReadString(quote) {
      let out = "", chunkStart = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Errors.UnterminatedString, this.state.startLoc);
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;
        ch === 38 ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos) : isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!1), chunkStart = this.state.pos) : ++this.state.pos;
      }
      out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(133, out);
    }
    jsxReadEntity() {
      const startPos = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let radix = 10;
        this.codePointAtPos(this.state.pos) === 120 && (radix = 16, ++this.state.pos);
        const codePoint = this.readInt(radix, void 0, !1, "bail");
        if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(codePoint);
      } else {
        let count2 = 0, semi = !1;
        for (; count2++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (semi) {
          const desc = this.input.slice(startPos, this.state.pos), entity = entities[desc];
          if (++this.state.pos, entity)
            return entity;
        }
      }
      return this.state.pos = startPos, "&";
    }
    jsxReadWord() {
      let ch;
      const start = this.state.pos;
      do
        ch = this.input.charCodeAt(++this.state.pos);
      while (isIdentifierChar(ch) || ch === 45);
      this.finishToken(140, this.input.slice(start, this.state.pos));
    }
    jsxParseIdentifier() {
      const node2 = this.startNode();
      return this.match(140) ? node2.name = this.state.value : tokenIsKeyword(this.state.type) ? node2.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(node2, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const startLoc = this.state.startLoc, name = this.jsxParseIdentifier();
      if (!this.eat(14)) return name;
      const node2 = this.startNodeAt(startLoc);
      return node2.namespace = name, node2.name = this.jsxParseIdentifier(), this.finishNode(node2, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const startLoc = this.state.startLoc;
      let node2 = this.jsxParseNamespacedName();
      if (node2.type === "JSXNamespacedName")
        return node2;
      for (; this.eat(16); ) {
        const newNode = this.startNodeAt(startLoc);
        newNode.object = node2, newNode.property = this.jsxParseIdentifier(), node2 = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node2;
    }
    jsxParseAttributeValue() {
      let node2;
      switch (this.state.type) {
        case 5:
          return node2 = this.startNode(), this.setContext(types2.brace), this.next(), node2 = this.jsxParseExpressionContainer(node2, types2.j_oTag), node2.expression.type === "JSXEmptyExpression" && this.raise(JsxErrors.AttributeIsEmpty, node2), node2;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const node2 = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(node2, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(node2) {
      return this.next(), node2.expression = this.parseExpression(), this.setContext(types2.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node2, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(node2, previousContext) {
      if (this.match(8))
        node2.expression = this.jsxParseEmptyExpression();
      else {
        const expression = this.parseExpression();
        node2.expression = expression;
      }
      return this.setContext(previousContext), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node2, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const node2 = this.startNode();
      return this.match(5) ? (this.setContext(types2.brace), this.next(), this.expect(21), node2.argument = this.parseMaybeAssignAllowIn(), this.setContext(types2.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node2, "JSXSpreadAttribute")) : (node2.name = this.jsxParseNamespacedName(), node2.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(node2, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      return this.eat(143) ? this.finishNode(node2, "JSXOpeningFragment") : (node2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(node2));
    }
    jsxParseOpeningElementAfterName(node2) {
      const attributes = [];
      for (; !this.match(56) && !this.match(143); )
        attributes.push(this.jsxParseAttribute());
      return node2.attributes = attributes, node2.selfClosing = this.eat(56), this.expect(143), this.finishNode(node2, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      return this.eat(143) ? this.finishNode(node2, "JSXClosingFragment") : (node2.name = this.jsxParseElementName(), this.expect(143), this.finishNode(node2, "JSXClosingElement"));
    }
    jsxParseElementAt(startLoc) {
      const node2 = this.startNodeAt(startLoc), children = [], openingElement = this.jsxParseOpeningElementAt(startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (; ; )
          switch (this.state.type) {
            case 142:
              if (startLoc = this.state.startLoc, this.next(), this.eat(56)) {
                closingElement = this.jsxParseClosingElementAt(startLoc);
                break contents;
              }
              children.push(this.jsxParseElementAt(startLoc));
              break;
            case 141:
              children.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              const node3 = this.startNode();
              this.setContext(types2.brace), this.next(), this.match(21) ? children.push(this.jsxParseSpreadChild(node3)) : children.push(this.jsxParseExpressionContainer(node3, types2.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null ? this.raise(JsxErrors.MissingClosingTagFragment, closingElement) : !isFragment(openingElement) && isFragment(closingElement) ? this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
          openingTagName: getQualifiedJSXName(openingElement.name)
        }) : !isFragment(openingElement) && !isFragment(closingElement) && getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
          openingTagName: getQualifiedJSXName(openingElement.name)
        });
      }
      if (isFragment(openingElement) ? (node2.openingFragment = openingElement, node2.closingFragment = closingElement) : (node2.openingElement = openingElement, node2.closingElement = closingElement), node2.children = children, this.match(47))
        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return isFragment(openingElement) ? this.finishNode(node2, "JSXFragment") : this.finishNode(node2, "JSXElement");
    }
    jsxParseElement() {
      const startLoc = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(startLoc);
    }
    setContext(newContext) {
      const {
        context
      } = this.state;
      context[context.length - 1] = newContext;
    }
    parseExprAtom(refExpressionErrors) {
      return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(refExpressionErrors);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(code2) {
      const context = this.curContext();
      if (context === types2.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (context === types2.j_oTag || context === types2.j_cTag) {
        if (isIdentifierStart(code2)) {
          this.jsxReadWord();
          return;
        }
        if (code2 === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((code2 === 34 || code2 === 39) && context === types2.j_oTag) {
          this.jsxReadString(code2);
          return;
        }
      }
      if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(code2);
    }
    updateContext(prevType) {
      const {
        context,
        type: type2
      } = this.state;
      if (type2 === 56 && prevType === 142)
        context.splice(-2, 2, types2.j_cTag), this.state.canStartJSXElement = !1;
      else if (type2 === 142)
        context.push(types2.j_oTag);
      else if (type2 === 143) {
        const out = context[context.length - 1];
        out === types2.j_oTag && prevType === 56 || out === types2.j_cTag ? (context.pop(), this.state.canStartJSXElement = context[context.length - 1] === types2.j_expr) : (this.setContext(types2.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = tokenComesBeforeExpression(type2);
    }
  };
  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args), this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class TypeScriptScopeHandler extends ScopeHandler {
    constructor(...args) {
      super(...args), this.importsStack = [];
    }
    createScope(flags) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new TypeScriptScope(flags);
    }
    enter(flags) {
      flags === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(flags);
    }
    exit() {
      const flags = super.exit();
      return flags === 256 && this.importsStack.pop(), flags;
    }
    hasImport(name, allowShadow) {
      const len = this.importsStack.length;
      if (this.importsStack[len - 1].has(name))
        return !0;
      if (!allowShadow && len > 1) {
        for (let i2 = 0; i2 < len - 1; i2++)
          if (this.importsStack[i2].has(name)) return !0;
      }
      return !1;
    }
    declareName(name, bindingType, loc) {
      if (bindingType & 4096) {
        this.hasImport(name, !0) && this.parser.raise(Errors.VarRedeclaration, loc, {
          identifierName: name
        }), this.importsStack[this.importsStack.length - 1].add(name);
        return;
      }
      const scope2 = this.currentScope();
      let type2 = scope2.tsNames.get(name) || 0;
      if (bindingType & 1024) {
        this.maybeExportDefined(scope2, name), scope2.tsNames.set(name, type2 | 16);
        return;
      }
      super.declareName(name, bindingType, loc), bindingType & 2 && (bindingType & 1 || (this.checkRedeclarationInScope(scope2, name, bindingType, loc), this.maybeExportDefined(scope2, name)), type2 = type2 | 1), bindingType & 256 && (type2 = type2 | 2), bindingType & 512 && (type2 = type2 | 4), bindingType & 128 && (type2 = type2 | 8), type2 && scope2.tsNames.set(name, type2);
    }
    isRedeclaredInScope(scope2, name, bindingType) {
      const type2 = scope2.tsNames.get(name);
      if ((type2 & 2) > 0) {
        if (bindingType & 256) {
          const isConst = !!(bindingType & 512), wasConst = (type2 & 4) > 0;
          return isConst !== wasConst;
        }
        return !0;
      }
      return bindingType & 128 && (type2 & 8) > 0 ? scope2.names.get(name) & 2 ? !!(bindingType & 1) : !1 : bindingType & 2 && (type2 & 1) > 0 ? !0 : super.isRedeclaredInScope(scope2, name, bindingType);
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      if (this.hasImport(name)) return;
      const len = this.scopeStack.length;
      for (let i2 = len - 1; i2 >= 0; i2--) {
        const type2 = this.scopeStack[i2].tsNames.get(name);
        if ((type2 & 1) > 0 || (type2 & 16) > 0)
          return;
      }
      super.checkLocalExport(id);
    }
  }
  const getOwn$1 = (object, key2) => hasOwnProperty.call(object, key2) && object[key2], unwrapParenthesizedExpression = (node2) => node2.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node2.expression) : node2;
  class LValParser extends NodeUtils {
    toAssignable(node2, isLHS = !1) {
      var _node$extra, _node$extra3;
      let parenthesized;
      switch ((node2.type === "ParenthesizedExpression" || (_node$extra = node2.extra) != null && _node$extra.parenthesized) && (parenthesized = unwrapParenthesizedExpression(node2), isLHS ? parenthesized.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node2) : parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized) && this.raise(Errors.InvalidParenthesizedAssignment, node2) : this.raise(Errors.InvalidParenthesizedAssignment, node2)), node2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node2.type = "ObjectPattern";
          for (let i2 = 0, length = node2.properties.length, last2 = length - 1; i2 < length; i2++) {
            var _node$extra2;
            const prop = node2.properties[i2], isLast = i2 === last2;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS), isLast && prop.type === "RestElement" && (_node$extra2 = node2.extra) != null && _node$extra2.trailingCommaLoc && this.raise(Errors.RestTrailingComma, node2.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const {
            key: key2,
            value
          } = node2;
          this.isPrivateName(key2) && this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start), this.toAssignable(value, isLHS);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          node2.type = "ArrayPattern", this.toAssignableList(node2.elements, (_node$extra3 = node2.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
          break;
        case "AssignmentExpression":
          node2.operator !== "=" && this.raise(Errors.MissingEqInAssignment, node2.left.loc.end), node2.type = "AssignmentPattern", delete node2.operator, this.toAssignable(node2.left, isLHS);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod")
        this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
      else if (prop.type === "SpreadElement") {
        prop.type = "RestElement";
        const arg = prop.argument;
        this.checkToRestConversion(arg, !1), this.toAssignable(arg, isLHS), isLast || this.raise(Errors.RestTrailingComma, prop);
      } else
        this.toAssignable(prop, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      const end2 = exprList.length - 1;
      for (let i2 = 0; i2 <= end2; i2++) {
        const elt = exprList[i2];
        if (elt) {
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, !0), this.toAssignable(arg, isLHS);
          } else
            this.toAssignable(elt, isLHS);
          elt.type === "RestElement" && (i2 < end2 ? this.raise(Errors.RestTrailingComma, elt) : trailingCommaLoc && this.raise(Errors.RestTrailingComma, trailingCommaLoc));
        }
      }
    }
    isAssignable(node2, isBinding) {
      switch (node2.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          const last2 = node2.properties.length - 1;
          return node2.properties.every((prop, i2) => prop.type !== "ObjectMethod" && (i2 === last2 || prop.type !== "SpreadElement") && this.isAssignable(prop));
        }
        case "ObjectProperty":
          return this.isAssignable(node2.value);
        case "SpreadElement":
          return this.isAssignable(node2.argument);
        case "ArrayExpression":
          return node2.elements.every((element) => element === null || this.isAssignable(element));
        case "AssignmentExpression":
          return node2.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(node2.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;
        default:
          return !1;
      }
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (const expr of exprList)
        expr?.type === "ArrayExpression" && this.toReferencedListDeep(expr.elements);
    }
    parseSpread(refExpressionErrors) {
      const node2 = this.startNode();
      return this.next(), node2.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0), this.finishNode(node2, "SpreadElement");
    }
    parseRestBinding() {
      const node2 = this.startNode();
      return this.next(), node2.argument = this.parseBindingAtom(), this.finishNode(node2, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const node2 = this.startNode();
          return this.next(), node2.elements = this.parseBindingList(3, 93, 1), this.finishNode(node2, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, flags) {
      const allowEmpty = flags & 1, elts = [];
      let first2 = !0;
      for (; !this.eat(close); )
        if (first2 ? first2 = !1 : this.expect(12), allowEmpty && this.match(12))
          elts.push(null);
        else {
          if (this.eat(close))
            break;
          if (this.match(21)) {
            if (elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags)), !this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
              decorators.push(this.parseDecorator());
            elts.push(this.parseAssignableListItem(flags, decorators));
          }
        }
      return elts;
    }
    parseBindingRestProperty(prop) {
      return this.next(), prop.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(prop, "RestElement");
    }
    parseBindingProperty() {
      const {
        type: type2,
        startLoc
      } = this.state;
      if (type2 === 21)
        return this.parseBindingRestProperty(this.startNode());
      const prop = this.startNode();
      return type2 === 138 ? (this.expectPlugin("destructuringPrivate", startLoc), this.classScope.usePrivateName(this.state.value, startLoc), prop.key = this.parsePrivateName()) : this.parsePropertyName(prop), prop.method = !1, this.parseObjPropValue(prop, startLoc, !1, !1, !0, !1);
    }
    parseAssignableListItem(flags, decorators) {
      const left2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left2, flags);
      const elt = this.parseMaybeDefault(left2.loc.start, left2);
      return decorators.length && (left2.decorators = decorators), elt;
    }
    parseAssignableListItemTypes(param, flags) {
      return param;
    }
    parseMaybeDefault(startLoc, left2) {
      var _startLoc, _left;
      if ((_startLoc = startLoc) != null || (startLoc = this.state.startLoc), left2 = (_left = left2) != null ? _left : this.parseBindingAtom(), !this.eat(29)) return left2;
      const node2 = this.startNodeAt(startLoc);
      return node2.left = left2, node2.right = this.parseMaybeAssignAllowIn(), this.finishNode(node2, "AssignmentPattern");
    }
    isValidLVal(type2, isUnparenthesizedInAssign, binding) {
      return getOwn$1({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, type2);
    }
    isOptionalMemberExpression(expression) {
      return expression.type === "OptionalMemberExpression";
    }
    checkLVal(expression, {
      in: ancestor,
      binding = 64,
      checkClashes = !1,
      strictModeChanged = !1,
      hasParenthesizedAncestor = !1
    }) {
      var _expression$extra;
      const type2 = expression.type;
      if (this.isObjectMethod(expression)) return;
      const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
      if (isOptionalMemberExpression || type2 === "MemberExpression") {
        isOptionalMemberExpression && (this.expectPlugin("optionalChainingAssign", expression.loc.start), ancestor.type !== "AssignmentExpression" && this.raise(Errors.InvalidLhsOptionalChaining, expression, {
          ancestor
        })), binding !== 64 && this.raise(Errors.InvalidPropertyBindingPattern, expression);
        return;
      }
      if (type2 === "Identifier") {
        this.checkIdentifier(expression, binding, strictModeChanged);
        const {
          name
        } = expression;
        checkClashes && (checkClashes.has(name) ? this.raise(Errors.ParamDupe, expression) : checkClashes.add(name));
        return;
      }
      const validity = this.isValidLVal(type2, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
      if (validity === !0) return;
      if (validity === !1) {
        const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
        this.raise(ParseErrorClass, expression, {
          ancestor
        });
        return;
      }
      const [key2, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type2 === "ParenthesizedExpression"], nextAncestor = type2 === "ArrayPattern" || type2 === "ObjectPattern" ? {
        type: type2
      } : ancestor;
      for (const child of [].concat(expression[key2]))
        child && this.checkLVal(child, {
          in: nextAncestor,
          binding,
          checkClashes,
          strictModeChanged,
          hasParenthesizedAncestor: isParenthesizedExpression
        });
    }
    checkIdentifier(at, bindingType, strictModeChanged = !1) {
      this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name)) && (bindingType === 64 ? this.raise(Errors.StrictEvalArguments, at, {
        referenceName: at.name
      }) : this.raise(Errors.StrictEvalArgumentsBinding, at, {
        bindingName: at.name
      })), bindingType & 8192 && at.name === "let" && this.raise(Errors.LetInLexicalBinding, at), bindingType & 64 || this.declareNameFromIdentifier(at, bindingType);
    }
    declareNameFromIdentifier(identifier, binding) {
      this.scope.declareName(identifier.name, binding, identifier.loc.start);
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(node2.expression, allowPattern);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (allowPattern) break;
        default:
          this.raise(Errors.InvalidRestAssignmentPattern, node2);
      }
    }
    checkCommaAfterRest(close) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }
  const getOwn = (object, key2) => hasOwnProperty.call(object, key2) && object[key2];
  function nonNull(x) {
    if (x == null)
      throw new Error(`Unexpected ${x} value.`);
    return x;
  }
  function assert2(x) {
    if (!x)
      throw new Error("Assert fail");
  }
  const TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({
      methodName
    }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({
      propertyName
    }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({
      kind
    }) => `'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({
      modifier
    }) => "Accessibility modifier already seen.",
    DuplicateModifier: ({
      modifier
    }) => `Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({
      token: token2
    }) => `'${token2}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({
      modifiers
    }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({
      modifier
    }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({
      modifier
    }) => `'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({
      modifier
    }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifiersOrder: ({
      orderedModifiers
    }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({
      modifier
    }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({
      typeParameterName
    }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({
      type: type2
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type2}.`
  });
  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  }
  function tsIsVarianceAnnotations(modifier) {
    return modifier === "in" || modifier === "out";
  }
  var typescript2 = (superClass) => class extends superClass {
    constructor(...args) {
      super(...args), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: TSErrors.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }
    tsIsIdentifier() {
      return tokenIsIdentifier(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
      if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      const modifier = this.state.value;
      if (allowedModifiers.indexOf(modifier) !== -1) {
        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return modifier;
      }
    }
    tsParseModifiers({
      allowedModifiers,
      disallowedModifiers,
      stopOnStartOfClassStaticBlock,
      errorTemplate = TSErrors.InvalidModifierOnTypeMember
    }, modified) {
      const enforceOrder = (loc, modifier, before, after) => {
        modifier === before && modified[after] && this.raise(TSErrors.InvalidModifiersOrder, loc, {
          orderedModifiers: [before, after]
        });
      }, incompatible = (loc, modifier, mod1, mod2) => {
        (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) && this.raise(TSErrors.IncompatibleModifiers, loc, {
          modifiers: [mod1, mod2]
        });
      };
      for (; ; ) {
        const {
          startLoc
        } = this.state, modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers ?? []), stopOnStartOfClassStaticBlock);
        if (!modifier) break;
        tsIsAccessModifier(modifier) ? modified.accessibility ? this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
          modifier
        }) : (enforceOrder(startLoc, modifier, modifier, "override"), enforceOrder(startLoc, modifier, modifier, "static"), enforceOrder(startLoc, modifier, modifier, "readonly"), modified.accessibility = modifier) : tsIsVarianceAnnotations(modifier) ? (modified[modifier] && this.raise(TSErrors.DuplicateModifier, startLoc, {
          modifier
        }), modified[modifier] = !0, enforceOrder(startLoc, modifier, "in", "out")) : (hasOwnProperty.call(modified, modifier) ? this.raise(TSErrors.DuplicateModifier, startLoc, {
          modifier
        }) : (enforceOrder(startLoc, modifier, "static", "readonly"), enforceOrder(startLoc, modifier, "static", "override"), enforceOrder(startLoc, modifier, "override", "readonly"), enforceOrder(startLoc, modifier, "abstract", "override"), incompatible(startLoc, modifier, "declare", "override"), incompatible(startLoc, modifier, "static", "abstract")), modified[modifier] = !0), disallowedModifiers != null && disallowedModifiers.includes(modifier) && this.raise(errorTemplate, startLoc, {
          modifier
        });
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(kind, parseElement) {
      const result = [];
      for (; !this.tsIsListTerminator(kind); )
        result.push(parseElement());
      return result;
    }
    tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, !0, refTrailingCommaPos));
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
      const result = [];
      let trailingCommaPos = -1;
      for (; !this.tsIsListTerminator(kind); ) {
        trailingCommaPos = -1;
        const element = parseElement();
        if (element == null)
          return;
        if (result.push(element), this.eat(12)) {
          trailingCommaPos = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(kind))
          break;
        expectSuccess && this.expect(12);
        return;
      }
      return refTrailingCommaPos && (refTrailingCommaPos.value = trailingCommaPos), result;
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
      skipFirstToken || (bracket ? this.expect(0) : this.expect(47));
      const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
      return bracket ? this.expect(3) : this.expect(48), result;
    }
    tsParseImportType() {
      const node2 = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc), node2.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (node2.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (node2.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (node2.qualifier = this.tsParseEntityName()), this.match(47) && (node2.typeParameters = this.tsParseTypeArguments()), this.finishNode(node2, "TSImportType");
    }
    tsParseEntityName(allowReservedWords = !0) {
      let entity = this.parseIdentifier(allowReservedWords);
      for (; this.eat(16); ) {
        const node2 = this.startNodeAtNode(entity);
        node2.left = entity, node2.right = this.parseIdentifier(allowReservedWords), entity = this.finishNode(node2, "TSQualifiedName");
      }
      return entity;
    }
    tsParseTypeReference() {
      const node2 = this.startNode();
      return node2.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (node2.typeParameters = this.tsParseTypeArguments()), this.finishNode(node2, "TSTypeReference");
    }
    tsParseThisTypePredicate(lhs) {
      this.next();
      const node2 = this.startNodeAtNode(lhs);
      return node2.parameterName = lhs, node2.typeAnnotation = this.tsParseTypeAnnotation(!1), node2.asserts = !1, this.finishNode(node2, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const node2 = this.startNode();
      return this.next(), this.finishNode(node2, "TSThisType");
    }
    tsParseTypeQuery() {
      const node2 = this.startNode();
      return this.expect(87), this.match(83) ? node2.exprName = this.tsParseImportType() : node2.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (node2.typeParameters = this.tsParseTypeArguments()), this.finishNode(node2, "TSTypeQuery");
    }
    tsParseTypeParameter(parseModifiers) {
      const node2 = this.startNode();
      return parseModifiers(node2), node2.name = this.tsParseTypeParameterName(), node2.constraint = this.tsEatThenParseType(81), node2.default = this.tsEatThenParseType(29), this.finishNode(node2, "TSTypeParameter");
    }
    tsTryParseTypeParameters(parseModifiers) {
      if (this.match(47))
        return this.tsParseTypeParameters(parseModifiers);
    }
    tsParseTypeParameters(parseModifiers) {
      const node2 = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      const refTrailingCommaPos = {
        value: -1
      };
      return node2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), !1, !0, refTrailingCommaPos), node2.params.length === 0 && this.raise(TSErrors.EmptyTypeParameters, node2), refTrailingCommaPos.value !== -1 && this.addExtra(node2, "trailingComma", refTrailingCommaPos.value), this.finishNode(node2, "TSTypeParameterDeclaration");
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === 19, paramsKey = "parameters", returnTypeKey = "typeAnnotation";
      signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), signature[paramsKey] = this.tsParseBindingListForSignature(), returnTokenRequired ? signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken) : this.match(returnToken) && (signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken));
    }
    tsParseBindingListForSignature() {
      const list2 = super.parseBindingList(11, 41, 2);
      for (const pattern of list2) {
        const {
          type: type2
        } = pattern;
        (type2 === "AssignmentPattern" || type2 === "TSParameterProperty") && this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
          type: type2
        });
      }
      return list2;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(kind, node2) {
      return this.tsFillSignature(14, node2), this.tsParseTypeMemberSemicolon(), this.finishNode(node2, kind);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), tokenIsIdentifier(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(node2) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(id), this.expect(3), node2.parameters = [id];
      const type2 = this.tsTryParseTypeAnnotation();
      return type2 && (node2.typeAnnotation = type2), this.tsParseTypeMemberSemicolon(), this.finishNode(node2, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(node2, readonly) {
      this.eat(17) && (node2.optional = !0);
      const nodeAny = node2;
      if (this.match(10) || this.match(47)) {
        readonly && this.raise(TSErrors.ReadonlyForMethodSignature, node2);
        const method = nodeAny;
        method.kind && this.match(47) && this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, method), this.tsParseTypeMemberSemicolon();
        const paramsKey = "parameters", returnTypeKey = "typeAnnotation";
        if (method.kind === "get")
          method[paramsKey].length > 0 && (this.raise(Errors.BadGetterArity, this.state.curPosition()), this.isThisParam(method[paramsKey][0]) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition()));
        else if (method.kind === "set") {
          if (method[paramsKey].length !== 1)
            this.raise(Errors.BadSetterArity, this.state.curPosition());
          else {
            const firstParameter = method[paramsKey][0];
            this.isThisParam(firstParameter) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition()), firstParameter.type === "Identifier" && firstParameter.optional && this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), firstParameter.type === "RestElement" && this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          method[returnTypeKey] && this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);
        } else
          method.kind = "method";
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property = nodeAny;
        readonly && (property.readonly = !0);
        const type2 = this.tsTryParseTypeAnnotation();
        return type2 && (property.typeAnnotation = type2), this.tsParseTypeMemberSemicolon(), this.finishNode(property, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const node2 = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node2);
      if (this.match(77)) {
        const id = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", node2) : (node2.key = this.createIdentifier(id, "new"), this.tsParsePropertyOrMethodSignature(node2, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, node2);
      const idx = this.tsTryParseIndexSignature(node2);
      return idx || (super.parsePropertyName(node2), !node2.computed && node2.key.type === "Identifier" && (node2.key.name === "get" || node2.key.name === "set") && this.tsTokenCanFollowModifier() && (node2.kind = node2.key.name, super.parsePropertyName(node2)), this.tsParsePropertyOrMethodSignature(node2, !!node2.readonly));
    }
    tsParseTypeLiteral() {
      const node2 = this.startNode();
      return node2.members = this.tsParseObjectTypeMembers(), this.finishNode(node2, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), members;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      const node2 = this.startNode();
      return node2.name = this.tsParseTypeParameterName(), node2.constraint = this.tsExpectThenParseType(58), this.finishNode(node2, "TSTypeParameter");
    }
    tsParseMappedType() {
      const node2 = this.startNode();
      return this.expect(5), this.match(53) ? (node2.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (node2.readonly = !0), this.expect(0), node2.typeParameter = this.tsParseMappedTypeParameter(), node2.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (node2.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (node2.optional = !0), node2.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(node2, "TSMappedType");
    }
    tsParseTupleType() {
      const node2 = this.startNode();
      node2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let seenOptionalElement = !1;
      return node2.elementTypes.forEach((elementNode) => {
        const {
          type: type2
        } = elementNode;
        seenOptionalElement && type2 !== "TSRestType" && type2 !== "TSOptionalType" && !(type2 === "TSNamedTupleMember" && elementNode.optional) && this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode), seenOptionalElement || (seenOptionalElement = type2 === "TSNamedTupleMember" && elementNode.optional || type2 === "TSOptionalType");
      }), this.finishNode(node2, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        startLoc
      } = this.state, rest = this.eat(21);
      let labeled, label, optional, type2;
      const chAfterWord = tokenIsKeywordOrIdentifier(this.state.type) ? this.lookaheadCharCode() : null;
      if (chAfterWord === 58)
        labeled = !0, optional = !1, label = this.parseIdentifier(!0), this.expect(14), type2 = this.tsParseType();
      else if (chAfterWord === 63) {
        optional = !0;
        const startLoc2 = this.state.startLoc, wordName = this.state.value, typeOrLabel = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (labeled = !0, label = this.createIdentifier(this.startNodeAt(startLoc2), wordName), this.expect(17), this.expect(14), type2 = this.tsParseType()) : (labeled = !1, type2 = typeOrLabel, this.expect(17));
      } else
        type2 = this.tsParseType(), optional = this.eat(17), labeled = this.eat(14);
      if (labeled) {
        let labeledNode;
        label ? (labeledNode = this.startNodeAtNode(label), labeledNode.optional = optional, labeledNode.label = label, labeledNode.elementType = type2, this.eat(17) && (labeledNode.optional = !0, this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (labeledNode = this.startNodeAtNode(type2), labeledNode.optional = optional, this.raise(TSErrors.InvalidTupleMemberLabel, type2), labeledNode.label = type2, labeledNode.elementType = this.tsParseType()), type2 = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type2);
        optionalTypeNode.typeAnnotation = type2, type2 = this.finishNode(optionalTypeNode, "TSOptionalType");
      }
      if (rest) {
        const restNode = this.startNodeAt(startLoc);
        restNode.typeAnnotation = type2, type2 = this.finishNode(restNode, "TSRestType");
      }
      return type2;
    }
    tsParseParenthesizedType() {
      const node2 = this.startNode();
      return this.expect(10), node2.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(node2, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(type2, abstract) {
      const node2 = this.startNode();
      return type2 === "TSConstructorType" && (node2.abstract = !!abstract, abstract && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node2)), this.finishNode(node2, type2);
    }
    tsParseLiteralTypeNode() {
      const node2 = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          node2.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(node2, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const node2 = this.startNode();
      return node2.literal = super.parseTemplate(!1), this.finishNode(node2, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(thisKeyword) : thisKeyword;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            const node2 = this.startNode(), nextToken = this.lookahead();
            return nextToken.type !== 134 && nextToken.type !== 135 && this.unexpected(), node2.literal = this.parseMaybeUnary(), this.finishNode(node2, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const {
            type: type2
          } = this.state;
          if (tokenIsIdentifier(type2) || type2 === 88 || type2 === 84) {
            const nodeType = type2 === 88 ? "TSVoidKeyword" : type2 === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
            if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
              const node2 = this.startNode();
              return this.next(), this.finishNode(node2, nodeType);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let type2 = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          const node2 = this.startNodeAtNode(type2);
          node2.elementType = type2, this.expect(3), type2 = this.finishNode(node2, "TSArrayType");
        } else {
          const node2 = this.startNodeAtNode(type2);
          node2.objectType = type2, node2.indexType = this.tsParseType(), this.expect(3), type2 = this.finishNode(node2, "TSIndexedAccessType");
        }
      return type2;
    }
    tsParseTypeOperator() {
      const node2 = this.startNode(), operator = this.state.value;
      return this.next(), node2.operator = operator, node2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), operator === "readonly" && this.tsCheckTypeAnnotationForReadOnly(node2), this.finishNode(node2, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(node2) {
      switch (node2.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(TSErrors.UnexpectedReadonly, node2);
      }
    }
    tsParseInferType() {
      const node2 = this.startNode();
      this.expectContextual(115);
      const typeParameter = this.startNode();
      return typeParameter.name = this.tsParseTypeParameterName(), typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), node2.typeParameter = this.finishNode(typeParameter, "TSTypeParameter"), this.finishNode(node2, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return constraint;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node2 = this.startNode(), hasLeadingOperator = this.eat(operator), types3 = [];
      do
        types3.push(parseConstituentType());
      while (this.eat(operator));
      return types3.length === 1 && !hasLeadingOperator ? types3[0] : (node2.types = types3, this.finishNode(node2, kind));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (tokenIsIdentifier(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        const {
          errors: errors2
        } = this.state, previousErrorCount = errors2.length;
        try {
          return this.parseObjectLike(8, !0), errors2.length === previousErrorCount;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        const {
          errors: errors2
        } = this.state, previousErrorCount = errors2.length;
        try {
          return super.parseBindingList(3, 93, 1), errors2.length === previousErrorCount;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const node2 = this.startNode(), asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (asserts && this.match(78)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
          return thisTypePredicate.type === "TSThisType" ? (node2.parameterName = thisTypePredicate, node2.asserts = !0, node2.typeAnnotation = null, thisTypePredicate = this.finishNode(node2, "TSTypePredicate")) : (this.resetStartLocationFromNode(thisTypePredicate, node2), thisTypePredicate.asserts = !0), t.typeAnnotation = thisTypePredicate, this.finishNode(t, "TSTypeAnnotation");
        }
        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!typePredicateVariable)
          return asserts ? (node2.parameterName = this.parseIdentifier(), node2.asserts = asserts, node2.typeAnnotation = null, t.typeAnnotation = this.finishNode(node2, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, t);
        const type2 = this.tsParseTypeAnnotation(!1);
        return node2.parameterName = typePredicateVariable, node2.typeAnnotation = type2, node2.asserts = asserts, t.typeAnnotation = this.finishNode(node2, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), id;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      const containsEsc = this.state.containsEsc;
      return this.next(), !tokenIsIdentifier(this.state.type) && !this.match(78) ? !1 : (containsEsc && this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(eatColon = !0, t = this.startNode()) {
      return this.tsInType(() => {
        eatColon && this.expect(14), t.typeAnnotation = this.tsParseType();
      }), this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      assert2(this.state.inType);
      const type2 = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return type2;
      const node2 = this.startNodeAtNode(type2);
      return node2.checkType = type2, node2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), node2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), node2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(node2, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
      const node2 = this.startNode();
      return node2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), node2.expression = this.parseMaybeUnary(), this.finishNode(node2, "TSTypeAssertion");
    }
    tsParseHeritageClause(token2) {
      const originalStartLoc = this.state.startLoc, delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const node2 = this.startNode();
        return node2.expression = this.tsParseEntityName(), this.match(47) && (node2.typeParameters = this.tsParseTypeArguments()), this.finishNode(node2, "TSExpressionWithTypeArguments");
      });
      return delimitedList.length || this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
        token: token2
      }), delimitedList;
    }
    tsParseInterfaceDeclaration(node2, properties = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), properties.declare && (node2.declare = !0), tokenIsIdentifier(this.state.type) ? (node2.id = this.parseIdentifier(), this.checkIdentifier(node2.id, 130)) : (node2.id = null, this.raise(TSErrors.MissingInterfaceName, this.state.startLoc)), node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (node2.extends = this.tsParseHeritageClause("extends"));
      const body = this.startNode();
      return body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), node2.body = this.finishNode(body, "TSInterfaceBody"), this.finishNode(node2, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(node2) {
      return node2.id = this.parseIdentifier(), this.checkIdentifier(node2.id, 2), node2.typeAnnotation = this.tsInType(() => {
        if (node2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          const node3 = this.startNode();
          return this.next(), this.finishNode(node3, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(node2, "TSTypeAliasDeclaration");
    }
    tsInNoContext(cb) {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];
      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = !0;
      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }
    tsInDisallowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsInAllowConditionalTypesContext(cb) {
      const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return cb();
      } finally {
        this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
      }
    }
    tsEatThenParseType(token2) {
      if (this.match(token2))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(token2) {
      return this.tsInType(() => (this.expect(token2), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const node2 = this.startNode();
      return node2.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (node2.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(node2, "TSEnumMember");
    }
    tsParseEnumDeclaration(node2, properties = {}) {
      return properties.const && (node2.const = !0), properties.declare && (node2.declare = !0), this.expectContextual(126), node2.id = this.parseIdentifier(), this.checkIdentifier(node2.id, node2.const ? 8971 : 8459), this.expect(5), node2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(node2, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const node2 = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(node2.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(node2, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(node2, nested = !1) {
      if (node2.id = this.parseIdentifier(), nested || this.checkIdentifier(node2.id, 1024), this.eat(16)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, !0), node2.body = inner;
      } else
        this.scope.enter(256), this.prodParam.enter(0), node2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(node2, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(node2) {
      return this.isContextual(112) ? (node2.global = !0, node2.id = this.parseIdentifier()) : this.match(133) ? node2.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), node2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(node2, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier, isExport) {
      node2.isExport = isExport || !1, node2.id = maybeDefaultIdentifier || this.parseIdentifier(), this.checkIdentifier(node2.id, 4096), this.expect(29);
      const moduleReference = this.tsParseModuleReference();
      return node2.importKind === "type" && moduleReference.type !== "TSExternalModuleReference" && this.raise(TSErrors.ImportAliasHasImportType, moduleReference), node2.moduleReference = moduleReference, this.semicolon(), this.finishNode(node2, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      const node2 = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), node2.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(node2, "TSExternalModuleReference");
    }
    tsLookAhead(f2) {
      const state2 = this.state.clone(), res = f2();
      return this.state = state2, res;
    }
    tsTryParseAndCatch(f2) {
      const result = this.tryParse((abort) => f2() || abort());
      if (!(result.aborted || !result.node))
        return result.error && (this.state = result.failState), result.node;
    }
    tsTryParse(f2) {
      const state2 = this.state.clone(), result = f2();
      if (result !== void 0 && result !== !1)
        return result;
      this.state = state2;
    }
    tsTryParseDeclare(nany) {
      if (this.isLineTerminator())
        return;
      let startType = this.state.type, kind;
      return this.isContextual(100) && (startType = 74, kind = "let"), this.tsInAmbientContext(() => {
        switch (startType) {
          case 68:
            return nany.declare = !0, super.parseFunctionStatement(nany, !1, !1);
          case 80:
            return nany.declare = !0, this.parseClass(nany, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(nany, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (nany.declare = !0, this.parseVarStatement(nany, kind || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(nany, {
              const: !0,
              declare: !0
            }));
          case 129: {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: !0
            });
            if (result) return result;
          }
          default:
            if (tokenIsIdentifier(startType))
              return this.tsParseDeclaration(nany, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(node2, expr, decorators) {
      switch (expr.name) {
        case "declare": {
          const declaration = this.tsTryParseDeclare(node2);
          return declaration && (declaration.declare = !0), declaration;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const mod = node2;
            return mod.global = !0, mod.id = expr, mod.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(mod, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(node2, expr.name, !1, decorators);
      }
    }
    tsParseDeclaration(node2, value, next, decorators) {
      switch (value) {
        case "abstract":
          if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type)))
            return this.tsParseAbstractDeclaration(node2, decorators);
          break;
        case "module":
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(node2);
            if (tokenIsIdentifier(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(node2);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(node2);
          break;
        case "type":
          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
            return this.tsParseTypeAliasDeclaration(node2);
          break;
      }
    }
    tsCheckLineTerminator(next) {
      return next ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(startLoc) {
      if (!this.match(47)) return;
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      const res = this.tsTryParseAndCatch(() => {
        const node2 = this.startNodeAt(startLoc);
        return node2.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(node2), node2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), node2;
      });
      if (this.state.maybeInArrowParameters = oldMaybeInArrowParameters, !!res)
        return super.parseArrowExpression(res, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const node2 = this.startNode();
      return node2.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), node2.params.length === 0 ? this.raise(TSErrors.EmptyTypeArguments, node2) : !this.state.inType && this.curContext() === types2.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(node2, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return tokenIsTSDeclarationStart(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(flags, decorators) {
      const startLoc = this.state.startLoc, modified = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, modified);
      const accessibility = modified.accessibility, override = modified.override, readonly = modified.readonly;
      !(flags & 4) && (accessibility || readonly || override) && this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
      const left2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left2, flags);
      const elt = this.parseMaybeDefault(left2.loc.start, left2);
      if (accessibility || readonly || override) {
        const pp = this.startNodeAt(startLoc);
        return decorators.length && (pp.decorators = decorators), accessibility && (pp.accessibility = accessibility), readonly && (pp.readonly = readonly), override && (pp.override = override), elt.type !== "Identifier" && elt.type !== "AssignmentPattern" && this.raise(TSErrors.UnsupportedParameterPropertyKind, pp), pp.parameter = elt, this.finishNode(pp, "TSParameterProperty");
      }
      return decorators.length && (left2.decorators = decorators), elt;
    }
    isSimpleParameter(node2) {
      return node2.type === "TSParameterProperty" && super.isSimpleParameter(node2.parameter) || super.isSimpleParameter(node2);
    }
    tsDisallowOptionalPattern(node2) {
      for (const param of node2.params)
        param.type !== "Identifier" && param.optional && !this.state.isAmbientContext && this.raise(TSErrors.PatternIsOptional, param);
    }
    setArrowFunctionParameters(node2, params, trailingCommaLoc) {
      super.setArrowFunctionParameters(node2, params, trailingCommaLoc), this.tsDisallowOptionalPattern(node2);
    }
    parseFunctionBodyAndFinish(node2, type2, isMethod = !1) {
      this.match(14) && (node2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const bodilessType = type2 === "FunctionDeclaration" ? "TSDeclareFunction" : type2 === "ClassMethod" || type2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return bodilessType && !this.match(5) && this.isLineTerminator() ? this.finishNode(node2, bodilessType) : bodilessType === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(TSErrors.DeclareFunctionHasImplementation, node2), node2.declare) ? super.parseFunctionBodyAndFinish(node2, bodilessType, isMethod) : (this.tsDisallowOptionalPattern(node2), super.parseFunctionBodyAndFinish(node2, type2, isMethod));
    }
    registerFunctionStatementId(node2) {
      !node2.body && node2.id ? this.checkIdentifier(node2.id, 1024) : super.registerFunctionStatementId(node2);
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node2) => {
        node2?.type === "TSTypeCastExpression" && this.raise(TSErrors.UnexpectedTypeAnnotation, node2.typeAnnotation);
      });
    }
    toReferencedList(exprList, isInParens) {
      return this.tsCheckForInvalidTypeCasts(exprList), exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node2 = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      return node2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(node2.elements), node2;
    }
    parseSubscript(base2, startLoc, noCalls, state2) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        const nonNullExpression = this.startNodeAt(startLoc);
        return nonNullExpression.expression = base2, this.finishNode(nonNullExpression, "TSNonNullExpression");
      }
      let isOptionalCall = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (noCalls)
          return state2.stop = !0, base2;
        state2.optionalChainMember = isOptionalCall = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let missingParenErrorLoc;
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base2)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
            if (asyncArrowFn)
              return asyncArrowFn;
          }
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (!typeArguments) return;
          if (isOptionalCall && !this.match(10)) {
            missingParenErrorLoc = this.state.curPosition();
            return;
          }
          if (tokenIsTemplate(this.state.type)) {
            const result2 = super.parseTaggedTemplateExpression(base2, startLoc, state2);
            return result2.typeParameters = typeArguments, result2;
          }
          if (!noCalls && this.eat(10)) {
            const node3 = this.startNodeAt(startLoc);
            return node3.callee = base2, node3.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(node3.arguments), node3.typeParameters = typeArguments, state2.optionalChainMember && (node3.optional = isOptionalCall), this.finishCallExpression(node3, state2.optionalChainMember);
          }
          const tokenType = this.state.type;
          if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak())
            return;
          const node2 = this.startNodeAt(startLoc);
          return node2.expression = base2, node2.typeParameters = typeArguments, this.finishNode(node2, "TSInstantiationExpression");
        });
        if (missingParenErrorLoc && this.unexpected(missingParenErrorLoc, 10), result)
          return result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), result;
      }
      return super.parseSubscript(base2, startLoc, noCalls, state2);
    }
    parseNewCallee(node2) {
      var _callee$extra;
      super.parseNewCallee(node2);
      const {
        callee
      } = node2;
      callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized) && (node2.typeParameters = callee.typeParameters, node2.callee = callee.expression);
    }
    parseExprOp(left2, leftStartLoc, minPrec) {
      let isSatisfies;
      if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
        const node2 = this.startNodeAt(leftStartLoc);
        return node2.expression = left2, node2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (isSatisfies && this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(node2, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(node2, leftStartLoc, minPrec);
      }
      return super.parseExprOp(left2, leftStartLoc, minPrec);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      this.state.isAmbientContext || super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    }
    checkImportReflection(node2) {
      super.checkImportReflection(node2), node2.module && node2.importKind !== "value" && this.raise(TSErrors.ImportReflectionHasImportType, node2.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(isExport) {
      if (super.isPotentialImportPhase(isExport)) return !0;
      if (this.isContextual(130)) {
        const ch = this.lookaheadCharCode();
        return isExport ? ch === 123 || ch === 42 : ch !== 61;
      }
      return !isExport && this.isContextual(87);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      super.applyImportPhase(node2, isExport, phase, loc), isExport ? node2.exportKind = phase === "type" ? "type" : "value" : node2.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    }
    parseImport(node2) {
      if (this.match(133))
        return node2.importKind = "value", super.parseImport(node2);
      let importNode;
      if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61)
        return node2.importKind = "value", this.tsParseImportEqualsDeclaration(node2);
      if (this.isContextual(130)) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(node2, maybeDefaultIdentifier);
        importNode = super.parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier);
      } else
        importNode = super.parseImport(node2);
      return importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode), importNode;
    }
    parseExport(node2, decorators) {
      if (this.match(83)) {
        this.next();
        const nodeImportEquals = node2;
        let maybeDefaultIdentifier = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, !1) : nodeImportEquals.importKind = "value", this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, !0);
      } else if (this.eat(29)) {
        const assign2 = node2;
        return assign2.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(assign2, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        const decl = node2;
        return this.expectContextual(128), decl.id = this.parseIdentifier(), this.semicolon(), this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(node2, decorators);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        return this.next(), cls.abstract = !0, this.parseClass(cls, !0, !0);
      }
      if (this.match(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result) return result;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(node2, kind, allowMissingInitializer = !1) {
      const {
        isAmbientContext
      } = this.state, declaration = super.parseVarStatement(node2, kind, allowMissingInitializer || isAmbientContext);
      if (!isAmbientContext) return declaration;
      for (const {
        id,
        init
      } of declaration.declarations)
        init && (kind !== "const" || id.typeAnnotation ? this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init) : isValidAmbientConstInitializer(init, this.hasPlugin("estree")) || this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init));
      return declaration;
    }
    parseStatementContent(flags, decorators) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const node2 = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(node2, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const result = this.tsParseInterfaceDeclaration(this.startNode());
        if (result) return result;
      }
      return super.parseStatementContent(flags, decorators);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => tsIsAccessModifier(modifier) ? member.accessibility === modifier : !!member[modifier]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(classBody, member, state2) {
      const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: modifiers,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
      }, member);
      const callParseClassMemberWithIsStatic = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(member, modifiers) && this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(classBody, member)) : this.parseClassMemberWithIsStatic(classBody, member, state2, !!member.static);
      };
      member.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
    }
    parseClassMemberWithIsStatic(classBody, member, state2, isStatic) {
      const idx = this.tsTryParseIndexSignature(member);
      if (idx) {
        classBody.body.push(idx), member.abstract && this.raise(TSErrors.IndexSignatureHasAbstract, member), member.accessibility && this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
          modifier: member.accessibility
        }), member.declare && this.raise(TSErrors.IndexSignatureHasDeclare, member), member.override && this.raise(TSErrors.IndexSignatureHasOverride, member);
        return;
      }
      !this.state.inAbstractClass && member.abstract && this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member), member.override && (state2.hadSuperClass || this.raise(TSErrors.OverrideNotInSubClass, member)), super.parseClassMemberWithIsStatic(classBody, member, state2, isStatic);
    }
    parsePostMemberNameModifiers(methodOrProp) {
      this.eat(17) && (methodOrProp.optional = !0), methodOrProp.readonly && this.match(10) && this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp), methodOrProp.declare && this.match(10) && this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
    }
    parseExpressionStatement(node2, expr, decorators) {
      return (expr.type === "Identifier" ? this.tsParseExpressionStatement(node2, expr, decorators) : void 0) || super.parseExpressionStatement(node2, expr, decorators);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      const result = this.tryParse(() => super.parseConditional(expr, startLoc));
      return result.node ? (result.error && (this.state = result.failState), result.node) : (result.error && super.setOptionalParametersError(refExpressionErrors, result.error), expr);
    }
    parseParenItem(node2, startLoc) {
      const newNode = super.parseParenItem(node2, startLoc);
      if (this.eat(17) && (newNode.optional = !0, this.resetEndLocation(node2)), this.match(14)) {
        const typeCastNode = this.startNodeAt(startLoc);
        return typeCastNode.expression = node2, typeCastNode.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(typeCastNode, "TSTypeCastExpression");
      }
      return node2;
    }
    parseExportDeclaration(node2) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(node2));
      const startLoc = this.state.startLoc, isDeclare = this.eatContextual(125);
      if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const declaration = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node2);
      return declaration ? ((declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) && (node2.exportKind = "type"), isDeclare && (this.resetStartLocation(declaration, startLoc), declaration.declare = !0), declaration) : null;
    }
    parseClassId(node2, isStatement, optionalId, bindingType) {
      if ((!isStatement || optionalId) && this.isContextual(113))
        return;
      super.parseClassId(node2, isStatement, optionalId, node2.declare ? 1024 : 8331);
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      typeParameters && (node2.typeParameters = typeParameters);
    }
    parseClassPropertyAnnotation(node2) {
      node2.optional || (this.eat(35) ? node2.definite = !0 : this.eat(17) && (node2.optional = !0));
      const type2 = this.tsTryParseTypeAnnotation();
      type2 && (node2.typeAnnotation = type2);
    }
    parseClassProperty(node2) {
      if (this.parseClassPropertyAnnotation(node2), this.state.isAmbientContext && !(node2.readonly && !node2.typeAnnotation) && this.match(29) && this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc), node2.abstract && this.match(29)) {
        const {
          key: key2
        } = node2;
        this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: key2.type === "Identifier" && !node2.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
        });
      }
      return super.parseClassProperty(node2);
    }
    parseClassPrivateProperty(node2) {
      return node2.abstract && this.raise(TSErrors.PrivateElementHasAbstract, node2), node2.accessibility && this.raise(TSErrors.PrivateElementHasAccessibility, node2, {
        modifier: node2.accessibility
      }), this.parseClassPropertyAnnotation(node2), super.parseClassPrivateProperty(node2);
    }
    parseClassAccessorProperty(node2) {
      return this.parseClassPropertyAnnotation(node2), node2.optional && this.raise(TSErrors.AccessorCannotBeOptional, node2), super.parseClassAccessorProperty(node2);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      typeParameters && isConstructor && this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
      const {
        declare = !1,
        kind
      } = method;
      declare && (kind === "get" || kind === "set") && this.raise(TSErrors.DeclareAccessor, method, {
        kind
      }), typeParameters && (method.typeParameters = typeParameters), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      typeParameters && (method.typeParameters = typeParameters), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    declareClassPrivateMethodInScope(node2, kind) {
      node2.type !== "TSDeclareMethod" && (node2.type === "MethodDefinition" && !hasOwnProperty.call(node2.value, "body") || super.declareClassPrivateMethodInScope(node2, kind));
    }
    parseClassSuper(node2) {
      super.parseClassSuper(node2), node2.superClass && (this.match(47) || this.match(51)) && (node2.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (node2.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return typeParameters && (prop.typeParameters = typeParameters), super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
    }
    parseFunctionParams(node2, isConstructor) {
      const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      typeParameters && (node2.typeParameters = typeParameters), super.parseFunctionParams(node2, isConstructor);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind), decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (decl.definite = !0);
      const type2 = this.tsTryParseTypeAnnotation();
      type2 && (decl.id.typeAnnotation = type2, this.resetEndLocation(decl.id));
    }
    parseAsyncArrowFromCallExpression(node2, call2) {
      return this.match(14) && (node2.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(node2, call2);
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
      let state2, jsx3, typeCast;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (state2 = this.state.clone(), jsx3 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state2), !jsx3.error) return jsx3.node;
        const {
          context
        } = this.state, currentContext = context[context.length - 1];
        (currentContext === types2.j_oTag || currentContext === types2.j_expr) && context.pop();
      }
      if (!((_jsx = jsx3) != null && _jsx.error) && !this.match(47))
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      (!state2 || state2 === this.state) && (state2 = this.state.clone());
      let typeParameters;
      const arrow4 = this.tryParse((abort) => {
        var _expr$extra, _typeParameters;
        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
        const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        return (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && abort(), ((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0 && this.resetStartLocationFromNode(expr, typeParameters), expr.typeParameters = typeParameters, expr;
      }, state2);
      if (!arrow4.error && !arrow4.aborted)
        return typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow4.node;
      if (!jsx3 && (assert2(!this.hasPlugin("jsx")), typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state2), !typeCast.error))
        return typeCast.node;
      if ((_jsx2 = jsx3) != null && _jsx2.node)
        return this.state = jsx3.failState, jsx3.node;
      if (arrow4.node)
        return this.state = arrow4.failState, typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow4.node;
      if ((_typeCast = typeCast) != null && _typeCast.node)
        return this.state = typeCast.failState, typeCast.node;
      throw ((_jsx3 = jsx3) == null ? void 0 : _jsx3.error) || arrow4.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
    }
    reportReservedArrowTypeParam(node2) {
      var _node$extra;
      node2.params.length === 1 && !node2.params[0].constraint && !((_node$extra = node2.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedArrowTypeParam, node2);
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(refExpressionErrors, sawUnary);
    }
    parseArrow(node2) {
      if (this.match(14)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && abort(), returnType;
        });
        if (result.aborted) return;
        result.thrown || (result.error && (this.state = result.failState), node2.returnType = result.node);
      }
      return super.parseArrow(node2);
    }
    parseAssignableListItemTypes(param, flags) {
      if (!(flags & 2)) return param;
      this.eat(17) && (param.optional = !0);
      const type2 = this.tsTryParseTypeAnnotation();
      return type2 && (param.typeAnnotation = type2), this.resetEndLocation(param), param;
    }
    isAssignable(node2, isBinding) {
      switch (node2.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(node2.expression, isBinding);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(node2, isBinding);
      }
    }
    toAssignable(node2, isLHS = !1) {
      switch (node2.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(node2, isLHS);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          isLHS ? this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node2) : this.raise(TSErrors.UnexpectedTypeCastInParameter, node2), this.toAssignable(node2.expression, isLHS);
          break;
        case "AssignmentExpression":
          !isLHS && node2.left.type === "TSTypeCastExpression" && (node2.left = this.typeCastToParameter(node2.left));
        default:
          super.toAssignable(node2, isLHS);
      }
    }
    toAssignableParenthesizedExpression(node2, isLHS) {
      switch (node2.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(node2.expression, isLHS);
          break;
        default:
          super.toAssignable(node2, isLHS);
      }
    }
    checkToRestConversion(node2, allowPattern) {
      switch (node2.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(node2.expression, !1);
          break;
        default:
          super.checkToRestConversion(node2, allowPattern);
      }
    }
    isValidLVal(type2, isUnparenthesizedInAssign, binding) {
      return getOwn({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", !0],
        TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", !0],
        TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", !0]
      }, type2) || super.isValidLVal(type2, isUnparenthesizedInAssign, binding);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const call2 = super.parseMaybeDecoratorArguments(expr);
          return call2.typeParameters = typeArguments, call2;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(expr);
    }
    checkCommaAfterRest(close) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close ? (this.next(), !1) : super.checkCommaAfterRest(close);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(startLoc, left2) {
      const node2 = super.parseMaybeDefault(startLoc, left2);
      return node2.type === "AssignmentPattern" && node2.typeAnnotation && node2.right.start < node2.typeAnnotation.start && this.raise(TSErrors.TypeAnnotationAfterAssign, node2.typeAnnotation), node2;
    }
    getTokenFromCode(code2) {
      if (this.state.inType) {
        if (code2 === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (code2 === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(code2);
    }
    reScan_lt_gt() {
      const {
        type: type2
      } = this.state;
      type2 === 47 ? (this.state.pos -= 1, this.readToken_lt()) : type2 === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const {
        type: type2
      } = this.state;
      return type2 === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : type2;
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
      for (let i2 = 0; i2 < exprList.length; i2++) {
        const expr = exprList[i2];
        expr?.type === "TSTypeCastExpression" && (exprList[i2] = this.typeCastToParameter(expr));
      }
      super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    }
    typeCastToParameter(node2) {
      return node2.expression.typeAnnotation = node2.typeAnnotation, this.resetEndLocation(node2.expression, node2.typeAnnotation.loc.end), node2.expression;
    }
    shouldParseArrow(params) {
      return this.match(14) ? params.every((expr) => this.isAssignable(expr, !0)) : super.shouldParseArrow(params);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(node2) {
      if (this.match(47) || this.match(51)) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        typeArguments && (node2.typeParameters = typeArguments);
      }
      return super.jsxParseOpeningElementAfterName(node2);
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method), firstParam = this.getObjectOrClassMethodParams(method)[0];
      return firstParam && this.isThisParam(firstParam) ? baseCount + 1 : baseCount;
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam(), type2 = this.tsTryParseTypeAnnotation();
      return type2 && (param.typeAnnotation = type2, this.resetEndLocation(param)), param;
    }
    tsInAmbientContext(cb) {
      const oldIsAmbientContext = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return cb();
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext;
      }
    }
    parseClass(node2, isStatement, optionalId) {
      const oldInAbstractClass = this.state.inAbstractClass;
      this.state.inAbstractClass = !!node2.abstract;
      try {
        return super.parseClass(node2, isStatement, optionalId);
      } finally {
        this.state.inAbstractClass = oldInAbstractClass;
      }
    }
    tsParseAbstractDeclaration(node2, decorators) {
      if (this.match(80))
        return node2.abstract = !0, this.maybeTakeDecorators(decorators, this.parseClass(node2, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return node2.abstract = !0, this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node2), this.tsParseInterfaceDeclaration(node2);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope) {
      const method = super.parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope);
      if (method.abstract && (this.hasPlugin("estree") ? !!method.value.body : !!method.body)) {
        const {
          key: key2
        } = method;
        this.raise(TSErrors.AbstractMethodHasImplementation, method, {
          methodName: key2.type === "Identifier" && !method.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
        });
      }
      return method;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
      return !isString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(node2, !1, isInTypeExport), this.finishNode(node2, "ExportSpecifier")) : (node2.exportKind = "value", super.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly));
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      return !importedIsString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(specifier, !0, isInTypeOnlyImport), this.finishNode(specifier, "ImportSpecifier")) : (specifier.importKind = "value", super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(node2, isImport, isInTypeOnlyImportExport) {
      const leftOfAsKey = isImport ? "imported" : "local", rightOfAsKey = isImport ? "local" : "exported";
      let leftOfAs = node2[leftOfAsKey], rightOfAs, hasTypeSpecifier = !1, canParseAsKeyword = !0;
      const loc = leftOfAs.loc.start;
      if (this.isContextual(93)) {
        const firstAs = this.parseIdentifier();
        if (this.isContextual(93)) {
          const secondAs = this.parseIdentifier();
          tokenIsKeywordOrIdentifier(this.state.type) ? (hasTypeSpecifier = !0, leftOfAs = firstAs, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName(), canParseAsKeyword = !1) : (rightOfAs = secondAs, canParseAsKeyword = !1);
        } else tokenIsKeywordOrIdentifier(this.state.type) ? (canParseAsKeyword = !1, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName()) : (hasTypeSpecifier = !0, leftOfAs = firstAs);
      } else tokenIsKeywordOrIdentifier(this.state.type) && (hasTypeSpecifier = !0, isImport ? (leftOfAs = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, !0, !0)) : leftOfAs = this.parseModuleExportName());
      hasTypeSpecifier && isInTypeOnlyImportExport && this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc), node2[leftOfAsKey] = leftOfAs, node2[rightOfAsKey] = rightOfAs;
      const kindKey = isImport ? "importKind" : "exportKind";
      node2[kindKey] = hasTypeSpecifier ? "type" : "value", canParseAsKeyword && this.eatContextual(93) && (node2[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName()), node2[rightOfAsKey] || (node2[rightOfAsKey] = cloneIdentifier(node2[leftOfAsKey])), isImport && this.checkIdentifier(node2[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
    }
  };
  function isPossiblyLiteralEnum(expression) {
    if (expression.type !== "MemberExpression") return !1;
    const {
      computed,
      property
    } = expression;
    return computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0) ? !1 : isUncomputedMemberExpressionChain(expression.object);
  }
  function isValidAmbientConstInitializer(expression, estree2) {
    var _expression$extra;
    const {
      type: type2
    } = expression;
    if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized)
      return !1;
    if (estree2) {
      if (type2 === "Literal") {
        const {
          value
        } = expression;
        if (typeof value == "string" || typeof value == "boolean")
          return !0;
      }
    } else if (type2 === "StringLiteral" || type2 === "BooleanLiteral")
      return !0;
    return !!(isNumber2(expression, estree2) || isNegativeNumber(expression, estree2) || type2 === "TemplateLiteral" && expression.expressions.length === 0 || isPossiblyLiteralEnum(expression));
  }
  function isNumber2(expression, estree2) {
    return estree2 ? expression.type === "Literal" && (typeof expression.value == "number" || "bigint" in expression) : expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
  }
  function isNegativeNumber(expression, estree2) {
    if (expression.type === "UnaryExpression") {
      const {
        operator,
        argument
      } = expression;
      if (operator === "-" && isNumber2(argument, estree2))
        return !0;
    }
    return !1;
  }
  function isUncomputedMemberExpressionChain(expression) {
    return expression.type === "Identifier" ? !0 : expression.type !== "MemberExpression" || expression.computed ? !1 : isUncomputedMemberExpressionChain(expression.object);
  }
  const PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var placeholders = (superClass) => class extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(144)) {
        const node2 = this.startNode();
        return this.next(), this.assertNoSpace(), node2.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(node2, expectedNode);
      }
    }
    finishPlaceholder(node2, expectedNode) {
      let placeholder = node2;
      return (!placeholder.expectedNode || !placeholder.type) && (placeholder = this.finishNode(placeholder, "Placeholder")), placeholder.expectedNode = expectedNode, placeholder;
    }
    getTokenFromCode(code2) {
      code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(code2);
    }
    parseExprAtom(refExpressionErrors) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
    }
    parseIdentifier(liberal) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      word !== void 0 && super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(type2, isParenthesized, binding) {
      return type2 === "Placeholder" || super.isValidLVal(type2, isParenthesized, binding);
    }
    toAssignable(node2, isLHS) {
      node2 && node2.type === "Placeholder" && node2.expectedNode === "Expression" ? node2.expectedNode = "Pattern" : super.toAssignable(node2, isLHS);
    }
    chStartsBindingIdentifier(ch, pos2) {
      return !!(super.chStartsBindingIdentifier(ch, pos2) || this.lookahead().type === 144);
    }
    verifyBreakContinue(node2, isBreak) {
      node2.label && node2.label.type === "Placeholder" || super.verifyBreakContinue(node2, isBreak);
    }
    parseExpressionStatement(node2, expr) {
      var _expr$extra;
      if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized)
        return super.parseExpressionStatement(node2, expr);
      if (this.match(14)) {
        const stmt = node2;
        return stmt.label = this.finishPlaceholder(expr, "Identifier"), this.next(), stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(stmt, "LabeledStatement");
      }
      this.semicolon();
      const stmtPlaceholder = node2;
      return stmtPlaceholder.name = expr.name, this.finishPlaceholder(stmtPlaceholder, "Statement");
    }
    parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    }
    parseFunctionId(requireId) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
    }
    parseClass(node2, isStatement, optionalId) {
      const type2 = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const oldStrict = this.state.strict, placeholder = this.parsePlaceholder("Identifier");
      if (placeholder)
        if (this.match(81) || this.match(144) || this.match(5))
          node2.id = placeholder;
        else {
          if (optionalId || !isStatement)
            return node2.id = null, node2.body = this.finishPlaceholder(placeholder, "ClassBody"), this.finishNode(node2, type2);
          throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(node2, isStatement, optionalId);
      return super.parseClassSuper(node2), node2.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node2.superClass, oldStrict), this.finishNode(node2, type2);
    }
    parseExport(node2, decorators) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseExport(node2, decorators);
      const node22 = node2;
      if (!this.isContextual(98) && !this.match(12))
        return node22.specifiers = [], node22.source = null, node22.declaration = this.finishPlaceholder(placeholder, "Declaration"), this.finishNode(node22, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      return specifier.exported = placeholder, node22.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], super.parseExport(node22, decorators);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const next = this.nextTokenStart();
        if (this.isUnparsedContextual(next, "from") && this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
      var _specifiers;
      return (_specifiers = node2.specifiers) != null && _specifiers.length ? !0 : super.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier);
    }
    checkExport(node2) {
      const {
        specifiers
      } = node2;
      specifiers != null && specifiers.length && (node2.specifiers = specifiers.filter((node3) => node3.exported.type === "Placeholder")), super.checkExport(node2), node2.specifiers = specifiers;
    }
    parseImport(node2) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseImport(node2);
      if (node2.specifiers = [], !this.isContextual(98) && !this.match(12))
        return node2.source = this.finishPlaceholder(placeholder, "StringLiteral"), this.semicolon(), this.finishNode(node2, "ImportDeclaration");
      const specifier = this.startNodeAtNode(placeholder);
      return specifier.local = placeholder, node2.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(node2) || this.parseNamedImportSpecifiers(node2)), this.expectContextual(98), node2.source = this.parseImportSource(), this.semicolon(), this.finishNode(node2, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, v8intrinsic = (superClass) => class extends superClass {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const v8IntrinsicStartLoc = this.state.startLoc, node2 = this.startNode();
        if (this.next(), tokenIsIdentifier(this.state.type)) {
          const name = this.parseIdentifierName(), identifier = this.createIdentifier(node2, name);
          if (identifier.type = "V8IntrinsicIdentifier", this.match(10))
            return identifier;
        }
        this.unexpected(v8IntrinsicStartLoc);
      }
    }
    parseExprAtom(refExpressionErrors) {
      return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    }
  };
  function hasPlugin(plugins, expectedConfig) {
    const [expectedName, expectedOptions] = typeof expectedConfig == "string" ? [expectedConfig, {}] : expectedConfig, expectedKeys = Object.keys(expectedOptions), expectedOptionsIsEmpty = expectedKeys.length === 0;
    return plugins.some((p) => {
      if (typeof p == "string")
        return expectedOptionsIsEmpty && p === expectedName;
      {
        const [pluginName, pluginOptions] = p;
        if (pluginName !== expectedName)
          return !1;
        for (const key2 of expectedKeys)
          if (pluginOptions[key2] !== expectedOptions[key2])
            return !1;
        return !0;
      }
    });
  }
  function getPluginOption(plugins, name, option) {
    const plugin = plugins.find((plugin2) => Array.isArray(plugin2) ? plugin2[0] === name : plugin2 === name);
    return plugin && Array.isArray(plugin) && plugin.length > 1 ? plugin[1][option] : null;
  }
  const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"], TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"], RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
      if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
      if (allowCallParenthesized != null && typeof allowCallParenthesized != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (hasPlugin(plugins, "pipelineOperator")) {
      const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
      if (!PIPELINE_PROPOSALS.includes(proposal)) {
        const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
      }
      const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (proposal === "hack") {
        if (hasPlugin(plugins, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (hasPlugin(plugins, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
        if (!TOPIC_TOKENS.includes(topicToken)) {
          const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
        }
        if (topicToken === "#" && tupleSyntaxIsHash)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (proposal === "smart" && tupleSyntaxIsHash)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (hasPlugin(plugins, "moduleAttributes")) {
      if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (getPluginOption(plugins, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
      const error2 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw error2.missingPlugins = "doExpressions", error2;
    }
    if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  const mixinPlugins = {
    estree,
    jsx: jsx2,
    flow: flow2,
    typescript: typescript2,
    v8intrinsic,
    placeholders
  }, mixinPluginNames = Object.keys(mixinPlugins), defaultOptions2 = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function getOptions(opts) {
    if (opts == null)
      return Object.assign({}, defaultOptions2);
    if (opts.annexB != null && opts.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    const options2 = {};
    for (const key2 of Object.keys(defaultOptions2)) {
      var _opts$key;
      options2[key2] = (_opts$key = opts[key2]) != null ? _opts$key : defaultOptions2[key2];
    }
    return options2;
  }
  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand)
        return;
      const key2 = prop.key;
      if ((key2.type === "Identifier" ? key2.name : key2.value) === "__proto__") {
        if (isRecord) {
          this.raise(Errors.RecordNoProto, key2);
          return;
        }
        protoRef.used && (refExpressionErrors ? refExpressionErrors.doubleProtoLoc === null && (refExpressionErrors.doubleProtoLoc = key2.loc.start) : this.raise(Errors.DuplicateProto, key2)), protoRef.used = !0;
      }
    }
    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const expr = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), expr.comments = this.comments, expr.errors = this.state.errors, this.options.tokens && (expr.tokens = this.tokens), expr;
    }
    parseExpression(disallowIn, refExpressionErrors) {
      return disallowIn ? this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors)) : this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    parseExpressionBase(refExpressionErrors) {
      const startLoc = this.state.startLoc, expr = this.parseMaybeAssign(refExpressionErrors);
      if (this.match(12)) {
        const node2 = this.startNodeAt(startLoc);
        for (node2.expressions = [expr]; this.eat(12); )
          node2.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        return this.toReferencedList(node2.expressions), this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$loc;
      refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError?.loc) != null ? _resultError$loc : this.state.startLoc;
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      const startLoc = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let left3 = this.parseYield();
        return afterLeftParse && (left3 = afterLeftParse.call(this, left3, startLoc)), left3;
      }
      let ownExpressionErrors;
      refExpressionErrors ? ownExpressionErrors = !1 : (refExpressionErrors = new ExpressionErrors(), ownExpressionErrors = !0);
      const {
        type: type2
      } = this.state;
      (type2 === 10 || tokenIsIdentifier(type2)) && (this.state.potentialArrowAt = this.state.start);
      let left2 = this.parseMaybeConditional(refExpressionErrors);
      if (afterLeftParse && (left2 = afterLeftParse.call(this, left2, startLoc)), tokenIsAssignment(this.state.type)) {
        const node2 = this.startNodeAt(startLoc), operator = this.state.value;
        if (node2.operator = operator, this.match(29)) {
          this.toAssignable(left2, !0), node2.left = left2;
          const startIndex = startLoc.index;
          refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex && (refExpressionErrors.doubleProtoLoc = null), refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex && (refExpressionErrors.shorthandAssignLoc = null), refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex && (this.checkDestructuringPrivate(refExpressionErrors), refExpressionErrors.privateKeyLoc = null);
        } else
          node2.left = left2;
        return this.next(), node2.right = this.parseMaybeAssign(), this.checkLVal(left2, {
          in: this.finishNode(node2, "AssignmentExpression")
        }), node2;
      } else ownExpressionErrors && this.checkExpressionErrors(refExpressionErrors, !0);
      return left2;
    }
    parseMaybeConditional(refExpressionErrors) {
      const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprOps(refExpressionErrors);
      return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
      if (this.eat(17)) {
        const node2 = this.startNodeAt(startLoc);
        return node2.test = expr, node2.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), node2.alternate = this.parseMaybeAssign(), this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    }
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    parseExprOps(refExpressionErrors) {
      const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
      return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseExprOp(expr, startLoc, -1);
    }
    parseExprOp(left2, leftStartLoc, minPrec) {
      if (this.isPrivateName(left2)) {
        const value = this.getPrivateNameSV(left2);
        (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Errors.PrivateInExpectedIn, left2, {
          identifierName: value
        }), this.classScope.usePrivateName(value, left2.loc.start);
      }
      const op = this.state.type;
      if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
        let prec = tokenOperatorPrecedence(op);
        if (prec > minPrec) {
          if (op === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return left2;
            this.checkPipelineAtInfixOperator(left2, leftStartLoc);
          }
          const node2 = this.startNodeAt(leftStartLoc);
          node2.left = left2, node2.operator = this.state.value;
          const logical = op === 41 || op === 42, coalesce = op === 40;
          if (coalesce && (prec = tokenOperatorPrecedence(42)), this.next(), op === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          node2.right = this.parseExprOpRightExpr(op, prec);
          const finishedNode = this.finishNode(node2, logical || coalesce ? "LogicalExpression" : "BinaryExpression"), nextOp = this.state.type;
          if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40)
            throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
        }
      }
      return left2;
    }
    parseExprOpRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      switch (op) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(prec));
          }
        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
    parseExprOpBaseRightExpr(op, prec) {
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
    parseHackPipeBody() {
      var _body$extra;
      const {
        startLoc
      } = this.state, body = this.parseMaybeAssign();
      return UnparenthesizedPipeBodyDescriptions.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized) && this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
        type: body.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipeTopicUnused, startLoc), body;
    }
    checkExponentialAfterUnary(node2) {
      this.match(57) && this.raise(Errors.UnexpectedTokenUnaryExponentiation, node2.argument);
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startLoc = this.state.startLoc, isAwait = this.isContextual(96);
      if (isAwait && this.isAwaitAllowed()) {
        this.next();
        const expr2 = this.parseAwait(startLoc);
        return sawUnary || this.checkExponentialAfterUnary(expr2), expr2;
      }
      const update = this.match(34), node2 = this.startNode();
      if (tokenIsPrefix(this.state.type)) {
        node2.operator = this.state.value, node2.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        const isDelete = this.match(89);
        if (this.next(), node2.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(refExpressionErrors, !0), this.state.strict && isDelete) {
          const arg = node2.argument;
          arg.type === "Identifier" ? this.raise(Errors.StrictDelete, node2) : this.hasPropertyAsPrivateName(arg) && this.raise(Errors.DeletePrivateField, node2);
        }
        if (!update)
          return sawUnary || this.checkExponentialAfterUnary(node2), this.finishNode(node2, "UnaryExpression");
      }
      const expr = this.parseUpdate(node2, update, refExpressionErrors);
      if (isAwait) {
        const {
          type: type2
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc), this.parseAwait(startLoc);
      }
      return expr;
    }
    parseUpdate(node2, update, refExpressionErrors) {
      if (update) {
        const updateExpressionNode = node2;
        return this.checkLVal(updateExpressionNode.argument, {
          in: this.finishNode(updateExpressionNode, "UpdateExpression")
        }), node2;
      }
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, !1)) return expr;
      for (; tokenIsPostfix(this.state.type) && !this.canInsertSemicolon(); ) {
        const node3 = this.startNodeAt(startLoc);
        node3.operator = this.state.value, node3.prefix = !1, node3.argument = expr, this.next(), this.checkLVal(expr, {
          in: expr = this.finishNode(node3, "UpdateExpression")
        });
      }
      return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
      const startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprAtom(refExpressionErrors);
      return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseSubscripts(expr, startLoc);
    }
    parseSubscripts(base2, startLoc, noCalls) {
      const state2 = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base2),
        stop: !1
      };
      do
        base2 = this.parseSubscript(base2, startLoc, noCalls, state2), state2.maybeAsyncArrow = !1;
      while (!state2.stop);
      return base2;
    }
    parseSubscript(base2, startLoc, noCalls, state2) {
      const {
        type: type2
      } = this.state;
      if (!noCalls && type2 === 15)
        return this.parseBind(base2, startLoc, noCalls, state2);
      if (tokenIsTemplate(type2))
        return this.parseTaggedTemplateExpression(base2, startLoc, state2);
      let optional = !1;
      if (type2 === 18) {
        if (noCalls && (this.raise(Errors.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return state2.stop = !0, base2;
        state2.optionalChainMember = optional = !0, this.next();
      }
      if (!noCalls && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(base2, startLoc, state2, optional);
      {
        const computed = this.eat(0);
        return computed || optional || this.eat(16) ? this.parseMember(base2, startLoc, state2, computed, optional) : (state2.stop = !0, base2);
      }
    }
    parseMember(base2, startLoc, state2, computed, optional) {
      const node2 = this.startNodeAt(startLoc);
      return node2.object = base2, node2.computed = computed, computed ? (node2.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (base2.type === "Super" && this.raise(Errors.SuperPrivateField, startLoc), this.classScope.usePrivateName(this.state.value, this.state.startLoc), node2.property = this.parsePrivateName()) : node2.property = this.parseIdentifier(!0), state2.optionalChainMember ? (node2.optional = optional, this.finishNode(node2, "OptionalMemberExpression")) : this.finishNode(node2, "MemberExpression");
    }
    parseBind(base2, startLoc, noCalls, state2) {
      const node2 = this.startNodeAt(startLoc);
      return node2.object = base2, this.next(), node2.callee = this.parseNoCallExpr(), state2.stop = !0, this.parseSubscripts(this.finishNode(node2, "BindExpression"), startLoc, noCalls);
    }
    parseCoverCallAndAsyncArrowHead(base2, startLoc, state2, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      let refExpressionErrors = null;
      this.state.maybeInArrowParameters = !0, this.next();
      const node2 = this.startNodeAt(startLoc);
      node2.callee = base2;
      const {
        maybeAsyncArrow,
        optionalChainMember
      } = state2;
      maybeAsyncArrow && (this.expressionScope.enter(newAsyncArrowScope()), refExpressionErrors = new ExpressionErrors()), optionalChainMember && (node2.optional = optional), optional ? node2.arguments = this.parseCallExpressionArguments(11) : node2.arguments = this.parseCallExpressionArguments(11, base2.type === "Import", base2.type !== "Super", node2, refExpressionErrors);
      let finishedNode = this.finishCallExpression(node2, optionalChainMember);
      return maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional ? (state2.stop = !0, this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode)) : (maybeAsyncArrow && (this.checkExpressionErrors(refExpressionErrors, !0), this.expressionScope.exit()), this.toReferencedArguments(finishedNode)), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, finishedNode;
    }
    toReferencedArguments(node2, isParenthesizedExpr) {
      this.toReferencedListDeep(node2.arguments, isParenthesizedExpr);
    }
    parseTaggedTemplateExpression(base2, startLoc, state2) {
      const node2 = this.startNodeAt(startLoc);
      return node2.tag = base2, node2.quasi = this.parseTemplate(!0), state2.optionalChainMember && this.raise(Errors.OptionalChainingNoTemplate, startLoc), this.finishNode(node2, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base2) {
      return base2.type === "Identifier" && base2.name === "async" && this.state.lastTokEndLoc.index === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && base2.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(node2, optional) {
      if (node2.callee.type === "Import")
        if (node2.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), node2.arguments.length === 0 || node2.arguments.length > 2)
          this.raise(Errors.ImportCallArity, node2, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          });
        else
          for (const arg of node2.arguments)
            arg.type === "SpreadElement" && this.raise(Errors.ImportCallSpreadArgument, arg);
      return this.finishNode(node2, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      const elts = [];
      let first2 = !0;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(close); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.match(close)) {
          dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
          break;
        }
        elts.push(this.parseExprListItem(!1, refExpressionErrors, allowPlaceholder));
      }
      return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, elts;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node2, call2) {
      var _call$extra;
      return this.resetPreviousNodeTrailingComments(call2), this.expect(19), this.parseArrowExpression(node2, call2.arguments, !0, (_call$extra = call2.extra) == null ? void 0 : _call$extra.trailingCommaLoc), call2.innerComments && setInnerComments(node2, call2.innerComments), call2.callee.trailingComments && setInnerComments(node2, call2.callee.trailingComments), node2;
    }
    parseNoCallExpr() {
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startLoc, !0);
    }
    parseExprAtom(refExpressionErrors) {
      let node2, decorators = null;
      const {
        type: type2
      } = this.state;
      switch (type2) {
        case 79:
          return this.parseSuper();
        case 83:
          return node2 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(node2) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(node2) : this.finishNode(node2, "Import") : (this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(node2, "Import"));
        case 78:
          return node2 = this.startNode(), this.next(), this.finishNode(node2, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, refExpressionErrors);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, refExpressionErrors);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          decorators = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          node2 = this.startNode(), this.next(), node2.object = null;
          const callee = node2.callee = this.parseNoCallExpr();
          if (callee.type === "MemberExpression")
            return this.finishNode(node2, "BindExpression");
          throw this.raise(Errors.UnsupportedBind, callee);
        }
        case 138:
          return this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal)
            return this.parseTopicReference(pipeProposal);
          this.unexpected();
          break;
        }
        case 47: {
          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
          isIdentifierStart(lookaheadCh) || lookaheadCh === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (tokenIsIdentifier(type2)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            const canBeArrow = this.state.potentialArrowAt === this.state.start, containsEsc = this.state.containsEsc, id = this.parseIdentifier();
            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              const {
                type: type3
              } = this.state;
              if (type3 === 68)
                return this.resetPreviousNodeTrailingComments(id), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
              if (tokenIsIdentifier(type3))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)) : id;
              if (type3 === 90)
                return this.resetPreviousNodeTrailingComments(id), this.parseDo(this.startNodeAtNode(id), !0);
            }
            return canBeArrow && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(id), [id], !1)) : id;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
      const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
      if (pipeProposal)
        return this.state.type = topicTokenType, this.state.value = topicTokenValue, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(pipeProposal);
      this.unexpected();
    }
    parseTopicReference(pipeProposal) {
      const node2 = this.startNode(), startLoc = this.state.startLoc, tokenType = this.state.type;
      return this.next(), this.finishTopicReference(node2, startLoc, pipeProposal, tokenType);
    }
    finishTopicReference(node2, startLoc, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
        const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc), this.registerTopicReference(), this.finishNode(node2, nodeType);
      } else
        throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
          token: tokenLabelName(tokenType)
        });
    }
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
      switch (pipeProposal) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: tokenLabelName(tokenType)
          }]);
        case "smart":
          return tokenType === 27;
        default:
          throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
      }
    }
    parseAsyncArrowUnaryFunction(node2) {
      this.prodParam.enter(functionFlags(!0, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(node2, params, !0);
    }
    parseDo(node2, isAsync) {
      this.expectPlugin("doExpressions"), isAsync && this.expectPlugin("asyncDoExpressions"), node2.async = isAsync, this.next();
      const oldLabels = this.state.labels;
      return this.state.labels = [], isAsync ? (this.prodParam.enter(2), node2.body = this.parseBlock(), this.prodParam.exit()) : node2.body = this.parseBlock(), this.state.labels = oldLabels, this.finishNode(node2, "DoExpression");
    }
    parseSuper() {
      const node2 = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(Errors.SuperNotAllowed, node2) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(Errors.UnexpectedSuper, node2), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(Errors.UnsupportedSuper, node2), this.finishNode(node2, "Super");
    }
    parsePrivateName() {
      const node2 = this.startNode(), id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1)), name = this.state.value;
      return this.next(), node2.id = this.createIdentifier(id, name), this.finishNode(node2, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const node2 = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node2), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(node2, meta, "sent");
      }
      return this.parseFunction(node2);
    }
    parseMetaProperty(node2, meta, propertyName) {
      node2.meta = meta;
      const containsEsc = this.state.containsEsc;
      return node2.property = this.parseIdentifier(!0), (node2.property.name !== propertyName || containsEsc) && this.raise(Errors.UnsupportedMetaProperty, node2.property, {
        target: meta.name,
        onlyValidPropertyName: propertyName
      }), this.finishNode(node2, "MetaProperty");
    }
    parseImportMetaProperty(node2) {
      const id = this.createIdentifier(this.startNodeAtNode(node2), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(Errors.ImportMetaOutsideModule, id), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        const isSource = this.isContextual(105);
        if (isSource || this.unexpected(), this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), node2.phase = isSource ? "source" : "defer", this.parseImportCall(node2);
      }
      return this.parseMetaProperty(node2, id, "meta");
    }
    parseLiteralAtNode(value, type2, node2) {
      return this.addExtra(node2, "rawValue", value), this.addExtra(node2, "raw", this.input.slice(node2.start, this.state.end)), node2.value = value, this.next(), this.finishNode(node2, type2);
    }
    parseLiteral(value, type2) {
      const node2 = this.startNode();
      return this.parseLiteralAtNode(value, type2, node2);
    }
    parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }
    parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }
    parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    }
    parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }
    parseRegExpLiteral(value) {
      const node2 = this.parseLiteral(value.value, "RegExpLiteral");
      return node2.pattern = value.pattern, node2.flags = value.flags, node2;
    }
    parseBooleanLiteral(value) {
      const node2 = this.startNode();
      return node2.value = value, this.next(), this.finishNode(node2, "BooleanLiteral");
    }
    parseNullLiteral() {
      const node2 = this.startNode();
      return this.next(), this.finishNode(node2, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      const startLoc = this.state.startLoc;
      let val;
      this.next(), this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      const innerStartLoc = this.state.startLoc, exprList = [], refExpressionErrors = new ExpressionErrors();
      let first2 = !0, spreadStartLoc, optionalCommaStartLoc;
      for (; !this.match(11); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc), this.match(11)) {
          optionalCommaStartLoc = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          if (spreadStartLoc = this.state.startLoc, exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc)), !this.checkCommaAfterRest(41))
            break;
        } else
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
      }
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startLoc);
      return canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode)) ? (this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(arrowNode, exprList, !1), arrowNode) : (this.expressionScope.exit(), exprList.length || this.unexpected(this.state.lastTokStartLoc), optionalCommaStartLoc && this.unexpected(optionalCommaStartLoc), spreadStartLoc && this.unexpected(spreadStartLoc), this.checkExpressionErrors(refExpressionErrors, !0), this.toReferencedListDeep(exprList, !0), exprList.length > 1 ? (val = this.startNodeAt(innerStartLoc), val.expressions = exprList, this.finishNode(val, "SequenceExpression"), this.resetEndLocation(val, innerEndLoc)) : val = exprList[0], this.wrapParenthesis(startLoc, val));
    }
    wrapParenthesis(startLoc, expression) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(expression, "parenthesized", !0), this.addExtra(expression, "parenStart", startLoc.index), this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index), expression;
      const parenExpression = this.startNodeAt(startLoc);
      return parenExpression.expression = expression, this.finishNode(parenExpression, "ParenthesizedExpression");
    }
    shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
    parseArrow(node2) {
      if (this.eat(19))
        return node2;
    }
    parseParenItem(node2, startLoc) {
      return node2;
    }
    parseNewOrNewTarget() {
      const node2 = this.startNode();
      if (this.next(), this.match(16)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node2), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node2, meta, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(Errors.UnexpectedNewTarget, metaProp), metaProp;
      }
      return this.parseNew(node2);
    }
    parseNew(node2) {
      if (this.parseNewCallee(node2), this.eat(10)) {
        const args = this.parseExprList(11);
        this.toReferencedList(args), node2.arguments = args;
      } else
        node2.arguments = [];
      return this.finishNode(node2, "NewExpression");
    }
    parseNewCallee(node2) {
      const isImport = this.match(83), callee = this.parseNoCallExpr();
      node2.callee = callee, isImport && (callee.type === "Import" || callee.type === "ImportExpression") && this.raise(Errors.ImportCallNotNewExpression, callee);
    }
    parseTemplateElement(isTagged) {
      const {
        start,
        startLoc,
        end: end2,
        value
      } = this.state, elemStart = start + 1, elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
      value === null && (isTagged || this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)));
      const isTail = this.match(24), endOffset = isTail ? -1 : -2, elemEnd = end2 + endOffset;
      elem.value = {
        raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, `
`),
        cooked: value === null ? null : value.slice(1, endOffset)
      }, elem.tail = isTail, this.next();
      const finishedNode = this.finishNode(elem, "TemplateElement");
      return this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset)), finishedNode;
    }
    parseTemplate(isTagged) {
      const node2 = this.startNode();
      let curElt = this.parseTemplateElement(isTagged);
      const quasis = [curElt], substitutions = [];
      for (; !curElt.tail; )
        substitutions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), quasis.push(curElt = this.parseTemplateElement(isTagged));
      return node2.expressions = substitutions, node2.quasis = quasis, this.finishNode(node2, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      isRecord && this.expectPlugin("recordAndTuple");
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const propHash = /* @__PURE__ */ Object.create(null);
      let first2 = !0;
      const node2 = this.startNode();
      for (node2.properties = [], this.next(); !this.match(close); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.match(close)) {
          this.addTrailingCommaExtraToNode(node2);
          break;
        }
        let prop;
        isPattern ? prop = this.parseBindingProperty() : (prop = this.parsePropertyDefinition(refExpressionErrors), this.checkProto(prop, isRecord, propHash, refExpressionErrors)), isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement" && this.raise(Errors.InvalidRecordProperty, prop), prop.shorthand && this.addExtra(prop, "shorthand", !0), node2.properties.push(prop);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type2 = "ObjectExpression";
      return isPattern ? type2 = "ObjectPattern" : isRecord && (type2 = "RecordExpression"), this.finishNode(node2, type2);
    }
    addTrailingCommaExtraToNode(node2) {
      this.addExtra(node2, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(node2, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(refExpressionErrors) {
      let decorators = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          decorators.push(this.parseDecorator());
      const prop = this.startNode();
      let isAsync = !1, isAccessor = !1, startLoc;
      if (this.match(21))
        return decorators.length && this.unexpected(), this.parseSpread();
      decorators.length && (prop.decorators = decorators, decorators = []), prop.method = !1, refExpressionErrors && (startLoc = this.state.startLoc);
      let isGenerator = this.eat(55);
      this.parsePropertyNamePrefixOperator(prop);
      const containsEsc = this.state.containsEsc;
      if (this.parsePropertyName(prop, refExpressionErrors), !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const {
          key: key2
        } = prop, keyName = key2.name;
        keyName === "async" && !this.hasPrecedingLineBreak() && (isAsync = !0, this.resetPreviousNodeTrailingComments(key2), isGenerator = this.eat(55), this.parsePropertyName(prop)), (keyName === "get" || keyName === "set") && (isAccessor = !0, this.resetPreviousNodeTrailingComments(key2), prop.kind = keyName, this.match(55) && (isGenerator = !0, this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
          kind: keyName
        }), this.next()), this.parsePropertyName(prop));
      }
      return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, !1, isAccessor, refExpressionErrors);
    }
    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method) {
      return method.params;
    }
    checkGetterSetterParams(method) {
      var _params;
      const paramCount = this.getGetterSetterExpectedParamCount(method), params = this.getObjectOrClassMethodParams(method);
      params.length !== paramCount && this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method), method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement" && this.raise(Errors.BadSetterRestParameter, method);
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        const finishedProp = this.parseMethod(prop, isGenerator, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(finishedProp), finishedProp;
      }
      if (isAsync || isGenerator || this.match(10))
        return isPattern && this.unexpected(), prop.kind = "method", prop.method = !0, this.parseMethod(prop, isGenerator, isAsync, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      if (prop.shorthand = !1, this.eat(14))
        return prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors), this.finishNode(prop, "ObjectProperty");
      if (!prop.computed && prop.key.type === "Identifier") {
        if (this.checkReservedWord(prop.key.name, prop.key.loc.start, !0, !1), isPattern)
          prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        else if (this.match(29)) {
          const shorthandAssignLoc = this.state.startLoc;
          refExpressionErrors != null ? refExpressionErrors.shorthandAssignLoc === null && (refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc) : this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc), prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
        } else
          prop.value = cloneIdentifier(prop.key);
        return prop.shorthand = !0, this.finishNode(prop, "ObjectProperty");
      }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const node2 = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      return node2 || this.unexpected(), node2;
    }
    parsePropertyName(prop, refExpressionErrors) {
      if (this.eat(0))
        prop.computed = !0, prop.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const {
          type: type2,
          value
        } = this.state;
        let key2;
        if (tokenIsKeywordOrIdentifier(type2))
          key2 = this.parseIdentifier(!0);
        else
          switch (type2) {
            case 134:
              key2 = this.parseNumericLiteral(value);
              break;
            case 133:
              key2 = this.parseStringLiteral(value);
              break;
            case 135:
              key2 = this.parseBigIntLiteral(value);
              break;
            case 136:
              key2 = this.parseDecimalLiteral(value);
              break;
            case 138: {
              const privateKeyLoc = this.state.startLoc;
              refExpressionErrors != null ? refExpressionErrors.privateKeyLoc === null && (refExpressionErrors.privateKeyLoc = privateKeyLoc) : this.raise(Errors.UnexpectedPrivateField, privateKeyLoc), key2 = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        prop.key = key2, type2 !== 138 && (prop.computed = !1);
      }
    }
    initFunction(node2, isAsync) {
      node2.id = null, node2.generator = !1, node2.async = isAsync;
    }
    parseMethod(node2, isGenerator, isAsync, isConstructor, allowDirectSuper, type2, inClassScope = !1) {
      this.initFunction(node2, isAsync), node2.generator = isGenerator, this.scope.enter(18 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0)), this.prodParam.enter(functionFlags(isAsync, node2.generator)), this.parseFunctionParams(node2, isConstructor);
      const finishedNode = this.parseFunctionBodyAndFinish(node2, type2, !0);
      return this.prodParam.exit(), this.scope.exit(), finishedNode;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      isTuple && this.expectPlugin("recordAndTuple");
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      const node2 = this.startNode();
      return this.next(), node2.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node2), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, this.finishNode(node2, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node2, params, isAsync, trailingCommaLoc) {
      this.scope.enter(6);
      let flags = functionFlags(isAsync, !1);
      !this.match(5) && this.prodParam.hasIn && (flags |= 8), this.prodParam.enter(flags), this.initFunction(node2, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      return params && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(node2, params, trailingCommaLoc)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(node2, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.finishNode(node2, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node2, params, trailingCommaLoc) {
      this.toAssignableList(params, trailingCommaLoc, !1), node2.params = params;
    }
    parseFunctionBodyAndFinish(node2, type2, isMethod = !1) {
      return this.parseFunctionBody(node2, !1, isMethod), this.finishNode(node2, type2);
    }
    parseFunctionBody(node2, allowExpression, isMethod = !1) {
      const isExpression = allowExpression && !this.match(5);
      if (this.expressionScope.enter(newExpressionScope()), isExpression)
        node2.body = this.parseMaybeAssign(), this.checkParams(node2, !1, allowExpression, !1);
      else {
        const oldStrict = this.state.strict, oldLabels = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), node2.body = this.parseBlock(!0, !1, (hasStrictModeDirective) => {
          const nonSimple = !this.isSimpleParamList(node2.params);
          hasStrictModeDirective && nonSimple && this.raise(Errors.IllegalLanguageModeDirective, (node2.kind === "method" || node2.kind === "constructor") && node2.key ? node2.key.loc.end : node2);
          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node2, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged), this.state.strict && node2.id && this.checkIdentifier(node2.id, 65, strictModeChanged);
        }), this.prodParam.exit(), this.state.labels = oldLabels;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(node2) {
      return node2.type === "Identifier";
    }
    isSimpleParamList(params) {
      for (let i2 = 0, len = params.length; i2 < len; i2++)
        if (!this.isSimpleParameter(params[i2])) return !1;
      return !0;
    }
    checkParams(node2, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
      const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set(), formalParameters = {
        type: "FormalParameters"
      };
      for (const param of node2.params)
        this.checkLVal(param, {
          in: formalParameters,
          binding: 5,
          checkClashes,
          strictModeChanged
        });
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first2 = !0;
      for (; !this.eat(close); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.match(close)) {
          nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
          break;
        }
        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }
      return elts;
    }
    parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      let elt;
      if (this.match(12))
        allowEmpty || this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), elt = null;
      else if (this.match(21)) {
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), allowPlaceholder || this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const node2 = this.startNode();
        this.next(), elt = this.finishNode(node2, "ArgumentPlaceholder");
      } else
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      return elt;
    }
    parseIdentifier(liberal) {
      const node2 = this.startNode(), name = this.parseIdentifierName(liberal);
      return this.createIdentifier(node2, name);
    }
    createIdentifier(node2, name) {
      return node2.name = name, node2.loc.identifierName = name, this.finishNode(node2, "Identifier");
    }
    parseIdentifierName(liberal) {
      let name;
      const {
        startLoc,
        type: type2
      } = this.state;
      tokenIsKeywordOrIdentifier(type2) ? name = this.state.value : this.unexpected();
      const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type2);
      return liberal ? tokenIsKeyword2 && this.replaceToken(132) : this.checkReservedWord(name, startLoc, tokenIsKeyword2, !1), this.next(), name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10 || !canBeReservedWord(word))
        return;
      if (checkKeywords && isKeyword(word)) {
        this.raise(Errors.UnexpectedKeyword, startLoc, {
          keyword: word
        });
        return;
      }
      if ((this.state.strict ? isBinding ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(word, this.inModule)) {
        this.raise(Errors.UnexpectedReservedWord, startLoc, {
          reservedWord: word
        });
        return;
      } else if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Errors.YieldBindingIdentifier, startLoc);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Errors.AwaitBindingIdentifier, startLoc);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(startLoc);
      } else if (word === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(Errors.ArgumentsInClass, startLoc);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(startLoc) {
      const node2 = this.startNodeAt(startLoc);
      return this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node2), this.eat(55) && this.raise(Errors.ObsoleteAwaitStar, node2), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (node2.argument = this.parseMaybeUnary(null, !0)), this.finishNode(node2, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      const {
        type: type2
      } = this.state;
      return type2 === 53 || type2 === 10 || type2 === 0 || tokenIsTemplate(type2) || type2 === 102 && !this.state.containsEsc || type2 === 137 || type2 === 56 || this.hasPlugin("v8intrinsic") && type2 === 54;
    }
    parseYield() {
      const node2 = this.startNode();
      this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node2), this.next();
      let delegating = !1, argument = null;
      if (!this.hasPrecedingLineBreak())
        switch (delegating = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!delegating) break;
          default:
            argument = this.parseMaybeAssign();
        }
      return node2.delegate = delegating, node2.argument = argument, this.finishNode(node2, "YieldExpression");
    }
    parseImportCall(node2) {
      return this.next(), node2.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (node2.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (node2.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(node2, "ImportExpression");
    }
    checkPipelineAtInfixOperator(left2, leftStartLoc) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && left2.type === "SequenceExpression" && this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
    }
    parseSmartPipelineBodyInStyle(childExpr, startLoc) {
      if (this.isSimpleReference(childExpr)) {
        const bodyNode = this.startNodeAt(startLoc);
        return bodyNode.callee = childExpr, this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        const bodyNode = this.startNodeAt(startLoc);
        return this.checkSmartPipeTopicBodyEarlyErrors(startLoc), bodyNode.expression = childExpr, this.finishNode(bodyNode, "PipelineTopicExpression");
      }
    }
    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(startLoc) {
      if (this.match(19))
        throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipelineTopicUnused, startLoc);
    }
    withTopicBindingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withSmartMixTopicForbiddingContext(callback) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else
        return callback();
    }
    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      if (8 & ~flags) {
        this.prodParam.enter(flags | 8);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      if (8 & flags) {
        this.prodParam.enter(flags & -9);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec) {
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
      return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const node2 = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      const program = this.startNodeAt(this.state.endLoc);
      this.next();
      const revertScopes = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        node2.body = this.parseProgram(program, 8, "module");
      } finally {
        revertScopes();
      }
      return this.finishNode(node2, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(prop) {
    }
  }
  const loopLabel = {
    kind: 1
  }, switchLabel = {
    kind: 2
  }, loneSurrogate = /[\uD800-\uDFFF]/u, keywordRelationalOperator = /in(?:stanceof)?/y;
  function babel7CompatTokens(tokens, input2) {
    for (let i2 = 0; i2 < tokens.length; i2++) {
      const token2 = tokens[i2], {
        type: type2
      } = token2;
      if (typeof type2 == "number") {
        {
          if (type2 === 138) {
            const {
              loc,
              start,
              value,
              end: end2
            } = token2, hashEndPos = start + 1, hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
            tokens.splice(i2, 1, new Token({
              type: getExportedToken(27),
              value: "#",
              start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: getExportedToken(132),
              value,
              start: hashEndPos,
              end: end2,
              startLoc: hashEndLoc,
              endLoc: loc.end
            })), i2++;
            continue;
          }
          if (tokenIsTemplate(type2)) {
            const {
              loc,
              start,
              value,
              end: end2
            } = token2, backquoteEnd = start + 1, backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
            let startToken;
            input2.charCodeAt(start) === 96 ? startToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc
            }) : startToken = new Token({
              type: getExportedToken(8),
              value: "}",
              start,
              end: backquoteEnd,
              startLoc: loc.start,
              endLoc: backquoteEndLoc
            });
            let templateValue, templateElementEnd, templateElementEndLoc, endToken;
            type2 === 24 ? (templateElementEnd = end2 - 1, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1), templateValue = value === null ? null : value.slice(1, -1), endToken = new Token({
              type: getExportedToken(22),
              value: "`",
              start: templateElementEnd,
              end: end2,
              startLoc: templateElementEndLoc,
              endLoc: loc.end
            })) : (templateElementEnd = end2 - 2, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2), templateValue = value === null ? null : value.slice(1, -2), endToken = new Token({
              type: getExportedToken(23),
              value: "${",
              start: templateElementEnd,
              end: end2,
              startLoc: templateElementEndLoc,
              endLoc: loc.end
            })), tokens.splice(i2, 1, startToken, new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc
            }), endToken), i2 += 2;
            continue;
          }
        }
        token2.type = getExportedToken(type2);
      }
    }
    return tokens;
  }
  class StatementParser extends ExpressionParser {
    parseTopLevel(file2, program) {
      return file2.program = this.parseProgram(program), file2.comments = this.comments, this.options.tokens && (file2.tokens = babel7CompatTokens(this.tokens, this.input)), this.finishNode(file2, "File");
    }
    parseProgram(program, end2 = 139, sourceType = this.options.sourceType) {
      if (program.sourceType = sourceType, program.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(program, !0, !0, end2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (const [localName, at] of Array.from(this.scope.undefinedExports))
          this.raise(Errors.ModuleExportUndefined, at, {
            localName
          });
      let finishedProgram;
      return end2 === 139 ? finishedProgram = this.finishNode(program, "Program") : finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1)), finishedProgram;
    }
    stmtToDirective(stmt) {
      const directive = stmt;
      directive.type = "Directive", directive.value = directive.expression, delete directive.expression;
      const directiveLiteral = directive.value, expressionValue = directiveLiteral.value, raw = this.input.slice(directiveLiteral.start, directiveLiteral.end), val = directiveLiteral.value = raw.slice(1, -1);
      return this.addExtra(directiveLiteral, "raw", raw), this.addExtra(directiveLiteral, "rawValue", val), this.addExtra(directiveLiteral, "expressionValue", expressionValue), directiveLiteral.type = "DirectiveLiteral", directive;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      const node2 = this.startNode();
      return node2.value = this.state.value, this.next(), this.finishNode(node2, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(ch, pos2) {
      if (isIdentifierStart(ch)) {
        if (keywordRelationalOperator.lastIndex = pos2, keywordRelationalOperator.test(this.input)) {
          const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92)
            return !1;
        }
        return !0;
      } else return ch === 92;
    }
    chStartsBindingPattern(ch) {
      return ch === 91 || ch === 123;
    }
    hasFollowingBindingAtom() {
      const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
      return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    hasInLineFollowingBindingIdentifier() {
      const next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
      return this.chStartsBindingIdentifier(nextCh, next);
    }
    startsUsingForOf() {
      const {
        type: type2,
        containsEsc
      } = this.lookahead();
      if (type2 === 102 && !containsEsc)
        return !1;
      if (tokenIsIdentifier(type2) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let next = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(next, "using")) {
        next = this.nextTokenInLineStartSince(next + 5);
        const nextCh = this.codePointAtPos(next);
        if (this.chStartsBindingIdentifier(nextCh, next))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = !1) {
      let flags = 0;
      return this.options.annexB && !this.state.strict && (flags |= 4, allowLabeledFunction && (flags |= 8)), this.parseStatementLike(flags);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(flags) {
      let decorators = null;
      return this.match(26) && (decorators = this.parseDecorators(!0)), this.parseStatementContent(flags, decorators);
    }
    parseStatementContent(flags, decorators) {
      const starttype = this.state.type, node2 = this.startNode(), allowDeclaration = !!(flags & 2), allowFunctionDeclaration = !!(flags & 4), topLevel = flags & 1;
      switch (starttype) {
        case 60:
          return this.parseBreakContinueStatement(node2, !0);
        case 63:
          return this.parseBreakContinueStatement(node2, !1);
        case 64:
          return this.parseDebuggerStatement(node2);
        case 90:
          return this.parseDoWhileStatement(node2);
        case 91:
          return this.parseForStatement(node2);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return allowFunctionDeclaration || this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(node2, !1, !allowDeclaration && allowFunctionDeclaration);
        case 80:
          return allowDeclaration || this.unexpected(), this.parseClass(this.maybeTakeDecorators(decorators, node2), !0);
        case 69:
          return this.parseIfStatement(node2);
        case 70:
          return this.parseReturnStatement(node2);
        case 71:
          return this.parseSwitchStatement(node2);
        case 72:
          return this.parseThrowStatement(node2);
        case 73:
          return this.parseTryStatement(node2);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, node2) : this.raise(Errors.AwaitUsingNotInAsyncContext, node2), this.next(), this.parseVarStatement(node2, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc) : allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(node2, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
          if (nextCh !== 91 && (!allowDeclaration && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123))
            break;
        }
        case 75:
          allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const kind = this.state.value;
          return this.parseVarStatement(node2, kind);
        }
        case 92:
          return this.parseWhileStatement(node2);
        case 76:
          return this.parseWithStatement(node2);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(node2);
        case 83: {
          const nextTokenCharCode = this.lookaheadCharCode();
          if (nextTokenCharCode === 40 || nextTokenCharCode === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !topLevel && this.raise(Errors.UnexpectedImportExport, this.state.startLoc), this.next();
          let result;
          return starttype === 83 ? (result = this.parseImport(node2), result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value") && (this.sawUnambiguousESM = !0)) : (result = this.parseExport(node2, decorators), (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(result), result;
        }
        default:
          if (this.isAsyncFunction())
            return allowDeclaration || this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(node2, !0, !allowDeclaration && allowFunctionDeclaration);
      }
      const maybeName = this.state.value, expr = this.parseExpression();
      return tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(node2, maybeName, expr, flags) : this.parseExpressionStatement(node2, expr, decorators);
    }
    assertModuleNodeAllowed(node2) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(Errors.ImportOutsideModule, node2);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
      return maybeDecorators && (classNode.decorators && classNode.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]), classNode.decorators.unshift(...maybeDecorators)) : classNode.decorators = maybeDecorators, this.resetStartLocationFromNode(classNode, maybeDecorators[0]), exportNode && this.resetStartLocationFromNode(exportNode, classNode)), classNode;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(allowExport) {
      const decorators = [];
      do
        decorators.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        allowExport || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Errors.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
      return decorators;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const node2 = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const startLoc = this.state.startLoc;
        let expr;
        if (this.match(10)) {
          const startLoc2 = this.state.startLoc;
          this.next(), expr = this.parseExpression(), this.expect(11), expr = this.wrapParenthesis(startLoc2, expr);
          const paramsStartLoc = this.state.startLoc;
          node2.expression = this.parseMaybeDecoratorArguments(expr), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && node2.expression !== expr && this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
        } else {
          for (expr = this.parseIdentifier(!1); this.eat(16); ) {
            const node3 = this.startNodeAt(startLoc);
            node3.object = expr, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), node3.property = this.parsePrivateName()) : node3.property = this.parseIdentifier(!0), node3.computed = !1, expr = this.finishNode(node3, "MemberExpression");
          }
          node2.expression = this.parseMaybeDecoratorArguments(expr);
        }
      } else
        node2.expression = this.parseExprSubscripts();
      return this.finishNode(node2, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(10)) {
        const node2 = this.startNodeAtNode(expr);
        return node2.callee = expr, node2.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(node2.arguments), this.finishNode(node2, "CallExpression");
      }
      return expr;
    }
    parseBreakContinueStatement(node2, isBreak) {
      return this.next(), this.isLineTerminator() ? node2.label = null : (node2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(node2, isBreak), this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node2, isBreak) {
      let i2;
      for (i2 = 0; i2 < this.state.labels.length; ++i2) {
        const lab = this.state.labels[i2];
        if ((node2.label == null || lab.name === node2.label.name) && (lab.kind != null && (isBreak || lab.kind === 1) || node2.label && isBreak))
          break;
      }
      if (i2 === this.state.labels.length) {
        const type2 = isBreak ? "BreakStatement" : "ContinueStatement";
        this.raise(Errors.IllegalBreakContinue, node2, {
          type: type2
        });
      }
    }
    parseDebuggerStatement(node2) {
      return this.next(), this.semicolon(), this.finishNode(node2, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const val = this.parseExpression();
      return this.expect(11), val;
    }
    parseDoWhileStatement(node2) {
      return this.next(), this.state.labels.push(loopLabel), node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), node2.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(node2, "DoWhileStatement");
    }
    parseForStatement(node2) {
      this.next(), this.state.labels.push(loopLabel);
      let awaitAt = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (awaitAt = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
        return awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node2, null);
      const startsWithLet = this.isContextual(100);
      {
        const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing(), starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf(), isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
        if (this.match(74) || this.match(75) || isLetOrUsing) {
          const initNode = this.startNode();
          let kind;
          startsWithAwaitUsing ? (kind = "await using", this.isAwaitAllowed() || this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : kind = this.state.value, this.next(), this.parseVar(initNode, !0, kind);
          const init2 = this.finishNode(initNode, "VariableDeclaration"), isForIn = this.match(58);
          return isForIn && starsWithUsingDeclaration && this.raise(Errors.ForInUsing, init2), (isForIn || this.isContextual(102)) && init2.declarations.length === 1 ? this.parseForIn(node2, init2, awaitAt) : (awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node2, init2));
        }
      }
      const startsWithAsync = this.isContextual(95), refExpressionErrors = new ExpressionErrors(), init = this.parseExpression(!0, refExpressionErrors), isForOf = this.isContextual(102);
      if (isForOf && (startsWithLet && this.raise(Errors.ForOfLet, init), awaitAt === null && startsWithAsync && init.type === "Identifier" && this.raise(Errors.ForOfAsync, init)), isForOf || this.match(58)) {
        this.checkDestructuringPrivate(refExpressionErrors), this.toAssignable(init, !0);
        const type2 = isForOf ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(init, {
          in: {
            type: type2
          }
        }), this.parseForIn(node2, init, awaitAt);
      } else
        this.checkExpressionErrors(refExpressionErrors, !0);
      return awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node2, init);
    }
    parseFunctionStatement(node2, isAsync, isHangingDeclaration) {
      return this.next(), this.parseFunction(node2, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    }
    parseIfStatement(node2) {
      return this.next(), node2.test = this.parseHeaderExpression(), node2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), node2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(node2, "IfStatement");
    }
    parseReturnStatement(node2) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(Errors.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? node2.argument = null : (node2.argument = this.parseExpression(), this.semicolon()), this.finishNode(node2, "ReturnStatement");
    }
    parseSwitchStatement(node2) {
      this.next(), node2.discriminant = this.parseHeaderExpression();
      const cases = node2.cases = [];
      this.expect(5), this.state.labels.push(switchLabel), this.scope.enter(0);
      let cur;
      for (let sawDefault; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          const isCase = this.match(61);
          cur && this.finishNode(cur, "SwitchCase"), cases.push(cur = this.startNode()), cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), sawDefault = !0, cur.test = null), this.expect(14);
        } else
          cur ? cur.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), cur && this.finishNode(cur, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(node2, "SwitchStatement");
    }
    parseThrowStatement(node2) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc), node2.argument = this.parseExpression(), this.semicolon(), this.finishNode(node2, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0), this.checkLVal(param, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), param;
    }
    parseTryStatement(node2) {
      if (this.next(), node2.block = this.parseBlock(), node2.handler = null, this.match(62)) {
        const clause = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), clause.param = this.parseCatchClauseParam(), this.expect(11)) : (clause.param = null, this.scope.enter(0)), clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), node2.handler = this.finishNode(clause, "CatchClause");
      }
      return node2.finalizer = this.eat(67) ? this.parseBlock() : null, !node2.handler && !node2.finalizer && this.raise(Errors.NoCatchOrFinally, node2), this.finishNode(node2, "TryStatement");
    }
    parseVarStatement(node2, kind, allowMissingInitializer = !1) {
      return this.next(), this.parseVar(node2, !1, kind, allowMissingInitializer), this.semicolon(), this.finishNode(node2, "VariableDeclaration");
    }
    parseWhileStatement(node2) {
      return this.next(), node2.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel), node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(node2, "WhileStatement");
    }
    parseWithStatement(node2) {
      return this.state.strict && this.raise(Errors.StrictWith, this.state.startLoc), this.next(), node2.object = this.parseHeaderExpression(), node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(node2, "WithStatement");
    }
    parseEmptyStatement(node2) {
      return this.next(), this.finishNode(node2, "EmptyStatement");
    }
    parseLabeledStatement(node2, maybeName, expr, flags) {
      for (const label of this.state.labels)
        label.name === maybeName && this.raise(Errors.LabelRedeclaration, expr, {
          labelName: maybeName
        });
      const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let i2 = this.state.labels.length - 1; i2 >= 0; i2--) {
        const label = this.state.labels[i2];
        if (label.statementStart === node2.start)
          label.statementStart = this.state.start, label.kind = kind;
        else
          break;
      }
      return this.state.labels.push({
        name: maybeName,
        kind,
        statementStart: this.state.start
      }), node2.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), node2.label = expr, this.finishNode(node2, "LabeledStatement");
    }
    parseExpressionStatement(node2, expr, decorators) {
      return node2.expression = expr, this.semicolon(), this.finishNode(node2, "ExpressionStatement");
    }
    parseBlock(allowDirectives = !1, createNewLexicalScope = !0, afterBlockParse) {
      const node2 = this.startNode();
      return allowDirectives && this.state.strictErrors.clear(), this.expect(5), createNewLexicalScope && this.scope.enter(0), this.parseBlockBody(node2, allowDirectives, !1, 8, afterBlockParse), createNewLexicalScope && this.scope.exit(), this.finishNode(node2, "BlockStatement");
    }
    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node2, allowDirectives, topLevel, end2, afterBlockParse) {
      const body = node2.body = [], directives = node2.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end2, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end2, afterBlockParse) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = !1, parsedNonDirective = !1;
      for (; !this.match(end2); ) {
        const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive), !hasStrictModeDirective && directive.value.value === "use strict" && (hasStrictModeDirective = !0, this.setStrict(!0));
            continue;
          }
          parsedNonDirective = !0, this.state.strictErrors.clear();
        }
        body.push(stmt);
      }
      afterBlockParse?.call(this, hasStrictModeDirective), oldStrict || this.setStrict(!1), this.next();
    }
    parseFor(node2, init) {
      return node2.init = init, this.semicolon(!1), node2.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), node2.update = this.match(11) ? null : this.parseExpression(), this.expect(11), node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node2, "ForStatement");
    }
    parseForIn(node2, init, awaitAt) {
      const isForIn = this.match(58);
      return this.next(), isForIn ? awaitAt !== null && this.unexpected(awaitAt) : node2.await = awaitAt !== null, init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier") && this.raise(Errors.ForInOfLoopInitializer, init, {
        type: isForIn ? "ForInStatement" : "ForOfStatement"
      }), init.type === "AssignmentPattern" && this.raise(Errors.InvalidLhs, init, {
        ancestor: {
          type: "ForStatement"
        }
      }), node2.left = init, node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), node2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node2, isFor, kind, allowMissingInitializer = !1) {
      const declarations = node2.declarations = [];
      for (node2.kind = kind; ; ) {
        const decl = this.startNode();
        if (this.parseVarId(decl, kind), decl.init = this.eat(29) ? isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, decl.init === null && !allowMissingInitializer && (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102))) ? this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
          kind
        })), declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(12)) break;
      }
      return node2;
    }
    parseVarId(decl, kind) {
      const id = this.parseBindingAtom();
      this.checkLVal(id, {
        in: {
          type: "VariableDeclarator"
        },
        binding: kind === "var" ? 5 : 8201
      }), decl.id = id;
    }
    parseAsyncFunctionExpression(node2) {
      return this.parseFunction(node2, 8);
    }
    parseFunction(node2, flags = 0) {
      const hangingDeclaration = flags & 2, isDeclaration = !!(flags & 1), requireId = isDeclaration && !(flags & 4), isAsync = !!(flags & 8);
      this.initFunction(node2, isAsync), this.match(55) && (hangingDeclaration && this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), node2.generator = !0), isDeclaration && (node2.id = this.parseFunctionId(requireId));
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(functionFlags(isAsync, node2.generator)), isDeclaration || (node2.id = this.parseFunctionId()), this.parseFunctionParams(node2, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node2, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), isDeclaration && !hangingDeclaration && this.registerFunctionStatementId(node2), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node2;
    }
    parseFunctionId(requireId) {
      return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node2, isConstructor) {
      this.expect(10), this.expressionScope.enter(newParameterDeclarationScope()), node2.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(node2) {
      node2.id && this.scope.declareName(node2.id.name, !this.options.annexB || this.state.strict || node2.generator || node2.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node2.id.loc.start);
    }
    parseClass(node2, isStatement, optionalId) {
      this.next();
      const oldStrict = this.state.strict;
      return this.state.strict = !0, this.parseClassId(node2, isStatement, optionalId), this.parseClassSuper(node2), node2.body = this.parseClassBody(!!node2.superClass, oldStrict), this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(key2) {
      return key2.type === "Identifier" && key2.name === "constructor" || key2.type === "StringLiteral" && key2.value === "constructor";
    }
    isNonstaticConstructor(method) {
      return !method.computed && !method.static && this.nameIsConstructor(method.key);
    }
    parseClassBody(hadSuperClass, oldStrict) {
      this.classScope.enter();
      const state2 = {
        hadConstructor: !1,
        hadSuperClass
      };
      let decorators = [];
      const classBody = this.startNode();
      if (classBody.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (decorators.length > 0)
              throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            decorators.push(this.parseDecorator());
            continue;
          }
          const member = this.startNode();
          decorators.length && (member.decorators = decorators, this.resetStartLocationFromNode(member, decorators[0]), decorators = []), this.parseClassMember(classBody, member, state2), member.kind === "constructor" && member.decorators && member.decorators.length > 0 && this.raise(Errors.DecoratorConstructor, member);
        }
      }), this.state.strict = oldStrict, this.next(), decorators.length)
        throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
      const key2 = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        const method = member;
        return method.kind = "method", method.computed = !1, method.key = key2, method.static = !1, this.pushClassMethod(classBody, method, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        const prop = member;
        return prop.computed = !1, prop.key = key2, prop.static = !1, classBody.body.push(this.parseClassProperty(prop)), !0;
      }
      return this.resetPreviousNodeTrailingComments(key2), !1;
    }
    parseClassMember(classBody, member, state2) {
      const isStatic = this.isContextual(106);
      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(classBody, member, state2, isStatic);
    }
    parseClassMemberWithIsStatic(classBody, member, state2, isStatic) {
      const publicMethod = member, privateMethod = member, publicProp = member, privateProp = member, accessorProp = member, method = publicMethod, publicMember = publicMethod;
      if (member.static = isStatic, this.parsePropertyNamePrefixOperator(member), this.eat(55)) {
        method.kind = "method";
        const isPrivateName = this.match(138);
        if (this.parseClassElementName(method), isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, !0, !1);
          return;
        }
        this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsGenerator, publicMethod.key), this.pushClassMethod(classBody, publicMethod, !0, !1, !1, !1);
        return;
      }
      const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type), key2 = this.parseClassElementName(member), maybeContextualKw = isContextual ? key2.name : null, isPrivate = this.isPrivateName(key2), maybeQuestionTokenStartLoc = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(publicMember), this.isClassMethod()) {
        if (method.kind = "method", isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, !1, !1);
          return;
        }
        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = !1;
        isConstructor && (publicMethod.kind = "constructor", state2.hadConstructor && !this.hasPlugin("typescript") && this.raise(Errors.DuplicateConstructor, key2), isConstructor && this.hasPlugin("typescript") && member.override && this.raise(Errors.OverrideOnConstructor, key2), state2.hadConstructor = !0, allowsDirectSuper = state2.hadSuperClass), this.pushClassMethod(classBody, publicMethod, !1, !1, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty())
        isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp);
      else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key2);
        const isGenerator = this.eat(55);
        publicMember.optional && this.unexpected(maybeQuestionTokenStartLoc), method.kind = "method";
        const isPrivate2 = this.match(138);
        this.parseClassElementName(method), this.parsePostMemberNameModifiers(publicMember), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, !0) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAsync, publicMethod.key), this.pushClassMethod(classBody, publicMethod, isGenerator, !0, !1, !1));
      } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key2), method.kind = maybeContextualKw;
        const isPrivate2 = this.match(138);
        this.parseClassElementName(publicMethod), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, !1, !1) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAccessor, publicMethod.key), this.pushClassMethod(classBody, publicMethod, !1, !1, !1, !1)), this.checkGetterSetterParams(publicMethod);
      } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(key2);
        const isPrivate2 = this.match(138);
        this.parseClassElementName(publicProp), this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
      } else this.isLineTerminator() ? isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp) : this.unexpected();
    }
    parseClassElementName(member) {
      const {
        type: type2,
        value
      } = this.state;
      if ((type2 === 132 || type2 === 133) && member.static && value === "prototype" && this.raise(Errors.StaticPrototype, this.state.startLoc), type2 === 138) {
        value === "constructor" && this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
        const key2 = this.parsePrivateName();
        return member.key = key2, key2;
      }
      return this.parsePropertyName(member), member.key;
    }
    parseClassStaticBlock(classBody, member) {
      var _member$decorators;
      this.scope.enter(208);
      const oldLabels = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = oldLabels, classBody.body.push(this.finishNode(member, "StaticBlock")), (_member$decorators = member.decorators) != null && _member$decorators.length && this.raise(Errors.DecoratorStaticBlock, member);
    }
    pushClassProperty(classBody, prop) {
      !prop.computed && this.nameIsConstructor(prop.key) && this.raise(Errors.ConstructorClassField, prop.key), classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
      const node2 = this.parseClassPrivateProperty(prop);
      classBody.body.push(node2), this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
    }
    pushClassAccessorProperty(classBody, prop, isPrivate) {
      !isPrivate && !prop.computed && this.nameIsConstructor(prop.key) && this.raise(Errors.ConstructorClassField, prop.key);
      const node2 = this.parseClassAccessorProperty(prop);
      classBody.body.push(node2), isPrivate && this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), 0, node2.key.loc.start);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const node2 = this.parseMethod(method, isGenerator, isAsync, !1, !1, "ClassPrivateMethod", !0);
      classBody.body.push(node2);
      const kind = node2.kind === "get" ? node2.static ? 6 : 2 : node2.kind === "set" ? node2.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(node2, kind);
    }
    declareClassPrivateMethodInScope(node2, kind) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node2.key), kind, node2.key.loc.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {
    }
    parseClassPrivateProperty(node2) {
      return this.parseInitializer(node2), this.semicolon(), this.finishNode(node2, "ClassPrivateProperty");
    }
    parseClassProperty(node2) {
      return this.parseInitializer(node2), this.semicolon(), this.finishNode(node2, "ClassProperty");
    }
    parseClassAccessorProperty(node2) {
      return this.parseInitializer(node2), this.semicolon(), this.finishNode(node2, "ClassAccessorProperty");
    }
    parseInitializer(node2) {
      this.scope.enter(80), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), node2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(node2, isStatement, optionalId, bindingType = 8331) {
      if (tokenIsIdentifier(this.state.type))
        node2.id = this.parseIdentifier(), isStatement && this.declareNameFromIdentifier(node2.id, bindingType);
      else if (optionalId || !isStatement)
        node2.id = null;
      else
        throw this.raise(Errors.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(node2) {
      node2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(node2, decorators) {
      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node2, !0), hasDefault = this.maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier), parseAfterDefault = !hasDefault || this.eat(12), hasStar = parseAfterDefault && this.eatExportStar(node2), hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node2), parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12)), isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) {
        if (hasDefault && this.unexpected(), decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        return this.parseExportFrom(node2, !0), this.finishNode(node2, "ExportAllDeclaration");
      }
      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node2);
      hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers && this.unexpected(null, 5), hasNamespace && parseAfterNamespace && this.unexpected(null, 98);
      let hasDeclaration;
      if (isFromRequired || hasSpecifiers) {
        if (hasDeclaration = !1, decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        this.parseExportFrom(node2, isFromRequired);
      } else
        hasDeclaration = this.maybeParseExportDeclaration(node2);
      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        var _node2$declaration;
        const node22 = node2;
        if (this.checkExport(node22, !0, !1, !!node22.source), ((_node2$declaration = node22.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration")
          this.maybeTakeDecorators(decorators, node22.declaration, node22);
        else if (decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        return this.finishNode(node22, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const node22 = node2, decl = this.parseExportDefaultExpression();
        if (node22.declaration = decl, decl.type === "ClassDeclaration")
          this.maybeTakeDecorators(decorators, decl, node22);
        else if (decorators)
          throw this.raise(Errors.UnsupportedDecoratorExport, node2);
        return this.checkExport(node22, !0, !0), this.finishNode(node22, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(node2) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(node2, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier?.loc.start);
        const id = maybeDefaultIdentifier || this.parseIdentifier(!0), specifier = this.startNodeAtNode(id);
        return specifier.exported = id, node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(node2) {
      if (this.isContextual(93)) {
        var _ref, _ref$specifiers;
        (_ref$specifiers = (_ref = node2).specifiers) != null || (_ref.specifiers = []);
        const specifier = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), specifier.exported = this.parseModuleExportName(), node2.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(node2) {
      if (this.match(5)) {
        const node22 = node2;
        node22.specifiers || (node22.specifiers = []);
        const isTypeExport = node22.exportKind === "type";
        return node22.specifiers.push(...this.parseExportSpecifiers(isTypeExport)), node22.source = null, node22.declaration = null, this.hasPlugin("importAssertions") && (node22.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(node2) {
      return this.shouldParseExportDeclaration() ? (node2.specifiers = [], node2.source = null, this.hasPlugin("importAssertions") && (node2.assertions = []), node2.declaration = this.parseExportDeclaration(node2), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      const next = this.nextTokenInLineStart();
      return this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
      const expr = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(expr, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(expr, 13);
      if (this.match(80))
        return this.parseClass(expr, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
      const res = this.parseMaybeAssignAllowIn();
      return this.semicolon(), res;
    }
    parseExportDeclaration(node2) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const {
        type: type2
      } = this.state;
      if (tokenIsIdentifier(type2)) {
        if (type2 === 95 && !this.state.containsEsc || type2 === 100)
          return !1;
        if ((type2 === 130 || type2 === 129) && !this.state.containsEsc) {
          const {
            type: nextType
          } = this.lookahead();
          if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      const next = this.nextTokenStart(), hasFrom = this.isUnparsedContextual(next, "from");
      if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom)
        return !0;
      if (this.match(65) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }
      return !1;
    }
    parseExportFrom(node2, expect) {
      this.eatContextual(98) ? (node2.source = this.parseImportSource(), this.checkExport(node2), this.maybeParseImportAttributes(node2), this.checkJSONModuleImport(node2)) : expect && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      const {
        type: type2
      } = this.state;
      return type2 === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(Errors.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(Errors.UsingDeclarationExport, this.state.startLoc), !0) : type2 === 74 || type2 === 75 || type2 === 68 || type2 === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node2, checkNames, isDefault, isFrom) {
      if (checkNames) {
        var _node$specifiers;
        if (isDefault) {
          if (this.checkDuplicateExports(node2, "default"), this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;
            const declaration = node2.declaration;
            declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized) && this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
          }
        } else if ((_node$specifiers = node2.specifiers) != null && _node$specifiers.length)
          for (const specifier of node2.specifiers) {
            const {
              exported
            } = specifier, exportName = exported.type === "Identifier" ? exported.name : exported.value;
            if (this.checkDuplicateExports(specifier, exportName), !isFrom && specifier.local) {
              const {
                local
              } = specifier;
              local.type !== "Identifier" ? this.raise(Errors.ExportBindingIsString, specifier, {
                localName: local.value,
                exportName
              }) : (this.checkReservedWord(local.name, local.loc.start, !0, !1), this.scope.checkLocalExport(local));
            }
          }
        else if (node2.declaration) {
          const decl = node2.declaration;
          if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
            const {
              id
            } = decl;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node2, id.name);
          } else if (decl.type === "VariableDeclaration")
            for (const declaration of decl.declarations)
              this.checkDeclaration(declaration.id);
        }
      }
    }
    checkDeclaration(node2) {
      if (node2.type === "Identifier")
        this.checkDuplicateExports(node2, node2.name);
      else if (node2.type === "ObjectPattern")
        for (const prop of node2.properties)
          this.checkDeclaration(prop);
      else if (node2.type === "ArrayPattern")
        for (const elem of node2.elements)
          elem && this.checkDeclaration(elem);
      else node2.type === "ObjectProperty" ? this.checkDeclaration(node2.value) : node2.type === "RestElement" ? this.checkDeclaration(node2.argument) : node2.type === "AssignmentPattern" && this.checkDeclaration(node2.left);
    }
    checkDuplicateExports(node2, exportName) {
      this.exportedIdentifiers.has(exportName) && (exportName === "default" ? this.raise(Errors.DuplicateDefaultExport, node2) : this.raise(Errors.DuplicateExport, node2, {
        exportName
      })), this.exportedIdentifiers.add(exportName);
    }
    parseExportSpecifiers(isInTypeExport) {
      const nodes = [];
      let first2 = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (first2)
          first2 = !1;
        else if (this.expect(12), this.eat(8)) break;
        const isMaybeTypeOnly = this.isContextual(130), isString = this.match(133), node2 = this.startNode();
        node2.local = this.parseModuleExportName(), nodes.push(this.parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly));
      }
      return nodes;
    }
    parseExportSpecifier(node2, isString, isInTypeExport, isMaybeTypeOnly) {
      return this.eatContextual(93) ? node2.exported = this.parseModuleExportName() : isString ? node2.exported = cloneStringLiteral(node2.local) : node2.exported || (node2.exported = cloneIdentifier(node2.local)), this.finishNode(node2, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        const result = this.parseStringLiteral(this.state.value), surrogate = result.value.match(loneSurrogate);
        return surrogate && this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
          surrogateCharCode: surrogate[0].charCodeAt(0)
        }), result;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(node2) {
      return node2.assertions != null ? node2.assertions.some(({
        key: key2,
        value
      }) => value.value === "json" && (key2.type === "Identifier" ? key2.name === "type" : key2.value === "type")) : !1;
    }
    checkImportReflection(node2) {
      const {
        specifiers
      } = node2, singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
      if (node2.phase === "source")
        singleBindingType !== "ImportDefaultSpecifier" && this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
      else if (node2.phase === "defer")
        singleBindingType !== "ImportNamespaceSpecifier" && this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
      else if (node2.module) {
        var _node$assertions;
        singleBindingType !== "ImportDefaultSpecifier" && this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start), ((_node$assertions = node2.assertions) == null ? void 0 : _node$assertions.length) > 0 && this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
      }
    }
    checkJSONModuleImport(node2) {
      if (this.isJSONModuleImport(node2) && node2.type !== "ExportAllDeclaration") {
        const {
          specifiers
        } = node2;
        if (specifiers != null) {
          const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
            let imported;
            if (specifier.type === "ExportSpecifier" ? imported = specifier.local : specifier.type === "ImportSpecifier" && (imported = specifier.imported), imported !== void 0)
              return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
          });
          nonDefaultNamedSpecifier !== void 0 && this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
        }
      }
    }
    isPotentialImportPhase(isExport) {
      return isExport ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(node2, isExport, phase, loc) {
      isExport || (phase === "module" ? (this.expectPlugin("importReflection", loc), node2.module = !0) : this.hasPlugin("importReflection") && (node2.module = !1), phase === "source" ? (this.expectPlugin("sourcePhaseImports", loc), node2.phase = "source") : phase === "defer" ? (this.expectPlugin("deferredImportEvaluation", loc), node2.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (node2.phase = null));
    }
    parseMaybeImportPhase(node2, isExport) {
      if (!this.isPotentialImportPhase(isExport))
        return this.applyImportPhase(node2, isExport, null), null;
      const phaseIdentifier = this.parseIdentifier(!0), {
        type: type2
      } = this.state;
      return (tokenIsKeywordOrIdentifier(type2) ? type2 !== 98 || this.lookaheadCharCode() === 102 : type2 !== 12) ? (this.resetPreviousIdentifierLeadingComments(phaseIdentifier), this.applyImportPhase(node2, isExport, phaseIdentifier.name, phaseIdentifier.loc.start), null) : (this.applyImportPhase(node2, isExport, null), phaseIdentifier);
    }
    isPrecedingIdImportPhase(phase) {
      const {
        type: type2
      } = this.state;
      return tokenIsIdentifier(type2) ? type2 !== 98 || this.lookaheadCharCode() === 102 : type2 !== 12;
    }
    parseImport(node2) {
      return this.match(133) ? this.parseImportSourceAndAttributes(node2) : this.parseImportSpecifiersAndAfter(node2, this.parseMaybeImportPhase(node2, !1));
    }
    parseImportSpecifiersAndAfter(node2, maybeDefaultIdentifier) {
      node2.specifiers = [];
      const parseNext = !this.maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier) || this.eat(12), hasStar = parseNext && this.maybeParseStarImportSpecifier(node2);
      return parseNext && !hasStar && this.parseNamedImportSpecifiers(node2), this.expectContextual(98), this.parseImportSourceAndAttributes(node2);
    }
    parseImportSourceAndAttributes(node2) {
      var _node$specifiers2;
      return (_node$specifiers2 = node2.specifiers) != null || (node2.specifiers = []), node2.source = this.parseImportSource(), this.maybeParseImportAttributes(node2), this.checkImportReflection(node2), this.checkJSONModuleImport(node2), this.semicolon(), this.finishNode(node2, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(node2, specifier, type2) {
      specifier.local = this.parseIdentifier(), node2.specifiers.push(this.finishImportSpecifier(specifier, type2));
    }
    finishImportSpecifier(specifier, type2, bindingType = 8201) {
      return this.checkLVal(specifier.local, {
        in: {
          type: type2
        },
        binding: bindingType
      }), this.finishNode(specifier, type2);
    }
    parseImportAttributes() {
      this.expect(5);
      const attrs = [], attrNames = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        const node2 = this.startNode(), keyName = this.state.value;
        if (attrNames.has(keyName) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: keyName
        }), attrNames.add(keyName), this.match(133) ? node2.key = this.parseStringLiteral(keyName) : node2.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        node2.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node2, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), attrs;
    }
    parseModuleAttributes() {
      const attrs = [], attributes = /* @__PURE__ */ new Set();
      do {
        const node2 = this.startNode();
        if (node2.key = this.parseIdentifier(!0), node2.key.name !== "type" && this.raise(Errors.ModuleAttributeDifferentFromType, node2.key), attributes.has(node2.key.name) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, node2.key, {
          key: node2.key.name
        }), attributes.add(node2.key.name), this.expect(14), !this.match(133))
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        node2.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node2, "ImportAttribute"));
      } while (this.eat(12));
      return attrs;
    }
    maybeParseImportAttributes(node2) {
      let attributes, useWith = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? attributes = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), attributes = this.parseImportAttributes()), useWith = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(node2, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), attributes = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        attributes = [];
      else if (this.hasPlugin("moduleAttributes"))
        attributes = [];
      else return;
      !useWith && this.hasPlugin("importAssertions") ? node2.assertions = attributes : node2.attributes = attributes;
    }
    maybeParseDefaultImportSpecifier(node2, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier) {
        const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
        return specifier.local = maybeDefaultIdentifier, node2.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier")), !0;
      } else if (tokenIsKeywordOrIdentifier(this.state.type))
        return this.parseImportSpecifierLocal(node2, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(node2) {
      if (this.match(55)) {
        const specifier = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(node2, specifier, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(node2) {
      let first2 = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (first2)
          first2 = !1;
        else {
          if (this.eat(14))
            throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        const specifier = this.startNode(), importedIsString = this.match(133), isMaybeTypeOnly = this.isContextual(130);
        specifier.imported = this.parseModuleExportName();
        const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node2.importKind === "type" || node2.importKind === "typeof", isMaybeTypeOnly, void 0);
        node2.specifiers.push(importSpecifier);
      }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (this.eatContextual(93))
        specifier.local = this.parseIdentifier();
      else {
        const {
          imported
        } = specifier;
        if (importedIsString)
          throw this.raise(Errors.ImportBindingIsString, specifier, {
            importName: imported.value
          });
        this.checkReservedWord(imported.name, specifier.loc.start, !0, !0), specifier.local || (specifier.local = cloneIdentifier(imported));
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    }
    isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  }
  class Parser2 extends StatementParser {
    constructor(options2, input2) {
      options2 = getOptions(options2), super(options2, input2), this.options = options2, this.initializeScopes(), this.plugins = pluginsMap(this.options.plugins), this.filename = options2.sourceFilename;
    }
    getScopeHandler() {
      return ScopeHandler;
    }
    parse() {
      this.enterInitialScopes();
      const file2 = this.startNode(), program = this.startNode();
      return this.nextToken(), file2.errors = null, this.parseTopLevel(file2, program), file2.errors = this.state.errors, file2.comments.length = this.state.commentsLen, file2;
    }
  }
  function pluginsMap(plugins) {
    const pluginMap = /* @__PURE__ */ new Map();
    for (const plugin of plugins) {
      const [name, options2] = Array.isArray(plugin) ? plugin : [plugin, {}];
      pluginMap.has(name) || pluginMap.set(name, options2 || {});
    }
    return pluginMap;
  }
  function parse3(input2, options2) {
    var _options;
    if (((_options = options2) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options2 = Object.assign({}, options2);
      try {
        options2.sourceType = "module";
        const parser2 = getParser(options2, input2), ast = parser2.parse();
        if (parser2.sawUnambiguousESM)
          return ast;
        if (parser2.ambiguousScriptDifferentAst)
          try {
            return options2.sourceType = "script", getParser(options2, input2).parse();
          } catch {
          }
        else
          ast.program.sourceType = "script";
        return ast;
      } catch (moduleError) {
        try {
          return options2.sourceType = "script", getParser(options2, input2).parse();
        } catch {
        }
        throw moduleError;
      }
    } else
      return getParser(options2, input2).parse();
  }
  function parseExpression(input2, options2) {
    const parser2 = getParser(options2, input2);
    return parser2.options.strictMode && (parser2.state.strict = !0), parser2.getExpression();
  }
  function generateExportedTokenTypes(internalTokenTypes) {
    const tokenTypes2 = {};
    for (const typeName of Object.keys(internalTokenTypes))
      tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
    return tokenTypes2;
  }
  const tokTypes = generateExportedTokenTypes(tt);
  function getParser(options2, input2) {
    let cls = Parser2;
    return options2 != null && options2.plugins && (validatePlugins(options2.plugins), cls = getParserClass(options2.plugins)), new cls(options2, input2);
  }
  const parserClassCache = {};
  function getParserClass(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name)), key2 = pluginList.join("/");
    let cls = parserClassCache[key2];
    if (!cls) {
      cls = Parser2;
      for (const plugin of pluginList)
        cls = mixinPlugins[plugin](cls);
      parserClassCache[key2] = cls;
    }
    return cls;
  }
  return lib$1.parse = parse3, lib$1.parseExpression = parseExpression, lib$1.tokTypes = tokTypes, lib$1;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.parse = exports2.parser = void 0;
  var tslib_12 = require$$0$3, _babel_options_12 = tslib_12.__importDefault(require_babel_options());
  exports2.parser = function() {
    try {
      return requireLib$1();
    } catch {
      try {
        return require("babylon");
      } catch {
        throw new Error("Install @babel/parser to use the `typescript`, `flow`, or `babel` parsers");
      }
    }
  }();
  function parse3(source2, options2) {
    var babelOptions = (0, _babel_options_12.default)(options2);
    return babelOptions.plugins.push("jsx", "flow", "decoratorAutoAccessors"), exports2.parser.parse(source2, babelOptions);
  }
  exports2.parse = parse3;
})(babel);
Object.defineProperty(typescript, "__esModule", { value: !0 });
var parse_1 = typescript.parse = void 0, tslib_1 = require$$0$3, babel_1 = babel, _babel_options_1 = tslib_1.__importDefault(require_babel_options());
function parse(source2, options2) {
  var babelOptions = (0, _babel_options_1.default)(options2);
  return babelOptions.plugins.push("typescript"), babel_1.parser.parse(source2, babelOptions);
}
parse_1 = typescript.parse = parse;
var parser = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: typescript,
  get parse() {
    return parse_1;
  }
}, [typescript]);
const defaultTemplate$1 = `
import {defineCliConfig} from 'sanity/cli'

export default defineCliConfig({
  api: {
    projectId: '%projectId%',
    dataset: '%dataset%'
  }
})
`;
function createCliConfig(options2) {
  const variables = options2, template = defaultTemplate$1.trimStart(), ast = main$4.parse(template, { parser });
  return traverse__default.default(ast, {
    StringLiteral: {
      enter({ node: node2 }) {
        const value = node2.value;
        if (!value.startsWith("%") || !value.endsWith("%"))
          return;
        const variableName = value.slice(1, -1);
        if (!(variableName in variables))
          throw new Error(`Template variable '${value}' not defined`);
        node2.value = variables[variableName] || "";
      }
    }
  }), main$4.print(ast, { quote: "single" }).code;
}
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject = function isObject2(val) {
  return val != null && typeof val == "object" && Array.isArray(val) === !1;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isObject$1 = isobject;
function isObjectObject(o) {
  return isObject$1(o) === !0 && Object.prototype.toString.call(o) === "[object Object]";
}
var isPlainObject$1 = function isPlainObject2(o) {
  var ctor, prot;
  return !(isObjectObject(o) === !1 || (ctor = o.constructor, typeof ctor != "function") || (prot = ctor.prototype, isObjectObject(prot) === !1) || prot.hasOwnProperty("isPrototypeOf") === !1);
}, isPlainObject = isPlainObject$1;
function defaultSortFn(a, b) {
  return a.localeCompare(b);
}
function sort(src2, comparator) {
  var out;
  return Array.isArray(src2) ? src2.map(function(item) {
    return sort(item, comparator);
  }) : isPlainObject(src2) ? (out = {}, Object.keys(src2).sort(comparator || defaultSortFn).forEach(function(key2) {
    out[key2] = sort(src2[key2], comparator);
  }), out) : src2;
}
var deepSortObject = sort, sortObject = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(deepSortObject);
const manifestPropOrder = [
  "name",
  "private",
  "version",
  "description",
  "main",
  "author",
  "license",
  "scripts",
  "keywords",
  "dependencies",
  "devDependencies"
];
function createPackageManifest(data) {
  const dependencies = data.dependencies ? { dependencies: sortObject(data.dependencies) } : {}, devDependencies = data.devDependencies ? { devDependencies: sortObject(data.devDependencies) } : {}, pkg = {
    ...getCommonManifest(data),
    main: "package.json",
    keywords: ["sanity"],
    scripts: {
      dev: "sanity dev",
      start: "sanity start",
      build: "sanity build",
      deploy: "sanity deploy",
      "deploy-graphql": "sanity graphql deploy"
    },
    ...dependencies,
    ...devDependencies,
    prettier: {
      semi: !1,
      printWidth: 100,
      bracketSpacing: !1,
      singleQuote: !0
    }
  };
  return serializeManifest(pkg);
}
function getCommonManifest(data) {
  const pkg = {
    name: data.name,
    version: "1.0.0",
    description: data.description,
    author: data.author,
    license: data.license || "UNLICENSED",
    devDependencies: {}
  };
  return pkg.license === "UNLICENSED" && (pkg.private = !0), data.gitRemote && (pkg.repository = {
    type: "git",
    url: data.gitRemote
  }), pkg;
}
function serializeManifest(src2) {
  const ordered = manifestPropOrder.concat(Object.keys(src2)).reduce(
    (target, prop) => {
      const source2 = src2;
      return typeof source2[prop] < "u" && typeof target[prop] > "u" && (target[prop] = source2[prop]), target;
    },
    {}
  );
  return `${JSON.stringify(ordered, null, 2)}
`;
}
const defaultTemplate = `
import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [structureTool(), visionTool()],

  schema: {
    types: schemaTypes,
  },
})
`, defaultVariables = {
  projectName: "Sanity Studio",
  sourceName: "default",
  sourceTitle: "Default"
};
function createStudioConfig(options2) {
  const variables = { ...defaultVariables, ...options2.variables };
  if (typeof options2.template == "function")
    return options2.template(variables).trimStart();
  const template = (options2.template || defaultTemplate).trimStart(), ast = main$4.parse(template, { parser });
  return traverse__default.default(ast, {
    StringLiteral: {
      enter({ node: node2 }) {
        const value = node2.value;
        if (!value.startsWith("%") || !value.endsWith("%"))
          return;
        const variableName = value.slice(1, -1);
        if (!(variableName in variables))
          throw new Error(`Template variable '${value}' not defined`);
        node2.value = variables[variableName] || "";
      }
    }
  }), main$4.print(ast, { quote: "single" }).code;
}
const blogTemplate = {}, cleanTemplate = {}, configTemplate$3 = `
import {defineConfig, isDev} from 'sanity'
import {visionTool} from '@sanity/vision'
import {structureTool} from 'sanity/structure'
import {schemaTypes} from './schemaTypes'
import {getStartedPlugin} from './plugins/sanity-plugin-tutorial'

const devOnlyPlugins = [getStartedPlugin()]

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [structureTool(), visionTool(), ...(isDev ? devOnlyPlugins : [])],

  schema: {
    types: schemaTypes,
  },
})

`, getStartedTemplate = {
  configTemplate: configTemplate$3,
  typescriptOnly: !0,
  dependencies: {
    "@sanity/icons": "^2.11.0",
    "@sanity/ui": "^2.0.0"
  }
}, configTemplate$2 = `
import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [
    structureTool(),
    visionTool(),
  ],

  schema: {
    types: schemaTypes,
  },
})
`, movieTemplate = {
  configTemplate: configTemplate$2,
  importPrompt: "Add a sampling of sci-fi movies to your dataset on the hosted backend?",
  datasetUrl: "https://public.sanity.io/moviesdb-2018-03-06.tar.gz",
  dependencies: {
    "react-icons": "^3.11.0"
  }
}, quickStartTemplate = {}, configTemplate$1 = `
import {defineConfig, isDev} from 'sanity'

import {structureTool} from 'sanity/structure'
import {schemaTypes} from './schemaTypes'
import {structure} from './structure'

import {visionTool} from '@sanity/vision'
import {colorInput} from '@sanity/color-input'
import {imageHotspotArrayPlugin} from 'sanity-plugin-hotspot-array'
import {media, mediaAssetSource} from 'sanity-plugin-media'
import {customDocumentActions} from './plugins/customDocumentActions'
import Navbar from './components/studio/Navbar'

const devOnlyPlugins = [visionTool()]

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [
    structureTool({structure}),
    colorInput(),
    imageHotspotArrayPlugin(),
    customDocumentActions(),
    media(),
    ...(isDev ? devOnlyPlugins : []),
  ],

  schema: {
    types: schemaTypes,
  },

  form: {
    file: {
      assetSources: (previousAssetSources) => {
        return previousAssetSources.filter((assetSource) => assetSource !== mediaAssetSource)
      },
    },
    image: {
      assetSources: (previousAssetSources) => {
        return previousAssetSources.filter((assetSource) => assetSource === mediaAssetSource)
      },
    },
  },

  studio: {
    components: {
      navbar: Navbar,
    },
  },
})`, shopifyTemplate$1 = {
  configTemplate: configTemplate$1,
  dependencies: {
    "@sanity/asset-utils": "^1.3.0",
    "@sanity/color-input": "^3.0.2",
    "@sanity/icons": "^2.11.0",
    "@sanity/ui": "^2.0.0",
    "lodash.get": "^4.4.2",
    "pluralize-esm": "^9.0.2",
    "sanity-plugin-hotspot-array": "^1.0.1",
    "sanity-plugin-media": "^2.0.5",
    slug: "^8.2.2"
  },
  devDependencies: {
    "@portabletext/types": "^2.0.2",
    "@types/lodash.get": "^4.4.7",
    "@types/slug": "^5.0.3"
  }
}, configTemplate = `
import {shopifyAssets} from 'sanity-plugin-shopify-assets'
import {defineConfig, isDev} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {shopifyDocumentActions} from './plugins/shopifyDocumentActions'
import {schemaTypes} from './schemaTypes'
import {structure} from './structure'
import {SHOPIFY_STORE_ID} from './constants'

const devOnlyPlugins = [visionTool()]

export default defineConfig({
  name: '%sourceName%',
  title: '%projectName%',

  projectId: '%projectId%',
  dataset: '%dataset%',

  plugins: [
    structureTool({structure}),
    shopifyDocumentActions(),
    shopifyAssets({
      shopifyDomain: SHOPIFY_STORE_ID,
    }),
    ...(isDev ? devOnlyPlugins : []),
  ],

  schema: {
    types: schemaTypes,
  },
})
`, shopifyTemplate = {
  configTemplate,
  typescriptOnly: !0,
  dependencies: {
    "@portabletext/toolkit": "^2.0.1",
    "@sanity/icons": "^2.11.0",
    "@sanity/ui": "^2.0.0",
    "@types/lodash.get": "^4.4.7",
    "lodash.get": "^4.4.2",
    "pluralize-esm": "^9.0.4",
    "sanity-plugin-shopify-assets": "^1.1.0"
  }
}, templates = {
  blog: blogTemplate,
  clean: cleanTemplate,
  "get-started": getStartedTemplate,
  moviedb: movieTemplate,
  shopify: shopifyTemplate$1,
  "shopify-online-storefront": shopifyTemplate,
  quickstart: quickStartTemplate
  // empty project that dynamically imports its own schema
};
async function bootstrapTemplate(opts, context) {
  const { apiClient, cliRoot, output } = context, templatesDir = path__default.default.join(cliRoot, "templates"), { outputPath, templateName, useTypeScript, packageName, variables } = opts, { projectId } = variables, sourceDir = path__default.default.join(templatesDir, templateName), sharedDir = path__default.default.join(templatesDir, "shared"), template = templates[templateName];
  if (!template)
    throw new Error(`Template "${templateName}" not defined`);
  loadEnv.debug('Copying files from template "%s" to "%s"', templateName, outputPath);
  let spinner = output.spinner(
    opts.schemaUrl ? "Extracting your Sanity configuration" : "Bootstrapping files from template"
  ).start();
  await copy(sourceDir, outputPath, {
    rename: useTypeScript ? toTypeScriptPath : void 0
  }), await copy(path__default.default.join(sharedDir, "gitignore.txt"), outputPath, { rename: () => ".gitignore" }), useTypeScript && await fs__default$1.default.copyFile(path__default.default.join(sharedDir, "tsconfig.json"), path__default.default.join(outputPath, "tsconfig.json")), opts.schemaUrl && (loadEnv.debug('Fetching and writing remote schema "%s"', opts.schemaUrl), await journeyConfig.getAndWriteJourneySchemaWorker({
    schemasPath: path__default.default.join(outputPath, "schemaTypes"),
    useTypeScript,
    schemaUrl: opts.schemaUrl
  })), spinner.succeed(), spinner = output.spinner("Resolving latest module versions").start();
  const dependencyVersions = await resolveLatestVersions({
    ...studioDependencies.dependencies,
    ...studioDependencies.devDependencies,
    ...template.dependencies || {}
  });
  spinner.succeed();
  const dependencies = Object.keys({
    ...studioDependencies.dependencies,
    ...template.dependencies
  }).reduce(
    (deps, dependency) => (deps[dependency] = dependencyVersions[dependency], deps),
    {}
  ), devDependencies = Object.keys({
    ...studioDependencies.devDependencies,
    ...template.devDependencies
  }).reduce(
    (deps, dependency) => (deps[dependency] = dependencyVersions[dependency], deps),
    {}
  );
  spinner = output.spinner("Creating default project files").start();
  const packageManifest = await createPackageManifest({
    name: packageName,
    dependencies,
    devDependencies
  }), studioConfig = await createStudioConfig({
    template: template.configTemplate,
    variables
  }), cliConfig = await createCliConfig({
    projectId: variables.projectId,
    dataset: variables.dataset
  }), codeExt = useTypeScript ? "ts" : "js";
  await Promise.all([
    writeFileIfNotExists(`sanity.config.${codeExt}`, studioConfig),
    writeFileIfNotExists(`sanity.cli.${codeExt}`, cliConfig),
    writeFileIfNotExists("package.json", packageManifest),
    writeFileIfNotExists(
      ".eslintrc",
      `${JSON.stringify({ extends: "@sanity/eslint-config-studio" }, null, 2)}
`
    )
  ]);
  try {
    await apiClient({ api: { projectId } }).request({
      method: "PATCH",
      uri: `/projects/${projectId}`,
      body: { metadata: { initialTemplate: `cli-${templateName}` } }
    });
  } catch (err) {
    let message = typeof err == "string" ? err : "<unknown error>";
    err instanceof Error && (message = err.message), loadEnv.debug("Failed to update initial template metadata for project: %s", message);
  }
  return spinner.succeed(), template;
  async function writeFileIfNotExists(fileName, content) {
    const filePath = path__default.default.join(outputPath, fileName);
    try {
      await fs__default$1.default.writeFile(filePath, content, { flag: "wx" });
    } catch (err) {
      if (err.code === "EEXIST")
        output.warn(`
${chalk__default.default.yellow("\u26A0")} File "${filePath}" already exists, skipping`);
      else
        throw err;
    }
  }
}
function toTypeScriptPath(originalPath) {
  return originalPath.replace(/\.js$/, ".ts");
}
function validateEmptyPath(dir) {
  const checkPath2 = absolutify(dir);
  return pathIsEmpty(checkPath2) ? !0 : "Given path is not empty";
}
function absolutify(dir) {
  const pathName = expandHome(dir);
  return path__default.default.isAbsolute(pathName) ? pathName : path__default.default.resolve(process.cwd(), pathName);
}
function pathIsEmpty(dir) {
  try {
    return fs__default.default.readdirSync(dir).length === 0;
  } catch (err) {
    if (err.code === "ENOENT")
      return !0;
    throw err;
  }
}
function expandHome(filePath) {
  if (filePath.charCodeAt(0) === 126) {
    if (filePath.charCodeAt(1) === 43)
      return path__default.default.join(process.cwd(), filePath.slice(2));
    const home2 = os__default.default.homedir();
    return home2 ? path__default.default.join(home2, filePath.slice(1)) : filePath;
  }
  return filePath;
}
var pathIsAbsolute = { exports: {} }, hasRequiredPathIsAbsolute;
function requirePathIsAbsolute() {
  if (hasRequiredPathIsAbsolute) return pathIsAbsolute.exports;
  hasRequiredPathIsAbsolute = 1;
  function posix(path2) {
    return path2.charAt(0) === "/";
  }
  function win32(path2) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/, result = splitDeviceRe.exec(path2), device = result[1] || "", isUnc = !!(device && device.charAt(1) !== ":");
    return !!(result[2] || isUnc);
  }
  return pathIsAbsolute.exports = process.platform === "win32" ? win32 : posix, pathIsAbsolute.exports.posix = posix, pathIsAbsolute.exports.win32 = win32, pathIsAbsolute.exports;
}
var common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1, common.setopts = setopts2, common.ownProp = ownProp2, common.makeAbs = makeAbs2, common.finish = finish2, common.mark = mark2, common.isIgnored = isIgnored2, common.childrenIgnored = childrenIgnored2;
  function ownProp2(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var fs2 = require$$0__default$1.default, path2 = require$$0__default.default, minimatch2 = minimatch_1$2, isAbsolute2 = requirePathIsAbsolute(), Minimatch3 = minimatch2.Minimatch;
  function alphasort2(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores2(self2, options2) {
    self2.ignore = options2.ignore || [], Array.isArray(self2.ignore) || (self2.ignore = [self2.ignore]), self2.ignore.length && (self2.ignore = self2.ignore.map(ignoreMap2));
  }
  function ignoreMap2(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch3(gpattern, { dot: !0 });
    }
    return {
      matcher: new Minimatch3(pattern, { dot: !0 }),
      gmatcher
    };
  }
  function setopts2(self2, pattern, options2) {
    if (options2 || (options2 = {}), options2.matchBase && pattern.indexOf("/") === -1) {
      if (options2.noglobstar)
        throw new Error("base matching requires globstar");
      pattern = "**/" + pattern;
    }
    self2.silent = !!options2.silent, self2.pattern = pattern, self2.strict = options2.strict !== !1, self2.realpath = !!options2.realpath, self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null), self2.follow = !!options2.follow, self2.dot = !!options2.dot, self2.mark = !!options2.mark, self2.nodir = !!options2.nodir, self2.nodir && (self2.mark = !0), self2.sync = !!options2.sync, self2.nounique = !!options2.nounique, self2.nonull = !!options2.nonull, self2.nosort = !!options2.nosort, self2.nocase = !!options2.nocase, self2.stat = !!options2.stat, self2.noprocess = !!options2.noprocess, self2.absolute = !!options2.absolute, self2.fs = options2.fs || fs2, self2.maxLength = options2.maxLength || 1 / 0, self2.cache = options2.cache || /* @__PURE__ */ Object.create(null), self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null), self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null), setupIgnores2(self2, options2), self2.changedCwd = !1;
    var cwd2 = process.cwd();
    ownProp2(options2, "cwd") ? (self2.cwd = path2.resolve(options2.cwd), self2.changedCwd = self2.cwd !== cwd2) : self2.cwd = cwd2, self2.root = options2.root || path2.resolve(self2.cwd, "/"), self2.root = path2.resolve(self2.root), process.platform === "win32" && (self2.root = self2.root.replace(/\\/g, "/")), self2.cwdAbs = isAbsolute2(self2.cwd) ? self2.cwd : makeAbs2(self2, self2.cwd), process.platform === "win32" && (self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/")), self2.nomount = !!options2.nomount, options2.nonegate = !0, options2.nocomment = !0, options2.allowWindowsEscape = !1, self2.minimatch = new Minimatch3(pattern, options2), self2.options = self2.minimatch.options;
  }
  function finish2(self2) {
    for (var nou = self2.nounique, all = nou ? [] : /* @__PURE__ */ Object.create(null), i2 = 0, l = self2.matches.length; i2 < l; i2++) {
      var matches2 = self2.matches[i2];
      if (!matches2 || Object.keys(matches2).length === 0) {
        if (self2.nonull) {
          var literal2 = self2.minimatch.globSet[i2];
          nou ? all.push(literal2) : all[literal2] = !0;
        }
      } else {
        var m = Object.keys(matches2);
        nou ? all.push.apply(all, m) : m.forEach(function(m2) {
          all[m2] = !0;
        });
      }
    }
    if (nou || (all = Object.keys(all)), self2.nosort || (all = all.sort(alphasort2)), self2.mark) {
      for (var i2 = 0; i2 < all.length; i2++)
        all[i2] = self2._mark(all[i2]);
      self2.nodir && (all = all.filter(function(e) {
        var notDir = !/\/$/.test(e), c2 = self2.cache[e] || self2.cache[makeAbs2(self2, e)];
        return notDir && c2 && (notDir = c2 !== "DIR" && !Array.isArray(c2)), notDir;
      }));
    }
    self2.ignore.length && (all = all.filter(function(m2) {
      return !isIgnored2(self2, m2);
    })), self2.found = all;
  }
  function mark2(self2, p) {
    var abs = makeAbs2(self2, p), c2 = self2.cache[abs], m = p;
    if (c2) {
      var isDir = c2 === "DIR" || Array.isArray(c2), slash = p.slice(-1) === "/";
      if (isDir && !slash ? m += "/" : !isDir && slash && (m = m.slice(0, -1)), m !== p) {
        var mabs = makeAbs2(self2, m);
        self2.statCache[mabs] = self2.statCache[abs], self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m;
  }
  function makeAbs2(self2, f2) {
    var abs = f2;
    return f2.charAt(0) === "/" ? abs = path2.join(self2.root, f2) : isAbsolute2(f2) || f2 === "" ? abs = f2 : self2.changedCwd ? abs = path2.resolve(self2.cwd, f2) : abs = path2.resolve(f2), process.platform === "win32" && (abs = abs.replace(/\\/g, "/")), abs;
  }
  function isIgnored2(self2, path3) {
    return self2.ignore.length ? self2.ignore.some(function(item) {
      return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
    }) : !1;
  }
  function childrenIgnored2(self2, path3) {
    return self2.ignore.length ? self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path3));
    }) : !1;
  }
  return common;
}
var sync, hasRequiredSync;
function requireSync() {
  if (hasRequiredSync) return sync;
  hasRequiredSync = 1, sync = globSync, globSync.GlobSync = GlobSync;
  var rp = requireFs_realpath(), minimatch2 = minimatch_1$2;
  requireGlob().Glob;
  var path2 = require$$0__default.default, assert2 = require$$5__default.default, isAbsolute2 = requirePathIsAbsolute(), common2 = requireCommon(), setopts2 = common2.setopts, ownProp2 = common2.ownProp, childrenIgnored2 = common2.childrenIgnored, isIgnored2 = common2.isIgnored;
  function globSync(pattern, options2) {
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    return new GlobSync(pattern, options2).found;
  }
  function GlobSync(pattern, options2) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options2);
    if (setopts2(this, pattern, options2), this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i2 = 0; i2 < n; i2++)
      this._process(this.minimatch.set[i2], i2, !1);
    this._finish();
  }
  return GlobSync.prototype._finish = function() {
    if (assert2.ok(this instanceof GlobSync), this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set2 = self2.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset)
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = !0;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = !0;
            else
              throw er;
          }
      });
    }
    common2.finish(this);
  }, GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert2.ok(this instanceof GlobSync);
    for (var n = 0; typeof pattern[n] == "string"; )
      n++;
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n), read2;
    prefix === null ? read2 = "." : ((isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p) {
      return typeof p == "string" ? p : "[*]";
    }).join("/"))) && (!prefix || !isAbsolute2(prefix)) && (prefix = "/" + prefix), read2 = prefix);
    var abs = this._makeAbs(read2);
    if (!childrenIgnored2(this, read2)) {
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar);
    }
  }, GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i2 = 0; i2 < entries.length; i2++) {
        var e = entries[i2];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len !== 0) {
        if (remain.length === 1 && !this.mark && !this.stat) {
          this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
          for (var i2 = 0; i2 < len; i2++) {
            var e = matchedEntries[i2];
            prefix && (prefix.slice(-1) !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i2 = 0; i2 < len; i2++) {
          var e = matchedEntries[i2], newPattern;
          prefix ? newPattern = [prefix, e] : newPattern = [e], this._process(newPattern.concat(remain), index, inGlobStar);
        }
      }
    }
  }, GlobSync.prototype._emitMatch = function(index, e) {
    if (!isIgnored2(this, e)) {
      var abs = this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0, this.stat && this._stat(e);
      }
    }
  }, GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, !1);
    var entries, lstat;
    try {
      lstat = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT")
        return null;
    }
    var isSym = lstat && lstat.isSymbolicLink();
    return this.symlinks[abs] = isSym, !isSym && lstat && !lstat.isDirectory() ? this.cache[abs] = "FILE" : entries = this._readdir(abs, !1), entries;
  }, GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return null;
      if (Array.isArray(c2))
        return c2;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      return this._readdirError(abs, er), null;
    }
  }, GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat)
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e = entries[i2];
        abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
      }
    return this.cache[abs] = entries, entries;
  }, GlobSync.prototype._readdirError = function(f2, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f2);
        if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          throw error2.path = this.cwd, error2.code = er.code, error2;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f2)] = !1;
        break;
      default:
        if (this.cache[this._makeAbs(f2)] = !1, this.strict)
          throw er;
        this.silent || console.error("glob error", er);
        break;
    }
  }, GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, !1);
      var len = entries.length, isSym = this.symlinks[abs];
      if (!(isSym && inGlobStar))
        for (var i2 = 0; i2 < len; i2++) {
          var e = entries[i2];
          if (!(e.charAt(0) === "." && !this.dot)) {
            var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
            this._process(instead, index, !0);
            var below = gspref.concat(entries[i2], remain);
            this._process(below, index, !0);
          }
        }
    }
  }, GlobSync.prototype._processSimple = function(prefix, index) {
    var exists2 = this._stat(prefix);
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !!exists2) {
      if (prefix && isAbsolute2(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
      }
      process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix);
    }
  }, GlobSync.prototype._stat = function(f2) {
    var abs = this._makeAbs(f2), needDir = f2.slice(-1) === "/";
    if (f2.length > this.maxLength)
      return !1;
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return c2;
      if (needDir && c2 === "FILE")
        return !1;
    }
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
          return this.statCache[abs] = !1, !1;
      }
      if (lstat && lstat.isSymbolicLink())
        try {
          stat = this.fs.statSync(abs);
        } catch {
          stat = lstat;
        }
      else
        stat = lstat;
    }
    this.statCache[abs] = stat;
    var c2 = !0;
    return stat && (c2 = stat.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? !1 : c2;
  }, GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, GlobSync.prototype._makeAbs = function(f2) {
    return common2.makeAbs(this, f2);
  }, sync;
}
var glob_1, hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob) return glob_1;
  hasRequiredGlob = 1, glob_1 = glob2;
  var rp = requireFs_realpath(), minimatch2 = minimatch_1$2, inherits2 = inheritsExports, EE2 = require$$3__default.default.EventEmitter, path2 = require$$0__default.default, assert2 = require$$5__default.default, isAbsolute2 = requirePathIsAbsolute(), globSync = requireSync(), common2 = requireCommon(), setopts2 = common2.setopts, ownProp2 = common2.ownProp, inflight = requireInflight(), childrenIgnored2 = common2.childrenIgnored, isIgnored2 = common2.isIgnored, once2 = requireOnce();
  function glob2(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), options2 || (options2 = {}), options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options2);
    }
    return new Glob(pattern, options2, cb);
  }
  glob2.sync = globSync;
  var GlobSync = glob2.GlobSync = globSync.GlobSync;
  glob2.glob = glob2;
  function extend4(origin, add) {
    if (add === null || typeof add != "object")
      return origin;
    for (var keys = Object.keys(add), i2 = keys.length; i2--; )
      origin[keys[i2]] = add[keys[i2]];
    return origin;
  }
  glob2.hasMagic = function(pattern, options_) {
    var options2 = extend4({}, options_);
    options2.noprocess = !0;
    var g = new Glob(pattern, options2), set2 = g.minimatch.set;
    if (!pattern)
      return !1;
    if (set2.length > 1)
      return !0;
    for (var j = 0; j < set2[0].length; j++)
      if (typeof set2[0][j] != "string")
        return !0;
    return !1;
  }, glob2.Glob = Glob, inherits2(Glob, EE2);
  function Glob(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = null), options2 && options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options2);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options2, cb);
    setopts2(this, pattern, options2), this._didRealPath = !1;
    var n = this.minimatch.set.length;
    this.matches = new Array(n), typeof cb == "function" && (cb = once2(cb), this.on("error", cb), this.on("end", function(matches2) {
      cb(null, matches2);
    }));
    var self2 = this;
    if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = !1, this.noprocess)
      return this;
    if (n === 0)
      return done();
    for (var sync2 = !0, i2 = 0; i2 < n; i2++)
      this._process(this.minimatch.set[i2], i2, !1, done);
    sync2 = !1;
    function done() {
      --self2._processing, self2._processing <= 0 && (sync2 ? process.nextTick(function() {
        self2._finish();
      }) : self2._finish());
    }
  }
  Glob.prototype._finish = function() {
    if (assert2(this instanceof Glob), !this.aborted) {
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common2.finish(this), this.emit("end", this.found);
    }
  }, Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = !0;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    for (var self2 = this, i2 = 0; i2 < this.matches.length; i2++)
      this._realpathSet(i2, next);
    function next() {
      --n === 0 && self2._finish();
    }
  }, Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset), self2 = this, n = found.length;
    if (n === 0)
      return cb();
    var set2 = this.matches[index] = /* @__PURE__ */ Object.create(null);
    found.forEach(function(p, i2) {
      p = self2._makeAbs(p), rp.realpath(p, self2.realpathCache, function(er, real) {
        er ? er.syscall === "stat" ? set2[p] = !0 : self2.emit("error", er) : set2[real] = !0, --n === 0 && (self2.matches[index] = set2, cb());
      });
    });
  }, Glob.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, Glob.prototype._makeAbs = function(f2) {
    return common2.makeAbs(this, f2);
  }, Glob.prototype.abort = function() {
    this.aborted = !0, this.emit("abort");
  }, Glob.prototype.pause = function() {
    this.paused || (this.paused = !0, this.emit("pause"));
  }, Glob.prototype.resume = function() {
    if (this.paused) {
      if (this.emit("resume"), this.paused = !1, this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i2 = 0; i2 < eq.length; i2++) {
          var e = eq[i2];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i2 = 0; i2 < pq.length; i2++) {
          var p = pq[i2];
          this._processing--, this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  }, Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    if (assert2(this instanceof Glob), assert2(typeof cb == "function"), !this.aborted) {
      if (this._processing++, this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      for (var n = 0; typeof pattern[n] == "string"; )
        n++;
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n), read2;
      prefix === null ? read2 = "." : ((isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p) {
        return typeof p == "string" ? p : "[*]";
      }).join("/"))) && (!prefix || !isAbsolute2(prefix)) && (prefix = "/" + prefix), read2 = prefix);
      var abs = this._makeAbs(read2);
      if (childrenIgnored2(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar, cb) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar, cb);
    }
  }, Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i2 = 0; i2 < entries.length; i2++) {
      var e = entries[i2];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
      for (var i2 = 0; i2 < len; i2++) {
        var e = matchedEntries[i2];
        prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i2 = 0; i2 < len; i2++) {
      var e = matchedEntries[i2];
      prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  }, Glob.prototype._emitMatch = function(index, e) {
    if (!this.aborted && !isIgnored2(this, e)) {
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute2(e) ? e : this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0;
        var st = this.statCache[abs];
        st && this.emit("stat", e, st), this.emit("match", e);
      }
    }
  }, Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, !1, cb);
    var lstatkey = "lstat\0" + abs, self2 = this, lstatcb = inflight(lstatkey, lstatcb_);
    lstatcb && self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym, !isSym && lstat && !lstat.isDirectory() ? (self2.cache[abs] = "FILE", cb()) : self2._readdir(abs, !1, cb);
    }
  }, Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (!this.aborted && (cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb), !!cb)) {
      if (inGlobStar && !ownProp2(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp2(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return cb();
        if (Array.isArray(c2))
          return cb(null, c2);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    }
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      er ? self2._readdirError(abs, er, cb) : self2._readdirEntries(abs, entries, cb);
    };
  }
  return Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (!this.aborted) {
      if (!this.mark && !this.stat)
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e = entries[i2];
          abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
        }
      return this.cache[abs] = entries, cb(null, entries);
    }
  }, Glob.prototype._readdirError = function(f2, er, cb) {
    if (!this.aborted) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd, error2.code = er.code, this.emit("error", error2), this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = !1;
          break;
        default:
          this.cache[this._makeAbs(f2)] = !1, this.strict && (this.emit("error", er), this.abort()), this.silent || console.error("glob error", er);
          break;
      }
      return cb();
    }
  }, Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, !1, cb);
    var isSym = this.symlinks[abs], len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i2 = 0; i2 < len; i2++) {
      var e = entries[i2];
      if (!(e.charAt(0) === "." && !this.dot)) {
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index, !0, cb);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index, !0, cb);
      }
    }
    cb();
  }, Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists2) {
      self2._processSimple2(prefix, index, er, exists2, cb);
    });
  }, Glob.prototype._processSimple2 = function(prefix, index, er, exists2, cb) {
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !exists2)
      return cb();
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
    }
    process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix), cb();
  }, Glob.prototype._stat = function(f2, cb) {
    var abs = this._makeAbs(f2), needDir = f2.slice(-1) === "/";
    if (f2.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return cb(null, c2);
      if (needDir && c2 === "FILE")
        return cb();
    }
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === !1)
        return cb(null, stat);
      var type2 = stat.isDirectory() ? "DIR" : "FILE";
      return needDir && type2 === "FILE" ? cb() : cb(null, type2, stat);
    }
    var self2 = this, statcb = inflight("stat\0" + abs, lstatcb_);
    statcb && self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink())
        return self2.fs.stat(abs, function(er2, stat2) {
          er2 ? self2._stat2(f2, abs, null, lstat, cb) : self2._stat2(f2, abs, er2, stat2, cb);
        });
      self2._stat2(f2, abs, er, lstat, cb);
    }
  }, Glob.prototype._stat2 = function(f2, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
      return this.statCache[abs] = !1, cb();
    var needDir = f2.slice(-1) === "/";
    if (this.statCache[abs] = stat, abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, !1, stat);
    var c2 = !0;
    return stat && (c2 = stat.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? cb() : cb(null, c2, stat);
  }, glob_1;
}
const assert = require$$5__default.default, path$1 = require$$0__default.default, fs = require$$0__default$1.default;
let glob;
try {
  glob = requireGlob();
} catch (_err) {
}
const defaultGlobOpts = {
  nosort: !0,
  silent: !0
};
let timeout$1 = 0;
const isWindows = process.platform === "win32", defaults$2 = (options2) => {
  if ([
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ].forEach((m) => {
    options2[m] = options2[m] || fs[m], m = m + "Sync", options2[m] = options2[m] || fs[m];
  }), options2.maxBusyTries = options2.maxBusyTries || 3, options2.emfileWait = options2.emfileWait || 1e3, options2.glob === !1 && (options2.disableGlob = !0), options2.disableGlob !== !0 && glob === void 0)
    throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
  options2.disableGlob = options2.disableGlob || !1, options2.glob = options2.glob || defaultGlobOpts;
}, rimraf$1 = (p, options2, cb) => {
  typeof options2 == "function" && (cb = options2, options2 = {}), assert(p, "rimraf: missing path"), assert.equal(typeof p, "string", "rimraf: path should be a string"), assert.equal(typeof cb, "function", "rimraf: callback function required"), assert(options2, "rimraf: invalid options argument provided"), assert.equal(typeof options2, "object", "rimraf: options should be object"), defaults$2(options2);
  let busyTries = 0, errState = null, n = 0;
  const next = (er) => {
    errState = errState || er, --n === 0 && cb(errState);
  }, afterGlob = (er, results) => {
    if (er)
      return cb(er);
    if (n = results.length, n === 0)
      return cb();
    results.forEach((p2) => {
      const CB = (er2) => {
        if (er2) {
          if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options2.maxBusyTries)
            return busyTries++, setTimeout(() => rimraf_(p2, options2, CB), busyTries * 100);
          if (er2.code === "EMFILE" && timeout$1 < options2.emfileWait)
            return setTimeout(() => rimraf_(p2, options2, CB), timeout$1++);
          er2.code === "ENOENT" && (er2 = null);
        }
        timeout$1 = 0, next(er2);
      };
      rimraf_(p2, options2, CB);
    });
  };
  if (options2.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p]);
  options2.lstat(p, (er, stat) => {
    if (!er)
      return afterGlob(null, [p]);
    glob(p, options2.glob, afterGlob);
  });
}, rimraf_ = (p, options2, cb) => {
  assert(p), assert(options2), assert(typeof cb == "function"), options2.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT")
      return cb(null);
    if (er && er.code === "EPERM" && isWindows && fixWinEPERM(p, options2, er, cb), st && st.isDirectory())
      return rmdir(p, options2, er, cb);
    options2.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT")
          return cb(null);
        if (er2.code === "EPERM")
          return isWindows ? fixWinEPERM(p, options2, er2, cb) : rmdir(p, options2, er2, cb);
        if (er2.code === "EISDIR")
          return rmdir(p, options2, er2, cb);
      }
      return cb(er2);
    });
  });
}, fixWinEPERM = (p, options2, er, cb) => {
  assert(p), assert(options2), assert(typeof cb == "function"), options2.chmod(p, 438, (er2) => {
    er2 ? cb(er2.code === "ENOENT" ? null : er) : options2.stat(p, (er3, stats) => {
      er3 ? cb(er3.code === "ENOENT" ? null : er) : stats.isDirectory() ? rmdir(p, options2, er, cb) : options2.unlink(p, cb);
    });
  });
}, fixWinEPERMSync = (p, options2, er) => {
  assert(p), assert(options2);
  try {
    options2.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT")
      return;
    throw er;
  }
  let stats;
  try {
    stats = options2.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT")
      return;
    throw er;
  }
  stats.isDirectory() ? rmdirSync(p, options2, er) : options2.unlinkSync(p);
}, rmdir = (p, options2, originalEr, cb) => {
  assert(p), assert(options2), assert(typeof cb == "function"), options2.rmdir(p, (er) => {
    er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") ? rmkids(p, options2, cb) : er && er.code === "ENOTDIR" ? cb(originalEr) : cb(er);
  });
}, rmkids = (p, options2, cb) => {
  assert(p), assert(options2), assert(typeof cb == "function"), options2.readdir(p, (er, files) => {
    if (er)
      return cb(er);
    let n = files.length;
    if (n === 0)
      return options2.rmdir(p, cb);
    let errState;
    files.forEach((f2) => {
      rimraf$1(path$1.join(p, f2), options2, (er2) => {
        if (!errState) {
          if (er2)
            return cb(errState = er2);
          --n === 0 && options2.rmdir(p, cb);
        }
      });
    });
  });
}, rimrafSync = (p, options2) => {
  options2 = options2 || {}, defaults$2(options2), assert(p, "rimraf: missing path"), assert.equal(typeof p, "string", "rimraf: path should be a string"), assert(options2, "rimraf: missing options"), assert.equal(typeof options2, "object", "rimraf: options should be object");
  let results;
  if (options2.disableGlob || !glob.hasMagic(p))
    results = [p];
  else
    try {
      options2.lstatSync(p), results = [p];
    } catch {
      results = glob.sync(p, options2.glob);
    }
  if (results.length)
    for (let i2 = 0; i2 < results.length; i2++) {
      const p2 = results[i2];
      let st;
      try {
        st = options2.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        er.code === "EPERM" && isWindows && fixWinEPERMSync(p2, options2, er);
      }
      try {
        st && st.isDirectory() ? rmdirSync(p2, options2, null) : options2.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p2, options2, er) : rmdirSync(p2, options2, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options2, er);
      }
    }
}, rmdirSync = (p, options2, originalEr) => {
  assert(p), assert(options2);
  try {
    options2.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOENT")
      return;
    if (er.code === "ENOTDIR")
      throw originalEr;
    (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") && rmkidsSync(p, options2);
  }
}, rmkidsSync = (p, options2) => {
  assert(p), assert(options2), options2.readdirSync(p).forEach((f2) => rimrafSync(path$1.join(p, f2), options2));
  const retries = isWindows ? 100 : 1;
  let i2 = 0;
  do {
    let threw = !0;
    try {
      const ret = options2.rmdirSync(p, options2);
      return threw = !1, ret;
    } finally {
      if (++i2 < retries && threw)
        continue;
    }
  } while (!0);
};
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
var rimrafCb = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(rimraf_1);
const defaultCommitMessage = "feat: bootstrap sanity studio";
function tryGitInit(rootDir, commitMessage) {
  const execOptions = { stdio: "ignore", cwd: rootDir };
  let didInit = !1;
  try {
    return childProcess$2.execSync("git --version", execOptions), isInGitRepository(rootDir) || isInMercurialRepository(rootDir) ? !1 : (childProcess$2.execSync("git init", execOptions), didInit = !0, childProcess$2.execSync("git checkout -b main", execOptions), childProcess$2.execSync("git add -A", execOptions), childProcess$2.execFileSync("git", ["commit", "-m", commitMessage || defaultCommitMessage], {
      stdio: "ignore",
      cwd: rootDir
    }), !0);
  } catch {
    if (didInit)
      try {
        rimrafCb.sync(path__default.default.join(rootDir, ".git"));
      } catch {
      }
    return !1;
  }
}
function isInGitRepository(rootDir) {
  try {
    return childProcess$2.execSync("git rev-parse --is-inside-work-tree", { stdio: "ignore", cwd: rootDir }), !0;
  } catch {
  }
  return !1;
}
function isInMercurialRepository(rootDir) {
  try {
    return childProcess$2.execSync("hg --cwd . root", { stdio: "ignore", cwd: rootDir }), !0;
  } catch {
  }
  return !1;
}
const MAX_DATASET_NAME_LENGTH = 64, datasetNameError = `Dataset names can only contain lowercase characters,numbers, underscores and dashesand can be at most ${MAX_DATASET_NAME_LENGTH} characters.`;
function promptForDatasetName(prompt2, options2 = {}, existingDatasets = []) {
  return prompt2.single({
    type: "input",
    message: "Dataset name:",
    validate: (name) => {
      if (existingDatasets.includes(name))
        return "Dataset name already exists";
      if (!name || name.length < 2 || name.length > MAX_DATASET_NAME_LENGTH)
        return `Dataset name must be between 2 and ${MAX_DATASET_NAME_LENGTH} characters`;
      if (name.toLowerCase() !== name)
        return "Dataset name must be lowercase";
      if (name.replace(/\s/g, "") !== name)
        return "Dataset name cannot contain whitespace";
      if (/^[^a-z0-9]/.test(name))
        return "Dataset name must start with a character or letter";
      if (/[-_]$/.test(name))
        return "Dataset name must not end with a dash or an underscore";
      if (/^[a-z0-9][-\w]+$/.test(name))
        return !0;
      const invalid = name.match(/[^-\w]/g) || [];
      return invalid.length > 0 ? `Disallowed characters found: ${formatInvalid(name, invalid)}` : datasetNameError;
    },
    ...options2
  });
}
function formatInvalid(name, invalid) {
  return invalid.reduce(
    (acc, char) => acc.replace(new RegExp(escapeRegex(char), "g"), chalk__default.default.red.bold(char)),
    name
  );
}
function escapeRegex(str2) {
  return `${str2}`.replace(/([?!${}*:()|=^[\]/\\.+])/g, "\\$1");
}
function promptForTypeScript(prompt2) {
  return prompt2.single({
    type: "confirm",
    message: "Do you want to use TypeScript?",
    default: !0
  });
}
function promptForDefaultConfig(prompt2) {
  return prompt2.single({
    type: "confirm",
    message: "Use the default dataset configuration?",
    default: !0
  });
}
async function promptForAclMode(prompt2, output) {
  const mode2 = await prompt2.single({
    type: "list",
    message: "Choose dataset visibility\xA0\u2013\xA0this can be changed later",
    choices: [
      {
        value: "public",
        name: "Public (world readable)"
      },
      {
        value: "private",
        name: "Private (authenticated requests only)"
      }
    ]
  });
  return mode2 === "private" && output.print(
    `Please note that while documents are private, assets (files and images) are still public
`
  ), mode2;
}
function promptForEmbeddedStudio(prompt2) {
  return prompt2.single({
    type: "confirm",
    message: "Would you like an embedded Sanity Studio?",
    default: !0
  });
}
function promptForStudioPath(prompt2) {
  return prompt2.single({
    type: "input",
    message: "What route do you want to use for the Studio?",
    default: "/studio",
    validate(input2) {
      return input2.startsWith("/") ? input2.endsWith("/") ? "Must not end with /" : /^[a-zA-Z0-9-_\\/]+$/.test(input2) ? !0 : "Must only contain a-Z, 0-9, -, _ and /" : "Must start with /";
    }
  });
}
function promptForNextTemplate(prompt2) {
  return prompt2.single({
    message: "Select project template to use",
    type: "list",
    choices: [
      {
        value: "clean",
        name: "Clean project with no predefined schema types"
      },
      {
        value: "blog",
        name: "Blog (schema)"
      }
    ],
    default: "clean"
  });
}
function promptForAppendEnv(prompt2, envFilename) {
  return prompt2.single({
    type: "confirm",
    message: `Would you like to add the project ID and dataset to your ${envFilename} file?`,
    default: !0
  });
}
async function pathExists(filePath) {
  try {
    return await fs__default$1.default.access(filePath), !0;
  } catch (err) {
    if (err.code === "ENOENT")
      return !1;
    throw err;
  }
}
function writeJson$1(filePath, content) {
  const serialized = JSON.stringify(content, null, 2);
  return fs$o.writeFile(filePath, serialized, "utf8");
}
const isCI$1 = process.env.CI;
async function reconfigureV2Project(args, context) {
  const { output, prompt: prompt2, workDir, apiClient, yarn, chalk: chalk2 } = context, cliFlags = args.extOptions, unattended = cliFlags.y || cliFlags.yes, print = unattended ? lodashExports.noop : output.print;
  let defaultConfig = cliFlags["dataset-default"], showDefaultConfigPrompt = !defaultConfig;
  const manifestPath = path__default.default.join(workDir, "sanity.json");
  let projectManifest = await readJson(manifestPath);
  const hasProjectId = projectManifest && projectManifest.api && projectManifest.api.projectId;
  print("The Sanity Studio in this folder will be tied to a new project on Sanity.io!"), hasProjectId && print("The previous project configuration will be overwritten."), print("We're first going to make sure you have an account with Sanity.io. Hang on."), print(`Press ctrl + C at any time to quit.
`);
  const hasToken = getUserConfig().get("authToken");
  loadEnv.debug(hasToken ? "User already has a token" : "User has no token"), hasToken ? print(`Looks like you already have a Sanity-account. Sweet!
`) : unattended || await getOrCreateUser();
  const flags = await prepareFlags();
  loadEnv.debug("Prompting user to select or create a project");
  const { projectId, displayName, isFirstProject } = await getOrCreateProject();
  loadEnv.debug(`Project with name ${displayName} selected`), loadEnv.debug("Prompting user to select or create a dataset");
  const { datasetName } = await getOrCreateDataset({
    projectId,
    displayName,
    dataset: flags.dataset,
    aclMode: flags.visibility,
    defaultConfig: flags["dataset-default"]
  });
  loadEnv.debug(`Dataset with name ${datasetName} selected`);
  const outputPath = workDir, projectInfo = projectManifest.project || {}, newProps = {
    root: !0,
    api: {
      ...projectManifest.api || {},
      projectId,
      dataset: datasetName
    },
    project: {
      ...projectInfo,
      // Keep original name if present
      name: projectInfo.name || displayName
    }
  };
  if (projectManifest = {
    ...newProps,
    ...projectManifest,
    ...newProps
  }, await writeJson$1(manifestPath, projectManifest), await pathExists(path__default.default.join(workDir, "node_modules")))
    print("Skipping installation of dependencies since node_modules exists."), print("Run sanity install to reinstall dependencies");
  else
    try {
      await yarn(["install"], { ...output, rootDir: workDir });
    } catch (err) {
      throw err;
    }
  print(`
${chalk2.green("Success!")} Now what?
`), outputPath === process.cwd() || print(`\u25AA ${chalk2.cyan(`cd ${outputPath}`)}, then:`), print(`\u25AA ${chalk2.cyan("sanity docs")} to open the documentation in a browser`), print(`\u25AA ${chalk2.cyan("sanity manage")} to open the project settings in a browser`), print(`\u25AA ${chalk2.cyan("sanity help")} to explore the CLI manual`), print(`\u25AA ${chalk2.green("sanity start")} to run your studio
`), isFirstProject && await prompt2.single({
    type: "confirm",
    message: "We have an excellent developer community, would you like us to send you an invitation to join?",
    default: !0
  }) && apiClient({ requireProject: !1 }).request({
    uri: "/invitations/community",
    method: "POST"
  }).catch(lodashExports.noop);
  async function getOrCreateUser() {
    print("We can't find any auth credentials in your Sanity config"), print(`- log in or create a new account
`);
    const { extOptions, ...otherArgs } = args, loginArgs = { ...otherArgs, extOptions: {} };
    await login(loginArgs, context), print("Good stuff, you're now authenticated. You'll need a project to keep your"), print("datasets and collaborators safe and snug.");
  }
  async function getOrCreateProject() {
    let projects;
    try {
      projects = await apiClient({ requireProject: !1 }).projects.list({ includeMembers: !1 });
    } catch (err) {
      if (unattended && flags.project)
        return { projectId: flags.project, displayName: "Unknown project", isFirstProject: !1 };
      throw new Error(`Failed to communicate with the Sanity API:
${err.message}`);
    }
    if (projects.length === 0 && unattended)
      throw new Error("No projects found for current user");
    if (flags.project) {
      const project = projects.find((proj) => proj.id === flags.project);
      if (!project && !unattended)
        throw new Error(
          `Given project ID (${flags.project}) not found, or you do not have access to it`
        );
      return {
        projectId: flags.project,
        displayName: project ? project.displayName : "Unknown project",
        isFirstProject: !1
      };
    }
    const isUsersFirstProject = projects.length === 0;
    if (isUsersFirstProject) {
      loadEnv.debug("No projects found for user, prompting for name");
      const projectName = await prompt2.single({ type: "input", message: "Project name:" });
      return createProject(apiClient, {
        displayName: projectName,
        subscription: void 0
      }).then((response) => ({
        ...response,
        isFirstProject: isUsersFirstProject
      }));
    }
    loadEnv.debug(`User has ${projects.length} project(s) already, showing list of choices`);
    const projectChoices = projects.map((project) => ({
      value: project.id,
      name: `${project.displayName} [${project.id}]`
    })), selected = await prompt2.single({
      message: "Select project to use",
      type: "list",
      choices: [
        { value: "new", name: "Create new project" },
        new prompt2.Separator(),
        ...projectChoices
      ]
    });
    return selected === "new" ? (loadEnv.debug("User wants to create a new project, prompting for name"), createProject(apiClient, {
      displayName: await prompt2.single({
        type: "input",
        message: "Your project name:",
        default: "My Sanity Project"
      }),
      subscription: void 0
    }).then((response) => ({
      ...response,
      isFirstProject: isUsersFirstProject
    }))) : (loadEnv.debug(`Returning selected project (${selected})`), {
      projectId: selected,
      displayName: projects.find((proj) => proj.id === selected)?.displayName || "",
      isFirstProject: isUsersFirstProject
    });
  }
  async function getOrCreateDataset(opts) {
    if (opts.dataset && isCI$1)
      return { datasetName: opts.dataset };
    const client2 = apiClient({ api: { projectId: opts.projectId } }), [datasets, projectFeatures] = await Promise.all([
      client2.datasets.list(),
      client2.request({ uri: "/features" })
    ]), privateDatasetsAllowed = projectFeatures.includes("privateDataset"), allowedModes = privateDatasetsAllowed ? ["public", "private"] : ["public"];
    if (opts.aclMode && !allowedModes.includes(opts.aclMode))
      throw new Error(`Visibility mode "${opts.aclMode}" not allowed`);
    const getAclMode = async () => opts.aclMode ? opts.aclMode : unattended || !privateDatasetsAllowed || defaultConfig ? "public" : privateDatasetsAllowed ? await promptForAclMode(prompt2, output) : "public";
    if (opts.dataset) {
      if (loadEnv.debug("User has specified dataset through a flag (%s)", opts.dataset), !datasets.find((ds) => ds.name === opts.dataset)) {
        loadEnv.debug("Specified dataset not found, creating it");
        const aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
        await client2.datasets.create(opts.dataset, { aclMode }), spinner.succeed();
      }
      return { datasetName: opts.dataset };
    }
    const datasetInfo = `Your content will be stored in a dataset that can be public or private, depending on
whether you want to query your content with or without authentication.
The default dataset configuration has a public dataset named "production".`;
    if (datasets.length === 0) {
      loadEnv.debug("No datasets found for project, prompting for name"), showDefaultConfigPrompt && (output.print(datasetInfo), defaultConfig = await promptForDefaultConfig(prompt2));
      const name = defaultConfig ? "production" : await promptForDatasetName(prompt2, {
        message: "Name of your first dataset:"
      }), aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
      return await client2.datasets.create(name, { aclMode }), spinner.succeed(), { datasetName: name };
    }
    loadEnv.debug(`User has ${datasets.length} dataset(s) already, showing list of choices`);
    const datasetChoices = datasets.map((dataset) => ({ value: dataset.name })), selected = await prompt2.single({
      message: "Select dataset to use",
      type: "list",
      choices: [
        { value: "new", name: "Create new dataset" },
        new prompt2.Separator(),
        ...datasetChoices
      ]
    });
    if (selected === "new") {
      const existingDatasetNames = datasets.map((ds) => ds.name);
      loadEnv.debug("User wants to create a new dataset, prompting for name"), showDefaultConfigPrompt && !existingDatasetNames.includes("production") && (output.print(datasetInfo), defaultConfig = await promptForDefaultConfig(prompt2));
      const newDatasetName = defaultConfig ? "production" : await promptForDatasetName(
        prompt2,
        {
          message: "Dataset name:"
        },
        existingDatasetNames
      ), aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
      return await client2.datasets.create(newDatasetName, { aclMode }), spinner.succeed(), { datasetName: newDatasetName };
    }
    return loadEnv.debug(`Returning selected dataset (${selected})`), { datasetName: selected };
  }
  async function prepareFlags() {
    const createProjectName = cliFlags["create-project"];
    if ((cliFlags.dataset || cliFlags.visibility || cliFlags["dataset-default"] || unattended) && (showDefaultConfigPrompt = !1), cliFlags.project && createProjectName)
      throw new Error(
        "Both `--project` and `--create-project` specified, only a single is supported"
      );
    if (createProjectName === !0)
      throw new Error("Please specify a project name (`--create-project <name>`)");
    if (typeof createProjectName == "string" && createProjectName.trim().length === 0)
      throw new Error("Please specify a project name (`--create-project <name>`)");
    if (unattended && (loadEnv.debug("Unattended mode, validating required options"), ["dataset", "output-path"].forEach((flag) => {
      if (!cliFlags[flag])
        throw new Error(`\`--${flag}\` must be specified in unattended mode`);
    }), !cliFlags.project && !createProjectName))
      throw new Error(
        "`--project <id>` or `--create-project <name>` must be specified in unattended mode"
      );
    if (createProjectName) {
      loadEnv.debug("--create-project specified, creating a new project");
      const createdProject = await createProject(apiClient, {
        displayName: createProjectName.trim(),
        subscription: void 0
      });
      if (loadEnv.debug("Project with ID %s created", createdProject.projectId), cliFlags.dataset) {
        loadEnv.debug("--dataset specified, creating dataset (%s)", cliFlags.dataset);
        const client2 = apiClient({ api: { projectId: createdProject.projectId } }), spinner = context.output.spinner("Creating dataset").start(), createBody = cliFlags.visibility ? { aclMode: cliFlags.visibility } : {};
        await client2.datasets.create(cliFlags.dataset, createBody), spinner.succeed();
      }
      const newFlags = { ...cliFlags, project: createdProject.projectId };
      return delete newFlags["create-project"], newFlags;
    }
    return cliFlags;
  }
}
const authorTS = `import {defineField, defineType} from 'sanity'

export default defineType({
  name: 'author',
  title: 'Author',
  type: 'document',
  fields: [
    defineField({
      name: 'name',
      title: 'Name',
      type: 'string',
    }),
    defineField({
      name: 'slug',
      title: 'Slug',
      type: 'slug',
      options: {
        source: 'name',
        maxLength: 96,
      },
    }),
    defineField({
      name: 'image',
      title: 'Image',
      type: 'image',
      options: {
        hotspot: true,
      },
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        }
      ]
    }),
    defineField({
      name: 'bio',
      title: 'Bio',
      type: 'array',
      of: [
        {
          title: 'Block',
          type: 'block',
          styles: [{title: 'Normal', value: 'normal'}],
          lists: [],
        },
      ],
    }),
  ],
  preview: {
    select: {
      title: 'name',
      media: 'image',
    },
  },
})
`, authorJS = `export const author = {
  name: 'author',
  title: 'Author',
  type: 'document',
  fields: [
    {
      name: 'name',
      title: 'Name',
      type: 'string',
    },
    {
      name: 'slug',
      title: 'Slug',
      type: 'slug',
      options: {
        source: 'name',
        maxLength: 96,
      },
    },
    {
      name: 'image',
      title: 'Image',
      type: 'image',
      options: {
        hotspot: true,
      },
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        }
      ]
    },
    {
      name: 'bio',
      title: 'Bio',
      type: 'array',
      of: [
        {
          title: 'Block',
          type: 'block',
          styles: [{title: 'Normal', value: 'normal'}],
          lists: [],
        },
      ],
    },
  ],
  preview: {
    select: {
      title: 'name',
      media: 'image',
    },
  },
}
`, blockContentTS = `import {defineType, defineArrayMember} from 'sanity'

/**
 * This is the schema type for block content used in the post document type
 * Importing this type into the studio configuration's \`schema\` property
 * lets you reuse it in other document types with:
 *  {
 *    name: 'someName',
 *    title: 'Some title',
 *    type: 'blockContent'
 *  }
 */

export default defineType({
  title: 'Block Content',
  name: 'blockContent',
  type: 'array',
  of: [
    defineArrayMember({
      title: 'Block',
      type: 'block',
      // Styles let you define what blocks can be marked up as. The default
      // set corresponds with HTML tags, but you can set any title or value
      // you want, and decide how you want to deal with it where you want to
      // use your content.
      styles: [
        {title: 'Normal', value: 'normal'},
        {title: 'H1', value: 'h1'},
        {title: 'H2', value: 'h2'},
        {title: 'H3', value: 'h3'},
        {title: 'H4', value: 'h4'},
        {title: 'Quote', value: 'blockquote'},
      ],
      lists: [{title: 'Bullet', value: 'bullet'}],
      // Marks let you mark up inline text in the Portable Text Editor
      marks: {
        // Decorators usually describe a single property \u2013 e.g. a typographic
        // preference or highlighting
        decorators: [
          {title: 'Strong', value: 'strong'},
          {title: 'Emphasis', value: 'em'},
        ],
        // Annotations can be any object structure \u2013 e.g. a link or a footnote.
        annotations: [
          {
            title: 'URL',
            name: 'link',
            type: 'object',
            fields: [
              {
                title: 'URL',
                name: 'href',
                type: 'url',
              },
            ],
          },
        ],
      },
    }),
    // You can add additional types here. Note that you can't use
    // primitive types such as 'string' and 'number' in the same array
    // as a block type.
    defineArrayMember({
      type: 'image',
      options: {hotspot: true},
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        }
      ]
    }),
  ],
})
`, blockContentJS = `/**
 * This is the schema type for block content used in the post document type
 * Importing this type into the studio configuration's \`schema\` property
 * lets you reuse it in other document types with:
 *  {
 *    name: 'someName',
 *    title: 'Some title',
 *    type: 'blockContent'
 *  }
 */

export const blockContent = {
  title: 'Block Content',
  name: 'blockContent',
  type: 'array',
  of: [
    {
      title: 'Block',
      type: 'block',
      // Styles let you set what your user can mark up blocks with. These
      // correspond with HTML tags, but you can set any title or value
      // you want and decide how you want to deal with it where you want to
      // use your content.
      styles: [
        {title: 'Normal', value: 'normal'},
        {title: 'H1', value: 'h1'},
        {title: 'H2', value: 'h2'},
        {title: 'H3', value: 'h3'},
        {title: 'H4', value: 'h4'},
        {title: 'Quote', value: 'blockquote'},
      ],
      lists: [{title: 'Bullet', value: 'bullet'}],
      // Marks let you mark up inline text in the block editor.
      marks: {
        // Decorators usually describe a single property \u2013 e.g. a typographic
        // preference or highlighting by editors.
        decorators: [
          {title: 'Strong', value: 'strong'},
          {title: 'Emphasis', value: 'em'},
        ],
        // Annotations can be any object structure \u2013 e.g. a link or a footnote.
        annotations: [
          {
            title: 'URL',
            name: 'link',
            type: 'object',
            fields: [
              {
                title: 'URL',
                name: 'href',
                type: 'url',
              },
            ],
          },
        ],
      },
    },
    // You can add additional types here. Note that you can't use
    // primitive types such as 'string' and 'number' in the same array
    // as a block type.
    {
      type: 'image',
      options: {hotspot: true},
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        }
      ]
    },
  ],
}
`, categoryTS = `import {defineField, defineType} from 'sanity'

export default defineType({
  name: 'category',
  title: 'Category',
  type: 'document',
  fields: [
    defineField({
      name: 'title',
      title: 'Title',
      type: 'string',
    }),
    defineField({
      name: 'description',
      title: 'Description',
      type: 'text',
    }),
  ],
})
`, categoryJS = `export const category = {
  name: 'category',
  title: 'Category',
  type: 'document',
  fields: [
    {
      name: 'title',
      title: 'Title',
      type: 'string',
    },
    {
      name: 'description',
      title: 'Description',
      type: 'text',
    },
  ],
}
`, postTS = `import {defineField, defineType} from 'sanity'

export default defineType({
  name: 'post',
  title: 'Post',
  type: 'document',
  fields: [
    defineField({
      name: 'title',
      title: 'Title',
      type: 'string',
    }),
    defineField({
      name: 'slug',
      title: 'Slug',
      type: 'slug',
      options: {
        source: 'title',
        maxLength: 96,
      },
    }),
    defineField({
      name: 'author',
      title: 'Author',
      type: 'reference',
      to: {type: 'author'},
    }),
    defineField({
      name: 'mainImage',
      title: 'Main image',
      type: 'image',
      options: {
        hotspot: true,
      },
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        }
      ]
    }),
    defineField({
      name: 'categories',
      title: 'Categories',
      type: 'array',
      of: [{type: 'reference', to: {type: 'category'}}],
    }),
    defineField({
      name: 'publishedAt',
      title: 'Published at',
      type: 'datetime',
    }),
    defineField({
      name: 'body',
      title: 'Body',
      type: 'blockContent',
    }),
  ],

  preview: {
    select: {
      title: 'title',
      author: 'author.name',
      media: 'mainImage',
    },
    prepare(selection) {
      const {author} = selection
      return {...selection, subtitle: author && \`by \${author}\`}
    },
  },
})
`, postJS = `export const post = {
  name: 'post',
  title: 'Post',
  type: 'document',
  fields: [
    {
      name: 'title',
      title: 'Title',
      type: 'string',
    },
    {
      name: 'slug',
      title: 'Slug',
      type: 'slug',
      options: {
        source: 'title',
        maxLength: 96,
      },
    },
    {
      name: 'author',
      title: 'Author',
      type: 'reference',
      to: {type: 'author'},
    },
    {
      name: 'mainImage',
      title: 'Main image',
      type: 'image',
      options: {
        hotspot: true,
      },
      fields: [
        {
          name: 'alt',
          type: 'string',
          title: 'Alternative Text',
        }
      ]
    },
    {
      name: 'categories',
      title: 'Categories',
      type: 'array',
      of: [{type: 'reference', to: {type: 'category'}}],
    },
    {
      name: 'publishedAt',
      title: 'Published at',
      type: 'datetime',
    },
    {
      name: 'body',
      title: 'Body',
      type: 'blockContent',
    },
  ],

  preview: {
    select: {
      title: 'title',
      author: 'author.name',
      media: 'mainImage',
    },
    prepare(selection) {
      const {author} = selection
      return {...selection, subtitle: author && \`by \${author}\`}
    },
  },
}
`, blogSchemaTS = `import { type SchemaTypeDefinition } from 'sanity'

import blockContent from './schemaTypes/blockContent'
import category from './schemaTypes/category'
import post from './schemaTypes/post'
import author from './schemaTypes/author'

export const schema: { types: SchemaTypeDefinition[] } = {
  types: [post, author, category, blockContent],
}
`, blogSchemaJS = `import {blockContent} from './schemaTypes/blockContent'
import {category} from './schemaTypes/category'
import {post} from './schemaTypes/post'
import {author} from './schemaTypes/author'

export const schema = {
  types: [post, author, category, blockContent],
}
`, blogSchemaFolder = (useTypeScript) => ({
  "author.": useTypeScript ? authorTS : authorJS,
  "blockContent.": useTypeScript ? blockContentTS : blockContentJS,
  "category.": useTypeScript ? categoryTS : categoryJS,
  "post.": useTypeScript ? postTS : postJS
}), sanityConfigTemplate = `'use client'

/**
 * This configuration is used to for the Sanity Studio that\u2019s mounted on the \`:route:\` route
 */

import {visionTool} from '@sanity/vision'
import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'

// Go to https://www.sanity.io/docs/api-versioning to learn how API versioning works
import {apiVersion, dataset, projectId} from './sanity/env'
import {schema} from './sanity/schema'

export default defineConfig({
  basePath: ':basePath:',
  projectId,
  dataset,
  // Add and edit the content schema in the './sanity/schema' folder
  schema,
  plugins: [
    structureTool(),
    // Vision is a tool that lets you query your content with GROQ in the studio
    // https://www.sanity.io/docs/the-vision-plugin
    visionTool({defaultApiVersion: apiVersion}),
  ],
})
`, sanityCliTemplate = `/**
* This configuration file lets you run \`$ sanity [command]\` in this folder
* Go to https://www.sanity.io/docs/cli to learn more.
**/
import { defineCliConfig } from 'sanity/cli'

const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID
const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET

export default defineCliConfig({ api: { projectId, dataset } })
`, sanityStudioTemplate = `/**
 * This route is responsible for the built-in authoring environment using Sanity Studio.
 * All routes under your studio path is handled by this file using Next.js' catch-all routes:
 * https://nextjs.org/docs/routing/dynamic-routes#catch-all-routes
 *
 * You can learn more about the next-sanity package here:
 * https://github.com/sanity-io/next-sanity
 */

import { NextStudio } from 'next-sanity/studio'
import config from ':configPath:'

export const dynamic = 'force-static'

export { metadata, viewport } from 'next-sanity/studio'

export default function StudioPage() {
  return <NextStudio config={config} />
}`, envTS = `export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || '${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}'

export const dataset = assertValue(
  process.env.NEXT_PUBLIC_SANITY_DATASET,
  'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET'
)

export const projectId = assertValue(
  process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
  'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID'
)

export const useCdn = false

function assertValue<T>(v: T | undefined, errorMessage: string): T {
  if (v === undefined) {
    throw new Error(errorMessage)
  }

  return v
}
`, envJS = `export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || '${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}'

export const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET;
export const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID;
export const useCdn = false
`, schemaTS = `import { type SchemaTypeDefinition } from 'sanity'

export const schema: { types: SchemaTypeDefinition[] } = {
  types: [],
}
`, schemaJS = `export const schema = {
  types: [],
}
`, client = `import { createClient } from 'next-sanity'

import { apiVersion, dataset, projectId, useCdn } from '../env'

export const client = createClient({
  projectId,
  dataset,
  apiVersion,
  useCdn,
  perspective: 'published',
})
`, imageTS = `import createImageUrlBuilder from '@sanity/image-url'
import type { Image } from 'sanity'

import { dataset, projectId } from '../env'

const imageBuilder = createImageUrlBuilder({
  projectId: projectId || '',
  dataset: dataset || '',
})

export const urlForImage = (source: Image) => {
  return imageBuilder?.image(source).auto('format').fit('max').url()
}
`, imageJS = `import createImageUrlBuilder from '@sanity/image-url'

import { dataset, projectId } from '../env'

const imageBuilder = createImageUrlBuilder({
  projectId: projectId || '',
  dataset: dataset || '',
})

export const urlForImage = (source) => {
  return imageBuilder?.image(source).auto('format').fit('max').url()
}
`, sanityFolder = (useTypeScript, template) => {
  const isBlogTemplate = template === "blog", structure = {
    // eslint-disable-next-line no-nested-ternary
    "schema.": useTypeScript ? isBlogTemplate ? blogSchemaTS : schemaTS : isBlogTemplate ? blogSchemaJS : schemaJS,
    "env.": useTypeScript ? envTS : envJS,
    lib: {
      "client.": client,
      "image.": useTypeScript ? imageTS : imageJS
    }
  };
  return isBlogTemplate && (structure.schemaTypes = blogSchemaFolder(useTypeScript)), structure;
}, isCI = process.env.CI;
async function initSanity(args, context) {
  const {
    output,
    prompt: prompt2,
    workDir,
    apiClient,
    chalk: chalk2,
    sanityMajorVersion,
    telemetry: telemetry2,
    detectedFramework
  } = context, trace = telemetry2.trace(CLIInitStepCompleted), cliFlags = args.extOptions, unattended = cliFlags.y || cliFlags.yes, print = unattended ? lodashExports.noop : output.print, intendedPlan = cliFlags["project-plan"], intendedCoupon = cliFlags.coupon, reconfigure = cliFlags.reconfigure, commitMessage = cliFlags.git, useGit = typeof commitMessage > "u" ? !0 : !!commitMessage, bareOutput = cliFlags.bare, env = cliFlags.env;
  let defaultConfig = cliFlags["dataset-default"], showDefaultConfigPrompt = !defaultConfig;
  if (trace.start(), trace.log({
    step: "start",
    flags: {
      defaultConfig,
      unattended,
      plan: intendedPlan,
      coupon: intendedCoupon,
      reconfigure,
      git: commitMessage,
      bare: bareOutput,
      env
    }
  }), sanityMajorVersion === 2) {
    await reconfigureV2Project(args, context);
    return;
  }
  if (intendedCoupon && intendedPlan)
    throw new Error(
      "Error! --project-plan and --coupon cannot be used together; please select only one flag"
    );
  if (intendedCoupon && cliFlags.project)
    throw new Error(
      "Error! --project and --coupon cannot be used together; coupons can only be applied to new projects"
    );
  let selectedPlan;
  if (intendedCoupon)
    try {
      selectedPlan = await getPlanFromCoupon(apiClient, intendedCoupon), print(`Coupon "${intendedCoupon}" validated!
`);
    } catch (err) {
      if (err.statusCode == "404") {
        const useDefaultPlan = unattended ?? await prompt2.single({
          type: "confirm",
          message: `Coupon "${intendedCoupon}" is not available, use default plan instead?`,
          default: !0
        });
        if (unattended && output.warn(`Coupon "${intendedCoupon}" is not available - using default plan`), trace.log({
          step: "useDefaultPlanCoupon",
          selectedOption: useDefaultPlan ? "yes" : "no",
          coupon: intendedCoupon
        }), useDefaultPlan)
          print("Using default plan.");
        else
          throw new Error(`Coupon "${intendedCoupon}" does not exist`);
      } else
        throw new Error(`Unable to validate coupon, please try again later:

${err.message}`);
    }
  else if (intendedPlan)
    try {
      selectedPlan = await getPlanFromId(apiClient, intendedPlan);
    } catch (err) {
      if (err.statusCode == "404") {
        const useDefaultPlan = unattended ?? await prompt2.single({
          type: "confirm",
          message: `Project plan "${intendedPlan}" does not exist, use default plan instead?`,
          default: !0
        });
        if (unattended && output.warn(`Project plan "${intendedPlan}" does not exist - using default plan`), trace.log({
          step: "useDefaultPlanId",
          selectedOption: useDefaultPlan ? "yes" : "no",
          planId: intendedPlan
        }), useDefaultPlan)
          print("Using default plan.");
        else
          throw new Error(`Plan id "${intendedPlan}" does not exist`);
      } else
        throw new Error(`Unable to validate plan, please try again later:

${err.message}`);
    }
  if (reconfigure)
    throw new Error("`--reconfigure` is deprecated - manual configuration is now required");
  const envFilename = typeof env == "string" ? env : ".env";
  if (!envFilename.startsWith(".env"))
    throw new Error("Env filename must start with .env");
  const usingBareOrEnv = cliFlags.bare || cliFlags.env;
  print(
    cliFlags.quickstart ? "You're ejecting a remote Sanity project!" : "You're setting up a new project!"
  ), print(`We'll make sure you have an account with Sanity.io. ${usingBareOrEnv ? "" : "Then we'll"}`), usingBareOrEnv || (print("install an open-source JS content editor that connects to"), print(`the real-time hosted API on Sanity.io. Hang on.
`)), print(`Press ctrl + C at any time to quit.
`), print("Prefer web interfaces to terminals?"), print("You can also set up best practice Sanity projects with"), print(`your favorite frontends on https://www.sanity.io/templates
`);
  const hasToken = getUserConfig().get("authToken");
  loadEnv.debug(hasToken ? "User already has a token" : "User has no token"), hasToken ? (trace.log({ step: "login", alreadyLoggedIn: !0 }), print(`Looks like you already have a Sanity-account. Sweet!
`)) : unattended || (trace.log({ step: "login" }), await getOrCreateUser());
  const flags = await prepareFlags(), { projectId, displayName, isFirstProject, datasetName, schemaUrl } = await getProjectDetails(), sluggedName = lodashExports.deburr(displayName.toLowerCase()).replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "");
  if (bareOutput) {
    print(`
${chalk2.green("Success!")} Below are your project details:
`), print(`Project ID: ${chalk2.cyan(projectId)}`), print(`Dataset: ${chalk2.cyan(datasetName)}`), print(
      `
You can find your project on Sanity Manage \u2014 https://www.sanity.io/manage/project/${projectId}
`
    );
    return;
  }
  let initNext = !1;
  detectedFramework?.slug === "nextjs" && (initNext = await prompt2.single({
    type: "confirm",
    message: "Would you like to add configuration files for a Sanity project in this Next.js folder?",
    default: !0
  }), trace.log({
    step: "useDetectedFramework",
    selectedOption: initNext ? "yes" : "no",
    detectedFramework: detectedFramework?.name
  }));
  const initFramework = initNext;
  let outputPath = workDir;
  const defaults2 = await getProjectDefaults(workDir, { isPlugin: !1, context }), answers = await getProjectInfo();
  if (outputPath = answers.outputPath, initNext) {
    const useTypeScript2 = unattended ? !0 : await promptForTypeScript(prompt2);
    trace.log({ step: "useTypeScript", selectedOption: useTypeScript2 ? "yes" : "no" });
    const fileExtension = useTypeScript2 ? "ts" : "js";
    if (unattended || await promptForEmbeddedStudio(prompt2)) {
      const srcDir = "app";
      let srcPath = path__default.default.join(workDir, srcDir);
      fs$p.existsSync(srcPath) || (srcPath = path__default.default.join(workDir, "src", srcDir), fs$p.existsSync(srcPath) || await fs__default$1.default.mkdir(srcPath, { recursive: !0 }).catch(() => loadEnv.debug("Error creating folder %s", srcPath)));
      const studioPath = unattended ? "/studio" : await promptForStudioPath(prompt2), embeddedStudioRouteFilePath = path__default.default.join(
        srcPath,
        `${studioPath}/`,
        `[[...tool]]/page.${fileExtension}x`
      );
      await writeOrOverwrite(
        embeddedStudioRouteFilePath,
        sanityStudioTemplate.replace(
          ":configPath:",
          new Array(countNestedFolders(embeddedStudioRouteFilePath.slice(workDir.length))).join("../").concat("sanity.config")
        )
      );
      const sanityConfigPath = path__default.default.join(workDir, `sanity.config.${fileExtension}`);
      await writeOrOverwrite(
        sanityConfigPath,
        sanityConfigTemplate.replace(":route:", embeddedStudioRouteFilePath.slice(workDir.length).replace("src/", "")).replace(":basePath:", studioPath)
      );
    }
    const sanityCliPath = path__default.default.join(workDir, `sanity.cli.${fileExtension}`);
    await writeOrOverwrite(sanityCliPath, sanityCliTemplate);
    const writeSourceFiles = async (files, folderPath) => {
      for (const [filePath, content] of Object.entries(files))
        filePath.includes(".") && typeof content == "string" ? await writeOrOverwrite(
          path__default.default.join(workDir, "sanity", folderPath || "", `${filePath}${fileExtension}`),
          content
        ) : (await fs__default$1.default.mkdir(path__default.default.join(workDir, "sanity", filePath), { recursive: !0 }), typeof content == "object" && await writeSourceFiles(content, filePath));
    }, templateToUse = unattended ? "clean" : await promptForNextTemplate(prompt2);
    await writeSourceFiles(sanityFolder(useTypeScript2, templateToUse));
    const tsConfigPath = path__default.default.join(workDir, "tsconfig.json");
    if (useTypeScript2 && fs$p.existsSync(tsConfigPath)) {
      const tsConfigFile = fs$p.readFileSync(tsConfigPath, "utf8"), config2 = silverFleece.evaluate(tsConfigFile);
      if (config2.compilerOptions.target?.toLowerCase() !== "es2017") {
        config2.compilerOptions.target = "ES2017";
        const newConfig = silverFleece.patch(tsConfigFile, config2);
        await fs__default$1.default.writeFile(tsConfigPath, Buffer.from(newConfig));
      }
    }
    (unattended || await promptForAppendEnv(prompt2, envFilename)) && await createOrAppendEnvVars(envFilename, detectedFramework, {
      log: !0
    });
    const { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
    trace.log({ step: "selectPackageManager", selectedOption: chosen }), await installNewPackages(
      {
        packageManager: chosen,
        packages: ["@sanity/vision@3", "sanity@3", "@sanity/image-url@1", "styled-components@6"]
      },
      {
        output: context.output,
        workDir
      }
    );
    const execOptions = {
      encoding: "utf8",
      env: getPartialEnvWithNpmPath(workDir),
      cwd: workDir,
      stdio: "inherit"
    };
    chosen === "npm" ? await execa$1("npm", ["install", "next-sanity@9"], execOptions) : chosen === "yarn" ? await execa$1("npx", ["install-peerdeps", "--yarn", "next-sanity@9"], execOptions) : chosen === "pnpm" && await execa$1("pnpm", ["install", "next-sanity@9"], execOptions), print(
      `
${chalk2.green("Success!")} Your Sanity configuration files has been added to this project`
    ), process.exit(0);
    return;
  }
  function countNestedFolders(path2) {
    const separator2 = path2.includes("\\") ? "\\" : "/";
    return path2.split(separator2).filter(Boolean).length;
  }
  async function writeOrOverwrite(filePath, content) {
    if (fs$p.existsSync(filePath) && !await prompt2.single({
      type: "confirm",
      message: `File ${chalk2.yellow(
        filePath.replace(workDir, "")
      )} already exists. Do you want to overwrite it?`,
      default: !1
    }))
      return;
    const folderPath = path__default.default.dirname(filePath);
    await fs__default$1.default.mkdir(folderPath, { recursive: !0 }).catch(() => loadEnv.debug("Error creating folder %s", folderPath)), await fs__default$1.default.writeFile(filePath, content, {
      encoding: "utf8"
    });
  }
  if (env) {
    await createOrAppendEnvVars(envFilename, detectedFramework);
    return;
  }
  const templateName = await selectProjectTemplate();
  trace.log({ step: "selectProjectTemplate", selectedOption: templateName });
  const template = templates[templateName];
  if (!template)
    throw new Error(`Template "${templateName}" not found`);
  const typescriptOnly = template.typescriptOnly === !0;
  let useTypeScript = !0;
  !typescriptOnly && typeof cliFlags.typescript == "boolean" ? useTypeScript = cliFlags.typescript : !typescriptOnly && !unattended && (useTypeScript = await promptForTypeScript(prompt2), trace.log({ step: "useTypeScript", selectedOption: useTypeScript ? "yes" : "no" }));
  const templateOptions = {
    outputPath,
    packageName: sluggedName,
    templateName,
    schemaUrl,
    useTypeScript,
    variables: {
      dataset: datasetName,
      projectId,
      projectName: displayName || answers.projectName
    }
  }, shouldImport = !unattended && template.datasetUrl && await promptForDatasetImport(template.importPrompt);
  trace.log({ step: "importTemplateDataset", selectedOption: shouldImport ? "yes" : "no" }), await bootstrapTemplate(templateOptions, context);
  const pkgManager = await getPackageManagerChoice(outputPath, {
    prompt: prompt2,
    interactive: unattended ? !1 : isInteractive$2
  });
  if (trace.log({ step: "selectPackageManager", selectedOption: pkgManager.chosen }), await installDeclaredPackages(outputPath, pkgManager.chosen, context), useGit && tryGitInit(outputPath, typeof commitMessage == "string" ? commitMessage : void 0), shouldImport) {
    const importCommand = getImportCommand(outputPath);
    await doDatasetImport({
      projectId,
      outputPath,
      importCommand,
      template,
      datasetName,
      context
    }), await hasGlobalCli() && (print(""), print("If you want to delete the imported data, use"), print(`  ${chalk2.cyan(`sanity dataset delete ${datasetName}`)}`), print("and create a new clean dataset with"), print(`  ${chalk2.cyan("sanity dataset create <name>")}
`));
  }
  const devCommand = {
    yarn: "yarn dev",
    npm: "npm run dev",
    pnpm: "pnpm dev",
    bun: "bun dev",
    manual: "npm run dev"
  }[pkgManager.chosen];
  outputPath === process.cwd() ? (print(`
${chalk2.green("Success!")} Now, use this command to continue:
`), print(`${chalk2.cyan(devCommand)} - to run Sanity Studio
`)) : (print(`
${chalk2.green("Success!")} Now, use these commands to continue:
`), print(`First: ${chalk2.cyan(`cd ${outputPath}`)} - to enter project\u2019s directory`), print(`Then: ${chalk2.cyan(devCommand)} - to run Sanity Studio
`)), await hasGlobalCli() && (print("Other helpful commands"), print("sanity docs - to open the documentation in a browser"), print("sanity manage - to open the project settings in a browser"), print("sanity help - to explore the CLI manual"));
  try {
    (await apiClient({ api: { projectId } }).request({ uri: `/projects/${projectId}` }))?.metadata?.cliInitializedAt || await apiClient({ api: { projectId } }).request({
      method: "PATCH",
      uri: `/projects/${projectId}`,
      body: { metadata: { cliInitializedAt: (/* @__PURE__ */ new Date()).toISOString() } }
    });
  } catch {
    loadEnv.debug("Failed to update cliInitializedAt metadata");
  }
  const sendInvite = isFirstProject && await prompt2.single({
    type: "confirm",
    message: "We have an excellent developer community, would you like us to send you an invitation to join?",
    default: !0
  });
  sendInvite && (trace.log({ step: "sendCommunityInvite", selectedOption: sendInvite ? "yes" : "no" }), apiClient({ requireProject: !1 }).request({
    uri: "/invitations/community",
    method: "POST"
  }).catch(lodashExports.noop)), trace.complete();
  async function getOrCreateUser() {
    print("We can't find any auth credentials in your Sanity config"), print(`- log in or create a new account
`);
    const { extOptions, ...otherArgs } = args, loginArgs = { ...otherArgs, extOptions: {} };
    await login(loginArgs, { ...context, telemetry: trace.newContext("login") }), print("Good stuff, you're now authenticated. You'll need a project to keep your"), print("datasets and collaborators safe and snug.");
  }
  async function getProjectDetails() {
    if (flags.quickstart) {
      loadEnv.debug("Fetching project details from Journey API");
      const data = await journeyConfig.fetchJourneyConfig(apiClient, flags.quickstart);
      return trace.log({
        step: "fetchJourneyConfig",
        projectId: data.projectId,
        datasetName: data.datasetName,
        displayName: data.displayName,
        isFirstProject: data.isFirstProject
      }), data;
    }
    loadEnv.debug("Prompting user to select or create a project");
    const project = await getOrCreateProject();
    loadEnv.debug(`Project with name ${project.displayName} selected`), loadEnv.debug("Prompting user to select or create a dataset");
    const dataset = await getOrCreateDataset({
      projectId: project.projectId,
      displayName: project.displayName,
      dataset: flags.dataset,
      aclMode: flags.visibility,
      defaultConfig: flags["dataset-default"]
    });
    return loadEnv.debug(`Dataset with name ${dataset.datasetName} selected`), trace.log({
      step: "createOrSelectDataset",
      selectedOption: dataset.userAction,
      datasetName: dataset.datasetName,
      visibility: flags.visibility
    }), {
      projectId: project.projectId,
      displayName: project.displayName,
      isFirstProject: project.isFirstProject,
      datasetName: dataset.datasetName
    };
  }
  async function getOrCreateProject() {
    const spinner = context.output.spinner("Fetching existing projects").start();
    let projects, organizations;
    try {
      const client2 = apiClient({ requireUser: !0, requireProject: !1 }), [allProjects, allOrgs] = await Promise.all([
        client2.projects.list({ includeMembers: !1 }),
        client2.request({ uri: "/organizations" })
      ]);
      projects = allProjects.sort((a, b) => b.createdAt.localeCompare(a.createdAt)), organizations = allOrgs, spinner.succeed();
    } catch (err) {
      if (unattended && flags.project)
        return spinner.succeed(), {
          projectId: flags.project,
          displayName: "Unknown project",
          isFirstProject: !1,
          userAction: "select"
        };
      throw spinner.fail(), new Error(`Failed to communicate with the Sanity API:
${err.message}`);
    }
    if (projects.length === 0 && unattended)
      throw new Error("No projects found for current user");
    if (flags.project) {
      const project = projects.find((proj) => proj.id === flags.project);
      if (!project && !unattended)
        throw new Error(
          `Given project ID (${flags.project}) not found, or you do not have access to it`
        );
      return {
        projectId: flags.project,
        displayName: project ? project.displayName : "Unknown project",
        isFirstProject: !1,
        userAction: "select"
      };
    }
    if (flags.organization) {
      if (!(organizations.find((org) => org.id === flags.organization) || organizations.find((org) => org.slug === flags.organization)))
        throw new Error(
          `Given organization ID (${flags.organization}) not found, or you do not have access to it`
        );
      if (!await hasProjectAttachGrant(flags.organization))
        throw new Error(
          "You lack the necessary permissions to attach a project to this organization"
        );
    }
    const isUsersFirstProject = projects.length === 0;
    if (isUsersFirstProject || intendedCoupon) {
      loadEnv.debug(
        isUsersFirstProject ? "No projects found for user, prompting for name" : "Using a coupon - skipping project selection"
      );
      const projectName = await prompt2.single({ type: "input", message: "Project name:" });
      return createProject(apiClient, {
        displayName: projectName,
        organizationId: await getOrganizationId(organizations),
        subscription: selectedPlan ? { planId: selectedPlan } : void 0,
        metadata: { coupon: intendedCoupon }
      }).then((response) => ({
        ...response,
        isFirstProject: isUsersFirstProject,
        userAction: "create",
        coupon: intendedCoupon
      }));
    }
    loadEnv.debug(`User has ${projects.length} project(s) already, showing list of choices`);
    const projectChoices = projects.map((project) => ({
      value: project.id,
      name: `${project.displayName} [${project.id}]`
    })), selected = await prompt2.single({
      message: "Select project to use",
      type: "list",
      choices: [
        { value: "new", name: "Create new project" },
        new prompt2.Separator(),
        ...projectChoices
      ]
    });
    return selected === "new" ? (loadEnv.debug("User wants to create a new project, prompting for name"), createProject(apiClient, {
      displayName: await prompt2.single({
        type: "input",
        message: "Your project name:",
        default: "My Sanity Project"
      }),
      organizationId: await getOrganizationId(organizations),
      subscription: selectedPlan ? { planId: selectedPlan } : void 0,
      metadata: { coupon: intendedCoupon }
    }).then((response) => ({
      ...response,
      isFirstProject: isUsersFirstProject,
      userAction: "create"
    }))) : (loadEnv.debug(`Returning selected project (${selected})`), {
      projectId: selected,
      displayName: projects.find((proj) => proj.id === selected)?.displayName || "",
      isFirstProject: isUsersFirstProject,
      userAction: "select"
    });
  }
  async function getOrCreateDataset(opts) {
    if (opts.dataset && (isCI || unattended))
      return { datasetName: opts.dataset, userAction: "none" };
    const client2 = apiClient({ api: { projectId: opts.projectId } }), [datasets, projectFeatures] = await Promise.all([
      client2.datasets.list(),
      client2.request({ uri: "/features" })
    ]), privateDatasetsAllowed = projectFeatures.includes("privateDataset"), allowedModes = privateDatasetsAllowed ? ["public", "private"] : ["public"];
    if (opts.aclMode && !allowedModes.includes(opts.aclMode))
      throw new Error(`Visibility mode "${opts.aclMode}" not allowed`);
    const getAclMode = async () => opts.aclMode ? opts.aclMode : unattended || !privateDatasetsAllowed || defaultConfig ? "public" : privateDatasetsAllowed ? await promptForAclMode(prompt2, output) : "public";
    if (opts.dataset) {
      if (loadEnv.debug("User has specified dataset through a flag (%s)", opts.dataset), !datasets.find((ds) => ds.name === opts.dataset)) {
        loadEnv.debug("Specified dataset not found, creating it");
        const aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
        await client2.datasets.create(opts.dataset, { aclMode }), spinner.succeed();
      }
      return { datasetName: opts.dataset, userAction: "none" };
    }
    const datasetInfo = `Your content will be stored in a dataset that can be public or private, depending on
whether you want to query your content with or without authentication.
The default dataset configuration has a public dataset named "production".`;
    if (datasets.length === 0) {
      loadEnv.debug("No datasets found for project, prompting for name"), showDefaultConfigPrompt && (output.print(datasetInfo), defaultConfig = await promptForDefaultConfig(prompt2));
      const name = defaultConfig ? "production" : await promptForDatasetName(prompt2, {
        message: "Name of your first dataset:"
      }), aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
      return await client2.datasets.create(name, { aclMode }), spinner.succeed(), { datasetName: name, userAction: "create" };
    }
    loadEnv.debug(`User has ${datasets.length} dataset(s) already, showing list of choices`);
    const datasetChoices = datasets.map((dataset) => ({ value: dataset.name })), selected = await prompt2.single({
      message: "Select dataset to use",
      type: "list",
      choices: [
        { value: "new", name: "Create new dataset" },
        new prompt2.Separator(),
        ...datasetChoices
      ]
    });
    if (selected === "new") {
      const existingDatasetNames = datasets.map((ds) => ds.name);
      loadEnv.debug("User wants to create a new dataset, prompting for name"), showDefaultConfigPrompt && !existingDatasetNames.includes("production") && (output.print(datasetInfo), defaultConfig = await promptForDefaultConfig(prompt2));
      const newDatasetName = defaultConfig ? "production" : await promptForDatasetName(
        prompt2,
        {
          message: "Dataset name:"
        },
        existingDatasetNames
      ), aclMode = await getAclMode(), spinner = context.output.spinner("Creating dataset").start();
      return await client2.datasets.create(newDatasetName, { aclMode }), spinner.succeed(), { datasetName: newDatasetName, userAction: "create" };
    }
    return loadEnv.debug(`Returning selected dataset (${selected})`), { datasetName: selected, userAction: "select" };
  }
  function promptForDatasetImport(message) {
    return prompt2.single({
      type: "confirm",
      message: message || "This template includes a sample dataset, would you like to use it?",
      default: !0
    });
  }
  function selectProjectTemplate() {
    return flags.quickstart ? "quickstart" : (unattended || flags.template ? flags.template || "clean" : null) || prompt2.single({
      message: "Select project template",
      type: "list",
      choices: [
        {
          value: "moviedb",
          name: "Movie project (schema + sample data)"
        },
        {
          value: "shopify",
          name: "E-commerce (Shopify)"
        },
        {
          value: "blog",
          name: "Blog (schema)"
        },
        {
          value: "clean",
          name: "Clean project with no predefined schema types"
        }
      ]
    });
  }
  async function getProjectInfo() {
    const specifiedPath = flags["output-path"] && path__default.default.resolve(flags["output-path"]);
    if (unattended || specifiedPath || env || initFramework)
      return {
        ...defaults2,
        outputPath: specifiedPath || workDir
      };
    const workDirIsEmpty = (await fs__default$1.default.readdir(workDir)).length === 0, projectOutputPath = await prompt2.single({
      type: "input",
      message: "Project output path:",
      default: workDirIsEmpty ? workDir : path__default.default.join(workDir, sluggedName),
      validate: validateEmptyPath,
      filter: absolutify
    });
    return {
      ...defaults2,
      outputPath: projectOutputPath
    };
  }
  async function prepareFlags() {
    const createProjectName = cliFlags["create-project"];
    if ((cliFlags.dataset || cliFlags.visibility || cliFlags["dataset-default"] || unattended) && (showDefaultConfigPrompt = !1), cliFlags.project && createProjectName)
      throw new Error(
        "Both `--project` and `--create-project` specified, only a single is supported"
      );
    if (cliFlags.project && cliFlags.organization)
      throw new Error(
        "You have specified both a project and an organization. To move a project to an organization please visit https://www.sanity.io/manage"
      );
    if (cliFlags.quickstart && (cliFlags.project || cliFlags.dataset || cliFlags.visibility || cliFlags.template)) {
      const usedDisallowedStr = ["project", "dataset", "visibility", "template"].filter((flag) => cliFlags[flag]).map((flag) => `--${flag}`).join(", ");
      throw new Error(`\`--quickstart\` cannot be combined with ${usedDisallowedStr}`);
    }
    if (createProjectName === !0)
      throw new Error("Please specify a project name (`--create-project <name>`)");
    if (typeof createProjectName == "string" && createProjectName.trim().length === 0)
      throw new Error("Please specify a project name (`--create-project <name>`)");
    if (unattended && (loadEnv.debug("Unattended mode, validating required options"), ["dataset", "output-path"].forEach((flag) => {
      if (!cliFlags[flag])
        throw new Error(`\`--${flag}\` must be specified in unattended mode`);
    }), !cliFlags.project && !createProjectName))
      throw new Error(
        "`--project <id>` or `--create-project <name>` must be specified in unattended mode"
      );
    if (createProjectName) {
      loadEnv.debug("--create-project specified, creating a new project");
      const createdProject = await createProject(apiClient, {
        displayName: createProjectName.trim(),
        organizationId: cliFlags.organization || void 0,
        subscription: selectedPlan ? { planId: selectedPlan } : void 0,
        metadata: { coupon: intendedCoupon }
      });
      if (loadEnv.debug("Project with ID %s created", createdProject.projectId), cliFlags.dataset) {
        loadEnv.debug("--dataset specified, creating dataset (%s)", cliFlags.dataset);
        const client2 = apiClient({ api: { projectId: createdProject.projectId } }), spinner = context.output.spinner("Creating dataset").start(), createBody = cliFlags.visibility ? { aclMode: cliFlags.visibility } : {};
        await client2.datasets.create(cliFlags.dataset, createBody), spinner.succeed();
      }
      const newFlags = { ...cliFlags, project: createdProject.projectId };
      return delete newFlags["create-project"], newFlags;
    }
    return cliFlags;
  }
  async function getOrganizationId(organizations) {
    let organizationId = flags.organization;
    if (unattended)
      return organizationId || void 0;
    if (organizations.length > 0 && !organizationId) {
      loadEnv.debug(`User has ${organizations.length} organization(s), checking attach access`);
      const withGrant = await getOrganizationsWithAttachGrant(organizations);
      if (withGrant.length === 0) {
        loadEnv.debug("User lacks project attach grant in all organizations, not prompting");
        return;
      }
      loadEnv.debug("User has attach access to %d organizations, prompting.", withGrant.length);
      const organizationChoices = [
        { value: "none", name: "None" },
        new prompt2.Separator(),
        ...withGrant.map((organization) => ({
          value: organization.id,
          name: `${organization.name} [${organization.id}]`
        }))
      ], chosenOrg = await prompt2.single({
        message: "Select organization to attach project to",
        type: "list",
        choices: organizationChoices
      });
      chosenOrg && chosenOrg !== "none" && (organizationId = chosenOrg);
    } else organizationId ? loadEnv.debug("User has defined organization flag explicitly (%s)", organizationId) : organizations.length === 0 && loadEnv.debug("User has no organizations, skipping selection prompt");
    return organizationId || void 0;
  }
  async function hasProjectAttachGrant(organizationId) {
    const requiredGrantGroup = "sanity.organization.projects", requiredGrant = "attach";
    return ((await apiClient({ requireProject: !1, requireUser: !0 }).clone().config({ apiVersion: "v2021-06-07" }).request({ uri: `organizations/${organizationId}/grants` }))[requiredGrantGroup] || []).some(
      (resource) => resource.grants && resource.grants.some((grant) => grant.name === requiredGrant)
    );
  }
  function getOrganizationsWithAttachGrant(organizations) {
    return pFilter$1(organizations, (org) => hasProjectAttachGrant(org.id), { concurrency: 3 });
  }
  async function createOrAppendEnvVars(filename, framework, options2) {
    const envVars = {
      PROJECT_ID: projectId,
      DATASET: datasetName
    };
    try {
      framework && framework.envPrefix && !options2?.log && print(
        `
Detected framework ${chalk2.blue(framework?.name)}, using prefix '${framework.envPrefix}'`
      ), await writeEnvVarsToFile(filename, envVars, {
        framework,
        outputPath,
        log: options2?.log
      });
    } catch (err) {
      throw print(err), new Error("An error occurred while creating .env", { cause: err });
    }
  }
  async function writeEnvVarsToFile(filename, envVars, options2) {
    const envPrefix = options2.framework?.envPrefix || "", keyPrefix = envPrefix.includes("SANITY") ? envPrefix : `${envPrefix}SANITY_`, fileOutputPath = path__default.default.join(options2.outputPath, filename);
    for (const key2 of Object.keys(envVars))
      envVars[`${keyPrefix}${key2}`] = envVars[key2], delete envVars[key2];
    await fs__default$1.default.mkdir(options2.outputPath, { recursive: !0 }).catch(() => loadEnv.debug("Error creating folder %s", options2.outputPath));
    const existingEnv = await fs__default$1.default.readFile(fileOutputPath, { encoding: "utf8" }).catch((err) => err.code === "ENOENT" ? "" : Promise.reject(err)), updatedEnv = parseAndUpdateEnvVars(existingEnv, envVars, {
      log: options2.log
    }), warningComment = [
      "# Warning: Do not add secrets (API keys and similar) to this file, as it source controlled!",
      "# Use `.env.local` for any secrets, and ensure it is not added to source control"
    ].join(`
`);
    if (!existingEnv.includes(warningComment)) {
      await fs__default$1.default.writeFile(fileOutputPath, `${warningComment}

${updatedEnv}`, {
        encoding: "utf8"
      });
      return;
    }
    await fs__default$1.default.writeFile(fileOutputPath, updatedEnv, {
      encoding: "utf8"
    }), options2.log || print(`
${chalk2.green("Success!")} Environment variables written to ${fileOutputPath}`);
  }
  function parseAndUpdateEnvVars(fileContents, envVars, options2) {
    const existingKeys = loadEnv.dotenv.parse(fileContents), updatedKeys = {};
    for (const [key2, value] of Object.entries(envVars)) {
      if (!existingKeys[key2]) {
        updatedKeys[key2] = value, options2?.log || print(`Appended ${key2}="${envVars[key2]}"`);
        continue;
      }
      options2?.log || print(`Found existing ${key2}, replacing value.`), updatedKeys[key2] = value;
    }
    let updatedEnv = fileContents;
    for (const [key2, value] of Object.entries(updatedKeys))
      if (existingKeys[key2]) {
        const existingValue = existingKeys[key2];
        updatedEnv = updatedEnv.split(`
`).map((line3) => !line3.trim().startsWith("#") && // ignore comments
        new RegExp(`(^\\s*${key2})((: )|( *=))`).test(line3) ? line3.replace(existingValue, value) : line3).join(`
`);
      } else
        updatedEnv = updatedEnv.trim().concat(`
${key2}="${value}"`);
    return updatedEnv.concat(fileContents === "" ? `
` : "");
  }
}
function doDatasetImport(options2) {
  const { outputPath, importCommand, template, datasetName, projectId, context } = options2;
  if (!template.datasetUrl)
    return Promise.resolve(void 0);
  if (!importCommand)
    throw new Error("Failed to find `sanity dataset import` command");
  const commandArgs = {
    argv: [template.datasetUrl, datasetName],
    argsWithoutOptions: [template.datasetUrl, datasetName],
    extOptions: {},
    groupOrCommand: "import",
    extraArguments: []
  }, configPath2 = context.cliConfigPath || path__default.default.join(outputPath, "sanity.cli.js"), apiClient = getClientWrapper({ projectId, dataset: datasetName }, configPath2), commandContext = {
    ...context,
    apiClient,
    workDir: outputPath,
    fromInitCommand: !0
  };
  return importCommand.action(commandArgs, commandContext);
}
async function getPlanFromCoupon(apiClient, couponCode) {
  const planId = (await apiClient({
    requireUser: !1,
    requireProject: !1
  }).request({
    method: "GET",
    uri: `plans/coupon/${couponCode}`
  }))[0].id;
  if (!planId)
    throw new Error("Unable to find a plan from coupon code");
  return planId;
}
async function getPlanFromId(apiClient, planId) {
  const id = (await apiClient({
    requireUser: !1,
    requireProject: !1
  }).request({
    method: "GET",
    uri: `plans/${planId}`
  }))[0].id;
  if (!id)
    throw new Error(`Unable to find a plan with id ${planId}`);
  return id;
}
function getImportCommand(outputPath, studioVersion) {
  {
    const pkgPath2 = resolveFrom$1.silent(outputPath, "sanity/_internal");
    if (!pkgPath2)
      throw new Error("Failed to resolve `sanity` module - problem with dependency installation?");
    loadEnv.debug("`sanity` module path resolved to %s (from %s)", pkgPath2, outputPath);
    const cliInternals = getCliConfig.dynamicRequire(pkgPath2);
    if (!("cliProjectCommands" in cliInternals))
      throw new Error("Incorrect version of the `sanity` module installed");
    return cliInternals.cliProjectCommands.commands.find(
      (cmd) => !isCommandGroup(cmd) && cmd.name === "import" && cmd.group === "dataset"
    );
  }
}
async function hasGlobalCli() {
  try {
    return !!await which$2("sanity");
  } catch {
    return !1;
  }
}
const helpText$8 = `
Options
  -y, --yes Use unattended mode, accepting defaults and using only flags for choices
  --project <projectId> Project ID to use for the studio
  --organization <organizationId> Organization ID to use for the project
  --dataset <dataset> Dataset name for the studio
  --dataset-default Set up a project with a public dataset named "production"
  --output-path <path> Path to write studio project to
  --template <template> Project template to use [default: "clean"]
  --bare Skip the Studio initialization and only print the selected project ID and dataset name to stdout
  --env <filename> Write environment variables to file [default: ".env"]
  --provider <provider> Login provider to use
  --visibility <mode> Visibility mode for dataset (public/private)
  --create-project <name> Create a new project with the given name
  --project-plan <name> Optionally select a plan for a new project
  --coupon <name> Optionally select a coupon for a new project (cannot be used with --project-plan)
  --no-typescript Do not use TypeScript for template files

Examples
  # Initialize a new project, prompt for required information along the way
  sanity init

  # Initialize a new project with a public dataset named "production"
  sanity init --dataset-default

  # Initialize a project with the given project ID and dataset to the given path
  sanity init -y --project abc123 --dataset production --output-path ~/myproj

  # Initialize a project with the given project ID and dataset using the moviedb
  # template to the given path
  sanity init -y --project abc123 --dataset staging --template moviedb --output-path .

  # Create a brand new project with name "Movies Unlimited"
  sanity init -y \\
    --create-project "Movies Unlimited" \\
    --dataset moviedb \\
    --visibility private \\
    --template moviedb \\
    --output-path /Users/espenh/movies-unlimited
`, initCommand = {
  name: "init",
  signature: "",
  description: "Initializes a new Sanity Studio and/or project",
  helpText: helpText$8,
  action: async (args, context) => {
    const { output, chalk: chalk2, prompt: prompt2 } = context, [type2] = args.argsWithoutOptions, unattended = args.extOptions.y || args.extOptions.yes, warn = (msg) => output.warn(chalk2.yellow.bgBlack(msg));
    if (type2 === "plugin")
      return context.sanityMajorVersion === 2 ? (
        // don't bother with telemetry here, as it's not supported in v3
        initPlugin(args, context)
      ) : Promise.reject(new Error("'sanity init plugin' is not available in modern studios"));
    if (type2)
      return Promise.reject(new Error(`Unknown init type "${type2}"`));
    const detectedFramework = await distExports.detectFrameworkRecord({
      fs: new distExports.LocalFileSystemDetector(process.cwd()),
      frameworkList: frameworks.frameworks
    });
    if (args.argv.includes("--from-create") || args.argv.includes("--env") || args.argv.includes("--bare") || detectedFramework?.slug === "nextjs")
      return initSanity(args, {
        ...context,
        detectedFramework
      });
    warn("\u256D\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256E"), warn("\u2502                                                            \u2502"), warn("\u2502  Welcome to Sanity! It looks like you're following         \u2502"), warn("\u2502  instructions for Sanity Studio v2, but the version you    \u2502"), warn("\u2502  have installed is the latest - Sanity Studio v3.          \u2502"), warn("\u2502                                                            \u2502"), warn("\u2502  In Sanity Studio v3, new projects are created by running  \u2502"), warn("\u2502  [npm create sanity@latest]. For more information, see     \u2502"), warn("\u2502   https://www.sanity.io/help/studio-v2-vs-v3               \u2502"), warn("\u2502                                                            \u2502"), warn("\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256F"), warn(""), unattended || await prompt2.single({
      message: "Continue creating a Sanity Studio v3 project?",
      type: "confirm"
    }) || process.exit(1);
    const returnVal = await initSanity(args, {
      ...context,
      detectedFramework
    }).catch((err) => Promise.reject(err));
    return warn("\u256D\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256E"), warn("\u2502                                                            \u2502"), warn("\u2502  To learn how commands have changed from Studio v2 to v3,  \u2502"), warn("\u2502  see https://www.sanity.io/help/studio-v2-vs-v3            \u2502"), warn("\u2502                                                            \u2502"), warn("\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256F"), warn(""), returnVal;
  }
}, installCommand = {
  name: "install",
  signature: "",
  helpText: "",
  description: "Installs dependencies for Sanity Studio project",
  action: async (args, context) => {
    const { workDir, prompt: prompt2, sanityMajorVersion } = context, packages = args.argsWithoutOptions;
    if (packages.length > 0 && sanityMajorVersion === 2)
      throw new Error("Re-run this command with `@sanity/core` installed");
    const pkgManager = await getPackageManagerChoice(workDir, { prompt: prompt2 });
    packages.length > 0 ? await installNewPackages(
      { packageManager: pkgManager.chosen, packages: args.argsWithoutOptions },
      context
    ) : await installDeclaredPackages(workDir, pkgManager.chosen, context);
  }
}, helpText$7 = `
Options
  --sso <slug> Log in using Single Sign On, using the given slug
  --provider <providerId> Authenticate against a specific provider
  --no-open Do not open a browser window to log in, only print URL

Examples
  # Log in using default settings
  sanity login

  # Log in using Single Sign-On with the "my-organization" slug
  sanity login --sso my-organization

  # Login with GitHub provider, but do not open a browser window automatically
  sanity login --provider github --no-open
`, loginCommand = {
  name: "login",
  signature: "[--sso <slug>] [--provider <providerId>] [--no-open]",
  helpText: helpText$7,
  description: "Authenticates the CLI for access to Sanity projects",
  action: login
}, helpText$6 = `
Examples
  # Log out of the CLI
  sanity logout
`, logoutCommand = {
  name: "logout",
  helpText: helpText$6,
  signature: "logout",
  description: "Logs out the CLI from the current user session",
  async action(args, { output, apiClient }) {
    const cfg = getUserConfig();
    if (!cfg.get("authToken")) {
      output.print(chalk__default.default.red("No login credentials found"));
      return;
    }
    const client2 = apiClient({ requireUser: !0, requireProject: !1 });
    try {
      await client2.request({ uri: "/auth/logout", method: "POST" });
    } catch (err) {
      if ((err && err.response && err.response.statusCode) !== 401) {
        output.error(chalk__default.default.red(`Failed to communicate with the Sanity API:
${err.message}`));
        return;
      }
    }
    cfg.delete("authType"), cfg.delete("authToken"), cfg.delete(TELEMETRY_CONSENT_CONFIG_KEY), output.print(chalk__default.default.green("Logged out"));
  }
}, manageCommand = {
  name: "manage",
  signature: "manage",
  helpText: "",
  description: "Opens project management interface in your web browser",
  async action(args, context) {
    const { output, cliConfig } = context, { print } = output, projectId = cliConfig?.api?.projectId, url2 = projectId ? `https://www.sanity.io/manage/project/${projectId}` : "https://www.sanity.io/manage/";
    print(`Opening ${url2}`), await open$1(url2);
  }
}, headings = ["id", "members", "name", "url", "created"], helpText$5 = `
Options
  --sort <field> Sort output by specified column
  --order <asc/desc> Sort output ascending/descending

Examples
  # List projects
  sanity projects list

  # List projects sorted by member count, ascending
  sanity projects list --sort=members --order=asc
`, defaultFlags = {
  sort: "created",
  order: "desc"
}, listProjectsCommand = {
  name: "list",
  group: "projects",
  signature: "",
  helpText: helpText$5,
  description: "Lists projects connected to your user",
  action: async (args, context) => {
    const { apiClient, output, chalk: chalk2 } = context, flags = { ...defaultFlags, ...args.extOptions }, projects = await apiClient({
      requireUser: !0,
      requireProject: !1
    }).projects.list(), ordered = lodashExports.sortBy(
      projects.map(({ displayName, id, members = [], studioHost = "", createdAt }) => {
        const studio = studioHost ? `https://${studioHost}.sanity.studio` : "Not deployed";
        return [id, members.length, displayName, studio, createdAt].map(String);
      }),
      [headings.indexOf(flags.sort)]
    ), rows = flags.order === "asc" ? ordered : ordered.reverse(), maxWidths = rows.reduce(
      (max2, row) => row.map((current, index) => Math.max(lodashExports.size(current), max2[index])),
      headings.map((str2) => lodashExports.size(str2))
    ), printRow = (row) => row.map((col, i2) => `${col}`.padEnd(maxWidths[i2])).join("   ");
    output.print(chalk2.cyan(printRow(headings))), rows.forEach((row) => output.print(printRow(row)));
  }
}, projectGroup = {
  name: "projects",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Lists all projects associated with your logged-in account"
}, helpText$4 = `
Examples
  # Check telemetry consent status for your logged in user
  sanity telemetry status
`;
function telemetryStatusMessage(status, { chalk: chalk2 }) {
  switch (status) {
    case "granted":
      return `Status: ${chalk2.green("Enabled")}`;
    case "denied":
      return `Status: ${chalk2.red("Disabled")}`;
    case "unset":
      return `Status: ${chalk2.yellow("Not set")}`;
    default:
      return "";
  }
}
function telemetryLearnMoreMessage(status) {
  const url2 = "https://www.sanity.io/telemetry";
  switch (status) {
    case "granted":
      return `Learn more about the data being collected here:
${url2}`;
    default:
      return `Learn more here:
${url2}`;
  }
}
const telemetryStatusCommand = {
  name: "status",
  group: "telemetry",
  helpText: helpText$4,
  signature: "",
  description: "Check telemetry consent status for your logged in user",
  action: async (_2, context) => {
    const { chalk: chalk2, output } = context, { status, reason } = await resolveConsent({ env: process.env });
    switch (!0) {
      case (status === "undetermined" && reason === "unauthenticated"):
        output.print("You need to log in first to see telemetry status.");
        break;
      case (status === "undetermined" && reason === "fetchError"):
        output.print(chalk2.yellow("Could not fetch telemetry consent status."));
        break;
      case (status === "denied" && reason === "localOverride"):
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(
          `You've opted out of telemetry data collection.
No data will be collected from your machine.
`
        ), output.print(`Using ${chalk2.cyan("DO_NOT_TRACK")} environment variable.`);
        break;
      case status === "denied":
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(
          `You've opted out of telemetry data collection.
No data will be collected from your Sanity account.`
        );
        break;
      case status === "granted":
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(
          "Telemetry data on general usage and errors is collected to help us improve Sanity."
        );
        break;
      case status === "unset":
        output.print(`${telemetryStatusMessage(status, context)}
`), output.print(`You've not set your preference for telemetry collection.
`), output.print(`Run ${chalk2.cyan("npx sanity telemetry enable/disable")} to opt in or out.`), output.print(
          `You can also use the ${chalk2.cyan("DO_NOT_TRACK")} environment variable to opt out.`
        );
        break;
    }
    output.print(`
${telemetryLearnMoreMessage(status)}`);
  }
}, resultMessages = {
  granted: {
    success: () => "You've now enabled telemetry data collection to help us improve Sanity.",
    unchanged: () => "You've already enabled telemetry data collection to help us improve Sanity.",
    failure: (message) => message ? `Failed to enable telemetry: ${message}` : "Failed to enable telemetry"
  },
  denied: {
    success: () => `You've opted out of telemetry data collection.
No data will be collected from your Sanity account.`,
    unchanged: ({ reason }) => reason === "localOverride" ? `You've already opted out of telemetry data collection.
No data is collected from your machine.

Using DO_NOT_TRACK environment variable.` : `You've already opted out of telemetry data collection.
No data is collected from your Sanity account.`,
    failure: () => "Failed to disable telemetry"
  }
};
function createSetTelemetryConsentAction(status) {
  return async function(_2, context) {
    const { apiClient, output } = context, config2 = getUserConfig(), client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }).withConfig({
      apiVersion: "2023-12-18",
      useProjectHostname: !1
    }), currentInformation = await resolveConsent({ env: process.env }), isChanged = currentInformation.status !== status;
    if (isChanged || (loadEnv.debug('Telemetry consent is already "%s"', status), output.print(`${telemetryStatusMessage(status, context)}
`), output.print(resultMessages[status].unchanged(currentInformation))), isChanged) {
      loadEnv.debug('Setting telemetry consent to "%s"', status);
      try {
        const uri = `/users/me/consents/telemetry/status/${status}`;
        loadEnv.debug("Sending telemetry consent status to %s", uri), await client2.request({
          method: "PUT",
          uri
        }), config2.delete(TELEMETRY_CONSENT_CONFIG_KEY), output.print(`${telemetryStatusMessage(status, context)}
`), output.print(resultMessages[status].success());
      } catch (err) {
        const errorMessage = resultMessages[status].failure(err.response?.body?.message);
        throw err.statusCode === 403 ? new Error(errorMessage) : (err.message = errorMessage, err);
      }
    }
    output.print(`
${telemetryLearnMoreMessage(status)}`);
  };
}
const helpText$3 = `
Examples
  # Disable telemetry for your logged in user
  sanity telemetry disable
`, disableTelemetryCommand = {
  name: "disable",
  group: "telemetry",
  helpText: helpText$3,
  signature: "",
  description: "Disable telemetry for your logged in user",
  action: createSetTelemetryConsentAction("denied")
}, helpText$2 = `
Examples
  # Enable telemetry for your logged in user
  sanity telemetry enable
`, enableTelemetryCommand = {
  name: "enable",
  group: "telemetry",
  helpText: helpText$2,
  signature: "",
  description: "Enable telemetry for your logged in user",
  action: createSetTelemetryConsentAction("granted")
}, telemetryGroup = {
  name: "telemetry",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Manages telemetry settings, opting in or out of data collection"
}, description = "Generates TypeScript types from schema types and GROQ queries", helpText$1 = `
Sanity TypeGen (Beta)
This command is currently in beta and may undergo significant changes. Feedback is welcome!

Usage
  sanity typegen generate [options]

Options:
  --config-path <path>
    Specifies the path to the typegen configuration file. This file should be a JSON file that contains settings for the type generation process.
    Default: "sanity-typegen.json"

  --help, -h
    Displays this help message, providing information on command usage and options.

Examples:
  Generate TypeScript type definitions from a Sanity Studio schema extracted using the \`sanity schema extract\` command.
    $ sanity typegen generate

Configuration:
This command can utilize configuration settings defined in a \`sanity-typegen.json\` file. These settings include:

- "path": Specifies a glob pattern to locate your TypeScript or JavaScript files.
  Default: "./src/**/*.{ts,tsx,js,jsx}"

- "schema": Defines the path to your Sanity schema file. This file should be generated using the \`sanity schema extract\` command.
  Default: "schema.json"

- "generates": Indicates the path where the generated TypeScript type definitions will be saved.
  Default: "./sanity.types.ts"

The default configuration values listed above are used if not overridden in your \`sanity-typegen.json\` configuration file. To customize the behavior of the type generation, adjust these properties in the configuration file according to your project's needs.

Note:
- The \`sanity schema extract\` command is a prerequisite for extracting your Sanity Studio schema into a \`schema.json\` file, which is then used by the \`sanity typegen generate\` command to generate type definitions.
- While this tool is in beta, we encourage you to experiment with these configurations and provide feedback to help improve its functionality and usability.
`, generateTypegenCommand = {
  name: "generate",
  group: "typegen",
  signature: "",
  description,
  helpText: helpText$1,
  action: async (args, context) => (await Promise.resolve().then(function() {
    return require("./generateAction.js");
  })).default(args, context)
}, typegenGroup = {
  name: "typegen",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Beta: Generate TypeScript types for schema and GROQ"
};
var boxen$1 = { exports: {} }, stringWidth$5 = { exports: {} }, ansiRegex$3 = ({ onlyFirst = !1 } = {}) => {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
};
const ansiRegex$2 = ansiRegex$3;
var stripAnsi$4 = (string) => typeof string == "string" ? string.replace(ansiRegex$2(), "") : string, isFullwidthCodePoint$3 = { exports: {} };
const isFullwidthCodePoint$2 = (codePoint) => Number.isNaN(codePoint) ? !1 : codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
// CJK Radicals Supplement .. Enclosed CJK Letters and Months
11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
131072 <= codePoint && codePoint <= 262141);
isFullwidthCodePoint$3.exports = isFullwidthCodePoint$2;
isFullwidthCodePoint$3.exports.default = isFullwidthCodePoint$2;
var isFullwidthCodePointExports = isFullwidthCodePoint$3.exports, emojiRegex$1 = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
const stripAnsi$3 = stripAnsi$4, isFullwidthCodePoint$1 = isFullwidthCodePointExports, emojiRegex = emojiRegex$1, stringWidth$4 = (string) => {
  if (typeof string != "string" || string.length === 0 || (string = stripAnsi$3(string), string.length === 0))
    return 0;
  string = string.replace(emojiRegex(), "  ");
  let width = 0;
  for (let i2 = 0; i2 < string.length; i2++) {
    const code = string.codePointAt(i2);
    code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || (code > 65535 && i2++, width += isFullwidthCodePoint$1(code) ? 2 : 1);
  }
  return width;
};
stringWidth$5.exports = stringWidth$4;
stringWidth$5.exports.default = stringWidth$4;
var stringWidthExports = stringWidth$5.exports, widestLine$2 = { exports: {} };
const stringWidth$3 = stringWidthExports, widestLine$1 = (input2) => {
  let max2 = 0;
  for (const line3 of input2.split(`
`))
    max2 = Math.max(max2, stringWidth$3(line3));
  return max2;
};
widestLine$2.exports = widestLine$1;
widestLine$2.exports.default = widestLine$1;
var widestLineExports = widestLine$2.exports, cliBoxes$2 = { exports: {} }, single$1 = {
  topLeft: "\u250C",
  topRight: "\u2510",
  bottomRight: "\u2518",
  bottomLeft: "\u2514",
  vertical: "\u2502",
  horizontal: "\u2500"
}, double = {
  topLeft: "\u2554",
  topRight: "\u2557",
  bottomRight: "\u255D",
  bottomLeft: "\u255A",
  vertical: "\u2551",
  horizontal: "\u2550"
}, round = {
  topLeft: "\u256D",
  topRight: "\u256E",
  bottomRight: "\u256F",
  bottomLeft: "\u2570",
  vertical: "\u2502",
  horizontal: "\u2500"
}, bold = {
  topLeft: "\u250F",
  topRight: "\u2513",
  bottomRight: "\u251B",
  bottomLeft: "\u2517",
  vertical: "\u2503",
  horizontal: "\u2501"
}, singleDouble = {
  topLeft: "\u2553",
  topRight: "\u2556",
  bottomRight: "\u255C",
  bottomLeft: "\u2559",
  vertical: "\u2551",
  horizontal: "\u2500"
}, doubleSingle = {
  topLeft: "\u2552",
  topRight: "\u2555",
  bottomRight: "\u255B",
  bottomLeft: "\u2558",
  vertical: "\u2502",
  horizontal: "\u2550"
}, classic = {
  topLeft: "+",
  topRight: "+",
  bottomRight: "+",
  bottomLeft: "+",
  vertical: "|",
  horizontal: "-"
}, require$$0$2 = {
  single: single$1,
  double,
  round,
  bold,
  singleDouble,
  doubleSingle,
  classic
};
const cliBoxes$1 = require$$0$2;
cliBoxes$2.exports = cliBoxes$1;
cliBoxes$2.exports.default = cliBoxes$1;
var cliBoxesExports = cliBoxes$2.exports, camelcase = { exports: {} };
const preserveCamelCase = (string) => {
  let isLastCharLower = !1, isLastCharUpper = !1, isLastLastCharUpper = !1;
  for (let i2 = 0; i2 < string.length; i2++) {
    const character = string[i2];
    isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character ? (string = string.slice(0, i2) + "-" + string.slice(i2), isLastCharLower = !1, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !0, i2++) : isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character ? (string = string.slice(0, i2 - 1) + "-" + string.slice(i2 - 1), isLastLastCharUpper = isLastCharUpper, isLastCharUpper = !1, isLastCharLower = !0) : (isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character, isLastLastCharUpper = isLastCharUpper, isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character);
  }
  return string;
}, camelCase$1 = (input2, options2) => {
  if (!(typeof input2 == "string" || Array.isArray(input2)))
    throw new TypeError("Expected the input to be `string | string[]`");
  options2 = Object.assign({
    pascalCase: !1
  }, options2);
  const postProcess = (x) => options2.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
  return Array.isArray(input2) ? input2 = input2.map((x) => x.trim()).filter((x) => x.length).join("-") : input2 = input2.trim(), input2.length === 0 ? "" : input2.length === 1 ? options2.pascalCase ? input2.toUpperCase() : input2.toLowerCase() : (input2 !== input2.toLowerCase() && (input2 = preserveCamelCase(input2)), input2 = input2.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_2, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase()), postProcess(input2));
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
var camelcaseExports = camelcase.exports;
const stringWidth$2 = stringWidthExports;
function ansiAlign$1(text, opts) {
  if (!text) return text;
  opts = opts || {};
  const align = opts.align || "center";
  if (align === "left") return text;
  const split = opts.split || `
`, pad2 = opts.pad || " ", widthDiffFn = align !== "right" ? halfDiff : fullDiff;
  let returnString = !1;
  Array.isArray(text) || (returnString = !0, text = String(text).split(split));
  let width, maxWidth = 0;
  return text = text.map(function(str2) {
    return str2 = String(str2), width = stringWidth$2(str2), maxWidth = Math.max(width, maxWidth), {
      str: str2,
      width
    };
  }).map(function(obj) {
    return new Array(widthDiffFn(maxWidth, obj.width) + 1).join(pad2) + obj.str;
  }), returnString ? text.join(split) : text;
}
ansiAlign$1.left = function left(text) {
  return ansiAlign$1(text, { align: "left" });
};
ansiAlign$1.center = function center(text) {
  return ansiAlign$1(text, { align: "center" });
};
ansiAlign$1.right = function right(text) {
  return ansiAlign$1(text, { align: "right" });
};
var ansiAlign_1 = ansiAlign$1;
function halfDiff(maxWidth, curWidth) {
  return Math.floor((maxWidth - curWidth) / 2);
}
function fullDiff(maxWidth, curWidth) {
  return maxWidth - curWidth;
}
const { execFileSync } = require$$0__default$7.default, path = require$$0__default.default, exec = (command2, arguments_, shell) => execFileSync(command2, arguments_, { encoding: "utf8", shell }).trim(), create = (columns, rows) => ({
  columns: parseInt(columns, 10),
  rows: parseInt(rows, 10)
});
var termSize$1 = () => {
  const { env, stdout, stderr } = process;
  if (stdout && stdout.columns && stdout.rows)
    return create(stdout.columns, stdout.rows);
  if (stderr && stderr.columns && stderr.rows)
    return create(stderr.columns, stderr.rows);
  if (env.COLUMNS && env.LINES)
    return create(env.COLUMNS, env.LINES);
  if (process.platform === "win32")
    try {
      const size = exec(path.join(__dirname, "vendor/windows/term-size.exe")).split(/\r?\n/);
      if (size.length === 2)
        return create(size[0], size[1]);
    } catch {
    }
  else {
    if (process.platform === "darwin")
      try {
        const size = exec(path.join(__dirname, "vendor/macos/term-size"), [], !0).split(/\r?\n/);
        if (size.length === 2)
          return create(size[0], size[1]);
      } catch {
      }
    try {
      const size = exec("resize", ["-u"]).match(/\d+/g);
      if (size.length === 2)
        return create(size[0], size[1]);
    } catch {
    }
    if (process.env.TERM)
      try {
        const columns = exec("tput", ["cols"]), rows = exec("tput", ["lines"]);
        if (columns && rows)
          return create(columns, rows);
      } catch {
      }
  }
  return create(80, 24);
};
const stringWidth$1 = stringWidthExports, chalk$3 = chalk__default.default, widestLine = widestLineExports, cliBoxes = cliBoxesExports, camelCase = camelcaseExports, ansiAlign = ansiAlign_1, termSize = termSize$1, getObject = (detail) => {
  let object;
  return typeof detail == "number" ? object = {
    top: detail,
    right: detail * 3,
    bottom: detail,
    left: detail * 3
  } : object = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...detail
  }, object;
}, getBorderChars = (borderStyle) => {
  const sides = [
    "topLeft",
    "topRight",
    "bottomRight",
    "bottomLeft",
    "vertical",
    "horizontal"
  ];
  let chararacters;
  if (typeof borderStyle == "string") {
    if (chararacters = cliBoxes[borderStyle], !chararacters)
      throw new TypeError(`Invalid border style: ${borderStyle}`);
  } else {
    for (const side of sides)
      if (!borderStyle[side] || typeof borderStyle[side] != "string")
        throw new TypeError(`Invalid border style: ${side}`);
    chararacters = borderStyle;
  }
  return chararacters;
}, isHex = (color) => color.match(/^#[0-f]{3}(?:[0-f]{3})?$/i), isColorValid = (color) => typeof color == "string" && (chalk$3[color] || isHex(color)), getColorFn = (color) => isHex(color) ? chalk$3.hex(color) : chalk$3[color], getBGColorFn = (color) => isHex(color) ? chalk$3.bgHex(color) : chalk$3[camelCase(["bg", color])];
boxen$1.exports = (text, options2) => {
  if (options2 = {
    padding: 0,
    borderStyle: "single",
    dimBorder: !1,
    align: "left",
    float: "left",
    ...options2
  }, options2.borderColor && !isColorValid(options2.borderColor))
    throw new Error(`${options2.borderColor} is not a valid borderColor`);
  if (options2.backgroundColor && !isColorValid(options2.backgroundColor))
    throw new Error(`${options2.backgroundColor} is not a valid backgroundColor`);
  const chars = getBorderChars(options2.borderStyle), padding = getObject(options2.padding), margin = getObject(options2.margin), colorizeBorder = (border) => {
    const newBorder = options2.borderColor ? getColorFn(options2.borderColor)(border) : border;
    return options2.dimBorder ? chalk$3.dim(newBorder) : newBorder;
  }, colorizeContent = (content) => options2.backgroundColor ? getBGColorFn(options2.backgroundColor)(content) : content;
  text = ansiAlign(text, { align: options2.align });
  const NL = `
`, PAD = " ";
  let lines2 = text.split(NL);
  padding.top > 0 && (lines2 = new Array(padding.top).fill("").concat(lines2)), padding.bottom > 0 && (lines2 = lines2.concat(new Array(padding.bottom).fill("")));
  const contentWidth = widestLine(text) + padding.left + padding.right, paddingLeft = PAD.repeat(padding.left), { columns } = termSize();
  let marginLeft = PAD.repeat(margin.left);
  if (options2.float === "center") {
    const padWidth = Math.max((columns - contentWidth) / 2, 0);
    marginLeft = PAD.repeat(padWidth);
  } else if (options2.float === "right") {
    const padWidth = Math.max(columns - contentWidth - margin.right - 2, 0);
    marginLeft = PAD.repeat(padWidth);
  }
  const horizontal = chars.horizontal.repeat(contentWidth), top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + horizontal + chars.topRight), bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom)), side = colorizeBorder(chars.vertical), middle = lines2.map((line3) => {
    const paddingRight = PAD.repeat(contentWidth - stringWidth$1(line3) - padding.left);
    return marginLeft + side + colorizeContent(paddingLeft + line3 + paddingRight) + side;
  }).join(NL);
  return top + NL + middle + NL + bottom;
};
boxen$1.exports._borderStyles = cliBoxes;
var boxenExports = boxen$1.exports, boxen = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(boxenExports);
const rimraf = util__default.default.promisify(rimrafCb), unsupportedMessage = `
\`sanity upgrade\` is not supported as of sanity v3.
Use npm-check-updates or similar (https://www.npmjs.com/package/npm-check-updates)
`.trim(), upgradeDependencies = async function(args, context) {
  const { output, workDir, yarn, chalk: chalk2, sanityMajorVersion } = context;
  if (sanityMajorVersion >= 3)
    throw new Error(unsupportedMessage);
  const { extOptions, argsWithoutOptions } = args, modules = argsWithoutOptions.slice(), { range: range2, tag } = extOptions, saveExact = extOptions["save-exact"], targetRange = tag || range2;
  if (range2 && tag)
    throw new Error("Both --tag and --range specified, can only use one");
  if (range2 && !semver__default.default.validRange(range2))
    throw new Error(`Invalid semver range "${range2}"`);
  const versions = await findSanityModuleVersions(context, {
    target: targetRange,
    includeCli: !1
  }), allNeedsUpdate = versions.filter((mod) => mod.needsUpdate);
  loadEnv.debug("In need of update: %s", allNeedsUpdate.map((mod) => mod.name).join(", "));
  const needsUpdate = modules.length === 0 ? allNeedsUpdate : allNeedsUpdate.filter((outOfDate) => modules.indexOf(outOfDate.name) !== -1), semverBreakingUpgrades = versions.filter(hasSemverBreakingUpgrade), baseMajorUpgrade = semverBreakingUpgrades.find((mod) => mod.name === "@sanity/base"), majorUpgrades = semverBreakingUpgrades.filter((mod) => mod.name !== "@sanity/base");
  if (schedulePrintMajorUpgrades({ baseMajorUpgrade, majorUpgrades }, context), needsUpdate.length === 0) {
    const specified = modules.length === 0 ? "All" : "All *specified*";
    context.output.print(
      `${chalk2.green("\u2714")} ${specified} Sanity modules are at latest compatible versions`
    );
    return;
  }
  const pinned = needsUpdate.filter((mod) => mod.isPinned), nonPinned = needsUpdate.filter((mod) => !mod.isPinned), pinnedNames = pinned.map((mod) => mod.name).join(`
 - `);
  if (nonPinned.length === 0) {
    context.output.warn(
      `${chalk2.yellow(
        "\u26A0"
      )} All modules are pinned to specific versions, not upgrading:
 - ${pinnedNames}`
    );
    return;
  }
  pinned.length > 0 && context.output.warn(
    `${chalk2.yellow(
      "\u26A0"
    )} The follow modules are pinned to specific versions, not upgrading:
 - ${pinnedNames}`
  ), await maybeDeleteReactAce(nonPinned, workDir), await Promise.all(
    nonPinned.map(
      (mod) => deleteIfNotSymlink(
        path__default.default.join(context.workDir, "node_modules", mod.name.replace(/\//g, path__default.default.sep))
      )
    )
  );
  const versionPrefix = saveExact ? "" : "^", oldManifest = await readLocalManifest(workDir), newManifest = nonPinned.reduce((target, mod) => (oldManifest.dependencies && oldManifest.dependencies[mod.name] && (target.dependencies[mod.name] = mod.latestInRange === "unknown" ? oldManifest.dependencies[mod.name] : versionPrefix + mod.latestInRange), oldManifest.devDependencies && oldManifest.devDependencies[mod.name] && (target.devDependencies[mod.name] = mod.latestInRange === "unknown" ? oldManifest.devDependencies[mod.name] : versionPrefix + mod.latestInRange), target), oldManifest), manifestPath = path__default.default.join(context.workDir, "package.json");
  await writeJson(manifestPath, newManifest);
  const flags = extOptions.offline ? ["--offline"] : [], cmd = ["install"].concat(flags);
  loadEnv.debug("Running yarn %s", cmd.join(" ")), await yarn(cmd, { ...output, rootDir: workDir }), context.output.print(""), context.output.print(`${chalk2.green("\u2714")} Modules upgraded:`);
  const { versionLength, formatName } = getFormatters(nonPinned);
  nonPinned.forEach((mod) => {
    const current = chalk2.yellow(lodashExports.padStart(mod.installed || "<missing>", versionLength)), latest = chalk2.green(mod.latestInRange);
    context.output.print(`${formatName(mod.name)} ${current} \u2192 ${latest}`);
  });
};
function writeJson(filePath, data) {
  return fs$p.promises.writeFile(filePath, `${JSON.stringify(data, null, 2)}
`);
}
async function deleteIfNotSymlink(modPath) {
  const stats = await fs$p.promises.lstat(modPath).catch(lodashExports.noop);
  return !stats || stats.isSymbolicLink() ? null : rimraf(modPath);
}
function hasSemverBreakingUpgrade(mod) {
  const current = mod.installed || semver__default.default.minVersion(mod.declared)?.toString() || "";
  return !semver__default.default.satisfies(mod.latest, `^${current}`) && semver__default.default.gt(mod.latest, current);
}
function getMajorUpgradeText(mods2, chalk2) {
  return [
    `The following modules has new major versions
`,
    `released and will have to be manually upgraded:

`,
    ` - ${mods2.map((mod) => `${mod.name} (v${semver__default.default.major(mod.latest)})`).join(`
 - `)}

`,
    chalk2.yellow("\u26A0"),
    ` Note that major versions can contain backwards
`,
    "  incompatible changes and should be handled with care."
  ].join("");
}
function getMajorStudioUpgradeText(mod, chalk2) {
  const prev = semver__default.default.major(mod.installed || semver__default.default.minVersion(mod.declared)?.toString() || ""), next = semver__default.default.major(mod.latest);
  return [
    "There is now a new major version of Sanity Studio!",
    "",
    "Read more about the new version and how to upgrade:",
    chalk2.blueBright(`https://www.sanity.io/changelog/studio?from=v${prev}&to=v${next}`)
  ].join(`
`);
}
function schedulePrintMajorUpgrades({
  baseMajorUpgrade,
  majorUpgrades
}, { chalk: chalk2, output }) {
  majorUpgrades.length === 0 && !baseMajorUpgrade || process.on("beforeExit", () => {
    if (output.print(""), baseMajorUpgrade) {
      output.warn(
        boxen(getMajorStudioUpgradeText(baseMajorUpgrade, chalk2), {
          borderColor: "green",
          padding: 1
        })
      );
      return;
    }
    output.warn(
      boxen(getMajorUpgradeText(majorUpgrades, chalk2), {
        borderColor: "yellow",
        padding: 1
      })
    );
  });
}
async function maybeDeleteReactAce(toUpgrade, workDir) {
  const codeInputUpdate = toUpgrade.find((mod) => mod.name === "@sanity/code-input");
  if (!codeInputUpdate)
    return;
  const installed = codeInputUpdate.installed ? codeInputUpdate.installed : "2.4.0", upgradeTo = codeInputUpdate.latestInRange;
  if (!(semver__default.default.lte(installed, "2.24.0") && semver__default.default.gte(upgradeTo, "2.24.1")))
    return;
  const depRootPath = path__default.default.join(workDir, "node_modules"), closestReactAcePath = getModulePath("react-ace", path__default.default.join(depRootPath, "@sanity", "code-input")) || path__default.default.join(depRootPath, "react-ace");
  await rimraf(closestReactAcePath);
}
function getModulePath(modName, fromPath) {
  const manifestFile = `${modName.replace(/\//g, path__default.default.sep)}/package.json`, manifestPath = resolveFrom$1.silent(fromPath, manifestFile);
  return manifestPath ? path__default.default.dirname(manifestPath) : void 0;
}
async function readLocalManifest(dirName, fileName = "package.json") {
  try {
    const content = await fs$p.promises.readFile(path__default.default.join(dirName, fileName), "utf8");
    return JSON.parse(content);
  } catch (err) {
    if (err.code === "ENOENT")
      return {};
    throw new Error(`Error while attempting to read projects "${fileName}":
${err.message}`);
  }
}
const helpText = `
Upgrades installed Sanity modules to the latest available version within the
semantic versioning range specified in "package.json".

If a specific module name is provided, only that module will be upgraded.

Options
  --range [range] Version range to upgrade to, eg '^2.2.7' or '2.1.x'
  --tag [tag]     Tagged release to upgrade to, eg 'canary' or 'some-feature'
  --save-exact    Pin the resolved version numbers in package.json (no ^ prefix)

Examples
  # Upgrade modules to the latest semver compatible versions
  sanity upgrade

  # Update to the latest within the 2.2 range
  sanity upgrade --range 2.2.x

  # Update to the latest semver compatible versions and pin the versions
  sanity upgrade --save-exact

  # Update to the latest 'canary' npm tag
  sanity upgrade --tag canary
`, upgradeCommand = {
  name: "upgrade",
  signature: "[--tag DIST_TAG] [--range SEMVER_RANGE] [--save-exact]",
  description: "Upgrades all (or some) Sanity modules to their latest versions",
  action: upgradeDependencies,
  hideFromHelp: !0,
  helpText
}, help = `
Shows a list of installed Sanity modules and their respective versions, and
checks the npm registry for the latest available versions.`;
var versionsCommand = {
  name: "versions",
  signature: "",
  description: "Shows installed versions of Sanity Studio and components",
  helpText: help,
  action: printVersionResultCommand
};
const baseCommands = [
  initCommand,
  loginCommand,
  logoutCommand,
  installCommand,
  upgradeCommand,
  versionsCommand,
  docsCommand,
  manageCommand,
  debugCommand,
  command$1,
  projectGroup,
  listProjectsCommand,
  codemodCommand,
  telemetryGroup,
  disableTelemetryCommand,
  enableTelemetryCommand,
  telemetryStatusCommand,
  generateTypegenCommand,
  typegenGroup
];
var ora$1 = { exports: {} }, cliCursor$2 = {};
const onetime$1 = onetimeExports, signalExit = signalExitExports;
var restoreCursor$1 = onetime$1(() => {
  signalExit(() => {
    process.stderr.write("\x1B[?25h");
  }, { alwaysLast: !0 });
});
(function(exports2) {
  const restoreCursor2 = restoreCursor$1;
  let isHidden = !1;
  exports2.show = (writableStream = process.stderr) => {
    writableStream.isTTY && (isHidden = !1, writableStream.write("\x1B[?25h"));
  }, exports2.hide = (writableStream = process.stderr) => {
    writableStream.isTTY && (restoreCursor2(), isHidden = !0, writableStream.write("\x1B[?25l"));
  }, exports2.toggle = (force, writableStream) => {
    force !== void 0 && (isHidden = force), isHidden ? exports2.show(writableStream) : exports2.hide(writableStream);
  };
})(cliCursor$2);
var dots = {
  interval: 80,
  frames: [
    "\u280B",
    "\u2819",
    "\u2839",
    "\u2838",
    "\u283C",
    "\u2834",
    "\u2826",
    "\u2827",
    "\u2807",
    "\u280F"
  ]
}, dots2 = {
  interval: 80,
  frames: [
    "\u28FE",
    "\u28FD",
    "\u28FB",
    "\u28BF",
    "\u287F",
    "\u28DF",
    "\u28EF",
    "\u28F7"
  ]
}, dots3 = {
  interval: 80,
  frames: [
    "\u280B",
    "\u2819",
    "\u281A",
    "\u281E",
    "\u2816",
    "\u2826",
    "\u2834",
    "\u2832",
    "\u2833",
    "\u2813"
  ]
}, dots4 = {
  interval: 80,
  frames: [
    "\u2804",
    "\u2806",
    "\u2807",
    "\u280B",
    "\u2819",
    "\u2838",
    "\u2830",
    "\u2820",
    "\u2830",
    "\u2838",
    "\u2819",
    "\u280B",
    "\u2807",
    "\u2806"
  ]
}, dots5 = {
  interval: 80,
  frames: [
    "\u280B",
    "\u2819",
    "\u281A",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u2832",
    "\u2834",
    "\u2826",
    "\u2816",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2813",
    "\u280B"
  ]
}, dots6 = {
  interval: 80,
  frames: [
    "\u2801",
    "\u2809",
    "\u2819",
    "\u281A",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u2832",
    "\u2834",
    "\u2824",
    "\u2804",
    "\u2804",
    "\u2824",
    "\u2834",
    "\u2832",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u281A",
    "\u2819",
    "\u2809",
    "\u2801"
  ]
}, dots7 = {
  interval: 80,
  frames: [
    "\u2808",
    "\u2809",
    "\u280B",
    "\u2813",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2816",
    "\u2826",
    "\u2824",
    "\u2820",
    "\u2820",
    "\u2824",
    "\u2826",
    "\u2816",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2813",
    "\u280B",
    "\u2809",
    "\u2808"
  ]
}, dots8 = {
  interval: 80,
  frames: [
    "\u2801",
    "\u2801",
    "\u2809",
    "\u2819",
    "\u281A",
    "\u2812",
    "\u2802",
    "\u2802",
    "\u2812",
    "\u2832",
    "\u2834",
    "\u2824",
    "\u2804",
    "\u2804",
    "\u2824",
    "\u2820",
    "\u2820",
    "\u2824",
    "\u2826",
    "\u2816",
    "\u2812",
    "\u2810",
    "\u2810",
    "\u2812",
    "\u2813",
    "\u280B",
    "\u2809",
    "\u2808",
    "\u2808"
  ]
}, dots9 = {
  interval: 80,
  frames: [
    "\u28B9",
    "\u28BA",
    "\u28BC",
    "\u28F8",
    "\u28C7",
    "\u2867",
    "\u2857",
    "\u284F"
  ]
}, dots10 = {
  interval: 80,
  frames: [
    "\u2884",
    "\u2882",
    "\u2881",
    "\u2841",
    "\u2848",
    "\u2850",
    "\u2860"
  ]
}, dots11 = {
  interval: 100,
  frames: [
    "\u2801",
    "\u2802",
    "\u2804",
    "\u2840",
    "\u2880",
    "\u2820",
    "\u2810",
    "\u2808"
  ]
}, dots12 = {
  interval: 80,
  frames: [
    "\u2880\u2800",
    "\u2840\u2800",
    "\u2804\u2800",
    "\u2882\u2800",
    "\u2842\u2800",
    "\u2805\u2800",
    "\u2883\u2800",
    "\u2843\u2800",
    "\u280D\u2800",
    "\u288B\u2800",
    "\u284B\u2800",
    "\u280D\u2801",
    "\u288B\u2801",
    "\u284B\u2801",
    "\u280D\u2809",
    "\u280B\u2809",
    "\u280B\u2809",
    "\u2809\u2819",
    "\u2809\u2819",
    "\u2809\u2829",
    "\u2808\u2899",
    "\u2808\u2859",
    "\u2888\u2829",
    "\u2840\u2899",
    "\u2804\u2859",
    "\u2882\u2829",
    "\u2842\u2898",
    "\u2805\u2858",
    "\u2883\u2828",
    "\u2843\u2890",
    "\u280D\u2850",
    "\u288B\u2820",
    "\u284B\u2880",
    "\u280D\u2841",
    "\u288B\u2801",
    "\u284B\u2801",
    "\u280D\u2809",
    "\u280B\u2809",
    "\u280B\u2809",
    "\u2809\u2819",
    "\u2809\u2819",
    "\u2809\u2829",
    "\u2808\u2899",
    "\u2808\u2859",
    "\u2808\u2829",
    "\u2800\u2899",
    "\u2800\u2859",
    "\u2800\u2829",
    "\u2800\u2898",
    "\u2800\u2858",
    "\u2800\u2828",
    "\u2800\u2890",
    "\u2800\u2850",
    "\u2800\u2820",
    "\u2800\u2880",
    "\u2800\u2840"
  ]
}, dots13 = {
  interval: 80,
  frames: [
    "\u28FC",
    "\u28F9",
    "\u28BB",
    "\u283F",
    "\u285F",
    "\u28CF",
    "\u28E7",
    "\u28F6"
  ]
}, dots8Bit = {
  interval: 80,
  frames: [
    "\u2800",
    "\u2801",
    "\u2802",
    "\u2803",
    "\u2804",
    "\u2805",
    "\u2806",
    "\u2807",
    "\u2840",
    "\u2841",
    "\u2842",
    "\u2843",
    "\u2844",
    "\u2845",
    "\u2846",
    "\u2847",
    "\u2808",
    "\u2809",
    "\u280A",
    "\u280B",
    "\u280C",
    "\u280D",
    "\u280E",
    "\u280F",
    "\u2848",
    "\u2849",
    "\u284A",
    "\u284B",
    "\u284C",
    "\u284D",
    "\u284E",
    "\u284F",
    "\u2810",
    "\u2811",
    "\u2812",
    "\u2813",
    "\u2814",
    "\u2815",
    "\u2816",
    "\u2817",
    "\u2850",
    "\u2851",
    "\u2852",
    "\u2853",
    "\u2854",
    "\u2855",
    "\u2856",
    "\u2857",
    "\u2818",
    "\u2819",
    "\u281A",
    "\u281B",
    "\u281C",
    "\u281D",
    "\u281E",
    "\u281F",
    "\u2858",
    "\u2859",
    "\u285A",
    "\u285B",
    "\u285C",
    "\u285D",
    "\u285E",
    "\u285F",
    "\u2820",
    "\u2821",
    "\u2822",
    "\u2823",
    "\u2824",
    "\u2825",
    "\u2826",
    "\u2827",
    "\u2860",
    "\u2861",
    "\u2862",
    "\u2863",
    "\u2864",
    "\u2865",
    "\u2866",
    "\u2867",
    "\u2828",
    "\u2829",
    "\u282A",
    "\u282B",
    "\u282C",
    "\u282D",
    "\u282E",
    "\u282F",
    "\u2868",
    "\u2869",
    "\u286A",
    "\u286B",
    "\u286C",
    "\u286D",
    "\u286E",
    "\u286F",
    "\u2830",
    "\u2831",
    "\u2832",
    "\u2833",
    "\u2834",
    "\u2835",
    "\u2836",
    "\u2837",
    "\u2870",
    "\u2871",
    "\u2872",
    "\u2873",
    "\u2874",
    "\u2875",
    "\u2876",
    "\u2877",
    "\u2838",
    "\u2839",
    "\u283A",
    "\u283B",
    "\u283C",
    "\u283D",
    "\u283E",
    "\u283F",
    "\u2878",
    "\u2879",
    "\u287A",
    "\u287B",
    "\u287C",
    "\u287D",
    "\u287E",
    "\u287F",
    "\u2880",
    "\u2881",
    "\u2882",
    "\u2883",
    "\u2884",
    "\u2885",
    "\u2886",
    "\u2887",
    "\u28C0",
    "\u28C1",
    "\u28C2",
    "\u28C3",
    "\u28C4",
    "\u28C5",
    "\u28C6",
    "\u28C7",
    "\u2888",
    "\u2889",
    "\u288A",
    "\u288B",
    "\u288C",
    "\u288D",
    "\u288E",
    "\u288F",
    "\u28C8",
    "\u28C9",
    "\u28CA",
    "\u28CB",
    "\u28CC",
    "\u28CD",
    "\u28CE",
    "\u28CF",
    "\u2890",
    "\u2891",
    "\u2892",
    "\u2893",
    "\u2894",
    "\u2895",
    "\u2896",
    "\u2897",
    "\u28D0",
    "\u28D1",
    "\u28D2",
    "\u28D3",
    "\u28D4",
    "\u28D5",
    "\u28D6",
    "\u28D7",
    "\u2898",
    "\u2899",
    "\u289A",
    "\u289B",
    "\u289C",
    "\u289D",
    "\u289E",
    "\u289F",
    "\u28D8",
    "\u28D9",
    "\u28DA",
    "\u28DB",
    "\u28DC",
    "\u28DD",
    "\u28DE",
    "\u28DF",
    "\u28A0",
    "\u28A1",
    "\u28A2",
    "\u28A3",
    "\u28A4",
    "\u28A5",
    "\u28A6",
    "\u28A7",
    "\u28E0",
    "\u28E1",
    "\u28E2",
    "\u28E3",
    "\u28E4",
    "\u28E5",
    "\u28E6",
    "\u28E7",
    "\u28A8",
    "\u28A9",
    "\u28AA",
    "\u28AB",
    "\u28AC",
    "\u28AD",
    "\u28AE",
    "\u28AF",
    "\u28E8",
    "\u28E9",
    "\u28EA",
    "\u28EB",
    "\u28EC",
    "\u28ED",
    "\u28EE",
    "\u28EF",
    "\u28B0",
    "\u28B1",
    "\u28B2",
    "\u28B3",
    "\u28B4",
    "\u28B5",
    "\u28B6",
    "\u28B7",
    "\u28F0",
    "\u28F1",
    "\u28F2",
    "\u28F3",
    "\u28F4",
    "\u28F5",
    "\u28F6",
    "\u28F7",
    "\u28B8",
    "\u28B9",
    "\u28BA",
    "\u28BB",
    "\u28BC",
    "\u28BD",
    "\u28BE",
    "\u28BF",
    "\u28F8",
    "\u28F9",
    "\u28FA",
    "\u28FB",
    "\u28FC",
    "\u28FD",
    "\u28FE",
    "\u28FF"
  ]
}, sand = {
  interval: 80,
  frames: [
    "\u2801",
    "\u2802",
    "\u2804",
    "\u2840",
    "\u2848",
    "\u2850",
    "\u2860",
    "\u28C0",
    "\u28C1",
    "\u28C2",
    "\u28C4",
    "\u28CC",
    "\u28D4",
    "\u28E4",
    "\u28E5",
    "\u28E6",
    "\u28EE",
    "\u28F6",
    "\u28F7",
    "\u28FF",
    "\u287F",
    "\u283F",
    "\u289F",
    "\u281F",
    "\u285B",
    "\u281B",
    "\u282B",
    "\u288B",
    "\u280B",
    "\u280D",
    "\u2849",
    "\u2809",
    "\u2811",
    "\u2821",
    "\u2881"
  ]
}, line = {
  interval: 130,
  frames: [
    "-",
    "\\",
    "|",
    "/"
  ]
}, line2 = {
  interval: 100,
  frames: [
    "\u2802",
    "-",
    "\u2013",
    "\u2014",
    "\u2013",
    "-"
  ]
}, pipe$1 = {
  interval: 100,
  frames: [
    "\u2524",
    "\u2518",
    "\u2534",
    "\u2514",
    "\u251C",
    "\u250C",
    "\u252C",
    "\u2510"
  ]
}, simpleDots = {
  interval: 400,
  frames: [
    ".  ",
    ".. ",
    "...",
    "   "
  ]
}, simpleDotsScrolling = {
  interval: 200,
  frames: [
    ".  ",
    ".. ",
    "...",
    " ..",
    "  .",
    "   "
  ]
}, star = {
  interval: 70,
  frames: [
    "\u2736",
    "\u2738",
    "\u2739",
    "\u273A",
    "\u2739",
    "\u2737"
  ]
}, star2 = {
  interval: 80,
  frames: [
    "+",
    "x",
    "*"
  ]
}, flip = {
  interval: 70,
  frames: [
    "_",
    "_",
    "_",
    "-",
    "`",
    "`",
    "'",
    "\xB4",
    "-",
    "_",
    "_",
    "_"
  ]
}, hamburger = {
  interval: 100,
  frames: [
    "\u2631",
    "\u2632",
    "\u2634"
  ]
}, growVertical = {
  interval: 120,
  frames: [
    "\u2581",
    "\u2583",
    "\u2584",
    "\u2585",
    "\u2586",
    "\u2587",
    "\u2586",
    "\u2585",
    "\u2584",
    "\u2583"
  ]
}, growHorizontal = {
  interval: 120,
  frames: [
    "\u258F",
    "\u258E",
    "\u258D",
    "\u258C",
    "\u258B",
    "\u258A",
    "\u2589",
    "\u258A",
    "\u258B",
    "\u258C",
    "\u258D",
    "\u258E"
  ]
}, balloon = {
  interval: 140,
  frames: [
    " ",
    ".",
    "o",
    "O",
    "@",
    "*",
    " "
  ]
}, balloon2 = {
  interval: 120,
  frames: [
    ".",
    "o",
    "O",
    "\xB0",
    "O",
    "o",
    "."
  ]
}, noise = {
  interval: 100,
  frames: [
    "\u2593",
    "\u2592",
    "\u2591"
  ]
}, bounce = {
  interval: 120,
  frames: [
    "\u2801",
    "\u2802",
    "\u2804",
    "\u2802"
  ]
}, boxBounce = {
  interval: 120,
  frames: [
    "\u2596",
    "\u2598",
    "\u259D",
    "\u2597"
  ]
}, boxBounce2 = {
  interval: 100,
  frames: [
    "\u258C",
    "\u2580",
    "\u2590",
    "\u2584"
  ]
}, triangle = {
  interval: 50,
  frames: [
    "\u25E2",
    "\u25E3",
    "\u25E4",
    "\u25E5"
  ]
}, binary = {
  interval: 80,
  frames: [
    "010010",
    "001100",
    "100101",
    "111010",
    "111101",
    "010111",
    "101011",
    "111000",
    "110011",
    "110101"
  ]
}, arc = {
  interval: 100,
  frames: [
    "\u25DC",
    "\u25E0",
    "\u25DD",
    "\u25DE",
    "\u25E1",
    "\u25DF"
  ]
}, circle = {
  interval: 120,
  frames: [
    "\u25E1",
    "\u2299",
    "\u25E0"
  ]
}, squareCorners = {
  interval: 180,
  frames: [
    "\u25F0",
    "\u25F3",
    "\u25F2",
    "\u25F1"
  ]
}, circleQuarters = {
  interval: 120,
  frames: [
    "\u25F4",
    "\u25F7",
    "\u25F6",
    "\u25F5"
  ]
}, circleHalves = {
  interval: 50,
  frames: [
    "\u25D0",
    "\u25D3",
    "\u25D1",
    "\u25D2"
  ]
}, squish = {
  interval: 100,
  frames: [
    "\u256B",
    "\u256A"
  ]
}, toggle = {
  interval: 250,
  frames: [
    "\u22B6",
    "\u22B7"
  ]
}, toggle2 = {
  interval: 80,
  frames: [
    "\u25AB",
    "\u25AA"
  ]
}, toggle3 = {
  interval: 120,
  frames: [
    "\u25A1",
    "\u25A0"
  ]
}, toggle4 = {
  interval: 100,
  frames: [
    "\u25A0",
    "\u25A1",
    "\u25AA",
    "\u25AB"
  ]
}, toggle5 = {
  interval: 100,
  frames: [
    "\u25AE",
    "\u25AF"
  ]
}, toggle6 = {
  interval: 300,
  frames: [
    "\u101D",
    "\u1040"
  ]
}, toggle7 = {
  interval: 80,
  frames: [
    "\u29BE",
    "\u29BF"
  ]
}, toggle8 = {
  interval: 100,
  frames: [
    "\u25CD",
    "\u25CC"
  ]
}, toggle9 = {
  interval: 100,
  frames: [
    "\u25C9",
    "\u25CE"
  ]
}, toggle10 = {
  interval: 100,
  frames: [
    "\u3282",
    "\u3280",
    "\u3281"
  ]
}, toggle11 = {
  interval: 50,
  frames: [
    "\u29C7",
    "\u29C6"
  ]
}, toggle12 = {
  interval: 120,
  frames: [
    "\u2617",
    "\u2616"
  ]
}, toggle13 = {
  interval: 80,
  frames: [
    "=",
    "*",
    "-"
  ]
}, arrow = {
  interval: 100,
  frames: [
    "\u2190",
    "\u2196",
    "\u2191",
    "\u2197",
    "\u2192",
    "\u2198",
    "\u2193",
    "\u2199"
  ]
}, arrow2 = {
  interval: 80,
  frames: [
    "\u2B06\uFE0F ",
    "\u2197\uFE0F ",
    "\u27A1\uFE0F ",
    "\u2198\uFE0F ",
    "\u2B07\uFE0F ",
    "\u2199\uFE0F ",
    "\u2B05\uFE0F ",
    "\u2196\uFE0F "
  ]
}, arrow3 = {
  interval: 120,
  frames: [
    "\u25B9\u25B9\u25B9\u25B9\u25B9",
    "\u25B8\u25B9\u25B9\u25B9\u25B9",
    "\u25B9\u25B8\u25B9\u25B9\u25B9",
    "\u25B9\u25B9\u25B8\u25B9\u25B9",
    "\u25B9\u25B9\u25B9\u25B8\u25B9",
    "\u25B9\u25B9\u25B9\u25B9\u25B8"
  ]
}, bouncingBar = {
  interval: 80,
  frames: [
    "[    ]",
    "[=   ]",
    "[==  ]",
    "[=== ]",
    "[====]",
    "[ ===]",
    "[  ==]",
    "[   =]",
    "[    ]",
    "[   =]",
    "[  ==]",
    "[ ===]",
    "[====]",
    "[=== ]",
    "[==  ]",
    "[=   ]"
  ]
}, bouncingBall = {
  interval: 80,
  frames: [
    "( \u25CF    )",
    "(  \u25CF   )",
    "(   \u25CF  )",
    "(    \u25CF )",
    "(     \u25CF)",
    "(    \u25CF )",
    "(   \u25CF  )",
    "(  \u25CF   )",
    "( \u25CF    )",
    "(\u25CF     )"
  ]
}, smiley = {
  interval: 200,
  frames: [
    "\u{1F604} ",
    "\u{1F61D} "
  ]
}, monkey = {
  interval: 300,
  frames: [
    "\u{1F648} ",
    "\u{1F648} ",
    "\u{1F649} ",
    "\u{1F64A} "
  ]
}, hearts = {
  interval: 100,
  frames: [
    "\u{1F49B} ",
    "\u{1F499} ",
    "\u{1F49C} ",
    "\u{1F49A} ",
    "\u2764\uFE0F "
  ]
}, clock = {
  interval: 100,
  frames: [
    "\u{1F55B} ",
    "\u{1F550} ",
    "\u{1F551} ",
    "\u{1F552} ",
    "\u{1F553} ",
    "\u{1F554} ",
    "\u{1F555} ",
    "\u{1F556} ",
    "\u{1F557} ",
    "\u{1F558} ",
    "\u{1F559} ",
    "\u{1F55A} "
  ]
}, earth = {
  interval: 180,
  frames: [
    "\u{1F30D} ",
    "\u{1F30E} ",
    "\u{1F30F} "
  ]
}, material = {
  interval: 17,
  frames: [
    "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
    "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
    "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581"
  ]
}, moon = {
  interval: 80,
  frames: [
    "\u{1F311} ",
    "\u{1F312} ",
    "\u{1F313} ",
    "\u{1F314} ",
    "\u{1F315} ",
    "\u{1F316} ",
    "\u{1F317} ",
    "\u{1F318} "
  ]
}, runner = {
  interval: 140,
  frames: [
    "\u{1F6B6} ",
    "\u{1F3C3} "
  ]
}, pong = {
  interval: 80,
  frames: [
    "\u2590\u2802       \u258C",
    "\u2590\u2808       \u258C",
    "\u2590 \u2802      \u258C",
    "\u2590 \u2820      \u258C",
    "\u2590  \u2840     \u258C",
    "\u2590  \u2820     \u258C",
    "\u2590   \u2802    \u258C",
    "\u2590   \u2808    \u258C",
    "\u2590    \u2802   \u258C",
    "\u2590    \u2820   \u258C",
    "\u2590     \u2840  \u258C",
    "\u2590     \u2820  \u258C",
    "\u2590      \u2802 \u258C",
    "\u2590      \u2808 \u258C",
    "\u2590       \u2802\u258C",
    "\u2590       \u2820\u258C",
    "\u2590       \u2840\u258C",
    "\u2590      \u2820 \u258C",
    "\u2590      \u2802 \u258C",
    "\u2590     \u2808  \u258C",
    "\u2590     \u2802  \u258C",
    "\u2590    \u2820   \u258C",
    "\u2590    \u2840   \u258C",
    "\u2590   \u2820    \u258C",
    "\u2590   \u2802    \u258C",
    "\u2590  \u2808     \u258C",
    "\u2590  \u2802     \u258C",
    "\u2590 \u2820      \u258C",
    "\u2590 \u2840      \u258C",
    "\u2590\u2820       \u258C"
  ]
}, shark = {
  interval: 120,
  frames: [
    "\u2590|\\____________\u258C",
    "\u2590_|\\___________\u258C",
    "\u2590__|\\__________\u258C",
    "\u2590___|\\_________\u258C",
    "\u2590____|\\________\u258C",
    "\u2590_____|\\_______\u258C",
    "\u2590______|\\______\u258C",
    "\u2590_______|\\_____\u258C",
    "\u2590________|\\____\u258C",
    "\u2590_________|\\___\u258C",
    "\u2590__________|\\__\u258C",
    "\u2590___________|\\_\u258C",
    "\u2590____________|\\\u258C",
    "\u2590____________/|\u258C",
    "\u2590___________/|_\u258C",
    "\u2590__________/|__\u258C",
    "\u2590_________/|___\u258C",
    "\u2590________/|____\u258C",
    "\u2590_______/|_____\u258C",
    "\u2590______/|______\u258C",
    "\u2590_____/|_______\u258C",
    "\u2590____/|________\u258C",
    "\u2590___/|_________\u258C",
    "\u2590__/|__________\u258C",
    "\u2590_/|___________\u258C",
    "\u2590/|____________\u258C"
  ]
}, dqpb = {
  interval: 100,
  frames: [
    "d",
    "q",
    "p",
    "b"
  ]
}, weather = {
  interval: 100,
  frames: [
    "\u2600\uFE0F ",
    "\u2600\uFE0F ",
    "\u2600\uFE0F ",
    "\u{1F324} ",
    "\u26C5\uFE0F ",
    "\u{1F325} ",
    "\u2601\uFE0F ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u26C8 ",
    "\u{1F328} ",
    "\u{1F327} ",
    "\u{1F328} ",
    "\u2601\uFE0F ",
    "\u{1F325} ",
    "\u26C5\uFE0F ",
    "\u{1F324} ",
    "\u2600\uFE0F ",
    "\u2600\uFE0F "
  ]
}, christmas = {
  interval: 400,
  frames: [
    "\u{1F332}",
    "\u{1F384}"
  ]
}, grenade = {
  interval: 80,
  frames: [
    "\u060C  ",
    "\u2032  ",
    " \xB4 ",
    " \u203E ",
    "  \u2E0C",
    "  \u2E0A",
    "  |",
    "  \u204E",
    "  \u2055",
    " \u0DF4 ",
    "  \u2053",
    "   ",
    "   ",
    "   "
  ]
}, point = {
  interval: 125,
  frames: [
    "\u2219\u2219\u2219",
    "\u25CF\u2219\u2219",
    "\u2219\u25CF\u2219",
    "\u2219\u2219\u25CF",
    "\u2219\u2219\u2219"
  ]
}, layer = {
  interval: 150,
  frames: [
    "-",
    "=",
    "\u2261"
  ]
}, betaWave = {
  interval: 80,
  frames: [
    "\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2",
    "\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2",
    "\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2",
    "\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2",
    "\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2",
    "\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2",
    "\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1"
  ]
}, fingerDance = {
  interval: 160,
  frames: [
    "\u{1F918} ",
    "\u{1F91F} ",
    "\u{1F596} ",
    "\u270B ",
    "\u{1F91A} ",
    "\u{1F446} "
  ]
}, fistBump = {
  interval: 80,
  frames: [
    "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
    "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
    "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
    "\u3000\u{1F91C}\u3000\u3000\u{1F91B}\u3000 ",
    "\u3000\u3000\u{1F91C}\u{1F91B}\u3000\u3000 ",
    "\u3000\u{1F91C}\u2728\u{1F91B}\u3000\u3000 ",
    "\u{1F91C}\u3000\u2728\u3000\u{1F91B}\u3000 "
  ]
}, soccerHeader = {
  interval: 80,
  frames: [
    " \u{1F9D1}\u26BD\uFE0F       \u{1F9D1} ",
    "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ",
    "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
    "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
    "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
    "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
    "\u{1F9D1}       \u26BD\uFE0F\u{1F9D1}  ",
    "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
    "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
    "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
    "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
    "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} "
  ]
}, mindblown = {
  interval: 160,
  frames: [
    "\u{1F610} ",
    "\u{1F610} ",
    "\u{1F62E} ",
    "\u{1F62E} ",
    "\u{1F626} ",
    "\u{1F626} ",
    "\u{1F627} ",
    "\u{1F627} ",
    "\u{1F92F} ",
    "\u{1F4A5} ",
    "\u2728 ",
    "\u3000 ",
    "\u3000 ",
    "\u3000 "
  ]
}, speaker = {
  interval: 160,
  frames: [
    "\u{1F508} ",
    "\u{1F509} ",
    "\u{1F50A} ",
    "\u{1F509} "
  ]
}, orangePulse = {
  interval: 100,
  frames: [
    "\u{1F538} ",
    "\u{1F536} ",
    "\u{1F7E0} ",
    "\u{1F7E0} ",
    "\u{1F536} "
  ]
}, bluePulse = {
  interval: 100,
  frames: [
    "\u{1F539} ",
    "\u{1F537} ",
    "\u{1F535} ",
    "\u{1F535} ",
    "\u{1F537} "
  ]
}, orangeBluePulse = {
  interval: 100,
  frames: [
    "\u{1F538} ",
    "\u{1F536} ",
    "\u{1F7E0} ",
    "\u{1F7E0} ",
    "\u{1F536} ",
    "\u{1F539} ",
    "\u{1F537} ",
    "\u{1F535} ",
    "\u{1F535} ",
    "\u{1F537} "
  ]
}, timeTravel = {
  interval: 100,
  frames: [
    "\u{1F55B} ",
    "\u{1F55A} ",
    "\u{1F559} ",
    "\u{1F558} ",
    "\u{1F557} ",
    "\u{1F556} ",
    "\u{1F555} ",
    "\u{1F554} ",
    "\u{1F553} ",
    "\u{1F552} ",
    "\u{1F551} ",
    "\u{1F550} "
  ]
}, aesthetic = {
  interval: 80,
  frames: [
    "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1",
    "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0",
    "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1"
  ]
}, dwarfFortress = {
  interval: 80,
  frames: [
    " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "\u263A \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u263A \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u263A \u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
    "   \u263A \u2588\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
    "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
    "    \u263A \u2588\xA3\xA3\xA3  ",
    "     \u263A\u2588\xA3\xA3\xA3  ",
    "     \u263A\u2588\xA3\xA3\xA3  ",
    "     \u263A\u2593\xA3\xA3\xA3  ",
    "     \u263A\u2593\xA3\xA3\xA3  ",
    "     \u263A\u2592\xA3\xA3\xA3  ",
    "     \u263A\u2592\xA3\xA3\xA3  ",
    "     \u263A\u2591\xA3\xA3\xA3  ",
    "     \u263A\u2591\xA3\xA3\xA3  ",
    "     \u263A \xA3\xA3\xA3  ",
    "      \u263A\xA3\xA3\xA3  ",
    "      \u263A\xA3\xA3\xA3  ",
    "      \u263A\u2593\xA3\xA3  ",
    "      \u263A\u2593\xA3\xA3  ",
    "      \u263A\u2592\xA3\xA3  ",
    "      \u263A\u2592\xA3\xA3  ",
    "      \u263A\u2591\xA3\xA3  ",
    "      \u263A\u2591\xA3\xA3  ",
    "      \u263A \xA3\xA3  ",
    "       \u263A\xA3\xA3  ",
    "       \u263A\xA3\xA3  ",
    "       \u263A\u2593\xA3  ",
    "       \u263A\u2593\xA3  ",
    "       \u263A\u2592\xA3  ",
    "       \u263A\u2592\xA3  ",
    "       \u263A\u2591\xA3  ",
    "       \u263A\u2591\xA3  ",
    "       \u263A \xA3  ",
    "        \u263A\xA3  ",
    "        \u263A\xA3  ",
    "        \u263A\u2593  ",
    "        \u263A\u2593  ",
    "        \u263A\u2592  ",
    "        \u263A\u2592  ",
    "        \u263A\u2591  ",
    "        \u263A\u2591  ",
    "        \u263A   ",
    "        \u263A  &",
    "        \u263A \u263C&",
    "       \u263A \u263C &",
    "       \u263A\u263C  &",
    "      \u263A\u263C  & ",
    "      \u203C   & ",
    "     \u263A   &  ",
    "    \u203C    &  ",
    "   \u263A    &   ",
    "  \u203C     &   ",
    " \u263A     &    ",
    "\u203C      &    ",
    "      &     ",
    "      &     ",
    "     &   \u2591  ",
    "     &   \u2592  ",
    "    &    \u2593  ",
    "    &    \xA3  ",
    "   &    \u2591\xA3  ",
    "   &    \u2592\xA3  ",
    "  &     \u2593\xA3  ",
    "  &     \xA3\xA3  ",
    " &     \u2591\xA3\xA3  ",
    " &     \u2592\xA3\xA3  ",
    "&      \u2593\xA3\xA3  ",
    "&      \xA3\xA3\xA3  ",
    "      \u2591\xA3\xA3\xA3  ",
    "      \u2592\xA3\xA3\xA3  ",
    "      \u2593\xA3\xA3\xA3  ",
    "      \u2588\xA3\xA3\xA3  ",
    "     \u2591\u2588\xA3\xA3\xA3  ",
    "     \u2592\u2588\xA3\xA3\xA3  ",
    "     \u2593\u2588\xA3\xA3\xA3  ",
    "     \u2588\u2588\xA3\xA3\xA3  ",
    "    \u2591\u2588\u2588\xA3\xA3\xA3  ",
    "    \u2592\u2588\u2588\xA3\xA3\xA3  ",
    "    \u2593\u2588\u2588\xA3\xA3\xA3  ",
    "    \u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "   \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    "  \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
    " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  "
  ]
}, require$$0$1 = {
  dots,
  dots2,
  dots3,
  dots4,
  dots5,
  dots6,
  dots7,
  dots8,
  dots9,
  dots10,
  dots11,
  dots12,
  dots13,
  dots8Bit,
  sand,
  line,
  line2,
  pipe: pipe$1,
  simpleDots,
  simpleDotsScrolling,
  star,
  star2,
  flip,
  hamburger,
  growVertical,
  growHorizontal,
  balloon,
  balloon2,
  noise,
  bounce,
  boxBounce,
  boxBounce2,
  triangle,
  binary,
  arc,
  circle,
  squareCorners,
  circleQuarters,
  circleHalves,
  squish,
  toggle,
  toggle2,
  toggle3,
  toggle4,
  toggle5,
  toggle6,
  toggle7,
  toggle8,
  toggle9,
  toggle10,
  toggle11,
  toggle12,
  toggle13,
  arrow,
  arrow2,
  arrow3,
  bouncingBar,
  bouncingBall,
  smiley,
  monkey,
  hearts,
  clock,
  earth,
  material,
  moon,
  runner,
  pong,
  shark,
  dqpb,
  weather,
  christmas,
  grenade,
  point,
  layer,
  betaWave,
  fingerDance,
  fistBump,
  soccerHeader,
  mindblown,
  speaker,
  orangePulse,
  bluePulse,
  orangeBluePulse,
  timeTravel,
  aesthetic,
  dwarfFortress
};
const spinners = Object.assign({}, require$$0$1), spinnersList = Object.keys(spinners);
Object.defineProperty(spinners, "random", {
  get() {
    const randomIndex = Math.floor(Math.random() * spinnersList.length), spinnerName = spinnersList[randomIndex];
    return spinners[spinnerName];
  }
});
var cliSpinners$1 = spinners, isUnicodeSupported$2 = () => process.platform !== "win32" ? !0 : !!process.env.CI || !!process.env.WT_SESSION || // Windows Terminal
process.env.TERM_PROGRAM === "vscode" || process.env.TERM === "xterm-256color" || process.env.TERM === "alacritty";
const chalk$2 = chalk__default.default, isUnicodeSupported$1 = isUnicodeSupported$2, main$2 = {
  info: chalk$2.blue("\u2139"),
  success: chalk$2.green("\u2714"),
  warning: chalk$2.yellow("\u26A0"),
  error: chalk$2.red("\u2716")
}, fallback = {
  info: chalk$2.blue("i"),
  success: chalk$2.green("\u221A"),
  warning: chalk$2.yellow("\u203C"),
  error: chalk$2.red("\xD7")
};
var logSymbols$1 = isUnicodeSupported$1() ? main$2 : fallback, wcwidth$2 = { exports: {} }, clone$1 = { exports: {} };
(function(module2) {
  var clone2 = function() {
    function clone3(parent, circular, depth2, prototype) {
      typeof circular == "object" && (depth2 = circular.depth, prototype = circular.prototype, circular = circular.circular);
      var allParents = [], allChildren = [], useBuffer = typeof Buffer < "u";
      typeof circular > "u" && (circular = !0), typeof depth2 > "u" && (depth2 = 1 / 0);
      function _clone(parent2, depth3) {
        if (parent2 === null)
          return null;
        if (depth3 == 0)
          return parent2;
        var child, proto;
        if (typeof parent2 != "object")
          return parent2;
        if (clone3.__isArray(parent2))
          child = [];
        else if (clone3.__isRegExp(parent2))
          child = new RegExp(parent2.source, __getRegExpFlags(parent2)), parent2.lastIndex && (child.lastIndex = parent2.lastIndex);
        else if (clone3.__isDate(parent2))
          child = new Date(parent2.getTime());
        else {
          if (useBuffer && Buffer.isBuffer(parent2))
            return Buffer.allocUnsafe ? child = Buffer.allocUnsafe(parent2.length) : child = new Buffer(parent2.length), parent2.copy(child), child;
          typeof prototype > "u" ? (proto = Object.getPrototypeOf(parent2), child = Object.create(proto)) : (child = Object.create(prototype), proto = prototype);
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1)
            return allChildren[index];
          allParents.push(parent2), allChildren.push(child);
        }
        for (var i2 in parent2) {
          var attrs;
          proto && (attrs = Object.getOwnPropertyDescriptor(proto, i2)), !(attrs && attrs.set == null) && (child[i2] = _clone(parent2[i2], depth3 - 1));
        }
        return child;
      }
      return _clone(parent, depth2);
    }
    clone3.clonePrototype = function(parent) {
      if (parent === null)
        return null;
      var c2 = function() {
      };
      return c2.prototype = parent, new c2();
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone3.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o == "object" && __objToStr(o) === "[object Date]";
    }
    clone3.__isDate = __isDate;
    function __isArray(o) {
      return typeof o == "object" && __objToStr(o) === "[object Array]";
    }
    clone3.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o == "object" && __objToStr(o) === "[object RegExp]";
    }
    clone3.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = "";
      return re.global && (flags += "g"), re.ignoreCase && (flags += "i"), re.multiline && (flags += "m"), flags;
    }
    return clone3.__getRegExpFlags = __getRegExpFlags, clone3;
  }();
  module2.exports && (module2.exports = clone2);
})(clone$1);
var cloneExports = clone$1.exports, clone = cloneExports, defaults$1 = function(options2, defaults2) {
  return options2 = options2 || {}, Object.keys(defaults2).forEach(function(key2) {
    typeof options2[key2] > "u" && (options2[key2] = clone(defaults2[key2]));
  }), options2;
}, combining$1 = [
  [768, 879],
  [1155, 1158],
  [1160, 1161],
  [1425, 1469],
  [1471, 1471],
  [1473, 1474],
  [1476, 1477],
  [1479, 1479],
  [1536, 1539],
  [1552, 1557],
  [1611, 1630],
  [1648, 1648],
  [1750, 1764],
  [1767, 1768],
  [1770, 1773],
  [1807, 1807],
  [1809, 1809],
  [1840, 1866],
  [1958, 1968],
  [2027, 2035],
  [2305, 2306],
  [2364, 2364],
  [2369, 2376],
  [2381, 2381],
  [2385, 2388],
  [2402, 2403],
  [2433, 2433],
  [2492, 2492],
  [2497, 2500],
  [2509, 2509],
  [2530, 2531],
  [2561, 2562],
  [2620, 2620],
  [2625, 2626],
  [2631, 2632],
  [2635, 2637],
  [2672, 2673],
  [2689, 2690],
  [2748, 2748],
  [2753, 2757],
  [2759, 2760],
  [2765, 2765],
  [2786, 2787],
  [2817, 2817],
  [2876, 2876],
  [2879, 2879],
  [2881, 2883],
  [2893, 2893],
  [2902, 2902],
  [2946, 2946],
  [3008, 3008],
  [3021, 3021],
  [3134, 3136],
  [3142, 3144],
  [3146, 3149],
  [3157, 3158],
  [3260, 3260],
  [3263, 3263],
  [3270, 3270],
  [3276, 3277],
  [3298, 3299],
  [3393, 3395],
  [3405, 3405],
  [3530, 3530],
  [3538, 3540],
  [3542, 3542],
  [3633, 3633],
  [3636, 3642],
  [3655, 3662],
  [3761, 3761],
  [3764, 3769],
  [3771, 3772],
  [3784, 3789],
  [3864, 3865],
  [3893, 3893],
  [3895, 3895],
  [3897, 3897],
  [3953, 3966],
  [3968, 3972],
  [3974, 3975],
  [3984, 3991],
  [3993, 4028],
  [4038, 4038],
  [4141, 4144],
  [4146, 4146],
  [4150, 4151],
  [4153, 4153],
  [4184, 4185],
  [4448, 4607],
  [4959, 4959],
  [5906, 5908],
  [5938, 5940],
  [5970, 5971],
  [6002, 6003],
  [6068, 6069],
  [6071, 6077],
  [6086, 6086],
  [6089, 6099],
  [6109, 6109],
  [6155, 6157],
  [6313, 6313],
  [6432, 6434],
  [6439, 6440],
  [6450, 6450],
  [6457, 6459],
  [6679, 6680],
  [6912, 6915],
  [6964, 6964],
  [6966, 6970],
  [6972, 6972],
  [6978, 6978],
  [7019, 7027],
  [7616, 7626],
  [7678, 7679],
  [8203, 8207],
  [8234, 8238],
  [8288, 8291],
  [8298, 8303],
  [8400, 8431],
  [12330, 12335],
  [12441, 12442],
  [43014, 43014],
  [43019, 43019],
  [43045, 43046],
  [64286, 64286],
  [65024, 65039],
  [65056, 65059],
  [65279, 65279],
  [65529, 65531],
  [68097, 68099],
  [68101, 68102],
  [68108, 68111],
  [68152, 68154],
  [68159, 68159],
  [119143, 119145],
  [119155, 119170],
  [119173, 119179],
  [119210, 119213],
  [119362, 119364],
  [917505, 917505],
  [917536, 917631],
  [917760, 917999]
], defaults = defaults$1, combining = combining$1, DEFAULTS = {
  nul: 0,
  control: 0
};
wcwidth$2.exports = function wcwidth2(str2) {
  return wcswidth(str2, DEFAULTS);
};
wcwidth$2.exports.config = function(opts) {
  return opts = defaults(opts || {}, DEFAULTS), function(str2) {
    return wcswidth(str2, opts);
  };
};
function wcswidth(str2, opts) {
  if (typeof str2 != "string") return wcwidth$1(str2, opts);
  for (var s = 0, i2 = 0; i2 < str2.length; i2++) {
    var n = wcwidth$1(str2.charCodeAt(i2), opts);
    if (n < 0) return -1;
    s += n;
  }
  return s;
}
function wcwidth$1(ucs, opts) {
  return ucs === 0 ? opts.nul : ucs < 32 || ucs >= 127 && ucs < 160 ? opts.control : bisearch(ucs) ? 0 : 1 + (ucs >= 4352 && (ucs <= 4447 || // Hangul Jamo init. consonants
  ucs == 9001 || ucs == 9002 || ucs >= 11904 && ucs <= 42191 && ucs != 12351 || // CJK ... Yi
  ucs >= 44032 && ucs <= 55203 || // Hangul Syllables
  ucs >= 63744 && ucs <= 64255 || // CJK Compatibility Ideographs
  ucs >= 65040 && ucs <= 65049 || // Vertical forms
  ucs >= 65072 && ucs <= 65135 || // CJK Compatibility Forms
  ucs >= 65280 && ucs <= 65376 || // Fullwidth Forms
  ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
}
function bisearch(ucs) {
  var min2 = 0, max2 = combining.length - 1, mid;
  if (ucs < combining[0][0] || ucs > combining[max2][1]) return !1;
  for (; max2 >= min2; )
    if (mid = Math.floor((min2 + max2) / 2), ucs > combining[mid][1]) min2 = mid + 1;
    else if (ucs < combining[mid][0]) max2 = mid - 1;
    else return !0;
  return !1;
}
var wcwidthExports = wcwidth$2.exports, isInteractive$1 = ({ stream: stream2 = process.stdout } = {}) => !!(stream2 && stream2.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env)), bl = { exports: {} }, readable = { exports: {} }, stream, hasRequiredStream;
function requireStream() {
  return hasRequiredStream || (hasRequiredStream = 1, stream = require$$0__default$4.default), stream;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2] != null ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source2), !0).forEach(function(key2) {
        _defineProperty(target, key2, source2[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    return key2 = _toPropertyKey(key2), key2 in obj ? Object.defineProperty(obj, key2, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key2] = value, obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor))
      throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor2 = props[i2];
      descriptor2.enumerable = descriptor2.enumerable || !1, descriptor2.configurable = !0, "value" in descriptor2 && (descriptor2.writable = !0), Object.defineProperty(target, _toPropertyKey(descriptor2.key), descriptor2);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    return protoProps && _defineProperties(Constructor.prototype, protoProps), Object.defineProperty(Constructor, "prototype", { writable: !1 }), Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 == "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input2, hint) {
    if (typeof input2 != "object" || input2 === null) return input2;
    var prim = input2[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input2, hint || "default");
      if (typeof res != "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input2);
  }
  var _require2 = require$$0__default$9.default, Buffer2 = _require2.Buffer, _require22 = require$$0__default$5.default, inspect = _require22.inspect, custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2), this.head = null, this.tail = null, this.length = 0;
    }
    return _createClass(BufferList2, [{
      key: "push",
      value: function(v) {
        var entry = {
          data: v,
          next: null
        };
        this.length > 0 ? this.tail.next = entry : this.head = entry, this.tail = entry, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(v) {
        var entry = {
          data: v,
          next: this.head
        };
        this.length === 0 && (this.tail = entry), this.head = entry, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ret = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ret;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(s) {
        if (this.length === 0) return "";
        for (var p = this.head, ret = "" + p.data; p = p.next; ) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        for (var ret = Buffer2.allocUnsafe(n >>> 0), p = this.head, i2 = 0; p; )
          copyBuffer(p.data, ret, i2), i2 += p.data.length, p = p.next;
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(n, hasStrings) {
        var ret;
        return n < this.head.data.length ? (ret = this.head.data.slice(0, n), this.head.data = this.head.data.slice(n)) : n === this.head.data.length ? ret = this.shift() : ret = hasStrings ? this._getString(n) : this._getBuffer(n), ret;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(n) {
        var p = this.head, c2 = 1, ret = p.data;
        for (n -= ret.length; p = p.next; ) {
          var str2 = p.data, nb = n > str2.length ? str2.length : n;
          if (nb === str2.length ? ret += str2 : ret += str2.slice(0, n), n -= nb, n === 0) {
            nb === str2.length ? (++c2, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, p.data = str2.slice(nb));
            break;
          }
          ++c2;
        }
        return this.length -= c2, ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(n) {
        var ret = Buffer2.allocUnsafe(n), p = this.head, c2 = 1;
        for (p.data.copy(ret), n -= p.data.length; p = p.next; ) {
          var buf = p.data, nb = n > buf.length ? buf.length : n;
          if (buf.copy(ret, ret.length - n, 0, nb), n -= nb, n === 0) {
            nb === buf.length ? (++c2, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, p.data = buf.slice(nb));
            break;
          }
          ++c2;
        }
        return this.length -= c2, ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function(_2, options2) {
        return inspect(this, _objectSpread(_objectSpread({}, options2), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), BufferList2;
  }(), buffer_list;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this, readableDestroyed = this._readableState && this._readableState.destroyed, writableDestroyed = this._writableState && this._writableState.destroyed;
    return readableDestroyed || writableDestroyed ? (cb ? cb(err) : err && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(emitErrorNT, this, err)) : process.nextTick(emitErrorNT, this, err)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(err || null, function(err2) {
      !cb && err2 ? _this._writableState ? _this._writableState.errorEmitted ? process.nextTick(emitCloseNT, _this) : (_this._writableState.errorEmitted = !0, process.nextTick(emitErrorAndCloseNT, _this, err2)) : process.nextTick(emitErrorAndCloseNT, _this, err2) : cb ? (process.nextTick(emitCloseNT, _this), cb(err2)) : process.nextTick(emitCloseNT, _this);
    }), this);
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err), emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    self2._writableState && !self2._writableState.emitClose || self2._readableState && !self2._readableState.emitClose || self2.emit("close");
  }
  function undestroy() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream2, err) {
    var rState = stream2._readableState, wState = stream2._writableState;
    rState && rState.autoDestroy || wState && wState.autoDestroy ? stream2.destroy(err) : stream2.emit("error", err);
  }
  return destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  }, destroy_1;
}
var errors = {}, hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  const codes = {};
  function createErrorType(code, message, Base2) {
    Base2 || (Base2 = Error);
    function getMessage(arg1, arg2, arg3) {
      return typeof message == "string" ? message : message(arg1, arg2, arg3);
    }
    class NodeError extends Base2 {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base2.name, NodeError.prototype.code = code, codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      return expected = expected.map((i2) => String(i2)), len > 2 ? `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1] : len === 2 ? `one of ${thing} ${expected[0]} or ${expected[1]}` : `of ${thing} ${expected[0]}`;
    } else
      return `of ${thing} ${String(expected)}`;
  }
  function startsWith(str2, search, pos2) {
    return str2.substr(0, search.length) === search;
  }
  function endsWith(str2, search, this_len) {
    return (this_len === void 0 || this_len > str2.length) && (this_len = str2.length), str2.substring(this_len - search.length, this_len) === search;
  }
  function includes(str2, search, start) {
    return typeof start != "number" && (start = 0), start + search.length > str2.length ? !1 : str2.indexOf(search, start) !== -1;
  }
  return createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError), createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    typeof expected == "string" && startsWith(expected, "not ") ? (determiner = "must not be", expected = expected.replace(/^not /, "")) : determiner = "must be";
    let msg;
    if (endsWith(name, " argument"))
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    else {
      const type2 = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    return msg += `. Received type ${typeof actual}`, msg;
  }, TypeError), createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  }), createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  }), createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end"), createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError), createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errors.codes = codes, errors;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options2, isDuplex, duplexKey) {
    return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
  }
  function getHighWaterMark(state2, options2, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark
  }, state;
}
var node, hasRequiredNode;
function requireNode() {
  return hasRequiredNode || (hasRequiredNode = 1, node = require$$0__default$5.default.deprecate), node;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null, this.entry = null, this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireNode()
  }, Stream2 = requireStream(), Buffer2 = require$$0__default$9.default.Buffer, OurUint8Array = (typeof loadEnv.commonjsGlobal < "u" ? loadEnv.commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy(), _require2 = requireState(), getHighWaterMark = _require2.getHighWaterMark, _require$codes = requireErrors().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING, errorOrDestroy = destroyImpl.errorOrDestroy;
  inheritsExports(Writable, Stream2);
  function nop() {
  }
  function WritableState(options2, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex(), options2 = options2 || {}, typeof isDuplex != "boolean" && (isDuplex = stream2 instanceof Duplex), this.objectMode = !!options2.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options2.writableObjectMode), this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var noDecode = options2.decodeStrings === !1;
    this.decodeStrings = !noDecode, this.defaultEncoding = options2.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
      onwrite(stream2, er);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = options2.emitClose !== !1, this.autoDestroy = !!options2.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function() {
    for (var current = this.bufferedRequest, out = []; current; )
      out.push(current), current = current.next;
    return out;
  }, function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var realHasInstance;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (realHasInstance = Function.prototype[Symbol.hasInstance], Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
      return realHasInstance.call(this, object) ? !0 : this !== Writable ? !1 : object && object._writableState instanceof WritableState;
    }
  })) : realHasInstance = function(object) {
    return object instanceof this;
  };
  function Writable(options2) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options2);
    this._writableState = new WritableState(options2, this, isDuplex), this.writable = !0, options2 && (typeof options2.write == "function" && (this._write = options2.write), typeof options2.writev == "function" && (this._writev = options2.writev), typeof options2.destroy == "function" && (this._destroy = options2.destroy), typeof options2.final == "function" && (this._final = options2.final)), Stream2.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream2, er), process.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var er;
    return chunk === null ? er = new ERR_STREAM_NULL_VALUES() : typeof chunk != "string" && !state2.objectMode && (er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk)), er ? (errorOrDestroy(stream2, er), process.nextTick(cb, er), !1) : !0;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState, ret = !1, isBuf = !state2.objectMode && _isUint8Array(chunk);
    return isBuf && !Buffer2.isBuffer(chunk) && (chunk = _uint8ArrayToBuffer(chunk)), typeof encoding == "function" && (cb = encoding, encoding = null), isBuf ? encoding = "buffer" : encoding || (encoding = state2.defaultEncoding), typeof cb != "function" && (cb = nop), state2.ending ? writeAfterEnd(this, cb) : (isBuf || validChunk(this, state2, chunk, cb)) && (state2.pendingcb++, ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb)), ret;
  }, Writable.prototype.cork = function() {
    this._writableState.corked++;
  }, Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    state2.corked && (state2.corked--, !state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest && clearBuffer(this, state2));
  }, Writable.prototype.setDefaultEncoding = function(encoding) {
    if (typeof encoding == "string" && (encoding = encoding.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    return this._writableState.defaultEncoding = encoding, this;
  }, Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    return !state2.objectMode && state2.decodeStrings !== !1 && typeof chunk == "string" && (chunk = Buffer2.from(chunk, encoding)), chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      chunk !== newChunk && (isBuf = !0, encoding = "buffer", chunk = newChunk);
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (ret || (state2.needDrain = !0), state2.writing || state2.corked) {
      var last2 = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      }, last2 ? last2.next = state2.lastBufferedRequest : state2.bufferedRequest = state2.lastBufferedRequest, state2.bufferedRequestCount += 1;
    } else
      doWrite(stream2, state2, !1, len, chunk, encoding, cb);
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len, state2.writecb = cb, state2.writing = !0, state2.sync = !0, state2.destroyed ? state2.onwrite(new ERR_STREAM_DESTROYED("write")) : writev ? stream2._writev(chunk, state2.onwrite) : stream2._write(chunk, encoding, state2.onwrite), state2.sync = !1;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb, sync2 ? (process.nextTick(cb, er), process.nextTick(finishMaybe, stream2, state2), stream2._writableState.errorEmitted = !0, errorOrDestroy(stream2, er)) : (cb(er), stream2._writableState.errorEmitted = !0, errorOrDestroy(stream2, er), finishMaybe(stream2, state2));
  }
  function onwriteStateUpdate(state2) {
    state2.writing = !1, state2.writecb = null, state2.length -= state2.writelen, state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState, sync2 = state2.sync, cb = state2.writecb;
    if (typeof cb != "function") throw new ERR_MULTIPLE_CALLBACK();
    if (onwriteStateUpdate(state2), er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      !finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest && clearBuffer(stream2, state2), sync2 ? process.nextTick(afterWrite, stream2, state2, finished, cb) : afterWrite(stream2, state2, finished, cb);
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    finished || onwriteDrain(stream2, state2), state2.pendingcb--, cb(), finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    state2.length === 0 && state2.needDrain && (state2.needDrain = !1, stream2.emit("drain"));
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = !0;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount, buffer2 = new Array(l), holder = state2.corkedRequestsFree;
      holder.entry = entry;
      for (var count2 = 0, allBuffers = !0; entry; )
        buffer2[count2] = entry, entry.isBuf || (allBuffers = !1), entry = entry.next, count2 += 1;
      buffer2.allBuffers = allBuffers, doWrite(stream2, state2, !0, state2.length, buffer2, "", holder.finish), state2.pendingcb++, state2.lastBufferedRequest = null, holder.next ? (state2.corkedRequestsFree = holder.next, holder.next = null) : state2.corkedRequestsFree = new CorkedRequest(state2), state2.bufferedRequestCount = 0;
    } else {
      for (; entry; ) {
        var chunk = entry.chunk, encoding = entry.encoding, cb = entry.callback, len = state2.objectMode ? 1 : chunk.length;
        if (doWrite(stream2, state2, !1, len, chunk, encoding, cb), entry = entry.next, state2.bufferedRequestCount--, state2.writing)
          break;
      }
      entry === null && (state2.lastBufferedRequest = null);
    }
    state2.bufferedRequest = entry, state2.bufferProcessing = !1;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  }, Writable.prototype._writev = null, Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    return typeof chunk == "function" ? (cb = chunk, chunk = null, encoding = null) : typeof encoding == "function" && (cb = encoding, encoding = null), chunk != null && this.write(chunk, encoding), state2.corked && (state2.corked = 1, this.uncork()), state2.ending || endWritable(this, state2, cb), this;
  }, Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--, err && errorOrDestroy(stream2, err), state2.prefinished = !0, stream2.emit("prefinish"), finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    !state2.prefinished && !state2.finalCalled && (typeof stream2._final == "function" && !state2.destroyed ? (state2.pendingcb++, state2.finalCalled = !0, process.nextTick(callFinal, stream2, state2)) : (state2.prefinished = !0, stream2.emit("prefinish")));
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need && (prefinish(stream2, state2), state2.pendingcb === 0 && (state2.finished = !0, stream2.emit("finish"), state2.autoDestroy))) {
      var rState = stream2._readableState;
      (!rState || rState.autoDestroy && rState.endEmitted) && stream2.destroy();
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = !0, finishMaybe(stream2, state2), cb && (state2.finished ? process.nextTick(cb) : stream2.once("finish", cb)), state2.ended = !0, stream2.writable = !1;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    for (corkReq.entry = null; entry; ) {
      var cb = entry.callback;
      state2.pendingcb--, cb(err), entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  return Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(value) {
      this._writableState && (this._writableState.destroyed = value);
    }
  }), Writable.prototype.destroy = destroyImpl.destroy, Writable.prototype._undestroy = destroyImpl.undestroy, Writable.prototype._destroy = function(err, cb) {
    cb(err);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key2 in obj) keys2.push(key2);
    return keys2;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable(), Writable = require_stream_writable();
  inheritsExports(Duplex, Readable);
  for (var keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++) {
    var method = keys[v];
    Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
  }
  function Duplex(options2) {
    if (!(this instanceof Duplex)) return new Duplex(options2);
    Readable.call(this, options2), Writable.call(this, options2), this.allowHalfOpen = !0, options2 && (options2.readable === !1 && (this.readable = !1), options2.writable === !1 && (this.writable = !1), options2.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", onend)));
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function onend() {
    this._writableState.ended || process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  return Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = value, this._writableState.destroyed = value);
    }
  }), _stream_duplex;
}
var string_decoder = {}, safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(module2, exports2) {
    var buffer2 = require$$0__default$9.default, Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2)
        dst[key2] = src2[key2];
    }
    Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow ? module2.exports = buffer2 : (copyProps(buffer2, exports2), exports2.Buffer = SafeBuffer);
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype), copyProps(Buffer2, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg == "number")
        throw new TypeError("Argument must not be a number");
      return Buffer2(arg, encodingOrOffset, length);
    }, SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size != "number")
        throw new TypeError("Argument must be a number");
      var buf = Buffer2(size);
      return fill2 !== void 0 ? typeof encoding == "string" ? buf.fill(fill2, encoding) : buf.fill(fill2) : buf.fill(0), buf;
    }, SafeBuffer.allocUnsafe = function(size) {
      if (typeof size != "number")
        throw new TypeError("Argument must be a number");
      return Buffer2(size);
    }, SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size != "number")
        throw new TypeError("Argument must be a number");
      return buffer2.SlowBuffer(size);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer, isEncoding = Buffer2.isEncoding || function(encoding) {
    switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    for (var retried; ; )
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase(), retried = !0;
      }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc != "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text, this.end = utf16End, nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast, nb = 4;
        break;
      case "base64":
        this.text = base64Text, this.end = base64End, nb = 3;
        break;
      default:
        this.write = simpleWrite, this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r, i2;
    if (this.lastNeed) {
      if (r = this.fillLast(buf), r === void 0) return "";
      i2 = this.lastNeed, this.lastNeed = 0;
    } else
      i2 = 0;
    return i2 < buf.length ? r ? r + this.text(buf, i2) : this.text(buf, i2) : r || "";
  }, StringDecoder.prototype.end = utf8End, StringDecoder.prototype.text = utf8Text, StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length)
      return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    return byte <= 127 ? 0 : byte >> 5 === 6 ? 2 : byte >> 4 === 14 ? 3 : byte >> 3 === 30 ? 4 : byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i2) {
    var j = buf.length - 1;
    if (j < i2) return 0;
    var nb = utf8CheckByte(buf[j]);
    return nb >= 0 ? (nb > 0 && (self2.lastNeed = nb - 1), nb) : --j < i2 || nb === -2 ? 0 : (nb = utf8CheckByte(buf[j]), nb >= 0 ? (nb > 0 && (self2.lastNeed = nb - 2), nb) : --j < i2 || nb === -2 ? 0 : (nb = utf8CheckByte(buf[j]), nb >= 0 ? (nb > 0 && (nb === 2 ? nb = 0 : self2.lastNeed = nb - 3), nb) : 0));
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128)
      return self2.lastNeed = 0, "\uFFFD";
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128)
        return self2.lastNeed = 1, "\uFFFD";
      if (self2.lastNeed > 2 && buf.length > 2 && (buf[2] & 192) !== 128)
        return self2.lastNeed = 2, "\uFFFD";
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length)
      return buf.copy(this.lastChar, p, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    buf.copy(this.lastChar, p, 0, buf.length), this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i2) {
    var total = utf8CheckIncomplete(this, buf, i2);
    if (!this.lastNeed) return buf.toString("utf8", i2);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    return buf.copy(this.lastChar, 0, end2), buf.toString("utf8", i2, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    return this.lastNeed ? r + "\uFFFD" : r;
  }
  function utf16Text(buf, i2) {
    if ((buf.length - i2) % 2 === 0) {
      var r = buf.toString("utf16le", i2);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
      }
      return r;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i2, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i2) {
    var n = (buf.length - i2) % 3;
    return n === 0 ? buf.toString("base64", i2) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = buf[buf.length - 1] : (this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1]), buf.toString("base64", i2, buf.length - n));
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    return this.lastNeed ? r + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once2(callback) {
    var called = !1;
    return function() {
      if (!called) {
        called = !0;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        callback.apply(this, args);
      }
    };
  }
  function noop2() {
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort == "function";
  }
  function eos2(stream2, opts, callback) {
    if (typeof opts == "function") return eos2(stream2, null, opts);
    opts || (opts = {}), callback = once2(callback || noop2);
    var readable2 = opts.readable || opts.readable !== !1 && stream2.readable, writable = opts.writable || opts.writable !== !1 && stream2.writable, onlegacyfinish = function() {
      stream2.writable || onfinish();
    }, writableEnded = stream2._writableState && stream2._writableState.finished, onfinish = function() {
      writable = !1, writableEnded = !0, readable2 || callback.call(stream2);
    }, readableEnded = stream2._readableState && stream2._readableState.endEmitted, onend = function() {
      readable2 = !1, readableEnded = !0, writable || callback.call(stream2);
    }, onerror = function(err) {
      callback.call(stream2, err);
    }, onclose = function() {
      var err;
      if (readable2 && !readableEnded)
        return (!stream2._readableState || !stream2._readableState.ended) && (err = new ERR_STREAM_PREMATURE_CLOSE()), callback.call(stream2, err);
      if (writable && !writableEnded)
        return (!stream2._writableState || !stream2._writableState.ended) && (err = new ERR_STREAM_PREMATURE_CLOSE()), callback.call(stream2, err);
    }, onrequest = function() {
      stream2.req.on("finish", onfinish);
    };
    return isRequest2(stream2) ? (stream2.on("complete", onfinish), stream2.on("abort", onclose), stream2.req ? onrequest() : stream2.on("request", onrequest)) : writable && !stream2._writableState && (stream2.on("end", onlegacyfinish), stream2.on("close", onlegacyfinish)), stream2.on("end", onend), stream2.on("finish", onfinish), opts.error !== !1 && stream2.on("error", onerror), stream2.on("close", onclose), function() {
      stream2.removeListener("complete", onfinish), stream2.removeListener("abort", onclose), stream2.removeListener("request", onrequest), stream2.req && stream2.req.removeListener("finish", onfinish), stream2.removeListener("end", onlegacyfinish), stream2.removeListener("close", onlegacyfinish), stream2.removeListener("finish", onfinish), stream2.removeListener("end", onend), stream2.removeListener("error", onerror), stream2.removeListener("close", onclose);
    };
  }
  return endOfStream = eos2, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key2, value) {
    return key2 = _toPropertyKey(key2), key2 in obj ? Object.defineProperty(obj, key2, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key2] = value, obj;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 == "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input2, hint) {
    if (typeof input2 != "object" || input2 === null) return input2;
    var prim = input2[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input2, hint || "default");
      if (typeof res != "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input2);
  }
  var finished = requireEndOfStream(), kLastResolve = Symbol("lastResolve"), kLastReject = Symbol("lastReject"), kError = Symbol("error"), kEnded = Symbol("ended"), kLastPromise = Symbol("lastPromise"), kHandlePromise = Symbol("handlePromise"), kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data = iter[kStream].read();
      data !== null && (iter[kLastPromise] = null, iter[kLastResolve] = null, iter[kLastReject] = null, resolve2(createIterResult(data, !1)));
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve2, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(void 0, !0));
          return;
        }
        iter[kHandlePromise](resolve2, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  }), ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function() {
      var _this = this, error2 = this[kError];
      if (error2 !== null)
        return Promise.reject(error2);
      if (this[kEnded])
        return Promise.resolve(createIterResult(void 0, !0));
      if (this[kStream].destroyed)
        return new Promise(function(resolve2, reject) {
          process.nextTick(function() {
            _this[kError] ? reject(_this[kError]) : resolve2(createIterResult(void 0, !0));
          });
        });
      var lastPromise = this[kLastPromise], promise2;
      if (lastPromise)
        promise2 = new Promise(wrapForNext(lastPromise, this));
      else {
        var data = this[kStream].read();
        if (data !== null)
          return Promise.resolve(createIterResult(data, !1));
        promise2 = new Promise(this[kHandlePromise]);
      }
      return this[kLastPromise] = promise2, promise2;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function() {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(createIterResult(void 0, !0));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype), createReadableStreamAsyncIterator = function(stream2) {
    var _Object$create, iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: !0
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: !0
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: !0
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: !0
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: !0
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function(resolve2, reject) {
        var data = iterator2[kStream].read();
        data ? (iterator2[kLastPromise] = null, iterator2[kLastResolve] = null, iterator2[kLastReject] = null, resolve2(createIterResult(data, !1))) : (iterator2[kLastResolve] = resolve2, iterator2[kLastReject] = reject);
      },
      writable: !0
    }), _Object$create));
    return iterator2[kLastPromise] = null, finished(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator2[kLastReject];
        reject !== null && (iterator2[kLastPromise] = null, iterator2[kLastResolve] = null, iterator2[kLastReject] = null, reject(err)), iterator2[kError] = err;
        return;
      }
      var resolve2 = iterator2[kLastResolve];
      resolve2 !== null && (iterator2[kLastPromise] = null, iterator2[kLastResolve] = null, iterator2[kLastReject] = null, resolve2(createIterResult(void 0, !0))), iterator2[kEnded] = !0;
    }), stream2.on("readable", onReadable.bind(null, iterator2)), iterator2;
  };
  return async_iterator = createReadableStreamAsyncIterator, async_iterator;
}
var from_1, hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from_1;
  hasRequiredFrom = 1;
  function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key2, arg) {
    try {
      var info = gen[key2](arg), value = info.value;
    } catch (error2) {
      reject(error2);
      return;
    }
    info.done ? resolve2(value) : Promise.resolve(value).then(_next, _throw);
  }
  function _asyncToGenerator(fn2) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve2, reject) {
        var gen = fn2.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2] != null ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source2), !0).forEach(function(key2) {
        _defineProperty(target, key2, source2[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    return key2 = _toPropertyKey(key2), key2 in obj ? Object.defineProperty(obj, key2, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key2] = value, obj;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 == "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input2, hint) {
    if (typeof input2 != "object" || input2 === null) return input2;
    var prim = input2[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input2, hint || "default");
      if (typeof res != "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input2);
  }
  var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
  function from2(Readable, iterable, opts) {
    var iterator2;
    if (iterable && typeof iterable.next == "function")
      iterator2 = iterable;
    else if (iterable && iterable[Symbol.asyncIterator]) iterator2 = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator2 = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable2 = new Readable(_objectSpread({
      objectMode: !0
    }, opts)), reading = !1;
    readable2._read = function() {
      reading || (reading = !0, next());
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      return _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator2.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          done ? readable2.push(null) : readable2.push(yield value) ? next() : reading = !1;
        } catch (err) {
          readable2.destroy(err);
        }
      }), _next2.apply(this, arguments);
    }
    return readable2;
  }
  return from_1 = from2, from_1;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EElistenerCount = function(emitter2, type2) {
    return emitter2.listeners(type2).length;
  }, Stream2 = requireStream(), Buffer2 = require$$0__default$9.default.Buffer, OurUint8Array = (typeof loadEnv.commonjsGlobal < "u" ? loadEnv.commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$0__default$5.default, debug2;
  debugUtil && debugUtil.debuglog ? debug2 = debugUtil.debuglog("stream") : debug2 = function() {
  };
  var BufferList2 = requireBuffer_list(), destroyImpl = requireDestroy(), _require2 = requireState(), getHighWaterMark = _require2.getHighWaterMark, _require$codes = requireErrors().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, StringDecoder, createReadableStreamAsyncIterator, from2;
  inheritsExports(Readable, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy, kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter2, event, fn2) {
    if (typeof emitter2.prependListener == "function") return emitter2.prependListener(event, fn2);
    !emitter2._events || !emitter2._events[event] ? emitter2.on(event, fn2) : Array.isArray(emitter2._events[event]) ? emitter2._events[event].unshift(fn2) : emitter2._events[event] = [fn2, emitter2._events[event]];
  }
  function ReadableState(options2, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex(), options2 = options2 || {}, typeof isDuplex != "boolean" && (isDuplex = stream2 instanceof Duplex), this.objectMode = !!options2.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options2.readableObjectMode), this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex), this.buffer = new BufferList2(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = options2.emitClose !== !1, this.autoDestroy = !!options2.autoDestroy, this.destroyed = !1, this.defaultEncoding = options2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, options2.encoding && (StringDecoder || (StringDecoder = requireString_decoder().StringDecoder), this.decoder = new StringDecoder(options2.encoding), this.encoding = options2.encoding);
  }
  function Readable(options2) {
    if (Duplex = Duplex || require_stream_duplex(), !(this instanceof Readable)) return new Readable(options2);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options2, this, isDuplex), this.readable = !0, options2 && (typeof options2.read == "function" && (this._read = options2.read), typeof options2.destroy == "function" && (this._destroy = options2.destroy)), Stream2.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(value) {
      this._readableState && (this._readableState.destroyed = value);
    }
  }), Readable.prototype.destroy = destroyImpl.destroy, Readable.prototype._undestroy = destroyImpl.undestroy, Readable.prototype._destroy = function(err, cb) {
    cb(err);
  }, Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState, skipChunkCheck;
    return state2.objectMode ? skipChunkCheck = !0 : typeof chunk == "string" && (encoding = encoding || state2.defaultEncoding, encoding !== state2.encoding && (chunk = Buffer2.from(chunk, encoding), encoding = ""), skipChunkCheck = !0), readableAddChunk(this, chunk, encoding, !1, skipChunkCheck);
  }, Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, !0, !1);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null)
      state2.reading = !1, onEofChunk(stream2, state2);
    else {
      var er;
      if (skipChunkCheck || (er = chunkInvalid(state2, chunk)), er)
        errorOrDestroy(stream2, er);
      else if (state2.objectMode || chunk && chunk.length > 0)
        if (typeof chunk != "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype && (chunk = _uint8ArrayToBuffer(chunk)), addToFront)
          state2.endEmitted ? errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT()) : addChunk(stream2, state2, chunk, !0);
        else if (state2.ended)
          errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        else {
          if (state2.destroyed)
            return !1;
          state2.reading = !1, state2.decoder && !encoding ? (chunk = state2.decoder.write(chunk), state2.objectMode || chunk.length !== 0 ? addChunk(stream2, state2, chunk, !1) : maybeReadMore(stream2, state2)) : addChunk(stream2, state2, chunk, !1);
        }
      else addToFront || (state2.reading = !1, maybeReadMore(stream2, state2));
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    state2.flowing && state2.length === 0 && !state2.sync ? (state2.awaitDrain = 0, stream2.emit("data", chunk)) : (state2.length += state2.objectMode ? 1 : chunk.length, addToFront ? state2.buffer.unshift(chunk) : state2.buffer.push(chunk), state2.needReadable && emitReadable(stream2)), maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    return !_isUint8Array(chunk) && typeof chunk != "string" && chunk !== void 0 && !state2.objectMode && (er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk)), er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Readable.prototype.setEncoding = function(enc) {
    StringDecoder || (StringDecoder = requireString_decoder().StringDecoder);
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var p = this._readableState.buffer.head, content = ""; p !== null; )
      content += decoder.write(p.data), p = p.next;
    return this._readableState.buffer.clear(), content !== "" && this._readableState.buffer.push(content), this._readableState.length = content.length, this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    return n >= MAX_HWM ? n = MAX_HWM : (n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++), n;
  }
  function howMuchToRead(n, state2) {
    return n <= 0 || state2.length === 0 && state2.ended ? 0 : state2.objectMode ? 1 : n !== n ? state2.flowing && state2.length ? state2.buffer.head.data.length : state2.length : (n > state2.highWaterMark && (state2.highWaterMark = computeNewHighWaterMark(n)), n <= state2.length ? n : state2.ended ? state2.length : (state2.needReadable = !0, 0));
  }
  Readable.prototype.read = function(n) {
    debug2("read", n), n = parseInt(n, 10);
    var state2 = this._readableState, nOrig = n;
    if (n !== 0 && (state2.emittedReadable = !1), n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended))
      return debug2("read: emitReadable", state2.length, state2.ended), state2.length === 0 && state2.ended ? endReadable(this) : emitReadable(this), null;
    if (n = howMuchToRead(n, state2), n === 0 && state2.ended)
      return state2.length === 0 && endReadable(this), null;
    var doRead = state2.needReadable;
    debug2("need readable", doRead), (state2.length === 0 || state2.length - n < state2.highWaterMark) && (doRead = !0, debug2("length less than watermark", doRead)), state2.ended || state2.reading ? (doRead = !1, debug2("reading or ended", doRead)) : doRead && (debug2("do read"), state2.reading = !0, state2.sync = !0, state2.length === 0 && (state2.needReadable = !0), this._read(state2.highWaterMark), state2.sync = !1, state2.reading || (n = howMuchToRead(nOrig, state2)));
    var ret;
    return n > 0 ? ret = fromList(n, state2) : ret = null, ret === null ? (state2.needReadable = state2.length <= state2.highWaterMark, n = 0) : (state2.length -= n, state2.awaitDrain = 0), state2.length === 0 && (state2.ended || (state2.needReadable = !0), nOrig !== n && state2.ended && endReadable(this)), ret !== null && this.emit("data", ret), ret;
  };
  function onEofChunk(stream2, state2) {
    if (debug2("onEofChunk"), !state2.ended) {
      if (state2.decoder) {
        var chunk = state2.decoder.end();
        chunk && chunk.length && (state2.buffer.push(chunk), state2.length += state2.objectMode ? 1 : chunk.length);
      }
      state2.ended = !0, state2.sync ? emitReadable(stream2) : (state2.needReadable = !1, state2.emittedReadable || (state2.emittedReadable = !0, emitReadable_(stream2)));
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable), state2.needReadable = !1, state2.emittedReadable || (debug2("emitReadable", state2.flowing), state2.emittedReadable = !0, process.nextTick(emitReadable_, stream2));
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended), !state2.destroyed && (state2.length || state2.ended) && (stream2.emit("readable"), state2.emittedReadable = !1), state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark, flow2(stream2);
  }
  function maybeReadMore(stream2, state2) {
    state2.readingMore || (state2.readingMore = !0, process.nextTick(maybeReadMore_, stream2, state2));
  }
  function maybeReadMore_(stream2, state2) {
    for (; !state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0); ) {
      var len = state2.length;
      if (debug2("maybeReadMore read 0"), stream2.read(0), len === state2.length)
        break;
    }
    state2.readingMore = !1;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  }, Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this, state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1, debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== !1) && dest !== process.stdout && dest !== process.stderr, endFn = doEnd ? onend : unpipe;
    state2.endEmitted ? process.nextTick(endFn) : src2.once("end", endFn), dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe"), readable2 === src2 && unpipeInfo && unpipeInfo.hasUnpiped === !1 && (unpipeInfo.hasUnpiped = !0, cleanup());
    }
    function onend() {
      debug2("onend"), dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = !1;
    function cleanup() {
      debug2("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src2.removeListener("end", onend), src2.removeListener("end", unpipe), src2.removeListener("data", ondata), cleanedUp = !0, state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain) && ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret), ret === !1 && ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp && (debug2("false write response, pause", state2.awaitDrain), state2.awaitDrain++), src2.pause());
    }
    function onerror(er) {
      debug2("onerror", er), unpipe(), dest.removeListener("error", onerror), EElistenerCount(dest, "error") === 0 && errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish), unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish"), dest.removeListener("close", onclose), unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe"), src2.unpipe(dest);
    }
    return dest.emit("pipe", src2), state2.flowing || (debug2("pipe resume"), src2.resume()), dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain), state2.awaitDrain && state2.awaitDrain--, state2.awaitDrain === 0 && EElistenerCount(src2, "data") && (state2.flowing = !0, flow2(src2));
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState, unpipeInfo = {
      hasUnpiped: !1
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1)
      return dest && dest !== state2.pipes ? this : (dest || (dest = state2.pipes), state2.pipes = null, state2.pipesCount = 0, state2.flowing = !1, dest && dest.emit("unpipe", this, unpipeInfo), this);
    if (!dest) {
      var dests = state2.pipes, len = state2.pipesCount;
      state2.pipes = null, state2.pipesCount = 0, state2.flowing = !1;
      for (var i2 = 0; i2 < len; i2++) dests[i2].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    return index === -1 ? this : (state2.pipes.splice(index, 1), state2.pipesCount -= 1, state2.pipesCount === 1 && (state2.pipes = state2.pipes[0]), dest.emit("unpipe", this, unpipeInfo), this);
  }, Readable.prototype.on = function(ev, fn2) {
    var res = Stream2.prototype.on.call(this, ev, fn2), state2 = this._readableState;
    return ev === "data" ? (state2.readableListening = this.listenerCount("readable") > 0, state2.flowing !== !1 && this.resume()) : ev === "readable" && !state2.endEmitted && !state2.readableListening && (state2.readableListening = state2.needReadable = !0, state2.flowing = !1, state2.emittedReadable = !1, debug2("on readable", state2.length, state2.reading), state2.length ? emitReadable(this) : state2.reading || process.nextTick(nReadingNextTick, this)), res;
  }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.removeListener = function(ev, fn2) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn2);
    return ev === "readable" && process.nextTick(updateReadableListening, this), res;
  }, Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    return (ev === "readable" || ev === void 0) && process.nextTick(updateReadableListening, this), res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0, state2.resumeScheduled && !state2.paused ? state2.flowing = !0 : self2.listenerCount("data") > 0 && self2.resume();
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0"), self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    return state2.flowing || (debug2("resume"), state2.flowing = !state2.readableListening, resume(this, state2)), state2.paused = !1, this;
  };
  function resume(stream2, state2) {
    state2.resumeScheduled || (state2.resumeScheduled = !0, process.nextTick(resume_, stream2, state2));
  }
  function resume_(stream2, state2) {
    debug2("resume", state2.reading), state2.reading || stream2.read(0), state2.resumeScheduled = !1, stream2.emit("resume"), flow2(stream2), state2.flowing && !state2.reading && stream2.read(0);
  }
  Readable.prototype.pause = function() {
    return debug2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (debug2("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function flow2(stream2) {
    var state2 = stream2._readableState;
    for (debug2("flow", state2.flowing); state2.flowing && stream2.read() !== null; ) ;
  }
  Readable.prototype.wrap = function(stream2) {
    var _this = this, state2 = this._readableState, paused = !1;
    stream2.on("end", function() {
      if (debug2("wrapped end"), state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        chunk && chunk.length && _this.push(chunk);
      }
      _this.push(null);
    }), stream2.on("data", function(chunk) {
      if (debug2("wrapped data"), state2.decoder && (chunk = state2.decoder.write(chunk)), !(state2.objectMode && chunk == null) && !(!state2.objectMode && (!chunk || !chunk.length))) {
        var ret = _this.push(chunk);
        ret || (paused = !0, stream2.pause());
      }
    });
    for (var i2 in stream2)
      this[i2] === void 0 && typeof stream2[i2] == "function" && (this[i2] = /* @__PURE__ */ function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i2));
    for (var n = 0; n < kProxyEvents.length; n++)
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    return this._read = function(n2) {
      debug2("wrapped _read", n2), paused && (paused = !1, stream2.resume());
    }, this;
  }, typeof Symbol == "function" && (Readable.prototype[Symbol.asyncIterator] = function() {
    return createReadableStreamAsyncIterator === void 0 && (createReadableStreamAsyncIterator = requireAsync_iterator()), createReadableStreamAsyncIterator(this);
  }), Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(state2) {
      this._readableState && (this._readableState.flowing = state2);
    }
  }), Readable._fromList = fromList, Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    return state2.objectMode ? ret = state2.buffer.shift() : !n || n >= state2.length ? (state2.decoder ? ret = state2.buffer.join("") : state2.buffer.length === 1 ? ret = state2.buffer.first() : ret = state2.buffer.concat(state2.length), state2.buffer.clear()) : ret = state2.buffer.consume(n, state2.decoder), ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("endReadable", state2.endEmitted), state2.endEmitted || (state2.ended = !0, process.nextTick(endReadableNT, state2, stream2));
  }
  function endReadableNT(state2, stream2) {
    if (debug2("endReadableNT", state2.endEmitted, state2.length), !state2.endEmitted && state2.length === 0 && (state2.endEmitted = !0, stream2.readable = !1, stream2.emit("end"), state2.autoDestroy)) {
      var wState = stream2._writableState;
      (!wState || wState.autoDestroy && wState.finished) && stream2.destroy();
    }
  }
  typeof Symbol == "function" && (Readable.from = function(iterable, opts) {
    return from2 === void 0 && (from2 = requireFrom()), from2(Readable, iterable, opts);
  });
  function indexOf(xs, x) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++)
      if (xs[i2] === x) return i2;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = Transform;
  var _require$codes = requireErrors().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
  inheritsExports(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = !1;
    var cb = ts.writecb;
    if (cb === null)
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null, ts.writecb = null, data != null && this.push(data), cb(er);
    var rs = this._readableState;
    rs.reading = !1, (rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
  }
  function Transform(options2) {
    if (!(this instanceof Transform)) return new Transform(options2);
    Duplex.call(this, options2), this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, options2 && (typeof options2.transform == "function" && (this._transform = options2.transform), typeof options2.flush == "function" && (this._flush = options2.flush)), this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(er, data) {
      done(_this, er, data);
    }) : done(this, null, null);
  }
  Transform.prototype.push = function(chunk, encoding) {
    return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
  }, Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  }, Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
      var rs = this._readableState;
      (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
    }
  }, Transform.prototype._read = function(n) {
    var ts = this._transformState;
    ts.writechunk !== null && !ts.transforming ? (ts.transforming = !0, this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)) : ts.needTransform = !0;
  }, Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null && stream2.push(data), stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream2.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = PassThrough2;
  var Transform = require_stream_transform();
  inheritsExports(PassThrough2, Transform);
  function PassThrough2(options2) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options2);
    Transform.call(this, options2);
  }
  return PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  }, _stream_passthrough;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos2;
  function once2(callback) {
    var called = !1;
    return function() {
      called || (called = !0, callback.apply(void 0, arguments));
    };
  }
  var _require$codes = requireErrors().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort == "function";
  }
  function destroyer2(stream2, reading, writing, callback) {
    callback = once2(callback);
    var closed = !1;
    stream2.on("close", function() {
      closed = !0;
    }), eos2 === void 0 && (eos2 = requireEndOfStream()), eos2(stream2, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = !0, callback();
    });
    var destroyed = !1;
    return function(err) {
      if (!closed && !destroyed) {
        if (destroyed = !0, isRequest2(stream2)) return stream2.abort();
        if (typeof stream2.destroy == "function") return stream2.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      }
    };
  }
  function call2(fn2) {
    fn2();
  }
  function pipe2(from2, to) {
    return from2.pipe(to);
  }
  function popCallback(streams2) {
    return !streams2.length || typeof streams2[streams2.length - 1] != "function" ? noop2 : streams2.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams2 = new Array(_len), _key = 0; _key < _len; _key++)
      streams2[_key] = arguments[_key];
    var callback = popCallback(streams2);
    if (Array.isArray(streams2[0]) && (streams2 = streams2[0]), streams2.length < 2)
      throw new ERR_MISSING_ARGS("streams");
    var error2, destroys = streams2.map(function(stream2, i2) {
      var reading = i2 < streams2.length - 1, writing = i2 > 0;
      return destroyer2(stream2, reading, writing, function(err) {
        error2 || (error2 = err), err && destroys.forEach(call2), !reading && (destroys.forEach(call2), callback(error2));
      });
    });
    return streams2.reduce(pipe2);
  }
  return pipeline_1 = pipeline, pipeline_1;
}
(function(module2, exports2) {
  var Stream2 = require$$0__default$4.default;
  process.env.READABLE_STREAM === "disable" && Stream2 ? (module2.exports = Stream2.Readable, Object.assign(module2.exports, Stream2), module2.exports.Stream = Stream2) : (exports2 = module2.exports = require_stream_readable(), exports2.Stream = Stream2 || exports2, exports2.Readable = exports2, exports2.Writable = require_stream_writable(), exports2.Duplex = require_stream_duplex(), exports2.Transform = require_stream_transform(), exports2.PassThrough = require_stream_passthrough(), exports2.finished = requireEndOfStream(), exports2.pipeline = requirePipeline());
})(readable, readable.exports);
var readableExports = readable.exports;
const { Buffer: Buffer$1 } = require$$0__default$9.default, symbol = Symbol.for("BufferList");
function BufferList$1(buf) {
  if (!(this instanceof BufferList$1))
    return new BufferList$1(buf);
  BufferList$1._init.call(this, buf);
}
BufferList$1._init = function _init(buf) {
  Object.defineProperty(this, symbol, { value: !0 }), this._bufs = [], this.length = 0, buf && this.append(buf);
};
BufferList$1.prototype._new = function _new(buf) {
  return new BufferList$1(buf);
};
BufferList$1.prototype._offset = function _offset(offset) {
  if (offset === 0)
    return [0, 0];
  let tot = 0;
  for (let i2 = 0; i2 < this._bufs.length; i2++) {
    const _t = tot + this._bufs[i2].length;
    if (offset < _t || i2 === this._bufs.length - 1)
      return [i2, offset - tot];
    tot = _t;
  }
};
BufferList$1.prototype._reverseOffset = function(blOffset) {
  const bufferId = blOffset[0];
  let offset = blOffset[1];
  for (let i2 = 0; i2 < bufferId; i2++)
    offset += this._bufs[i2].length;
  return offset;
};
BufferList$1.prototype.get = function get(index) {
  if (index > this.length || index < 0)
    return;
  const offset = this._offset(index);
  return this._bufs[offset[0]][offset[1]];
};
BufferList$1.prototype.slice = function slice(start, end2) {
  return typeof start == "number" && start < 0 && (start += this.length), typeof end2 == "number" && end2 < 0 && (end2 += this.length), this.copy(null, 0, start, end2);
};
BufferList$1.prototype.copy = function copy2(dst, dstStart, srcStart, srcEnd) {
  if ((typeof srcStart != "number" || srcStart < 0) && (srcStart = 0), (typeof srcEnd != "number" || srcEnd > this.length) && (srcEnd = this.length), srcStart >= this.length || srcEnd <= 0)
    return dst || Buffer$1.alloc(0);
  const copy3 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart;
  let bytes = len, bufoff = copy3 && dstStart || 0, start = off[1];
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy3)
      return this._bufs.length === 1 ? this._bufs[0] : Buffer$1.concat(this._bufs, this.length);
    for (let i2 = 0; i2 < this._bufs.length; i2++)
      this._bufs[i2].copy(dst, bufoff), bufoff += this._bufs[i2].length;
    return dst;
  }
  if (bytes <= this._bufs[off[0]].length - start)
    return copy3 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
  copy3 || (dst = Buffer$1.allocUnsafe(len));
  for (let i2 = off[0]; i2 < this._bufs.length; i2++) {
    const l = this._bufs[i2].length - start;
    if (bytes > l)
      this._bufs[i2].copy(dst, bufoff, start), bufoff += l;
    else {
      this._bufs[i2].copy(dst, bufoff, start, start + bytes), bufoff += l;
      break;
    }
    bytes -= l, start && (start = 0);
  }
  return dst.length > bufoff ? dst.slice(0, bufoff) : dst;
};
BufferList$1.prototype.shallowSlice = function shallowSlice(start, end2) {
  if (start = start || 0, end2 = typeof end2 != "number" ? this.length : end2, start < 0 && (start += this.length), end2 < 0 && (end2 += this.length), start === end2)
    return this._new();
  const startOffset = this._offset(start), endOffset = this._offset(end2), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
  return endOffset[1] === 0 ? buffers.pop() : buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]), startOffset[1] !== 0 && (buffers[0] = buffers[0].slice(startOffset[1])), this._new(buffers);
};
BufferList$1.prototype.toString = function toString7(encoding, start, end2) {
  return this.slice(start, end2).toString(encoding);
};
BufferList$1.prototype.consume = function consume(bytes) {
  if (bytes = Math.trunc(bytes), Number.isNaN(bytes) || bytes <= 0) return this;
  for (; this._bufs.length; )
    if (bytes >= this._bufs[0].length)
      bytes -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
    else {
      this._bufs[0] = this._bufs[0].slice(bytes), this.length -= bytes;
      break;
    }
  return this;
};
BufferList$1.prototype.duplicate = function duplicate() {
  const copy3 = this._new();
  for (let i2 = 0; i2 < this._bufs.length; i2++)
    copy3.append(this._bufs[i2]);
  return copy3;
};
BufferList$1.prototype.append = function append2(buf) {
  if (buf == null)
    return this;
  if (buf.buffer)
    this._appendBuffer(Buffer$1.from(buf.buffer, buf.byteOffset, buf.byteLength));
  else if (Array.isArray(buf))
    for (let i2 = 0; i2 < buf.length; i2++)
      this.append(buf[i2]);
  else if (this._isBufferList(buf))
    for (let i2 = 0; i2 < buf._bufs.length; i2++)
      this.append(buf._bufs[i2]);
  else
    typeof buf == "number" && (buf = buf.toString()), this._appendBuffer(Buffer$1.from(buf));
  return this;
};
BufferList$1.prototype._appendBuffer = function appendBuffer(buf) {
  this._bufs.push(buf), this.length += buf.length;
};
BufferList$1.prototype.indexOf = function(search, offset, encoding) {
  if (encoding === void 0 && typeof offset == "string" && (encoding = offset, offset = void 0), typeof search == "function" || Array.isArray(search))
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
  if (typeof search == "number" ? search = Buffer$1.from([search]) : typeof search == "string" ? search = Buffer$1.from(search, encoding) : this._isBufferList(search) ? search = search.slice() : Array.isArray(search.buffer) ? search = Buffer$1.from(search.buffer, search.byteOffset, search.byteLength) : Buffer$1.isBuffer(search) || (search = Buffer$1.from(search)), offset = Number(offset || 0), isNaN(offset) && (offset = 0), offset < 0 && (offset = this.length + offset), offset < 0 && (offset = 0), search.length === 0)
    return offset > this.length ? this.length : offset;
  const blOffset = this._offset(offset);
  let blIndex = blOffset[0], buffOffset = blOffset[1];
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex];
    for (; buffOffset < buff.length; )
      if (buff.length - buffOffset >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset);
        if (nativeSearchResult !== -1)
          return this._reverseOffset([blIndex, nativeSearchResult]);
        buffOffset = buff.length - search.length + 1;
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset]);
        if (this._match(revOffset, search))
          return revOffset;
        buffOffset++;
      }
    buffOffset = 0;
  }
  return -1;
};
BufferList$1.prototype._match = function(offset, search) {
  if (this.length - offset < search.length)
    return !1;
  for (let searchOffset = 0; searchOffset < search.length; searchOffset++)
    if (this.get(offset + searchOffset) !== search[searchOffset])
      return !1;
  return !0;
};
(function() {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  };
  for (const m in methods)
    (function(m2) {
      methods[m2] === null ? BufferList$1.prototype[m2] = function(offset, byteLength) {
        return this.slice(offset, offset + byteLength)[m2](0, byteLength);
      } : BufferList$1.prototype[m2] = function(offset = 0) {
        return this.slice(offset, offset + methods[m2])[m2](0);
      };
    })(m);
})();
BufferList$1.prototype._isBufferList = function _isBufferList(b) {
  return b instanceof BufferList$1 || BufferList$1.isBufferList(b);
};
BufferList$1.isBufferList = function isBufferList(b) {
  return b != null && b[symbol];
};
var BufferList_1 = BufferList$1;
const DuplexStream = readableExports.Duplex, inherits = inheritsExports, BufferList = BufferList_1;
function BufferListStream$1(callback) {
  if (!(this instanceof BufferListStream$1))
    return new BufferListStream$1(callback);
  if (typeof callback == "function") {
    this._callback = callback;
    const piper = function(err) {
      this._callback && (this._callback(err), this._callback = null);
    }.bind(this);
    this.on("pipe", function(src2) {
      src2.on("error", piper);
    }), this.on("unpipe", function(src2) {
      src2.removeListener("error", piper);
    }), callback = null;
  }
  BufferList._init.call(this, callback), DuplexStream.call(this);
}
inherits(BufferListStream$1, DuplexStream);
Object.assign(BufferListStream$1.prototype, BufferList.prototype);
BufferListStream$1.prototype._new = function _new2(callback) {
  return new BufferListStream$1(callback);
};
BufferListStream$1.prototype._write = function _write(buf, encoding, callback) {
  this._appendBuffer(buf), typeof callback == "function" && callback();
};
BufferListStream$1.prototype._read = function _read(size) {
  if (!this.length)
    return this.push(null);
  size = Math.min(size, this.length), this.push(this.slice(0, size)), this.consume(size);
};
BufferListStream$1.prototype.end = function end(chunk) {
  DuplexStream.prototype.end.call(this, chunk), this._callback && (this._callback(null, this.slice()), this._callback = null);
};
BufferListStream$1.prototype._destroy = function _destroy(err, cb) {
  this._bufs.length = 0, this.length = 0, cb(err);
};
BufferListStream$1.prototype._isBufferList = function _isBufferList2(b) {
  return b instanceof BufferListStream$1 || b instanceof BufferList || BufferListStream$1.isBufferList(b);
};
BufferListStream$1.isBufferList = BufferList.isBufferList;
bl.exports = BufferListStream$1;
bl.exports.BufferListStream = BufferListStream$1;
bl.exports.BufferList = BufferList;
var blExports = bl.exports;
const readline$2 = require$$0__default$a.default, chalk$1 = chalk__default.default, cliCursor$1 = cliCursor$2, cliSpinners = cliSpinners$1, logSymbols = logSymbols$1, stripAnsi$2 = stripAnsi$4, wcwidth = wcwidthExports, isInteractive = isInteractive$1, isUnicodeSupported = isUnicodeSupported$2, { BufferListStream } = blExports, TEXT = Symbol("text"), PREFIX_TEXT = Symbol("prefixText"), ASCII_ETX_CODE = 3;
class StdinDiscarder {
  constructor() {
    this.requests = 0, this.mutedStream = new BufferListStream(), this.mutedStream.pipe(process.stdout);
    const self2 = this;
    this.ourEmit = function(event, data, ...args) {
      const { stdin } = process;
      if (self2.requests > 0 || stdin.emit === self2.ourEmit) {
        if (event === "keypress")
          return;
        event === "data" && data.includes(ASCII_ETX_CODE) && process.emit("SIGINT"), Reflect.apply(self2.oldEmit, this, [event, data, ...args]);
      } else
        Reflect.apply(process.stdin.emit, this, [event, data, ...args]);
    };
  }
  start() {
    this.requests++, this.requests === 1 && this.realStart();
  }
  stop() {
    if (this.requests <= 0)
      throw new Error("`stop` called more times than `start`");
    this.requests--, this.requests === 0 && this.realStop();
  }
  realStart() {
    process.platform !== "win32" && (this.rl = readline$2.createInterface({
      input: process.stdin,
      output: this.mutedStream
    }), this.rl.on("SIGINT", () => {
      process.listenerCount("SIGINT") === 0 ? process.emit("SIGINT") : (this.rl.close(), process.kill(process.pid, "SIGINT"));
    }));
  }
  realStop() {
    process.platform !== "win32" && (this.rl.close(), this.rl = void 0);
  }
}
let stdinDiscarder;
class Ora {
  constructor(options2) {
    stdinDiscarder || (stdinDiscarder = new StdinDiscarder()), typeof options2 == "string" && (options2 = {
      text: options2
    }), this.options = {
      text: "",
      color: "cyan",
      stream: process.stderr,
      discardStdin: !0,
      ...options2
    }, this.spinner = this.options.spinner, this.color = this.options.color, this.hideCursor = this.options.hideCursor !== !1, this.interval = this.options.interval || this.spinner.interval || 100, this.stream = this.options.stream, this.id = void 0, this.isEnabled = typeof this.options.isEnabled == "boolean" ? this.options.isEnabled : isInteractive({ stream: this.stream }), this.isSilent = typeof this.options.isSilent == "boolean" ? this.options.isSilent : !1, this.text = this.options.text, this.prefixText = this.options.prefixText, this.linesToClear = 0, this.indent = this.options.indent, this.discardStdin = this.options.discardStdin, this.isDiscardingStdin = !1;
  }
  get indent() {
    return this._indent;
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent)))
      throw new Error("The `indent` option must be an integer from 0 and up");
    this._indent = indent;
  }
  _updateInterval(interval2) {
    interval2 !== void 0 && (this.interval = interval2);
  }
  get spinner() {
    return this._spinner;
  }
  set spinner(spinner) {
    if (this.frameIndex = 0, typeof spinner == "object") {
      if (spinner.frames === void 0)
        throw new Error("The given spinner must have a `frames` property");
      this._spinner = spinner;
    } else if (!isUnicodeSupported())
      this._spinner = cliSpinners.line;
    else if (spinner === void 0)
      this._spinner = cliSpinners.dots;
    else if (spinner !== "default" && cliSpinners[spinner])
      this._spinner = cliSpinners[spinner];
    else
      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
    this._updateInterval(this._spinner.interval);
  }
  get text() {
    return this[TEXT];
  }
  set text(value) {
    this[TEXT] = value, this.updateLineCount();
  }
  get prefixText() {
    return this[PREFIX_TEXT];
  }
  set prefixText(value) {
    this[PREFIX_TEXT] = value, this.updateLineCount();
  }
  get isSpinning() {
    return this.id !== void 0;
  }
  getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = " ") {
    return typeof prefixText == "string" ? prefixText + postfix : typeof prefixText == "function" ? prefixText() + postfix : "";
  }
  updateLineCount() {
    const columns = this.stream.columns || 80, fullPrefixText = this.getFullPrefixText(this.prefixText, "-");
    this.lineCount = 0;
    for (const line3 of stripAnsi$2(fullPrefixText + "--" + this[TEXT]).split(`
`))
      this.lineCount += Math.max(1, Math.ceil(wcwidth(line3) / columns));
  }
  get isEnabled() {
    return this._isEnabled && !this.isSilent;
  }
  set isEnabled(value) {
    if (typeof value != "boolean")
      throw new TypeError("The `isEnabled` option must be a boolean");
    this._isEnabled = value;
  }
  get isSilent() {
    return this._isSilent;
  }
  set isSilent(value) {
    if (typeof value != "boolean")
      throw new TypeError("The `isSilent` option must be a boolean");
    this._isSilent = value;
  }
  frame() {
    const { frames } = this.spinner;
    let frame = frames[this.frameIndex];
    this.color && (frame = chalk$1[this.color](frame)), this.frameIndex = ++this.frameIndex % frames.length;
    const fullPrefixText = typeof this.prefixText == "string" && this.prefixText !== "" ? this.prefixText + " " : "", fullText = typeof this.text == "string" ? " " + this.text : "";
    return fullPrefixText + frame + fullText;
  }
  clear() {
    if (!this.isEnabled || !this.stream.isTTY)
      return this;
    for (let i2 = 0; i2 < this.linesToClear; i2++)
      i2 > 0 && this.stream.moveCursor(0, -1), this.stream.clearLine(), this.stream.cursorTo(this.indent);
    return this.linesToClear = 0, this;
  }
  render() {
    return this.isSilent ? this : (this.clear(), this.stream.write(this.frame()), this.linesToClear = this.lineCount, this);
  }
  start(text) {
    return text && (this.text = text), this.isSilent ? this : this.isEnabled ? this.isSpinning ? this : (this.hideCursor && cliCursor$1.hide(this.stream), this.discardStdin && process.stdin.isTTY && (this.isDiscardingStdin = !0, stdinDiscarder.start()), this.render(), this.id = setInterval(this.render.bind(this), this.interval), this) : (this.text && this.stream.write(`- ${this.text}
`), this);
  }
  stop() {
    return this.isEnabled ? (clearInterval(this.id), this.id = void 0, this.frameIndex = 0, this.clear(), this.hideCursor && cliCursor$1.show(this.stream), this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin && (stdinDiscarder.stop(), this.isDiscardingStdin = !1), this) : this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: logSymbols.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: logSymbols.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: logSymbols.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: logSymbols.info, text });
  }
  stopAndPersist(options2 = {}) {
    if (this.isSilent)
      return this;
    const prefixText = options2.prefixText || this.prefixText, text = options2.text || this.text, fullText = typeof text == "string" ? " " + text : "";
    return this.stop(), this.stream.write(`${this.getFullPrefixText(prefixText, " ")}${options2.symbol || " "}${fullText}
`), this;
  }
}
const oraFactory = function(options2) {
  return new Ora(options2);
};
ora$1.exports = oraFactory;
ora$1.exports.promise = (action, options2) => {
  if (typeof action.then != "function")
    throw new TypeError("Parameter `action` must be a Promise");
  const spinner = new Ora(options2);
  return spinner.start(), (async () => {
    try {
      await action, spinner.succeed();
    } catch {
      spinner.fail();
    }
  })(), spinner;
};
var oraExports = ora$1.exports, ora = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(oraExports);
let isFirstClear = !0;
var cliOutputter = {
  print(...args) {
    console.log(...args);
  },
  warn(...args) {
    console.warn(...args);
  },
  error(...args) {
    args[0] instanceof Error ? console.error(chalk__default.default.red(args[0].stack)) : console.error(...args);
  },
  clear: () => {
    process.stdout.write(isFirstClear ? "\x1Bc" : "\x1B[2J\x1B[0f"), isFirstClear = !1;
  },
  spinner(options2) {
    return ora(options2);
  }
}, inquirer$1 = { exports: {} }, matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g, escapeStringRegexp$3 = function(str2) {
  if (typeof str2 != "string")
    throw new TypeError("Expected a string");
  return str2.replace(matchOperatorsRe, "\\$&");
};
const escapeStringRegexp$2 = escapeStringRegexp$3, platform = process.platform, main$1 = {
  tick: "\u2714",
  cross: "\u2716",
  star: "\u2605",
  square: "\u2587",
  squareSmall: "\u25FB",
  squareSmallFilled: "\u25FC",
  play: "\u25B6",
  circle: "\u25EF",
  circleFilled: "\u25C9",
  circleDotted: "\u25CC",
  circleDouble: "\u25CE",
  circleCircle: "\u24DE",
  circleCross: "\u24E7",
  circlePipe: "\u24BE",
  circleQuestionMark: "?\u20DD",
  bullet: "\u25CF",
  dot: "\u2024",
  line: "\u2500",
  ellipsis: "\u2026",
  pointer: "\u276F",
  pointerSmall: "\u203A",
  info: "\u2139",
  warning: "\u26A0",
  hamburger: "\u2630",
  smiley: "\u32E1",
  mustache: "\u0DF4",
  heart: "\u2665",
  arrowUp: "\u2191",
  arrowDown: "\u2193",
  arrowLeft: "\u2190",
  arrowRight: "\u2192",
  radioOn: "\u25C9",
  radioOff: "\u25EF",
  checkboxOn: "\u2612",
  checkboxOff: "\u2610",
  checkboxCircleOn: "\u24E7",
  checkboxCircleOff: "\u24BE",
  questionMarkPrefix: "?\u20DD",
  oneHalf: "\xBD",
  oneThird: "\u2153",
  oneQuarter: "\xBC",
  oneFifth: "\u2155",
  oneSixth: "\u2159",
  oneSeventh: "\u2150",
  oneEighth: "\u215B",
  oneNinth: "\u2151",
  oneTenth: "\u2152",
  twoThirds: "\u2154",
  twoFifths: "\u2156",
  threeQuarters: "\xBE",
  threeFifths: "\u2157",
  threeEighths: "\u215C",
  fourFifths: "\u2158",
  fiveSixths: "\u215A",
  fiveEighths: "\u215D",
  sevenEighths: "\u215E"
}, win = {
  tick: "\u221A",
  cross: "\xD7",
  star: "*",
  square: "\u2588",
  squareSmall: "[ ]",
  squareSmallFilled: "[\u2588]",
  play: "\u25BA",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "(\u25CB)",
  circleCross: "(\xD7)",
  circlePipe: "(\u2502)",
  circleQuestionMark: "(?)",
  bullet: "*",
  dot: ".",
  line: "\u2500",
  ellipsis: "...",
  pointer: ">",
  pointerSmall: "\xBB",
  info: "i",
  warning: "\u203C",
  hamburger: "\u2261",
  smiley: "\u263A",
  mustache: "\u250C\u2500\u2510",
  heart: main$1.heart,
  arrowUp: main$1.arrowUp,
  arrowDown: main$1.arrowDown,
  arrowLeft: main$1.arrowLeft,
  arrowRight: main$1.arrowRight,
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[\xD7]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "(\xD7)",
  checkboxCircleOff: "( )",
  questionMarkPrefix: "\uFF1F",
  oneHalf: "1/2",
  oneThird: "1/3",
  oneQuarter: "1/4",
  oneFifth: "1/5",
  oneSixth: "1/6",
  oneSeventh: "1/7",
  oneEighth: "1/8",
  oneNinth: "1/9",
  oneTenth: "1/10",
  twoThirds: "2/3",
  twoFifths: "2/5",
  threeQuarters: "3/4",
  threeFifths: "3/5",
  threeEighths: "3/8",
  fourFifths: "4/5",
  fiveSixths: "5/6",
  fiveEighths: "5/8",
  sevenEighths: "7/8"
};
platform === "linux" && (main$1.questionMarkPrefix = "?");
const figures$1 = platform === "win32" ? win : main$1, fn = (str2) => (figures$1 === main$1 || Object.keys(main$1).forEach((key2) => {
  main$1[key2] !== figures$1[key2] && (str2 = str2.replace(new RegExp(escapeStringRegexp$2(main$1[key2]), "g"), figures$1[key2]));
}), str2);
var figures_1 = Object.assign(fn, figures$1), chalk = chalk__default.default, figures = figures_1;
class Separator {
  constructor(line3) {
    this.type = "separator", this.line = chalk.dim(line3 || new Array(15).join(figures.line));
  }
  /**
   * Stringify separator
   * @return {String} the separator display string
   */
  toString() {
    return this.line;
  }
}
Separator.exclude = function(obj) {
  return obj.type !== "separator";
};
var separator = Separator, through$1 = { exports: {} };
(function(module2, exports2) {
  var Stream2 = require$$0__default$4.default;
  module2.exports = through2, through2.through = through2;
  function through2(write, end2, opts) {
    write = write || function(data) {
      this.queue(data);
    }, end2 = end2 || function() {
      this.queue(null);
    };
    var ended = !1, destroyed = !1, buffer2 = [], _ended = !1, stream2 = new Stream2();
    stream2.readable = stream2.writable = !0, stream2.paused = !1, stream2.autoDestroy = !(opts && opts.autoDestroy === !1), stream2.write = function(data) {
      return write.call(this, data), !stream2.paused;
    };
    function drain() {
      for (; buffer2.length && !stream2.paused; ) {
        var data = buffer2.shift();
        if (data === null)
          return stream2.emit("end");
        stream2.emit("data", data);
      }
    }
    stream2.queue = stream2.push = function(data) {
      return _ended || (data === null && (_ended = !0), buffer2.push(data), drain()), stream2;
    }, stream2.on("end", function() {
      stream2.readable = !1, !stream2.writable && stream2.autoDestroy && process.nextTick(function() {
        stream2.destroy();
      });
    });
    function _end() {
      stream2.writable = !1, end2.call(stream2), !stream2.readable && stream2.autoDestroy && stream2.destroy();
    }
    return stream2.end = function(data) {
      if (!ended)
        return ended = !0, arguments.length && stream2.write(data), _end(), stream2;
    }, stream2.destroy = function() {
      if (!destroyed)
        return destroyed = !0, ended = !0, buffer2.length = 0, stream2.writable = stream2.readable = !1, stream2.emit("close"), stream2;
    }, stream2.pause = function() {
      if (!stream2.paused)
        return stream2.paused = !0, stream2;
    }, stream2.resume = function() {
      return stream2.paused && (stream2.paused = !1, stream2.emit("resume")), drain(), stream2.paused || stream2.emit("drain"), stream2;
    }, stream2;
  }
})(through$1);
var throughExports = through$1.exports, Stream = require$$0__default$4.default, mute = MuteStream$1;
function MuteStream$1(opts) {
  Stream.apply(this), opts = opts || {}, this.writable = this.readable = !0, this.muted = !1, this.on("pipe", this._onpipe), this.replace = opts.replace, this._prompt = opts.prompt || null, this._hadControl = !1;
}
MuteStream$1.prototype = Object.create(Stream.prototype);
Object.defineProperty(MuteStream$1.prototype, "constructor", {
  value: MuteStream$1,
  enumerable: !1
});
MuteStream$1.prototype.mute = function() {
  this.muted = !0;
};
MuteStream$1.prototype.unmute = function() {
  this.muted = !1;
};
Object.defineProperty(MuteStream$1.prototype, "_onpipe", {
  value: onPipe,
  enumerable: !1,
  writable: !0,
  configurable: !0
});
function onPipe(src2) {
  this._src = src2;
}
Object.defineProperty(MuteStream$1.prototype, "isTTY", {
  get: getIsTTY,
  set: setIsTTY,
  enumerable: !0,
  configurable: !0
});
function getIsTTY() {
  return this._dest ? this._dest.isTTY : this._src ? this._src.isTTY : !1;
}
function setIsTTY(isTTY) {
  Object.defineProperty(this, "isTTY", {
    value: isTTY,
    enumerable: !0,
    writable: !0,
    configurable: !0
  });
}
Object.defineProperty(MuteStream$1.prototype, "rows", {
  get: function() {
    return this._dest ? this._dest.rows : this._src ? this._src.rows : void 0;
  },
  enumerable: !0,
  configurable: !0
});
Object.defineProperty(MuteStream$1.prototype, "columns", {
  get: function() {
    return this._dest ? this._dest.columns : this._src ? this._src.columns : void 0;
  },
  enumerable: !0,
  configurable: !0
});
MuteStream$1.prototype.pipe = function(dest, options2) {
  return this._dest = dest, Stream.prototype.pipe.call(this, dest, options2);
};
MuteStream$1.prototype.pause = function() {
  if (this._src) return this._src.pause();
};
MuteStream$1.prototype.resume = function() {
  if (this._src) return this._src.resume();
};
MuteStream$1.prototype.write = function(c2) {
  if (this.muted) {
    if (!this.replace) return !0;
    if (c2.match(/^\u001b/))
      return c2.indexOf(this._prompt) === 0 && (c2 = c2.substr(this._prompt.length), c2 = c2.replace(/./g, this.replace), c2 = this._prompt + c2), this._hadControl = !0, this.emit("data", c2);
    this._prompt && this._hadControl && c2.indexOf(this._prompt) === 0 && (this._hadControl = !1, this.emit("data", this._prompt), c2 = c2.substr(this._prompt.length)), c2 = c2.toString().replace(/./g, this.replace);
  }
  this.emit("data", c2);
};
MuteStream$1.prototype.end = function(c2) {
  this.muted && (c2 && this.replace ? c2 = c2.toString().replace(/./g, this.replace) : c2 = null), c2 && this.emit("data", c2), this.emit("end");
};
function proxy(fn2) {
  return function() {
    var d = this._dest, s = this._src;
    d && d[fn2] && d[fn2].apply(d, arguments), s && s[fn2] && s[fn2].apply(s, arguments);
  };
}
MuteStream$1.prototype.destroy = proxy("destroy");
MuteStream$1.prototype.destroySoon = proxy("destroySoon");
MuteStream$1.prototype.close = proxy("close");
var _$3 = lodashExports, MuteStream = mute, readline$1 = require$$0__default$a.default;
class UI {
  constructor(opt) {
    this.rl || (this.rl = readline$1.createInterface(setupReadlineOptions(opt))), this.rl.resume(), this.onForceClose = this.onForceClose.bind(this), process.on("exit", this.onForceClose), this.rl.on("SIGINT", this.onForceClose);
  }
  /**
   * Handle the ^C exit
   * @return {null}
   */
  onForceClose() {
    this.close(), process.kill(process.pid, "SIGINT"), console.log("");
  }
  /**
   * Close the interface and cleanup listeners
   */
  close() {
    this.rl.removeListener("SIGINT", this.onForceClose), process.removeListener("exit", this.onForceClose), this.rl.output.unmute(), this.activePrompt && typeof this.activePrompt.close == "function" && this.activePrompt.close(), this.rl.output.end(), this.rl.pause(), this.rl.close();
  }
}
function setupReadlineOptions(opt) {
  opt = opt || {};
  var input2 = opt.input || process.stdin, ms = new MuteStream();
  ms.pipe(opt.output || process.stdout);
  var output = ms;
  return _$3.extend(
    {
      terminal: !0,
      input: input2,
      output
    },
    _$3.omit(opt, ["input", "output"])
  );
}
var baseUI = UI, readline = {}, ansiEscapes$1 = { exports: {} };
(function(module2) {
  const x = module2.exports, ESC = "\x1B[", OSC = "\x1B]", BEL = "\x07", SEP = ";", isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
  x.cursorTo = (x2, y) => {
    if (typeof x2 != "number")
      throw new TypeError("The `x` argument is required");
    return typeof y != "number" ? ESC + (x2 + 1) + "G" : ESC + (y + 1) + ";" + (x2 + 1) + "H";
  }, x.cursorMove = (x2, y) => {
    if (typeof x2 != "number")
      throw new TypeError("The `x` argument is required");
    let ret = "";
    return x2 < 0 ? ret += ESC + -x2 + "D" : x2 > 0 && (ret += ESC + x2 + "C"), y < 0 ? ret += ESC + -y + "A" : y > 0 && (ret += ESC + y + "B"), ret;
  }, x.cursorUp = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "A", x.cursorDown = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "B", x.cursorForward = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "C", x.cursorBackward = (count2) => ESC + (typeof count2 == "number" ? count2 : 1) + "D", x.cursorLeft = ESC + "G", x.cursorSavePosition = ESC + (isTerminalApp ? "7" : "s"), x.cursorRestorePosition = ESC + (isTerminalApp ? "8" : "u"), x.cursorGetPosition = ESC + "6n", x.cursorNextLine = ESC + "E", x.cursorPrevLine = ESC + "F", x.cursorHide = ESC + "?25l", x.cursorShow = ESC + "?25h", x.eraseLines = (count2) => {
    let clear = "";
    for (let i2 = 0; i2 < count2; i2++)
      clear += x.eraseLine + (i2 < count2 - 1 ? x.cursorUp() : "");
    return count2 && (clear += x.cursorLeft), clear;
  }, x.eraseEndLine = ESC + "K", x.eraseStartLine = ESC + "1K", x.eraseLine = ESC + "2K", x.eraseDown = ESC + "J", x.eraseUp = ESC + "1J", x.eraseScreen = ESC + "2J", x.scrollUp = ESC + "S", x.scrollDown = ESC + "T", x.clearScreen = "\x1Bc", x.clearTerminal = process.platform === "win32" ? `${x.eraseScreen}${ESC}0f` : (
    // 1. Erases the screen (Only done in case `2` is not supported)
    // 2. Erases the whole screen including scrollback buffer
    // 3. Moves cursor to the top-left position
    // More info: https://www.real-world-systems.com/docs/ANSIcode.html
    `${x.eraseScreen}${ESC}3J${ESC}H`
  ), x.beep = BEL, x.link = (text, url2) => [
    OSC,
    "8",
    SEP,
    SEP,
    url2,
    BEL,
    text,
    OSC,
    "8",
    SEP,
    SEP,
    BEL
  ].join(""), x.image = (buf, opts) => {
    opts = opts || {};
    let ret = OSC + "1337;File=inline=1";
    return opts.width && (ret += `;width=${opts.width}`), opts.height && (ret += `;height=${opts.height}`), opts.preserveAspectRatio === !1 && (ret += ";preserveAspectRatio=0"), ret + ":" + buf.toString("base64") + BEL;
  }, x.iTerm = {}, x.iTerm.setCwd = (cwd2) => OSC + "50;CurrentDir=" + (cwd2 || process.cwd()) + BEL;
})(ansiEscapes$1);
var ansiEscapesExports = ansiEscapes$1.exports, ansiEscapes = ansiEscapesExports;
readline.left = function(rl, x) {
  rl.output.write(ansiEscapes.cursorBackward(x));
};
readline.right = function(rl, x) {
  rl.output.write(ansiEscapes.cursorForward(x));
};
readline.up = function(rl, x) {
  rl.output.write(ansiEscapes.cursorUp(x));
};
readline.down = function(rl, x) {
  rl.output.write(ansiEscapes.cursorDown(x));
};
readline.clearLine = function(rl, len) {
  rl.output.write(ansiEscapes.eraseLines(len));
};
var through = throughExports, Base$1 = baseUI, rlUtils = readline, _$2 = lodashExports;
class BottomBar extends Base$1 {
  constructor(opt) {
    opt = opt || {}, super(opt), this.log = through(this.writeLog.bind(this)), this.bottomBar = opt.bottomBar || "", this.render();
  }
  /**
   * Render the prompt to screen
   * @return {BottomBar} self
   */
  render() {
    return this.write(this.bottomBar), this;
  }
  clean() {
    return rlUtils.clearLine(this.rl, this.bottomBar.split(`
`).length), this;
  }
  /**
   * Update the bottom bar content and rerender
   * @param  {String} bottomBar Bottom bar content
   * @return {BottomBar}           self
   */
  updateBottomBar(bottomBar2) {
    return rlUtils.clearLine(this.rl, 1), this.rl.output.unmute(), this.clean(), this.bottomBar = bottomBar2, this.render(), this.rl.output.mute(), this;
  }
  /**
   * Write out log data
   * @param {String} data - The log data to be output
   * @return {BottomBar} self
   */
  writeLog(data) {
    return this.rl.output.unmute(), this.clean(), this.rl.output.write(this.enforceLF(data.toString())), this.render(), this.rl.output.mute(), this;
  }
  /**
   * Make sure line end on a line feed
   * @param  {String} str Input string
   * @return {String}     The input string with a final line feed
   */
  enforceLF(str2) {
    return str2.match(/[\r\n]$/) ? str2 : str2 + `
`;
  }
  /**
   * Helper for writing message in Prompt
   * @param {BottomBar} prompt  - The Prompt object that extends tty
   * @param {String} message - The message to be output
   */
  write(message) {
    var msgLines = message.split(/\n/);
    this.height = msgLines.length, this.rl.setPrompt(_$2.last(msgLines)), this.rl.output.rows === 0 && this.rl.output.columns === 0 && rlUtils.left(this.rl, message.length + this.rl.line.length), this.rl.output.write(message);
  }
}
var bottomBar = BottomBar;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
  }, extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function isFunction(x) {
  return typeof x == "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1, config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$2 = {
  closed: !0,
  next: function(value) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling)
      throw err;
    hostReportError(err);
  },
  complete: function() {
  }
}, isArray = /* @__PURE__ */ function() {
  return Array.isArray || function(x) {
    return x && typeof x.length == "number";
  };
}();
function isObject(x) {
  return x !== null && typeof x == "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors2) {
    return Error.call(this), this.message = errors2 ? errors2.length + ` errors occurred during unsubscription:
` + errors2.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = errors2, this;
  }
  return UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), UnsubscriptionErrorImpl2;
}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, unsubscribe && (this._ctorUnsubscribe = !0, this._unsubscribe = unsubscribe);
  }
  return Subscription2.prototype.unsubscribe = function() {
    var errors2;
    if (!this.closed) {
      var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, _parentOrParents instanceof Subscription2)
        _parentOrParents.remove(this);
      else if (_parentOrParents !== null)
        for (var index = 0; index < _parentOrParents.length; ++index) {
          var parent_1 = _parentOrParents[index];
          parent_1.remove(this);
        }
      if (isFunction(_unsubscribe)) {
        _ctorUnsubscribe && (this._unsubscribe = void 0);
        try {
          _unsubscribe.call(this);
        } catch (e) {
          errors2 = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
        }
      }
      if (isArray(_subscriptions))
        for (var index = -1, len = _subscriptions.length; ++index < len; ) {
          var sub = _subscriptions[index];
          if (isObject(sub))
            try {
              sub.unsubscribe();
            } catch (e) {
              errors2 = errors2 || [], e instanceof UnsubscriptionError ? errors2 = errors2.concat(flattenUnsubscriptionErrors(e.errors)) : errors2.push(e);
            }
        }
      if (errors2)
        throw new UnsubscriptionError(errors2);
    }
  }, Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown)
      return Subscription2.EMPTY;
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe != "function")
          return subscription;
        if (this.closed)
          return subscription.unsubscribe(), subscription;
        if (!(subscription instanceof Subscription2)) {
          var tmp2 = subscription;
          subscription = new Subscription2(), subscription._subscriptions = [tmp2];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null)
      subscription._parentOrParents = this;
    else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this)
        return subscription;
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1)
      _parentOrParents.push(this);
    else
      return subscription;
    var subscriptions = this._subscriptions;
    return subscriptions === null ? this._subscriptions = [subscription] : subscriptions.push(subscription), subscription;
  }, Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      subscriptionIndex !== -1 && subscriptions.splice(subscriptionIndex, 1);
    }
  }, Subscription2.EMPTY = function(empty2) {
    return empty2.closed = !0, empty2;
  }(new Subscription2()), Subscription2;
}();
function flattenUnsubscriptionErrors(errors2) {
  return errors2.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, _this.isStopped = !1, arguments.length) {
      case 0:
        _this.destination = empty$2;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$2;
          break;
        }
        if (typeof destinationOrNext == "object") {
          destinationOrNext instanceof Subscriber2 ? (_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, _this.destination = destinationOrNext, destinationOrNext.add(_this)) : (_this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext));
          break;
        }
      default:
        _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext, error2, complete);
        break;
    }
    return _this;
  }
  return Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  }, Subscriber2.create = function(next, error2, complete) {
    var subscriber = new Subscriber2(next, error2, complete);
    return subscriber.syncErrorThrowable = !1, subscriber;
  }, Subscriber2.prototype.next = function(value) {
    this.isStopped || this._next(value);
  }, Subscriber2.prototype.error = function(err) {
    this.isStopped || (this.isStopped = !0, this._error(err));
  }, Subscriber2.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, Subscriber2.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this));
  }, Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  }, Subscriber2.prototype._error = function(err) {
    this.destination.error(err), this.unsubscribe();
  }, Subscriber2.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = _parentOrParents, this;
  }, Subscriber2;
}(Subscription), SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next, context = _this;
    return isFunction(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, error2 = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== empty$2 && (context = Object.create(observerOrNext), isFunction(context.unsubscribe) && _this.add(context.unsubscribe.bind(context)), context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, _this._next = next, _this._error = error2, _this._complete = complete, _this;
  }
  return SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      !config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable ? this.__tryOrUnsub(this._next, value) : this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe();
    }
  }, SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber, useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable ? (this.__tryOrUnsub(this._error, err), this.unsubscribe()) : (this.__tryOrSetError(_parentSubscriber, this._error, err), this.unsubscribe());
      else if (_parentSubscriber.syncErrorThrowable)
        useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, _parentSubscriber.syncErrorThrown = !0) : hostReportError(err), this.unsubscribe();
      else {
        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling)
          throw err;
        hostReportError(err);
      }
    }
  }, SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        !config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable ? (this.__tryOrUnsub(wrappedComplete), this.unsubscribe()) : (this.__tryOrSetError(_parentSubscriber, wrappedComplete), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
    try {
      fn2.call(this._context, value);
    } catch (err) {
      if (this.unsubscribe(), config.useDeprecatedSynchronousErrorHandling)
        throw err;
      hostReportError(err);
    }
  }, SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value) {
    if (!config.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      fn2.call(this._context, value);
    } catch (err) {
      return config.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, parent.syncErrorThrown = !0, !0) : (hostReportError(err), !0);
    }
    return !1;
  }, SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
  }, SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  for (; observer; ) {
    var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
    if (closed_1 || isStopped)
      return !1;
    destination && destination instanceof Subscriber ? observer = destination : observer = null;
  }
  return !0;
}
function toSubscriber(nextOrObserver, error2, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber)
      return nextOrObserver;
    if (nextOrObserver[rxSubscriber])
      return nextOrObserver[rxSubscriber]();
  }
  return !nextOrObserver && !error2 && !complete ? new Subscriber(empty$2) : new Subscriber(nextOrObserver, error2, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipe() {
  for (var fns = [], _i = 0; _i < arguments.length; _i++)
    fns[_i] = arguments[_i];
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  return fns.length === 0 ? identity : fns.length === 1 ? fns[0] : function(input2) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input2);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe) {
    this._isScalar = !1, subscribe && (this._subscribe = subscribe);
  }
  return Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    return observable2.source = this, observable2.operator = operator, observable2;
  }, Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var operator = this.operator, sink = toSubscriber(observerOrNext, error2, complete);
    if (operator ? sink.add(operator.call(sink, this.source)) : sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), config.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, sink.syncErrorThrown))
      throw sink.syncErrorValue;
    return sink;
  }, Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      config.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), canReportError(sink) ? sink.error(err) : console.warn(err);
    }
  }, Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    return promiseCtor = getPromiseCtor(promiseCtor), new promiseCtor(function(resolve2, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err), subscription && subscription.unsubscribe();
        }
      }, reject, resolve2);
    });
  }, Observable2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    return source2 && source2.subscribe(subscriber);
  }, Observable2.prototype[observable] = function() {
    return this;
  }, Observable2.prototype.pipe = function() {
    for (var operations = [], _i = 0; _i < arguments.length; _i++)
      operations[_i] = arguments[_i];
    return operations.length === 0 ? this : pipeFromArray(operations)(this);
  }, Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    return promiseCtor = getPromiseCtor(promiseCtor), new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  }, Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  }, Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (promiseCtor || (promiseCtor = config.Promise || Promise), !promiseCtor)
    throw new Error("no Promise impl found");
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), ObjectUnsubscribedErrorImpl2;
}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, _this;
  }
  return SubjectSubscription2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var subject = this.subject, observers = subject.observers;
      if (this.subject = null, !(!observers || observers.length === 0 || subject.isStopped || subject.closed)) {
        var subscriberIndex = observers.indexOf(this.subscriber);
        subscriberIndex !== -1 && observers.splice(subscriberIndex, 1);
      }
    }
  }, SubjectSubscription2;
}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this;
  }
  return SubjectSubscriber2;
}(Subscriber), Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, _this.thrownError = null, _this;
  }
  return Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  }, Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    return subject.operator = operator, subject;
  }, Subject2.prototype.next = function(value) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (!this.isStopped)
      for (var observers = this.observers, len = observers.length, copy3 = observers.slice(), i2 = 0; i2 < len; i2++)
        copy3[i2].next(value);
  }, Subject2.prototype.error = function(err) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.hasError = !0, this.thrownError = err, this.isStopped = !0;
    for (var observers = this.observers, len = observers.length, copy3 = observers.slice(), i2 = 0; i2 < len; i2++)
      copy3[i2].error(err);
    this.observers.length = 0;
  }, Subject2.prototype.complete = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.isStopped = !0;
    for (var observers = this.observers, len = observers.length, copy3 = observers.slice(), i2 = 0; i2 < len; i2++)
      copy3[i2].complete();
    this.observers.length = 0;
  }, Subject2.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return _super.prototype._trySubscribe.call(this, subscriber);
  }, Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this.hasError ? (subscriber.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (subscriber.complete(), Subscription.EMPTY) : (this.observers.push(subscriber), new SubjectSubscription(this, subscriber));
  }, Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    return observable2.source = this, observable2;
  }, Subject2.create = function(destination, source2) {
    return new AnonymousSubject(destination, source2);
  }, Subject2;
}(Observable), AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source2) {
    var _this = _super.call(this) || this;
    return _this.destination = destination, _this.source = source2, _this;
  }
  return AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    destination && destination.next && destination.next(value);
  }, AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    destination && destination.error && this.destination.error(err);
  }, AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    destination && destination.complete && this.destination.complete();
  }, AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    return source2 ? this.source.subscribe(subscriber) : Subscription.EMPTY;
  }, AnonymousSubject2;
}(Subject);
function refCount() {
  return function(source2) {
    return source2.lift(new RefCountOperator(source2));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  return RefCountOperator2.prototype.call = function(subscriber, source2) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable), subscription = source2.subscribe(refCounter);
    return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
  }, RefCountOperator2;
}(), RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    return _this.connectable = connectable, _this;
  }
  return RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    if (connectable._refCount = refCount2 - 1, refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection, sharedConnection = connectable._connection;
    this.connection = null, sharedConnection && (!connection || sharedConnection === connection) && sharedConnection.unsubscribe();
  }, RefCountSubscriber2;
}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source2, subjectFactory) {
    var _this = _super.call(this) || this;
    return _this.source = source2, _this.subjectFactory = subjectFactory, _this._refCount = 0, _this._isComplete = !1, _this;
  }
  return ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  }, ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    return (!subject || subject.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    return connection || (this._isComplete = !1, connection = this._connection = new Subscription(), connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), connection.closed && (this._connection = null, connection = Subscription.EMPTY)), connection;
  }, ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  }, ConnectableObservable2;
}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: !0 },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
  };
}(), ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    return _this.connectable = connectable, _this;
  }
  return ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe(), _super.prototype._error.call(this, err);
  }, ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this);
  }, ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0, connectable._subject = null, connectable._connection = null, connection && connection.unsubscribe();
    }
  }, ConnectableSubscriber2;
}(SubjectSubscriber);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source2) {
    return source2.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector, this.elementSelector = elementSelector, this.durationSelector = durationSelector, this.subjectSelector = subjectSelector;
  }
  return GroupByOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, GroupByOperator2;
}(), GroupBySubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.keySelector = keySelector, _this.elementSelector = elementSelector, _this.durationSelector = durationSelector, _this.subjectSelector = subjectSelector, _this.groups = null, _this.attemptedToUnsubscribe = !1, _this.count = 0, _this;
  }
  return GroupBySubscriber2.prototype._next = function(value) {
    var key2;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key2);
  }, GroupBySubscriber2.prototype._group = function(value, key2) {
    var groups = this.groups;
    groups || (groups = this.groups = /* @__PURE__ */ new Map());
    var group = groups.get(key2), element;
    if (this.elementSelector)
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    else
      element = value;
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject(), groups.set(key2, group);
      var groupedObservable = new GroupedObservable(key2, group, this);
      if (this.destination.next(groupedObservable), this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key2, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
      }
    }
    group.closed || group.next(element);
  }, GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    groups && (groups.forEach(function(group, key2) {
      group.error(err);
    }), groups.clear()), this.destination.error(err);
  }, GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    groups && (groups.forEach(function(group, key2) {
      group.complete();
    }), groups.clear()), this.destination.complete();
  }, GroupBySubscriber2.prototype.removeGroup = function(key2) {
    this.groups.delete(key2);
  }, GroupBySubscriber2.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && _super.prototype.unsubscribe.call(this));
  }, GroupBySubscriber2;
}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key2, group, parent) {
    var _this = _super.call(this, group) || this;
    return _this.key = key2, _this.group = group, _this.parent = parent, _this;
  }
  return GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  }, GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a = this, parent = _a.parent, key2 = _a.key;
    this.key = this.parent = null, parent && parent.removeGroup(key2);
  }, GroupDurationSubscriber2;
}(Subscriber), GroupedObservable = /* @__PURE__ */ function(_super) {
  __extends(GroupedObservable2, _super);
  function GroupedObservable2(key2, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    return _this.key = key2, _this.groupSubject = groupSubject, _this.refCountSubscription = refCountSubscription, _this;
  }
  return GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription(), _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
    return refCountSubscription && !refCountSubscription.closed && subscription.add(new InnerRefCountSubscription(refCountSubscription)), subscription.add(groupSubject.subscribe(subscriber)), subscription;
  }, GroupedObservable2;
}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  __extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, parent.count++, _this;
  }
  return InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent = this.parent;
    !parent.closed && !this.closed && (_super.prototype.unsubscribe.call(this), parent.count -= 1, parent.count === 0 && parent.attemptedToUnsubscribe && parent.unsubscribe());
  }, InnerRefCountSubscription2;
}(Subscription), BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    return _this._value = _value, _this;
  }
  return Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    return subscription && !subscription.closed && subscriber.next(this._value), subscription;
  }, BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this._value;
  }, BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  }, BehaviorSubject2;
}(Subject), Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  return Action2.prototype.schedule = function(state2, delay2) {
    return this;
  }, Action2;
}(Subscription), AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this;
  }
  return AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0 && (delay2 = 0), this.closed)
      return this;
    this.state = state2;
    var id = this.id, scheduler = this.scheduler;
    return id != null && (this.id = this.recycleAsyncId(scheduler, id, delay2)), this.pending = !0, this.delay = delay2, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2), this;
  }, AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), setInterval(scheduler.flush.bind(scheduler, this), delay2);
  }, AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0 && (delay2 = 0), delay2 !== null && this.delay === delay2 && this.pending === !1)
      return id;
    clearInterval(id);
  }, AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var error2 = this._execute(state2, delay2);
    if (error2)
      return error2;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, AsyncAction2.prototype._execute = function(state2, delay2) {
    var errored = !1, errorValue = void 0;
    try {
      this.work(state2);
    } catch (e) {
      errored = !0, errorValue = !!e && e || new Error(e);
    }
    if (errored)
      return this.unsubscribe(), errorValue;
  }, AsyncAction2.prototype._unsubscribe = function() {
    var id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, index !== -1 && actions.splice(index, 1), id != null && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
  }, AsyncAction2;
}(Action), QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this;
  }
  return QueueAction2.prototype.schedule = function(state2, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 > 0 ? _super.prototype.schedule.call(this, state2, delay2) : (this.delay = delay2, this.state = state2, this.scheduler.flush(this), this);
  }, QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  }, QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay2) : scheduler.flush(this);
  }, QueueAction2;
}(AsyncAction), Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now) {
    now === void 0 && (now = Scheduler2.now), this.SchedulerAction = SchedulerAction, this.now = now;
  }
  return Scheduler2.prototype.schedule = function(work, delay2, state2) {
    return delay2 === void 0 && (delay2 = 0), new this.SchedulerAction(this, work).schedule(state2, delay2);
  }, Scheduler2.now = function() {
    return Date.now();
  }, Scheduler2;
}(), AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    now === void 0 && (now = Scheduler.now);
    var _this = _super.call(this, SchedulerAction, function() {
      return AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this ? AsyncScheduler2.delegate.now() : now();
    }) || this;
    return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this;
  }
  return AsyncScheduler2.prototype.schedule = function(work, delay2, state2) {
    return delay2 === void 0 && (delay2 = 0), AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this ? AsyncScheduler2.delegate.schedule(work, delay2, state2) : _super.prototype.schedule.call(this, work, delay2, state2);
  }, AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error2;
    this.active = !0;
    do
      if (error2 = action.execute(action.state, action.delay))
        break;
    while (action = actions.shift());
    if (this.active = !1, error2) {
      for (; action = actions.shift(); )
        action.unsubscribe();
      throw error2;
    }
  }, AsyncScheduler2;
}(Scheduler), QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue = queueScheduler, EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty$1(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
function isScheduler(value) {
  return value && typeof value.schedule == "function";
}
var subscribeToArray = function(array2) {
  return function(subscriber) {
    for (var i2 = 0, len = array2.length; i2 < len && !subscriber.closed; i2++)
      subscriber.next(array2[i2]);
    subscriber.complete();
  };
};
function scheduleArray(input2, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription(), i2 = 0;
    return sub.add(scheduler.schedule(function() {
      if (i2 === input2.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input2[i2++]), subscriber.closed || sub.add(this.schedule());
    })), sub;
  });
}
function fromArray(input2, scheduler) {
  return scheduler ? scheduleArray(input2, scheduler) : new Observable(subscribeToArray(input2));
}
function of$2() {
  for (var args = [], _i = 0; _i < arguments.length; _i++)
    args[_i] = arguments[_i];
  var scheduler = args[args.length - 1];
  return isScheduler(scheduler) ? (args.pop(), scheduleArray(args, scheduler)) : fromArray(args);
}
function throwError(error2, scheduler) {
  return scheduler ? new Observable(function(subscriber) {
    return scheduler.schedule(dispatch$7, 0, { error: error2, subscriber });
  }) : new Observable(function(subscriber) {
    return subscriber.error(error2);
  });
}
function dispatch$7(_a) {
  var error2 = _a.error, subscriber = _a.subscriber;
  subscriber.error(error2);
}
var NotificationKind;
NotificationKind || (NotificationKind = {});
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error2) {
    this.kind = kind, this.value = value, this.error = error2, this.hasValue = kind === "N";
  }
  return Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  }, Notification2.prototype.do = function(next, error2, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error2 && error2(this.error);
      case "C":
        return complete && complete();
    }
  }, Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
    return nextOrObserver && typeof nextOrObserver.next == "function" ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
  }, Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of$2(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$1();
    }
    throw new Error("unexpected notification kind value");
  }, Notification2.createNext = function(value) {
    return typeof value < "u" ? new Notification2("N", value) : Notification2.undefinedValueNotification;
  }, Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  }, Notification2.createComplete = function() {
    return Notification2.completeNotification;
  }, Notification2.completeNotification = new Notification2("C"), Notification2.undefinedValueNotification = new Notification2("N", void 0), Notification2;
}();
function observeOn(scheduler, delay2) {
  return delay2 === void 0 && (delay2 = 0), function(source2) {
    return source2.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler, delay2) {
    delay2 === void 0 && (delay2 = 0), this.scheduler = scheduler, this.delay = delay2;
  }
  return ObserveOnOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  }, ObserveOnOperator2;
}(), ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay2) {
    delay2 === void 0 && (delay2 = 0);
    var _this = _super.call(this, destination) || this;
    return _this.scheduler = scheduler, _this.delay = delay2, _this;
  }
  return ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination), this.unsubscribe();
  }, ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  }, ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  }, ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err)), this.unsubscribe();
  }, ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
  }, ObserveOnSubscriber2;
}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification, this.destination = destination;
  }
  return ObserveOnMessage2;
}(), ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler) {
    bufferSize === void 0 && (bufferSize = Number.POSITIVE_INFINITY), windowTime2 === void 0 && (windowTime2 = Number.POSITIVE_INFINITY);
    var _this = _super.call(this) || this;
    return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime2 < 1 ? 1 : windowTime2, windowTime2 === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, _this;
  }
  return ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value), _events.length > this._bufferSize && _events.shift();
    }
    _super.prototype.next.call(this, value);
  }, ReplaySubject2.prototype.nextTimeWindow = function(value) {
    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents()), _super.prototype.next.call(this, value);
  }, ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length, subscription;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (this.isStopped || this.hasError ? subscription = Subscription.EMPTY : (this.observers.push(subscriber), subscription = new SubjectSubscription(this, subscriber)), scheduler && subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler)), _infiniteTimeWindow)
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++)
        subscriber.next(_events[i2]);
    else
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++)
        subscriber.next(_events[i2].value);
    return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), subscription;
  }, ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  }, ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); )
      spliceCount++;
    return eventsCount > _bufferSize && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), spliceCount > 0 && _events.splice(0, spliceCount), _events;
  }, ReplaySubject2;
}(Subject), ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time, value) {
    this.time = time, this.value = value;
  }
  return ReplayEvent2;
}(), AsyncSubject = /* @__PURE__ */ function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    return _this.value = null, _this.hasNext = !1, _this.hasCompleted = !1, _this;
  }
  return AsyncSubject2.prototype._subscribe = function(subscriber) {
    return this.hasError ? (subscriber.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (subscriber.next(this.value), subscriber.complete(), Subscription.EMPTY) : _super.prototype._subscribe.call(this, subscriber);
  }, AsyncSubject2.prototype.next = function(value) {
    this.hasCompleted || (this.value = value, this.hasNext = !0);
  }, AsyncSubject2.prototype.error = function(error2) {
    this.hasCompleted || _super.prototype.error.call(this, error2);
  }, AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && _super.prototype.next.call(this, this.value), _super.prototype.complete.call(this);
  }, AsyncSubject2;
}(Subject), nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), activeHandles = {};
function findAndClearHandle(handle) {
  return handle in activeHandles ? (delete activeHandles[handle], !0) : !1;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    return activeHandles[handle] = !0, RESOLVED.then(function() {
      return findAndClearHandle(handle) && cb();
    }), handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
}, AsapAction = /* @__PURE__ */ function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this;
  }
  return AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay2) : (scheduler.actions.push(this), scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null))));
  }, AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0)
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    scheduler.actions.length === 0 && (Immediate.clearImmediate(id), scheduler.scheduled = void 0);
  }, AsapAction2;
}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return AsapScheduler2.prototype.flush = function(action) {
    this.active = !0, this.scheduled = void 0;
    var actions = this.actions, error2, index = -1, count2 = actions.length;
    action = action || actions.shift();
    do
      if (error2 = action.execute(action.state, action.delay))
        break;
    while (++index < count2 && (action = actions.shift()));
    if (this.active = !1, error2) {
      for (; ++index < count2 && (action = actions.shift()); )
        action.unsubscribe();
      throw error2;
    }
  }, AsapScheduler2;
}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async = asyncScheduler, AnimationFrameAction = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this;
  }
  return AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    return delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay2) : (scheduler.actions.push(this), scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
      return scheduler.flush(null);
    })));
  }, AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0 && (delay2 = 0), delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0)
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    scheduler.actions.length === 0 && (cancelAnimationFrame(id), scheduler.scheduled = void 0);
  }, AnimationFrameAction2;
}(AsyncAction), AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return AnimationFrameScheduler2.prototype.flush = function(action) {
    this.active = !0, this.scheduled = void 0;
    var actions = this.actions, error2, index = -1, count2 = actions.length;
    action = action || actions.shift();
    do
      if (error2 = action.execute(action.state, action.delay))
        break;
    while (++index < count2 && (action = actions.shift()));
    if (this.active = !1, error2) {
      for (; ++index < count2 && (action = actions.shift()); )
        action.unsubscribe();
      throw error2;
    }
  }, AnimationFrameScheduler2;
}(AsyncScheduler), animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction), animationFrame = animationFrameScheduler, VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
    SchedulerAction === void 0 && (SchedulerAction = VirtualAction), maxFrames === void 0 && (maxFrames = Number.POSITIVE_INFINITY);
    var _this = _super.call(this, SchedulerAction, function() {
      return _this.frame;
    }) || this;
    return _this.maxFrames = maxFrames, _this.frame = 0, _this.index = -1, _this;
  }
  return VirtualTimeScheduler2.prototype.flush = function() {
    for (var _a = this, actions = _a.actions, maxFrames = _a.maxFrames, error2, action; (action = actions[0]) && action.delay <= maxFrames && (actions.shift(), this.frame = action.delay, !(error2 = action.execute(action.state, action.delay))); )
      ;
    if (error2) {
      for (; action = actions.shift(); )
        action.unsubscribe();
      throw error2;
    }
  }, VirtualTimeScheduler2.frameTimeFactor = 10, VirtualTimeScheduler2;
}(AsyncScheduler), VirtualAction = /* @__PURE__ */ function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    index === void 0 && (index = scheduler.index += 1);
    var _this = _super.call(this, scheduler, work) || this;
    return _this.scheduler = scheduler, _this.work = work, _this.index = index, _this.active = !0, _this.index = scheduler.index = index, _this;
  }
  return VirtualAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0 && (delay2 = 0), !this.id)
      return _super.prototype.schedule.call(this, state2, delay2);
    this.active = !1;
    var action = new VirtualAction2(this.scheduler, this.work);
    return this.add(action), action.schedule(state2, delay2);
  }, VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    delay2 === void 0 && (delay2 = 0), this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    return actions.push(this), actions.sort(VirtualAction2.sortActions), !0;
  }, VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
  }, VirtualAction2.prototype._execute = function(state2, delay2) {
    if (this.active === !0)
      return _super.prototype._execute.call(this, state2, delay2);
  }, VirtualAction2.sortActions = function(a, b) {
    return a.delay === b.delay ? a.index === b.index ? 0 : a.index > b.index ? 1 : -1 : a.delay > b.delay ? 1 : -1;
  }, VirtualAction2;
}(AsyncAction);
function noop() {
}
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift == "function" && typeof obj.subscribe == "function");
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), ArgumentOutOfRangeErrorImpl2;
}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl, EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), EmptyErrorImpl2;
}(), EmptyError = EmptyErrorImpl, TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype), TimeoutErrorImpl2;
}(), TimeoutError$1 = TimeoutErrorImpl;
function map(project, thisArg) {
  return function(source2) {
    if (typeof project != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return source2.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project, this.thisArg = thisArg;
  }
  return MapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  }, MapOperator2;
}(), MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, _this;
  }
  return MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, MapSubscriber2;
}(Subscriber);
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector)
    if (isScheduler(resultSelector))
      scheduler = resultSelector;
    else
      return function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
  return function() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    var context = this, subject, params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (scheduler) {
        var state2 = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch$6, 0, state2);
      } else {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            for (var innerArgs = [], _i2 = 0; _i2 < arguments.length; _i2++)
              innerArgs[_i2] = arguments[_i2];
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs), subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            canReportError(subject) ? subject.error(err) : console.warn(err);
          }
        }
        return subject.subscribe(subscriber);
      }
    });
  };
}
function dispatch$6(state2) {
  var _this = this, args = state2.args, subscriber = state2.subscriber, params = state2.params, callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler, subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      for (var innerArgs = [], _i = 0; _i < arguments.length; _i++)
        innerArgs[_i] = arguments[_i];
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext$3, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$3(state2) {
  var value = state2.value, subject = state2.subject;
  subject.next(value), subject.complete();
}
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector)
    if (isScheduler(resultSelector))
      scheduler = resultSelector;
    else
      return function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
  return function() {
    for (var args = [], _i = 0; _i < arguments.length; _i++)
      args[_i] = arguments[_i];
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context, subject = params.subject;
      if (scheduler)
        return scheduler.schedule(dispatch$5, 0, { params, subscriber, context });
      if (!subject) {
        subject = params.subject = new AsyncSubject();
        var handler = function() {
          for (var innerArgs = [], _i2 = 0; _i2 < arguments.length; _i2++)
            innerArgs[_i2] = arguments[_i2];
          var err = innerArgs.shift();
          if (err) {
            subject.error(err);
            return;
          }
          subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs), subject.complete();
        };
        try {
          callbackFunc.apply(context, args.concat([handler]));
        } catch (err) {
          canReportError(subject) ? subject.error(err) : console.warn(err);
        }
      }
      return subject.subscribe(subscriber);
    });
  };
}
function dispatch$5(state2) {
  var _this = this, params = state2.params, subscriber = state2.subscriber, context = state2.context, callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler, subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      for (var innerArgs = [], _i = 0; _i < arguments.length; _i++)
        innerArgs[_i] = arguments[_i];
      var err = innerArgs.shift();
      if (err)
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext$2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value), subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  }, OuterSubscriber2.prototype.notifyError = function(error2, innerSub) {
    this.destination.error(error2);
  }, OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  }, OuterSubscriber2;
}(Subscriber), InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, _this.index = 0, _this;
  }
  return InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  }, InnerSubscriber2.prototype._error = function(error2) {
    this.parent.notifyError(error2, this), this.unsubscribe();
  }, InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, InnerSubscriber2;
}(Subscriber), subscribeToPromise = function(promise2) {
  return function(subscriber) {
    return promise2.then(function(value) {
      subscriber.closed || (subscriber.next(value), subscriber.complete());
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError), subscriber;
  };
};
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$1 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$1.next();
      } catch (err) {
        return subscriber.error(err), subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      if (subscriber.next(item.value), subscriber.closed)
        break;
    } while (!0);
    return typeof iterator$1.return == "function" && subscriber.add(function() {
      iterator$1.return && iterator$1.return();
    }), subscriber;
  };
}, subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return obs.subscribe(subscriber);
  };
}, isArrayLike = function(x) {
  return x && typeof x.length == "number" && typeof x != "function";
};
function isPromise$1(value) {
  return !!value && typeof value.subscribe != "function" && typeof value.then == "function";
}
var subscribeTo = function(result) {
  if (result && typeof result[observable] == "function")
    return subscribeToObservable(result);
  if (isArrayLike(result))
    return subscribeToArray(result);
  if (isPromise$1(result))
    return subscribeToPromise(result);
  if (result && typeof result[iterator] == "function")
    return subscribeToIterable(result);
  var value = isObject(result) ? "an invalid object" : "'" + result + "'", msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(msg);
};
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0 && (innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex)), !innerSubscriber.closed)
    return result instanceof Observable ? result.subscribe(innerSubscriber) : subscribeTo(result)(innerSubscriber);
}
var NONE = {};
function combineLatest$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var resultSelector = void 0, scheduler = void 0;
  return isScheduler(observables[observables.length - 1]) && (scheduler = observables.pop()), typeof observables[observables.length - 1] == "function" && (resultSelector = observables.pop()), observables.length === 1 && isArray(observables[0]) && (observables = observables[0]), fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  return CombineLatestOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  }, CombineLatestOperator2;
}(), CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], _this.observables = [], _this;
  }
  return CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE), this.observables.push(observable2);
  }, CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables, len = observables.length;
    if (len === 0)
      this.destination.complete();
    else {
      this.active = len, this.toRespond = len;
      for (var i2 = 0; i2 < len; i2++) {
        var observable2 = observables[i2];
        this.add(subscribeToResult(this, observable2, void 0, i2));
      }
    }
  }, CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values = this.values, oldVal = values[outerIndex], toRespond = this.toRespond ? oldVal === NONE ? --this.toRespond : this.toRespond : 0;
    values[outerIndex] = innerValue, toRespond === 0 && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
  }, CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, CombineLatestSubscriber2;
}(OuterSubscriber);
function scheduleObservable(input2, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    return sub.add(scheduler.schedule(function() {
      var observable$1 = input2[observable]();
      sub.add(observable$1.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    })), sub;
  });
}
function schedulePromise(input2, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    return sub.add(scheduler.schedule(function() {
      return input2.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value), sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    })), sub;
  });
}
function scheduleIterable(input2, scheduler) {
  if (!input2)
    throw new Error("Iterable cannot be null");
  return new Observable(function(subscriber) {
    var sub = new Subscription(), iterator$1;
    return sub.add(function() {
      iterator$1 && typeof iterator$1.return == "function" && iterator$1.return();
    }), sub.add(scheduler.schedule(function() {
      iterator$1 = input2[iterator](), sub.add(scheduler.schedule(function() {
        if (!subscriber.closed) {
          var value, done;
          try {
            var result = iterator$1.next();
            value = result.value, done = result.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          done ? subscriber.complete() : (subscriber.next(value), this.schedule());
        }
      }));
    })), sub;
  });
}
function isInteropObservable(input2) {
  return input2 && typeof input2[observable] == "function";
}
function isIterable(input2) {
  return input2 && typeof input2[iterator] == "function";
}
function scheduled(input2, scheduler) {
  if (input2 != null) {
    if (isInteropObservable(input2))
      return scheduleObservable(input2, scheduler);
    if (isPromise$1(input2))
      return schedulePromise(input2, scheduler);
    if (isArrayLike(input2))
      return scheduleArray(input2, scheduler);
    if (isIterable(input2) || typeof input2 == "string")
      return scheduleIterable(input2, scheduler);
  }
  throw new TypeError((input2 !== null && typeof input2 || input2) + " is not observable");
}
function from$2(input2, scheduler) {
  return scheduler ? scheduled(input2, scheduler) : input2 instanceof Observable ? input2 : new Observable(subscribeTo(input2));
}
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, _this;
  }
  return SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  }, SimpleInnerSubscriber2.prototype._error = function(error2) {
    this.parent.notifyError(error2), this.unsubscribe();
  }, SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, SimpleInnerSubscriber2;
}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  }, SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  }, SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (!innerSubscriber.closed) {
    if (result instanceof Observable)
      return result.subscribe(innerSubscriber);
    var subscription;
    try {
      subscription = subscribeTo(result)(innerSubscriber);
    } catch (error2) {
      innerSubscriber.error(error2);
    }
    return subscription;
  }
}
function mergeMap(project, resultSelector, concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), typeof resultSelector == "function" ? function(source2) {
    return source2.pipe(mergeMap(function(a, i2) {
      return from$2(project(a, i2)).pipe(map(function(b, ii) {
        return resultSelector(a, b, i2, ii);
      }));
    }, concurrent));
  } : (typeof resultSelector == "number" && (concurrent = resultSelector), function(source2) {
    return source2.lift(new MergeMapOperator(project, concurrent));
  });
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), this.project = project, this.concurrent = concurrent;
  }
  return MergeMapOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  }, MergeMapOperator2;
}(), MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY);
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, _this.buffer = [], _this.active = 0, _this.index = 0, _this;
  }
  return MergeMapSubscriber2.prototype._next = function(value) {
    this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
  }, MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result, index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++, this._innerSub(result);
  }, MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    innerSubscription !== innerSubscriber && destination.add(innerSubscription);
  }, MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--, buffer2.length > 0 ? this._next(buffer2.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, MergeMapSubscriber2;
}(SimpleOuterSubscriber), flatMap = mergeMap;
function mergeAll(concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return concatAll()(of$2.apply(void 0, observables));
}
function defer$1(observableFactory) {
  return new Observable(function(subscriber) {
    var input2;
    try {
      input2 = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return;
    }
    var source2 = input2 ? from$2(input2) : empty$1();
    return source2.subscribe(subscriber);
  });
}
function forkJoin() {
  for (var sources = [], _i = 0; _i < arguments.length; _i++)
    sources[_i] = arguments[_i];
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1))
      return forkJoinInternal(first_1, null);
    if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function(key2) {
        return first_1[key2];
      }), keys);
    }
  }
  if (typeof sources[sources.length - 1] == "function") {
    var resultSelector_1 = sources.pop();
    return sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources, forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    for (var values = new Array(len), completed = 0, emitted = 0, _loop_1 = function(i3) {
      var source2 = from$2(sources[i3]), hasValue = !1;
      subscriber.add(source2.subscribe({
        next: function(value) {
          hasValue || (hasValue = !0, emitted++), values[i3] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++, (completed === len || !hasValue) && (emitted === len && subscriber.next(keys ? keys.reduce(function(result, key2, i4) {
            return result[key2] = values[i4], result;
          }, {}) : values), subscriber.complete());
        }
      }));
    }, i2 = 0; i2 < len; i2++)
      _loop_1(i2);
  });
}
function fromEvent(target, eventName, options2, resultSelector) {
  return isFunction(options2) && (resultSelector = options2, options2 = void 0), resultSelector ? fromEvent(target, eventName, options2).pipe(map(function(args) {
    return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
  })) : new Observable(function(subscriber) {
    function handler(e) {
      arguments.length > 1 ? subscriber.next(Array.prototype.slice.call(arguments)) : subscriber.next(e);
    }
    setupSubscription(target, eventName, handler, subscriber, options2);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options2) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options2), unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options2);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler), unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler), unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length)
    for (var i2 = 0, len = sourceObj.length; i2 < len; i2++)
      setupSubscription(sourceObj[i2], eventName, handler, subscriber, options2);
  else
    throw new TypeError("Invalid event target");
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener == "function" && typeof sourceObj.removeListener == "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on == "function" && typeof sourceObj.off == "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener == "function" && typeof sourceObj.removeEventListener == "function";
}
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  return resultSelector ? fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
    return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
  })) : new Observable(function(subscriber) {
    var handler = function() {
      for (var e = [], _i = 0; _i < arguments.length; _i++)
        e[_i] = arguments[_i];
      return subscriber.next(e.length === 1 ? e[0] : e);
    }, retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return;
    }
    if (isFunction(removeHandler))
      return function() {
        return removeHandler(handler, retValue);
      };
  });
}
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector, initialState;
  if (arguments.length == 1) {
    var options2 = initialStateOrOptions;
    initialState = options2.initialState, condition = options2.condition, iterate = options2.iterate, resultSelector = options2.resultSelector || identity, scheduler = options2.scheduler;
  } else resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable) ? (initialState = initialStateOrOptions, resultSelector = identity, scheduler = resultSelectorOrObservable) : (initialState = initialStateOrOptions, resultSelector = resultSelectorOrObservable);
  return new Observable(function(subscriber) {
    var state2 = initialState;
    if (scheduler)
      return scheduler.schedule(dispatch$4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state: state2
      });
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state2);
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state2);
      } catch (err) {
        subscriber.error(err);
        return;
      }
      if (subscriber.next(value), subscriber.closed)
        break;
      try {
        state2 = iterate(state2);
      } catch (err) {
        subscriber.error(err);
        return;
      }
    } while (!0);
  });
}
function dispatch$4(state2) {
  var subscriber = state2.subscriber, condition = state2.condition;
  if (!subscriber.closed) {
    if (state2.needIterate)
      try {
        state2.state = state2.iterate(state2.state);
      } catch (err) {
        subscriber.error(err);
        return;
      }
    else
      state2.needIterate = !0;
    if (condition) {
      var conditionResult = void 0;
      try {
        conditionResult = condition(state2.state);
      } catch (err) {
        subscriber.error(err);
        return;
      }
      if (!conditionResult) {
        subscriber.complete();
        return;
      }
      if (subscriber.closed)
        return;
    }
    var value;
    try {
      value = state2.resultSelector(state2.state);
    } catch (err) {
      subscriber.error(err);
      return;
    }
    if (!subscriber.closed && (subscriber.next(value), !subscriber.closed))
      return this.schedule(state2);
  }
}
function iif(condition, trueResult, falseResult) {
  return trueResult === void 0 && (trueResult = EMPTY), falseResult === void 0 && (falseResult = EMPTY), defer$1(function() {
    return condition() ? trueResult : falseResult;
  });
}
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
function interval(period, scheduler) {
  return period === void 0 && (period = 0), scheduler === void 0 && (scheduler = async), (!isNumeric(period) || period < 0) && (period = 0), (!scheduler || typeof scheduler.schedule != "function") && (scheduler = async), new Observable(function(subscriber) {
    return subscriber.add(scheduler.schedule(dispatch$3, period, { subscriber, counter: 0, period })), subscriber;
  });
}
function dispatch$3(state2) {
  var subscriber = state2.subscriber, counter = state2.counter, period = state2.period;
  subscriber.next(counter), this.schedule({ subscriber, counter: counter + 1, period }, period);
}
function merge$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var concurrent = Number.POSITIVE_INFINITY, scheduler = null, last2 = observables[observables.length - 1];
  return isScheduler(last2) ? (scheduler = observables.pop(), observables.length > 1 && typeof observables[observables.length - 1] == "number" && (concurrent = observables.pop())) : typeof last2 == "number" && (concurrent = observables.pop()), scheduler === null && observables.length === 1 && observables[0] instanceof Observable ? observables[0] : mergeAll(concurrent)(fromArray(observables, scheduler));
}
var NEVER = /* @__PURE__ */ new Observable(noop);
function never() {
  return NEVER;
}
function onErrorResumeNext$1() {
  for (var sources = [], _i = 0; _i < arguments.length; _i++)
    sources[_i] = arguments[_i];
  if (sources.length === 0)
    return EMPTY;
  var first2 = sources[0], remainder = sources.slice(1);
  return sources.length === 1 && isArray(first2) ? onErrorResumeNext$1.apply(void 0, first2) : new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext$1.apply(void 0, remainder).subscribe(subscriber));
    };
    return from$2(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
function pairs(obj, scheduler) {
  return scheduler ? new Observable(function(subscriber) {
    var keys = Object.keys(obj), subscription = new Subscription();
    return subscription.add(scheduler.schedule(dispatch$2, 0, { keys, index: 0, subscriber, subscription, obj })), subscription;
  }) : new Observable(function(subscriber) {
    for (var keys = Object.keys(obj), i2 = 0; i2 < keys.length && !subscriber.closed; i2++) {
      var key2 = keys[i2];
      obj.hasOwnProperty(key2) && subscriber.next([key2, obj[key2]]);
    }
    subscriber.complete();
  });
}
function dispatch$2(state2) {
  var keys = state2.keys, index = state2.index, subscriber = state2.subscriber, subscription = state2.subscription, obj = state2.obj;
  if (!subscriber.closed)
    if (index < keys.length) {
      var key2 = keys[index];
      subscriber.next([key2, obj[key2]]), subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));
    } else
      subscriber.complete();
}
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  return notPred.pred = pred, notPred.thisArg = thisArg, notPred;
}
function filter$1(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate, this.thisArg = thisArg;
  }
  return FilterOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  }, FilterOperator2;
}(), FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this;
  }
  return FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    result && this.destination.next(value);
  }, FilterSubscriber2;
}(Subscriber);
function partition$1(source2, predicate, thisArg) {
  return [
    filter$1(predicate, thisArg)(new Observable(subscribeTo(source2))),
    filter$1(not(predicate, thisArg))(new Observable(subscribeTo(source2)))
  ];
}
function race$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  if (observables.length === 1)
    if (isArray(observables[0]))
      observables = observables[0];
    else
      return observables[0];
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  return RaceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RaceSubscriber(subscriber));
  }, RaceOperator2;
}(), RaceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.hasFirst = !1, _this.observables = [], _this.subscriptions = [], _this;
  }
  return RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  }, RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables, len = observables.length;
    if (len === 0)
      this.destination.complete();
    else {
      for (var i2 = 0; i2 < len && !this.hasFirst; i2++) {
        var observable2 = observables[i2], subscription = subscribeToResult(this, observable2, void 0, i2);
        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
      }
      this.observables = null;
    }
  }, RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var i2 = 0; i2 < this.subscriptions.length; i2++)
        if (i2 !== outerIndex) {
          var subscription = this.subscriptions[i2];
          subscription.unsubscribe(), this.remove(subscription);
        }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  }, RaceSubscriber2;
}(OuterSubscriber);
function range(start, count2, scheduler) {
  return start === void 0 && (start = 0), new Observable(function(subscriber) {
    count2 === void 0 && (count2 = start, start = 0);
    var index = 0, current = start;
    if (scheduler)
      return scheduler.schedule(dispatch$1, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    do {
      if (index++ >= count2) {
        subscriber.complete();
        break;
      }
      if (subscriber.next(current++), subscriber.closed)
        break;
    } while (!0);
  });
}
function dispatch$1(state2) {
  var start = state2.start, index = state2.index, count2 = state2.count, subscriber = state2.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start), !subscriber.closed && (state2.index = index + 1, state2.start = start + 1, this.schedule(state2));
}
function timer(dueTime, periodOrScheduler, scheduler) {
  dueTime === void 0 && (dueTime = 0);
  var period = -1;
  return isNumeric(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler) : isScheduler(periodOrScheduler) && (scheduler = periodOrScheduler), isScheduler(scheduler) || (scheduler = async), new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state2) {
  var index = state2.index, period = state2.period, subscriber = state2.subscriber;
  if (subscriber.next(index), !subscriber.closed) {
    if (period === -1)
      return subscriber.complete();
    state2.index = index + 1, this.schedule(state2, period);
  }
}
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return;
    }
    var source2 = result ? from$2(result) : EMPTY, subscription = source2.subscribe(subscriber);
    return function() {
      subscription.unsubscribe(), resource && resource.unsubscribe();
    };
  });
}
function zip$1() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var resultSelector = observables[observables.length - 1];
  return typeof resultSelector == "function" && observables.pop(), fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  return ZipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  }, ZipOperator2;
}(), ZipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values) {
    var _this = _super.call(this, destination) || this;
    return _this.resultSelector = resultSelector, _this.iterators = [], _this.active = 0, _this.resultSelector = typeof resultSelector == "function" ? resultSelector : void 0, _this;
  }
  return ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    isArray(value) ? iterators.push(new StaticArrayIterator(value)) : typeof value[iterator] == "function" ? iterators.push(new StaticIterator(value[iterator]())) : iterators.push(new ZipBufferIterator(this.destination, this, value));
  }, ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators, len = iterators.length;
    if (this.unsubscribe(), len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else
        this.active--;
    }
  }, ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, ZipSubscriber2.prototype.checkIterators = function() {
    for (var iterators = this.iterators, len = iterators.length, destination = this.destination, i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (typeof iterator2.hasValue == "function" && !iterator2.hasValue())
        return;
    }
    for (var shouldComplete = !1, args = [], i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2], result = iterator2.next();
      if (iterator2.hasCompleted() && (shouldComplete = !0), result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    this.resultSelector ? this._tryresultSelector(args) : destination.next(args), shouldComplete && destination.complete();
  }, ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, ZipSubscriber2;
}(Subscriber), StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2, this.nextResult = iterator2.next();
  }
  return StaticIterator2.prototype.hasValue = function() {
    return !0;
  }, StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    return this.nextResult = this.iterator.next(), result;
  }, StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return !!(nextResult && nextResult.done);
  }, StaticIterator2;
}(), StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array2) {
    this.array = array2, this.index = 0, this.length = 0, this.length = array2.length;
  }
  return StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  }, StaticArrayIterator2.prototype.next = function(value) {
    var i2 = this.index++, array2 = this.array;
    return i2 < this.length ? { value: array2[i2], done: !1 } : { value: null, done: !0 };
  }, StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, StaticArrayIterator2;
}(), ZipBufferIterator = /* @__PURE__ */ function(_super) {
  __extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent, observable2) {
    var _this = _super.call(this, destination) || this;
    return _this.parent = parent, _this.observable = observable2, _this.stillUnsubscribed = !0, _this.buffer = [], _this.isComplete = !1, _this;
  }
  return ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  }, ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    return buffer2.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: buffer2.shift(), done: !1 };
  }, ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, ZipBufferIterator2.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue), this.parent.checkIterators();
  }, ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  }, ZipBufferIterator2;
}(SimpleOuterSubscriber), _esm5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArgumentOutOfRangeError,
  AsyncSubject,
  BehaviorSubject,
  ConnectableObservable,
  EMPTY,
  EmptyError,
  GroupedObservable,
  NEVER,
  Notification,
  get NotificationKind() {
    return NotificationKind;
  },
  ObjectUnsubscribedError,
  Observable,
  ReplaySubject,
  Scheduler,
  Subject,
  Subscriber,
  Subscription,
  TimeoutError: TimeoutError$1,
  UnsubscriptionError,
  VirtualAction,
  VirtualTimeScheduler,
  animationFrame,
  animationFrameScheduler,
  asap,
  asapScheduler,
  async,
  asyncScheduler,
  bindCallback,
  bindNodeCallback,
  combineLatest: combineLatest$1,
  concat: concat$1,
  config,
  defer: defer$1,
  empty: empty$1,
  forkJoin,
  from: from$2,
  fromEvent,
  fromEventPattern,
  generate,
  identity,
  iif,
  interval,
  isObservable,
  merge: merge$1,
  never,
  noop,
  observable,
  of: of$2,
  onErrorResumeNext: onErrorResumeNext$1,
  pairs,
  partition: partition$1,
  pipe,
  queue,
  queueScheduler,
  race: race$1,
  range,
  scheduled,
  throwError,
  timer,
  using,
  zip: zip$1
}), require$$4$1 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(_esm5);
function audit(durationSelector) {
  return function(source2) {
    return source2.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  return AuditOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  }, AuditOperator2;
}(), AuditSubscriber = /* @__PURE__ */ function(_super) {
  __extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.durationSelector = durationSelector, _this.hasValue = !1, _this;
  }
  return AuditSubscriber2.prototype._next = function(value) {
    if (this.value = value, this.hasValue = !0, !this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      !innerSubscription || innerSubscription.closed ? this.clearThrottle() : this.add(this.throttled = innerSubscription);
    }
  }, AuditSubscriber2.prototype.clearThrottle = function() {
    var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
    throttled && (this.remove(throttled), this.throttled = void 0, throttled.unsubscribe()), hasValue && (this.value = void 0, this.hasValue = !1, this.destination.next(value));
  }, AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  }, AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, AuditSubscriber2;
}(SimpleOuterSubscriber);
function auditTime(duration, scheduler) {
  return scheduler === void 0 && (scheduler = async), audit(function() {
    return timer(duration, scheduler);
  });
}
function buffer(closingNotifier) {
  return function(source2) {
    return source2.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  return BufferOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  }, BufferOperator2;
}(), BufferSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    return _this.buffer = [], _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this))), _this;
  }
  return BufferSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  }, BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [], this.destination.next(buffer2);
  }, BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  return startBufferEvery === void 0 && (startBufferEvery = null), function(source2) {
    return source2.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize, this.startBufferEvery = startBufferEvery, !startBufferEvery || bufferSize === startBufferEvery ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;
  }
  return BufferCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  }, BufferCountOperator2;
}(), BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    return _this.bufferSize = bufferSize, _this.buffer = [], _this;
  }
  return BufferCountSubscriber2.prototype._next = function(value) {
    var buffer2 = this.buffer;
    buffer2.push(value), buffer2.length == this.bufferSize && (this.destination.next(buffer2), this.buffer = []);
  }, BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    buffer2.length > 0 && this.destination.next(buffer2), _super.prototype._complete.call(this);
  }, BufferCountSubscriber2;
}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    return _this.bufferSize = bufferSize, _this.startBufferEvery = startBufferEvery, _this.buffers = [], _this.count = 0, _this;
  }
  return BufferSkipCountSubscriber2.prototype._next = function(value) {
    var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count2 = _a.count;
    this.count++, count2 % startBufferEvery === 0 && buffers.push([]);
    for (var i2 = buffers.length; i2--; ) {
      var buffer2 = buffers[i2];
      buffer2.push(value), buffer2.length === bufferSize && (buffers.splice(i2, 1), this.destination.next(buffer2));
    }
  }, BufferSkipCountSubscriber2.prototype._complete = function() {
    for (var _a = this, buffers = _a.buffers, destination = _a.destination; buffers.length > 0; ) {
      var buffer2 = buffers.shift();
      buffer2.length > 0 && destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  }, BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length = arguments.length, scheduler = async;
  isScheduler(arguments[arguments.length - 1]) && (scheduler = arguments[arguments.length - 1], length--);
  var bufferCreationInterval = null;
  length >= 2 && (bufferCreationInterval = arguments[1]);
  var maxBufferSize = Number.POSITIVE_INFINITY;
  return length >= 3 && (maxBufferSize = arguments[2]), function(source2) {
    return source2.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    this.bufferTimeSpan = bufferTimeSpan, this.bufferCreationInterval = bufferCreationInterval, this.maxBufferSize = maxBufferSize, this.scheduler = scheduler;
  }
  return BufferTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, BufferTimeOperator2;
}(), Context = /* @__PURE__ */ function() {
  function Context2() {
    this.buffer = [];
  }
  return Context2;
}(), BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan, _this.bufferCreationInterval = bufferCreationInterval, _this.maxBufferSize = maxBufferSize, _this.scheduler = scheduler, _this.contexts = [];
    var context = _this.openContext();
    if (_this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0, _this.timespanOnly) {
      var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = { subscriber: _this, context }, creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState)), _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  return BufferTimeSubscriber2.prototype._next = function(value) {
    for (var contexts = this.contexts, len = contexts.length, filledBufferContext, i2 = 0; i2 < len; i2++) {
      var context_1 = contexts[i2], buffer2 = context_1.buffer;
      buffer2.push(value), buffer2.length == this.maxBufferSize && (filledBufferContext = context_1);
    }
    filledBufferContext && this.onBufferFull(filledBufferContext);
  }, BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0, _super.prototype._error.call(this, err);
  }, BufferTimeSubscriber2.prototype._complete = function() {
    for (var _a = this, contexts = _a.contexts, destination = _a.destination; contexts.length > 0; ) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  }, BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  }, BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
    this.closeContext(context);
    var closeAction = context.closeAction;
    if (closeAction.unsubscribe(), this.remove(closeAction), !this.closed && this.timespanOnly) {
      context = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan, timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  }, BufferTimeSubscriber2.prototype.openContext = function() {
    var context = new Context();
    return this.contexts.push(context), context;
  }, BufferTimeSubscriber2.prototype.closeContext = function(context) {
    this.destination.next(context.buffer);
    var contexts = this.contexts, spliceIndex = contexts ? contexts.indexOf(context) : -1;
    spliceIndex >= 0 && contexts.splice(contexts.indexOf(context), 1);
  }, BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state2) {
  var subscriber = state2.subscriber, prevContext = state2.context;
  prevContext && subscriber.closeContext(prevContext), subscriber.closed || (state2.context = subscriber.openContext(), state2.context.closeAction = this.schedule(state2, state2.bufferTimeSpan));
}
function dispatchBufferCreation(state2) {
  var bufferCreationInterval = state2.bufferCreationInterval, bufferTimeSpan = state2.bufferTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler, context = subscriber.openContext(), action = this;
  subscriber.closed || (subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context })), action.schedule(state2, bufferCreationInterval));
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
function bufferToggle(openings, closingSelector) {
  return function(source2) {
    return source2.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings, this.closingSelector = closingSelector;
  }
  return BufferToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  }, BufferToggleOperator2;
}(), BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.closingSelector = closingSelector, _this.contexts = [], _this.add(subscribeToResult(_this, openings)), _this;
  }
  return BufferToggleSubscriber2.prototype._next = function(value) {
    for (var contexts = this.contexts, len = contexts.length, i2 = 0; i2 < len; i2++)
      contexts[i2].buffer.push(value);
  }, BufferToggleSubscriber2.prototype._error = function(err) {
    for (var contexts = this.contexts; contexts.length > 0; ) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe(), context_1.buffer = null, context_1.subscription = null;
    }
    this.contexts = null, _super.prototype._error.call(this, err);
  }, BufferToggleSubscriber2.prototype._complete = function() {
    for (var contexts = this.contexts; contexts.length > 0; ) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer), context_2.subscription.unsubscribe(), context_2.buffer = null, context_2.subscription = null;
    }
    this.contexts = null, _super.prototype._complete.call(this);
  }, BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  }, BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  }, BufferToggleSubscriber2.prototype.openBuffer = function(value) {
    try {
      var closingSelector = this.closingSelector, closingNotifier = closingSelector.call(this, value);
      closingNotifier && this.trySubscribe(closingNotifier);
    } catch (err) {
      this._error(err);
    }
  }, BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
    var contexts = this.contexts;
    if (contexts && context) {
      var buffer2 = context.buffer, subscription = context.subscription;
      this.destination.next(buffer2), contexts.splice(contexts.indexOf(context), 1), this.remove(subscription), subscription.unsubscribe();
    }
  }, BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts, buffer2 = [], subscription = new Subscription(), context = { buffer: buffer2, subscription };
    contexts.push(context);
    var innerSubscription = subscribeToResult(this, closingNotifier, context);
    !innerSubscription || innerSubscription.closed ? this.closeBuffer(context) : (innerSubscription.context = context, this.add(innerSubscription), subscription.add(innerSubscription));
  }, BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source2) {
    return source2.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  return BufferWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  }, BufferWhenOperator2;
}(), BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.closingSelector = closingSelector, _this.subscribing = !1, _this.openBuffer(), _this;
  }
  return BufferWhenSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  }, BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    buffer2 && this.destination.next(buffer2), _super.prototype._complete.call(this);
  }, BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  }, BufferWhenSubscriber2.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    closingSubscription && (this.remove(closingSubscription), closingSubscription.unsubscribe());
    var buffer2 = this.buffer;
    this.buffer && this.destination.next(buffer2), this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription(), this.closingSubscription = closingSubscription, this.add(closingSubscription), this.subscribing = !0, closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this))), this.subscribing = !1;
  }, BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function(source2) {
    var operator = new CatchOperator(selector), caught = source2.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  return CatchOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  }, CatchOperator2;
}(), CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    return _this.selector = selector, _this.caught = caught, _this;
  }
  return CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      innerSubscription !== innerSubscriber && this.add(innerSubscription);
    }
  }, CatchSubscriber2;
}(SimpleOuterSubscriber);
function combineAll(project) {
  return function(source2) {
    return source2.lift(new CombineLatestOperator(project));
  };
}
function combineLatest() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  var project = null;
  return typeof observables[observables.length - 1] == "function" && (project = observables.pop()), observables.length === 1 && isArray(observables[0]) && (observables = observables[0].slice()), function(source2) {
    return source2.lift.call(from$2([source2].concat(observables)), new CombineLatestOperator(project));
  };
}
function concat() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return source2.lift.call(concat$1.apply(void 0, [source2].concat(observables)));
  };
}
function concatMap$1(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap$1(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source2) {
    return source2.lift(new CountOperator(predicate, source2));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source2) {
    this.predicate = predicate, this.source = source2;
  }
  return CountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  }, CountOperator2;
}(), CountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.source = source2, _this.count = 0, _this.index = 0, _this;
  }
  return CountSubscriber2.prototype._next = function(value) {
    this.predicate ? this._tryPredicate(value) : this.count++;
  }, CountSubscriber2.prototype._tryPredicate = function(value) {
    var result;
    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    result && this.count++;
  }, CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source2) {
    return source2.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  return DebounceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  }, DebounceOperator2;
}(), DebounceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.durationSelector = durationSelector, _this.hasValue = !1, _this;
  }
  return DebounceSubscriber2.prototype._next = function(value) {
    try {
      var result = this.durationSelector.call(this, value);
      result && this._tryNext(value, result);
    } catch (err) {
      this.destination.error(err);
    }
  }, DebounceSubscriber2.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, DebounceSubscriber2.prototype._tryNext = function(value, duration) {
    var subscription = this.durationSubscription;
    this.value = value, this.hasValue = !0, subscription && (subscription.unsubscribe(), this.remove(subscription)), subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this)), subscription && !subscription.closed && this.add(this.durationSubscription = subscription);
  }, DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  }, DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  }, DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value = this.value, subscription = this.durationSubscription;
      subscription && (this.durationSubscription = void 0, subscription.unsubscribe(), this.remove(subscription)), this.value = void 0, this.hasValue = !1, _super.prototype._next.call(this, value);
    }
  }, DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    return source2.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler) {
    this.dueTime = dueTime, this.scheduler = scheduler;
  }
  return DebounceTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  }, DebounceTimeOperator2;
}(), DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.dueTime = dueTime, _this.scheduler = scheduler, _this.debouncedSubscription = null, _this.lastValue = null, _this.hasValue = !1, _this;
  }
  return DebounceTimeSubscriber2.prototype._next = function(value) {
    this.clearDebounce(), this.lastValue = value, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  }, DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(lastValue);
    }
  }, DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    debouncedSubscription !== null && (this.remove(debouncedSubscription), debouncedSubscription.unsubscribe(), this.debouncedSubscription = null);
  }, DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  return defaultValue === void 0 && (defaultValue = null), function(source2) {
    return source2.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  return DefaultIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  }, DefaultIfEmptyOperator2;
}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    return _this.defaultValue = defaultValue, _this.isEmpty = !0, _this;
  }
  return DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = !1, this.destination.next(value);
  }, DefaultIfEmptySubscriber2.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
function delay(delay2, scheduler) {
  scheduler === void 0 && (scheduler = async);
  var absoluteDelay = isDate(delay2), delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source2) {
    return source2.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler) {
    this.delay = delay2, this.scheduler = scheduler;
  }
  return DelayOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  }, DelayOperator2;
}(), DelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.delay = delay2, _this.scheduler = scheduler, _this.queue = [], _this.active = !1, _this.errored = !1, _this;
  }
  return DelaySubscriber2.dispatch = function(state2) {
    for (var source2 = state2.source, queue2 = source2.queue, scheduler = state2.scheduler, destination = state2.destination; queue2.length > 0 && queue2[0].time - scheduler.now() <= 0; )
      queue2.shift().notification.observe(destination);
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
      this.schedule(state2, delay_1);
    } else
      this.unsubscribe(), source2.active = !1;
  }, DelaySubscriber2.prototype._schedule = function(scheduler) {
    this.active = !0;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler
    }));
  }, DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored !== !0) {
      var scheduler = this.scheduler, message = new DelayMessage(scheduler.now() + this.delay, notification);
      this.queue.push(message), this.active === !1 && this._schedule(scheduler);
    }
  }, DelaySubscriber2.prototype._next = function(value) {
    this.scheduleNotification(Notification.createNext(value));
  }, DelaySubscriber2.prototype._error = function(err) {
    this.errored = !0, this.queue = [], this.destination.error(err), this.unsubscribe();
  }, DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
  }, DelaySubscriber2;
}(Subscriber), DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time, notification) {
    this.time = time, this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  return subscriptionDelay ? function(source2) {
    return new SubscriptionDelayObservable(source2, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
  } : function(source2) {
    return source2.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  return DelayWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  }, DelayWhenOperator2;
}(), DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.delayDurationSelector = delayDurationSelector, _this.completed = !1, _this.delayNotifierSubscriptions = [], _this.index = 0, _this;
  }
  return DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue), this.removeSubscription(innerSub), this.tryComplete();
  }, DelayWhenSubscriber2.prototype.notifyError = function(error2, innerSub) {
    this._error(error2);
  }, DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value = this.removeSubscription(innerSub);
    value && this.destination.next(value), this.tryComplete();
  }, DelayWhenSubscriber2.prototype._next = function(value) {
    var index = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value, index);
      delayNotifier && this.tryDelay(delayNotifier, value);
    } catch (err) {
      this.destination.error(err);
    }
  }, DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    return subscriptionIdx !== -1 && this.delayNotifierSubscriptions.splice(subscriptionIdx, 1), subscription.outerValue;
  }, DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription), this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  }, DelayWhenSubscriber2.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, DelayWhenSubscriber2;
}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source2, subscriptionDelay) {
    var _this = _super.call(this) || this;
    return _this.source = source2, _this.subscriptionDelay = subscriptionDelay, _this;
  }
  return SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  }, SubscriptionDelayObservable2;
}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent, source2) {
    var _this = _super.call(this) || this;
    return _this.parent = parent, _this.source = source2, _this.sourceSubscribed = !1, _this;
  }
  return SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  }, SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe(), this.parent.error(err);
  }, SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function(source2) {
    return source2.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  return DeMaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DeMaterializeSubscriber(subscriber));
  }, DeMaterializeOperator2;
}(), DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  return DeMaterializeSubscriber2.prototype._next = function(value) {
    value.observe(this.destination);
  }, DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source2) {
    return source2.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector, this.flushes = flushes;
  }
  return DistinctOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  }, DistinctOperator2;
}(), DistinctSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    return _this.keySelector = keySelector, _this.values = /* @__PURE__ */ new Set(), flushes && _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this))), _this;
  }
  return DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  }, DistinctSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  }, DistinctSubscriber2.prototype._next = function(value) {
    this.keySelector ? this._useKeySelector(value) : this._finalizeNext(value, value);
  }, DistinctSubscriber2.prototype._useKeySelector = function(value) {
    var key2, destination = this.destination;
    try {
      key2 = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key2, value);
  }, DistinctSubscriber2.prototype._finalizeNext = function(key2, value) {
    var values = this.values;
    values.has(key2) || (values.add(key2), this.destination.next(value));
  }, DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare2, keySelector) {
  return function(source2) {
    return source2.lift(new DistinctUntilChangedOperator(compare2, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare2, keySelector) {
    this.compare = compare2, this.keySelector = keySelector;
  }
  return DistinctUntilChangedOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  }, DistinctUntilChangedOperator2;
}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
    var _this = _super.call(this, destination) || this;
    return _this.keySelector = keySelector, _this.hasKey = !1, typeof compare2 == "function" && (_this.compare = compare2), _this;
  }
  return DistinctUntilChangedSubscriber2.prototype.compare = function(x, y) {
    return x === y;
  }, DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key2;
    try {
      var keySelector = this.keySelector;
      key2 = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = !1;
    if (this.hasKey)
      try {
        var compare2 = this.compare;
        result = compare2(this.key, key2);
      } catch (err) {
        return this.destination.error(err);
      }
    else
      this.hasKey = !0;
    result || (this.key = key2, this.destination.next(value));
  }, DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key2, compare2) {
  return distinctUntilChanged(function(x, y) {
    return compare2 ? compare2(x[key2], y[key2]) : x[key2] === y[key2];
  });
}
function throwIfEmpty(errorFactory) {
  return errorFactory === void 0 && (errorFactory = defaultErrorFactory), function(source2) {
    return source2.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  return ThrowIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  }, ThrowIfEmptyOperator2;
}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    return _this.errorFactory = errorFactory, _this.hasValue = !1, _this;
  }
  return ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = !0, this.destination.next(value);
  }, ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var err = void 0;
    try {
      err = this.errorFactory();
    } catch (e) {
      err = e;
    }
    this.destination.error(err);
  }, ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count2) {
  return function(source2) {
    return count2 === 0 ? empty$1() : source2.lift(new TakeOperator(count2));
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    if (this.total = total, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return TakeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeSubscriber(subscriber, this.total));
  }, TakeOperator2;
}(), TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    return _this.total = total, _this.count = 0, _this;
  }
  return TakeSubscriber2.prototype._next = function(value) {
    var total = this.total, count2 = ++this.count;
    count2 <= total && (this.destination.next(value), count2 === total && (this.destination.complete(), this.unsubscribe()));
  }, TakeSubscriber2;
}(Subscriber);
function elementAt(index, defaultValue) {
  if (index < 0)
    throw new ArgumentOutOfRangeError();
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(filter$1(function(v, i2) {
      return i2 === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  for (var array2 = [], _i = 0; _i < arguments.length; _i++)
    array2[_i] = arguments[_i];
  return function(source2) {
    return concat$1(source2, of$2.apply(void 0, array2));
  };
}
function every(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new EveryOperator(predicate, thisArg, source2));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source2) {
    this.predicate = predicate, this.thisArg = thisArg, this.source = source2;
  }
  return EveryOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  }, EveryOperator2;
}(), EverySubscriber = /* @__PURE__ */ function(_super) {
  __extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.thisArg = thisArg, _this.source = source2, _this.index = 0, _this.thisArg = thisArg || _this, _this;
  }
  return EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch), this.destination.complete();
  }, EverySubscriber2.prototype._next = function(value) {
    var result = !1;
    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    result || this.notifyComplete(!1);
  }, EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(!0);
  }, EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source2) {
    return source2.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  return SwitchFirstOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchFirstSubscriber(subscriber));
  }, SwitchFirstOperator2;
}(), SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.hasCompleted = !1, _this.hasSubscription = !1, _this;
  }
  return SwitchFirstSubscriber2.prototype._next = function(value) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(value, new SimpleInnerSubscriber(this))));
  }, SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  return resultSelector ? function(source2) {
    return source2.pipe(exhaustMap(function(a, i2) {
      return from$2(project(a, i2)).pipe(map(function(b, ii) {
        return resultSelector(a, b, i2, ii);
      }));
    }));
  } : function(source2) {
    return source2.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  return ExhaustMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  }, ExhaustMapOperator2;
}(), ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.hasSubscription = !1, _this.hasCompleted = !1, _this.index = 0, _this;
  }
  return ExhaustMapSubscriber2.prototype._next = function(value) {
    this.hasSubscription || this.tryNext(value);
  }, ExhaustMapSubscriber2.prototype.tryNext = function(value) {
    var result, index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = !0, this._innerSub(result);
  }, ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    innerSubscription !== innerSubscriber && destination.add(innerSubscription);
  }, ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  }, ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand$1(project, concurrent, scheduler) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent, function(source2) {
    return source2.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler) {
    this.project = project, this.concurrent = concurrent, this.scheduler = scheduler;
  }
  return ExpandOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  }, ExpandOperator2;
}(), ExpandSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.concurrent = concurrent, _this.scheduler = scheduler, _this.index = 0, _this.active = 0, _this.hasCompleted = !1, concurrent < Number.POSITIVE_INFINITY && (_this.buffer = []), _this;
  }
  return ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
    subscriber.subscribeToProjection(result, value, index);
  }, ExpandSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value);
      try {
        var project = this.project, result = project(value, index);
        if (!this.scheduler)
          this.subscribeToProjection(result, value, index);
        else {
          var state2 = { subscriber: this, result, value, index }, destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state2));
        }
      } catch (e) {
        destination.error(e);
      }
    } else
      this.buffer.push(value);
  }, ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  }, ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  }, ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--, buffer2 && buffer2.length > 0 && this._next(buffer2.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source2) {
    return source2.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  return FinallyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FinallySubscriber(subscriber, this.callback));
  }, FinallyOperator2;
}(), FinallySubscriber = /* @__PURE__ */ function(_super) {
  __extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    return _this.add(new Subscription(callback)), _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find(predicate, thisArg) {
  if (typeof predicate != "function")
    throw new TypeError("predicate is not a function");
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, !1, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source2, yieldIndex, thisArg) {
    this.predicate = predicate, this.source = source2, this.yieldIndex = yieldIndex, this.thisArg = thisArg;
  }
  return FindValueOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, FindValueOperator2;
}(), FindValueSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source2, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.source = source2, _this.yieldIndex = yieldIndex, _this.thisArg = thisArg, _this.index = 0, _this;
  }
  return FindValueSubscriber2.prototype.notifyComplete = function(value) {
    var destination = this.destination;
    destination.next(value), destination.complete(), this.unsubscribe();
  }, FindValueSubscriber2.prototype._next = function(value) {
    var _a = this, predicate = _a.predicate, thisArg = _a.thisArg, index = this.index++;
    try {
      var result = predicate.call(thisArg || this, value, index, this.source);
      result && this.notifyComplete(this.yieldIndex ? index : value);
    } catch (err) {
      this.destination.error(err);
    }
  }, FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, !0, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter$1(function(v, i2) {
      return predicate(v, i2, source2);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function ignoreElements() {
  return function(source2) {
    return source2.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  return IgnoreElementsOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new IgnoreElementsSubscriber(subscriber));
  }, IgnoreElementsOperator2;
}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  __extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return IgnoreElementsSubscriber2.prototype._next = function(unused) {
  }, IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty() {
  return function(source2) {
    return source2.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  return IsEmptyOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new IsEmptySubscriber(observer));
  }, IsEmptyOperator2;
}(), IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  return IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2), destination.complete();
  }, IsEmptySubscriber2.prototype._next = function(value) {
    this.notifyComplete(!1);
  }, IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(!0);
  }, IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function(source2) {
    return count2 === 0 ? empty$1() : source2.lift(new TakeLastOperator(count2));
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    if (this.total = total, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return TakeLastOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeLastSubscriber(subscriber, this.total));
  }, TakeLastOperator2;
}(), TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    return _this.total = total, _this.ring = new Array(), _this.count = 0, _this;
  }
  return TakeLastSubscriber2.prototype._next = function(value) {
    var ring = this.ring, total = this.total, count2 = this.count++;
    if (ring.length < total)
      ring.push(value);
    else {
      var index = count2 % total;
      ring[index] = value;
    }
  }, TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination, count2 = this.count;
    if (count2 > 0)
      for (var total = this.count >= this.total ? this.total : this.count, ring = this.ring, i2 = 0; i2 < total; i2++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    destination.complete();
  }, TakeLastSubscriber2;
}(Subscriber);
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter$1(function(v, i2) {
      return predicate(v, i2, source2);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value) {
  return function(source2) {
    return source2.lift(new MapToOperator(value));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value) {
    this.value = value;
  }
  return MapToOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapToSubscriber(subscriber, this.value));
  }, MapToOperator2;
}(), MapToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value) {
    var _this = _super.call(this, destination) || this;
    return _this.value = value, _this;
  }
  return MapToSubscriber2.prototype._next = function(x) {
    this.destination.next(this.value);
  }, MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function(source2) {
    return source2.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  return MaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MaterializeSubscriber(subscriber));
  }, MaterializeOperator2;
}(), MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  return MaterializeSubscriber2.prototype._next = function(value) {
    this.destination.next(Notification.createNext(value));
  }, MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err)), destination.complete();
  }, MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete()), destination.complete();
  }, MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = !1;
  return arguments.length >= 2 && (hasSeed = !0), function(source2) {
    return source2.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    hasSeed === void 0 && (hasSeed = !1), this.accumulator = accumulator, this.seed = seed, this.hasSeed = hasSeed;
  }
  return ScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  }, ScanOperator2;
}(), ScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    return _this.accumulator = accumulator, _this._seed = _seed, _this.hasSeed = hasSeed, _this.index = 0, _this;
  }
  return Object.defineProperty(ScanSubscriber2.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(value) {
      this.hasSeed = !0, this._seed = value;
    },
    enumerable: !0,
    configurable: !0
  }), ScanSubscriber2.prototype._next = function(value) {
    if (!this.hasSeed)
      this.seed = value, this.destination.next(value);
    else
      return this._tryNext(value);
  }, ScanSubscriber2.prototype._tryNext = function(value) {
    var index = this.index++, result;
    try {
      result = this.accumulator(this.seed, value, index);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result, this.destination.next(result);
  }, ScanSubscriber2;
}(Subscriber);
function reduce$1(accumulator, seed) {
  return arguments.length >= 2 ? function(source2) {
    return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source2);
  } : function(source2) {
    return pipe(scan(function(acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), takeLast(1))(source2);
  };
}
function max(comparer) {
  var max2 = typeof comparer == "function" ? function(x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function(x, y) {
    return x > y ? x : y;
  };
  return reduce$1(max2);
}
function merge() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return source2.lift.call(merge$1.apply(void 0, [source2].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), typeof resultSelector == "function" ? mergeMap(function() {
    return innerObservable;
  }, resultSelector, concurrent) : (typeof resultSelector == "number" && (concurrent = resultSelector), mergeMap(function() {
    return innerObservable;
  }, concurrent));
}
function mergeScan(accumulator, seed, concurrent) {
  return concurrent === void 0 && (concurrent = Number.POSITIVE_INFINITY), function(source2) {
    return source2.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator, this.seed = seed, this.concurrent = concurrent;
  }
  return MergeScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  }, MergeScanOperator2;
}(), MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    return _this.accumulator = accumulator, _this.acc = acc, _this.concurrent = concurrent, _this.hasValue = !1, _this.hasCompleted = !1, _this.buffer = [], _this.active = 0, _this.index = 0, _this;
  }
  return MergeScanSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      var index = this.index++, destination = this.destination, ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index);
      } catch (e) {
        return destination.error(e);
      }
      this.active++, this._innerSub(ish);
    } else
      this.buffer.push(value);
  }, MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    innerSubscription !== innerSubscriber && destination.add(innerSubscription);
  }, MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue, this.hasValue = !0, destination.next(innerValue);
  }, MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--, buffer2.length > 0 ? this._next(buffer2.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer == "function" ? function(x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function(x, y) {
    return x < y ? x : y;
  };
  return reduce$1(min2);
}
function multicast(subjectOrSubjectFactory, selector) {
  return function(source2) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory == "function" ? subjectFactory = subjectOrSubjectFactory : subjectFactory = function() {
      return subjectOrSubjectFactory;
    }, typeof selector == "function")
      return source2.lift(new MulticastOperator(subjectFactory, selector));
    var connectable = Object.create(source2, connectableObservableDescriptor);
    return connectable.source = source2, connectable.subjectFactory = subjectFactory, connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory, this.selector = selector;
  }
  return MulticastOperator2.prototype.call = function(subscriber, source2) {
    var selector = this.selector, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
    return subscription.add(source2.subscribe(subject)), subscription;
  }, MulticastOperator2;
}();
function onErrorResumeNext() {
  for (var nextSources = [], _i = 0; _i < arguments.length; _i++)
    nextSources[_i] = arguments[_i];
  return nextSources.length === 1 && isArray(nextSources[0]) && (nextSources = nextSources[0]), function(source2) {
    return source2.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  return OnErrorResumeNextOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  }, OnErrorResumeNextOperator2;
}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.nextSources = nextSources, _this;
  }
  return OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next = this.nextSources.shift();
    if (next) {
      var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next, innerSubscriber);
      innerSubscription !== innerSubscriber && destination.add(innerSubscription);
    } else
      this.destination.complete();
  }, OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source2) {
    return source2.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  return PairwiseOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new PairwiseSubscriber(subscriber));
  }, PairwiseOperator2;
}(), PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  __extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.hasPrev = !1, _this;
  }
  return PairwiseSubscriber2.prototype._next = function(value) {
    var pair;
    this.hasPrev ? pair = [this.prev, value] : this.hasPrev = !0, this.prev = value, pair && this.destination.next(pair);
  }, PairwiseSubscriber2;
}(Subscriber);
function partition(predicate, thisArg) {
  return function(source2) {
    return [
      filter$1(predicate, thisArg)(source2),
      filter$1(not(predicate, thisArg))(source2)
    ];
  };
}
function pluck() {
  for (var properties = [], _i = 0; _i < arguments.length; _i++)
    properties[_i] = arguments[_i];
  var length = properties.length;
  if (length === 0)
    throw new Error("list of properties cannot be empty.");
  return function(source2) {
    return map(plucker(properties, length))(source2);
  };
}
function plucker(props, length) {
  var mapper = function(x) {
    for (var currentProp = x, i2 = 0; i2 < length; i2++) {
      var p = currentProp?.[props[i2]];
      if (p !== void 0)
        currentProp = p;
      else
        return;
    }
    return currentProp;
  };
  return mapper;
}
function publish$1(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
function publishBehavior(value) {
  return function(source2) {
    return multicast(new BehaviorSubject(value))(source2);
  };
}
function publishLast() {
  return function(source2) {
    return multicast(new AsyncSubject())(source2);
  };
}
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  selectorOrScheduler && typeof selectorOrScheduler != "function" && (scheduler = selectorOrScheduler);
  var selector = typeof selectorOrScheduler == "function" ? selectorOrScheduler : void 0, subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source2) {
    return multicast(function() {
      return subject;
    }, selector)(source2);
  };
}
function race() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return observables.length === 1 && isArray(observables[0]) && (observables = observables[0]), source2.lift.call(race$1.apply(void 0, [source2].concat(observables)));
  };
}
function repeat(count2) {
  return count2 === void 0 && (count2 = -1), function(source2) {
    return count2 === 0 ? empty$1() : count2 < 0 ? source2.lift(new RepeatOperator(-1, source2)) : source2.lift(new RepeatOperator(count2 - 1, source2));
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source2) {
    this.count = count2, this.source = source2;
  }
  return RepeatOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  }, RepeatOperator2;
}(), RepeatSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.count = count2, _this.source = source2, _this;
  }
  return RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a = this, source2 = _a.source, count2 = _a.count;
      if (count2 === 0)
        return _super.prototype.complete.call(this);
      count2 > -1 && (this.count = count2 - 1), source2.subscribe(this._unsubscribeAndRecycle());
    }
  }, RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source2) {
    return source2.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  return RepeatWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source2));
  }, RepeatWhenOperator2;
}(), RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.notifier = notifier, _this.source = source2, _this.sourceIsBeingSubscribedTo = !0, _this;
  }
  return RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return _super.prototype.complete.call(this);
  }, RepeatWhenSubscriber2.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return _super.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
    notifications && (notifications.unsubscribe(), this.notifications = void 0), retriesSubscription && (retriesSubscription.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    return this._unsubscribe = null, _super.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = _unsubscribe, this;
  }, RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries, this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  }, RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry(count2) {
  return count2 === void 0 && (count2 = -1), function(source2) {
    return source2.lift(new RetryOperator(count2, source2));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source2) {
    this.count = count2, this.source = source2;
  }
  return RetryOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  }, RetryOperator2;
}(), RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.count = count2, _this.source = source2, _this;
  }
  return RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a = this, source2 = _a.source, count2 = _a.count;
      if (count2 === 0)
        return _super.prototype.error.call(this, err);
      count2 > -1 && (this.count = count2 - 1), source2.subscribe(this._unsubscribeAndRecycle());
    }
  }, RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source2) {
    return source2.lift(new RetryWhenOperator(notifier, source2));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source2) {
    this.notifier = notifier, this.source = source2;
  }
  return RetryWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  }, RetryWhenOperator2;
}(), RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.notifier = notifier, _this.source = source2, _this;
  }
  return RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors2 = this.errors, retries = this.retries, retriesSubscription = this.retriesSubscription;
      if (retries)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        errors2 = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors2);
        } catch (e) {
          return _super.prototype.error.call(this, e);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      }
      this._unsubscribeAndRecycle(), this.errors = errors2, this.retries = retries, this.retriesSubscription = retriesSubscription, errors2.next(err);
    }
  }, RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a = this, errors2 = _a.errors, retriesSubscription = _a.retriesSubscription;
    errors2 && (errors2.unsubscribe(), this.errors = void 0), retriesSubscription && (retriesSubscription.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = _unsubscribe, this.source.subscribe(this);
  }, RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample$1(notifier) {
  return function(source2) {
    return source2.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  return SampleOperator2.prototype.call = function(subscriber, source2) {
    var sampleSubscriber = new SampleSubscriber(subscriber), subscription = source2.subscribe(sampleSubscriber);
    return subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber))), subscription;
  }, SampleOperator2;
}(), SampleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    return _this.hasValue = !1, _this;
  }
  return SampleSubscriber2.prototype._next = function(value) {
    this.value = value, this.hasValue = !0;
  }, SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  }, SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  }, SampleSubscriber2.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    return source2.lift(new SampleTimeOperator(period, scheduler));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler) {
    this.period = period, this.scheduler = scheduler;
  }
  return SampleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  }, SampleTimeOperator2;
}(), SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.period = period, _this.scheduler = scheduler, _this.hasValue = !1, _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period })), _this;
  }
  return SampleTimeSubscriber2.prototype._next = function(value) {
    this.lastValue = value, this.hasValue = !0;
  }, SampleTimeSubscriber2.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state2) {
  var subscriber = state2.subscriber, period = state2.period;
  subscriber.notifyNext(), this.schedule(state2, period);
}
function sequenceEqual(compareTo, comparator) {
  return function(source2) {
    return source2.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator) {
    this.compareTo = compareTo, this.comparator = comparator;
  }
  return SequenceEqualOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  }, SequenceEqualOperator2;
}(), SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator) {
    var _this = _super.call(this, destination) || this;
    return _this.compareTo = compareTo, _this.comparator = comparator, _this._a = [], _this._b = [], _this._oneComplete = !1, _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this))), _this;
  }
  return SequenceEqualSubscriber2.prototype._next = function(value) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(value), this.checkValues());
  }, SequenceEqualSubscriber2.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, SequenceEqualSubscriber2.prototype.checkValues = function() {
    for (var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator; _a.length > 0 && _b.length > 0; ) {
      var a = _a.shift(), b = _b.shift(), areEqual = !1;
      try {
        areEqual = comparator ? comparator(a, b) : a === b;
      } catch (e) {
        this.destination.error(e);
      }
      areEqual || this.emit(!1);
    }
  }, SequenceEqualSubscriber2.prototype.emit = function(value) {
    var destination = this.destination;
    destination.next(value), destination.complete();
  }, SequenceEqualSubscriber2.prototype.nextB = function(value) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(value), this.checkValues());
  }, SequenceEqualSubscriber2.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, SequenceEqualSubscriber2;
}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent) {
    var _this = _super.call(this, destination) || this;
    return _this.parent = parent, _this;
  }
  return SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
    this.parent.nextB(value);
  }, SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err), this.unsubscribe();
  }, SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source2) {
    return refCount()(multicast(shareSubjectFactory)(source2));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  return configOrBufferSize && typeof configOrBufferSize == "object" ? config2 = configOrBufferSize : config2 = {
    bufferSize: configOrBufferSize,
    windowTime: windowTime2,
    refCount: !1,
    scheduler
  }, function(source2) {
    return source2.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a) {
  var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler, subject, refCount2 = 0, subscription, hasError = !1, isComplete = !1;
  return function(source2) {
    refCount2++;
    var innerSub;
    !subject || hasError ? (hasError = !1, subject = new ReplaySubject(bufferSize, windowTime2, scheduler), innerSub = subject.subscribe(this), subscription = source2.subscribe({
      next: function(value) {
        subject.next(value);
      },
      error: function(err) {
        hasError = !0, subject.error(err);
      },
      complete: function() {
        isComplete = !0, subscription = void 0, subject.complete();
      }
    }), isComplete && (subscription = void 0)) : innerSub = subject.subscribe(this), this.add(function() {
      refCount2--, innerSub.unsubscribe(), innerSub = void 0, subscription && !isComplete && useRefCount && refCount2 === 0 && (subscription.unsubscribe(), subscription = void 0, subject = void 0);
    });
  };
}
function single(predicate) {
  return function(source2) {
    return source2.lift(new SingleOperator(predicate, source2));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source2) {
    this.predicate = predicate, this.source = source2;
  }
  return SingleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  }, SingleOperator2;
}(), SingleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.source = source2, _this.seenValue = !1, _this.index = 0, _this;
  }
  return SingleSubscriber2.prototype.applySingleValue = function(value) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = value);
  }, SingleSubscriber2.prototype._next = function(value) {
    var index = this.index++;
    this.predicate ? this.tryNext(value, index) : this.applySingleValue(value);
  }, SingleSubscriber2.prototype.tryNext = function(value, index) {
    try {
      this.predicate(value, index, this.source) && this.applySingleValue(value);
    } catch (err) {
      this.destination.error(err);
    }
  }, SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    this.index > 0 ? (destination.next(this.seenValue ? this.singleValue : void 0), destination.complete()) : destination.error(new EmptyError());
  }, SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source2) {
    return source2.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  return SkipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipSubscriber(subscriber, this.total));
  }, SkipOperator2;
}(), SkipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    return _this.total = total, _this.count = 0, _this;
  }
  return SkipSubscriber2.prototype._next = function(x) {
    ++this.count > this.total && this.destination.next(x);
  }, SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source2) {
    return source2.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    if (this._skipCount = _skipCount, this._skipCount < 0)
      throw new ArgumentOutOfRangeError();
  }
  return SkipLastOperator2.prototype.call = function(subscriber, source2) {
    return this._skipCount === 0 ? source2.subscribe(new Subscriber(subscriber)) : source2.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
  }, SkipLastOperator2;
}(), SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    return _this._skipCount = _skipCount, _this._count = 0, _this._ring = new Array(_skipCount), _this;
  }
  return SkipLastSubscriber2.prototype._next = function(value) {
    var skipCount = this._skipCount, count2 = this._count++;
    if (count2 < skipCount)
      this._ring[count2] = value;
    else {
      var currentIndex = count2 % skipCount, ring = this._ring, oldValue = ring[currentIndex];
      ring[currentIndex] = value, this.destination.next(oldValue);
    }
  }, SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source2) {
    return source2.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  return SkipUntilOperator2.prototype.call = function(destination, source2) {
    return source2.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  }, SkipUntilOperator2;
}(), SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = !1;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber), _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    return innerSubscription !== innerSubscriber && (_this.add(innerSubscription), _this.innerSubscription = innerSubscription), _this;
  }
  return SkipUntilSubscriber2.prototype._next = function(value) {
    this.hasValue && _super.prototype._next.call(this, value);
  }, SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, SkipUntilSubscriber2.prototype.notifyComplete = function() {
  }, SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source2) {
    return source2.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  return SkipWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  }, SkipWhileOperator2;
}(), SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.skipping = !0, _this.index = 0, _this;
  }
  return SkipWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    this.skipping && this.tryCallPredicate(value), this.skipping || destination.next(value);
  }, SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = !!result;
    } catch (err) {
      this.destination.error(err);
    }
  }, SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  for (var array2 = [], _i = 0; _i < arguments.length; _i++)
    array2[_i] = arguments[_i];
  var scheduler = array2[array2.length - 1];
  return isScheduler(scheduler) ? (array2.pop(), function(source2) {
    return concat$1(array2, source2, scheduler);
  }) : function(source2) {
    return concat$1(array2, source2);
  };
}
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source2, delayTime, scheduler) {
    delayTime === void 0 && (delayTime = 0), scheduler === void 0 && (scheduler = asap);
    var _this = _super.call(this) || this;
    return _this.source = source2, _this.delayTime = delayTime, _this.scheduler = scheduler, (!isNumeric(delayTime) || delayTime < 0) && (_this.delayTime = 0), (!scheduler || typeof scheduler.schedule != "function") && (_this.scheduler = asap), _this;
  }
  return SubscribeOnObservable2.create = function(source2, delay2, scheduler) {
    return delay2 === void 0 && (delay2 = 0), scheduler === void 0 && (scheduler = asap), new SubscribeOnObservable2(source2, delay2, scheduler);
  }, SubscribeOnObservable2.dispatch = function(arg) {
    var source2 = arg.source, subscriber = arg.subscriber;
    return this.add(source2.subscribe(subscriber));
  }, SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime, source2 = this.source, scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
      source: source2,
      subscriber
    });
  }, SubscribeOnObservable2;
}(Observable);
function subscribeOn(scheduler, delay2) {
  return delay2 === void 0 && (delay2 = 0), function(source2) {
    return source2.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler, delay2) {
    this.scheduler = scheduler, this.delay = delay2;
  }
  return SubscribeOnOperator2.prototype.call = function(subscriber, source2) {
    return new SubscribeOnObservable(source2, this.delay, this.scheduler).subscribe(subscriber);
  }, SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  return typeof resultSelector == "function" ? function(source2) {
    return source2.pipe(switchMap(function(a, i2) {
      return from$2(project(a, i2)).pipe(map(function(b, ii) {
        return resultSelector(a, b, i2, ii);
      }));
    }));
  } : function(source2) {
    return source2.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  return SwitchMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  }, SwitchMapOperator2;
}(), SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    return _this.project = project, _this.index = 0, _this;
  }
  return SwitchMapSubscriber2.prototype._next = function(value) {
    var result, index = this.index++;
    try {
      result = this.project(value, index);
    } catch (error2) {
      this.destination.error(error2);
      return;
    }
    this._innerSub(result);
  }, SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    innerSubscription && innerSubscription.unsubscribe();
    var innerSubscriber = new SimpleInnerSubscriber(this), destination = this.destination;
    destination.add(innerSubscriber), this.innerSubscription = innerSubscribe(result, innerSubscriber), this.innerSubscription !== innerSubscriber && destination.add(this.innerSubscription);
  }, SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    (!innerSubscription || innerSubscription.closed) && _super.prototype._complete.call(this), this.unsubscribe();
  }, SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && _super.prototype._complete.call(this);
  }, SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  }, SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source2) {
    return source2.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  return TakeUntilOperator2.prototype.call = function(subscriber, source2) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber), notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    return notifierSubscription && !takeUntilSubscriber.seenValue ? (takeUntilSubscriber.add(notifierSubscription), source2.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
  }, TakeUntilOperator2;
}(), TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.seenValue = !1, _this;
  }
  return TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, TakeUntilSubscriber2.prototype.notifyComplete = function() {
  }, TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  return inclusive === void 0 && (inclusive = !1), function(source2) {
    return source2.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate, this.inclusive = inclusive;
  }
  return TakeWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  }, TakeWhileOperator2;
}(), TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    return _this.predicate = predicate, _this.inclusive = inclusive, _this.index = 0, _this;
  }
  return TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination, result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  }, TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    predicateResult ? destination.next(value) : (this.inclusive && destination.next(value), destination.complete());
  }, TakeWhileSubscriber2;
}(Subscriber);
function tap(nextOrObserver, error2, complete) {
  return function(source2) {
    return source2.lift(new DoOperator(nextOrObserver, error2, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error2, complete) {
    this.nextOrObserver = nextOrObserver, this.error = error2, this.complete = complete;
  }
  return DoOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  }, DoOperator2;
}(), TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error2, complete) {
    var _this = _super.call(this, destination) || this;
    return _this._tapNext = noop, _this._tapError = noop, _this._tapComplete = noop, _this._tapError = error2 || noop, _this._tapComplete = complete || noop, isFunction(observerOrNext) ? (_this._context = _this, _this._tapNext = observerOrNext) : observerOrNext && (_this._context = observerOrNext, _this._tapNext = observerOrNext.next || noop, _this._tapError = observerOrNext.error || noop, _this._tapComplete = observerOrNext.complete || noop), _this;
  }
  return TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  }, TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  }, TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  }, TapSubscriber2;
}(Subscriber), defaultThrottleConfig = {
  leading: !0,
  trailing: !1
};
function throttle(durationSelector, config2) {
  return config2 === void 0 && (config2 = defaultThrottleConfig), function(source2) {
    return source2.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector, this.leading = leading, this.trailing = trailing;
  }
  return ThrottleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  }, ThrottleOperator2;
}(), ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.durationSelector = durationSelector, _this._leading = _leading, _this._trailing = _trailing, _this._hasValue = !1, _this;
  }
  return ThrottleSubscriber2.prototype._next = function(value) {
    this._hasValue = !0, this._sendValue = value, this._throttled || (this._leading ? this.send() : this.throttle(value));
  }, ThrottleSubscriber2.prototype.send = function() {
    var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
    _hasValue && (this.destination.next(_sendValue), this.throttle(_sendValue)), this._hasValue = !1, this._sendValue = void 0;
  }, ThrottleSubscriber2.prototype.throttle = function(value) {
    var duration = this.tryDurationSelector(value);
    duration && this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
  }, ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      return this.destination.error(err), null;
    }
  }, ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
    _throttled && _throttled.unsubscribe(), this._throttled = void 0, _trailing && this.send();
  }, ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  }, ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler, config2) {
  return scheduler === void 0 && (scheduler = async), config2 === void 0 && (config2 = defaultThrottleConfig), function(source2) {
    return source2.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
    this.duration = duration, this.scheduler = scheduler, this.leading = leading, this.trailing = trailing;
  }
  return ThrottleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  }, ThrottleTimeOperator2;
}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    return _this.duration = duration, _this.scheduler = scheduler, _this.leading = leading, _this.trailing = trailing, _this._hasTrailingValue = !1, _this._trailingValue = null, _this;
  }
  return ThrottleTimeSubscriber2.prototype._next = function(value) {
    this.throttled ? this.trailing && (this._trailingValue = value, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(value) : this.trailing && (this._trailingValue = value, this._hasTrailingValue = !0));
  }, ThrottleTimeSubscriber2.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    throttled && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), throttled.unsubscribe(), this.remove(throttled), this.throttled = null);
  }, ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function timeInterval(scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    return defer$1(function() {
      return source2.pipe(scan(function(_a, value) {
        var current = _a.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a) {
        var current = _a.current, last2 = _a.last, value = _a.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval2) {
    this.value = value, this.interval = interval2;
  }
  return TimeInterval2;
}();
function timeoutWith(due, withObservable, scheduler) {
  return scheduler === void 0 && (scheduler = async), function(source2) {
    var absoluteTimeout = isDate(due), waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source2.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor, this.absoluteTimeout = absoluteTimeout, this.withObservable = withObservable, this.scheduler = scheduler;
  }
  return TimeoutWithOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, TimeoutWithOperator2;
}(), TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    return _this.absoluteTimeout = absoluteTimeout, _this.waitFor = waitFor, _this.withObservable = withObservable, _this.scheduler = scheduler, _this.scheduleTimeout(), _this;
  }
  return TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle(), subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  }, TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    action ? this.action = action.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
  }, TimeoutWithSubscriber2.prototype._next = function(value) {
    this.absoluteTimeout || this.scheduleTimeout(), _super.prototype._next.call(this, value);
  }, TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler) {
  return scheduler === void 0 && (scheduler = async), timeoutWith(due, throwError(new TimeoutError$1()), scheduler);
}
function timestamp(scheduler) {
  return scheduler === void 0 && (scheduler = async), map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value, timestamp2) {
    this.value = value, this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr, item, index) {
  return index === 0 ? [item] : (arr.push(item), arr);
}
function toArray() {
  return reduce$1(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function(source2) {
    return source2.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  return WindowOperator2.prototype.call = function(subscriber, source2) {
    var windowSubscriber = new WindowSubscriber$1(subscriber), sourceSubscription = source2.subscribe(windowSubscriber);
    return sourceSubscription.closed || windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber))), sourceSubscription;
  }, WindowOperator2;
}(), WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    return _this.window = new Subject(), destination.next(_this.window), _this;
  }
  return WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  }, WindowSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  }, WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  }, WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  }, WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err), this.destination.error(err);
  }, WindowSubscriber2.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  }, WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    prevWindow && prevWindow.complete();
    var destination = this.destination, newWindow = this.window = new Subject();
    destination.next(newWindow);
  }, WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  return startWindowEvery === void 0 && (startWindowEvery = 0), function(source2) {
    return source2.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize, this.startWindowEvery = startWindowEvery;
  }
  return WindowCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  }, WindowCountOperator2;
}(), WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.windowSize = windowSize, _this.startWindowEvery = startWindowEvery, _this.windows = [new Subject()], _this.count = 0, destination.next(_this.windows[0]), _this;
  }
  return WindowCountSubscriber2.prototype._next = function(value) {
    for (var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, destination = this.destination, windowSize = this.windowSize, windows2 = this.windows, len = windows2.length, i2 = 0; i2 < len && !this.closed; i2++)
      windows2[i2].next(value);
    var c2 = this.count - windowSize + 1;
    if (c2 >= 0 && c2 % startWindowEvery === 0 && !this.closed && windows2.shift().complete(), ++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows2.push(window_1), destination.next(window_1);
    }
  }, WindowCountSubscriber2.prototype._error = function(err) {
    var windows2 = this.windows;
    if (windows2)
      for (; windows2.length > 0 && !this.closed; )
        windows2.shift().error(err);
    this.destination.error(err);
  }, WindowCountSubscriber2.prototype._complete = function() {
    var windows2 = this.windows;
    if (windows2)
      for (; windows2.length > 0 && !this.closed; )
        windows2.shift().complete();
    this.destination.complete();
  }, WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler = async, windowCreationInterval = null, maxWindowSize = Number.POSITIVE_INFINITY;
  return isScheduler(arguments[3]) && (scheduler = arguments[3]), isScheduler(arguments[2]) ? scheduler = arguments[2] : isNumeric(arguments[2]) && (maxWindowSize = Number(arguments[2])), isScheduler(arguments[1]) ? scheduler = arguments[1] : isNumeric(arguments[1]) && (windowCreationInterval = Number(arguments[1])), function(source2) {
    return source2.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    this.windowTimeSpan = windowTimeSpan, this.windowCreationInterval = windowCreationInterval, this.maxWindowSize = maxWindowSize, this.scheduler = scheduler;
  }
  return WindowTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, WindowTimeOperator2;
}(), CountedSubject = /* @__PURE__ */ function(_super) {
  __extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    return _this._numberOfNextedValues = 0, _this;
  }
  return CountedSubject2.prototype.next = function(value) {
    this._numberOfNextedValues++, _super.prototype.next.call(this, value);
  }, Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), CountedSubject2;
}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination, _this.windowTimeSpan = windowTimeSpan, _this.windowCreationInterval = windowCreationInterval, _this.maxWindowSize = maxWindowSize, _this.scheduler = scheduler, _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = { subscriber: _this, window: window2, context: null }, creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState)), _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  return WindowTimeSubscriber2.prototype._next = function(value) {
    for (var windows2 = this.windows, len = windows2.length, i2 = 0; i2 < len; i2++) {
      var window_1 = windows2[i2];
      window_1.closed || (window_1.next(value), window_1.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(window_1));
    }
  }, WindowTimeSubscriber2.prototype._error = function(err) {
    for (var windows2 = this.windows; windows2.length > 0; )
      windows2.shift().error(err);
    this.destination.error(err);
  }, WindowTimeSubscriber2.prototype._complete = function() {
    for (var windows2 = this.windows; windows2.length > 0; ) {
      var window_2 = windows2.shift();
      window_2.closed || window_2.complete();
    }
    this.destination.complete();
  }, WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    return destination.next(window2), window2;
  }, WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows2 = this.windows;
    windows2.splice(windows2.indexOf(window2), 1);
  }, WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state2) {
  var subscriber = state2.subscriber, windowTimeSpan = state2.windowTimeSpan, window2 = state2.window;
  window2 && subscriber.closeWindow(window2), state2.window = subscriber.openWindow(), this.schedule(state2, windowTimeSpan);
}
function dispatchWindowCreation(state2) {
  var windowTimeSpan = state2.windowTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler, windowCreationInterval = state2.windowCreationInterval, window2 = subscriber.openWindow(), action = this, context = { action, subscription: null }, timeSpanState = { subscriber, window: window2, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState), action.add(context.subscription), action.schedule(state2, windowCreationInterval);
}
function dispatchWindowClose(state2) {
  var subscriber = state2.subscriber, window2 = state2.window, context = state2.context;
  context && context.action && context.subscription && context.action.remove(context.subscription), subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source2) {
    return source2.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings, this.closingSelector = closingSelector;
  }
  return WindowToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  }, WindowToggleOperator2;
}(), WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.openings = openings, _this.closingSelector = closingSelector, _this.contexts = [], _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings)), _this;
  }
  return WindowToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    if (contexts)
      for (var len = contexts.length, i2 = 0; i2 < len; i2++)
        contexts[i2].window.next(value);
  }, WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    if (this.contexts = null, contexts)
      for (var len = contexts.length, index = -1; ++index < len; ) {
        var context_1 = contexts[index];
        context_1.window.error(err), context_1.subscription.unsubscribe();
      }
    _super.prototype._error.call(this, err);
  }, WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    if (this.contexts = null, contexts)
      for (var len = contexts.length, index = -1; ++index < len; ) {
        var context_2 = contexts[index];
        context_2.window.complete(), context_2.subscription.unsubscribe();
      }
    _super.prototype._complete.call(this);
  }, WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    if (this.contexts = null, contexts)
      for (var len = contexts.length, index = -1; ++index < len; ) {
        var context_3 = contexts[index];
        context_3.window.unsubscribe(), context_3.subscription.unsubscribe();
      }
  }, WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e) {
        return this.error(e);
      }
      var window_1 = new Subject(), subscription = new Subscription(), context_4 = { window: window_1, subscription };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      innerSubscription.closed ? this.closeWindow(this.contexts.length - 1) : (innerSubscription.context = context_4, subscription.add(innerSubscription)), this.destination.next(window_1);
    } else
      this.closeWindow(this.contexts.indexOf(outerValue));
  }, WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  }, WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    inner !== this.openSubscription && this.closeWindow(this.contexts.indexOf(inner.context));
  }, WindowToggleSubscriber2.prototype.closeWindow = function(index) {
    if (index !== -1) {
      var contexts = this.contexts, context = contexts[index], window2 = context.window, subscription = context.subscription;
      contexts.splice(index, 1), window2.complete(), subscription.unsubscribe();
    }
  }, WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function(source2) {
    return source2.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  return WindowOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  }, WindowOperator2;
}(), WindowSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    return _this.destination = destination, _this.closingSelector = closingSelector, _this.openWindow(), _this;
  }
  return WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  }, WindowSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  }, WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  }, WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  }, WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err), this.destination.error(err), this.unsubscribeClosingNotification();
  }, WindowSubscriber2.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, WindowSubscriber2.prototype.openWindow = function(innerSub) {
    innerSub === void 0 && (innerSub = null), innerSub && (this.remove(innerSub), innerSub.unsubscribe());
    var prevWindow = this.window;
    prevWindow && prevWindow.complete();
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e) {
      this.destination.error(e), this.window.error(e);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  }, WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  for (var args = [], _i = 0; _i < arguments.length; _i++)
    args[_i] = arguments[_i];
  return function(source2) {
    var project;
    typeof args[args.length - 1] == "function" && (project = args.pop());
    var observables = args;
    return source2.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables, this.project = project;
  }
  return WithLatestFromOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  }, WithLatestFromOperator2;
}(), WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables, _this.project = project, _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);
    for (var i2 = 0; i2 < len; i2++)
      _this.toRespond.push(i2);
    for (var i2 = 0; i2 < len; i2++) {
      var observable2 = observables[i2];
      _this.add(subscribeToResult(_this, observable2, void 0, i2));
    }
    return _this;
  }
  return WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      found !== -1 && toRespond.splice(found, 1);
    }
  }, WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  }, WithLatestFromSubscriber2.prototype._next = function(value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);
      this.project ? this._tryProject(args) : this.destination.next(args);
    }
  }, WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }, WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip() {
  for (var observables = [], _i = 0; _i < arguments.length; _i++)
    observables[_i] = arguments[_i];
  return function(source2) {
    return source2.lift.call(zip$1.apply(void 0, [source2].concat(observables)));
  };
}
function zipAll(project) {
  return function(source2) {
    return source2.lift(new ZipOperator(project));
  };
}
var operators = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap: concatMap$1,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand: expand$1,
  filter: filter$1,
  finalize,
  find,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish: publish$1,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce: reduce$1,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample: sample$1,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}), require$$1$1 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(operators), runAsync$3 = { exports: {} };
function isPromise(obj) {
  return !!obj && (typeof obj == "object" || typeof obj == "function") && typeof obj.then == "function";
}
var runAsync$2 = runAsync$3.exports = function(func, cb) {
  return cb = cb || function() {
  }, function() {
    var args = arguments, promise2 = new Promise(function(resolve2, reject) {
      var resolved = !1;
      const wrappedResolve = function(value) {
        resolved && console.warn("Run-async promise already resolved."), resolved = !0, resolve2(value);
      };
      var rejected = !1;
      const wrappedReject = function(value) {
        rejected && console.warn("Run-async promise already rejected."), rejected = !0, reject(value);
      };
      var usingCallback = !1, callbackConflict = !1, contextEnded = !1, answer = func.apply({
        async: function() {
          return contextEnded ? (console.warn("Run-async async() called outside a valid run-async context, callback will be ignored."), function() {
          }) : (callbackConflict && console.warn(`Run-async wrapped function (async) returned a promise.
Calls to async() callback can have unexpected results.`), usingCallback = !0, function(err, value) {
            err ? wrappedReject(err) : wrappedResolve(value);
          });
        }
      }, Array.prototype.slice.call(args));
      usingCallback ? isPromise(answer) && console.warn("Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.") : isPromise(answer) ? (callbackConflict = !0, answer.then(wrappedResolve, wrappedReject)) : wrappedResolve(answer), contextEnded = !0;
    });
    return promise2.then(cb.bind(null, null), cb), promise2;
  };
};
runAsync$2.cb = function(func, cb) {
  return runAsync$2(function() {
    var args = Array.prototype.slice.call(arguments);
    return args.length === func.length - 1 && args.push(this.async()), func.apply(this, args);
  }, cb);
};
var runAsyncExports = runAsync$3.exports, utils$1 = {}, _$1 = lodashExports, { from: from$1, of: of$1 } = require$$4$1, runAsync$1 = runAsyncExports;
utils$1.fetchAsyncQuestionProperty = function(question, prop, answers) {
  return _$1.isFunction(question[prop]) ? from$1(
    runAsync$1(question[prop])(answers).then((value) => (question[prop] = value, question))
  ) : of$1(question);
};
var _ = lodashExports, { defer, empty, from, of } = require$$4$1, { concatMap, filter, publish, reduce } = require$$1$1, runAsync = runAsyncExports, utils = utils$1, Base = baseUI;
class PromptUI extends Base {
  constructor(prompts, opt) {
    super(opt), this.prompts = prompts;
  }
  run(questions) {
    this.answers = {}, _.isPlainObject(questions) && (questions = [questions]);
    var obs = _.isArray(questions) ? from(questions) : questions;
    return this.process = obs.pipe(
      concatMap(this.processQuestion.bind(this)),
      publish()
      // Creates a hot Observable. It prevents duplicating prompts.
    ), this.process.connect(), this.process.pipe(
      reduce((answers, answer) => (_.set(this.answers, answer.name, answer.answer), this.answers), {})
    ).toPromise(Promise).then(this.onCompletion.bind(this));
  }
  /**
   * Once all prompt are over
   */
  onCompletion() {
    return this.close(), this.answers;
  }
  processQuestion(question) {
    return question = _.clone(question), defer(() => {
      var obs = of(question);
      return obs.pipe(
        concatMap(this.setDefaultType.bind(this)),
        concatMap(this.filterIfRunnable.bind(this)),
        concatMap(
          () => utils.fetchAsyncQuestionProperty(question, "message", this.answers)
        ),
        concatMap(
          () => utils.fetchAsyncQuestionProperty(question, "default", this.answers)
        ),
        concatMap(
          () => utils.fetchAsyncQuestionProperty(question, "choices", this.answers)
        ),
        concatMap(this.fetchAnswer.bind(this))
      );
    });
  }
  fetchAnswer(question) {
    var Prompt = this.prompts[question.type];
    return this.activePrompt = new Prompt(question, this.rl, this.answers), defer(
      () => from(
        this.activePrompt.run().then((answer) => ({ name: question.name, answer }))
      )
    );
  }
  setDefaultType(question) {
    return this.prompts[question.type] || (question.type = "input"), defer(() => of(question));
  }
  filterIfRunnable(question) {
    if (question.when === !1)
      return empty();
    if (!_.isFunction(question.when))
      return of(question);
    var answers = this.answers;
    return defer(
      () => from(
        runAsync(question.when)(answers).then((shouldRun) => {
          if (shouldRun)
            return question;
        })
      ).pipe(filter((val) => val != null))
    );
  }
}
var prompt$1 = PromptUI, cliCursor = {}, mimicFn, hasRequiredMimicFn;
function requireMimicFn() {
  return hasRequiredMimicFn || (hasRequiredMimicFn = 1, mimicFn = (to, from2) => {
    for (const prop of Object.getOwnPropertyNames(from2).concat(Object.getOwnPropertySymbols(from2)))
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from2, prop));
    return to;
  }), mimicFn;
}
var onetime, hasRequiredOnetime;
function requireOnetime() {
  if (hasRequiredOnetime) return onetime;
  hasRequiredOnetime = 1;
  const mimicFn2 = requireMimicFn();
  return onetime = (fn2, opts) => {
    if (opts === !0)
      throw new TypeError("The second argument is now an options object");
    if (typeof fn2 != "function")
      throw new TypeError("Expected a function");
    opts = opts || {};
    let ret, called = !1;
    const fnName = fn2.displayName || fn2.name || "<anonymous>", onetime2 = function() {
      if (called) {
        if (opts.throw === !0)
          throw new Error(`Function \`${fnName}\` can only be called once`);
        return ret;
      }
      return called = !0, ret = fn2.apply(this, arguments), fn2 = null, ret;
    };
    return mimicFn2(onetime2, fn2), onetime2;
  }, onetime;
}
var restoreCursor, hasRequiredRestoreCursor;
function requireRestoreCursor() {
  if (hasRequiredRestoreCursor) return restoreCursor;
  hasRequiredRestoreCursor = 1;
  const onetime2 = requireOnetime(), signalExit2 = signalExitExports;
  return restoreCursor = onetime2(() => {
    signalExit2(() => {
      process.stderr.write("\x1B[?25h");
    }, { alwaysLast: !0 });
  }), restoreCursor;
}
var hasRequiredCliCursor;
function requireCliCursor() {
  return hasRequiredCliCursor || (hasRequiredCliCursor = 1, function(exports2) {
    const restoreCursor2 = requireRestoreCursor();
    let hidden = !1;
    exports2.show = (stream2) => {
      const s = stream2 || process.stderr;
      s.isTTY && (hidden = !1, s.write("\x1B[?25h"));
    }, exports2.hide = (stream2) => {
      const s = stream2 || process.stderr;
      s.isTTY && (restoreCursor2(), hidden = !0, s.write("\x1B[?25l"));
    }, exports2.toggle = (force, stream2) => {
      force !== void 0 && (hidden = force), hidden ? exports2.show(stream2) : exports2.hide(stream2);
    };
  }(cliCursor)), cliCursor;
}
var choice, hasRequiredChoice;
function requireChoice() {
  if (hasRequiredChoice) return choice;
  hasRequiredChoice = 1;
  var _2 = lodashExports;
  return choice = class Choice {
    constructor(val, answers) {
      if (val instanceof Choice || val.type === "separator")
        return val;
      _2.isString(val) || _2.isNumber(val) ? (this.name = String(val), this.value = val, this.short = String(val)) : _2.extend(this, val, {
        name: val.name || val.value,
        value: "value" in val ? val.value : val.name,
        short: val.short || val.name || val.value
      }), _2.isFunction(val.disabled) ? this.disabled = val.disabled(answers) : this.disabled = val.disabled;
    }
  }, choice;
}
var choices, hasRequiredChoices;
function requireChoices() {
  if (hasRequiredChoices) return choices;
  hasRequiredChoices = 1;
  var assert2 = require$$5__default.default, _2 = lodashExports, Separator2 = separator, Choice = requireChoice();
  return choices = class {
    constructor(choices2, answers) {
      this.choices = choices2.map((val) => val.type === "separator" ? (val instanceof Separator2 || (val = new Separator2(val.line)), val) : new Choice(val, answers)), this.realChoices = this.choices.filter(Separator2.exclude).filter((item) => !item.disabled), Object.defineProperty(this, "length", {
        get() {
          return this.choices.length;
        },
        set(val) {
          this.choices.length = val;
        }
      }), Object.defineProperty(this, "realLength", {
        get() {
          return this.realChoices.length;
        },
        set() {
          throw new Error("Cannot set `realLength` of a Choices collection");
        }
      });
    }
    /**
     * Get a valid choice from the collection
     * @param  {Number} selector  The selected choice index
     * @return {Choice|Undefined} Return the matched choice or undefined
     */
    getChoice(selector) {
      return assert2(_2.isNumber(selector)), this.realChoices[selector];
    }
    /**
     * Get a raw element from the collection
     * @param  {Number} selector  The selected index value
     * @return {Choice|Undefined} Return the matched choice or undefined
     */
    get(selector) {
      return assert2(_2.isNumber(selector)), this.choices[selector];
    }
    /**
     * Match the valid choices against a where clause
     * @param  {Object} whereClause Lodash `where` clause
     * @return {Array}              Matching choices or empty array
     */
    where(whereClause) {
      return _2.filter(this.realChoices, whereClause);
    }
    /**
     * Pluck a particular key from the choices
     * @param  {String} propertyName Property name to select
     * @return {Array}               Selected properties
     */
    pluck(propertyName) {
      return _2.map(this.realChoices, propertyName);
    }
    // Expose usual Array methods
    indexOf() {
      return this.choices.indexOf.apply(this.choices, arguments);
    }
    forEach() {
      return this.choices.forEach.apply(this.choices, arguments);
    }
    filter() {
      return this.choices.filter.apply(this.choices, arguments);
    }
    find(func) {
      return _2.find(this.choices, func);
    }
    push() {
      var objs = _2.map(arguments, (val) => new Choice(val));
      return this.choices.push.apply(this.choices, objs), this.realChoices = this.choices.filter(Separator2.exclude), this.choices;
    }
  }, choices;
}
var cliWidth = { exports: {} }, hasRequiredCliWidth;
function requireCliWidth() {
  return hasRequiredCliWidth || (hasRequiredCliWidth = 1, function(module2, exports2) {
    module2.exports = cliWidth2;
    function normalizeOpts(options2) {
      var defaultOpts = {
        defaultWidth: 0,
        output: process.stdout,
        tty: require$$0__default$b.default
      };
      return options2 ? (Object.keys(defaultOpts).forEach(function(key2) {
        options2[key2] || (options2[key2] = defaultOpts[key2]);
      }), options2) : defaultOpts;
    }
    function cliWidth2(options2) {
      var opts = normalizeOpts(options2);
      if (opts.output.getWindowSize)
        return opts.output.getWindowSize()[0] || opts.defaultWidth;
      if (opts.tty.getWindowSize)
        return opts.tty.getWindowSize()[1] || opts.defaultWidth;
      if (opts.output.columns)
        return opts.output.columns;
      if (process.env.CLI_WIDTH) {
        var width = parseInt(process.env.CLI_WIDTH, 10);
        if (!isNaN(width) && width !== 0)
          return width;
      }
      return opts.defaultWidth;
    }
  }(cliWidth)), cliWidth.exports;
}
var stripAnsi$1 = { exports: {} }, ansiRegex$1, hasRequiredAnsiRegex$1;
function requireAnsiRegex$1() {
  return hasRequiredAnsiRegex$1 || (hasRequiredAnsiRegex$1 = 1, ansiRegex$1 = (options2) => {
    options2 = Object.assign({
      onlyFirst: !1
    }, options2);
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, options2.onlyFirst ? void 0 : "g");
  }), ansiRegex$1;
}
var hasRequiredStripAnsi$1;
function requireStripAnsi$1() {
  if (hasRequiredStripAnsi$1) return stripAnsi$1.exports;
  hasRequiredStripAnsi$1 = 1;
  const ansiRegex2 = requireAnsiRegex$1(), stripAnsi2 = (string) => typeof string == "string" ? string.replace(ansiRegex2(), "") : string;
  return stripAnsi$1.exports = stripAnsi2, stripAnsi$1.exports.default = stripAnsi2, stripAnsi$1.exports;
}
var ansiRegex, hasRequiredAnsiRegex;
function requireAnsiRegex() {
  return hasRequiredAnsiRegex || (hasRequiredAnsiRegex = 1, ansiRegex = () => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[a-zA-Z\\d]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, "g");
  }), ansiRegex;
}
var stripAnsi, hasRequiredStripAnsi;
function requireStripAnsi() {
  if (hasRequiredStripAnsi) return stripAnsi;
  hasRequiredStripAnsi = 1;
  const ansiRegex2 = requireAnsiRegex();
  return stripAnsi = (input2) => typeof input2 == "string" ? input2.replace(ansiRegex2(), "") : input2, stripAnsi;
}
var isFullwidthCodePoint, hasRequiredIsFullwidthCodePoint;
function requireIsFullwidthCodePoint() {
  return hasRequiredIsFullwidthCodePoint || (hasRequiredIsFullwidthCodePoint = 1, isFullwidthCodePoint = (x) => Number.isNaN(x) ? !1 : x >= 4352 && (x <= 4447 || // Hangul Jamo
  x === 9001 || // LEFT-POINTING ANGLE BRACKET
  x === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= x && x <= 12871 && x !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= x && x <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= x && x <= 42182 || // Hangul Jamo Extended-A
  43360 <= x && x <= 43388 || // Hangul Syllables
  44032 <= x && x <= 55203 || // CJK Compatibility Ideographs
  63744 <= x && x <= 64255 || // Vertical Forms
  65040 <= x && x <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= x && x <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= x && x <= 65376 || 65504 <= x && x <= 65510 || // Kana Supplement
  110592 <= x && x <= 110593 || // Enclosed Ideographic Supplement
  127488 <= x && x <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= x && x <= 262141)), isFullwidthCodePoint;
}
var stringWidth, hasRequiredStringWidth;
function requireStringWidth() {
  if (hasRequiredStringWidth) return stringWidth;
  hasRequiredStringWidth = 1;
  const stripAnsi2 = requireStripAnsi(), isFullwidthCodePoint2 = requireIsFullwidthCodePoint();
  return stringWidth = (str2) => {
    if (typeof str2 != "string" || str2.length === 0)
      return 0;
    str2 = stripAnsi2(str2);
    let width = 0;
    for (let i2 = 0; i2 < str2.length; i2++) {
      const code = str2.codePointAt(i2);
      code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || (code > 65535 && i2++, width += isFullwidthCodePoint2(code) ? 2 : 1);
    }
    return width;
  }, stringWidth;
}
var screenManager, hasRequiredScreenManager;
function requireScreenManager() {
  if (hasRequiredScreenManager) return screenManager;
  hasRequiredScreenManager = 1;
  var _2 = lodashExports, util2 = readline, cliWidth2 = requireCliWidth(), stripAnsi2 = requireStripAnsi$1(), stringWidth2 = requireStringWidth();
  function height(content) {
    return content.split(`
`).length;
  }
  function lastLine(content) {
    return _2.last(content.split(`
`));
  }
  class ScreenManager {
    constructor(rl) {
      this.height = 0, this.extraLinesUnderPrompt = 0, this.rl = rl;
    }
    render(content, bottomContent) {
      this.rl.output.unmute(), this.clean(this.extraLinesUnderPrompt);
      var promptLine = lastLine(content), rawPromptLine = stripAnsi2(promptLine), prompt2 = rawPromptLine;
      this.rl.line.length && (prompt2 = prompt2.slice(0, -this.rl.line.length)), this.rl.setPrompt(prompt2);
      var cursorPos = this.rl._getCursorPos(), width = this.normalizedCliWidth();
      content = this.forceLineReturn(content, width), bottomContent && (bottomContent = this.forceLineReturn(bottomContent, width)), rawPromptLine.length % width === 0 && (content += `
`);
      var fullContent = content + (bottomContent ? `
` + bottomContent : "");
      this.rl.output.write(fullContent);
      var promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows, bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
      bottomContentHeight > 0 && util2.up(this.rl, bottomContentHeight), util2.left(this.rl, stringWidth2(lastLine(fullContent))), cursorPos.cols > 0 && util2.right(this.rl, cursorPos.cols), this.extraLinesUnderPrompt = bottomContentHeight, this.height = height(fullContent), this.rl.output.mute();
    }
    clean(extraLines) {
      extraLines > 0 && util2.down(this.rl, extraLines), util2.clearLine(this.rl, this.height);
    }
    done() {
      this.rl.setPrompt(""), this.rl.output.unmute(), this.rl.output.write(`
`);
    }
    releaseCursor() {
      this.extraLinesUnderPrompt > 0 && util2.down(this.rl, this.extraLinesUnderPrompt);
    }
    normalizedCliWidth() {
      var width = cliWidth2({
        defaultWidth: 80,
        output: this.rl.output
      });
      return width;
    }
    breakLines(lines2, width) {
      width = width || this.normalizedCliWidth();
      var regex = new RegExp("(?:(?:\\033[[0-9;]*m)*.?){1," + width + "}", "g");
      return lines2.map((line3) => {
        var chunk = line3.match(regex);
        return chunk.pop(), chunk || "";
      });
    }
    forceLineReturn(content, width) {
      return width = width || this.normalizedCliWidth(), _2.flatten(this.breakLines(content.split(`
`), width)).join(`
`);
    }
  }
  return screenManager = ScreenManager, screenManager;
}
var base, hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  var _2 = lodashExports, chalk2 = chalk__default.default, runAsync2 = runAsyncExports, { filter: filter2, flatMap: flatMap2, share: share2, take: take2, takeUntil: takeUntil2 } = require$$1$1, Choices = requireChoices(), ScreenManager = requireScreenManager();
  class Prompt {
    constructor(question, rl, answers) {
      _2.assign(this, {
        answers,
        status: "pending"
      }), this.opt = _2.defaults(_2.clone(question), {
        validate: () => !0,
        filter: (val) => val,
        when: () => !0,
        suffix: "",
        prefix: chalk2.green("?")
      }), this.opt.name || this.throwParamError("name"), this.opt.message || (this.opt.message = this.opt.name + ":"), Array.isArray(this.opt.choices) && (this.opt.choices = new Choices(this.opt.choices, answers)), this.rl = rl, this.screen = new ScreenManager(this.rl);
    }
    /**
     * Start the Inquiry session and manage output value filtering
     * @return {Promise}
     */
    run() {
      return new Promise((resolve2) => {
        this._run((value) => resolve2(value));
      });
    }
    // Default noop (this one should be overwritten in prompts)
    _run(cb) {
      cb();
    }
    /**
     * Throw an error telling a required parameter is missing
     * @param  {String} name Name of the missing param
     * @return {Throw Error}
     */
    throwParamError(name) {
      throw new Error("You must provide a `" + name + "` parameter");
    }
    /**
     * Called when the UI closes. Override to do any specific cleanup necessary
     */
    close() {
      this.screen.releaseCursor();
    }
    /**
     * Run the provided validation method each time a submit event occur.
     * @param  {Rx.Observable} submit - submit event flow
     * @return {Object}        Object containing two observables: `success` and `error`
     */
    handleSubmitEvents(submit) {
      var self2 = this, validate = runAsync2(this.opt.validate), asyncFilter = runAsync2(this.opt.filter), validation = submit.pipe(
        flatMap2(
          (value) => asyncFilter(value, self2.answers).then(
            (filteredValue) => validate(filteredValue, self2.answers).then(
              (isValid) => ({ isValid, value: filteredValue }),
              (err) => ({ isValid: err })
            ),
            (err) => ({ isValid: err })
          )
        ),
        share2()
      ), success = validation.pipe(
        filter2((state2) => state2.isValid === !0),
        take2(1)
      ), error2 = validation.pipe(
        filter2((state2) => state2.isValid !== !0),
        takeUntil2(success)
      );
      return {
        success,
        error: error2
      };
    }
    /**
     * Generate the prompt question string
     * @return {String} prompt question string
     */
    getQuestion() {
      var message = this.opt.prefix + " " + chalk2.bold(this.opt.message) + this.opt.suffix + chalk2.reset(" ");
      return this.opt.default != null && this.status !== "answered" && (this.opt.type === "password" ? message += chalk2.italic.dim("[hidden] ") : message += chalk2.dim("(" + this.opt.default + ") ")), message;
    }
  }
  return base = Prompt, base;
}
var events, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  var { fromEvent: fromEvent2 } = require$$4$1, { filter: filter2, map: map2, share: share2 } = require$$1$1;
  function normalizeKeypressEvents(value, key2) {
    return { value, key: key2 || {} };
  }
  return events = function(rl) {
    var keypress = fromEvent2(rl.input, "keypress", normalizeKeypressEvents).pipe(filter2(({ key: key2 }) => key2.name !== "enter" && key2.name !== "return"));
    return {
      line: fromEvent2(rl, "line"),
      keypress,
      normalizedUpKey: keypress.pipe(
        filter2(
          ({ key: key2 }) => key2.name === "up" || key2.name === "k" || key2.name === "p" && key2.ctrl
        ),
        share2()
      ),
      normalizedDownKey: keypress.pipe(
        filter2(
          ({ key: key2 }) => key2.name === "down" || key2.name === "j" || key2.name === "n" && key2.ctrl
        ),
        share2()
      ),
      numberKey: keypress.pipe(
        filter2((e) => e.value && "123456789".indexOf(e.value) >= 0),
        map2((e) => Number(e.value)),
        share2()
      ),
      spaceKey: keypress.pipe(
        filter2(({ key: key2 }) => key2 && key2.name === "space"),
        share2()
      ),
      aKey: keypress.pipe(
        filter2(({ key: key2 }) => key2 && key2.name === "a"),
        share2()
      ),
      iKey: keypress.pipe(
        filter2(({ key: key2 }) => key2 && key2.name === "i"),
        share2()
      )
    };
  }, events;
}
var paginator, hasRequiredPaginator;
function requirePaginator() {
  if (hasRequiredPaginator) return paginator;
  hasRequiredPaginator = 1;
  var _2 = lodashExports, chalk2 = chalk__default.default;
  class Paginator {
    constructor(screen) {
      this.pointer = 0, this.lastIndex = 0, this.screen = screen;
    }
    paginate(output, active, pageSize) {
      pageSize = pageSize || 7;
      var middleOfList = Math.floor(pageSize / 2), lines2 = output.split(`
`);
      if (this.screen && (lines2 = this.screen.breakLines(lines2), active = _2.sum(lines2.map((lineParts) => lineParts.length).splice(0, active)), lines2 = _2.flatten(lines2)), lines2.length <= pageSize)
        return output;
      this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize && (this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex)), this.lastIndex = active;
      var infinite = _2.flatten([lines2, lines2, lines2]), topIndex = Math.max(0, active + lines2.length - this.pointer), section = infinite.splice(topIndex, pageSize).join(`
`);
      return section + `
` + chalk2.dim("(Move up and down to reveal more choices)");
    }
  }
  return paginator = Paginator, paginator;
}
var list, hasRequiredList;
function requireList() {
  if (hasRequiredList) return list;
  hasRequiredList = 1;
  var _2 = lodashExports, chalk2 = chalk__default.default, figures2 = figures_1, cliCursor2 = requireCliCursor(), runAsync2 = runAsyncExports, { flatMap: flatMap2, map: map2, take: take2, takeUntil: takeUntil2 } = require$$1$1, Base2 = requireBase(), observe = requireEvents(), Paginator = requirePaginator();
  class ListPrompt extends Base2 {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), this.firstRender = !0, this.selected = 0;
      var def = this.opt.default;
      if (_2.isNumber(def) && def >= 0 && def < this.opt.choices.realLength)
        this.selected = def;
      else if (!_2.isNumber(def) && def != null) {
        let index = _2.findIndex(this.opt.choices.realChoices, ({ value }) => value === def);
        this.selected = Math.max(index, 0);
      }
      this.opt.default = null, this.paginator = new Paginator(this.screen);
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var self2 = this, events2 = observe(this.rl);
      return events2.normalizedUpKey.pipe(takeUntil2(events2.line)).forEach(this.onUpKey.bind(this)), events2.normalizedDownKey.pipe(takeUntil2(events2.line)).forEach(this.onDownKey.bind(this)), events2.numberKey.pipe(takeUntil2(events2.line)).forEach(this.onNumberKey.bind(this)), events2.line.pipe(
        take2(1),
        map2(this.getCurrentValue.bind(this)),
        flatMap2((value) => runAsync2(self2.opt.filter)(value).catch((err) => err))
      ).forEach(this.onSubmit.bind(this)), cliCursor2.hide(), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {ListPrompt} self
     */
    render() {
      var message = this.getQuestion();
      if (this.firstRender && (message += chalk2.dim("(Use arrow keys)")), this.status === "answered")
        message += chalk2.cyan(this.opt.choices.getChoice(this.selected).short);
      else {
        var choicesStr = listRender(this.opt.choices, this.selected), indexPosition = this.opt.choices.indexOf(
          this.opt.choices.getChoice(this.selected)
        );
        message += `
` + this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize);
      }
      this.firstRender = !1, this.screen.render(message);
    }
    /**
     * When user press `enter` key
     */
    onSubmit(value) {
      this.status = "answered", this.render(), this.screen.done(), cliCursor2.show(), this.done(value);
    }
    getCurrentValue() {
      return this.opt.choices.getChoice(this.selected).value;
    }
    /**
     * When user press a key
     */
    onUpKey() {
      var len = this.opt.choices.realLength;
      this.selected = this.selected > 0 ? this.selected - 1 : len - 1, this.render();
    }
    onDownKey() {
      var len = this.opt.choices.realLength;
      this.selected = this.selected < len - 1 ? this.selected + 1 : 0, this.render();
    }
    onNumberKey(input2) {
      input2 <= this.opt.choices.realLength && (this.selected = input2 - 1), this.render();
    }
  }
  function listRender(choices2, pointer) {
    var output = "", separatorOffset = 0;
    return choices2.forEach((choice2, i2) => {
      if (choice2.type === "separator") {
        separatorOffset++, output += "  " + choice2 + `
`;
        return;
      }
      if (choice2.disabled) {
        separatorOffset++, output += "  - " + choice2.name, output += " (" + (_2.isString(choice2.disabled) ? choice2.disabled : "Disabled") + ")", output += `
`;
        return;
      }
      var isSelected = i2 - separatorOffset === pointer, line3 = (isSelected ? figures2.pointer + " " : "  ") + choice2.name;
      isSelected && (line3 = chalk2.cyan(line3)), output += line3 + ` 
`;
    }), output.replace(/\n$/, "");
  }
  return list = ListPrompt, list;
}
var input, hasRequiredInput;
function requireInput() {
  if (hasRequiredInput) return input;
  hasRequiredInput = 1;
  var chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base2 = requireBase(), observe = requireEvents();
  class InputPrompt extends Base2 {
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), submit = events2.line.pipe(map2(this.filterInput.bind(this))), validation = this.handleSubmitEvents(submit);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {InputPrompt} self
     */
    render(error2) {
      var bottomContent = "", appendContent = "", message = this.getQuestion(), transformer = this.opt.transformer, isFinal = this.status === "answered";
      isFinal ? appendContent = this.answer : appendContent = this.rl.line, transformer ? message += transformer(appendContent, this.answers, { isFinal }) : message += isFinal ? chalk2.cyan(appendContent) : appendContent, error2 && (bottomContent = chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    filterInput(input2) {
      return input2 || (this.opt.default == null ? "" : this.opt.default);
    }
    onEnd(state2) {
      this.answer = state2.value, this.status = "answered", this.render(), this.screen.done(), this.done(state2.value);
    }
    onError(state2) {
      this.rl.line += state2.value, this.rl.cursor += state2.value.length, this.render(state2.isValid);
    }
    /**
     * When user press a key
     */
    onKeypress() {
      this.opt.default && (this.opt.default = void 0), this.render();
    }
  }
  return input = InputPrompt, input;
}
var number, hasRequiredNumber;
function requireNumber() {
  if (hasRequiredNumber) return number;
  hasRequiredNumber = 1;
  var Input = requireInput();
  class NumberPrompt extends Input {
    filterInput(input2) {
      if (input2 && typeof input2 == "string") {
        input2 = input2.trim();
        let numberMatch = input2.match(/(^-?\d+|^\d+\.\d*|^\d*\.\d+)(e\d+)?$/);
        if (numberMatch)
          return Number(numberMatch[0]);
      }
      return this.opt.default == null ? NaN : this.opt.default;
    }
  }
  return number = NumberPrompt, number;
}
var confirm, hasRequiredConfirm;
function requireConfirm() {
  if (hasRequiredConfirm) return confirm;
  hasRequiredConfirm = 1;
  var _2 = lodashExports, chalk2 = chalk__default.default, { take: take2, takeUntil: takeUntil2 } = require$$1$1, Base2 = requireBase(), observe = requireEvents();
  class ConfirmPrompt extends Base2 {
    constructor(questions, rl, answers) {
      super(questions, rl, answers);
      var rawDefault = !0;
      return _2.extend(this.opt, {
        filter: function(input2) {
          var value = rawDefault;
          return input2 != null && input2 !== "" && (value = /^y(es)?/i.test(input2)), value;
        }
      }), _2.isBoolean(this.opt.default) && (rawDefault = this.opt.default), this.opt.default = rawDefault ? "Y/n" : "y/N", this;
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb   Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl);
      return events2.keypress.pipe(takeUntil2(events2.line)).forEach(this.onKeypress.bind(this)), events2.line.pipe(take2(1)).forEach(this.onEnd.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {ConfirmPrompt} self
     */
    render(answer) {
      var message = this.getQuestion();
      return typeof answer == "boolean" ? message += chalk2.cyan(answer ? "Yes" : "No") : message += this.rl.line, this.screen.render(message), this;
    }
    /**
     * When user press `enter` key
     */
    onEnd(input2) {
      this.status = "answered";
      var output = this.opt.filter(input2);
      this.render(output), this.screen.done(), this.done(output);
    }
    /**
     * When user press a key
     */
    onKeypress() {
      this.render();
    }
  }
  return confirm = ConfirmPrompt, confirm;
}
var rawlist, hasRequiredRawlist;
function requireRawlist() {
  if (hasRequiredRawlist) return rawlist;
  hasRequiredRawlist = 1;
  var _2 = lodashExports, chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base2 = requireBase(), Separator2 = separator, observe = requireEvents(), Paginator = requirePaginator();
  class RawListPrompt extends Base2 {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), this.opt.validChoices = this.opt.choices.filter(Separator2.exclude), this.selected = 0, this.rawDefault = 0, _2.extend(this.opt, {
        validate: function(val) {
          return val != null;
        }
      });
      var def = this.opt.default;
      if (_2.isNumber(def) && def >= 0 && def < this.opt.choices.realLength)
        this.selected = def, this.rawDefault = def;
      else if (!_2.isNumber(def) && def != null) {
        let index = _2.findIndex(this.opt.choices.realChoices, ({ value }) => value === def), safeIndex = Math.max(index, 0);
        this.selected = safeIndex, this.rawDefault = safeIndex;
      }
      this.opt.default = null, this.paginator = new Paginator();
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), submit = events2.line.pipe(map2(this.getCurrentValue.bind(this))), validation = this.handleSubmitEvents(submit);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), events2.normalizedUpKey.pipe(takeUntil2(events2.line)).forEach(this.onUpKey.bind(this)), events2.normalizedDownKey.pipe(takeUntil2(events2.line)).forEach(this.onDownKey.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {RawListPrompt} self
     */
    render(error2) {
      var message = this.getQuestion(), bottomContent = "";
      if (this.status === "answered")
        message += chalk2.cyan(this.answer);
      else {
        var choicesStr = renderChoices(this.opt.choices, this.selected);
        message += `
` + this.paginator.paginate(choicesStr, this.selected, this.opt.pageSize), message += `
  Answer: `;
      }
      message += this.rl.line, error2 && (bottomContent = `
` + chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    getCurrentValue(index) {
      index == null || index === "" ? index = this.rawDefault : index -= 1;
      var choice2 = this.opt.choices.getChoice(index);
      return choice2 ? choice2.value : null;
    }
    onEnd(state2) {
      this.status = "answered", this.answer = state2.value, this.render(), this.screen.done(), this.done(state2.value);
    }
    onError() {
      this.render("Please enter a valid index");
    }
    /**
     * When user press a key
     */
    onKeypress() {
      var index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;
      this.opt.choices.getChoice(index) ? this.selected = index : this.selected = void 0, this.render();
    }
    /**
     * When user press up key
     */
    onUpKey() {
      this.onArrowKey("up");
    }
    /**
     * When user press down key
     */
    onDownKey() {
      this.onArrowKey("down");
    }
    /**
     * When user press up or down key
     * @param {String} type Arrow type: up or down
     */
    onArrowKey(type2) {
      var index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;
      type2 === "up" ? index = index === 0 ? this.opt.choices.length - 1 : index - 1 : index = index === this.opt.choices.length - 1 ? 0 : index + 1, this.rl.line = String(index + 1), this.onKeypress();
    }
  }
  function renderChoices(choices2, pointer) {
    var output = "", separatorOffset = 0;
    return choices2.forEach(function(choice2, i2) {
      if (output += `
  `, choice2.type === "separator") {
        separatorOffset++, output += " " + choice2;
        return;
      }
      var index = i2 - separatorOffset, display = index + 1 + ") " + choice2.name;
      index === pointer && (display = chalk2.cyan(display)), output += display;
    }), output;
  }
  return rawlist = RawListPrompt, rawlist;
}
var expand, hasRequiredExpand;
function requireExpand() {
  if (hasRequiredExpand) return expand;
  hasRequiredExpand = 1;
  var _2 = lodashExports, chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base2 = requireBase(), Separator2 = separator, observe = requireEvents(), Paginator = requirePaginator();
  class ExpandPrompt extends Base2 {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), this.validateChoices(this.opt.choices), this.opt.choices.push({
        key: "h",
        name: "Help, list all options",
        value: "help"
      }), this.opt.validate = (choice2) => choice2 == null ? "Please enter a valid command" : choice2 !== "help", this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default), this.paginator = new Paginator(this.screen);
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), validation = this.handleSubmitEvents(
        events2.line.pipe(map2(this.getCurrentValue.bind(this)))
      );
      return validation.success.forEach(this.onSubmit.bind(this)), validation.error.forEach(this.onError.bind(this)), this.keypressObs = events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {ExpandPrompt} self
     */
    render(error2, hint) {
      var message = this.getQuestion(), bottomContent = "";
      if (this.status === "answered")
        message += chalk2.cyan(this.answer);
      else if (this.status === "expanded") {
        var choicesStr = renderChoices(this.opt.choices, this.selectedKey);
        message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize), message += `
  Answer: `;
      }
      message += this.rl.line, error2 && (bottomContent = chalk2.red(">> ") + error2), hint && (bottomContent = chalk2.cyan(">> ") + hint), this.screen.render(message, bottomContent);
    }
    getCurrentValue(input2) {
      input2 || (input2 = this.rawDefault);
      var selected = this.opt.choices.where({ key: input2.toLowerCase().trim() })[0];
      return selected ? selected.value : null;
    }
    /**
     * Generate the prompt choices string
     * @return {String}  Choices string
     */
    getChoices() {
      var output = "";
      return this.opt.choices.forEach((choice2) => {
        if (output += `
  `, choice2.type === "separator") {
          output += " " + choice2;
          return;
        }
        var choiceStr = choice2.key + ") " + choice2.name;
        this.selectedKey === choice2.key && (choiceStr = chalk2.cyan(choiceStr)), output += choiceStr;
      }), output;
    }
    onError(state2) {
      if (state2.value === "help") {
        this.selectedKey = "", this.status = "expanded", this.render();
        return;
      }
      this.render(state2.isValid);
    }
    /**
     * When user press `enter` key
     */
    onSubmit(state2) {
      this.status = "answered";
      var choice2 = this.opt.choices.where({ value: state2.value })[0];
      this.answer = choice2.short || choice2.name, this.render(), this.screen.done(), this.done(state2.value);
    }
    /**
     * When user press a key
     */
    onKeypress() {
      this.selectedKey = this.rl.line.toLowerCase();
      var selected = this.opt.choices.where({ key: this.selectedKey })[0];
      this.status === "expanded" ? this.render() : this.render(null, selected ? selected.name : null);
    }
    /**
     * Validate the choices
     * @param {Array} choices
     */
    validateChoices(choices2) {
      var formatError2, errors2 = [], keymap = {};
      if (choices2.filter(Separator2.exclude).forEach((choice2) => {
        (!choice2.key || choice2.key.length !== 1) && (formatError2 = !0), keymap[choice2.key] && errors2.push(choice2.key), keymap[choice2.key] = !0, choice2.key = String(choice2.key).toLowerCase();
      }), formatError2)
        throw new Error(
          "Format error: `key` param must be a single letter and is required."
        );
      if (keymap.h)
        throw new Error(
          "Reserved key error: `key` param cannot be `h` - this value is reserved."
        );
      if (errors2.length)
        throw new Error(
          "Duplicate key error: `key` param must be unique. Duplicates: " + _2.uniq(errors2).join(", ")
        );
    }
    /**
     * Generate a string out of the choices keys
     * @param  {Array}  choices
     * @param  {Number|String} default - the choice index or name to capitalize
     * @return {String} The rendered choices key string
     */
    generateChoicesString(choices2, defaultChoice) {
      var defIndex = choices2.realLength - 1;
      if (_2.isNumber(defaultChoice) && this.opt.choices.getChoice(defaultChoice))
        defIndex = defaultChoice;
      else if (_2.isString(defaultChoice)) {
        let index = _2.findIndex(
          choices2.realChoices,
          ({ value }) => value === defaultChoice
        );
        defIndex = index === -1 ? defIndex : index;
      }
      var defStr = this.opt.choices.pluck("key");
      return this.rawDefault = defStr[defIndex], defStr[defIndex] = String(defStr[defIndex]).toUpperCase(), defStr.join("");
    }
  }
  function renderChoices(choices2, pointer) {
    var output = "";
    return choices2.forEach((choice2) => {
      if (output += `
  `, choice2.type === "separator") {
        output += " " + choice2;
        return;
      }
      var choiceStr = choice2.key + ") " + choice2.name;
      pointer === choice2.key && (choiceStr = chalk2.cyan(choiceStr)), output += choiceStr;
    }), output;
  }
  return expand = ExpandPrompt, expand;
}
var checkbox, hasRequiredCheckbox;
function requireCheckbox() {
  if (hasRequiredCheckbox) return checkbox;
  hasRequiredCheckbox = 1;
  var _2 = lodashExports, chalk2 = chalk__default.default, cliCursor2 = requireCliCursor(), figures2 = figures_1, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base2 = requireBase(), observe = requireEvents(), Paginator = requirePaginator();
  class CheckboxPrompt extends Base2 {
    constructor(questions, rl, answers) {
      super(questions, rl, answers), this.opt.choices || this.throwParamError("choices"), _2.isArray(this.opt.default) && this.opt.choices.forEach(function(choice2) {
        this.opt.default.indexOf(choice2.value) >= 0 && (choice2.checked = !0);
      }, this), this.pointer = 0, this.opt.default = null, this.paginator = new Paginator(this.screen);
    }
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), validation = this.handleSubmitEvents(
        events2.line.pipe(map2(this.getCurrentValue.bind(this)))
      );
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.normalizedUpKey.pipe(takeUntil2(validation.success)).forEach(this.onUpKey.bind(this)), events2.normalizedDownKey.pipe(takeUntil2(validation.success)).forEach(this.onDownKey.bind(this)), events2.numberKey.pipe(takeUntil2(validation.success)).forEach(this.onNumberKey.bind(this)), events2.spaceKey.pipe(takeUntil2(validation.success)).forEach(this.onSpaceKey.bind(this)), events2.aKey.pipe(takeUntil2(validation.success)).forEach(this.onAllKey.bind(this)), events2.iKey.pipe(takeUntil2(validation.success)).forEach(this.onInverseKey.bind(this)), cliCursor2.hide(), this.render(), this.firstRender = !1, this;
    }
    /**
     * Render the prompt to screen
     * @return {CheckboxPrompt} self
     */
    render(error2) {
      var message = this.getQuestion(), bottomContent = "";
      if (this.spaceKeyPressed || (message += "(Press " + chalk2.cyan.bold("<space>") + " to select, " + chalk2.cyan.bold("<a>") + " to toggle all, " + chalk2.cyan.bold("<i>") + " to invert selection)"), this.status === "answered")
        message += chalk2.cyan(this.selection.join(", "));
      else {
        var choicesStr = renderChoices(this.opt.choices, this.pointer), indexPosition = this.opt.choices.indexOf(
          this.opt.choices.getChoice(this.pointer)
        );
        message += `
` + this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize);
      }
      error2 && (bottomContent = chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    onEnd(state2) {
      this.status = "answered", this.render(), this.screen.done(), cliCursor2.show(), this.done(state2.value);
    }
    onError(state2) {
      this.render(state2.isValid);
    }
    getCurrentValue() {
      var choices2 = this.opt.choices.filter(function(choice2) {
        return !!choice2.checked && !choice2.disabled;
      });
      return this.selection = _2.map(choices2, "short"), _2.map(choices2, "value");
    }
    onUpKey() {
      var len = this.opt.choices.realLength;
      this.pointer = this.pointer > 0 ? this.pointer - 1 : len - 1, this.render();
    }
    onDownKey() {
      var len = this.opt.choices.realLength;
      this.pointer = this.pointer < len - 1 ? this.pointer + 1 : 0, this.render();
    }
    onNumberKey(input2) {
      input2 <= this.opt.choices.realLength && (this.pointer = input2 - 1, this.toggleChoice(this.pointer)), this.render();
    }
    onSpaceKey() {
      this.spaceKeyPressed = !0, this.toggleChoice(this.pointer), this.render();
    }
    onAllKey() {
      var shouldBeChecked = !!this.opt.choices.find(function(choice2) {
        return choice2.type !== "separator" && !choice2.checked;
      });
      this.opt.choices.forEach(function(choice2) {
        choice2.type !== "separator" && (choice2.checked = shouldBeChecked);
      }), this.render();
    }
    onInverseKey() {
      this.opt.choices.forEach(function(choice2) {
        choice2.type !== "separator" && (choice2.checked = !choice2.checked);
      }), this.render();
    }
    toggleChoice(index) {
      var item = this.opt.choices.getChoice(index);
      item !== void 0 && (this.opt.choices.getChoice(index).checked = !item.checked);
    }
  }
  function renderChoices(choices2, pointer) {
    var output = "", separatorOffset = 0;
    return choices2.forEach(function(choice2, i2) {
      if (choice2.type === "separator") {
        separatorOffset++, output += " " + choice2 + `
`;
        return;
      }
      if (choice2.disabled)
        separatorOffset++, output += " - " + choice2.name, output += " (" + (_2.isString(choice2.disabled) ? choice2.disabled : "Disabled") + ")";
      else {
        var line3 = getCheckbox(choice2.checked) + " " + choice2.name;
        i2 - separatorOffset === pointer ? output += chalk2.cyan(figures2.pointer + line3) : output += " " + line3;
      }
      output += `
`;
    }), output.replace(/\n$/, "");
  }
  function getCheckbox(checked) {
    return checked ? chalk2.green(figures2.radioOn) : figures2.radioOff;
  }
  return checkbox = CheckboxPrompt, checkbox;
}
var password, hasRequiredPassword;
function requirePassword() {
  if (hasRequiredPassword) return password;
  hasRequiredPassword = 1;
  var chalk2 = chalk__default.default, { map: map2, takeUntil: takeUntil2 } = require$$1$1, Base2 = requireBase(), observe = requireEvents();
  function mask(input2, maskChar) {
    return input2 = String(input2), maskChar = typeof maskChar == "string" ? maskChar : "*", input2.length === 0 ? "" : new Array(input2.length + 1).join(maskChar);
  }
  class PasswordPrompt extends Base2 {
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb;
      var events2 = observe(this.rl), submit = events2.line.pipe(map2(this.filterInput.bind(this))), validation = this.handleSubmitEvents(submit);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), events2.keypress.pipe(takeUntil2(validation.success)).forEach(this.onKeypress.bind(this)), this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {PasswordPrompt} self
     */
    render(error2) {
      var message = this.getQuestion(), bottomContent = "";
      this.status === "answered" ? message += this.opt.mask ? chalk2.cyan(mask(this.answer, this.opt.mask)) : chalk2.italic.dim("[hidden]") : this.opt.mask ? message += mask(this.rl.line || "", this.opt.mask) : message += chalk2.italic.dim("[input is hidden] "), error2 && (bottomContent = `
` + chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * When user press `enter` key
     */
    filterInput(input2) {
      return input2 || (this.opt.default == null ? "" : this.opt.default);
    }
    onEnd(state2) {
      this.status = "answered", this.answer = state2.value, this.render(), this.screen.done(), this.done(state2.value);
    }
    onError(state2) {
      this.render(state2.isValid);
    }
    onKeypress() {
      this.opt.default && (this.opt.default = void 0), this.render();
    }
  }
  return password = PasswordPrompt, password;
}
var main = {}, chardet = {}, match, hasRequiredMatch;
function requireMatch() {
  return hasRequiredMatch || (hasRequiredMatch = 1, match = function(det, rec, confidence, name, lang) {
    this.confidence = confidence, this.name = name || rec.name(det), this.lang = lang;
  }), match;
}
var utf8, hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  var Match = requireMatch();
  return utf8 = function() {
    this.name = function() {
      return "UTF-8";
    }, this.match = function(det) {
      var hasBOM = !1, numValid = 0, numInvalid = 0, input2 = det.fRawInput, trailBytes = 0, confidence;
      det.fRawLength >= 3 && (input2[0] & 255) == 239 && (input2[1] & 255) == 187 && (input2[2] & 255) == 191 && (hasBOM = !0);
      for (var i2 = 0; i2 < det.fRawLength; i2++) {
        var b = input2[i2];
        if (b & 128) {
          if ((b & 224) == 192)
            trailBytes = 1;
          else if ((b & 240) == 224)
            trailBytes = 2;
          else if ((b & 248) == 240)
            trailBytes = 3;
          else {
            if (numInvalid++, numInvalid > 5)
              break;
            trailBytes = 0;
          }
          for (; i2++, !(i2 >= det.fRawLength); ) {
            if ((input2[i2] & 192) != 128) {
              numInvalid++;
              break;
            }
            if (--trailBytes == 0) {
              numValid++;
              break;
            }
          }
        }
      }
      if (confidence = 0, hasBOM && numInvalid == 0)
        confidence = 100;
      else if (hasBOM && numValid > numInvalid * 10)
        confidence = 80;
      else if (numValid > 3 && numInvalid == 0)
        confidence = 100;
      else if (numValid > 0 && numInvalid == 0)
        confidence = 80;
      else if (numValid == 0 && numInvalid == 0)
        confidence = 10;
      else if (numValid > numInvalid * 10)
        confidence = 25;
      else
        return null;
      return new Match(det, this, confidence);
    };
  }, utf8;
}
var unicode = { exports: {} }, hasRequiredUnicode;
function requireUnicode() {
  return hasRequiredUnicode || (hasRequiredUnicode = 1, function(module2) {
    var util2 = require$$0__default$5.default, Match = requireMatch();
    module2.exports.UTF_16BE = function() {
      this.name = function() {
        return "UTF-16BE";
      }, this.match = function(det) {
        var input2 = det.fRawInput;
        return input2.length >= 2 && (input2[0] & 255) == 254 && (input2[1] & 255) == 255 ? new Match(det, this, 100) : null;
      };
    }, module2.exports.UTF_16LE = function() {
      this.name = function() {
        return "UTF-16LE";
      }, this.match = function(det) {
        var input2 = det.fRawInput;
        return input2.length >= 2 && (input2[0] & 255) == 255 && (input2[1] & 255) == 254 ? input2.length >= 4 && input2[2] == 0 && input2[3] == 0 ? null : new Match(det, this, 100) : null;
      };
    };
    function UTF_32() {
    }
    UTF_32.prototype.match = function(det) {
      var input2 = det.fRawInput, limit = det.fRawLength / 4 * 4, numValid = 0, numInvalid = 0, hasBOM = !1, confidence = 0;
      if (limit == 0)
        return null;
      this.getChar(input2, 0) == 65279 && (hasBOM = !0);
      for (var i2 = 0; i2 < limit; i2 += 4) {
        var ch = this.getChar(input2, i2);
        ch < 0 || ch >= 1114111 || ch >= 55296 && ch <= 57343 ? numInvalid += 1 : numValid += 1;
      }
      return hasBOM && numInvalid == 0 ? confidence = 100 : hasBOM && numValid > numInvalid * 10 ? confidence = 80 : numValid > 3 && numInvalid == 0 ? confidence = 100 : numValid > 0 && numInvalid == 0 ? confidence = 80 : numValid > numInvalid * 10 && (confidence = 25), confidence == 0 ? null : new Match(det, this, confidence);
    }, module2.exports.UTF_32BE = function() {
      this.name = function() {
        return "UTF-32BE";
      }, this.getChar = function(input2, index) {
        return (input2[index + 0] & 255) << 24 | (input2[index + 1] & 255) << 16 | (input2[index + 2] & 255) << 8 | input2[index + 3] & 255;
      };
    }, util2.inherits(module2.exports.UTF_32BE, UTF_32), module2.exports.UTF_32LE = function() {
      this.name = function() {
        return "UTF-32LE";
      }, this.getChar = function(input2, index) {
        return (input2[index + 3] & 255) << 24 | (input2[index + 2] & 255) << 16 | (input2[index + 1] & 255) << 8 | input2[index + 0] & 255;
      };
    }, util2.inherits(module2.exports.UTF_32LE, UTF_32);
  }(unicode)), unicode.exports;
}
var mbcs = { exports: {} }, hasRequiredMbcs;
function requireMbcs() {
  return hasRequiredMbcs || (hasRequiredMbcs = 1, function(module2) {
    var util2 = require$$0__default$5.default, Match = requireMatch();
    function binarySearch2(arr, searchValue) {
      function find2(arr2, searchValue2, left2, right2) {
        if (right2 < left2)
          return -1;
        var mid = Math.floor(left2 + right2 >>> 1);
        return searchValue2 > arr2[mid] ? find2(arr2, searchValue2, mid + 1, right2) : searchValue2 < arr2[mid] ? find2(arr2, searchValue2, left2, mid - 1) : mid;
      }
      return find2(arr, searchValue, 0, arr.length - 1);
    }
    function IteratedChar() {
      this.charValue = 0, this.index = 0, this.nextIndex = 0, this.error = !1, this.done = !1, this.reset = function() {
        this.charValue = 0, this.index = -1, this.nextIndex = 0, this.error = !1, this.done = !1;
      }, this.nextByte = function(det) {
        if (this.nextIndex >= det.fRawLength)
          return this.done = !0, -1;
        var byteValue = det.fRawInput[this.nextIndex++] & 255;
        return byteValue;
      };
    }
    function mbcs2() {
    }
    mbcs2.prototype.match = function(det) {
      var doubleByteCharCount = 0, commonCharCount = 0, badCharCount = 0, totalCharCount = 0, confidence = 0, iter = new IteratedChar();
      detectBlock: {
        for (iter.reset(); this.nextChar(iter, det); ) {
          if (totalCharCount++, iter.error)
            badCharCount++;
          else {
            var cv = iter.charValue & 4294967295;
            cv <= 255 || (doubleByteCharCount++, this.commonChars != null && binarySearch2(this.commonChars, cv) >= 0 && commonCharCount++);
          }
          if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount)
            break detectBlock;
        }
        if (doubleByteCharCount <= 10 && badCharCount == 0) {
          doubleByteCharCount == 0 && totalCharCount < 10 ? confidence = 0 : confidence = 10;
          break detectBlock;
        }
        if (doubleByteCharCount < 20 * badCharCount) {
          confidence = 0;
          break detectBlock;
        }
        if (this.commonChars == null)
          confidence = 30 + doubleByteCharCount - 20 * badCharCount, confidence > 100 && (confidence = 100);
        else {
          var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4), scaleFactor = 90 / maxVal;
          confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10), confidence = Math.min(confidence, 100);
        }
      }
      return confidence == 0 ? null : new Match(det, this, confidence);
    }, mbcs2.prototype.nextChar = function(iter, det) {
    }, module2.exports.sjis = function() {
      this.name = function() {
        return "Shift-JIS";
      }, this.language = function() {
        return "ja";
      }, this.commonChars = [
        33088,
        33089,
        33090,
        33093,
        33115,
        33129,
        33130,
        33141,
        33142,
        33440,
        33442,
        33444,
        33449,
        33450,
        33451,
        33453,
        33455,
        33457,
        33459,
        33461,
        33463,
        33469,
        33470,
        33473,
        33476,
        33477,
        33478,
        33480,
        33481,
        33484,
        33485,
        33500,
        33504,
        33511,
        33512,
        33513,
        33514,
        33520,
        33521,
        33601,
        33603,
        33614,
        33615,
        33624,
        33630,
        33634,
        33639,
        33653,
        33654,
        33673,
        33674,
        33675,
        33677,
        33683,
        36502,
        37882,
        38314
      ], this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex, iter.error = !1;
        var firstByte;
        if (firstByte = iter.charValue = iter.nextByte(det), firstByte < 0)
          return !1;
        if (firstByte <= 127 || firstByte > 160 && firstByte <= 223)
          return !0;
        var secondByte = iter.nextByte(det);
        return secondByte < 0 ? !1 : (iter.charValue = firstByte << 8 | secondByte, secondByte >= 64 && secondByte <= 127 || secondByte >= 128 && secondByte <= 255 || (iter.error = !0), !0);
      };
    }, util2.inherits(module2.exports.sjis, mbcs2), module2.exports.big5 = function() {
      this.name = function() {
        return "Big5";
      }, this.language = function() {
        return "zh";
      }, this.commonChars = [
        41280,
        41281,
        41282,
        41283,
        41287,
        41289,
        41333,
        41334,
        42048,
        42054,
        42055,
        42056,
        42065,
        42068,
        42071,
        42084,
        42090,
        42092,
        42103,
        42147,
        42148,
        42151,
        42177,
        42190,
        42193,
        42207,
        42216,
        42237,
        42304,
        42312,
        42328,
        42345,
        42445,
        42471,
        42583,
        42593,
        42594,
        42600,
        42608,
        42664,
        42675,
        42681,
        42707,
        42715,
        42726,
        42738,
        42816,
        42833,
        42841,
        42970,
        43171,
        43173,
        43181,
        43217,
        43219,
        43236,
        43260,
        43456,
        43474,
        43507,
        43627,
        43706,
        43710,
        43724,
        43772,
        44103,
        44111,
        44208,
        44242,
        44377,
        44745,
        45024,
        45290,
        45423,
        45747,
        45764,
        45935,
        46156,
        46158,
        46412,
        46501,
        46525,
        46544,
        46552,
        46705,
        47085,
        47207,
        47428,
        47832,
        47940,
        48033,
        48593,
        49860,
        50105,
        50240,
        50271
      ], this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex, iter.error = !1;
        var firstByte = iter.charValue = iter.nextByte(det);
        if (firstByte < 0)
          return !1;
        if (firstByte <= 127 || firstByte == 255)
          return !0;
        var secondByte = iter.nextByte(det);
        return secondByte < 0 ? !1 : (iter.charValue = iter.charValue << 8 | secondByte, (secondByte < 64 || secondByte == 127 || secondByte == 255) && (iter.error = !0), !0);
      };
    }, util2.inherits(module2.exports.big5, mbcs2);
    function eucNextChar(iter, det) {
      iter.index = iter.nextIndex, iter.error = !1;
      var firstByte = 0, secondByte = 0, thirdByte = 0;
      buildChar: {
        if (firstByte = iter.charValue = iter.nextByte(det), firstByte < 0) {
          iter.done = !0;
          break buildChar;
        }
        if (firstByte <= 141)
          break buildChar;
        if (secondByte = iter.nextByte(det), iter.charValue = iter.charValue << 8 | secondByte, firstByte >= 161 && firstByte <= 254) {
          secondByte < 161 && (iter.error = !0);
          break buildChar;
        }
        if (firstByte == 142) {
          secondByte < 161 && (iter.error = !0);
          break buildChar;
        }
        firstByte == 143 && (thirdByte = iter.nextByte(det), iter.charValue = iter.charValue << 8 | thirdByte, thirdByte < 161 && (iter.error = !0));
      }
      return iter.done == !1;
    }
    module2.exports.euc_jp = function() {
      this.name = function() {
        return "EUC-JP";
      }, this.language = function() {
        return "ja";
      }, this.commonChars = [
        41377,
        41378,
        41379,
        41382,
        41404,
        41418,
        41419,
        41430,
        41431,
        42146,
        42148,
        42150,
        42152,
        42154,
        42155,
        42156,
        42157,
        42159,
        42161,
        42163,
        42165,
        42167,
        42169,
        42171,
        42173,
        42175,
        42176,
        42177,
        42179,
        42180,
        42182,
        42183,
        42184,
        42185,
        42186,
        42187,
        42190,
        42191,
        42192,
        42206,
        42207,
        42209,
        42210,
        42212,
        42216,
        42217,
        42218,
        42219,
        42220,
        42223,
        42226,
        42227,
        42402,
        42403,
        42404,
        42406,
        42407,
        42410,
        42413,
        42415,
        42416,
        42419,
        42421,
        42423,
        42424,
        42425,
        42431,
        42435,
        42438,
        42439,
        42440,
        42441,
        42443,
        42448,
        42453,
        42454,
        42455,
        42462,
        42464,
        42465,
        42469,
        42473,
        42474,
        42475,
        42476,
        42477,
        42483,
        47273,
        47572,
        47854,
        48072,
        48880,
        49079,
        50410,
        50940,
        51133,
        51896,
        51955,
        52188,
        52689
      ], this.nextChar = eucNextChar;
    }, util2.inherits(module2.exports.euc_jp, mbcs2), module2.exports.euc_kr = function() {
      this.name = function() {
        return "EUC-KR";
      }, this.language = function() {
        return "ko";
      }, this.commonChars = [
        45217,
        45235,
        45253,
        45261,
        45268,
        45286,
        45293,
        45304,
        45306,
        45308,
        45496,
        45497,
        45511,
        45527,
        45538,
        45994,
        46011,
        46274,
        46287,
        46297,
        46315,
        46501,
        46517,
        46527,
        46535,
        46569,
        46835,
        47023,
        47042,
        47054,
        47270,
        47278,
        47286,
        47288,
        47291,
        47337,
        47531,
        47534,
        47564,
        47566,
        47613,
        47800,
        47822,
        47824,
        47857,
        48103,
        48115,
        48125,
        48301,
        48314,
        48338,
        48374,
        48570,
        48576,
        48579,
        48581,
        48838,
        48840,
        48863,
        48878,
        48888,
        48890,
        49057,
        49065,
        49088,
        49124,
        49131,
        49132,
        49144,
        49319,
        49327,
        49336,
        49338,
        49339,
        49341,
        49351,
        49356,
        49358,
        49359,
        49366,
        49370,
        49381,
        49403,
        49404,
        49572,
        49574,
        49590,
        49622,
        49631,
        49654,
        49656,
        50337,
        50637,
        50862,
        51151,
        51153,
        51154,
        51160,
        51173,
        51373
      ], this.nextChar = eucNextChar;
    }, util2.inherits(module2.exports.euc_kr, mbcs2), module2.exports.gb_18030 = function() {
      this.name = function() {
        return "GB18030";
      }, this.language = function() {
        return "zh";
      }, this.nextChar = function(iter, det) {
        iter.index = iter.nextIndex, iter.error = !1;
        var firstByte = 0, secondByte = 0, thirdByte = 0, fourthByte = 0;
        buildChar: {
          if (firstByte = iter.charValue = iter.nextByte(det), firstByte < 0) {
            iter.done = !0;
            break buildChar;
          }
          if (firstByte <= 128)
            break buildChar;
          if (secondByte = iter.nextByte(det), iter.charValue = iter.charValue << 8 | secondByte, firstByte >= 129 && firstByte <= 254) {
            if (secondByte >= 64 && secondByte <= 126 || secondByte >= 80 && secondByte <= 254)
              break buildChar;
            if (secondByte >= 48 && secondByte <= 57 && (thirdByte = iter.nextByte(det), thirdByte >= 129 && thirdByte <= 254 && (fourthByte = iter.nextByte(det), fourthByte >= 48 && fourthByte <= 57))) {
              iter.charValue = iter.charValue << 16 | thirdByte << 8 | fourthByte;
              break buildChar;
            }
            iter.error = !0;
            break buildChar;
          }
        }
        return iter.done == !1;
      }, this.commonChars = [
        41377,
        41378,
        41379,
        41380,
        41392,
        41393,
        41457,
        41459,
        41889,
        41900,
        41914,
        45480,
        45496,
        45502,
        45755,
        46025,
        46070,
        46323,
        46525,
        46532,
        46563,
        46767,
        46804,
        46816,
        47010,
        47016,
        47037,
        47062,
        47069,
        47284,
        47327,
        47350,
        47531,
        47561,
        47576,
        47610,
        47613,
        47821,
        48039,
        48086,
        48097,
        48122,
        48316,
        48347,
        48382,
        48588,
        48845,
        48861,
        49076,
        49094,
        49097,
        49332,
        49389,
        49611,
        49883,
        50119,
        50396,
        50410,
        50636,
        50935,
        51192,
        51371,
        51403,
        51413,
        51431,
        51663,
        51706,
        51889,
        51893,
        51911,
        51920,
        51926,
        51957,
        51965,
        52460,
        52728,
        52906,
        52932,
        52946,
        52965,
        53173,
        53186,
        53206,
        53442,
        53445,
        53456,
        53460,
        53671,
        53930,
        53938,
        53941,
        53947,
        53972,
        54211,
        54224,
        54269,
        54466,
        54490,
        54754,
        54992
      ];
    }, util2.inherits(module2.exports.gb_18030, mbcs2);
  }(mbcs)), mbcs.exports;
}
var sbcs = { exports: {} }, hasRequiredSbcs;
function requireSbcs() {
  return hasRequiredSbcs || (hasRequiredSbcs = 1, function(module2) {
    var util2 = require$$0__default$5.default, Match = requireMatch();
    function NGramParser(theNgramList, theByteMap) {
      var N_GRAM_MASK = 16777215;
      this.byteIndex = 0, this.ngram = 0, this.ngramList = theNgramList, this.byteMap = theByteMap, this.ngramCount = 0, this.hitCount = 0, this.search = function(table, value) {
        var index = 0;
        return table[index + 32] <= value && (index += 32), table[index + 16] <= value && (index += 16), table[index + 8] <= value && (index += 8), table[index + 4] <= value && (index += 4), table[index + 2] <= value && (index += 2), table[index + 1] <= value && (index += 1), table[index] > value && (index -= 1), index < 0 || table[index] != value ? -1 : index;
      }, this.lookup = function(thisNgram) {
        this.ngramCount += 1, this.search(this.ngramList, thisNgram) >= 0 && (this.hitCount += 1);
      }, this.addByte = function(b) {
        this.ngram = (this.ngram << 8) + (b & 255) & N_GRAM_MASK, this.lookup(this.ngram);
      }, this.nextByte = function(det) {
        return this.byteIndex >= det.fInputLen ? -1 : det.fInputBytes[this.byteIndex++] & 255;
      }, this.parse = function(det, spaceCh) {
        var b, ignoreSpace = !1;
        for (this.spaceChar = spaceCh; (b = this.nextByte(det)) >= 0; ) {
          var mb = this.byteMap[b];
          mb != 0 && (mb == this.spaceChar && ignoreSpace || this.addByte(mb), ignoreSpace = mb == this.spaceChar);
        }
        this.addByte(this.spaceChar);
        var rawPercent = this.hitCount / this.ngramCount;
        return rawPercent > 0.33 ? 98 : Math.floor(rawPercent * 300);
      };
    }
    function NGramsPlusLang(la, ng) {
      this.fLang = la, this.fNGrams = ng;
    }
    function sbcs2() {
    }
    sbcs2.prototype.spaceChar = 32, sbcs2.prototype.ngrams = function() {
    }, sbcs2.prototype.byteMap = function() {
    }, sbcs2.prototype.match = function(det) {
      var ngrams = this.ngrams(), multiple = Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang;
      if (!multiple) {
        var parser2 = new NGramParser(ngrams, this.byteMap()), confidence = parser2.parse(det, this.spaceChar);
        return confidence <= 0 ? null : new Match(det, this, confidence);
      }
      for (var bestConfidenceSoFar = -1, lang = null, i2 = ngrams.length - 1; i2 >= 0; i2--) {
        var ngl = ngrams[i2], parser2 = new NGramParser(ngl.fNGrams, this.byteMap()), confidence = parser2.parse(det, this.spaceChar);
        confidence > bestConfidenceSoFar && (bestConfidenceSoFar = confidence, lang = ngl.fLang);
      }
      var name = this.name(det);
      return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
    }, module2.exports.ISO_8859_1 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          170,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          186,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          new NGramsPlusLang("da", [
            2122086,
            2122100,
            2122853,
            2123118,
            2123122,
            2123375,
            2123873,
            2124064,
            2125157,
            2125671,
            2126053,
            2126697,
            2126708,
            2126953,
            2127465,
            6383136,
            6385184,
            6385252,
            6386208,
            6386720,
            6579488,
            6579566,
            6579570,
            6579572,
            6627443,
            6644768,
            6644837,
            6647328,
            6647396,
            6648352,
            6648421,
            6648608,
            6648864,
            6713202,
            6776096,
            6776174,
            6776178,
            6907749,
            6908960,
            6909543,
            7038240,
            7039845,
            7103858,
            7104871,
            7105637,
            7169380,
            7234661,
            7234848,
            7235360,
            7235429,
            7300896,
            7302432,
            7303712,
            7398688,
            7479396,
            7479397,
            7479411,
            7496992,
            7566437,
            7610483,
            7628064,
            7628146,
            7629164,
            7759218
          ]),
          new NGramsPlusLang("de", [
            2122094,
            2122101,
            2122341,
            2122849,
            2122853,
            2122857,
            2123113,
            2123621,
            2123873,
            2124142,
            2125161,
            2126691,
            2126693,
            2127214,
            2127461,
            2127471,
            2127717,
            2128501,
            6448498,
            6514720,
            6514789,
            6514804,
            6578547,
            6579566,
            6579570,
            6580581,
            6627428,
            6627443,
            6646126,
            6646132,
            6647328,
            6648352,
            6648608,
            6776174,
            6841710,
            6845472,
            6906728,
            6907168,
            6909472,
            6909541,
            6911008,
            7104867,
            7105637,
            7217249,
            7217252,
            7217267,
            7234592,
            7234661,
            7234848,
            7235360,
            7235429,
            7238757,
            7479396,
            7496805,
            7497065,
            7562088,
            7566437,
            7610468,
            7628064,
            7628142,
            7628146,
            7695972,
            7695975,
            7759218
          ]),
          new NGramsPlusLang("en", [
            2122016,
            2122094,
            2122341,
            2122607,
            2123375,
            2123873,
            2123877,
            2124142,
            2125153,
            2125670,
            2125938,
            2126437,
            2126689,
            2126708,
            2126952,
            2126959,
            2127720,
            6383972,
            6384672,
            6385184,
            6385252,
            6386464,
            6386720,
            6386789,
            6386793,
            6561889,
            6561908,
            6627425,
            6627443,
            6627444,
            6644768,
            6647412,
            6648352,
            6648608,
            6713202,
            6840692,
            6841632,
            6841714,
            6906912,
            6909472,
            6909543,
            6909806,
            6910752,
            7217249,
            7217268,
            7234592,
            7235360,
            7238688,
            7300640,
            7302688,
            7303712,
            7496992,
            7500576,
            7544929,
            7544948,
            7561577,
            7566368,
            7610484,
            7628146,
            7628897,
            7628901,
            7629167,
            7630624,
            7631648
          ]),
          new NGramsPlusLang("es", [
            2122016,
            2122593,
            2122607,
            2122853,
            2123116,
            2123118,
            2123123,
            2124142,
            2124897,
            2124911,
            2125921,
            2125935,
            2125938,
            2126197,
            2126437,
            2126693,
            2127214,
            2128160,
            6365283,
            6365284,
            6365285,
            6365292,
            6365296,
            6382441,
            6382703,
            6384672,
            6386208,
            6386464,
            6515187,
            6516590,
            6579488,
            6579564,
            6582048,
            6627428,
            6627429,
            6627436,
            6646816,
            6647328,
            6647412,
            6648608,
            6648692,
            6907246,
            6943598,
            7102752,
            7106419,
            7217253,
            7238757,
            7282788,
            7282789,
            7302688,
            7303712,
            7303968,
            7364978,
            7435621,
            7495968,
            7497075,
            7544932,
            7544933,
            7544944,
            7562528,
            7628064,
            7630624,
            7693600,
            15953440
          ]),
          new NGramsPlusLang("fr", [
            2122101,
            2122607,
            2122849,
            2122853,
            2122869,
            2123118,
            2123124,
            2124897,
            2124901,
            2125921,
            2125935,
            2125938,
            2126197,
            2126693,
            2126703,
            2127214,
            2154528,
            6385268,
            6386793,
            6513952,
            6516590,
            6579488,
            6579571,
            6583584,
            6627425,
            6627427,
            6627428,
            6627429,
            6627436,
            6627440,
            6627443,
            6647328,
            6647412,
            6648352,
            6648608,
            6648864,
            6649202,
            6909806,
            6910752,
            6911008,
            7102752,
            7103776,
            7103859,
            7169390,
            7217252,
            7234848,
            7238432,
            7238688,
            7302688,
            7302772,
            7304562,
            7435621,
            7479404,
            7496992,
            7544929,
            7544932,
            7544933,
            7544940,
            7544944,
            7610468,
            7628064,
            7629167,
            7693600,
            7696928
          ]),
          new NGramsPlusLang("it", [
            2122092,
            2122600,
            2122607,
            2122853,
            2122857,
            2123040,
            2124140,
            2124142,
            2124897,
            2125925,
            2125938,
            2127214,
            6365283,
            6365284,
            6365296,
            6365299,
            6386799,
            6514789,
            6516590,
            6579564,
            6580512,
            6627425,
            6627427,
            6627428,
            6627433,
            6627436,
            6627440,
            6627443,
            6646816,
            6646892,
            6647412,
            6648352,
            6841632,
            6889569,
            6889571,
            6889572,
            6889587,
            6906144,
            6908960,
            6909472,
            6909806,
            7102752,
            7103776,
            7104800,
            7105633,
            7234848,
            7235872,
            7237408,
            7238757,
            7282785,
            7282788,
            7282793,
            7282803,
            7302688,
            7302757,
            7366002,
            7495968,
            7496992,
            7563552,
            7627040,
            7628064,
            7629088,
            7630624,
            8022383
          ]),
          new NGramsPlusLang("nl", [
            2122092,
            2122341,
            2122849,
            2122853,
            2122857,
            2123109,
            2123118,
            2123621,
            2123877,
            2124142,
            2125153,
            2125157,
            2125680,
            2126949,
            2127457,
            2127461,
            2127471,
            2127717,
            2128489,
            6381934,
            6381938,
            6385184,
            6385252,
            6386208,
            6386720,
            6514804,
            6579488,
            6579566,
            6579570,
            6627426,
            6627446,
            6645102,
            6645106,
            6647328,
            6648352,
            6648435,
            6648864,
            6776174,
            6841716,
            6907168,
            6909472,
            6909543,
            6910752,
            7217250,
            7217252,
            7217253,
            7217256,
            7217263,
            7217270,
            7234661,
            7235360,
            7302756,
            7303026,
            7303200,
            7303712,
            7562088,
            7566437,
            7610468,
            7628064,
            7628142,
            7628146,
            7758190,
            7759218,
            7761775
          ]),
          new NGramsPlusLang("no", [
            2122100,
            2122102,
            2122853,
            2123118,
            2123122,
            2123375,
            2123873,
            2124064,
            2125157,
            2125671,
            2126053,
            2126693,
            2126699,
            2126703,
            2126708,
            2126953,
            2127465,
            2155808,
            6385252,
            6386208,
            6386720,
            6579488,
            6579566,
            6579572,
            6627443,
            6644768,
            6647328,
            6647397,
            6648352,
            6648421,
            6648864,
            6648948,
            6713202,
            6776174,
            6908779,
            6908960,
            6909543,
            7038240,
            7039845,
            7103776,
            7105637,
            7169380,
            7169390,
            7217267,
            7234848,
            7235360,
            7235429,
            7237221,
            7300896,
            7302432,
            7303712,
            7398688,
            7479411,
            7496992,
            7565165,
            7566437,
            7610483,
            7628064,
            7628142,
            7628146,
            7629164,
            7631904,
            7631973,
            7759218
          ]),
          new NGramsPlusLang("pt", [
            2122016,
            2122607,
            2122849,
            2122853,
            2122863,
            2123040,
            2123123,
            2125153,
            2125423,
            2125600,
            2125921,
            2125935,
            2125938,
            2126197,
            2126437,
            2126693,
            2127213,
            6365281,
            6365283,
            6365284,
            6365296,
            6382693,
            6382703,
            6384672,
            6386208,
            6386273,
            6386464,
            6516589,
            6516590,
            6578464,
            6579488,
            6582048,
            6582131,
            6627425,
            6627428,
            6647072,
            6647412,
            6648608,
            6648692,
            6906144,
            6906721,
            7169390,
            7238757,
            7238767,
            7282785,
            7282787,
            7282788,
            7282789,
            7282800,
            7303968,
            7364978,
            7435621,
            7495968,
            7497075,
            7544929,
            7544932,
            7544933,
            7544944,
            7566433,
            7628064,
            7630624,
            7693600,
            14905120,
            15197039
          ]),
          new NGramsPlusLang("sv", [
            2122100,
            2122102,
            2122853,
            2123118,
            2123510,
            2123873,
            2124064,
            2124142,
            2124655,
            2125157,
            2125667,
            2126053,
            2126699,
            2126703,
            2126708,
            2126953,
            2127457,
            2127465,
            2155634,
            6382693,
            6385184,
            6385252,
            6386208,
            6386804,
            6514720,
            6579488,
            6579566,
            6579570,
            6579572,
            6644768,
            6647328,
            6648352,
            6648864,
            6747762,
            6776174,
            6909036,
            6909543,
            7037216,
            7105568,
            7169380,
            7217267,
            7233824,
            7234661,
            7235360,
            7235429,
            7235950,
            7299944,
            7302432,
            7302688,
            7398688,
            7479393,
            7479411,
            7495968,
            7564129,
            7565165,
            7610483,
            7627040,
            7628064,
            7628146,
            7629164,
            7631904,
            7758194,
            14971424,
            16151072
          ])
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1252" : "ISO-8859-1";
      };
    }, util2.inherits(module2.exports.ISO_8859_1, sbcs2), module2.exports.ISO_8859_2 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          177,
          32,
          179,
          32,
          181,
          182,
          32,
          32,
          185,
          186,
          187,
          188,
          32,
          190,
          191,
          32,
          177,
          32,
          179,
          32,
          181,
          182,
          183,
          32,
          185,
          186,
          187,
          188,
          32,
          190,
          191,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          32
        ];
      }, this.ngrams = function() {
        return [
          new NGramsPlusLang("cs", [
            2122016,
            2122361,
            2122863,
            2124389,
            2125409,
            2125413,
            2125600,
            2125668,
            2125935,
            2125938,
            2126072,
            2126447,
            2126693,
            2126703,
            2126708,
            2126959,
            2127392,
            2127481,
            2128481,
            6365296,
            6513952,
            6514720,
            6627440,
            6627443,
            6627446,
            6647072,
            6647533,
            6844192,
            6844260,
            6910836,
            6972704,
            7042149,
            7103776,
            7104800,
            7233824,
            7268640,
            7269408,
            7269664,
            7282800,
            7300206,
            7301737,
            7304052,
            7304480,
            7304801,
            7368548,
            7368554,
            7369327,
            7403621,
            7562528,
            7565173,
            7566433,
            7566441,
            7566446,
            7628146,
            7630573,
            7630624,
            7676016,
            12477728,
            14773997,
            15296623,
            15540336,
            15540339,
            15559968,
            16278884
          ]),
          new NGramsPlusLang("hu", [
            2122016,
            2122106,
            2122341,
            2123111,
            2123116,
            2123365,
            2123873,
            2123887,
            2124147,
            2124645,
            2124649,
            2124790,
            2124901,
            2125153,
            2125157,
            2125161,
            2125413,
            2126714,
            2126949,
            2156915,
            6365281,
            6365291,
            6365293,
            6365299,
            6384416,
            6385184,
            6388256,
            6447470,
            6448494,
            6645625,
            6646560,
            6646816,
            6646885,
            6647072,
            6647328,
            6648421,
            6648864,
            6648933,
            6648948,
            6781216,
            6844263,
            6909556,
            6910752,
            7020641,
            7075450,
            7169383,
            7170414,
            7217249,
            7233899,
            7234923,
            7234925,
            7238688,
            7300985,
            7544929,
            7567973,
            7567988,
            7568097,
            7596391,
            7610465,
            7631904,
            7659891,
            8021362,
            14773792,
            15299360
          ]),
          new NGramsPlusLang("pl", [
            2122618,
            2122863,
            2124064,
            2124389,
            2124655,
            2125153,
            2125161,
            2125409,
            2125417,
            2125668,
            2125935,
            2125938,
            2126697,
            2127648,
            2127721,
            2127737,
            2128416,
            2128481,
            6365296,
            6365303,
            6385257,
            6514720,
            6519397,
            6519417,
            6582048,
            6584937,
            6627440,
            6627443,
            6627447,
            6627450,
            6645615,
            6646304,
            6647072,
            6647401,
            6778656,
            6906144,
            6907168,
            6907242,
            7037216,
            7039264,
            7039333,
            7170405,
            7233824,
            7235937,
            7235941,
            7282800,
            7305057,
            7305065,
            7368556,
            7369313,
            7369327,
            7369338,
            7502437,
            7502457,
            7563754,
            7564137,
            7566433,
            7825765,
            7955304,
            7957792,
            8021280,
            8022373,
            8026400,
            15955744
          ]),
          new NGramsPlusLang("ro", [
            2122016,
            2122083,
            2122593,
            2122597,
            2122607,
            2122613,
            2122853,
            2122857,
            2124897,
            2125153,
            2125925,
            2125938,
            2126693,
            2126819,
            2127214,
            2144873,
            2158190,
            6365283,
            6365284,
            6386277,
            6386720,
            6386789,
            6386976,
            6513010,
            6516590,
            6518048,
            6546208,
            6579488,
            6627425,
            6627427,
            6627428,
            6627440,
            6627443,
            6644e3,
            6646048,
            6646885,
            6647412,
            6648692,
            6889569,
            6889571,
            6889572,
            6889584,
            6907168,
            6908192,
            6909472,
            7102752,
            7103776,
            7106418,
            7107945,
            7234848,
            7238770,
            7303712,
            7365998,
            7496992,
            7497057,
            7501088,
            7594784,
            7628064,
            7631477,
            7660320,
            7694624,
            7695392,
            12216608,
            15625760
          ])
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1250" : "ISO-8859-2";
      };
    }, util2.inherits(module2.exports.ISO_8859_2, sbcs2), module2.exports.ISO_8859_5 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          32,
          254,
          255,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          32,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          32,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          2150944,
          2151134,
          2151646,
          2152400,
          2152480,
          2153168,
          2153182,
          2153936,
          2153941,
          2154193,
          2154462,
          2154464,
          2154704,
          2154974,
          2154978,
          2155230,
          2156514,
          2158050,
          13688280,
          13689580,
          13884960,
          14015468,
          14015960,
          14016994,
          14017056,
          14164191,
          14210336,
          14211104,
          14216992,
          14407133,
          14407712,
          14413021,
          14536736,
          14538016,
          14538965,
          14538991,
          14540320,
          14540498,
          14557394,
          14557407,
          14557409,
          14602784,
          14602960,
          14603230,
          14604576,
          14605292,
          14605344,
          14606818,
          14671579,
          14672085,
          14672088,
          14672094,
          14733522,
          14734804,
          14803664,
          14803666,
          14803672,
          14806816,
          14865883,
          14868e3,
          14868192,
          14871584,
          15196894,
          15459616
        ];
      }, this.name = function(det) {
        return "ISO-8859-5";
      }, this.language = function() {
        return "ru";
      };
    }, util2.inherits(module2.exports.ISO_8859_5, sbcs2), module2.exports.ISO_8859_6 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32
        ];
      }, this.ngrams = function() {
        return [
          2148324,
          2148326,
          2148551,
          2152932,
          2154986,
          2155748,
          2156006,
          2156743,
          13050055,
          13091104,
          13093408,
          13095200,
          13100064,
          13100227,
          13100231,
          13100232,
          13100234,
          13100236,
          13100237,
          13100239,
          13100243,
          13100249,
          13100258,
          13100261,
          13100264,
          13100266,
          13100320,
          13100576,
          13100746,
          13115591,
          13181127,
          13181153,
          13181156,
          13181157,
          13181160,
          13246663,
          13574343,
          13617440,
          13705415,
          13748512,
          13836487,
          14229703,
          14279913,
          14805536,
          14950599,
          14993696,
          15001888,
          15002144,
          15016135,
          15058720,
          15059232,
          15066656,
          15081671,
          15147207,
          15189792,
          15255524,
          15263264,
          15278279,
          15343815,
          15343845,
          15343848,
          15386912,
          15388960,
          15394336
        ];
      }, this.name = function(det) {
        return "ISO-8859-6";
      }, this.language = function() {
        return "ar";
      };
    }, util2.inherits(module2.exports.ISO_8859_6, sbcs2), module2.exports.ISO_8859_7 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          161,
          162,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          220,
          32,
          221,
          222,
          223,
          32,
          252,
          32,
          253,
          254,
          192,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          32,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          32
        ];
      }, this.ngrams = function() {
        return [
          2154989,
          2154992,
          2155497,
          2155753,
          2156016,
          2156320,
          2157281,
          2157797,
          2158049,
          2158368,
          2158817,
          2158831,
          2158833,
          2159604,
          2159605,
          2159847,
          2159855,
          14672160,
          14754017,
          14754036,
          14805280,
          14806304,
          14807292,
          14807584,
          14936545,
          15067424,
          15069728,
          15147252,
          15199520,
          15200800,
          15278324,
          15327520,
          15330014,
          15331872,
          15393257,
          15393268,
          15525152,
          15540449,
          15540453,
          15540464,
          15589664,
          15725088,
          15725856,
          15790069,
          15790575,
          15793184,
          15868129,
          15868133,
          15868138,
          15868144,
          15868148,
          15983904,
          15984416,
          15987951,
          16048416,
          16048617,
          16050157,
          16050162,
          16050666,
          16052e3,
          16052213,
          16054765,
          16379168,
          16706848
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1253" : "ISO-8859-7";
      }, this.language = function() {
        return "el";
      };
    }, util2.inherits(module2.exports.ISO_8859_7, sbcs2), module2.exports.ISO_8859_8 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          32,
          32,
          32,
          32,
          32
        ];
      }, this.ngrams = function() {
        return [
          new NGramsPlusLang("he", [
            2154725,
            2154727,
            2154729,
            2154746,
            2154985,
            2154990,
            2155744,
            2155749,
            2155753,
            2155758,
            2155762,
            2155769,
            2155770,
            2157792,
            2157796,
            2158304,
            2159340,
            2161132,
            14744096,
            14950624,
            14950625,
            14950628,
            14950636,
            14950638,
            14950649,
            15001056,
            15065120,
            15068448,
            15068960,
            15071264,
            15071776,
            15278308,
            15328288,
            15328762,
            15329773,
            15330592,
            15331104,
            15333408,
            15333920,
            15474912,
            15474916,
            15523872,
            15524896,
            15540448,
            15540449,
            15540452,
            15540460,
            15540462,
            15540473,
            15655968,
            15671524,
            15787040,
            15788320,
            15788525,
            15920160,
            16261348,
            16312813,
            16378912,
            16392416,
            16392417,
            16392420,
            16392428,
            16392430,
            16392441
          ]),
          new NGramsPlusLang("he", [
            2154725,
            2154732,
            2155753,
            2155756,
            2155758,
            2155760,
            2157040,
            2157810,
            2157817,
            2158053,
            2158057,
            2158565,
            2158569,
            2160869,
            2160873,
            2161376,
            2161381,
            2161385,
            14688484,
            14688492,
            14688493,
            14688506,
            14738464,
            14738916,
            14740512,
            14741024,
            14754020,
            14754029,
            14754042,
            14950628,
            14950633,
            14950636,
            14950637,
            14950639,
            14950648,
            14950650,
            15002656,
            15065120,
            15066144,
            15196192,
            15327264,
            15327520,
            15328288,
            15474916,
            15474925,
            15474938,
            15528480,
            15530272,
            15591913,
            15591920,
            15591928,
            15605988,
            15605997,
            15606010,
            15655200,
            15655968,
            15918112,
            16326884,
            16326893,
            16326906,
            16376864,
            16441376,
            16442400,
            16442857
          ])
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1255" : "ISO-8859-8";
      }, this.language = function() {
        return "he";
      };
    }, util2.inherits(module2.exports.ISO_8859_8, sbcs2), module2.exports.ISO_8859_9 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          170,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          186,
          32,
          32,
          32,
          32,
          32,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          105,
          254,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          32,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          2122337,
          2122345,
          2122357,
          2122849,
          2122853,
          2123621,
          2123873,
          2124140,
          2124641,
          2124655,
          2125153,
          2125676,
          2126689,
          2126945,
          2127461,
          2128225,
          6365282,
          6384416,
          6384737,
          6384993,
          6385184,
          6385405,
          6386208,
          6386273,
          6386429,
          6386685,
          6388065,
          6449522,
          6578464,
          6579488,
          6580512,
          6627426,
          6627435,
          6644841,
          6647328,
          6648352,
          6648425,
          6648681,
          6909029,
          6909472,
          6909545,
          6910496,
          7102830,
          7102834,
          7103776,
          7103858,
          7217249,
          7217250,
          7217259,
          7234657,
          7234661,
          7234848,
          7235872,
          7235950,
          7273760,
          7498094,
          7535982,
          7759136,
          7954720,
          7958386,
          16608800,
          16608868,
          16609021,
          16642301
        ];
      }, this.name = function(det) {
        return det && det.fC1Bytes ? "windows-1254" : "ISO-8859-9";
      }, this.language = function() {
        return "tr";
      };
    }, util2.inherits(module2.exports.ISO_8859_9, sbcs2), module2.exports.windows_1251 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          144,
          131,
          32,
          131,
          32,
          32,
          32,
          32,
          32,
          32,
          154,
          32,
          156,
          157,
          158,
          159,
          144,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          154,
          32,
          156,
          157,
          158,
          159,
          32,
          162,
          162,
          188,
          32,
          180,
          32,
          32,
          184,
          32,
          186,
          32,
          32,
          32,
          32,
          191,
          32,
          32,
          179,
          179,
          180,
          181,
          32,
          32,
          184,
          32,
          186,
          32,
          188,
          190,
          190,
          191,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255
        ];
      }, this.ngrams = function() {
        return [
          2155040,
          2155246,
          2155758,
          2156512,
          2156576,
          2157280,
          2157294,
          2158048,
          2158053,
          2158305,
          2158574,
          2158576,
          2158816,
          2159086,
          2159090,
          2159342,
          2160626,
          2162162,
          14740968,
          14742268,
          14937632,
          15068156,
          15068648,
          15069682,
          15069728,
          15212783,
          15263008,
          15263776,
          15269664,
          15459821,
          15460384,
          15465709,
          15589408,
          15590688,
          15591653,
          15591679,
          15592992,
          15593186,
          15605986,
          15605999,
          15606001,
          15655456,
          15655648,
          15655918,
          15657248,
          15657980,
          15658016,
          15659506,
          15724267,
          15724773,
          15724776,
          15724782,
          15786210,
          15787492,
          15856352,
          15856354,
          15856360,
          15859488,
          15918571,
          15920672,
          15920880,
          15924256,
          16249582,
          16512288
        ];
      }, this.name = function(det) {
        return "windows-1251";
      }, this.language = function() {
        return "ru";
      };
    }, util2.inherits(module2.exports.windows_1251, sbcs2), module2.exports.windows_1256 = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          129,
          32,
          131,
          32,
          32,
          32,
          32,
          136,
          32,
          138,
          32,
          156,
          141,
          142,
          143,
          144,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          152,
          32,
          154,
          32,
          156,
          32,
          32,
          159,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          170,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          181,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          32,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          32,
          32,
          32,
          32,
          244,
          32,
          32,
          32,
          32,
          249,
          32,
          251,
          252,
          32,
          32,
          255
        ];
      }, this.ngrams = function() {
        return [
          2148321,
          2148324,
          2148551,
          2153185,
          2153965,
          2154977,
          2155492,
          2156231,
          13050055,
          13091104,
          13093408,
          13095200,
          13099296,
          13099459,
          13099463,
          13099464,
          13099466,
          13099468,
          13099469,
          13099471,
          13099475,
          13099482,
          13099486,
          13099491,
          13099494,
          13099501,
          13099808,
          13100064,
          13100234,
          13115591,
          13181127,
          13181149,
          13181153,
          13181155,
          13181158,
          13246663,
          13574343,
          13617440,
          13705415,
          13748512,
          13836487,
          14295239,
          14344684,
          14544160,
          14753991,
          14797088,
          14806048,
          14806304,
          14885063,
          14927648,
          14928160,
          14935072,
          14950599,
          15016135,
          15058720,
          15124449,
          15131680,
          15474887,
          15540423,
          15540451,
          15540454,
          15583520,
          15585568,
          15590432
        ];
      }, this.name = function(det) {
        return "windows-1256";
      }, this.language = function() {
        return "ar";
      };
    }, util2.inherits(module2.exports.windows_1256, sbcs2), module2.exports.KOI8_R = function() {
      this.byteMap = function() {
        return [
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          0,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          163,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          163,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          32,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223
        ];
      }, this.ngrams = function() {
        return [
          2147535,
          2148640,
          2149313,
          2149327,
          2150081,
          2150085,
          2150338,
          2150607,
          2150610,
          2151105,
          2151375,
          2151380,
          2151631,
          2152224,
          2152399,
          2153153,
          2153684,
          2154196,
          12701385,
          12702936,
          12963032,
          12963529,
          12964820,
          12964896,
          13094688,
          13181136,
          13223200,
          13224224,
          13226272,
          13419982,
          13420832,
          13424846,
          13549856,
          13550880,
          13552069,
          13552081,
          13553440,
          13553623,
          13574352,
          13574355,
          13574359,
          13617103,
          13617696,
          13618392,
          13618464,
          13620180,
          13621024,
          13621185,
          13684684,
          13685445,
          13685449,
          13685455,
          13812183,
          13813188,
          13881632,
          13882561,
          13882569,
          13882583,
          13944268,
          13946656,
          13946834,
          13948960,
          14272544,
          14603471
        ];
      }, this.name = function(det) {
        return "KOI8-R";
      }, this.language = function() {
        return "ru";
      };
    }, util2.inherits(module2.exports.KOI8_R, sbcs2);
  }(sbcs)), sbcs.exports;
}
var iso2022 = { exports: {} }, hasRequiredIso2022;
function requireIso2022() {
  return hasRequiredIso2022 || (hasRequiredIso2022 = 1, function(module2) {
    var util2 = require$$0__default$5.default, Match = requireMatch();
    function ISO_2022() {
    }
    ISO_2022.prototype.match = function(det) {
      var i2, j, escN, hits = 0, misses = 0, shifts = 0, quality, text = det.fInputBytes, textLen = det.fInputLen;
      scanInput:
        for (i2 = 0; i2 < textLen; i2++) {
          if (text[i2] == 27) {
            checkEscapes:
              for (escN = 0; escN < this.escapeSequences.length; escN++) {
                var seq2 = this.escapeSequences[escN];
                if (textLen - i2 < seq2.length)
                  continue checkEscapes;
                for (j = 1; j < seq2.length; j++)
                  if (seq2[j] != text[i2 + j])
                    continue checkEscapes;
                hits++, i2 += seq2.length - 1;
                continue scanInput;
              }
            misses++;
          }
          (text[i2] == 14 || text[i2] == 15) && shifts++;
        }
      return hits == 0 ? null : (quality = (100 * hits - 100 * misses) / (hits + misses), hits + shifts < 5 && (quality -= (5 - (hits + shifts)) * 10), quality <= 0 ? null : new Match(det, this, quality));
    }, module2.exports.ISO_2022_JP = function() {
      this.name = function() {
        return "ISO-2022-JP";
      }, this.escapeSequences = [
        [27, 36, 40, 67],
        // KS X 1001:1992
        [27, 36, 40, 68],
        // JIS X 212-1990
        [27, 36, 64],
        // JIS C 6226-1978
        [27, 36, 65],
        // GB 2312-80
        [27, 36, 66],
        // JIS X 208-1983
        [27, 38, 64],
        // JIS X 208 1990, 1997
        [27, 40, 66],
        // ASCII
        [27, 40, 72],
        // JIS-Roman
        [27, 40, 73],
        // Half-width katakana
        [27, 40, 74],
        // JIS-Roman
        [27, 46, 65],
        // ISO 8859-1
        [27, 46, 70]
        // ISO 8859-7
      ];
    }, util2.inherits(module2.exports.ISO_2022_JP, ISO_2022), module2.exports.ISO_2022_KR = function() {
      this.name = function() {
        return "ISO-2022-KR";
      }, this.escapeSequences = [
        [27, 36, 41, 67]
      ];
    }, util2.inherits(module2.exports.ISO_2022_KR, ISO_2022), module2.exports.ISO_2022_CN = function() {
      this.name = function() {
        return "ISO-2022-CN";
      }, this.escapeSequences = [
        [27, 36, 41, 65],
        // GB 2312-80
        [27, 36, 41, 71],
        // CNS 11643-1992 Plane 1
        [27, 36, 42, 72],
        // CNS 11643-1992 Plane 2
        [27, 36, 41, 69],
        // ISO-IR-165
        [27, 36, 43, 73],
        // CNS 11643-1992 Plane 3
        [27, 36, 43, 74],
        // CNS 11643-1992 Plane 4
        [27, 36, 43, 75],
        // CNS 11643-1992 Plane 5
        [27, 36, 43, 76],
        // CNS 11643-1992 Plane 6
        [27, 36, 43, 77],
        // CNS 11643-1992 Plane 7
        [27, 78],
        // SS2
        [27, 79]
        // SS3
      ];
    }, util2.inherits(module2.exports.ISO_2022_CN, ISO_2022);
  }(iso2022)), iso2022.exports;
}
var hasRequiredChardet;
function requireChardet() {
  if (hasRequiredChardet) return chardet;
  hasRequiredChardet = 1;
  var fs2 = require$$0__default$1.default, utf82 = requireUtf8(), unicode2 = requireUnicode(), mbcs2 = requireMbcs(), sbcs2 = requireSbcs(), iso20222 = requireIso2022(), self2 = loadEnv.commonjsGlobal, recognisers = [
    new utf82(),
    new unicode2.UTF_16BE(),
    new unicode2.UTF_16LE(),
    new unicode2.UTF_32BE(),
    new unicode2.UTF_32LE(),
    new mbcs2.sjis(),
    new mbcs2.big5(),
    new mbcs2.euc_jp(),
    new mbcs2.euc_kr(),
    new mbcs2.gb_18030(),
    new iso20222.ISO_2022_JP(),
    new iso20222.ISO_2022_KR(),
    new iso20222.ISO_2022_CN(),
    new sbcs2.ISO_8859_1(),
    new sbcs2.ISO_8859_2(),
    new sbcs2.ISO_8859_5(),
    new sbcs2.ISO_8859_6(),
    new sbcs2.ISO_8859_7(),
    new sbcs2.ISO_8859_8(),
    new sbcs2.ISO_8859_9(),
    new sbcs2.windows_1251(),
    new sbcs2.windows_1256(),
    new sbcs2.KOI8_R()
  ];
  return chardet.detect = function(buffer2, opts) {
    for (var fByteStats = [], i2 = 0; i2 < 256; i2++)
      fByteStats[i2] = 0;
    for (var i2 = buffer2.length - 1; i2 >= 0; i2--)
      fByteStats[buffer2[i2] & 255]++;
    for (var fC1Bytes = !1, i2 = 128; i2 <= 159; i2 += 1)
      if (fByteStats[i2] != 0) {
        fC1Bytes = !0;
        break;
      }
    var context = {
      fByteStats,
      fC1Bytes,
      fRawInput: buffer2,
      fRawLength: buffer2.length,
      fInputBytes: buffer2,
      fInputLen: buffer2.length
    }, matches2 = recognisers.map(function(rec) {
      return rec.match(context);
    }).filter(function(match3) {
      return !!match3;
    }).sort(function(a, b) {
      return b.confidence - a.confidence;
    });
    return opts && opts.returnAllMatches === !0 ? matches2 : matches2.length > 0 ? matches2[0].name : null;
  }, chardet.detectFile = function(filepath, opts, cb) {
    typeof opts == "function" && (cb = opts, opts = void 0);
    var fd, handler = function(err, buffer2) {
      if (fd && fs2.closeSync(fd), err) return cb(err, null);
      cb(null, self2.detect(buffer2, opts));
    };
    if (opts && opts.sampleSize) {
      fd = fs2.openSync(filepath, "r"), sample = Buffer.allocUnsafe(opts.sampleSize), fs2.read(fd, sample, 0, opts.sampleSize, null, function(err) {
        handler(err, sample);
      });
      return;
    }
    fs2.readFile(filepath, handler);
  }, chardet.detectFileSync = function(filepath, opts) {
    if (opts && opts.sampleSize) {
      var fd = fs2.openSync(filepath, "r"), sample2 = Buffer.allocUnsafe(opts.sampleSize);
      return fs2.readSync(fd, sample2, 0, opts.sampleSize), fs2.closeSync(fd), self2.detect(sample2, opts);
    }
    return self2.detect(fs2.readFileSync(filepath), opts);
  }, chardet.detectAll = function(buffer2, opts) {
    return typeof opts != "object" && (opts = {}), opts.returnAllMatches = !0, self2.detect(buffer2, opts);
  }, chardet.detectFileAll = function(filepath, opts, cb) {
    typeof opts == "function" && (cb = opts, opts = void 0), typeof opts != "object" && (opts = {}), opts.returnAllMatches = !0, self2.detectFile(filepath, opts, cb);
  }, chardet.detectFileAllSync = function(filepath, opts) {
    return typeof opts != "object" && (opts = {}), opts.returnAllMatches = !0, self2.detectFileSync(filepath, opts);
  }, chardet;
}
var lib = { exports: {} }, safer_1, hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$0__default$9.default, Buffer2 = buffer2.Buffer, safer = {}, key2;
  for (key2 in buffer2)
    buffer2.hasOwnProperty(key2) && (key2 === "SlowBuffer" || key2 === "Buffer" || (safer[key2] = buffer2[key2]));
  var Safer = safer.Buffer = {};
  for (key2 in Buffer2)
    Buffer2.hasOwnProperty(key2) && (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow" || (Safer[key2] = Buffer2[key2]));
  if (safer.Buffer.prototype = Buffer2.prototype, (!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    if (value && typeof value.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    return Buffer2(value, encodingOrOffset, length);
  }), Safer.alloc || (Safer.alloc = function(size, fill2, encoding) {
    if (typeof size != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    if (size < 0 || size >= 2 * (1 << 30))
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    var buf = Buffer2(size);
    return !fill2 || fill2.length === 0 ? buf.fill(0) : typeof encoding == "string" ? buf.fill(fill2, encoding) : buf.fill(fill2), buf;
  }), !safer.kStringMaxLength)
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {
    }
  return safer.constants || (safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength)), safer_1 = safer, safer_1;
}
var bomHandling = {}, hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options2) {
    this.encoder = encoder, this.addBOM = !0;
  }
  PrependBOMWrapper.prototype.write = function(str2) {
    return this.addBOM && (str2 = BOMChar + str2, this.addBOM = !1), this.encoder.write(str2);
  }, PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  }, bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options2) {
    this.decoder = decoder, this.pass = !1, this.options = options2 || {};
  }
  return StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    return this.pass || !res || (res[0] === BOMChar && (res = res.slice(1), typeof this.options.stripBOM == "function" && this.options.stripBOM()), this.pass = !0), res;
  }, StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  }, bomHandling;
}
var encodings = {}, internal, hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: !0 },
    cesu8: { type: "_internal", bomAware: !0 },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: !0 },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName, this.bomAware = codecOptions.bomAware, this.enc === "base64" ? this.encoder = InternalEncoderBase64 : this.enc === "cesu8" && (this.enc = "utf8", this.encoder = InternalEncoderCesu8, Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}" && (this.decoder = InternalDecoderCesu8, this.defaultCharUnicode = iconv.defaultCharUnicode));
  }
  InternalCodec.prototype.encoder = InternalEncoder, InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = requireString_decoder().StringDecoder;
  StringDecoder.prototype.end || (StringDecoder.prototype.end = function() {
  });
  function InternalDecoder(options2, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options2, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  }, InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options2, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    return this.prevStr = str2.slice(completeQuads), str2 = str2.slice(0, completeQuads), Buffer2.from(str2, "base64");
  }, InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options2, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    for (var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0, i2 = 0; i2 < str2.length; i2++) {
      var charCode = str2.charCodeAt(i2);
      charCode < 128 ? buf[bufIdx++] = charCode : charCode < 2048 ? (buf[bufIdx++] = 192 + (charCode >>> 6), buf[bufIdx++] = 128 + (charCode & 63)) : (buf[bufIdx++] = 224 + (charCode >>> 12), buf[bufIdx++] = 128 + (charCode >>> 6 & 63), buf[bufIdx++] = 128 + (charCode & 63));
    }
    return buf.slice(0, bufIdx);
  }, InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options2, codec) {
    this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  return InternalDecoderCesu8.prototype.write = function(buf) {
    for (var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "", i2 = 0; i2 < buf.length; i2++) {
      var curByte = buf[i2];
      (curByte & 192) !== 128 ? (contBytes > 0 && (res += this.defaultCharUnicode, contBytes = 0), curByte < 128 ? res += String.fromCharCode(curByte) : curByte < 224 ? (acc = curByte & 31, contBytes = 1, accBytes = 1) : curByte < 240 ? (acc = curByte & 15, contBytes = 2, accBytes = 1) : res += this.defaultCharUnicode) : contBytes > 0 ? (acc = acc << 6 | curByte & 63, contBytes--, accBytes++, contBytes === 0 && (accBytes === 2 && acc < 128 && acc > 0 ? res += this.defaultCharUnicode : accBytes === 3 && acc < 2048 ? res += this.defaultCharUnicode : res += String.fromCharCode(acc))) : res += this.defaultCharUnicode;
    }
    return this.acc = acc, this.contBytes = contBytes, this.accBytes = accBytes, res;
  }, InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    return this.contBytes > 0 && (res += this.defaultCharUnicode), res;
  }, internal;
}
var utf16 = {}, hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder, Utf16BECodec.prototype.decoder = Utf16BEDecoder, Utf16BECodec.prototype.bomAware = !0;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    for (var buf = Buffer2.from(str2, "ucs2"), i2 = 0; i2 < buf.length; i2 += 2) {
      var tmp2 = buf[i2];
      buf[i2] = buf[i2 + 1], buf[i2 + 1] = tmp2;
    }
    return buf;
  }, Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i2 = 0, j = 0;
    for (this.overflowByte !== -1 && (buf2[0] = buf[0], buf2[1] = this.overflowByte, i2 = 1, j = 2); i2 < buf.length - 1; i2 += 2, j += 2)
      buf2[j] = buf[i2 + 1], buf2[j + 1] = buf[i2];
    return this.overflowByte = i2 == buf.length - 1 ? buf[buf.length - 1] : -1, buf2.slice(0, j).toString("ucs2");
  }, Utf16BEDecoder.prototype.end = function() {
  }, utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder, Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options2, codec) {
    options2 = options2 || {}, options2.addBOM === void 0 && (options2.addBOM = !0), this.encoder = codec.iconv.getEncoder("utf-16le", options2);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  }, Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options2, codec) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = options2 || {}, this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      if (this.initialBytes.push(buf), this.initialBytesLen += buf.length, this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options), this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  }, Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2)
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        for (var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64), i2 = 0; i2 < _len; i2 += 2)
          buf[i2] === 0 && buf[i2 + 1] !== 0 && asciiCharsBE++, buf[i2] !== 0 && buf[i2 + 1] === 0 && asciiCharsLE++;
        asciiCharsBE > asciiCharsLE ? enc = "utf-16be" : asciiCharsBE < asciiCharsLE && (enc = "utf-16le");
      }
    return enc;
  }
  return utf16;
}
var utf7 = {}, hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec, utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder, Utf7Codec.prototype.decoder = Utf7Decoder, Utf7Codec.prototype.bomAware = !0;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options2, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  }, Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options2, codec) {
    this.iconv = codec.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  for (var base64Regex = /[A-Za-z0-9\/+]/, base64Chars = [], i2 = 0; i2 < 256; i2++)
    base64Chars[i2] = base64Regex.test(String.fromCharCode(i2));
  var plusChar = 43, minusChar = 45, andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    for (var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum, i3 = 0; i3 < buf.length; i3++)
      if (!inBase64)
        buf[i3] == plusChar && (res += this.iconv.decode(buf.slice(lastI, i3), "ascii"), lastI = i3 + 1, inBase64 = !0);
      else if (!base64Chars[buf[i3]]) {
        if (i3 == lastI && buf[i3] == minusChar)
          res += "+";
        else {
          var b64str = base64Accum + buf.slice(lastI, i3).toString();
          res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
        }
        buf[i3] != minusChar && i3--, lastI = i3 + 1, inBase64 = !1, base64Accum = "";
      }
    if (!inBase64)
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    else {
      var b64str = base64Accum + buf.slice(lastI).toString(), canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded), b64str = b64str.slice(0, canBeDecoded), res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    return this.inBase64 = inBase64, this.base64Accum = base64Accum, res;
  }, Utf7Decoder.prototype.end = function() {
    var res = "";
    return this.inBase64 && this.base64Accum.length > 0 && (res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", res;
  }, utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder, Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder, Utf7IMAPCodec.prototype.bomAware = !0;
  function Utf7IMAPEncoder(options2, codec) {
    this.iconv = codec.iconv, this.inBase64 = !1, this.base64Accum = Buffer2.alloc(6), this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    for (var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0, i3 = 0; i3 < str2.length; i3++) {
      var uChar = str2.charCodeAt(i3);
      32 <= uChar && uChar <= 126 ? (inBase64 && (base64AccumIdx > 0 && (bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx), base64AccumIdx = 0), buf[bufIdx++] = minusChar, inBase64 = !1), inBase64 || (buf[bufIdx++] = uChar, uChar === andChar && (buf[bufIdx++] = minusChar))) : (inBase64 || (buf[bufIdx++] = andChar, inBase64 = !0), inBase64 && (base64Accum[base64AccumIdx++] = uChar >> 8, base64Accum[base64AccumIdx++] = uChar & 255, base64AccumIdx == base64Accum.length && (bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx), base64AccumIdx = 0)));
    }
    return this.inBase64 = inBase64, this.base64AccumIdx = base64AccumIdx, buf.slice(0, bufIdx);
  }, Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    return this.inBase64 && (this.base64AccumIdx > 0 && (bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx), this.base64AccumIdx = 0), buf[bufIdx++] = minusChar, this.inBase64 = !1), buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options2, codec) {
    this.iconv = codec.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  return base64IMAPChars[44] = !0, Utf7IMAPDecoder.prototype.write = function(buf) {
    for (var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum, i3 = 0; i3 < buf.length; i3++)
      if (!inBase64)
        buf[i3] == andChar && (res += this.iconv.decode(buf.slice(lastI, i3), "ascii"), lastI = i3 + 1, inBase64 = !0);
      else if (!base64IMAPChars[buf[i3]]) {
        if (i3 == lastI && buf[i3] == minusChar)
          res += "&";
        else {
          var b64str = base64Accum + buf.slice(lastI, i3).toString().replace(/,/g, "/");
          res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
        }
        buf[i3] != minusChar && i3--, lastI = i3 + 1, inBase64 = !1, base64Accum = "";
      }
    if (!inBase64)
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/"), canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded), b64str = b64str.slice(0, canBeDecoded), res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    return this.inBase64 = inBase64, this.base64Accum = base64Accum, res;
  }, Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    return this.inBase64 && this.base64Accum.length > 0 && (res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", res;
  }, utf7;
}
var sbcsCodec = {}, hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      for (var asciiString = "", i2 = 0; i2 < 128; i2++)
        asciiString += String.fromCharCode(i2);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    for (var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0)), i2 = 0; i2 < codecOptions.chars.length; i2++)
      encodeBuf[codecOptions.chars.charCodeAt(i2)] = i2;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder, SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options2, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    for (var buf = Buffer2.alloc(str2.length), i2 = 0; i2 < str2.length; i2++)
      buf[i2] = this.encodeBuf[str2.charCodeAt(i2)];
    return buf;
  }, SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options2, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  return SBCSDecoder.prototype.write = function(buf) {
    for (var decodeBuf = this.decodeBuf, newBuf = Buffer2.alloc(buf.length * 2), idx1 = 0, idx2 = 0, i2 = 0; i2 < buf.length; i2++)
      idx1 = buf[i2] * 2, idx2 = i2 * 2, newBuf[idx2] = decodeBuf[idx1], newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    return newBuf.toString("ucs2");
  }, SBCSDecoder.prototype.end = function() {
  }, sbcsCodec;
}
var sbcsData, hasRequiredSbcsData;
function requireSbcsData() {
  return hasRequiredSbcsData || (hasRequiredSbcsData = 1, sbcsData = {
    // Not supported by iconv, not sure why.
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
    },
    mik: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    // Aliases of generated encodings.
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  }), sbcsData;
}
var sbcsDataGenerated, hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  return hasRequiredSbcsDataGenerated || (hasRequiredSbcsDataGenerated = 1, sbcsDataGenerated = {
    437: "cp437",
    737: "cp737",
    775: "cp775",
    850: "cp850",
    852: "cp852",
    855: "cp855",
    856: "cp856",
    857: "cp857",
    858: "cp858",
    860: "cp860",
    861: "cp861",
    862: "cp862",
    863: "cp863",
    864: "cp864",
    865: "cp865",
    866: "cp866",
    869: "cp869",
    874: "windows874",
    922: "cp922",
    1046: "cp1046",
    1124: "cp1124",
    1125: "cp1125",
    1129: "cp1129",
    1133: "cp1133",
    1161: "cp1161",
    1162: "cp1162",
    1163: "cp1163",
    1250: "windows1250",
    1251: "windows1251",
    1252: "windows1252",
    1253: "windows1253",
    1254: "windows1254",
    1255: "windows1255",
    1256: "windows1256",
    1257: "windows1257",
    1258: "windows1258",
    28591: "iso88591",
    28592: "iso88592",
    28593: "iso88593",
    28594: "iso88594",
    28595: "iso88595",
    28596: "iso88596",
    28597: "iso88597",
    28598: "iso88598",
    28599: "iso88599",
    28600: "iso885910",
    28601: "iso885911",
    28603: "iso885913",
    28604: "iso885914",
    28605: "iso885915",
    28606: "iso885916",
    windows874: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
    },
    maccyrillic: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    macgreek: {
      type: "_sbcs",
      chars: "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
    },
    maciceland: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macroman: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macromania: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macthai: {
      type: "_sbcs",
      chars: "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    macturkish: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    macukraine: {
      type: "_sbcs",
      chars: "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
    },
    koi8r: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8u: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8ru: {
      type: "_sbcs",
      chars: "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    koi8t: {
      type: "_sbcs",
      chars: "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
    },
    armscii8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
    },
    rk1048: {
      type: "_sbcs",
      chars: "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    tcvn: {
      type: "_sbcs",
      chars: `\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	
\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    georgianps: {
      type: "_sbcs",
      chars: "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
    },
    pt154: {
      type: "_sbcs",
      chars: "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
    },
    viscii: {
      type: "_sbcs",
      chars: `\0\u1EB2\u1EB4\u1EAA\x07\b	
\v\f\r\u1EF6\u1EF8\x1B\u1EF4 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_\`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD`
    },
    hproman8: {
      type: "_sbcs",
      chars: "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
    },
    macintosh: {
      type: "_sbcs",
      chars: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
    },
    ascii: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
    },
    tis620: {
      type: "_sbcs",
      chars: "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
    }
  }), sbcsDataGenerated;
}
var dbcsCodec = {}, hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  for (var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1, i2 = 0; i2 < 256; i2++)
    UNASSIGNED_NODE[i2] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    if (this.encodingName = codecOptions.encodingName, !codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [], this.decodeTables[0] = UNASSIGNED_NODE.slice(0), this.decodeTableSeq = [];
    for (var i3 = 0; i3 < mappingTable.length; i3++)
      this._addDecodeChunk(mappingTable[i3]);
    this.defaultCharUnicode = iconv.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i3 = 0; i3 < codecOptions.encodeSkipVals.length; i3++) {
        var val = codecOptions.encodeSkipVals[i3];
        if (typeof val == "number")
          skipEncodeChars[val] = !0;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = !0;
      }
    if (this._fillEncodeTable(0, 0, skipEncodeChars), codecOptions.encodeAdd)
      for (var uChar in codecOptions.encodeAdd)
        Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar) && this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    if (this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)], this.defCharSB === UNASSIGNED && (this.defCharSB = this.encodeTable[0]["?"]), this.defCharSB === UNASSIGNED && (this.defCharSB = 63), typeof codecOptions.gb18030 == "function") {
      this.gb18030 = codecOptions.gb18030();
      for (var thirdByteNodeIdx = this.decodeTables.length, thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0), fourthByteNodeIdx = this.decodeTables.length, fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0), i3 = 129; i3 <= 254; i3++)
        for (var secondByteNodeIdx = NODE_START - this.decodeTables[0][i3], secondByteNode = this.decodeTables[secondByteNodeIdx], j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      for (var i3 = 129; i3 <= 254; i3++)
        thirdByteNode[i3] = NODE_START - fourthByteNodeIdx;
      for (var i3 = 48; i3 <= 57; i3++)
        fourthByteNode[i3] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder, DBCSCodec.prototype.decoder = DBCSDecoder, DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    for (var bytes = []; addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    bytes.length == 0 && bytes.push(0);
    for (var node2 = this.decodeTables[0], i3 = bytes.length - 1; i3 > 0; i3--) {
      var val = node2[bytes[i3]];
      if (val == UNASSIGNED)
        node2[bytes[i3]] = NODE_START - this.decodeTables.length, this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      else if (val <= NODE_START)
        node2 = this.decodeTables[NODE_START - val];
      else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  }, DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16), writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part == "string")
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            for (var len = 4095 - code + 2, seq2 = [], m = 0; m < len; m++)
              seq2.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length, this.decodeTableSeq.push(seq2);
          } else
            writeTable[curAddr++] = code;
        }
      else if (typeof part == "number")
        for (var charCode = writeTable[curAddr - 1] + 1, l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  }, DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    return this.encodeTable[high] === void 0 && (this.encodeTable[high] = UNASSIGNED_NODE.slice(0)), this.encodeTable[high];
  }, DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode), low = uCode & 255;
    bucket[low] <= SEQ_START ? this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode : bucket[low] == UNASSIGNED && (bucket[low] = dbcsCode);
  }, DBCSCodec.prototype._setEncodeSequence = function(seq2, dbcsCode) {
    var uCode = seq2[0], bucket = this._getEncodeBucket(uCode), low = uCode & 255, node2;
    bucket[low] <= SEQ_START ? node2 = this.encodeTableSeq[SEQ_START - bucket[low]] : (node2 = {}, bucket[low] !== UNASSIGNED && (node2[DEF_CHAR] = bucket[low]), bucket[low] = SEQ_START - this.encodeTableSeq.length, this.encodeTableSeq.push(node2));
    for (var j = 1; j < seq2.length - 1; j++) {
      var oldVal = node2[uCode];
      typeof oldVal == "object" ? node2 = oldVal : (node2 = node2[uCode] = {}, oldVal !== void 0 && (node2[DEF_CHAR] = oldVal));
    }
    uCode = seq2[seq2.length - 1], node2[uCode] = dbcsCode;
  }, DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    for (var node2 = this.decodeTables[nodeIdx], i3 = 0; i3 < 256; i3++) {
      var uCode = node2[i3], mbCode = prefix + i3;
      skipEncodeChars[mbCode] || (uCode >= 0 ? this._setEncodeChar(uCode, mbCode) : uCode <= NODE_START ? this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars) : uCode <= SEQ_START && this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode));
    }
  };
  function DBCSEncoder(options2, codec) {
    this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = codec.encodeTable, this.encodeTableSeq = codec.encodeTableSeq, this.defaultCharSingleByte = codec.defCharSB, this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    for (var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i3 = 0, j = 0; ; ) {
      if (nextChar === -1) {
        if (i3 == str2.length) break;
        var uCode = str2.charCodeAt(i3++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344)
        if (uCode < 56320)
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else
            leadSurrogate = uCode, uCode = UNASSIGNED;
        else
          leadSurrogate !== -1 ? (uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320), leadSurrogate = -1) : uCode = UNASSIGNED;
      else leadSurrogate !== -1 && (nextChar = uCode, uCode = UNASSIGNED, leadSurrogate = -1);
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode == "object") {
          seqObj = resCode;
          continue;
        } else typeof resCode == "number" ? dbcsCode = resCode : resCode == null && (resCode = seqObj[DEF_CHAR], resCode !== void 0 && (dbcsCode = resCode, nextChar = uCode));
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0 && (dbcsCode = subtable[uCode & 255]), dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600), dbcsCode = dbcsCode % 12600, newBuf[j++] = 48 + Math.floor(dbcsCode / 1260), dbcsCode = dbcsCode % 1260, newBuf[j++] = 129 + Math.floor(dbcsCode / 10), dbcsCode = dbcsCode % 10, newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      dbcsCode === UNASSIGNED && (dbcsCode = this.defaultCharSingleByte), dbcsCode < 256 ? newBuf[j++] = dbcsCode : dbcsCode < 65536 ? (newBuf[j++] = dbcsCode >> 8, newBuf[j++] = dbcsCode & 255) : (newBuf[j++] = dbcsCode >> 16, newBuf[j++] = dbcsCode >> 8 & 255, newBuf[j++] = dbcsCode & 255);
    }
    return this.seqObj = seqObj, this.leadSurrogate = leadSurrogate, newBuf.slice(0, j);
  }, DBCSEncoder.prototype.end = function() {
    if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        dbcsCode !== void 0 && (dbcsCode < 256 ? newBuf[j++] = dbcsCode : (newBuf[j++] = dbcsCode >> 8, newBuf[j++] = dbcsCode & 255)), this.seqObj = void 0;
      }
      return this.leadSurrogate !== -1 && (newBuf[j++] = this.defaultCharSingleByte, this.leadSurrogate = -1), newBuf.slice(0, j);
    }
  }, DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options2, codec) {
    this.nodeIdx = 0, this.prevBuf = Buffer2.alloc(0), this.decodeTables = codec.decodeTables, this.decodeTableSeq = codec.decodeTableSeq, this.defaultCharUnicode = codec.defaultCharUnicode, this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    prevBufOffset > 0 && (prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]));
    for (var i3 = 0, j = 0; i3 < buf.length; i3++) {
      var curByte = i3 >= 0 ? buf[i3] : prevBuf[i3 + prevBufOffset], uCode = this.decodeTables[nodeIdx][curByte];
      if (!(uCode >= 0)) if (uCode === UNASSIGNED)
        i3 = seqStart, uCode = this.defaultCharUnicode.charCodeAt(0);
      else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i3 + 1) : prevBuf.slice(seqStart + prevBufOffset, i3 + 1 + prevBufOffset), ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48), idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        for (var seq2 = this.decodeTableSeq[SEQ_START - uCode], k = 0; k < seq2.length - 1; k++)
          uCode = seq2[k], newBuf[j++] = uCode & 255, newBuf[j++] = uCode >> 8;
        uCode = seq2[seq2.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255, newBuf[j++] = uCodeLead >> 8, uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255, newBuf[j++] = uCode >> 8, nodeIdx = 0, seqStart = i3 + 1;
    }
    return this.nodeIdx = nodeIdx, this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset), newBuf.slice(0, j).toString("ucs2");
  }, DBCSDecoder.prototype.end = function() {
    for (var ret = ""; this.prevBuf.length > 0; ) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0), this.nodeIdx = 0, buf.length > 0 && (ret += this.write(buf));
    }
    return this.nodeIdx = 0, ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    for (var l = 0, r = table.length; l < r - 1; ) {
      var mid = l + Math.floor((r - l + 1) / 2);
      table[mid] <= val ? l = mid : r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
var require$$0 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "\uFF61",
    62
  ],
  [
    "8140",
    "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008",
    9,
    "\uFF0B\uFF0D\xB1\xD7"
  ],
  [
    "8180",
    "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"
  ],
  [
    "81b8",
    "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"
  ],
  [
    "81c8",
    "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"
  ],
  [
    "81da",
    "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"
  ],
  [
    "81f0",
    "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"
  ],
  [
    "81fc",
    "\u25EF"
  ],
  [
    "824f",
    "\uFF10",
    9
  ],
  [
    "8260",
    "\uFF21",
    25
  ],
  [
    "8281",
    "\uFF41",
    25
  ],
  [
    "829f",
    "\u3041",
    82
  ],
  [
    "8340",
    "\u30A1",
    62
  ],
  [
    "8380",
    "\u30E0",
    22
  ],
  [
    "839f",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "83bf",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "8440",
    "\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "8470",
    "\u0430",
    5,
    "\u0451\u0436",
    7
  ],
  [
    "8480",
    "\u043E",
    17
  ],
  [
    "849f",
    "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"
  ],
  [
    "8740",
    "\u2460",
    19,
    "\u2160",
    9
  ],
  [
    "875f",
    "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"
  ],
  [
    "877e",
    "\u337B"
  ],
  [
    "8780",
    "\u301D\u301F\u2116\u33CD\u2121\u32A4",
    4,
    "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"
  ],
  [
    "889f",
    "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"
  ],
  [
    "8940",
    "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"
  ],
  [
    "8980",
    "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"
  ],
  [
    "8a40",
    "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"
  ],
  [
    "8a80",
    "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"
  ],
  [
    "8b40",
    "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"
  ],
  [
    "8b80",
    "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"
  ],
  [
    "8c40",
    "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"
  ],
  [
    "8c80",
    "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"
  ],
  [
    "8d40",
    "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"
  ],
  [
    "8d80",
    "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"
  ],
  [
    "8e40",
    "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"
  ],
  [
    "8e80",
    "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"
  ],
  [
    "8f40",
    "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"
  ],
  [
    "8f80",
    "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"
  ],
  [
    "9040",
    "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"
  ],
  [
    "9080",
    "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"
  ],
  [
    "9140",
    "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"
  ],
  [
    "9180",
    "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"
  ],
  [
    "9240",
    "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"
  ],
  [
    "9280",
    "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"
  ],
  [
    "9340",
    "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"
  ],
  [
    "9380",
    "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"
  ],
  [
    "9440",
    "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"
  ],
  [
    "9480",
    "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"
  ],
  [
    "9540",
    "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"
  ],
  [
    "9580",
    "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"
  ],
  [
    "9640",
    "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"
  ],
  [
    "9680",
    "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"
  ],
  [
    "9740",
    "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"
  ],
  [
    "9780",
    "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"
  ],
  [
    "9840",
    "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"
  ],
  [
    "989f",
    "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"
  ],
  [
    "9940",
    "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"
  ],
  [
    "9980",
    "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"
  ],
  [
    "9a40",
    "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"
  ],
  [
    "9a80",
    "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"
  ],
  [
    "9b40",
    "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"
  ],
  [
    "9b80",
    "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"
  ],
  [
    "9c40",
    "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"
  ],
  [
    "9c80",
    "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"
  ],
  [
    "9d40",
    "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"
  ],
  [
    "9d80",
    "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"
  ],
  [
    "9e40",
    "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"
  ],
  [
    "9e80",
    "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"
  ],
  [
    "9f40",
    "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"
  ],
  [
    "9f80",
    "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"
  ],
  [
    "e040",
    "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"
  ],
  [
    "e080",
    "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"
  ],
  [
    "e140",
    "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"
  ],
  [
    "e180",
    "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"
  ],
  [
    "e240",
    "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"
  ],
  [
    "e280",
    "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"
  ],
  [
    "e340",
    "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"
  ],
  [
    "e380",
    "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"
  ],
  [
    "e440",
    "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"
  ],
  [
    "e480",
    "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"
  ],
  [
    "e540",
    "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"
  ],
  [
    "e580",
    "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"
  ],
  [
    "e640",
    "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"
  ],
  [
    "e680",
    "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"
  ],
  [
    "e740",
    "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"
  ],
  [
    "e780",
    "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"
  ],
  [
    "e840",
    "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"
  ],
  [
    "e880",
    "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"
  ],
  [
    "e940",
    "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"
  ],
  [
    "e980",
    "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"
  ],
  [
    "ea40",
    "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"
  ],
  [
    "ea80",
    "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"
  ],
  [
    "ed40",
    "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"
  ],
  [
    "ed80",
    "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"
  ],
  [
    "ee40",
    "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"
  ],
  [
    "ee80",
    "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"
  ],
  [
    "eeef",
    "\u2170",
    9,
    "\uFFE2\uFFE4\uFF07\uFF02"
  ],
  [
    "f040",
    "\uE000",
    62
  ],
  [
    "f080",
    "\uE03F",
    124
  ],
  [
    "f140",
    "\uE0BC",
    62
  ],
  [
    "f180",
    "\uE0FB",
    124
  ],
  [
    "f240",
    "\uE178",
    62
  ],
  [
    "f280",
    "\uE1B7",
    124
  ],
  [
    "f340",
    "\uE234",
    62
  ],
  [
    "f380",
    "\uE273",
    124
  ],
  [
    "f440",
    "\uE2F0",
    62
  ],
  [
    "f480",
    "\uE32F",
    124
  ],
  [
    "f540",
    "\uE3AC",
    62
  ],
  [
    "f580",
    "\uE3EB",
    124
  ],
  [
    "f640",
    "\uE468",
    62
  ],
  [
    "f680",
    "\uE4A7",
    124
  ],
  [
    "f740",
    "\uE524",
    62
  ],
  [
    "f780",
    "\uE563",
    124
  ],
  [
    "f840",
    "\uE5E0",
    62
  ],
  [
    "f880",
    "\uE61F",
    124
  ],
  [
    "f940",
    "\uE69C"
  ],
  [
    "fa40",
    "\u2170",
    9,
    "\u2160",
    9,
    "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"
  ],
  [
    "fa80",
    "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"
  ],
  [
    "fb40",
    "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"
  ],
  [
    "fb80",
    "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"
  ],
  [
    "fc40",
    "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"
  ]
], require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "\uFF61",
    62
  ],
  [
    "a1a1",
    "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008",
    9,
    "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"
  ],
  [
    "a2a1",
    "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"
  ],
  [
    "a2ba",
    "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"
  ],
  [
    "a2ca",
    "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"
  ],
  [
    "a2dc",
    "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"
  ],
  [
    "a2f2",
    "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"
  ],
  [
    "a2fe",
    "\u25EF"
  ],
  [
    "a3b0",
    "\uFF10",
    9
  ],
  [
    "a3c1",
    "\uFF21",
    25
  ],
  [
    "a3e1",
    "\uFF41",
    25
  ],
  [
    "a4a1",
    "\u3041",
    82
  ],
  [
    "a5a1",
    "\u30A1",
    85
  ],
  [
    "a6a1",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "a6c1",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "a7a1",
    "\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "a7d1",
    "\u0430",
    5,
    "\u0451\u0436",
    25
  ],
  [
    "a8a1",
    "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"
  ],
  [
    "ada1",
    "\u2460",
    19,
    "\u2160",
    9
  ],
  [
    "adc0",
    "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"
  ],
  [
    "addf",
    "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4",
    4,
    "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"
  ],
  [
    "b0a1",
    "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"
  ],
  [
    "b1a1",
    "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"
  ],
  [
    "b2a1",
    "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"
  ],
  [
    "b3a1",
    "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"
  ],
  [
    "b4a1",
    "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"
  ],
  [
    "b5a1",
    "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"
  ],
  [
    "b6a1",
    "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"
  ],
  [
    "b7a1",
    "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"
  ],
  [
    "b8a1",
    "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"
  ],
  [
    "b9a1",
    "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"
  ],
  [
    "baa1",
    "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"
  ],
  [
    "bba1",
    "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"
  ],
  [
    "bca1",
    "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"
  ],
  [
    "bda1",
    "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"
  ],
  [
    "bea1",
    "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"
  ],
  [
    "bfa1",
    "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"
  ],
  [
    "c0a1",
    "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"
  ],
  [
    "c1a1",
    "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"
  ],
  [
    "c2a1",
    "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"
  ],
  [
    "c3a1",
    "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"
  ],
  [
    "c4a1",
    "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"
  ],
  [
    "c5a1",
    "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"
  ],
  [
    "c6a1",
    "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"
  ],
  [
    "c7a1",
    "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"
  ],
  [
    "c8a1",
    "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"
  ],
  [
    "c9a1",
    "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"
  ],
  [
    "caa1",
    "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"
  ],
  [
    "cba1",
    "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"
  ],
  [
    "cca1",
    "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"
  ],
  [
    "cda1",
    "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"
  ],
  [
    "cea1",
    "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"
  ],
  [
    "cfa1",
    "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"
  ],
  [
    "d0a1",
    "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"
  ],
  [
    "d1a1",
    "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"
  ],
  [
    "d2a1",
    "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"
  ],
  [
    "d3a1",
    "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"
  ],
  [
    "d4a1",
    "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"
  ],
  [
    "d5a1",
    "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"
  ],
  [
    "d6a1",
    "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"
  ],
  [
    "d7a1",
    "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"
  ],
  [
    "d8a1",
    "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"
  ],
  [
    "d9a1",
    "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"
  ],
  [
    "daa1",
    "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"
  ],
  [
    "dba1",
    "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"
  ],
  [
    "dca1",
    "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"
  ],
  [
    "dda1",
    "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"
  ],
  [
    "dea1",
    "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"
  ],
  [
    "dfa1",
    "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"
  ],
  [
    "e0a1",
    "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"
  ],
  [
    "e1a1",
    "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"
  ],
  [
    "e2a1",
    "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"
  ],
  [
    "e3a1",
    "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"
  ],
  [
    "e4a1",
    "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"
  ],
  [
    "e5a1",
    "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"
  ],
  [
    "e6a1",
    "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"
  ],
  [
    "e7a1",
    "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"
  ],
  [
    "e8a1",
    "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"
  ],
  [
    "e9a1",
    "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"
  ],
  [
    "eaa1",
    "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"
  ],
  [
    "eba1",
    "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"
  ],
  [
    "eca1",
    "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"
  ],
  [
    "eda1",
    "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"
  ],
  [
    "eea1",
    "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"
  ],
  [
    "efa1",
    "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"
  ],
  [
    "f0a1",
    "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"
  ],
  [
    "f1a1",
    "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"
  ],
  [
    "f2a1",
    "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"
  ],
  [
    "f3a1",
    "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"
  ],
  [
    "f4a1",
    "\u582F\u69C7\u9059\u7464\u51DC\u7199"
  ],
  [
    "f9a1",
    "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"
  ],
  [
    "faa1",
    "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"
  ],
  [
    "fba1",
    "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"
  ],
  [
    "fca1",
    "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"
  ],
  [
    "fcf1",
    "\u2170",
    9,
    "\uFFE2\uFFE4\uFF07\uFF02"
  ],
  [
    "8fa2af",
    "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"
  ],
  [
    "8fa2c2",
    "\xA1\xA6\xBF"
  ],
  [
    "8fa2eb",
    "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"
  ],
  [
    "8fa6e1",
    "\u0386\u0388\u0389\u038A\u03AA"
  ],
  [
    "8fa6e7",
    "\u038C"
  ],
  [
    "8fa6e9",
    "\u038E\u03AB"
  ],
  [
    "8fa6ec",
    "\u038F"
  ],
  [
    "8fa6f1",
    "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"
  ],
  [
    "8fa7c2",
    "\u0402",
    10,
    "\u040E\u040F"
  ],
  [
    "8fa7f2",
    "\u0452",
    10,
    "\u045E\u045F"
  ],
  [
    "8fa9a1",
    "\xC6\u0110"
  ],
  [
    "8fa9a4",
    "\u0126"
  ],
  [
    "8fa9a6",
    "\u0132"
  ],
  [
    "8fa9a8",
    "\u0141\u013F"
  ],
  [
    "8fa9ab",
    "\u014A\xD8\u0152"
  ],
  [
    "8fa9af",
    "\u0166\xDE"
  ],
  [
    "8fa9c1",
    "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"
  ],
  [
    "8faaa1",
    "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"
  ],
  [
    "8faaba",
    "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"
  ],
  [
    "8faba1",
    "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"
  ],
  [
    "8fabbd",
    "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"
  ],
  [
    "8fabc5",
    "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"
  ],
  [
    "8fb0a1",
    "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"
  ],
  [
    "8fb1a1",
    "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"
  ],
  [
    "8fb2a1",
    "\u5092\u5093\u5094\u5096\u509B\u509C\u509E",
    4,
    "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"
  ],
  [
    "8fb3a1",
    "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"
  ],
  [
    "8fb4a1",
    "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"
  ],
  [
    "8fb5a1",
    "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"
  ],
  [
    "8fb6a1",
    "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D",
    5,
    "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4",
    4,
    "\u56F1\u56EB\u56ED"
  ],
  [
    "8fb7a1",
    "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D",
    4,
    "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"
  ],
  [
    "8fb8a1",
    "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"
  ],
  [
    "8fb9a1",
    "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"
  ],
  [
    "8fbaa1",
    "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6",
    4,
    "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"
  ],
  [
    "8fbba1",
    "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"
  ],
  [
    "8fbca1",
    "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A",
    4,
    "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"
  ],
  [
    "8fbda1",
    "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0",
    4,
    "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"
  ],
  [
    "8fbea1",
    "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110",
    4,
    "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"
  ],
  [
    "8fbfa1",
    "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"
  ],
  [
    "8fc0a1",
    "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"
  ],
  [
    "8fc1a1",
    "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"
  ],
  [
    "8fc2a1",
    "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"
  ],
  [
    "8fc3a1",
    "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E",
    4,
    "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"
  ],
  [
    "8fc4a1",
    "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"
  ],
  [
    "8fc5a1",
    "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"
  ],
  [
    "8fc6a1",
    "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"
  ],
  [
    "8fc7a1",
    "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"
  ],
  [
    "8fc8a1",
    "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"
  ],
  [
    "8fc9a1",
    "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094",
    4,
    "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103",
    4,
    "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"
  ],
  [
    "8fcaa1",
    "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"
  ],
  [
    "8fcba1",
    "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"
  ],
  [
    "8fcca1",
    "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428",
    9,
    "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"
  ],
  [
    "8fcda1",
    "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579",
    5,
    "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"
  ],
  [
    "8fcea1",
    "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2",
    6,
    "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"
  ],
  [
    "8fcfa1",
    "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"
  ],
  [
    "8fd0a1",
    "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"
  ],
  [
    "8fd1a1",
    "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"
  ],
  [
    "8fd2a1",
    "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59",
    5
  ],
  [
    "8fd3a1",
    "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"
  ],
  [
    "8fd4a1",
    "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2",
    4,
    "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"
  ],
  [
    "8fd5a1",
    "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"
  ],
  [
    "8fd6a1",
    "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"
  ],
  [
    "8fd7a1",
    "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"
  ],
  [
    "8fd8a1",
    "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"
  ],
  [
    "8fd9a1",
    "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F",
    4,
    "\u8556\u8559\u855C",
    6,
    "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"
  ],
  [
    "8fdaa1",
    "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660",
    4,
    "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"
  ],
  [
    "8fdba1",
    "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783",
    6,
    "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"
  ],
  [
    "8fdca1",
    "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA",
    4,
    "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"
  ],
  [
    "8fdda1",
    "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4",
    4,
    "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"
  ],
  [
    "8fdea1",
    "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42",
    4,
    "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"
  ],
  [
    "8fdfa1",
    "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"
  ],
  [
    "8fe0a1",
    "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"
  ],
  [
    "8fe1a1",
    "\u8F43\u8F47\u8F4F\u8F51",
    4,
    "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"
  ],
  [
    "8fe2a1",
    "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"
  ],
  [
    "8fe3a1",
    "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC",
    5,
    "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275",
    4,
    "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"
  ],
  [
    "8fe4a1",
    "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF",
    4,
    "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"
  ],
  [
    "8fe5a1",
    "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9",
    4,
    "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"
  ],
  [
    "8fe6a1",
    "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"
  ],
  [
    "8fe7a1",
    "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"
  ],
  [
    "8fe8a1",
    "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931",
    4,
    "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"
  ],
  [
    "8fe9a1",
    "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF",
    4
  ],
  [
    "8feaa1",
    "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A",
    4,
    "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"
  ],
  [
    "8feba1",
    "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26",
    4,
    "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"
  ],
  [
    "8feca1",
    "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"
  ],
  [
    "8feda1",
    "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43",
    4,
    "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D",
    4,
    "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"
  ]
], require$$2 = [
  [
    "0",
    "\0",
    127,
    "\u20AC"
  ],
  [
    "8140",
    "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A",
    5,
    "\u4E72\u4E74",
    9,
    "\u4E7F",
    6,
    "\u4E87\u4E8A"
  ],
  [
    "8180",
    "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02",
    6,
    "\u4F0B\u4F0C\u4F12",
    4,
    "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E",
    4,
    "\u4F44\u4F45\u4F47",
    5,
    "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"
  ],
  [
    "8240",
    "\u4FA4\u4FAB\u4FAD\u4FB0",
    4,
    "\u4FB6",
    8,
    "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2",
    4,
    "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF",
    11
  ],
  [
    "8280",
    "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F",
    10,
    "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050",
    4,
    "\u5056\u5057\u5058\u5059\u505B\u505D",
    7,
    "\u5066",
    5,
    "\u506D",
    8,
    "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E",
    20,
    "\u50A4\u50A6\u50AA\u50AB\u50AD",
    4,
    "\u50B3",
    6,
    "\u50BC"
  ],
  [
    "8340",
    "\u50BD",
    17,
    "\u50D0",
    5,
    "\u50D7\u50D8\u50D9\u50DB",
    10,
    "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6",
    4,
    "\u50FC",
    9,
    "\u5108"
  ],
  [
    "8380",
    "\u5109\u510A\u510C",
    5,
    "\u5113",
    13,
    "\u5122",
    28,
    "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D",
    4,
    "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6",
    4,
    "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2",
    5
  ],
  [
    "8440",
    "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5",
    5,
    "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244",
    5,
    "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"
  ],
  [
    "8480",
    "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273",
    9,
    "\u527E\u5280\u5283",
    4,
    "\u5289",
    6,
    "\u5291\u5292\u5294",
    6,
    "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4",
    9,
    "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9",
    5,
    "\u52E0\u52E1\u52E2\u52E3\u52E5",
    10,
    "\u52F1",
    7,
    "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"
  ],
  [
    "8540",
    "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F",
    9,
    "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"
  ],
  [
    "8580",
    "\u5390",
    4,
    "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF",
    6,
    "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3",
    4,
    "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D",
    4,
    "\u5463\u5465\u5467\u5469",
    7,
    "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"
  ],
  [
    "8640",
    "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0",
    4,
    "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4",
    5,
    "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A",
    4,
    "\u5512\u5513\u5515",
    5,
    "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"
  ],
  [
    "8680",
    "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B",
    4,
    "\u5551\u5552\u5553\u5554\u5557",
    4,
    "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F",
    5,
    "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0",
    6,
    "\u55A8",
    8,
    "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF",
    4,
    "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7",
    4,
    "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8",
    4,
    "\u55FF\u5602\u5603\u5604\u5605"
  ],
  [
    "8740",
    "\u5606\u5607\u560A\u560B\u560D\u5610",
    7,
    "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640",
    11,
    "\u564F",
    4,
    "\u5655\u5656\u565A\u565B\u565D",
    4
  ],
  [
    "8780",
    "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D",
    7,
    "\u5687",
    6,
    "\u5690\u5691\u5692\u5694",
    14,
    "\u56A4",
    10,
    "\u56B0",
    6,
    "\u56B8\u56B9\u56BA\u56BB\u56BD",
    12,
    "\u56CB",
    8,
    "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5",
    5,
    "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B",
    6
  ],
  [
    "8840",
    "\u5712",
    9,
    "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734",
    4,
    "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752",
    4,
    "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"
  ],
  [
    "8880",
    "\u5781\u5787\u5788\u5789\u578A\u578D",
    4,
    "\u5794",
    6,
    "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9",
    8,
    "\u57C4",
    6,
    "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5",
    7,
    "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825",
    4,
    "\u582B",
    4,
    "\u5831\u5832\u5833\u5834\u5836",
    7
  ],
  [
    "8940",
    "\u583E",
    5,
    "\u5845",
    6,
    "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859",
    4,
    "\u585F",
    5,
    "\u5866",
    4,
    "\u586D",
    16,
    "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"
  ],
  [
    "8980",
    "\u588D",
    4,
    "\u5894",
    4,
    "\u589B\u589C\u589D\u58A0",
    7,
    "\u58AA",
    17,
    "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6",
    10,
    "\u58D2\u58D3\u58D4\u58D6",
    13,
    "\u58E5",
    5,
    "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA",
    7,
    "\u5903\u5905\u5906\u5908",
    4,
    "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"
  ],
  [
    "8a40",
    "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B",
    4,
    "\u5961\u5963\u5964\u5966",
    12,
    "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"
  ],
  [
    "8a80",
    "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3",
    5,
    "\u59BA\u59BC\u59BD\u59BF",
    6,
    "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE",
    4,
    "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED",
    11,
    "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A",
    6,
    "\u5A33\u5A35\u5A37",
    4,
    "\u5A3D\u5A3E\u5A3F\u5A41",
    4,
    "\u5A47\u5A48\u5A4B",
    9,
    "\u5A56\u5A57\u5A58\u5A59\u5A5B",
    5
  ],
  [
    "8b40",
    "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B",
    8,
    "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80",
    17,
    "\u5A93",
    6,
    "\u5A9C",
    13,
    "\u5AAB\u5AAC"
  ],
  [
    "8b80",
    "\u5AAD",
    4,
    "\u5AB4\u5AB6\u5AB7\u5AB9",
    4,
    "\u5ABF\u5AC0\u5AC3",
    5,
    "\u5ACA\u5ACB\u5ACD",
    4,
    "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC",
    4,
    "\u5AF2",
    22,
    "\u5B0A",
    11,
    "\u5B18",
    25,
    "\u5B33\u5B35\u5B36\u5B38",
    7,
    "\u5B41",
    6
  ],
  [
    "8c40",
    "\u5B48",
    7,
    "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"
  ],
  [
    "8c80",
    "\u5BD1\u5BD4",
    8,
    "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9",
    4,
    "\u5BEF\u5BF1",
    6,
    "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67",
    6,
    "\u5C70\u5C72",
    6,
    "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83",
    4,
    "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D",
    4,
    "\u5CA4",
    4
  ],
  [
    "8d40",
    "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5",
    5,
    "\u5CCC",
    5,
    "\u5CD3",
    5,
    "\u5CDA",
    6,
    "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1",
    9,
    "\u5CFC",
    4
  ],
  [
    "8d80",
    "\u5D01\u5D04\u5D05\u5D08",
    5,
    "\u5D0F",
    4,
    "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F",
    4,
    "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F",
    4,
    "\u5D35",
    7,
    "\u5D3F",
    7,
    "\u5D48\u5D49\u5D4D",
    10,
    "\u5D59\u5D5A\u5D5C\u5D5E",
    10,
    "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75",
    12,
    "\u5D83",
    21,
    "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"
  ],
  [
    "8e40",
    "\u5DA1",
    21,
    "\u5DB8",
    12,
    "\u5DC6",
    6,
    "\u5DCE",
    12,
    "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"
  ],
  [
    "8e80",
    "\u5DF0\u5DF5\u5DF6\u5DF8",
    4,
    "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E",
    7,
    "\u5E28",
    4,
    "\u5E2F\u5E30\u5E32",
    4,
    "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46",
    5,
    "\u5E4D",
    6,
    "\u5E56",
    4,
    "\u5E5C\u5E5D\u5E5F\u5E60\u5E63",
    14,
    "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8",
    4,
    "\u5EAE",
    4,
    "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF",
    6
  ],
  [
    "8f40",
    "\u5EC6\u5EC7\u5EC8\u5ECB",
    5,
    "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC",
    11,
    "\u5EE9\u5EEB",
    8,
    "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"
  ],
  [
    "8f80",
    "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32",
    6,
    "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41",
    14,
    "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2",
    5,
    "\u5FA9\u5FAB\u5FAC\u5FAF",
    5,
    "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE",
    4,
    "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"
  ],
  [
    "9040",
    "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030",
    4,
    "\u6036",
    4,
    "\u603D\u603E\u6040\u6044",
    6,
    "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"
  ],
  [
    "9080",
    "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD",
    7,
    "\u60C7\u60C8\u60C9\u60CC",
    4,
    "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1",
    4,
    "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB",
    4,
    "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110",
    4,
    "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C",
    18,
    "\u6140",
    6
  ],
  [
    "9140",
    "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156",
    6,
    "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169",
    6,
    "\u6171\u6172\u6173\u6174\u6176\u6178",
    18,
    "\u618C\u618D\u618F",
    4,
    "\u6195"
  ],
  [
    "9180",
    "\u6196",
    6,
    "\u619E",
    8,
    "\u61AA\u61AB\u61AD",
    9,
    "\u61B8",
    5,
    "\u61BF\u61C0\u61C1\u61C3",
    4,
    "\u61C9\u61CC",
    4,
    "\u61D3\u61D5",
    16,
    "\u61E7",
    13,
    "\u61F6",
    8,
    "\u6200",
    5,
    "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238",
    4,
    "\u6242\u6244\u6245\u6246\u624A"
  ],
  [
    "9240",
    "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C",
    6,
    "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B",
    5,
    "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"
  ],
  [
    "9280",
    "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333",
    5,
    "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356",
    7,
    "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399",
    6,
    "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"
  ],
  [
    "9340",
    "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7",
    6,
    "\u63DF\u63E2\u63E4",
    4,
    "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406",
    4,
    "\u640D\u640E\u6411\u6412\u6415",
    5,
    "\u641D\u641F\u6422\u6423\u6424"
  ],
  [
    "9380",
    "\u6425\u6427\u6428\u6429\u642B\u642E",
    5,
    "\u6435",
    4,
    "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B",
    6,
    "\u6453\u6455\u6456\u6457\u6459",
    4,
    "\u645F",
    7,
    "\u6468\u646A\u646B\u646C\u646E",
    9,
    "\u647B",
    6,
    "\u6483\u6486\u6488",
    8,
    "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F",
    4,
    "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6",
    6,
    "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"
  ],
  [
    "9440",
    "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7",
    24,
    "\u6501",
    7,
    "\u650A",
    7,
    "\u6513",
    4,
    "\u6519",
    8
  ],
  [
    "9480",
    "\u6522\u6523\u6524\u6526",
    4,
    "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540",
    4,
    "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578",
    14,
    "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1",
    7,
    "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8",
    7,
    "\u65E1\u65E3\u65E4\u65EA\u65EB"
  ],
  [
    "9540",
    "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB",
    4,
    "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637",
    4,
    "\u663D\u663F\u6640\u6642\u6644",
    6,
    "\u664D\u664E\u6650\u6651\u6658"
  ],
  [
    "9580",
    "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669",
    4,
    "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698",
    4,
    "\u669E",
    8,
    "\u66A9",
    4,
    "\u66AF",
    4,
    "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF",
    25,
    "\u66DA\u66DE",
    7,
    "\u66E7\u66E8\u66EA",
    5,
    "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"
  ],
  [
    "9640",
    "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720",
    5,
    "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757",
    4,
    "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"
  ],
  [
    "9680",
    "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9",
    7,
    "\u67C2\u67C5",
    9,
    "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5",
    7,
    "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818",
    4,
    "\u681E\u681F\u6820\u6822",
    6,
    "\u682B",
    6,
    "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856",
    5
  ],
  [
    "9740",
    "\u685C\u685D\u685E\u685F\u686A\u686C",
    7,
    "\u6875\u6878",
    8,
    "\u6882\u6884\u6887",
    7,
    "\u6890\u6891\u6892\u6894\u6895\u6896\u6898",
    9,
    "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"
  ],
  [
    "9780",
    "\u68B9",
    6,
    "\u68C1\u68C3",
    5,
    "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB",
    4,
    "\u68E1\u68E2\u68E4",
    9,
    "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906",
    4,
    "\u690C\u690F\u6911\u6913",
    11,
    "\u6921\u6922\u6923\u6925",
    7,
    "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943",
    16,
    "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"
  ],
  [
    "9840",
    "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972",
    4,
    "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E",
    5,
    "\u6996\u6997\u6999\u699A\u699D",
    9,
    "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"
  ],
  [
    "9880",
    "\u69BE\u69BF\u69C0\u69C2",
    7,
    "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5",
    5,
    "\u69DC\u69DD\u69DE\u69E1",
    11,
    "\u69EE\u69EF\u69F0\u69F1\u69F3",
    9,
    "\u69FE\u6A00",
    9,
    "\u6A0B",
    11,
    "\u6A19",
    5,
    "\u6A20\u6A22",
    5,
    "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36",
    6,
    "\u6A3F",
    4,
    "\u6A45\u6A46\u6A48",
    7,
    "\u6A51",
    6,
    "\u6A5A"
  ],
  [
    "9940",
    "\u6A5C",
    4,
    "\u6A62\u6A63\u6A64\u6A66",
    10,
    "\u6A72",
    6,
    "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85",
    8,
    "\u6A8F\u6A92",
    4,
    "\u6A98",
    7,
    "\u6AA1",
    5
  ],
  [
    "9980",
    "\u6AA7\u6AA8\u6AAA\u6AAD",
    114,
    "\u6B25\u6B26\u6B28",
    6
  ],
  [
    "9a40",
    "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D",
    11,
    "\u6B5A",
    7,
    "\u6B68\u6B69\u6B6B",
    13,
    "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"
  ],
  [
    "9a80",
    "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C",
    4,
    "\u6BA2",
    7,
    "\u6BAB",
    7,
    "\u6BB6\u6BB8",
    6,
    "\u6BC0\u6BC3\u6BC4\u6BC6",
    4,
    "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC",
    4,
    "\u6BE2",
    7,
    "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE",
    6,
    "\u6C08",
    4,
    "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B",
    4,
    "\u6C51\u6C52\u6C53\u6C56\u6C58"
  ],
  [
    "9b40",
    "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B",
    4,
    "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"
  ],
  [
    "9b80",
    "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F",
    5,
    "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D",
    4,
    "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96",
    4,
    "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9",
    5,
    "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"
  ],
  [
    "9c40",
    "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD",
    7,
    "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"
  ],
  [
    "9c80",
    "\u6E36\u6E37\u6E39\u6E3B",
    7,
    "\u6E45",
    7,
    "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60",
    10,
    "\u6E6C\u6E6D\u6E6F",
    14,
    "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A",
    4,
    "\u6E91",
    6,
    "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA",
    5
  ],
  [
    "9d40",
    "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA",
    7,
    "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A",
    4,
    "\u6F10\u6F11\u6F12\u6F16",
    9,
    "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37",
    6,
    "\u6F3F\u6F40\u6F41\u6F42"
  ],
  [
    "9d80",
    "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E",
    9,
    "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67",
    5,
    "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D",
    6,
    "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F",
    12,
    "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2",
    4,
    "\u6FA8",
    10,
    "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA",
    5,
    "\u6FC1\u6FC3",
    5,
    "\u6FCA",
    6,
    "\u6FD3",
    10,
    "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"
  ],
  [
    "9e40",
    "\u6FE6",
    7,
    "\u6FF0",
    32,
    "\u7012",
    7,
    "\u701C",
    6,
    "\u7024",
    6
  ],
  [
    "9e80",
    "\u702B",
    9,
    "\u7036\u7037\u7038\u703A",
    17,
    "\u704D\u704E\u7050",
    13,
    "\u705F",
    11,
    "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E",
    12,
    "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB",
    12,
    "\u70DA"
  ],
  [
    "9f40",
    "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0",
    6,
    "\u70F8\u70FA\u70FB\u70FC\u70FE",
    10,
    "\u710B",
    4,
    "\u7111\u7112\u7114\u7117\u711B",
    10,
    "\u7127",
    7,
    "\u7132\u7133\u7134"
  ],
  [
    "9f80",
    "\u7135\u7137",
    13,
    "\u7146\u7147\u7148\u7149\u714B\u714D\u714F",
    12,
    "\u715D\u715F",
    4,
    "\u7165\u7169",
    4,
    "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E",
    5,
    "\u7185",
    4,
    "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A",
    4,
    "\u71A1",
    6,
    "\u71A9\u71AA\u71AB\u71AD",
    5,
    "\u71B4\u71B6\u71B7\u71B8\u71BA",
    8,
    "\u71C4",
    9,
    "\u71CF",
    4
  ],
  [
    "a040",
    "\u71D6",
    9,
    "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8",
    5,
    "\u71EF",
    9,
    "\u71FA",
    11,
    "\u7207",
    19
  ],
  [
    "a080",
    "\u721B\u721C\u721E",
    9,
    "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240",
    6,
    "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285",
    4,
    "\u728C\u728E\u7290\u7291\u7293",
    11,
    "\u72A0",
    11,
    "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA",
    6,
    "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"
  ],
  [
    "a1a1",
    "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008",
    7,
    "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"
  ],
  [
    "a2a1",
    "\u2170",
    9
  ],
  [
    "a2b1",
    "\u2488",
    19,
    "\u2474",
    19,
    "\u2460",
    9
  ],
  [
    "a2e5",
    "\u3220",
    9
  ],
  [
    "a2f1",
    "\u2160",
    11
  ],
  [
    "a3a1",
    "\uFF01\uFF02\uFF03\uFFE5\uFF05",
    88,
    "\uFFE3"
  ],
  [
    "a4a1",
    "\u3041",
    82
  ],
  [
    "a5a1",
    "\u30A1",
    85
  ],
  [
    "a6a1",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "a6c1",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "a6e0",
    "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"
  ],
  [
    "a6ee",
    "\uFE3B\uFE3C\uFE37\uFE38\uFE31"
  ],
  [
    "a6f4",
    "\uFE33\uFE34"
  ],
  [
    "a7a1",
    "\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "a7d1",
    "\u0430",
    5,
    "\u0451\u0436",
    25
  ],
  [
    "a840",
    "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550",
    35,
    "\u2581",
    6
  ],
  [
    "a880",
    "\u2588",
    7,
    "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"
  ],
  [
    "a8a1",
    "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"
  ],
  [
    "a8bd",
    "\u0144\u0148"
  ],
  [
    "a8c0",
    "\u0261"
  ],
  [
    "a8c5",
    "\u3105",
    36
  ],
  [
    "a940",
    "\u3021",
    8,
    "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"
  ],
  [
    "a959",
    "\u2121\u3231"
  ],
  [
    "a95c",
    "\u2010"
  ],
  [
    "a960",
    "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49",
    9,
    "\uFE54\uFE55\uFE56\uFE57\uFE59",
    8
  ],
  [
    "a980",
    "\uFE62",
    4,
    "\uFE68\uFE69\uFE6A\uFE6B"
  ],
  [
    "a996",
    "\u3007"
  ],
  [
    "a9a4",
    "\u2500",
    75
  ],
  [
    "aa40",
    "\u72DC\u72DD\u72DF\u72E2",
    5,
    "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304",
    5,
    "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340",
    8
  ],
  [
    "aa80",
    "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358",
    7,
    "\u7361",
    10,
    "\u736E\u7370\u7371"
  ],
  [
    "ab40",
    "\u7372",
    11,
    "\u737F",
    4,
    "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3",
    5,
    "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3",
    4
  ],
  [
    "ab80",
    "\u73CB\u73CC\u73CE\u73D2",
    6,
    "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3",
    4
  ],
  [
    "ac40",
    "\u73F8",
    10,
    "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411",
    8,
    "\u741C",
    5,
    "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437",
    4,
    "\u743D\u743E\u743F\u7440\u7442",
    11
  ],
  [
    "ac80",
    "\u744E",
    6,
    "\u7456\u7458\u745D\u7460",
    12,
    "\u746E\u746F\u7471",
    4,
    "\u7478\u7479\u747A"
  ],
  [
    "ad40",
    "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491",
    10,
    "\u749D\u749F",
    7,
    "\u74AA",
    15,
    "\u74BB",
    12
  ],
  [
    "ad80",
    "\u74C8",
    9,
    "\u74D3",
    8,
    "\u74DD\u74DF\u74E1\u74E5\u74E7",
    6,
    "\u74F0\u74F1\u74F2"
  ],
  [
    "ae40",
    "\u74F3\u74F5\u74F8",
    6,
    "\u7500\u7501\u7502\u7503\u7505",
    7,
    "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520",
    4,
    "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"
  ],
  [
    "ae80",
    "\u755D",
    7,
    "\u7567\u7568\u7569\u756B",
    6,
    "\u7573\u7575\u7576\u7577\u757A",
    4,
    "\u7580\u7581\u7582\u7584\u7585\u7587"
  ],
  [
    "af40",
    "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6",
    4,
    "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"
  ],
  [
    "af80",
    "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"
  ],
  [
    "b040",
    "\u7645",
    6,
    "\u764E",
    5,
    "\u7655\u7657",
    4,
    "\u765D\u765F\u7660\u7661\u7662\u7664",
    6,
    "\u766C\u766D\u766E\u7670",
    7,
    "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"
  ],
  [
    "b080",
    "\u769C",
    7,
    "\u76A5",
    8,
    "\u76AF\u76B0\u76B3\u76B5",
    9,
    "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"
  ],
  [
    "b140",
    "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0",
    4,
    "\u76E6",
    7,
    "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E",
    10,
    "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"
  ],
  [
    "b180",
    "\u772C\u772E\u7730",
    4,
    "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748",
    7,
    "\u7752",
    7,
    "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"
  ],
  [
    "b240",
    "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D",
    11,
    "\u777A\u777B\u777C\u7781\u7782\u7783\u7786",
    5,
    "\u778F\u7790\u7793",
    11,
    "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6",
    4
  ],
  [
    "b280",
    "\u77BC\u77BE\u77C0",
    12,
    "\u77CE",
    8,
    "\u77D8\u77D9\u77DA\u77DD",
    4,
    "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"
  ],
  [
    "b340",
    "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803",
    5,
    "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"
  ],
  [
    "b380",
    "\u785B\u785C\u785E",
    11,
    "\u786F",
    7,
    "\u7878\u7879\u787A\u787B\u787D",
    6,
    "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"
  ],
  [
    "b440",
    "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8",
    7,
    "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA",
    9
  ],
  [
    "b480",
    "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED",
    4,
    "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB",
    5,
    "\u7902\u7903\u7904\u7906",
    6,
    "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"
  ],
  [
    "b540",
    "\u790D",
    5,
    "\u7914",
    9,
    "\u791F",
    4,
    "\u7925",
    14,
    "\u7935",
    4,
    "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A",
    8,
    "\u7954\u7955\u7958\u7959\u7961\u7963"
  ],
  [
    "b580",
    "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970",
    6,
    "\u7979\u797B",
    4,
    "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"
  ],
  [
    "b640",
    "\u7993",
    6,
    "\u799B",
    11,
    "\u79A8",
    10,
    "\u79B4",
    4,
    "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9",
    5,
    "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"
  ],
  [
    "b680",
    "\u79EC\u79EE\u79F1",
    6,
    "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F",
    4,
    "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"
  ],
  [
    "b740",
    "\u7A1D\u7A1F\u7A21\u7A22\u7A24",
    14,
    "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40",
    5,
    "\u7A47",
    9,
    "\u7A52",
    4,
    "\u7A58",
    16
  ],
  [
    "b780",
    "\u7A69",
    6,
    "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"
  ],
  [
    "b840",
    "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE",
    4,
    "\u7AB4",
    10,
    "\u7AC0",
    10,
    "\u7ACC",
    9,
    "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7",
    5,
    "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"
  ],
  [
    "b880",
    "\u7AF4",
    4,
    "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"
  ],
  [
    "b940",
    "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F",
    5,
    "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63",
    10,
    "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86",
    6,
    "\u7B8E\u7B8F"
  ],
  [
    "b980",
    "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9",
    7,
    "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"
  ],
  [
    "ba40",
    "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4",
    4,
    "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2",
    4,
    "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF",
    7,
    "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10",
    5,
    "\u7C17\u7C18\u7C19"
  ],
  [
    "ba80",
    "\u7C1A",
    4,
    "\u7C20",
    5,
    "\u7C28\u7C29\u7C2B",
    12,
    "\u7C39",
    5,
    "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"
  ],
  [
    "bb40",
    "\u7C43",
    9,
    "\u7C4E",
    36,
    "\u7C75",
    5,
    "\u7C7E",
    9
  ],
  [
    "bb80",
    "\u7C88\u7C8A",
    6,
    "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4",
    4,
    "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"
  ],
  [
    "bc40",
    "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE",
    6,
    "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1",
    6,
    "\u7CE9",
    5,
    "\u7CF0",
    7,
    "\u7CF9\u7CFA\u7CFC",
    13,
    "\u7D0B",
    5
  ],
  [
    "bc80",
    "\u7D11",
    14,
    "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30",
    6,
    "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"
  ],
  [
    "bd40",
    "\u7D37",
    54,
    "\u7D6F",
    7
  ],
  [
    "bd80",
    "\u7D78",
    32,
    "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"
  ],
  [
    "be40",
    "\u7D99",
    12,
    "\u7DA7",
    6,
    "\u7DAF",
    42
  ],
  [
    "be80",
    "\u7DDA",
    32,
    "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"
  ],
  [
    "bf40",
    "\u7DFB",
    62
  ],
  [
    "bf80",
    "\u7E3A\u7E3C",
    4,
    "\u7E42",
    4,
    "\u7E48",
    21,
    "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"
  ],
  [
    "c040",
    "\u7E5E",
    35,
    "\u7E83",
    23,
    "\u7E9C\u7E9D\u7E9E"
  ],
  [
    "c080",
    "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B",
    6,
    "\u7F43\u7F46",
    9,
    "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"
  ],
  [
    "c140",
    "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63",
    4,
    "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82",
    7,
    "\u7F8B\u7F8D\u7F8F",
    4,
    "\u7F95",
    4,
    "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8",
    6,
    "\u7FB1"
  ],
  [
    "c180",
    "\u7FB3",
    4,
    "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF",
    4,
    "\u7FD6\u7FD7\u7FD9",
    5,
    "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"
  ],
  [
    "c240",
    "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4",
    6,
    "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B",
    5,
    "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"
  ],
  [
    "c280",
    "\u8059\u805B",
    13,
    "\u806B",
    5,
    "\u8072",
    11,
    "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"
  ],
  [
    "c340",
    "\u807E\u8081\u8082\u8085\u8088\u808A\u808D",
    5,
    "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7",
    4,
    "\u80CF",
    6,
    "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"
  ],
  [
    "c380",
    "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F",
    12,
    "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139",
    4,
    "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"
  ],
  [
    "c440",
    "\u8140",
    5,
    "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B",
    4,
    "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183",
    4,
    "\u8189\u818B\u818C\u818D\u818E\u8190\u8192",
    5,
    "\u8199\u819A\u819E",
    4,
    "\u81A4\u81A5"
  ],
  [
    "c480",
    "\u81A7\u81A9\u81AB",
    7,
    "\u81B4",
    5,
    "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD",
    6,
    "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"
  ],
  [
    "c540",
    "\u81D4",
    14,
    "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE",
    4,
    "\u81F5",
    5,
    "\u81FD\u81FF\u8203\u8207",
    4,
    "\u820E\u820F\u8211\u8213\u8215",
    5,
    "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"
  ],
  [
    "c580",
    "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250",
    7,
    "\u8259\u825B\u825C\u825D\u825E\u8260",
    7,
    "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"
  ],
  [
    "c640",
    "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"
  ],
  [
    "c680",
    "\u82FA\u82FC",
    4,
    "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D",
    9,
    "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"
  ],
  [
    "c740",
    "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A",
    4,
    "\u8353\u8355",
    4,
    "\u835D\u8362\u8370",
    6,
    "\u8379\u837A\u837E",
    6,
    "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1",
    6,
    "\u83AC\u83AD\u83AE"
  ],
  [
    "c780",
    "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"
  ],
  [
    "c840",
    "\u83EE\u83EF\u83F3",
    4,
    "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412",
    5,
    "\u8419\u841A\u841B\u841E",
    5,
    "\u8429",
    7,
    "\u8432",
    5,
    "\u8439\u843A\u843B\u843E",
    7,
    "\u8447\u8448\u8449"
  ],
  [
    "c880",
    "\u844A",
    6,
    "\u8452",
    4,
    "\u8458\u845D\u845E\u845F\u8460\u8462\u8464",
    4,
    "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"
  ],
  [
    "c940",
    "\u847D",
    4,
    "\u8483\u8484\u8485\u8486\u848A\u848D\u848F",
    7,
    "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2",
    12,
    "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"
  ],
  [
    "c980",
    "\u84D8",
    4,
    "\u84DE\u84E1\u84E2\u84E4\u84E7",
    4,
    "\u84ED\u84EE\u84EF\u84F1",
    10,
    "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"
  ],
  [
    "ca40",
    "\u8503",
    8,
    "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522",
    8,
    "\u852D",
    9,
    "\u853E",
    4,
    "\u8544\u8545\u8546\u8547\u854B",
    10
  ],
  [
    "ca80",
    "\u8557\u8558\u855A\u855B\u855C\u855D\u855F",
    4,
    "\u8565\u8566\u8567\u8569",
    8,
    "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"
  ],
  [
    "cb40",
    "\u8582\u8583\u8586\u8588",
    6,
    "\u8590",
    10,
    "\u859D",
    6,
    "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1",
    5,
    "\u85B8\u85BA",
    6,
    "\u85C2",
    6,
    "\u85CA",
    4,
    "\u85D1\u85D2"
  ],
  [
    "cb80",
    "\u85D4\u85D6",
    5,
    "\u85DD",
    6,
    "\u85E5\u85E6\u85E7\u85E8\u85EA",
    14,
    "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"
  ],
  [
    "cc40",
    "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600",
    4,
    "\u8606",
    10,
    "\u8612\u8613\u8614\u8615\u8617",
    15,
    "\u8628\u862A",
    13,
    "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"
  ],
  [
    "cc80",
    "\u8641",
    11,
    "\u8652\u8653\u8655",
    4,
    "\u865B\u865C\u865D\u865F\u8660\u8661\u8663",
    7,
    "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"
  ],
  [
    "cd40",
    "\u866D\u866F\u8670\u8672",
    6,
    "\u8683",
    6,
    "\u868E",
    4,
    "\u8694\u8696",
    5,
    "\u869E",
    4,
    "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB",
    4,
    "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"
  ],
  [
    "cd80",
    "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"
  ],
  [
    "ce40",
    "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740",
    6,
    "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A",
    5,
    "\u8761\u8762\u8766",
    7,
    "\u876F\u8771\u8772\u8773\u8775"
  ],
  [
    "ce80",
    "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E",
    4,
    "\u8794\u8795\u8796\u8798",
    6,
    "\u87A0",
    4,
    "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"
  ],
  [
    "cf40",
    "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1",
    4,
    "\u87C7\u87C8\u87C9\u87CC",
    4,
    "\u87D4",
    6,
    "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF",
    9
  ],
  [
    "cf80",
    "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804",
    5,
    "\u880B",
    7,
    "\u8814\u8817\u8818\u8819\u881A\u881C",
    4,
    "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"
  ],
  [
    "d040",
    "\u8824",
    13,
    "\u8833",
    5,
    "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846",
    5,
    "\u884E",
    5,
    "\u8855\u8856\u8858\u885A",
    6,
    "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"
  ],
  [
    "d080",
    "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897",
    4,
    "\u889D",
    4,
    "\u88A3\u88A5",
    5,
    "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"
  ],
  [
    "d140",
    "\u88AC\u88AE\u88AF\u88B0\u88B2",
    4,
    "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA",
    4,
    "\u88E0\u88E1\u88E6\u88E7\u88E9",
    6,
    "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903",
    5
  ],
  [
    "d180",
    "\u8909\u890B",
    4,
    "\u8911\u8914",
    4,
    "\u891C",
    4,
    "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"
  ],
  [
    "d240",
    "\u8938",
    8,
    "\u8942\u8943\u8945",
    24,
    "\u8960",
    5,
    "\u8967",
    19,
    "\u897C"
  ],
  [
    "d280",
    "\u897D\u897E\u8980\u8982\u8984\u8985\u8987",
    26,
    "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"
  ],
  [
    "d340",
    "\u89A2",
    30,
    "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4",
    6
  ],
  [
    "d380",
    "\u89FB",
    4,
    "\u8A01",
    5,
    "\u8A08",
    21,
    "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"
  ],
  [
    "d440",
    "\u8A1E",
    31,
    "\u8A3F",
    8,
    "\u8A49",
    21
  ],
  [
    "d480",
    "\u8A5F",
    25,
    "\u8A7A",
    6,
    "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"
  ],
  [
    "d540",
    "\u8A81",
    7,
    "\u8A8B",
    7,
    "\u8A94",
    46
  ],
  [
    "d580",
    "\u8AC3",
    32,
    "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"
  ],
  [
    "d640",
    "\u8AE4",
    34,
    "\u8B08",
    27
  ],
  [
    "d680",
    "\u8B24\u8B25\u8B27",
    30,
    "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"
  ],
  [
    "d740",
    "\u8B46",
    31,
    "\u8B67",
    4,
    "\u8B6D",
    25
  ],
  [
    "d780",
    "\u8B87",
    24,
    "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"
  ],
  [
    "d840",
    "\u8C38",
    8,
    "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D",
    7,
    "\u8C56\u8C57\u8C58\u8C59\u8C5B",
    5,
    "\u8C63",
    6,
    "\u8C6C",
    6,
    "\u8C74\u8C75\u8C76\u8C77\u8C7B",
    6,
    "\u8C83\u8C84\u8C86\u8C87"
  ],
  [
    "d880",
    "\u8C88\u8C8B\u8C8D",
    6,
    "\u8C95\u8C96\u8C97\u8C99",
    20,
    "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"
  ],
  [
    "d940",
    "\u8CAE",
    62
  ],
  [
    "d980",
    "\u8CED",
    32,
    "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"
  ],
  [
    "da40",
    "\u8D0E",
    14,
    "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78",
    8,
    "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C",
    4,
    "\u8D92\u8D93\u8D95",
    9,
    "\u8DA0\u8DA1"
  ],
  [
    "da80",
    "\u8DA2\u8DA4",
    12,
    "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"
  ],
  [
    "db40",
    "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE",
    6,
    "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15",
    7,
    "\u8E20\u8E21\u8E24",
    4,
    "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"
  ],
  [
    "db80",
    "\u8E3F\u8E43\u8E45\u8E46\u8E4C",
    4,
    "\u8E53",
    5,
    "\u8E5A",
    11,
    "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"
  ],
  [
    "dc40",
    "\u8E73\u8E75\u8E77",
    4,
    "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88",
    6,
    "\u8E91\u8E92\u8E93\u8E95",
    6,
    "\u8E9D\u8E9F",
    11,
    "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3",
    6,
    "\u8EBB",
    7
  ],
  [
    "dc80",
    "\u8EC3",
    10,
    "\u8ECF",
    21,
    "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"
  ],
  [
    "dd40",
    "\u8EE5",
    62
  ],
  [
    "dd80",
    "\u8F24",
    32,
    "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"
  ],
  [
    "de40",
    "\u8F45",
    32,
    "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"
  ],
  [
    "de80",
    "\u8FC9",
    4,
    "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"
  ],
  [
    "df40",
    "\u9019\u901C\u9023\u9024\u9025\u9027",
    5,
    "\u9030",
    4,
    "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048",
    4,
    "\u904E\u9054\u9055\u9056\u9059\u905A\u905C",
    5,
    "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F",
    4,
    "\u9076",
    6,
    "\u907E\u9081"
  ],
  [
    "df80",
    "\u9084\u9085\u9086\u9087\u9089\u908A\u908C",
    4,
    "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"
  ],
  [
    "e040",
    "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105",
    19,
    "\u911A\u911B\u911C"
  ],
  [
    "e080",
    "\u911D\u911F\u9120\u9121\u9124",
    10,
    "\u9130\u9132",
    6,
    "\u913A",
    8,
    "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"
  ],
  [
    "e140",
    "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180",
    4,
    "\u9186\u9188\u918A\u918E\u918F\u9193",
    6,
    "\u919C",
    5,
    "\u91A4",
    5,
    "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"
  ],
  [
    "e180",
    "\u91BC",
    10,
    "\u91C8\u91CB\u91D0\u91D2",
    9,
    "\u91DD",
    8,
    "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"
  ],
  [
    "e240",
    "\u91E6",
    62
  ],
  [
    "e280",
    "\u9225",
    32,
    "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967",
    5,
    "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"
  ],
  [
    "e340",
    "\u9246",
    45,
    "\u9275",
    16
  ],
  [
    "e380",
    "\u9286",
    7,
    "\u928F",
    24,
    "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"
  ],
  [
    "e440",
    "\u92A8",
    5,
    "\u92AF",
    24,
    "\u92C9",
    31
  ],
  [
    "e480",
    "\u92E9",
    32,
    "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"
  ],
  [
    "e540",
    "\u930A",
    51,
    "\u933F",
    10
  ],
  [
    "e580",
    "\u934A",
    31,
    "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"
  ],
  [
    "e640",
    "\u936C",
    34,
    "\u9390",
    27
  ],
  [
    "e680",
    "\u93AC",
    29,
    "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"
  ],
  [
    "e740",
    "\u93CE",
    7,
    "\u93D7",
    54
  ],
  [
    "e780",
    "\u940E",
    32,
    "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21",
    6,
    "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F",
    4,
    "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"
  ],
  [
    "e840",
    "\u942F",
    14,
    "\u943F",
    43,
    "\u946C\u946D\u946E\u946F"
  ],
  [
    "e880",
    "\u9470",
    20,
    "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"
  ],
  [
    "e940",
    "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577",
    7,
    "\u9580",
    42
  ],
  [
    "e980",
    "\u95AB",
    32,
    "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"
  ],
  [
    "ea40",
    "\u95CC",
    27,
    "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623",
    6,
    "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"
  ],
  [
    "ea80",
    "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D",
    4,
    "\u9673\u9678",
    12,
    "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"
  ],
  [
    "eb40",
    "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D",
    9,
    "\u96A8",
    7,
    "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6",
    9,
    "\u96E1",
    6,
    "\u96EB"
  ],
  [
    "eb80",
    "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717",
    4,
    "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"
  ],
  [
    "ec40",
    "\u9721",
    8,
    "\u972B\u972C\u972E\u972F\u9731\u9733",
    4,
    "\u973A\u973B\u973C\u973D\u973F",
    18,
    "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A",
    7
  ],
  [
    "ec80",
    "\u9772\u9775\u9777",
    4,
    "\u977D",
    7,
    "\u9786",
    4,
    "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799",
    4,
    "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"
  ],
  [
    "ed40",
    "\u979E\u979F\u97A1\u97A2\u97A4",
    6,
    "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5",
    46
  ],
  [
    "ed80",
    "\u97E4\u97E5\u97E8\u97EE",
    4,
    "\u97F4\u97F7",
    23,
    "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"
  ],
  [
    "ee40",
    "\u980F",
    62
  ],
  [
    "ee80",
    "\u984E",
    32,
    "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6",
    4,
    "\u94BC\u94BD\u94BF\u94C4\u94C8",
    6,
    "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"
  ],
  [
    "ef40",
    "\u986F",
    5,
    "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8",
    37,
    "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0",
    4
  ],
  [
    "ef80",
    "\u98E5\u98E6\u98E9",
    30,
    "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512",
    4,
    "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564",
    8,
    "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"
  ],
  [
    "f040",
    "\u9908",
    4,
    "\u990E\u990F\u9911",
    28,
    "\u992F",
    26
  ],
  [
    "f080",
    "\u994A",
    9,
    "\u9956",
    12,
    "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28",
    4,
    "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66",
    6,
    "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"
  ],
  [
    "f140",
    "\u998C\u998E\u999A",
    10,
    "\u99A6\u99A7\u99A9",
    47
  ],
  [
    "f180",
    "\u99D9",
    32,
    "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"
  ],
  [
    "f240",
    "\u99FA",
    62
  ],
  [
    "f280",
    "\u9A39",
    32,
    "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"
  ],
  [
    "f340",
    "\u9A5A",
    17,
    "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9",
    6,
    "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6",
    4,
    "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"
  ],
  [
    "f380",
    "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0",
    8,
    "\u9AFA\u9AFC",
    6,
    "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"
  ],
  [
    "f440",
    "\u9B07\u9B09",
    5,
    "\u9B10\u9B11\u9B12\u9B14",
    10,
    "\u9B20\u9B21\u9B22\u9B24",
    10,
    "\u9B30\u9B31\u9B33",
    7,
    "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55",
    5
  ],
  [
    "f480",
    "\u9B5B",
    32,
    "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"
  ],
  [
    "f540",
    "\u9B7C",
    62
  ],
  [
    "f580",
    "\u9BBB",
    32,
    "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"
  ],
  [
    "f640",
    "\u9BDC",
    62
  ],
  [
    "f680",
    "\u9C1B",
    32,
    "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85",
    5,
    "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E",
    5,
    "\u9CA5",
    4,
    "\u9CAB\u9CAD\u9CAE\u9CB0",
    7,
    "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"
  ],
  [
    "f740",
    "\u9C3C",
    62
  ],
  [
    "f780",
    "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE",
    4,
    "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC",
    4,
    "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"
  ],
  [
    "f840",
    "\u9CE3",
    62
  ],
  [
    "f880",
    "\u9D22",
    32
  ],
  [
    "f940",
    "\u9D43",
    62
  ],
  [
    "f980",
    "\u9D82",
    32
  ],
  [
    "fa40",
    "\u9DA3",
    62
  ],
  [
    "fa80",
    "\u9DE2",
    32
  ],
  [
    "fb40",
    "\u9E03",
    27,
    "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74",
    9,
    "\u9E80"
  ],
  [
    "fb80",
    "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C",
    5,
    "\u9E94",
    8,
    "\u9E9E\u9EA0",
    5,
    "\u9EA7\u9EA8\u9EA9\u9EAA"
  ],
  [
    "fc40",
    "\u9EAB",
    8,
    "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF",
    4,
    "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0",
    8,
    "\u9EFA\u9EFD\u9EFF",
    6
  ],
  [
    "fc80",
    "\u9F06",
    4,
    "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A",
    5,
    "\u9F21\u9F23",
    8,
    "\u9F2D\u9F2E\u9F30\u9F31"
  ],
  [
    "fd40",
    "\u9F32",
    4,
    "\u9F38\u9F3A\u9F3C\u9F3F",
    4,
    "\u9F45",
    10,
    "\u9F52",
    38
  ],
  [
    "fd80",
    "\u9F79",
    5,
    "\u9F81\u9F82\u9F8D",
    11,
    "\u9F9C\u9F9D\u9F9E\u9FA1",
    4,
    "\uF92C\uF979\uF995\uF9E7\uF9F1"
  ],
  [
    "fe40",
    "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"
  ]
], require$$3 = [
  [
    "a140",
    "\uE4C6",
    62
  ],
  [
    "a180",
    "\uE505",
    32
  ],
  [
    "a240",
    "\uE526",
    62
  ],
  [
    "a280",
    "\uE565",
    32
  ],
  [
    "a2ab",
    "\uE766",
    5
  ],
  [
    "a2e3",
    "\u20AC\uE76D"
  ],
  [
    "a2ef",
    "\uE76E\uE76F"
  ],
  [
    "a2fd",
    "\uE770\uE771"
  ],
  [
    "a340",
    "\uE586",
    62
  ],
  [
    "a380",
    "\uE5C5",
    31,
    "\u3000"
  ],
  [
    "a440",
    "\uE5E6",
    62
  ],
  [
    "a480",
    "\uE625",
    32
  ],
  [
    "a4f4",
    "\uE772",
    10
  ],
  [
    "a540",
    "\uE646",
    62
  ],
  [
    "a580",
    "\uE685",
    32
  ],
  [
    "a5f7",
    "\uE77D",
    7
  ],
  [
    "a640",
    "\uE6A6",
    62
  ],
  [
    "a680",
    "\uE6E5",
    32
  ],
  [
    "a6b9",
    "\uE785",
    7
  ],
  [
    "a6d9",
    "\uE78D",
    6
  ],
  [
    "a6ec",
    "\uE794\uE795"
  ],
  [
    "a6f3",
    "\uE796"
  ],
  [
    "a6f6",
    "\uE797",
    8
  ],
  [
    "a740",
    "\uE706",
    62
  ],
  [
    "a780",
    "\uE745",
    32
  ],
  [
    "a7c2",
    "\uE7A0",
    14
  ],
  [
    "a7f2",
    "\uE7AF",
    12
  ],
  [
    "a896",
    "\uE7BC",
    10
  ],
  [
    "a8bc",
    "\uE7C7"
  ],
  [
    "a8bf",
    "\u01F9"
  ],
  [
    "a8c1",
    "\uE7C9\uE7CA\uE7CB\uE7CC"
  ],
  [
    "a8ea",
    "\uE7CD",
    20
  ],
  [
    "a958",
    "\uE7E2"
  ],
  [
    "a95b",
    "\uE7E3"
  ],
  [
    "a95d",
    "\uE7E4\uE7E5\uE7E6"
  ],
  [
    "a989",
    "\u303E\u2FF0",
    11
  ],
  [
    "a997",
    "\uE7F4",
    12
  ],
  [
    "a9f0",
    "\uE801",
    14
  ],
  [
    "aaa1",
    "\uE000",
    93
  ],
  [
    "aba1",
    "\uE05E",
    93
  ],
  [
    "aca1",
    "\uE0BC",
    93
  ],
  [
    "ada1",
    "\uE11A",
    93
  ],
  [
    "aea1",
    "\uE178",
    93
  ],
  [
    "afa1",
    "\uE1D6",
    93
  ],
  [
    "d7fa",
    "\uE810",
    4
  ],
  [
    "f8a1",
    "\uE234",
    93
  ],
  [
    "f9a1",
    "\uE292",
    93
  ],
  [
    "faa1",
    "\uE2F0",
    93
  ],
  [
    "fba1",
    "\uE34E",
    93
  ],
  [
    "fca1",
    "\uE3AC",
    93
  ],
  [
    "fda1",
    "\uE40A",
    93
  ],
  [
    "fe50",
    "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"
  ],
  [
    "fe80",
    "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13",
    6,
    "\u4DAE\uE864\uE468",
    93
  ]
], uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
], gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
], require$$4 = {
  uChars,
  gbChars
}, require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "\uAC02\uAC03\uAC05\uAC06\uAC0B",
    4,
    "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25",
    6,
    "\uAC2E\uAC32\uAC33\uAC34"
  ],
  [
    "8161",
    "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41",
    9,
    "\uAC4C\uAC4E",
    5,
    "\uAC55"
  ],
  [
    "8181",
    "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D",
    18,
    "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B",
    4,
    "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95",
    6,
    "\uAC9E\uACA2",
    5,
    "\uACAB\uACAD\uACAE\uACB1",
    6,
    "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD",
    7,
    "\uACD6\uACD8",
    7,
    "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7",
    4,
    "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07",
    4,
    "\uAD0E\uAD10\uAD12\uAD13"
  ],
  [
    "8241",
    "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21",
    7,
    "\uAD2A\uAD2B\uAD2E",
    5
  ],
  [
    "8261",
    "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D",
    6,
    "\uAD46\uAD48\uAD4A",
    5,
    "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"
  ],
  [
    "8281",
    "\uAD59",
    7,
    "\uAD62\uAD64",
    7,
    "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83",
    4,
    "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91",
    10,
    "\uAD9E",
    5,
    "\uADA5",
    17,
    "\uADB8",
    7,
    "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9",
    6,
    "\uADD2\uADD4",
    7,
    "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5",
    18
  ],
  [
    "8341",
    "\uADFA\uADFB\uADFD\uADFE\uAE02",
    5,
    "\uAE0A\uAE0C\uAE0E",
    5,
    "\uAE15",
    7
  ],
  [
    "8361",
    "\uAE1D",
    18,
    "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"
  ],
  [
    "8381",
    "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57",
    4,
    "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71",
    6,
    "\uAE7A\uAE7E",
    5,
    "\uAE86",
    5,
    "\uAE8D",
    46,
    "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5",
    6,
    "\uAECE\uAED2",
    5,
    "\uAEDA\uAEDB\uAEDD",
    8
  ],
  [
    "8441",
    "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE",
    5,
    "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD",
    8
  ],
  [
    "8461",
    "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11",
    18
  ],
  [
    "8481",
    "\uAF24",
    7,
    "\uAF2E\uAF2F\uAF31\uAF33\uAF35",
    6,
    "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A",
    5,
    "\uAF51",
    10,
    "\uAF5E",
    5,
    "\uAF66",
    18,
    "\uAF7A",
    5,
    "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89",
    6,
    "\uAF92\uAF93\uAF94\uAF96",
    5,
    "\uAF9D",
    26,
    "\uAFBA\uAFBB\uAFBD\uAFBE"
  ],
  [
    "8541",
    "\uAFBF\uAFC1",
    5,
    "\uAFCA\uAFCC\uAFCF",
    4,
    "\uAFD5",
    6,
    "\uAFDD",
    4
  ],
  [
    "8561",
    "\uAFE2",
    5,
    "\uAFEA",
    5,
    "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9",
    6,
    "\uB002\uB003"
  ],
  [
    "8581",
    "\uB005",
    6,
    "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015",
    6,
    "\uB01E",
    9,
    "\uB029",
    26,
    "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E",
    29,
    "\uB07E\uB07F\uB081\uB082\uB083\uB085",
    6,
    "\uB08E\uB090\uB092",
    5,
    "\uB09B\uB09D\uB09E\uB0A3\uB0A4"
  ],
  [
    "8641",
    "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD",
    6,
    "\uB0C6\uB0CA",
    5,
    "\uB0D2"
  ],
  [
    "8661",
    "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9",
    6,
    "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6",
    10
  ],
  [
    "8681",
    "\uB0F1",
    22,
    "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E",
    4,
    "\uB126\uB127\uB129\uB12A\uB12B\uB12D",
    6,
    "\uB136\uB13A",
    5,
    "\uB142\uB143\uB145\uB146\uB147\uB149",
    6,
    "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161",
    22,
    "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183",
    4,
    "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"
  ],
  [
    "8741",
    "\uB19E",
    9,
    "\uB1A9",
    15
  ],
  [
    "8761",
    "\uB1B9",
    18,
    "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"
  ],
  [
    "8781",
    "\uB1D6",
    5,
    "\uB1DE\uB1E0",
    7,
    "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1",
    7,
    "\uB1FA\uB1FC\uB1FE",
    5,
    "\uB206\uB207\uB209\uB20A\uB20D",
    6,
    "\uB216\uB218\uB21A",
    5,
    "\uB221",
    18,
    "\uB235",
    6,
    "\uB23D",
    26,
    "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261",
    6,
    "\uB26A",
    4
  ],
  [
    "8841",
    "\uB26F",
    4,
    "\uB276",
    5,
    "\uB27D",
    6,
    "\uB286\uB287\uB288\uB28A",
    4
  ],
  [
    "8861",
    "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B",
    4,
    "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"
  ],
  [
    "8881",
    "\uB2B8",
    15,
    "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3",
    4,
    "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309",
    6,
    "\uB312\uB316",
    5,
    "\uB31D",
    54,
    "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"
  ],
  [
    "8941",
    "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379",
    6,
    "\uB382\uB386",
    5,
    "\uB38D"
  ],
  [
    "8961",
    "\uB38E\uB38F\uB391\uB392\uB393\uB395",
    10,
    "\uB3A2",
    5,
    "\uB3A9\uB3AA\uB3AB\uB3AD"
  ],
  [
    "8981",
    "\uB3AE",
    21,
    "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9",
    18,
    "\uB3FD",
    18,
    "\uB411",
    6,
    "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421",
    6,
    "\uB42A\uB42C",
    7,
    "\uB435",
    15
  ],
  [
    "8a41",
    "\uB445",
    10,
    "\uB452\uB453\uB455\uB456\uB457\uB459",
    6,
    "\uB462\uB464\uB466"
  ],
  [
    "8a61",
    "\uB467",
    4,
    "\uB46D",
    18,
    "\uB481\uB482"
  ],
  [
    "8a81",
    "\uB483",
    4,
    "\uB489",
    19,
    "\uB49E",
    5,
    "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD",
    7,
    "\uB4B6\uB4B8\uB4BA",
    5,
    "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9",
    6,
    "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6",
    5,
    "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7",
    4,
    "\uB4EE\uB4F0\uB4F2",
    5,
    "\uB4F9",
    26,
    "\uB516\uB517\uB519\uB51A\uB51D"
  ],
  [
    "8b41",
    "\uB51E",
    5,
    "\uB526\uB52B",
    4,
    "\uB532\uB533\uB535\uB536\uB537\uB539",
    6,
    "\uB542\uB546"
  ],
  [
    "8b61",
    "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555",
    6,
    "\uB55E\uB562",
    8
  ],
  [
    "8b81",
    "\uB56B",
    52,
    "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6",
    4,
    "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5",
    6,
    "\uB5CE\uB5D2",
    5,
    "\uB5D9",
    18,
    "\uB5ED",
    18
  ],
  [
    "8c41",
    "\uB600",
    15,
    "\uB612\uB613\uB615\uB616\uB617\uB619",
    4
  ],
  [
    "8c61",
    "\uB61E",
    6,
    "\uB626",
    5,
    "\uB62D",
    6,
    "\uB635",
    5
  ],
  [
    "8c81",
    "\uB63B",
    12,
    "\uB649",
    26,
    "\uB665\uB666\uB667\uB669",
    50,
    "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5",
    5,
    "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2",
    16
  ],
  [
    "8d41",
    "\uB6C3",
    16,
    "\uB6D5",
    8
  ],
  [
    "8d61",
    "\uB6DE",
    17,
    "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"
  ],
  [
    "8d81",
    "\uB6FB",
    4,
    "\uB702\uB703\uB704\uB706",
    33,
    "\uB72A\uB72B\uB72D\uB72E\uB731",
    6,
    "\uB73A\uB73C",
    7,
    "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D",
    6,
    "\uB756",
    9,
    "\uB761\uB762\uB763\uB765\uB766\uB767\uB769",
    6,
    "\uB772\uB774\uB776",
    5,
    "\uB77E\uB77F\uB781\uB782\uB783\uB785",
    6,
    "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"
  ],
  [
    "8e41",
    "\uB79F\uB7A1",
    6,
    "\uB7AA\uB7AE",
    5,
    "\uB7B6\uB7B7\uB7B9",
    8
  ],
  [
    "8e61",
    "\uB7C2",
    4,
    "\uB7C8\uB7CA",
    19
  ],
  [
    "8e81",
    "\uB7DE",
    13,
    "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5",
    6,
    "\uB7FE\uB802",
    4,
    "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811",
    6,
    "\uB81A\uB81C\uB81E",
    5,
    "\uB826\uB827\uB829\uB82A\uB82B\uB82D",
    6,
    "\uB836\uB83A",
    5,
    "\uB841\uB842\uB843\uB845",
    11,
    "\uB852\uB854",
    7,
    "\uB85E\uB85F\uB861\uB862\uB863\uB865",
    6,
    "\uB86E\uB870\uB872",
    5,
    "\uB879\uB87A\uB87B\uB87D",
    7
  ],
  [
    "8f41",
    "\uB885",
    7,
    "\uB88E",
    17
  ],
  [
    "8f61",
    "\uB8A0",
    7,
    "\uB8A9",
    6,
    "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9",
    4
  ],
  [
    "8f81",
    "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6",
    5,
    "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5",
    7,
    "\uB8DE\uB8E0\uB8E2",
    5,
    "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1",
    6,
    "\uB8FA\uB8FC\uB8FE",
    5,
    "\uB905",
    18,
    "\uB919",
    6,
    "\uB921",
    26,
    "\uB93E\uB93F\uB941\uB942\uB943\uB945",
    6,
    "\uB94D\uB94E\uB950\uB952",
    5
  ],
  [
    "9041",
    "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961",
    6,
    "\uB96A\uB96C\uB96E",
    5,
    "\uB976\uB977\uB979\uB97A\uB97B\uB97D"
  ],
  [
    "9061",
    "\uB97E",
    5,
    "\uB986\uB988\uB98B\uB98C\uB98F",
    15
  ],
  [
    "9081",
    "\uB99F",
    12,
    "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5",
    6,
    "\uB9BE\uB9C0\uB9C2",
    5,
    "\uB9CA\uB9CB\uB9CD\uB9D3",
    4,
    "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED",
    6,
    "\uB9F6\uB9FB",
    4,
    "\uBA02",
    5,
    "\uBA09",
    11,
    "\uBA16",
    33,
    "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"
  ],
  [
    "9141",
    "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D",
    6,
    "\uBA66\uBA6A",
    5
  ],
  [
    "9161",
    "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79",
    9,
    "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D",
    5
  ],
  [
    "9181",
    "\uBA93",
    20,
    "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3",
    4,
    "\uBABA\uBABC\uBABE",
    5,
    "\uBAC5\uBAC6\uBAC7\uBAC9",
    14,
    "\uBADA",
    33,
    "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05",
    7,
    "\uBB0E\uBB10\uBB12",
    5,
    "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21",
    6
  ],
  [
    "9241",
    "\uBB28\uBB2A\uBB2C",
    7,
    "\uBB37\uBB39\uBB3A\uBB3F",
    4,
    "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"
  ],
  [
    "9261",
    "\uBB53\uBB55\uBB56\uBB57\uBB59",
    7,
    "\uBB62\uBB64",
    7,
    "\uBB6D",
    4
  ],
  [
    "9281",
    "\uBB72",
    21,
    "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91",
    18,
    "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD",
    6,
    "\uBBB5\uBBB6\uBBB8",
    7,
    "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9",
    6,
    "\uBBD1\uBBD2\uBBD4",
    35,
    "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"
  ],
  [
    "9341",
    "\uBC03",
    4,
    "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"
  ],
  [
    "9361",
    "\uBC36\uBC37\uBC39",
    6,
    "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51",
    8
  ],
  [
    "9381",
    "\uBC5A\uBC5B\uBC5C\uBC5E",
    37,
    "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F",
    4,
    "\uBC96\uBC98\uBC9B",
    4,
    "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9",
    6,
    "\uBCB2\uBCB6",
    5,
    "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5",
    7,
    "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD",
    22,
    "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"
  ],
  [
    "9441",
    "\uBCFE",
    5,
    "\uBD06\uBD08\uBD0A",
    5,
    "\uBD11\uBD12\uBD13\uBD15",
    8
  ],
  [
    "9461",
    "\uBD1E",
    5,
    "\uBD25",
    6,
    "\uBD2D",
    12
  ],
  [
    "9481",
    "\uBD3A",
    5,
    "\uBD41",
    6,
    "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51",
    6,
    "\uBD5A",
    9,
    "\uBD65\uBD66\uBD67\uBD69",
    22,
    "\uBD82\uBD83\uBD85\uBD86\uBD8B",
    4,
    "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D",
    6,
    "\uBDA5",
    10,
    "\uBDB1",
    6,
    "\uBDB9",
    24
  ],
  [
    "9541",
    "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD",
    11,
    "\uBDEA",
    5,
    "\uBDF1"
  ],
  [
    "9561",
    "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9",
    6,
    "\uBE01\uBE02\uBE04\uBE06",
    5,
    "\uBE0E\uBE0F\uBE11\uBE12\uBE13"
  ],
  [
    "9581",
    "\uBE15",
    6,
    "\uBE1E\uBE20",
    35,
    "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F",
    4,
    "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B",
    4,
    "\uBE72\uBE76",
    4,
    "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85",
    6,
    "\uBE8E\uBE92",
    5,
    "\uBE9A",
    13,
    "\uBEA9",
    14
  ],
  [
    "9641",
    "\uBEB8",
    23,
    "\uBED2\uBED3"
  ],
  [
    "9661",
    "\uBED5\uBED6\uBED9",
    6,
    "\uBEE1\uBEE2\uBEE6",
    5,
    "\uBEED",
    8
  ],
  [
    "9681",
    "\uBEF6",
    10,
    "\uBF02",
    5,
    "\uBF0A",
    13,
    "\uBF1A\uBF1E",
    33,
    "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49",
    6,
    "\uBF52\uBF53\uBF54\uBF56",
    44
  ],
  [
    "9741",
    "\uBF83",
    16,
    "\uBF95",
    8
  ],
  [
    "9761",
    "\uBF9E",
    17,
    "\uBFB1",
    7
  ],
  [
    "9781",
    "\uBFB9",
    11,
    "\uBFC6",
    5,
    "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5",
    6,
    "\uBFDD\uBFDE\uBFE0\uBFE2",
    89,
    "\uC03D\uC03E\uC03F"
  ],
  [
    "9841",
    "\uC040",
    16,
    "\uC052",
    5,
    "\uC059\uC05A\uC05B"
  ],
  [
    "9861",
    "\uC05D\uC05E\uC05F\uC061",
    6,
    "\uC06A",
    15
  ],
  [
    "9881",
    "\uC07A",
    21,
    "\uC092\uC093\uC095\uC096\uC097\uC099",
    6,
    "\uC0A2\uC0A4\uC0A6",
    5,
    "\uC0AE\uC0B1\uC0B2\uC0B7",
    4,
    "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1",
    6,
    "\uC0DA\uC0DE",
    5,
    "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED",
    6,
    "\uC0F6\uC0F8\uC0FA",
    5,
    "\uC101\uC102\uC103\uC105\uC106\uC107\uC109",
    6,
    "\uC111\uC112\uC113\uC114\uC116",
    5,
    "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"
  ],
  [
    "9941",
    "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141",
    6,
    "\uC14A\uC14E",
    5,
    "\uC156\uC157"
  ],
  [
    "9961",
    "\uC159\uC15A\uC15B\uC15D",
    6,
    "\uC166\uC16A",
    5,
    "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"
  ],
  [
    "9981",
    "\uC17C",
    8,
    "\uC186",
    5,
    "\uC18F\uC191\uC192\uC193\uC195\uC197",
    4,
    "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1",
    11,
    "\uC1BE",
    5,
    "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD",
    6,
    "\uC1D5\uC1D6\uC1D9",
    6,
    "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9",
    6,
    "\uC1F2\uC1F4",
    7,
    "\uC1FE\uC1FF\uC201\uC202\uC203\uC205",
    6,
    "\uC20E\uC210\uC212",
    5,
    "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"
  ],
  [
    "9a41",
    "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235",
    16
  ],
  [
    "9a61",
    "\uC246\uC247\uC249",
    6,
    "\uC252\uC253\uC255\uC256\uC257\uC259",
    6,
    "\uC261\uC262\uC263\uC264\uC266"
  ],
  [
    "9a81",
    "\uC267",
    4,
    "\uC26E\uC26F\uC271\uC272\uC273\uC275",
    6,
    "\uC27E\uC280\uC282",
    5,
    "\uC28A",
    5,
    "\uC291",
    6,
    "\uC299\uC29A\uC29C\uC29E",
    5,
    "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE",
    5,
    "\uC2B6\uC2B8\uC2BA",
    33,
    "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5",
    5,
    "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301",
    6,
    "\uC30A\uC30B\uC30E\uC30F"
  ],
  [
    "9b41",
    "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D",
    6,
    "\uC326\uC327\uC32A",
    8
  ],
  [
    "9b61",
    "\uC333",
    17,
    "\uC346",
    7
  ],
  [
    "9b81",
    "\uC34E",
    25,
    "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373",
    4,
    "\uC37A\uC37B\uC37E",
    5,
    "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D",
    50,
    "\uC3C1",
    22,
    "\uC3DA"
  ],
  [
    "9c41",
    "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3",
    4,
    "\uC3EA\uC3EB\uC3EC\uC3EE",
    5,
    "\uC3F6\uC3F7\uC3F9",
    5
  ],
  [
    "9c61",
    "\uC3FF",
    8,
    "\uC409",
    6,
    "\uC411",
    9
  ],
  [
    "9c81",
    "\uC41B",
    8,
    "\uC425",
    6,
    "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435",
    6,
    "\uC43E",
    9,
    "\uC449",
    26,
    "\uC466\uC467\uC469\uC46A\uC46B\uC46D",
    6,
    "\uC476\uC477\uC478\uC47A",
    5,
    "\uC481",
    18,
    "\uC495",
    6,
    "\uC49D",
    12
  ],
  [
    "9d41",
    "\uC4AA",
    13,
    "\uC4B9\uC4BA\uC4BB\uC4BD",
    8
  ],
  [
    "9d61",
    "\uC4C6",
    25
  ],
  [
    "9d81",
    "\uC4E0",
    8,
    "\uC4EA",
    5,
    "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502",
    9,
    "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515",
    6,
    "\uC51D",
    10,
    "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531",
    6,
    "\uC53A\uC53C\uC53E",
    5,
    "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569",
    6,
    "\uC572\uC576",
    5,
    "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"
  ],
  [
    "9e41",
    "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1",
    7,
    "\uC5AA",
    9,
    "\uC5B6"
  ],
  [
    "9e61",
    "\uC5B7\uC5BA\uC5BF",
    4,
    "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9",
    6,
    "\uC5E2\uC5E4\uC5E6\uC5E7"
  ],
  [
    "9e81",
    "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611",
    6,
    "\uC61A\uC61D",
    6,
    "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649",
    6,
    "\uC652\uC656",
    5,
    "\uC65E\uC65F\uC661",
    10,
    "\uC66D\uC66E\uC670\uC672",
    5,
    "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681",
    6,
    "\uC68A\uC68C\uC68E",
    5,
    "\uC696\uC697\uC699\uC69A\uC69B\uC69D",
    6,
    "\uC6A6"
  ],
  [
    "9f41",
    "\uC6A8\uC6AA",
    5,
    "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB",
    4,
    "\uC6C2\uC6C4\uC6C6",
    5,
    "\uC6CE"
  ],
  [
    "9f61",
    "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5",
    6,
    "\uC6DE\uC6DF\uC6E2",
    5,
    "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"
  ],
  [
    "9f81",
    "\uC6F3",
    4,
    "\uC6FA\uC6FB\uC6FC\uC6FE",
    5,
    "\uC706\uC707\uC709\uC70A\uC70B\uC70D",
    6,
    "\uC716\uC718\uC71A",
    5,
    "\uC722\uC723\uC725\uC726\uC727\uC729",
    6,
    "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745",
    4,
    "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761",
    6,
    "\uC769\uC76A\uC76C",
    7,
    "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B",
    4,
    "\uC7A2\uC7A7",
    4,
    "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"
  ],
  [
    "a041",
    "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2",
    5,
    "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1",
    6,
    "\uC7D9\uC7DA\uC7DB\uC7DC"
  ],
  [
    "a061",
    "\uC7DE",
    5,
    "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED",
    13
  ],
  [
    "a081",
    "\uC7FB",
    4,
    "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B",
    4,
    "\uC812\uC814\uC817",
    4,
    "\uC81E\uC81F\uC821\uC822\uC823\uC825",
    6,
    "\uC82E\uC830\uC832",
    5,
    "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841",
    6,
    "\uC84A\uC84B\uC84E",
    5,
    "\uC855",
    26,
    "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B",
    4,
    "\uC882\uC884\uC888\uC889\uC88A\uC88E",
    5,
    "\uC895",
    7,
    "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"
  ],
  [
    "a141",
    "\uC8A5\uC8A6\uC8A7\uC8A9",
    18,
    "\uC8BE\uC8BF\uC8C0\uC8C1"
  ],
  [
    "a161",
    "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD",
    6,
    "\uC8D6\uC8D8\uC8DA",
    5,
    "\uC8E2\uC8E3\uC8E5"
  ],
  [
    "a181",
    "\uC8E6",
    14,
    "\uC8F6",
    5,
    "\uC8FE\uC8FF\uC901\uC902\uC903\uC907",
    4,
    "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008",
    9,
    "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"
  ],
  [
    "a241",
    "\uC910\uC912",
    5,
    "\uC919",
    18
  ],
  [
    "a261",
    "\uC92D",
    6,
    "\uC935",
    18
  ],
  [
    "a281",
    "\uC948",
    7,
    "\uC952\uC953\uC955\uC956\uC957\uC959",
    6,
    "\uC962\uC964",
    7,
    "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"
  ],
  [
    "a341",
    "\uC971\uC972\uC973\uC975",
    6,
    "\uC97D",
    10,
    "\uC98A\uC98B\uC98D\uC98E\uC98F"
  ],
  [
    "a361",
    "\uC991",
    6,
    "\uC99A\uC99C\uC99E",
    16
  ],
  [
    "a381",
    "\uC9AF",
    16,
    "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB",
    4,
    "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01",
    58,
    "\uFFE6\uFF3D",
    32,
    "\uFFE3"
  ],
  [
    "a441",
    "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2",
    5,
    "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"
  ],
  [
    "a461",
    "\uCA05\uCA06\uCA07\uCA0A\uCA0E",
    5,
    "\uCA15\uCA16\uCA17\uCA19",
    12
  ],
  [
    "a481",
    "\uCA26\uCA27\uCA28\uCA2A",
    28,
    "\u3131",
    93
  ],
  [
    "a541",
    "\uCA47",
    4,
    "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55",
    6,
    "\uCA5E\uCA62",
    5,
    "\uCA69\uCA6A"
  ],
  [
    "a561",
    "\uCA6B",
    17,
    "\uCA7E",
    5,
    "\uCA85\uCA86"
  ],
  [
    "a581",
    "\uCA87",
    16,
    "\uCA99",
    14,
    "\u2170",
    9
  ],
  [
    "a5b0",
    "\u2160",
    9
  ],
  [
    "a5c1",
    "\u0391",
    16,
    "\u03A3",
    6
  ],
  [
    "a5e1",
    "\u03B1",
    16,
    "\u03C3",
    6
  ],
  [
    "a641",
    "\uCAA8",
    19,
    "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"
  ],
  [
    "a661",
    "\uCAC6",
    5,
    "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA",
    5,
    "\uCAE1",
    6
  ],
  [
    "a681",
    "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED",
    6,
    "\uCAF5",
    18,
    "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543",
    7
  ],
  [
    "a741",
    "\uCB0B",
    4,
    "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19",
    6,
    "\uCB22",
    7
  ],
  [
    "a761",
    "\uCB2A",
    22,
    "\uCB42\uCB43\uCB44"
  ],
  [
    "a781",
    "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51",
    6,
    "\uCB5A\uCB5B\uCB5C\uCB5E",
    5,
    "\uCB65",
    7,
    "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399",
    9,
    "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0",
    9,
    "\u3380",
    4,
    "\u33BA",
    5,
    "\u3390",
    4,
    "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"
  ],
  [
    "a841",
    "\uCB6D",
    10,
    "\uCB7A",
    14
  ],
  [
    "a861",
    "\uCB89",
    18,
    "\uCB9D",
    6
  ],
  [
    "a881",
    "\uCBA4",
    19,
    "\uCBB9",
    11,
    "\xC6\xD0\xAA\u0126"
  ],
  [
    "a8a6",
    "\u0132"
  ],
  [
    "a8a8",
    "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"
  ],
  [
    "a8b1",
    "\u3260",
    27,
    "\u24D0",
    25,
    "\u2460",
    14,
    "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"
  ],
  [
    "a941",
    "\uCBC5",
    14,
    "\uCBD5",
    10
  ],
  [
    "a961",
    "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA",
    18
  ],
  [
    "a981",
    "\uCBFD",
    14,
    "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15",
    6,
    "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200",
    27,
    "\u249C",
    25,
    "\u2474",
    14,
    "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"
  ],
  [
    "aa41",
    "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31",
    6,
    "\uCC3A\uCC3F",
    4,
    "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"
  ],
  [
    "aa61",
    "\uCC4F",
    4,
    "\uCC56\uCC5A",
    5,
    "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69",
    6,
    "\uCC71\uCC72"
  ],
  [
    "aa81",
    "\uCC73\uCC74\uCC76",
    29,
    "\u3041",
    82
  ],
  [
    "ab41",
    "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1",
    6,
    "\uCCAA\uCCAE",
    5,
    "\uCCB6\uCCB7\uCCB9"
  ],
  [
    "ab61",
    "\uCCBA\uCCBB\uCCBD",
    6,
    "\uCCC6\uCCC8\uCCCA",
    5,
    "\uCCD1\uCCD2\uCCD3\uCCD5",
    5
  ],
  [
    "ab81",
    "\uCCDB",
    8,
    "\uCCE5",
    6,
    "\uCCED\uCCEE\uCCEF\uCCF1",
    12,
    "\u30A1",
    85
  ],
  [
    "ac41",
    "\uCCFE\uCCFF\uCD00\uCD02",
    5,
    "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11",
    6,
    "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"
  ],
  [
    "ac61",
    "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D",
    11,
    "\uCD3A",
    4
  ],
  [
    "ac81",
    "\uCD3F",
    28,
    "\uCD5D\uCD5E\uCD5F\u0410",
    5,
    "\u0401\u0416",
    25
  ],
  [
    "acd1",
    "\u0430",
    5,
    "\u0451\u0436",
    25
  ],
  [
    "ad41",
    "\uCD61\uCD62\uCD63\uCD65",
    6,
    "\uCD6E\uCD70\uCD72",
    5,
    "\uCD79",
    7
  ],
  [
    "ad61",
    "\uCD81",
    6,
    "\uCD89",
    10,
    "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"
  ],
  [
    "ad81",
    "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA",
    5,
    "\uCDB1",
    18,
    "\uCDC5"
  ],
  [
    "ae41",
    "\uCDC6",
    5,
    "\uCDCD\uCDCE\uCDCF\uCDD1",
    16
  ],
  [
    "ae61",
    "\uCDE2",
    5,
    "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1",
    6,
    "\uCDFA\uCDFC\uCDFE",
    4
  ],
  [
    "ae81",
    "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D",
    6,
    "\uCE15\uCE16\uCE17\uCE18\uCE1A",
    5,
    "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"
  ],
  [
    "af41",
    "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36",
    19
  ],
  [
    "af61",
    "\uCE4A",
    13,
    "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62",
    5,
    "\uCE6A\uCE6C"
  ],
  [
    "af81",
    "\uCE6E",
    5,
    "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D",
    6,
    "\uCE86\uCE88\uCE8A",
    5,
    "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"
  ],
  [
    "b041",
    "\uCE9A",
    5,
    "\uCEA2\uCEA6",
    5,
    "\uCEAE",
    12
  ],
  [
    "b061",
    "\uCEBB",
    5,
    "\uCEC2",
    19
  ],
  [
    "b081",
    "\uCED6",
    13,
    "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED",
    6,
    "\uCEF6\uCEFA",
    5,
    "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10",
    7,
    "\uAC19",
    4,
    "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"
  ],
  [
    "b141",
    "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09",
    6,
    "\uCF12\uCF14\uCF16",
    5,
    "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"
  ],
  [
    "b161",
    "\uCF25",
    6,
    "\uCF2E\uCF32",
    5,
    "\uCF39",
    11
  ],
  [
    "b181",
    "\uCF45",
    14,
    "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D",
    6,
    "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"
  ],
  [
    "b241",
    "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79",
    6,
    "\uCF81\uCF82\uCF83\uCF84\uCF86",
    5,
    "\uCF8D"
  ],
  [
    "b261",
    "\uCF8E",
    18,
    "\uCFA2",
    5,
    "\uCFA9"
  ],
  [
    "b281",
    "\uCFAA",
    5,
    "\uCFB1",
    18,
    "\uCFC5",
    6,
    "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"
  ],
  [
    "b341",
    "\uCFCC",
    19,
    "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"
  ],
  [
    "b361",
    "\uCFEA",
    5,
    "\uCFF2\uCFF4\uCFF6",
    5,
    "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005",
    5
  ],
  [
    "b381",
    "\uD00B",
    5,
    "\uD012",
    5,
    "\uD019",
    19,
    "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB",
    4,
    "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"
  ],
  [
    "b441",
    "\uD02E",
    5,
    "\uD036\uD037\uD039\uD03A\uD03B\uD03D",
    6,
    "\uD046\uD048\uD04A",
    5
  ],
  [
    "b461",
    "\uD051\uD052\uD053\uD055\uD056\uD057\uD059",
    6,
    "\uD061",
    10,
    "\uD06E\uD06F"
  ],
  [
    "b481",
    "\uD071\uD072\uD073\uD075",
    6,
    "\uD07E\uD07F\uD080\uD082",
    18,
    "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB",
    4,
    "\uB2F3\uB2F4\uB2F5\uB2F7",
    4,
    "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"
  ],
  [
    "b541",
    "\uD095",
    14,
    "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD",
    5
  ],
  [
    "b561",
    "\uD0B3\uD0B6\uD0B8\uD0BA",
    5,
    "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA",
    5,
    "\uD0D2\uD0D6",
    4
  ],
  [
    "b581",
    "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5",
    6,
    "\uD0EE\uD0F2",
    5,
    "\uD0F9",
    11,
    "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"
  ],
  [
    "b641",
    "\uD105",
    7,
    "\uD10E",
    17
  ],
  [
    "b661",
    "\uD120",
    15,
    "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"
  ],
  [
    "b681",
    "\uD13F\uD142\uD146",
    5,
    "\uD14E\uD14F\uD151\uD152\uD153\uD155",
    6,
    "\uD15E\uD160\uD162",
    5,
    "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"
  ],
  [
    "b741",
    "\uD16E",
    13,
    "\uD17D",
    6,
    "\uD185\uD186\uD187\uD189\uD18A"
  ],
  [
    "b761",
    "\uD18B",
    20,
    "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"
  ],
  [
    "b781",
    "\uD1A9",
    6,
    "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1",
    14,
    "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"
  ],
  [
    "b841",
    "\uD1D0",
    7,
    "\uD1D9",
    17
  ],
  [
    "b861",
    "\uD1EB",
    8,
    "\uD1F5\uD1F6\uD1F7\uD1F9",
    13
  ],
  [
    "b881",
    "\uD208\uD20A",
    5,
    "\uD211",
    24,
    "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE",
    4,
    "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"
  ],
  [
    "b941",
    "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235",
    6,
    "\uD23E\uD240\uD242",
    5,
    "\uD249\uD24A\uD24B\uD24C"
  ],
  [
    "b961",
    "\uD24D",
    14,
    "\uD25D",
    6,
    "\uD265\uD266\uD267\uD268"
  ],
  [
    "b981",
    "\uD269",
    22,
    "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14",
    4,
    "\uBC1B",
    4,
    "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"
  ],
  [
    "ba41",
    "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296",
    5,
    "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5",
    6,
    "\uD2AD"
  ],
  [
    "ba61",
    "\uD2AE\uD2AF\uD2B0\uD2B2",
    5,
    "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3",
    4,
    "\uD2CA\uD2CC",
    5
  ],
  [
    "ba81",
    "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD",
    6,
    "\uD2E6",
    9,
    "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"
  ],
  [
    "bb41",
    "\uD2FB",
    4,
    "\uD302\uD304\uD306",
    5,
    "\uD30F\uD311\uD312\uD313\uD315\uD317",
    4,
    "\uD31E\uD322\uD323"
  ],
  [
    "bb61",
    "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331",
    6,
    "\uD33A\uD33E",
    5,
    "\uD346\uD347\uD348\uD349"
  ],
  [
    "bb81",
    "\uD34A",
    31,
    "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"
  ],
  [
    "bc41",
    "\uD36A",
    17,
    "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"
  ],
  [
    "bc61",
    "\uD388\uD389\uD38A\uD38B\uD38E\uD392",
    5,
    "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1",
    6,
    "\uD3AA\uD3AC\uD3AE"
  ],
  [
    "bc81",
    "\uD3AF",
    4,
    "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD",
    6,
    "\uD3C6\uD3C7\uD3CA",
    5,
    "\uD3D1",
    5,
    "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C",
    4,
    "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"
  ],
  [
    "bd41",
    "\uD3D7\uD3D9",
    7,
    "\uD3E2\uD3E4",
    7,
    "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"
  ],
  [
    "bd61",
    "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402",
    5,
    "\uD409",
    13
  ],
  [
    "bd81",
    "\uD417",
    5,
    "\uD41E",
    25,
    "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"
  ],
  [
    "be41",
    "\uD438",
    7,
    "\uD441\uD442\uD443\uD445",
    14
  ],
  [
    "be61",
    "\uD454",
    7,
    "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465",
    7,
    "\uD46E\uD470\uD471\uD472"
  ],
  [
    "be81",
    "\uD473",
    4,
    "\uD47A\uD47B\uD47D\uD47E\uD481\uD483",
    4,
    "\uD48A\uD48C\uD48E",
    5,
    "\uD495",
    8,
    "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4",
    6,
    "\uC5CC\uC5CE"
  ],
  [
    "bf41",
    "\uD49E",
    10,
    "\uD4AA",
    14
  ],
  [
    "bf61",
    "\uD4B9",
    18,
    "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"
  ],
  [
    "bf81",
    "\uD4D6",
    5,
    "\uD4DD\uD4DE\uD4E0",
    7,
    "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1",
    6,
    "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC",
    5,
    "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"
  ],
  [
    "c041",
    "\uD4FE",
    5,
    "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D",
    6,
    "\uD516\uD518",
    5
  ],
  [
    "c061",
    "\uD51E",
    25
  ],
  [
    "c081",
    "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545",
    6,
    "\uD54E\uD550\uD552",
    5,
    "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751",
    7,
    "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"
  ],
  [
    "c141",
    "\uD564\uD566\uD567\uD56A\uD56C\uD56E",
    5,
    "\uD576\uD577\uD579\uD57A\uD57B\uD57D",
    6,
    "\uD586\uD58A\uD58B"
  ],
  [
    "c161",
    "\uD58C\uD58D\uD58E\uD58F\uD591",
    19,
    "\uD5A6\uD5A7"
  ],
  [
    "c181",
    "\uD5A8",
    31,
    "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"
  ],
  [
    "c241",
    "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3",
    4,
    "\uD5DA\uD5DC\uD5DE",
    5,
    "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"
  ],
  [
    "c261",
    "\uD5EF",
    4,
    "\uD5F6\uD5F8\uD5FA",
    5,
    "\uD602\uD603\uD605\uD606\uD607\uD609",
    6,
    "\uD612"
  ],
  [
    "c281",
    "\uD616",
    5,
    "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625",
    7,
    "\uD62E",
    9,
    "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"
  ],
  [
    "c341",
    "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D",
    4
  ],
  [
    "c361",
    "\uD662",
    4,
    "\uD668\uD66A",
    5,
    "\uD672\uD673\uD675",
    11
  ],
  [
    "c381",
    "\uD681\uD682\uD684\uD686",
    5,
    "\uD68E\uD68F\uD691\uD692\uD693\uD695",
    7,
    "\uD69E\uD6A0\uD6A2",
    5,
    "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"
  ],
  [
    "c441",
    "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1",
    7,
    "\uD6BA\uD6BC",
    7,
    "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"
  ],
  [
    "c461",
    "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA",
    5,
    "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9",
    4
  ],
  [
    "c481",
    "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6",
    5,
    "\uD6FE\uD6FF\uD701\uD702\uD703\uD705",
    11,
    "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"
  ],
  [
    "c541",
    "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721",
    6,
    "\uD72A\uD72C\uD72E",
    5,
    "\uD736\uD737\uD739"
  ],
  [
    "c561",
    "\uD73A\uD73B\uD73D",
    6,
    "\uD745\uD746\uD748\uD74A",
    5,
    "\uD752\uD753\uD755\uD75A",
    4
  ],
  [
    "c581",
    "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775",
    6,
    "\uD77E\uD77F\uD780\uD782",
    5,
    "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"
  ],
  [
    "c641",
    "\uD78D\uD78E\uD78F\uD791",
    6,
    "\uD79A\uD79C\uD79E",
    5
  ],
  [
    "c6a1",
    "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"
  ],
  [
    "c7a1",
    "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"
  ],
  [
    "c8a1",
    "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"
  ],
  [
    "caa1",
    "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"
  ],
  [
    "cba1",
    "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"
  ],
  [
    "cca1",
    "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"
  ],
  [
    "cda1",
    "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"
  ],
  [
    "cea1",
    "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"
  ],
  [
    "cfa1",
    "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"
  ],
  [
    "d0a1",
    "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"
  ],
  [
    "d1a1",
    "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E",
    5,
    "\u90A3\uF914",
    4,
    "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"
  ],
  [
    "d2a1",
    "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928",
    4,
    "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933",
    5,
    "\u99D1\uF939",
    10,
    "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A",
    7,
    "\u5AE9\u8A25\u677B\u7D10\uF952",
    5,
    "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"
  ],
  [
    "d3a1",
    "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"
  ],
  [
    "d4a1",
    "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"
  ],
  [
    "d5a1",
    "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"
  ],
  [
    "d6a1",
    "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"
  ],
  [
    "d7a1",
    "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"
  ],
  [
    "d8a1",
    "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"
  ],
  [
    "d9a1",
    "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"
  ],
  [
    "daa1",
    "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"
  ],
  [
    "dba1",
    "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"
  ],
  [
    "dca1",
    "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"
  ],
  [
    "dda1",
    "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"
  ],
  [
    "dea1",
    "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"
  ],
  [
    "dfa1",
    "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"
  ],
  [
    "e0a1",
    "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"
  ],
  [
    "e1a1",
    "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"
  ],
  [
    "e2a1",
    "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"
  ],
  [
    "e3a1",
    "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"
  ],
  [
    "e4a1",
    "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"
  ],
  [
    "e5a1",
    "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"
  ],
  [
    "e6a1",
    "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"
  ],
  [
    "e7a1",
    "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"
  ],
  [
    "e8a1",
    "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"
  ],
  [
    "e9a1",
    "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"
  ],
  [
    "eaa1",
    "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"
  ],
  [
    "eba1",
    "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"
  ],
  [
    "eca1",
    "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"
  ],
  [
    "eda1",
    "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"
  ],
  [
    "eea1",
    "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"
  ],
  [
    "efa1",
    "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"
  ],
  [
    "f0a1",
    "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"
  ],
  [
    "f1a1",
    "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"
  ],
  [
    "f2a1",
    "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"
  ],
  [
    "f3a1",
    "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"
  ],
  [
    "f4a1",
    "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"
  ],
  [
    "f5a1",
    "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"
  ],
  [
    "f6a1",
    "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"
  ],
  [
    "f7a1",
    "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"
  ],
  [
    "f8a1",
    "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"
  ],
  [
    "f9a1",
    "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"
  ],
  [
    "faa1",
    "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"
  ],
  [
    "fba1",
    "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"
  ],
  [
    "fca1",
    "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"
  ],
  [
    "fda1",
    "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"
  ]
], require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"
  ],
  [
    "a1a1",
    "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62",
    4,
    "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"
  ],
  [
    "a240",
    "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581",
    7,
    "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"
  ],
  [
    "a2a1",
    "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10",
    9,
    "\u2160",
    9,
    "\u3021",
    8,
    "\u5341\u5344\u5345\uFF21",
    25,
    "\uFF41",
    21
  ],
  [
    "a340",
    "\uFF57\uFF58\uFF59\uFF5A\u0391",
    16,
    "\u03A3",
    6,
    "\u03B1",
    16,
    "\u03C3",
    6,
    "\u3105",
    10
  ],
  [
    "a3a1",
    "\u3110",
    25,
    "\u02D9\u02C9\u02CA\u02C7\u02CB"
  ],
  [
    "a3e1",
    "\u20AC"
  ],
  [
    "a440",
    "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"
  ],
  [
    "a4a1",
    "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"
  ],
  [
    "a540",
    "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"
  ],
  [
    "a5a1",
    "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"
  ],
  [
    "a640",
    "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"
  ],
  [
    "a6a1",
    "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"
  ],
  [
    "a740",
    "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"
  ],
  [
    "a7a1",
    "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"
  ],
  [
    "a840",
    "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"
  ],
  [
    "a8a1",
    "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"
  ],
  [
    "a940",
    "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"
  ],
  [
    "a9a1",
    "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"
  ],
  [
    "aa40",
    "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"
  ],
  [
    "aaa1",
    "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"
  ],
  [
    "ab40",
    "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"
  ],
  [
    "aba1",
    "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"
  ],
  [
    "ac40",
    "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"
  ],
  [
    "aca1",
    "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"
  ],
  [
    "ad40",
    "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"
  ],
  [
    "ada1",
    "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"
  ],
  [
    "ae40",
    "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"
  ],
  [
    "aea1",
    "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"
  ],
  [
    "af40",
    "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"
  ],
  [
    "afa1",
    "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"
  ],
  [
    "b040",
    "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"
  ],
  [
    "b0a1",
    "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"
  ],
  [
    "b140",
    "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"
  ],
  [
    "b1a1",
    "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"
  ],
  [
    "b240",
    "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"
  ],
  [
    "b2a1",
    "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"
  ],
  [
    "b340",
    "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"
  ],
  [
    "b3a1",
    "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"
  ],
  [
    "b440",
    "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"
  ],
  [
    "b4a1",
    "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"
  ],
  [
    "b540",
    "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"
  ],
  [
    "b5a1",
    "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"
  ],
  [
    "b640",
    "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"
  ],
  [
    "b6a1",
    "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"
  ],
  [
    "b740",
    "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"
  ],
  [
    "b7a1",
    "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"
  ],
  [
    "b840",
    "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"
  ],
  [
    "b8a1",
    "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"
  ],
  [
    "b940",
    "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"
  ],
  [
    "b9a1",
    "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"
  ],
  [
    "ba40",
    "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"
  ],
  [
    "baa1",
    "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"
  ],
  [
    "bb40",
    "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"
  ],
  [
    "bba1",
    "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"
  ],
  [
    "bc40",
    "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"
  ],
  [
    "bca1",
    "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"
  ],
  [
    "bd40",
    "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"
  ],
  [
    "bda1",
    "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"
  ],
  [
    "be40",
    "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"
  ],
  [
    "bea1",
    "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"
  ],
  [
    "bf40",
    "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"
  ],
  [
    "bfa1",
    "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"
  ],
  [
    "c040",
    "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"
  ],
  [
    "c0a1",
    "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"
  ],
  [
    "c140",
    "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"
  ],
  [
    "c1a1",
    "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"
  ],
  [
    "c240",
    "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"
  ],
  [
    "c2a1",
    "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"
  ],
  [
    "c340",
    "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"
  ],
  [
    "c3a1",
    "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"
  ],
  [
    "c440",
    "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"
  ],
  [
    "c4a1",
    "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"
  ],
  [
    "c540",
    "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"
  ],
  [
    "c5a1",
    "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"
  ],
  [
    "c640",
    "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"
  ],
  [
    "c940",
    "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"
  ],
  [
    "c9a1",
    "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"
  ],
  [
    "ca40",
    "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"
  ],
  [
    "caa1",
    "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"
  ],
  [
    "cb40",
    "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"
  ],
  [
    "cba1",
    "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"
  ],
  [
    "cc40",
    "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"
  ],
  [
    "cca1",
    "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"
  ],
  [
    "cd40",
    "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"
  ],
  [
    "cda1",
    "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"
  ],
  [
    "ce40",
    "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"
  ],
  [
    "cea1",
    "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"
  ],
  [
    "cf40",
    "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"
  ],
  [
    "cfa1",
    "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"
  ],
  [
    "d040",
    "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"
  ],
  [
    "d0a1",
    "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"
  ],
  [
    "d140",
    "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"
  ],
  [
    "d1a1",
    "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"
  ],
  [
    "d240",
    "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"
  ],
  [
    "d2a1",
    "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"
  ],
  [
    "d340",
    "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"
  ],
  [
    "d3a1",
    "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"
  ],
  [
    "d440",
    "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"
  ],
  [
    "d4a1",
    "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"
  ],
  [
    "d540",
    "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"
  ],
  [
    "d5a1",
    "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"
  ],
  [
    "d640",
    "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"
  ],
  [
    "d6a1",
    "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"
  ],
  [
    "d740",
    "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"
  ],
  [
    "d7a1",
    "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"
  ],
  [
    "d840",
    "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"
  ],
  [
    "d8a1",
    "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"
  ],
  [
    "d940",
    "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"
  ],
  [
    "d9a1",
    "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"
  ],
  [
    "da40",
    "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"
  ],
  [
    "daa1",
    "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"
  ],
  [
    "db40",
    "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"
  ],
  [
    "dba1",
    "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"
  ],
  [
    "dc40",
    "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"
  ],
  [
    "dca1",
    "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"
  ],
  [
    "dd40",
    "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"
  ],
  [
    "dda1",
    "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"
  ],
  [
    "de40",
    "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"
  ],
  [
    "dea1",
    "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"
  ],
  [
    "df40",
    "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"
  ],
  [
    "dfa1",
    "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"
  ],
  [
    "e040",
    "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"
  ],
  [
    "e0a1",
    "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"
  ],
  [
    "e140",
    "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"
  ],
  [
    "e1a1",
    "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"
  ],
  [
    "e240",
    "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"
  ],
  [
    "e2a1",
    "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"
  ],
  [
    "e340",
    "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"
  ],
  [
    "e3a1",
    "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"
  ],
  [
    "e440",
    "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"
  ],
  [
    "e4a1",
    "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"
  ],
  [
    "e540",
    "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"
  ],
  [
    "e5a1",
    "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"
  ],
  [
    "e640",
    "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"
  ],
  [
    "e6a1",
    "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"
  ],
  [
    "e740",
    "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"
  ],
  [
    "e7a1",
    "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"
  ],
  [
    "e840",
    "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"
  ],
  [
    "e8a1",
    "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"
  ],
  [
    "e940",
    "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"
  ],
  [
    "e9a1",
    "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"
  ],
  [
    "ea40",
    "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"
  ],
  [
    "eaa1",
    "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"
  ],
  [
    "eb40",
    "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"
  ],
  [
    "eba1",
    "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"
  ],
  [
    "ec40",
    "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"
  ],
  [
    "eca1",
    "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"
  ],
  [
    "ed40",
    "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"
  ],
  [
    "eda1",
    "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"
  ],
  [
    "ee40",
    "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"
  ],
  [
    "eea1",
    "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"
  ],
  [
    "ef40",
    "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"
  ],
  [
    "efa1",
    "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"
  ],
  [
    "f040",
    "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"
  ],
  [
    "f0a1",
    "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"
  ],
  [
    "f140",
    "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"
  ],
  [
    "f1a1",
    "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"
  ],
  [
    "f240",
    "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"
  ],
  [
    "f2a1",
    "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"
  ],
  [
    "f340",
    "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"
  ],
  [
    "f3a1",
    "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"
  ],
  [
    "f440",
    "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"
  ],
  [
    "f4a1",
    "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"
  ],
  [
    "f540",
    "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"
  ],
  [
    "f5a1",
    "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"
  ],
  [
    "f640",
    "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"
  ],
  [
    "f6a1",
    "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"
  ],
  [
    "f740",
    "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"
  ],
  [
    "f7a1",
    "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"
  ],
  [
    "f840",
    "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"
  ],
  [
    "f8a1",
    "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"
  ],
  [
    "f940",
    "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"
  ],
  [
    "f9a1",
    "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"
  ]
], require$$7 = [
  [
    "8740",
    "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"
  ],
  [
    "8767",
    "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"
  ],
  [
    "87a1",
    "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"
  ],
  [
    "8840",
    "\u31C0",
    4,
    "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"
  ],
  [
    "88a1",
    "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"
  ],
  [
    "8940",
    "\u{2A3A9}\u{21145}"
  ],
  [
    "8943",
    "\u650A"
  ],
  [
    "8946",
    "\u4E3D\u6EDD\u9D4E\u91DF"
  ],
  [
    "894c",
    "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"
  ],
  [
    "89a1",
    "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"
  ],
  [
    "89ab",
    "\u918C\u78B8\u915E\u80BC"
  ],
  [
    "89b0",
    "\u8D0B\u80F6\u{209E7}"
  ],
  [
    "89b5",
    "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"
  ],
  [
    "89c1",
    "\u6E9A\u823E\u7519"
  ],
  [
    "89c5",
    "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"
  ],
  [
    "8a40",
    "\u{27D84}\u5525"
  ],
  [
    "8a43",
    "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"
  ],
  [
    "8a64",
    "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"
  ],
  [
    "8a76",
    "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"
  ],
  [
    "8aa1",
    "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"
  ],
  [
    "8aac",
    "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"
  ],
  [
    "8ab2",
    "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"
  ],
  [
    "8abb",
    "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"
  ],
  [
    "8ac9",
    "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"
  ],
  [
    "8ace",
    "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"
  ],
  [
    "8adf",
    "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"
  ],
  [
    "8af6",
    "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"
  ],
  [
    "8b40",
    "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"
  ],
  [
    "8b55",
    "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"
  ],
  [
    "8ba1",
    "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"
  ],
  [
    "8bde",
    "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"
  ],
  [
    "8c40",
    "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"
  ],
  [
    "8ca1",
    "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"
  ],
  [
    "8ca7",
    "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"
  ],
  [
    "8cc9",
    "\u9868\u676B\u4276\u573D"
  ],
  [
    "8cce",
    "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"
  ],
  [
    "8ce6",
    "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"
  ],
  [
    "8d40",
    "\u{20B9F}"
  ],
  [
    "8d42",
    "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"
  ],
  [
    "8da1",
    "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"
  ],
  [
    "8e40",
    "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"
  ],
  [
    "8ea1",
    "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"
  ],
  [
    "8f40",
    "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"
  ],
  [
    "8fa1",
    "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"
  ],
  [
    "9040",
    "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"
  ],
  [
    "90a1",
    "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"
  ],
  [
    "9140",
    "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"
  ],
  [
    "91a1",
    "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"
  ],
  [
    "9240",
    "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"
  ],
  [
    "92a1",
    "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"
  ],
  [
    "9340",
    "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"
  ],
  [
    "93a1",
    "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"
  ],
  [
    "9440",
    "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"
  ],
  [
    "94a1",
    "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"
  ],
  [
    "9540",
    "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"
  ],
  [
    "95a1",
    "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"
  ],
  [
    "9640",
    "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"
  ],
  [
    "96a1",
    "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"
  ],
  [
    "9740",
    "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"
  ],
  [
    "97a1",
    "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"
  ],
  [
    "9840",
    "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"
  ],
  [
    "98a1",
    "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"
  ],
  [
    "9940",
    "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"
  ],
  [
    "99a1",
    "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"
  ],
  [
    "9a40",
    "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"
  ],
  [
    "9aa1",
    "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"
  ],
  [
    "9b40",
    "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"
  ],
  [
    "9b62",
    "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"
  ],
  [
    "9ba1",
    "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"
  ],
  [
    "9c40",
    "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"
  ],
  [
    "9ca1",
    "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"
  ],
  [
    "9d40",
    "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"
  ],
  [
    "9da1",
    "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"
  ],
  [
    "9e40",
    "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"
  ],
  [
    "9ea1",
    "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"
  ],
  [
    "9ead",
    "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"
  ],
  [
    "9ec5",
    "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"
  ],
  [
    "9ef5",
    "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"
  ],
  [
    "9f40",
    "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"
  ],
  [
    "9f4f",
    "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"
  ],
  [
    "9fa1",
    "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"
  ],
  [
    "9fae",
    "\u9159\u9681\u915C"
  ],
  [
    "9fb2",
    "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"
  ],
  [
    "9fc1",
    "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"
  ],
  [
    "9fc9",
    "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"
  ],
  [
    "9fdb",
    "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"
  ],
  [
    "9fe7",
    "\u6BFA\u8818\u7F78"
  ],
  [
    "9feb",
    "\u5620\u{2A64A}\u8E77\u9F53"
  ],
  [
    "9ff0",
    "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"
  ],
  [
    "a040",
    "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"
  ],
  [
    "a055",
    "\u{2183B}\u{26E05}"
  ],
  [
    "a058",
    "\u8A7E\u{2251B}"
  ],
  [
    "a05b",
    "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"
  ],
  [
    "a063",
    "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"
  ],
  [
    "a073",
    "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"
  ],
  [
    "a0a1",
    "\u5D57\u{28BC2}\u8FDA\u{28E39}"
  ],
  [
    "a0a6",
    "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"
  ],
  [
    "a0ae",
    "\u77FE"
  ],
  [
    "a0b0",
    "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"
  ],
  [
    "a0d4",
    "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"
  ],
  [
    "a0e2",
    "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"
  ],
  [
    "a3c0",
    "\u2400",
    31,
    "\u2421"
  ],
  [
    "c6a1",
    "\u2460",
    9,
    "\u2474",
    9,
    "\u2170",
    9,
    "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041",
    23
  ],
  [
    "c740",
    "\u3059",
    58,
    "\u30A1\u30A2\u30A3\u30A4"
  ],
  [
    "c7a1",
    "\u30A5",
    81,
    "\u0410",
    5,
    "\u0401\u0416",
    4
  ],
  [
    "c840",
    "\u041B",
    26,
    "\u0451\u0436",
    25,
    "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"
  ],
  [
    "c8a1",
    "\u9FB0\u5188\u9FB1\u{27607}"
  ],
  [
    "c8cd",
    "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"
  ],
  [
    "c8f5",
    "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"
  ],
  [
    "f9fe",
    "\uFFED"
  ],
  [
    "fa40",
    "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"
  ],
  [
    "faa1",
    "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"
  ],
  [
    "fb40",
    "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"
  ],
  [
    "fba1",
    "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"
  ],
  [
    "fc40",
    "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"
  ],
  [
    "fca1",
    "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"
  ],
  [
    "fd40",
    "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"
  ],
  [
    "fda1",
    "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"
  ],
  [
    "fe40",
    "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"
  ],
  [
    "fea1",
    "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"
  ]
], dbcsData, hasRequiredDbcsData;
function requireDbcsData() {
  return hasRequiredDbcsData || (hasRequiredDbcsData = 1, dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require$$0;
      },
      encodeAdd: { "\xA5": 92, "\u203E": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "\xA5": 92, "\u203E": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    gbk: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "\u20AC": 41699 }
    },
    chinese: "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  }), dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  return hasRequiredEncodings || (hasRequiredEncodings = 1, function(exports2) {
    for (var modules = [
      requireInternal(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ], i2 = 0; i2 < modules.length; i2++) {
      var module2 = modules[i2];
      for (var enc in module2)
        Object.prototype.hasOwnProperty.call(module2, enc) && (exports2[enc] = module2[enc]);
    }
  }(encodings)), encodings;
}
var streams, hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = require$$0__default$9.default.Buffer, Transform = require$$0__default$4.default.Transform;
  streams = function(iconv) {
    iconv.encodeStream = function(encoding, options2) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options2), options2);
    }, iconv.decodeStream = function(encoding, options2) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options2), options2);
    }, iconv.supportsStreams = !0, iconv.IconvLiteEncoderStream = IconvLiteEncoderStream, iconv.IconvLiteDecoderStream = IconvLiteDecoderStream, iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options2) {
    this.conv = conv, options2 = options2 || {}, options2.decodeStrings = !1, Transform.call(this, options2);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  }), IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      res && res.length && this.push(res), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      res && res.length && this.push(res), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    return this.on("error", cb), this.on("data", function(chunk) {
      chunks.push(chunk);
    }), this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    }), this;
  };
  function IconvLiteDecoderStream(conv, options2) {
    this.conv = conv, options2 = options2 || {}, options2.encoding = this.encoding = "utf8", Transform.call(this, options2);
  }
  return IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  }), IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      res && res.length && this.push(res, this.encoding), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      res && res.length && this.push(res, this.encoding), done();
    } catch (e) {
      done(e);
    }
  }, IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    return this.on("error", cb), this.on("data", function(chunk) {
      res += chunk;
    }), this.on("end", function() {
      cb(null, res);
    }), this;
  }, streams;
}
var extendNode, hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode) return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer2 = require$$0__default$9.default.Buffer;
  return extendNode = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array), iconv.extendNodeEncodings = function() {
      if (!original) {
        if (original = {}, !iconv.supportsNodeEncodingsExtension) {
          console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"), console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
          return;
        }
        var nodeNativeEncodings = {
          hex: !0,
          utf8: !0,
          "utf-8": !0,
          ascii: !0,
          binary: !0,
          base64: !0,
          ucs2: !0,
          "ucs-2": !0,
          utf16le: !0,
          "utf-16le": !0
        };
        Buffer2.isNativeEncoding = function(enc) {
          return enc && nodeNativeEncodings[enc.toLowerCase()];
        };
        var SlowBuffer = require$$0__default$9.default.SlowBuffer;
        if (original.SlowBufferToString = SlowBuffer.prototype.toString, SlowBuffer.prototype.toString = function(encoding, start, end2) {
          return encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding) ? original.SlowBufferToString.call(this, encoding, start, end2) : (typeof start > "u" && (start = 0), typeof end2 > "u" && (end2 = this.length), iconv.decode(this.slice(start, end2), encoding));
        }, original.SlowBufferWrite = SlowBuffer.prototype.write, SlowBuffer.prototype.write = function(string, offset, length, encoding) {
          if (isFinite(offset))
            isFinite(length) || (encoding = length, length = void 0);
          else {
            var swap = encoding;
            encoding = offset, offset = length, length = swap;
          }
          offset = +offset || 0;
          var remaining = this.length - offset;
          if (length ? (length = +length, length > remaining && (length = remaining)) : length = remaining, encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding))
            return original.SlowBufferWrite.call(this, string, offset, length, encoding);
          if (string.length > 0 && (length < 0 || offset < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var buf = iconv.encode(string, encoding);
          return buf.length < length && (length = buf.length), buf.copy(this, offset, 0, length), length;
        }, original.BufferIsEncoding = Buffer2.isEncoding, Buffer2.isEncoding = function(encoding) {
          return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        }, original.BufferByteLength = Buffer2.byteLength, Buffer2.byteLength = SlowBuffer.byteLength = function(str2, encoding) {
          return encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding) ? original.BufferByteLength.call(this, str2, encoding) : iconv.encode(str2, encoding).length;
        }, original.BufferToString = Buffer2.prototype.toString, Buffer2.prototype.toString = function(encoding, start, end2) {
          return encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding) ? original.BufferToString.call(this, encoding, start, end2) : (typeof start > "u" && (start = 0), typeof end2 > "u" && (end2 = this.length), iconv.decode(this.slice(start, end2), encoding));
        }, original.BufferWrite = Buffer2.prototype.write, Buffer2.prototype.write = function(string, offset, length, encoding) {
          var _offset2 = offset, _length = length, _encoding = encoding;
          if (isFinite(offset))
            isFinite(length) || (encoding = length, length = void 0);
          else {
            var swap = encoding;
            encoding = offset, offset = length, length = swap;
          }
          if (encoding = String(encoding || "utf8").toLowerCase(), Buffer2.isNativeEncoding(encoding))
            return original.BufferWrite.call(this, string, _offset2, _length, _encoding);
          offset = +offset || 0;
          var remaining = this.length - offset;
          if (length ? (length = +length, length > remaining && (length = remaining)) : length = remaining, string.length > 0 && (length < 0 || offset < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var buf = iconv.encode(string, encoding);
          return buf.length < length && (length = buf.length), buf.copy(this, offset, 0, length), length;
        }, iconv.supportsStreams) {
          var Readable = require$$0__default$4.default.Readable;
          original.ReadableSetEncoding = Readable.prototype.setEncoding, Readable.prototype.setEncoding = function(enc, options2) {
            this._readableState.decoder = iconv.getDecoder(enc, options2), this._readableState.encoding = enc;
          }, Readable.prototype.collect = iconv._collect;
        }
      }
    }, iconv.undoExtendNodeEncodings = function() {
      if (iconv.supportsNodeEncodingsExtension) {
        if (!original)
          throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
        delete Buffer2.isNativeEncoding;
        var SlowBuffer = require$$0__default$9.default.SlowBuffer;
        if (SlowBuffer.prototype.toString = original.SlowBufferToString, SlowBuffer.prototype.write = original.SlowBufferWrite, Buffer2.isEncoding = original.BufferIsEncoding, Buffer2.byteLength = original.BufferByteLength, Buffer2.prototype.toString = original.BufferToString, Buffer2.prototype.write = original.BufferWrite, iconv.supportsStreams) {
          var Readable = require$$0__default$4.default.Readable;
          Readable.prototype.setEncoding = original.ReadableSetEncoding, delete Readable.prototype.collect;
        }
        original = void 0;
      }
    };
  }, extendNode;
}
var hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, function(module2) {
    var Buffer2 = requireSafer().Buffer, bomHandling2 = requireBomHandling(), iconv = module2.exports;
    iconv.encodings = null, iconv.defaultCharUnicode = "\uFFFD", iconv.defaultCharSingleByte = "?", iconv.encode = function(str2, encoding, options2) {
      str2 = "" + (str2 || "");
      var encoder = iconv.getEncoder(encoding, options2), res = encoder.write(str2), trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    }, iconv.decode = function(buf, encoding, options2) {
      typeof buf == "string" && (iconv.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), iconv.skipDecodeWarning = !0), buf = Buffer2.from("" + (buf || ""), "binary"));
      var decoder = iconv.getDecoder(encoding, options2), res = decoder.write(buf), trail = decoder.end();
      return trail ? res + trail : res;
    }, iconv.encodingExists = function(enc) {
      try {
        return iconv.getCodec(enc), !0;
      } catch {
        return !1;
      }
    }, iconv.toEncoding = iconv.encode, iconv.fromEncoding = iconv.decode, iconv._codecDataCache = {}, iconv.getCodec = function(encoding) {
      iconv.encodings || (iconv.encodings = requireEncodings());
      for (var enc = iconv._canonicalizeEncoding(encoding), codecOptions = {}; ; ) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key2 in codecDef)
              codecOptions[key2] = codecDef[key2];
            codecOptions.encodingName || (codecOptions.encodingName = enc), enc = codecDef.type;
            break;
          case "function":
            return codecOptions.encodingName || (codecOptions.encodingName = enc), codec = new codecDef(codecOptions, iconv), iconv._codecDataCache[codecOptions.encodingName] = codec, codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    }, iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    }, iconv.getEncoder = function(encoding, options2) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options2, codec);
      return codec.bomAware && options2 && options2.addBOM && (encoder = new bomHandling2.PrependBOM(encoder, options2)), encoder;
    }, iconv.getDecoder = function(encoding, options2) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options2, codec);
      return codec.bomAware && !(options2 && options2.stripBOM === !1) && (decoder = new bomHandling2.StripBOM(decoder, options2)), decoder;
    };
    var nodeVer = typeof process < "u" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) && requireStreams()(iconv), requireExtendNode()(iconv);
    }
  }(lib)), lib.exports;
}
var tmp = {}, osTmpdir, hasRequiredOsTmpdir;
function requireOsTmpdir() {
  if (hasRequiredOsTmpdir) return osTmpdir;
  hasRequiredOsTmpdir = 1;
  var isWindows2 = process.platform === "win32", trailingSlashRe = isWindows2 ? /[^:]\\$/ : /.\/$/;
  return osTmpdir = function() {
    var path2;
    return isWindows2 ? path2 = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp" : path2 = process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp", trailingSlashRe.test(path2) && (path2 = path2.slice(0, -1)), path2;
  }, osTmpdir;
}
/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */
var hasRequiredTmp;
function requireTmp() {
  if (hasRequiredTmp) return tmp;
  hasRequiredTmp = 1;
  const fs2 = require$$0__default$1.default, path2 = require$$0__default.default, crypto2 = require$$3__default$1.default, osTmpDir = requireOsTmpdir(), _c = process.binding("constants"), tmpDir = osTmpDir(), RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448, FILE_MODE = 384, _removeObjects = [];
  var _gracefulCleanup = !1, _uncaughtException = !1;
  function _randomChars(howMany) {
    var value = [], rnd = null;
    try {
      rnd = crypto2.randomBytes(howMany);
    } catch {
      rnd = crypto2.pseudoRandomBytes(howMany);
    }
    for (var i2 = 0; i2 < howMany; i2++)
      value.push(RANDOM_CHARS[rnd[i2] % RANDOM_CHARS.length]);
    return value.join("");
  }
  function _isUndefined(obj) {
    return typeof obj > "u";
  }
  function _parseArguments(options2, callback) {
    return typeof options2 == "function" ? [callback || {}, options2] : _isUndefined(options2) ? [{}, callback] : [options2, callback];
  }
  function _generateTmpName(opts) {
    if (opts.name)
      return path2.join(opts.dir || tmpDir, opts.name);
    if (opts.template)
      return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));
    const name = [
      opts.prefix || "tmp-",
      process.pid,
      _randomChars(12),
      opts.postfix || ""
    ].join("");
    return path2.join(opts.dir || tmpDir, name);
  }
  function tmpName(options2, callback) {
    var args = _parseArguments(options2, callback), opts = args[0], cb = args[1], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
    if (isNaN(tries) || tries < 0)
      return cb(new Error("Invalid tries"));
    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      return cb(new Error("Invalid template provided"));
    (function _getUniqueName() {
      const name = _generateTmpName(opts);
      fs2.stat(name, function(err) {
        if (!err)
          return tries-- > 0 ? _getUniqueName() : cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
        cb(null, name);
      });
    })();
  }
  function tmpNameSync(options2) {
    var args = _parseArguments(options2), opts = args[0], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
    if (isNaN(tries) || tries < 0)
      throw new Error("Invalid tries");
    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      throw new Error("Invalid template provided");
    do {
      const name = _generateTmpName(opts);
      try {
        fs2.statSync(name);
      } catch {
        return name;
      }
    } while (tries-- > 0);
    throw new Error("Could not get a unique tmp filename, max tries reached");
  }
  function file2(options2, callback) {
    var args = _parseArguments(options2, callback), opts = args[0], cb = args[1];
    opts.postfix = _isUndefined(opts.postfix) ? ".tmp" : opts.postfix, tmpName(opts, function(err, name) {
      if (err) return cb(err);
      fs2.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function(err2, fd) {
        if (err2) return cb(err2);
        if (opts.discardDescriptor)
          return fs2.close(fd, function(err3) {
            if (err3) {
              try {
                fs2.unlinkSync(name);
              } catch (e) {
                isENOENT(e) || (err3 = e);
              }
              return cb(err3);
            }
            cb(null, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts));
          });
        if (opts.detachDescriptor)
          return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
      });
    });
  }
  function fileSync(options2) {
    var args = _parseArguments(options2), opts = args[0];
    opts.postfix = opts.postfix || ".tmp";
    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor, name = tmpNameSync(opts);
    var fd = fs2.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    return opts.discardDescriptor && (fs2.closeSync(fd), fd = void 0), {
      name,
      fd,
      removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
    };
  }
  function _rmdirRecursiveSync(root2) {
    const dirs = [root2];
    do {
      for (var dir2 = dirs.pop(), deferred = !1, files = fs2.readdirSync(dir2), i2 = 0, length = files.length; i2 < length; i2++) {
        var file3 = path2.join(dir2, files[i2]), stat = fs2.lstatSync(file3);
        stat.isDirectory() ? (deferred || (deferred = !0, dirs.push(dir2)), dirs.push(file3)) : fs2.unlinkSync(file3);
      }
      deferred || fs2.rmdirSync(dir2);
    } while (dirs.length !== 0);
  }
  function dir(options2, callback) {
    var args = _parseArguments(options2, callback), opts = args[0], cb = args[1];
    tmpName(opts, function(err, name) {
      if (err) return cb(err);
      fs2.mkdir(name, opts.mode || DIR_MODE, function(err2) {
        if (err2) return cb(err2);
        cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
      });
    });
  }
  function dirSync(options2) {
    var args = _parseArguments(options2), opts = args[0];
    const name = tmpNameSync(opts);
    return fs2.mkdirSync(name, opts.mode || DIR_MODE), {
      name,
      removeCallback: _prepareTmpDirRemoveCallback(name, opts)
    };
  }
  function _prepareTmpFileRemoveCallback(name, fd, opts) {
    const removeCallback = _prepareRemoveCallback(function(fdPath) {
      try {
        0 <= fdPath[0] && fs2.closeSync(fdPath[0]);
      } catch (e) {
        if (!isEBADF(e) && !isENOENT(e))
          throw e;
      }
      try {
        fs2.unlinkSync(fdPath[1]);
      } catch (e) {
        if (!isENOENT(e))
          throw e;
      }
    }, [fd, name]);
    return opts.keep || _removeObjects.unshift(removeCallback), removeCallback;
  }
  function _prepareTmpDirRemoveCallback(name, opts) {
    const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs2.rmdirSync.bind(fs2), removeCallback = _prepareRemoveCallback(removeFunction, name);
    return opts.keep || _removeObjects.unshift(removeCallback), removeCallback;
  }
  function _prepareRemoveCallback(removeFunction, arg) {
    var called = !1;
    return function _cleanupCallback(next) {
      if (!called) {
        const index = _removeObjects.indexOf(_cleanupCallback);
        index >= 0 && _removeObjects.splice(index, 1), called = !0, removeFunction(arg);
      }
      next && next(null);
    };
  }
  function _garbageCollector() {
    if (!(_uncaughtException && !_gracefulCleanup))
      for (; _removeObjects.length; )
        try {
          _removeObjects[0].call(null);
        } catch {
        }
  }
  function isEBADF(error2) {
    return isExpectedError(error2, -EBADF, "EBADF");
  }
  function isENOENT(error2) {
    return isExpectedError(error2, -ENOENT, "ENOENT");
  }
  function isExpectedError(error2, code, errno) {
    return error2.code == code || error2.code == errno;
  }
  function setGracefulCleanup() {
    _gracefulCleanup = !0;
  }
  const version = process.versions.node.split(".").map(function(value) {
    return parseInt(value, 10);
  });
  return version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5) && process.addListener("uncaughtException", function(err) {
    throw _uncaughtException = !0, _garbageCollector(), err;
  }), process.addListener("exit", function(code) {
    code && (_uncaughtException = !0), _garbageCollector();
  }), tmp.tmpdir = tmpDir, tmp.dir = dir, tmp.dirSync = dirSync, tmp.file = file2, tmp.fileSync = fileSync, tmp.tmpName = tmpName, tmp.tmpNameSync = tmpNameSync, tmp.setGracefulCleanup = setGracefulCleanup, tmp;
}
var CreateFileError = {}, hasRequiredCreateFileError;
function requireCreateFileError() {
  if (hasRequiredCreateFileError) return CreateFileError;
  hasRequiredCreateFileError = 1;
  var __extends2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(CreateFileError, "__esModule", { value: !0 });
  var CreateFileError$1 = (
    /** @class */
    function(_super) {
      __extends2(CreateFileError2, _super);
      function CreateFileError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed to create temporary file for editor") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return CreateFileError2;
    }(Error)
  );
  return CreateFileError.CreateFileError = CreateFileError$1, CreateFileError;
}
var LaunchEditorError = {}, hasRequiredLaunchEditorError;
function requireLaunchEditorError() {
  if (hasRequiredLaunchEditorError) return LaunchEditorError;
  hasRequiredLaunchEditorError = 1;
  var __extends2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(LaunchEditorError, "__esModule", { value: !0 });
  var LaunchEditorError$1 = (
    /** @class */
    function(_super) {
      __extends2(LaunchEditorError2, _super);
      function LaunchEditorError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed launch editor") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return LaunchEditorError2;
    }(Error)
  );
  return LaunchEditorError.LaunchEditorError = LaunchEditorError$1, LaunchEditorError;
}
var ReadFileError = {}, hasRequiredReadFileError;
function requireReadFileError() {
  if (hasRequiredReadFileError) return ReadFileError;
  hasRequiredReadFileError = 1;
  var __extends2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(ReadFileError, "__esModule", { value: !0 });
  var ReadFileError$1 = (
    /** @class */
    function(_super) {
      __extends2(ReadFileError2, _super);
      function ReadFileError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed to read temporary file") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return ReadFileError2;
    }(Error)
  );
  return ReadFileError.ReadFileError = ReadFileError$1, ReadFileError;
}
var RemoveFileError = {}, hasRequiredRemoveFileError;
function requireRemoveFileError() {
  if (hasRequiredRemoveFileError) return RemoveFileError;
  hasRequiredRemoveFileError = 1;
  var __extends2 = loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      return extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) b2.hasOwnProperty(p) && (d2[p] = b2[p]);
      }, extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(RemoveFileError, "__esModule", { value: !0 });
  var RemoveFileError$1 = (
    /** @class */
    function(_super) {
      __extends2(RemoveFileError2, _super);
      function RemoveFileError2(originalError) {
        var _newTarget = this.constructor, _this = _super.call(this, "Failed to cleanup temporary file") || this;
        _this.originalError = originalError;
        var proto = _newTarget.prototype;
        return Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : _this.__proto__ = _newTarget.prototype, _this;
      }
      return RemoveFileError2;
    }(Error)
  );
  return RemoveFileError.RemoveFileError = RemoveFileError$1, RemoveFileError;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1, Object.defineProperty(main, "__esModule", { value: !0 });
  var chardet_1 = requireChardet(), child_process_12 = require$$0__default$7.default, fs_12 = require$$0__default$1.default, iconv_lite_1 = requireLib(), tmp_1 = requireTmp(), CreateFileError_1 = requireCreateFileError();
  main.CreateFileError = CreateFileError_1.CreateFileError;
  var LaunchEditorError_1 = requireLaunchEditorError();
  main.LaunchEditorError = LaunchEditorError_1.LaunchEditorError;
  var ReadFileError_1 = requireReadFileError();
  main.ReadFileError = ReadFileError_1.ReadFileError;
  var RemoveFileError_1 = requireRemoveFileError();
  main.RemoveFileError = RemoveFileError_1.RemoveFileError;
  function edit(text, fileOptions) {
    text === void 0 && (text = "");
    var editor2 = new ExternalEditor(text, fileOptions);
    return editor2.run(), editor2.cleanup(), editor2.text;
  }
  main.edit = edit;
  function editAsync(text, callback, fileOptions) {
    text === void 0 && (text = "");
    var editor2 = new ExternalEditor(text, fileOptions);
    editor2.runAsync(function(err, result) {
      if (err)
        setImmediate(callback, err, null);
      else
        try {
          editor2.cleanup(), setImmediate(callback, null, result);
        } catch (cleanupError) {
          setImmediate(callback, cleanupError, null);
        }
    });
  }
  main.editAsync = editAsync;
  var ExternalEditor = (
    /** @class */
    function() {
      function ExternalEditor2(text, fileOptions) {
        text === void 0 && (text = ""), this.text = "", this.fileOptions = {}, this.text = text, fileOptions && (this.fileOptions = fileOptions), this.determineEditor(), this.createTemporaryFile();
      }
      return ExternalEditor2.splitStringBySpace = function(str2) {
        for (var pieces = [], currentString = "", strIndex = 0; strIndex < str2.length; strIndex++) {
          var currentLetter = str2[strIndex];
          strIndex > 0 && currentLetter === " " && str2[strIndex - 1] !== "\\" && currentString.length > 0 ? (pieces.push(currentString), currentString = "") : currentString += currentLetter;
        }
        return currentString.length > 0 && pieces.push(currentString), pieces;
      }, Object.defineProperty(ExternalEditor2.prototype, "temp_file", {
        get: function() {
          return console.log("DEPRECATED: temp_file. Use tempFile moving forward."), this.tempFile;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(ExternalEditor2.prototype, "last_exit_status", {
        get: function() {
          return console.log("DEPRECATED: last_exit_status. Use lastExitStatus moving forward."), this.lastExitStatus;
        },
        enumerable: !0,
        configurable: !0
      }), ExternalEditor2.prototype.run = function() {
        return this.launchEditor(), this.readTemporaryFile(), this.text;
      }, ExternalEditor2.prototype.runAsync = function(callback) {
        var _this = this;
        try {
          this.launchEditorAsync(function() {
            try {
              _this.readTemporaryFile(), setImmediate(callback, null, _this.text);
            } catch (readError) {
              setImmediate(callback, readError, null);
            }
          });
        } catch (launchError) {
          setImmediate(callback, launchError, null);
        }
      }, ExternalEditor2.prototype.cleanup = function() {
        this.removeTemporaryFile();
      }, ExternalEditor2.prototype.determineEditor = function() {
        var editor2 = process.env.VISUAL ? process.env.VISUAL : process.env.EDITOR ? process.env.EDITOR : /^win/.test(process.platform) ? "notepad" : "vim", editorOpts = ExternalEditor2.splitStringBySpace(editor2).map(function(piece) {
          return piece.replace("\\ ", " ");
        }), bin = editorOpts.shift();
        this.editor = { args: editorOpts, bin };
      }, ExternalEditor2.prototype.createTemporaryFile = function() {
        try {
          this.tempFile = tmp_1.tmpNameSync(this.fileOptions);
          var opt = { encoding: "utf8" };
          this.fileOptions.hasOwnProperty("mode") && (opt.mode = this.fileOptions.mode), fs_12.writeFileSync(this.tempFile, this.text, opt);
        } catch (createFileError) {
          throw new CreateFileError_1.CreateFileError(createFileError);
        }
      }, ExternalEditor2.prototype.readTemporaryFile = function() {
        try {
          var tempFileBuffer = fs_12.readFileSync(this.tempFile);
          if (tempFileBuffer.length === 0)
            this.text = "";
          else {
            var encoding = chardet_1.detect(tempFileBuffer).toString();
            iconv_lite_1.encodingExists(encoding) || (encoding = "utf8"), this.text = iconv_lite_1.decode(tempFileBuffer, encoding);
          }
        } catch (readFileError) {
          throw new ReadFileError_1.ReadFileError(readFileError);
        }
      }, ExternalEditor2.prototype.removeTemporaryFile = function() {
        try {
          fs_12.unlinkSync(this.tempFile);
        } catch (removeFileError) {
          throw new RemoveFileError_1.RemoveFileError(removeFileError);
        }
      }, ExternalEditor2.prototype.launchEditor = function() {
        try {
          var editorProcess = child_process_12.spawnSync(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
          this.lastExitStatus = editorProcess.status;
        } catch (launchError) {
          throw new LaunchEditorError_1.LaunchEditorError(launchError);
        }
      }, ExternalEditor2.prototype.launchEditorAsync = function(callback) {
        var _this = this;
        try {
          var editorProcess = child_process_12.spawn(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
          editorProcess.on("exit", function(code) {
            _this.lastExitStatus = code, setImmediate(callback);
          });
        } catch (launchError) {
          throw new LaunchEditorError_1.LaunchEditorError(launchError);
        }
      }, ExternalEditor2;
    }()
  );
  return main.ExternalEditor = ExternalEditor, main;
}
var editor, hasRequiredEditor;
function requireEditor() {
  if (hasRequiredEditor) return editor;
  hasRequiredEditor = 1;
  var chalk2 = chalk__default.default, editAsync = requireMain().editAsync, Base2 = requireBase(), observe = requireEvents(), { Subject: Subject2 } = require$$4$1;
  class EditorPrompt extends Base2 {
    /**
     * Start the Inquiry session
     * @param  {Function} cb      Callback when prompt is done
     * @return {this}
     */
    _run(cb) {
      this.done = cb, this.editorResult = new Subject2();
      var events2 = observe(this.rl);
      this.lineSubscription = events2.line.subscribe(this.startExternalEditor.bind(this));
      var validation = this.handleSubmitEvents(this.editorResult);
      return validation.success.forEach(this.onEnd.bind(this)), validation.error.forEach(this.onError.bind(this)), this.currentText = this.opt.default, this.opt.default = null, this.render(), this;
    }
    /**
     * Render the prompt to screen
     * @return {EditorPrompt} self
     */
    render(error2) {
      var bottomContent = "", message = this.getQuestion();
      this.status === "answered" ? message += chalk2.dim("Received") : message += chalk2.dim("Press <enter> to launch your preferred editor."), error2 && (bottomContent = chalk2.red(">> ") + error2), this.screen.render(message, bottomContent);
    }
    /**
     * Launch $EDITOR on user press enter
     */
    startExternalEditor() {
      this.rl.pause(), editAsync(this.currentText, this.endExternalEditor.bind(this));
    }
    endExternalEditor(error2, result) {
      this.rl.resume(), error2 ? this.editorResult.error(error2) : this.editorResult.next(result);
    }
    onEnd(state2) {
      this.editorResult.unsubscribe(), this.lineSubscription.unsubscribe(), this.answer = state2.value, this.status = "answered", this.render(), this.screen.done(), this.done(this.answer);
    }
    onError(state2) {
      this.render(state2.isValid);
    }
  }
  return editor = EditorPrompt, editor;
}
(function(module2) {
  var inquirer2 = module2.exports;
  inquirer2.prompts = {}, inquirer2.Separator = separator, inquirer2.ui = {
    BottomBar: bottomBar,
    Prompt: prompt$1
  }, inquirer2.createPromptModule = function(opt) {
    var promptModule = function(questions) {
      var ui = new inquirer2.ui.Prompt(promptModule.prompts, opt), promise2 = ui.run(questions);
      return promise2.ui = ui, promise2;
    };
    return promptModule.prompts = {}, promptModule.registerPrompt = function(name, prompt2) {
      return promptModule.prompts[name] = prompt2, this;
    }, promptModule.restoreDefaultPrompts = function() {
      this.registerPrompt("list", requireList()), this.registerPrompt("input", requireInput()), this.registerPrompt("number", requireNumber()), this.registerPrompt("confirm", requireConfirm()), this.registerPrompt("rawlist", requireRawlist()), this.registerPrompt("expand", requireExpand()), this.registerPrompt("checkbox", requireCheckbox()), this.registerPrompt("password", requirePassword()), this.registerPrompt("editor", requireEditor());
    }, promptModule.restoreDefaultPrompts(), promptModule;
  }, inquirer2.prompt = inquirer2.createPromptModule(), inquirer2.registerPrompt = function(name, prompt2) {
    inquirer2.prompt.registerPrompt(name, prompt2);
  }, inquirer2.restoreDefaultPrompts = function() {
    inquirer2.prompt.restoreDefaultPrompts();
  };
})(inquirer$1);
var inquirerExports = inquirer$1.exports, inquirer = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(inquirerExports);
function prompt(questions) {
  return inquirer.prompt(questions);
}
prompt.Separator = inquirer.Separator;
prompt.single = (question) => prompt([{ ...question, name: "value" }]).then((answers) => answers.value);
class CommandRunner {
  handlers;
  commands;
  commandGroups;
  constructor(handlers, commands = baseCommands) {
    this.handlers = handlers, this.commands = lodashExports.sortBy(commands, "name"), this.commandGroups = {};
    for (const cmd of this.commands) {
      const group = "group" in cmd && cmd.group || "default";
      this.commandGroups[group] = this.commandGroups[group] || [], this.commandGroups[group].push(cmd);
    }
    if (!handlers.outputter || !handlers.prompter)
      throw new Error("`prompter` and `outputter` handlers must be defined");
  }
  async runCommand(commandOrGroup, args, options2) {
    if (!commandOrGroup)
      return this.handlers.outputter.print(generateCommandsDocumentation(this.commandGroups)), Promise.resolve();
    const cmdArgs = lodashExports.cloneDeep(args), subCommandName = args.argsWithoutOptions[0], commandInfo = this.resolveCommand(commandOrGroup, subCommandName);
    if (!commandInfo)
      throw new Error(getNoSuchCommandText(commandOrGroup, subCommandName, this.commandGroups));
    const command2 = commandInfo.command;
    !isCommandGroup(command2) && command2.group && command2.group !== "default" && (cmdArgs.argsWithoutOptions = args.argsWithoutOptions.slice(1));
    const output = this.handlers.outputter, prompt2 = this.handlers.prompter, { cliConfig, ...commandOptions } = options2, apiClient = getClientWrapper(
      cliConfig?.config?.api || null,
      cliConfig?.path || (cliConfig?.version === 2 ? "sanity.json" : "sanity.cli.js")
    ), context = {
      output,
      prompt: prompt2,
      apiClient,
      chalk: chalk__default.default,
      cliPackageManager,
      ...commandOptions,
      commandRunner: this,
      yarn: getYarnStub({ output, workDir: commandOptions.workDir }),
      ...getVersionedContextParams(cliConfig)
    };
    if (isCommandGroup(command2))
      return context.output.print(generateCommandsDocumentation(this.commandGroups, command2.name));
    if (typeof command2.action != "function") {
      const cmdName = command2.name || commandOrGroup || "<unknown>";
      loadEnv.debug(`Command "${cmdName}" doesnt have a valid "action"-property, showing help`);
      const groupName = command2.group && command2.group !== "default" ? command2.group : null;
      return context.output.print(generateCommandDocumentation(command2, groupName, subCommandName));
    }
    return loadEnv.debug(`Running command "${command2.name}"`), command2.action(cmdArgs, context);
  }
  resolveCommand(commandOrGroup, subCommandName) {
    if (this.commandGroups[commandOrGroup] && subCommandName) {
      loadEnv.debug(`Found group for name "${commandOrGroup}", resolving subcommand`);
      const subCommand = this.resolveSubcommand(
        this.commandGroups[commandOrGroup],
        subCommandName,
        commandOrGroup
      );
      return loadEnv.debug(
        subCommand ? `Subcommand resolved to "${subCommand.commandName}"` : `Subcommand with name "${subCommandName}" not found`
      ), subCommand;
    }
    loadEnv.debug(`No group found with name "${commandOrGroup}", looking for command`);
    const command2 = this.commandGroups.default.find((cmd) => cmd.name === commandOrGroup);
    return command2 ? (loadEnv.debug(`Found command in default group with name "${commandOrGroup}"`), {
      command: command2,
      commandName: command2.name,
      parentName: "default",
      isGroup: !1,
      isCommand: !0
    }) : (loadEnv.debug(`No default command with name "${commandOrGroup}" found, giving up`), null);
  }
  resolveSubcommand(group, subCommandName, parentGroupName) {
    if (!subCommandName)
      return null;
    const subCommand = group.find((cmd) => cmd.name === subCommandName);
    if (!subCommand)
      throw new Error(getNoSuchCommandText(subCommandName, parentGroupName, this.commandGroups));
    return {
      command: subCommand,
      commandName: subCommandName,
      parentName: parentGroupName,
      isGroup: !1,
      isCommand: !0
    };
  }
  resolveHelpForGroup() {
    const command2 = this.commandGroups.default.find((cmd) => cmd.name === "help");
    if (!command2)
      throw new Error("Failed to find default `help` command");
    return {
      command: command2,
      commandName: "help",
      isGroup: !1,
      isCommand: !0
    };
  }
}
function getCliRunner(commands) {
  return new CommandRunner(
    {
      outputter: cliOutputter,
      prompter: prompt
    },
    commands
  );
}
function getVersionedContextParams(cliConfig) {
  return cliConfig?.version === 2 ? {
    sanityMajorVersion: 2,
    cliConfig: cliConfig?.config || void 0,
    cliConfigPath: cliConfig?.path || void 0
  } : {
    sanityMajorVersion: 3,
    cliConfig: cliConfig?.config || void 0,
    cliConfigPath: cliConfig?.path || void 0
  };
}
function detectRuntime() {
  return "Deno" in globalThis ? "deno" : "Bun" in globalThis ? "bun" : "node";
}
async function mergeCommands(baseCommands2, corePath, options2) {
  if (!corePath)
    return baseCommands2;
  const { cwd: cwd2, workDir, cliVersion } = options2, coreImport = getCliConfig.dynamicRequire(corePath);
  semver__default.default.coerce(cliVersion);
  const core2 = "cliProjectCommands" in coreImport ? coreImport.cliProjectCommands : coreImport;
  return baseCommands2.concat(core2.commands).map(addDefaultGroup).reverse().reduce(
    (cmds, cmd) => {
      const group = isCommandGroup(cmd) ? void 0 : cmd.group;
      return lodashExports.find(cmds, { name: cmd.name, group }) || cmds.push(cmd), cmds;
    },
    []
  );
}
function addDefaultGroup(cmd) {
  return !isCommandGroup(cmd) && !cmd.group && (cmd.group = "default"), cmd;
}
var escapeStringRegexp$1 = (string) => {
  if (typeof string != "string")
    throw new TypeError("Expected a string");
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const os = require$$0__default$2.default, escapeStringRegexp = escapeStringRegexp$1, extractPathRegex = /\s+at.*[(\s](.*)\)?/, pathRegex = /^(?:(?:(?:node|(?:(?:node:)?internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)(?:\.js)?:\d+:\d+)|native)/, homeDir = typeof os.homedir > "u" ? "" : os.homedir();
var cleanStack = (stack2, { pretty = !1, basePath } = {}) => {
  const basePathRegex = basePath && new RegExp(`(at | \\()${escapeStringRegexp(basePath)}`, "g");
  return stack2.replace(/\\/g, "/").split(`
`).filter((line3) => {
    const pathMatches = line3.match(extractPathRegex);
    if (pathMatches === null || !pathMatches[1])
      return !0;
    const match3 = pathMatches[1];
    return match3.includes(".app/Contents/Resources/electron.asar") || match3.includes(".app/Contents/Resources/default_app.asar") ? !1 : !pathRegex.test(match3);
  }).filter((line3) => line3.trim() !== "").map((line3) => (basePathRegex && (line3 = line3.replace(basePathRegex, "$1")), pretty && (line3 = line3.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")))), line3)).join(`
`);
}, cleanStack$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(cleanStack);
const options = { pretty: process.platform !== "win32" };
function neatStack(error2) {
  if (typeof error2 == "string")
    return chalk$4.red(cleanStack$1(error2, options));
  if (error2 === null || typeof error2 != "object" || typeof error2.stack != "string")
    return chalk$4.red(util$b.inspect(error2));
  const title = error2.toString(), stack2 = cleanStack$1(error2.stack, options);
  return stack2.startsWith(title) ? chalk$4.red(`${title}${chalk$4.dim(cleanStack$1(error2.stack, options).slice(title.length))}`) : chalk$4.red(stack2);
}
function parseArguments(argv = process.argv) {
  const {
    _: _2,
    h,
    help: help2,
    d,
    debug: debug2,
    v,
    version,
    "--": extraArguments,
    ...extOptions
  } = minimist$1(argv.slice(2), {
    "--": !0,
    boolean: ["h", "help", "d", "debug", "v", "version"],
    string: ["_"]
  }), [groupOrCommand, ...argsWithoutOptions] = _2;
  return {
    groupOrCommand,
    argv,
    extOptions,
    argsWithoutOptions,
    extraArguments: extraArguments || [],
    // prettier-ignore
    coreOptions: {
      h,
      help: help2,
      d,
      debug: debug2,
      v,
      version
    }
  };
}
const TELEMETRY_DISCLOSED_CONFIG_KEY = "telemetryDisclosed";
function telemetryDisclosure() {
  const userConfig = getUserConfig();
  if (isCi) {
    loadEnv.debug("CI environment detected, skipping telemetry disclosure");
    return;
  }
  if (userConfig.get(TELEMETRY_DISCLOSED_CONFIG_KEY)) {
    loadEnv.debug("Telemetry disclosure has already been shown");
    return;
  }
  console.error(
    boxen(
      `The Sanity CLI now collects telemetry data on general usage and errors.
This helps us improve Sanity and prioritize features.

To opt in/out, run ${chalk__default.default.cyan("npx sanity telemetry enable/disable")}.

${telemetryLearnMoreMessage("unset")}`,
      {
        padding: 1,
        margin: 1,
        borderColor: "yellow",
        // Typescript issues forcing these to any
        borderStyle: "round"
      }
    )
  ), userConfig.set(TELEMETRY_DISCLOSED_CONFIG_KEY, Date.now());
}
var pTimeout$2 = { exports: {} };
class TimeoutError extends Error {
  constructor(message) {
    super(message), this.name = "TimeoutError";
  }
}
const pTimeout = (promise2, milliseconds, fallback2, options2) => {
  let timer2;
  const cancelablePromise = new Promise((resolve2, reject) => {
    if (typeof milliseconds != "number" || milliseconds < 0)
      throw new TypeError("Expected `milliseconds` to be a positive number");
    if (milliseconds === 1 / 0) {
      resolve2(promise2);
      return;
    }
    options2 = {
      customTimers: { setTimeout, clearTimeout },
      ...options2
    }, timer2 = options2.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback2 == "function") {
        try {
          resolve2(fallback2());
        } catch (error2) {
          reject(error2);
        }
        return;
      }
      const message = typeof fallback2 == "string" ? fallback2 : `Promise timed out after ${milliseconds} milliseconds`, timeoutError = fallback2 instanceof Error ? fallback2 : new TimeoutError(message);
      typeof promise2.cancel == "function" && promise2.cancel(), reject(timeoutError);
    }, milliseconds), (async () => {
      try {
        resolve2(await promise2);
      } catch (error2) {
        reject(error2);
      } finally {
        options2.customTimers.clearTimeout.call(void 0, timer2);
      }
    })();
  });
  return cancelablePromise.clear = () => {
    clearTimeout(timer2), timer2 = void 0;
  }, cancelablePromise;
};
pTimeout$2.exports = pTimeout;
pTimeout$2.exports.default = pTimeout;
pTimeout$2.exports.TimeoutError = TimeoutError;
var pTimeoutExports = pTimeout$2.exports, pTimeout$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(pTimeoutExports);
const MAX_BLOCKING_TIME = 300, TWELVE_HOURS = 1e3 * 60 * 60 * 12, isDisabled = isCi || // Running in CI environment
process.env.NO_UPDATE_NOTIFIER;
function runUpdateCheck(options2) {
  loadEnv.debug("CLI installed at %s", __dirname);
  const { pkg, cwd: cwd2, workDir } = options2, { name, version } = pkg, userConfig = getUserConfig(), check = getLatestRemote().catch(() => !1);
  let hasPrintedResult = !1;
  return { notify };
  async function notify() {
    if (!process.stdout.isTTY)
      return;
    const result = await pTimeout$1(check, MAX_BLOCKING_TIME, printCachedResult);
    if (hasPrintedResult) {
      loadEnv.debug("Has already printed result through timeout check, skipping result notification");
      return;
    }
    printResult2(result);
  }
  async function printCachedResult() {
    loadEnv.debug("Max time (%dms) reached waiting for latest version info", MAX_BLOCKING_TIME), hasPrintedResult = !0;
    const cached = userConfig.get("cliHasUpdate");
    return cached ? semverCompare$1(cached, version) <= 0 ? (loadEnv.debug("CLI was upgraded since last check, falling back"), userConfig.delete("cliHasUpdate"), !1) : (loadEnv.debug("Printing cached latest version result"), await printResult2(cached), !1) : (loadEnv.debug("No cached latest version result found"), !1);
  }
  async function printResult2(newVersion) {
    hasPrintedResult = !0;
    const lastUpdated = userConfig.get("cliLastUpdateNag") || 0;
    if (Date.now() - lastUpdated < TWELVE_HOURS) {
      loadEnv.debug("Less than 12 hours since last nag, skipping");
      return;
    }
    if (!newVersion || semverCompare$1(newVersion, version) <= 0) {
      loadEnv.debug(`New version is ${newVersion || "unknown"}, current is ${version}. Falling back.`);
      return;
    }
    const upgradeCommand2 = await getCliUpgradeCommand({ cwd: cwd2, workDir }), message = [
      "Update available ",
      chalk__default.default.dim(version),
      chalk__default.default.reset(" \u2192 "),
      chalk__default.default.green(newVersion),
      ` 
Run `,
      chalk__default.default.cyan(upgradeCommand2),
      " to update"
    ].join("");
    console.error(`
${boxen(message, {
      padding: 1,
      margin: 1,
      borderColor: "yellow",
      // Typescript issues forcing these to any
      align: "center",
      borderStyle: "round"
    })}`), userConfig.set("cliLastUpdateNag", Date.now());
  }
  async function getLatestRemote() {
    if (isDisabled)
      return loadEnv.debug("Running on CI, or explicitly disabled, skipping update check"), !1;
    const lastUpdated = userConfig.get("cliLastUpdateCheck") || 0;
    if (Date.now() - lastUpdated < TWELVE_HOURS)
      return loadEnv.debug("Less than 12 hours since last check, skipping update check"), userConfig.get("cliHasUpdate") || !1;
    let latestRemote;
    try {
      loadEnv.debug("Checking for latest remote version"), latestRemote = await latestVersion(name), loadEnv.debug("Latest remote version is %s", latestRemote);
    } catch (err) {
      return loadEnv.debug(`Failed to fetch latest version of ${name} from npm:
${err.stack}`), !1;
    }
    if (!latestRemote)
      return loadEnv.debug(`Failed to fetch latest version of ${name} from npm`), !1;
    userConfig.set("cliLastUpdateCheck", Date.now());
    const diff = semverCompare$1(latestRemote, version);
    return diff <= 0 ? (loadEnv.debug(diff === 0 ? "No update found" : "Remote version older than local"), userConfig.delete("cliHasUpdate"), !1) : (userConfig.set("cliHasUpdate", latestRemote), loadEnv.debug("Update is available (%s)", latestRemote), latestRemote);
  }
}
const sanityEnv = process.env.SANITY_INTERNAL_ENV || "production", knownEnvs = ["development", "staging", "production"];
function wait(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
function installProcessExitHack(finalTask) {
  const originalProcessExit = process.exit;
  process.exit = (exitCode) => {
    finalTask().finally(() => originalProcessExit(exitCode));
  };
}
async function runCli(cliRoot, { cliVersion }) {
  installUnhandledRejectionsHandler();
  const pkg = { name: "@sanity/cli", version: cliVersion }, args = parseArguments(), isInit = args.groupOrCommand === "init" && args.argsWithoutOptions[0] !== "plugin", cwd2 = getCurrentWorkingDirectory();
  let workDir;
  try {
    workDir = isInit ? process.cwd() : loadEnv.resolveRootDir(cwd2);
  } catch (err) {
    console.error(chalk__default.default.red(err.message)), process.exit(1);
  }
  loadAndSetEnvFromDotEnvFiles({ workDir, cmd: args.groupOrCommand }), maybeFixMissingWindowsEnvVar(), await runUpdateCheck({ pkg, cwd: cwd2, workDir }).notify(), telemetryDisclosure(), loadEnv.debug(`Reading CLI config from "${workDir}"`);
  const cliConfig = await getCliConfig.getCliConfig(workDir, { forked: !0 });
  cliConfig || loadEnv.debug("No CLI config found");
  const { logger: telemetry2, flush: flushTelemetry } = createTelemetryStore({
    projectId: cliConfig?.config?.api?.projectId,
    env: process.env
  });
  installProcessExitHack(
    () => (
      // When process.exit() is called, flush telemetry events first, but wait no more than x amount of ms before exiting process
      Promise.race([wait(2e3), flushTelemetry()])
    )
  ), telemetry2.updateUserProperties({
    deviceId: await nodeMachineId.machineId(),
    runtimeVersion: process.version,
    runtime: detectRuntime(),
    cliVersion: pkg.version,
    machinePlatform: process.platform,
    cpuArchitecture: process.arch,
    projectId: cliConfig?.config?.api?.projectId,
    dataset: cliConfig?.config?.api?.dataset
  });
  const options2 = {
    cliRoot,
    workDir,
    corePath: await getCoreModulePath(workDir, cliConfig),
    cliConfig,
    telemetry: telemetry2
  };
  warnOnNonProductionEnvironment(), warnOnInferredProjectDir(isInit, cwd2, workDir);
  const core2 = args.coreOptions, commands = await mergeCommands(baseCommands, options2.corePath, { cliVersion, cwd: cwd2, workDir });
  (core2.v || core2.version) && (console.log(`${pkg.name} version ${pkg.version}`), process.exit()), (core2.h || core2.help) && (args.groupOrCommand && args.argsWithoutOptions.unshift(args.groupOrCommand), args.groupOrCommand = "help"), args.groupOrCommand === "logout" && await flushTelemetry();
  const cliRunner = getCliRunner(commands), cliCommandTrace = telemetry2.trace(CliCommand, {
    groupOrCommand: args.groupOrCommand,
    extraArguments: args.extraArguments,
    commandArguments: args.argsWithoutOptions.slice(0, 10),
    coreOptions: {
      help: args.coreOptions.help || void 0,
      version: args.coreOptions.help || void 0,
      debug: args.coreOptions.help || void 0
    },
    ...!args.groupOrCommand && { emptyCommand: !0 }
    // user did not entry a command
  });
  cliCommandTrace.start(), cliRunner.runCommand(args.groupOrCommand, args, {
    ...options2,
    telemetry: cliCommandTrace.newContext(args.groupOrCommand)
  }).then(() => cliCommandTrace.complete()).catch(async (err) => {
    await flushTelemetry();
    const error2 = typeof err.details == "string" ? err.details : err;
    console.error(`
${error2.stack ? neatStack(err) : error2}`), cliCommandTrace.error(error2), process.exit(1);
  });
}
async function getCoreModulePath(workDir, cliConfig) {
  const corePath = resolveFrom$1.silent(workDir, "@sanity/core"), sanityPath = resolveFrom$1.silent(workDir, "sanity/_internal");
  if (corePath && sanityPath) {
    const closest = corePath.startsWith(workDir) ? corePath : sanityPath, assumedVersion = closest === corePath ? "v2" : "v3";
    return console.warn(
      chalk__default.default.yellow(
        `Both \`@sanity/core\` AND \`sanity\` installed - assuming Sanity ${assumedVersion} project.`
      )
    ), closest;
  }
  if (sanityPath)
    return sanityPath;
  if (corePath && cliConfig && cliConfig?.version < 3)
    return corePath;
  const isInstallCommand = process.argv.indexOf("install") === -1;
  if (cliConfig && cliConfig?.version < 3 && !corePath && !isInstallCommand) {
    const installCmd = await getInstallCommand({ workDir });
    console.warn(
      chalk__default.default.yellow(
        [
          "The `@sanity/core` module is not installed in current project",
          `Project-specific commands not available until you run \`${installCmd}\``
        ].join(`
`)
      )
    );
  }
  if (cliConfig && cliConfig.version >= 3 && !sanityPath) {
    const installCmd = await getInstallCommand({ workDir });
    console.warn(
      chalk__default.default.yellow(
        [
          "The `sanity` module is not installed in current project",
          `Project-specific commands not available until you run \`${installCmd}\``
        ].join(`
`)
      )
    );
  }
}
function getCurrentWorkingDirectory() {
  let pwd;
  try {
    pwd = process.cwd();
  } catch (err) {
    if (err.code === "ENOENT")
      console.error("[ERR] Could not resolve working directory, does the current folder exist?"), process.exit(1);
    else
      throw err;
  }
  return pwd;
}
function installUnhandledRejectionsHandler() {
  process.on("unhandledRejection", (reason) => {
    rejectionHasStack(reason) ? console.error("Unhandled rejection:", reason.stack) : console.error(`Unhandled rejection
`, reason);
  });
}
function rejectionHasStack(reason) {
  return !!(reason && typeof reason == "object" && "stack" in reason && typeof reason.stack == "string");
}
function warnOnInferredProjectDir(isInit, cwd2, workDir) {
  isInit || cwd2 === workDir || console.log(`Not in project directory, assuming context of project at ${workDir}`);
}
function warnOnNonProductionEnvironment() {
  sanityEnv !== "production" && console.warn(
    chalk__default.default.yellow(
      knownEnvs.includes(sanityEnv) ? `[WARN] Running in ${sanityEnv} environment mode
` : `[WARN] Running in ${chalk__default.default.red("UNKNOWN")} "${sanityEnv}" environment mode
`
    )
  );
}
function loadAndSetEnvFromDotEnvFiles({ workDir, cmd }) {
  if (fs$p.existsSync(path__default.default.join(workDir, "sanity.json"))) {
    loadEnv.debug("sanity.json exists, assuming v2 project and loading .env files using old behavior");
    const env = process.env.SANITY_ACTIVE_ENV || process.env.NODE_ENV || "development";
    loadEnv.debug("Loading environment files using %s mode", env), loadEnv.dotenv.config({ path: path__default.default.join(workDir, `.env.${env}`) });
    return;
  }
  loadEnv.debug("No sanity.json exists, assuming v3 project and loading .env files using new behavior");
  const isProdCmd = ["build", "deploy"].includes(cmd);
  let mode2 = process.env.SANITY_ACTIVE_ENV;
  !mode2 && (isProdCmd || process.env.NODE_ENV === "production") ? mode2 = "production" : mode2 || (mode2 = "development"), mode2 === "production" && !isProdCmd && console.warn(chalk__default.default.yellow(`[WARN] Running in ${sanityEnv} environment mode
`)), loadEnv.debug("Loading environment files using %s mode", mode2);
  const studioEnv = loadEnv.loadEnv(mode2, workDir, ["SANITY_STUDIO_"]);
  process.env = { ...process.env, ...studioEnv };
}
function maybeFixMissingWindowsEnvVar() {
  os__default.default.platform() === "win32" && !("SYSTEMROOT" in process.env) && "SystemRoot" in process.env && (process.env.SYSTEMROOT = process.env.SystemRoot);
}
exports.getCliVersion = getCliVersion;
exports.runCli = runCli;
//# sourceMappingURL=cli.js.map
