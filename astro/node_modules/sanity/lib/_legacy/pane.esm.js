import { Tooltip, TooltipDelayGroupProvider, Button, Dialog, MenuGroup, MenuItem, MenuButton, Tab, Popover as Popover$1, generateHelpUrl } from "./generate-help-url.esm.esm.js";
import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import { Box, rem, Flex, Inline, Text, useToast, Card, Stack, ErrorBoundary, Layer, useForwardedRef, BoundaryElementProvider, MenuDivider, Menu, TextSkeleton, rgba, useElementRect, LayerProvider, _raf2, TextInput, TabList, TabPanel, Code, Heading, focusFirstDescendant, Container, Spinner, usePortal, PortalProvider, Popover, useLayer, useClickOutside, useGlobalKeyDown, Grid, Button as Button$1, Dialog as Dialog$1, AvatarStack, Badge, Hotkeys, DialogProvider, Select, Checkbox, MenuButton as MenuButton$1 } from "@sanity/ui";
import { isValidElement, forwardRef, useContext, useMemo, useCallback, useId, useState, useEffect, memo, useRef, useLayoutEffect, createElement, useReducer, Fragment as Fragment$1, lazy } from "react";
import { PaneRouterContext, PaneLayoutContext, PaneContext, DocumentPaneContext, StructureToolContext, DocumentChangeContext } from "sanity/_singletons";
import { InfoOutlineIcon, UnknownIcon, WarningOutlineIcon, DocumentsIcon, ChevronDownIcon, CopyIcon, CheckmarkIcon, AddIcon, ChevronRightIcon, DocumentIcon, FolderIcon, CloseIcon, SearchIcon, ReadOnlyIcon, ErrorOutlineIcon, SyncIcon, AddCircleIcon, TrashIcon, EditIcon, PublishIcon, UnpublishIcon, ArrowLeftIcon, SplitVerticalIcon, ResetIcon, RestoreIcon, JsonIcon, EarthAmericasIcon, SpinnerIcon, DoubleChevronLeftIcon, ChevronLeftIcon, DoubleChevronRightIcon, SortIcon, StackCompactIcon, StackIcon, CheckmarkCircleIcon, MasterDetailIcon } from "@sanity/icons";
import camelCase from "lodash/camelCase.js";
import speakingurl from "speakingurl";
import uniqueId from "lodash/uniqueId.js";
import { isValidElementType } from "react-is";
import { defineLocaleResourceBundle, useSchema, useTranslation, unstable_useValuePreview, isRecord, getPreviewStateObservable, SanityDefaultPreview, getPreviewValueWithFallback, DocumentPreviewPresence, DocumentStatusIndicator, DocumentStatus, useUnique, getPublishedId, useDocumentPresence, useDocumentPreviewStore, PreviewCard, Translate, createHookFromObservableFactory, getDraftId, useClient, DEFAULT_STUDIO_CLIENT_OPTIONS, useDocumentStore, LoadingBlock, LegacyLayerProvider, IsLastPaneProvider, useGetI18nText, useI18nText, TooltipOfDisabled, ContextMenuButton, StatusButton, useCurrentUser, InsufficientPermissionsMessage, useTemplates, useTemplatePermissions, EMPTY_ARRAY as EMPTY_ARRAY$3, EMPTY_OBJECT, GetHookCollectionState, isDev, CommentsEnabledProvider, useCommentsEnabled, COMMENTS_INSPECTOR_NAME, CommentsProvider, useDocumentOperationEvent, useKeyValueStore, isString as isString$1, useDocumentOperation, isDeprecatedSchemaType, useListFormat, createPatchChannel, PresenceOverlay, FormBuilder, fromMutationPatches, ScrollContainer, useTimelineSelector, VirtualizerScrollInstanceProvider, UserAvatar, useDateTimeFormat, CommandList, TextWithTone, useFieldActions, useDocumentPairPermissions, useValidationStatus, useSyncState, useEditState, useRelativeTime, resizeObserver, useSource, ChangeConnectorRoot, useZIndex, FieldActionsResolver, FieldActionsProvider, useMiddlewareComponents, usePresenceStore, useInitialValue, useConnectionState, useTimelineStore, toMutationPatches, setAtPath, useDocumentValuePermissions, useFormState, getExpandOperations, SourceProvider, useDocumentType, ReferenceInputOptionsProvider, collate, getSearchableTypes, createSearch, useWorkspace, useSearchMaxFieldDepth, useSearchState, SearchHeader, Filters, SearchProvider, getConfigContextFromSource, visitDiff, ChangeFieldWrapper, DiffTooltip, NoChanges, ChangeList, isArray, isValidationError, isValidationWarning, definePlugin, useConfigContextFromSource } from "sanity";
import uniq from "lodash/uniq.js";
import kebabCase from "lodash/kebabCase.js";
import find from "lodash/find.js";
import startCase from "lodash/startCase.js";
import { uuid } from "@sanity/uuid";
import { styled, css, keyframes } from "styled-components";
import omit from "lodash/omit.js";
import { StateLink, useIntentLink, IntentLink, useRouter, route, encodeJsonParams, decodeJsonParams } from "sanity/router";
import * as PathUtils from "@sanity/util/paths";
import { toString, fromString, get, resolveKeyedPath } from "@sanity/util/paths";
import { fromEvent, timer, EMPTY, of, merge, concat, firstValueFrom, filter, from, defer, mergeMap, throwError, share, partition, take, throttleTime, asyncScheduler, map as map$1, Subject, tap as tap$1, debounce, catchError as catchError$1 } from "rxjs";
import { switchMap, startWith, map, distinctUntilChanged, shareReplay, catchError, mapTo, delay, debounceTime, tap, take as take$1, mergeMap as mergeMap$1, scan } from "rxjs/operators";
import { isHotkey } from "is-hotkey-esm";
import { useTranslation as useTranslation$1 } from "react-i18next";
import JSONInspector from "@rexxars/react-json-inspector";
import LRU from "quick-lru";
import { useMemoObservable, useAsObservable, useObservableCallback } from "react-rx";
import { useTelemetry } from "@sanity/telemetry/react";
import { isSanityDocument as isSanityDocument$1, isValidationErrorMarker, isKeySegment, isIndexSegment, isReferenceSchemaType, isObjectSchemaType, isDocumentSchemaType } from "@sanity/types";
import { defineEvent } from "@sanity/telemetry";
import { motion } from "framer-motion";
import { isActionEnabled } from "@sanity/schema/_internal";
import throttle from "lodash/throttle.js";
import deepEquals from "react-fast-compare";
import isEqual from "lodash/isEqual.js";
import shallowEquals from "shallow-equals";
import CopyToClipboard from "react-copy-to-clipboard";
import isNumber from "lodash/isNumber.js";
import isString from "lodash/isString.js";
import uniqBy from "lodash/uniqBy.js";
import negate from "lodash/negate.js";
import { parse } from "groq-js";
import { exhaustMapWithTrailing } from "rxjs-exhaustmap-with-trailing";
import { createColumnHelper, useReactTable, getCoreRowModel, getFilteredRowModel, getPaginationRowModel, flexRender } from "@tanstack/react-table";
const structureLocaleNamespace = "structure", structureUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: structureLocaleNamespace,
  resources: () => import("./resources.esm3.js")
});
function DocTitle(props) {
  const { document: documentValue } = props, schemaType = useSchema().get(documentValue._type), { t } = useTranslation(structureLocaleNamespace), { error, value } = unstable_useValuePreview({
    schemaType,
    value: documentValue
  });
  return schemaType ? error ? /* @__PURE__ */ jsx(Fragment, { children: t("doc-title.error.text", { errorMessage: error.message }) }) : /* @__PURE__ */ jsx(Fragment, { children: (value == null ? void 0 : value.title) || /* @__PURE__ */ jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("doc-title.fallback.text") }) }) : /* @__PURE__ */ jsx("code", { children: t("doc-title.unknown-schema-type.text", { schemaType: documentValue._type }) });
}
const ChevronWrapper = styled(Box)`
  margin-left: auto;
`, CrossDatasetReferencesDetails = styled.details`
  flex: none;

  &[open] ${ChevronWrapper} {
    transform: rotate(180deg);
  }
`, CrossDatasetReferencesSummary = styled.summary`
  list-style: none;

  &::-webkit-details-marker {
    display: none;
  }
`, Table$1 = styled.table`
  width: 100%;
  text-align: left;
  padding: 0 ${({ theme }) => rem(theme.sanity.space[2])};
  border-collapse: collapse;

  th {
    padding: ${({ theme }) => rem(theme.sanity.space[1])};
  }

  td {
    padding: 0 ${({ theme }) => rem(theme.sanity.space[1])};
  }

  tr > *:last-child {
    text-align: right;
  }
`, DocumentIdFlex = styled(Flex)`
  min-height: 33px;
`, OtherReferenceCount = (props) => {
  const { t } = useTranslation(structureLocaleNamespace), difference = props.totalCount - props.references.length;
  return difference ? /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsxs(Inline, { space: 2, children: [
    /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("confirm-delete-dialog.other-reference-count.title", { count: difference }) }),
    /* @__PURE__ */ jsx(
      Tooltip,
      {
        portal: !0,
        placement: "top",
        content: t("confirm-delete-dialog.other-reference-count.tooltip"),
        children: /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: /* @__PURE__ */ jsx(InfoOutlineIcon, {}) })
      }
    )
  ] }) }) : null;
};
function PaneItemPreview(props) {
  const { icon, layout, presence, schemaType, value } = props, title = isRecord(value.title) && isValidElement(value.title) || isString(value.title) || isNumber(value.title) ? value.title : null, { draft, published, isLoading } = useMemoObservable(
    () => getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title),
    [props.documentPreviewStore, schemaType, value._id, title]
  ), status = isLoading ? null : /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && /* @__PURE__ */ jsx(DocumentPreviewPresence, { presence }),
    /* @__PURE__ */ jsx(DocumentStatusIndicator, { draft, published })
  ] }) }), tooltip = /* @__PURE__ */ jsx(DocumentStatus, { draft, published });
  return /* @__PURE__ */ jsx(
    SanityDefaultPreview,
    {
      ...getPreviewValueWithFallback({ value, draft, published }),
      isPlaceholder: isLoading,
      icon,
      layout,
      status,
      tooltip
    }
  );
}
const BackLink = forwardRef(function(props, ref) {
  const { routerPanesState, groupIndex } = useContext(PaneRouterContext), panes = useMemo(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]), state2 = useMemo(() => ({ panes }), [panes]);
  return /* @__PURE__ */ jsx(StateLink, { ...props, ref, state: state2 });
});
function usePaneLayout() {
  const pane2 = useContext(PaneLayoutContext);
  if (!pane2)
    throw new Error("PaneLayout: missing context value");
  return pane2;
}
const ChildLink = forwardRef(function(props, ref) {
  const { childId, childPayload, childParameters, ...rest } = props, { routerPanesState, groupIndex } = useContext(PaneRouterContext);
  return /* @__PURE__ */ jsx(
    StateLink,
    {
      ...rest,
      ref,
      state: {
        panes: [
          ...routerPanesState.slice(0, groupIndex + 1),
          [{ id: childId, params: childParameters, payload: childPayload }]
        ]
      }
    }
  );
}), ParameterizedLink = forwardRef(function(props, ref) {
  const { routerPanesState: currentPanes, groupIndex, siblingIndex } = useContext(PaneRouterContext), { params, payload, ...rest } = props, nextParams = useUnique(params), nextPayload = useUnique(payload), nextState = useMemo(() => {
    const currentGroup = currentPanes[groupIndex], currentSibling = currentGroup[siblingIndex], nextSibling = {
      ...currentSibling,
      params: nextParams != null ? nextParams : currentSibling.params,
      payload: nextPayload != null ? nextPayload : currentSibling.payload
    }, nextGroup = [
      ...currentGroup.slice(0, siblingIndex),
      nextSibling,
      ...currentGroup.slice(siblingIndex + 1)
    ];
    return { panes: [
      ...currentPanes.slice(0, groupIndex),
      nextGroup,
      ...currentPanes.slice(groupIndex + 1)
    ] };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return /* @__PURE__ */ jsx(StateLink, { ref, ...rest, state: nextState });
}), ReferenceChildLink = forwardRef(function({ documentId, documentType, parentRefPath, children, template, ...rest }, ref) {
  return /* @__PURE__ */ jsx(
    ChildLink,
    {
      ...rest,
      ref,
      childId: documentId,
      childPayload: template == null ? void 0 : template.params,
      childParameters: {
        type: documentType,
        parentRefPath: toString(parentRefPath),
        ...template && { template: template == null ? void 0 : template.id }
      },
      children
    }
  );
});
function usePaneRouter() {
  return useContext(PaneRouterContext);
}
const EMPTY_ARRAY$2 = [];
function ReferencePreviewLink(props) {
  const { onClick, type, value } = props, publishedId = getPublishedId(value == null ? void 0 : value._id), documentPresence = useDocumentPresence(publishedId), documentPreviewStore = useDocumentPreviewStore(), { ReferenceChildLink: ReferenceChildLink2 } = usePaneRouter(), Link = useCallback(
    function(linkProps) {
      return /* @__PURE__ */ jsx(
        ReferenceChildLink2,
        {
          documentId: value == null ? void 0 : value._id,
          documentType: type == null ? void 0 : type.name,
          parentRefPath: EMPTY_ARRAY$2,
          ...linkProps
        }
      );
    },
    [ReferenceChildLink2, type == null ? void 0 : type.name, value == null ? void 0 : value._id]
  );
  return /* @__PURE__ */ jsx(PreviewCard, { __unstable_focusRing: !0, as: Link, "data-as": "a", onClick, radius: 2, children: /* @__PURE__ */ jsx(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: type == null ? void 0 : type.icon,
      layout: "compact",
      presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY$2,
      schemaType: type,
      value
    }
  ) });
}
function ConfirmDeleteDialogBody({
  crossDatasetReferences,
  internalReferences,
  documentTitle,
  totalCount,
  action,
  datasetNames,
  hasUnknownDatasetNames,
  onReferenceLinkClick
}) {
  const schema = useSchema(), toast = useToast(), { t } = useTranslation(structureLocaleNamespace), renderPreviewItem = useCallback(
    (item) => {
      const type = schema.get(item._type);
      return type ? /* @__PURE__ */ jsx(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick }) : (
        // Padding added to match the ReferencePreviewLink styling
        /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(
          SanityDefaultPreview,
          {
            icon: UnknownIcon,
            title: t("confirm-delete-dialog.preview-item.preview-unavailable.title"),
            subtitle: t("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", {
              documentId: item._id
            }),
            layout: "default"
          }
        ) })
      );
    },
    [schema, t, onReferenceLinkClick]
  );
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0)
    return /* @__PURE__ */ jsx(Text, { as: "p", size: 1, children: /* @__PURE__ */ jsx(
      Translate,
      {
        t,
        i18nKey: "confirm-delete-dialog.confirmation.text",
        context: action,
        components: { DocumentTitle: () => /* @__PURE__ */ jsx("strong", { children: documentTitle }) }
      }
    ) });
  const normalizedDatasetNames = [
    ...datasetNames,
    ...hasUnknownDatasetNames ? ["unavailable"] : []
  ], datasetSubtitle = t("confirm-delete-dialog.cdr-summary.subtitle", {
    count: normalizedDatasetNames.length,
    datasets: normalizedDatasetNames.join(", "),
    context: hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : ""
  });
  return /* @__PURE__ */ jsxs(Flex, { direction: "column", gap: 4, children: [
    /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: /* @__PURE__ */ jsxs(Flex, { children: [
      /* @__PURE__ */ jsx(Text, { "aria-hidden": "true", size: 1, children: /* @__PURE__ */ jsx(WarningOutlineIcon, {}) }),
      /* @__PURE__ */ jsx(Box, { flex: 1, marginLeft: 3, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(
        Translate,
        {
          i18nKey: "confirm-delete-dialog.referring-document-count.text",
          components: { DocumentTitle: () => documentTitle },
          t,
          values: { count: totalCount }
        }
      ) }) })
    ] }) }),
    /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(
      Translate,
      {
        i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) }),
    /* @__PURE__ */ jsx(Card, { radius: 2, shadow: 1, flex: "auto", padding: 2, children: /* @__PURE__ */ jsxs(Flex, { direction: "column", children: [
      internalReferences.totalCount > 0 && /* @__PURE__ */ jsxs(Stack, { as: "ul", marginBottom: 2, space: 2, "data-testid": "internal-references", children: [
        internalReferences == null ? void 0 : internalReferences.references.map((item) => /* @__PURE__ */ jsx(Box, { as: "li", children: renderPreviewItem(item) }, item._id)),
        internalReferences.totalCount > internalReferences.references.length && /* @__PURE__ */ jsx(Box, { as: "li", padding: 3, children: /* @__PURE__ */ jsx(OtherReferenceCount, { ...internalReferences }) })
      ] }),
      crossDatasetReferences.totalCount > 0 && /* @__PURE__ */ jsxs(
        CrossDatasetReferencesDetails,
        {
          "data-testid": "cross-dataset-references",
          style: {
            // only add the border if needed
            borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
          },
          children: [
            /* @__PURE__ */ jsx(CrossDatasetReferencesSummary, { children: /* @__PURE__ */ jsx(
              Card,
              {
                as: "a",
                marginTop: internalReferences.totalCount > 0 ? 2 : 0,
                radius: 2,
                shadow: 1,
                paddingY: 1,
                children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [
                  /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(DocumentsIcon, {}) }),
                  /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
                    /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", size: 1, children: t("confirm-delete-dialog.cdr-summary.title", {
                      count: normalizedDatasetNames.length,
                      documentCount: t("confirm-delete-dialog.cdr-summary.document-count", {
                        count: crossDatasetReferences.totalCount
                      })
                    }) }),
                    /* @__PURE__ */ jsx(Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: !0, children: datasetSubtitle })
                  ] }),
                  /* @__PURE__ */ jsx(ChevronWrapper, { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsx(ChevronDownIcon, {}) }) })
                ] })
              }
            ) }),
            /* @__PURE__ */ jsxs(Box, { overflow: "auto", paddingTop: 2, children: [
              /* @__PURE__ */ jsxs(Table$1, { children: [
                /* @__PURE__ */ jsx("thead", { children: /* @__PURE__ */ jsxs("tr", { children: [
                  /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, style: { minWidth: "5rem" }, weight: "medium", children: t("confirm-delete-dialog.cdr-table.project-id.label") }) }),
                  /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.dataset.label") }) }),
                  /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.document-id.label") }) })
                ] }) }),
                /* @__PURE__ */ jsx("tbody", { children: crossDatasetReferences.references.filter((reference) => "projectId" in reference).map(({ projectId, datasetName, documentId }, index) => (
                  // eslint-disable-next-line react/no-array-index-key
                  /* @__PURE__ */ jsxs("tr", { children: [
                    /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx(Text, { size: 1, children: projectId }) }),
                    /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx(Text, { size: 1, children: datasetName || "unavailable" }) }),
                    /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsxs(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [
                      /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", size: 1, children: documentId || "unavailable" }),
                      documentId && /* @__PURE__ */ jsx(
                        CopyToClipboard,
                        {
                          text: documentId,
                          onCopy: () => {
                            toast.push({
                              title: t(
                                "confirm-delete-dialog.cdr-table.id-copied-toast.title"
                              ),
                              status: "success"
                            });
                          },
                          children: /* @__PURE__ */ jsx(
                            Button,
                            {
                              mode: "bleed",
                              icon: CopyIcon,
                              tooltipProps: {
                                content: t(
                                  "confirm-delete-dialog.cdr-table.copy-id-button.tooltip"
                                )
                              }
                            }
                          )
                        }
                      )
                    ] }) })
                  ] }, `${documentId}-${index}`)
                )) })
              ] }),
              /* @__PURE__ */ jsx(OtherReferenceCount, { ...crossDatasetReferences })
            ] })
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(
      Translate,
      {
        i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) })
  ] });
}
function isClientError(e) {
  return typeof e != "object" || !e ? !1 : "statusCode" in e && "response" in e;
}
const POLL_INTERVAL = 5e3;
let visiblePoll$;
const getVisiblePoll$ = () => (visiblePoll$ || (visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
  // add empty emission to have this fire on creation
  startWith(null),
  map(() => document.visibilityState === "visible"),
  distinctUntilChanged(),
  switchMap(
    (visible) => visible ? (
      // using timer instead of interval since timer will emit on creation
      timer(0, POLL_INTERVAL)
    ) : EMPTY
  ),
  shareReplay({ refCount: !0, bufferSize: 1 })
)), visiblePoll$);
function getDocumentExistence(documentId, { versionedClient }) {
  const draftId = getDraftId(documentId), publishedId = getPublishedId(documentId), requestOptions = {
    uri: versionedClient.getDataUrl("doc", `${draftId},${publishedId}`),
    json: !0,
    query: { excludeContent: "true" },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(
    map(({ omitted }) => {
      const nonExistant = omitted.filter((doc) => doc.reason === "existence");
      if (nonExistant.length !== 2)
        return nonExistant.length === 0 || nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
    })
  );
}
function fetchCrossDatasetReferences(documentId, context) {
  const { versionedClient } = context;
  return getVisiblePoll$().pipe(
    switchMap(() => getDocumentExistence(documentId, context)),
    switchMap((checkDocumentId) => {
      if (!checkDocumentId)
        return of({ totalCount: 0, references: [] });
      const currentDataset = versionedClient.config().dataset;
      return versionedClient.observable.request({
        url: `/data/references/${currentDataset}/documents/${checkDocumentId}/to?excludeInternalReferences=true&excludePaths=true`,
        tag: "use-referring-documents.external"
      }).pipe(
        catchError((e) => {
          if (isClientError(e) && e.statusCode === 404)
            return of({ totalCount: 0, references: [] });
          throw e;
        })
      );
    })
  );
}
const useInternalReferences = createHookFromObservableFactory(
  ([documentId, documentStore]) => documentStore.listenQuery(
    { fetch: '{"references":*[references($documentId)][0...100]{_id,_type},"totalCount":count(*[references($documentId)])}', listen: "*[references($documentId)]" },
    { documentId },
    { tag: "use-referring-documents", transitions: ["appear", "disappear"], throttleTime: 5e3 }
  )
), useCrossDatasetReferences = createHookFromObservableFactory(
  ([documentId, versionedClient]) => getVisiblePoll$().pipe(
    switchMap(
      () => fetchCrossDatasetReferences(documentId, {
        versionedClient
      })
    )
  )
);
function useReferringDocuments(documentId) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentStore = useDocumentStore(), publishedId = getPublishedId(documentId), [internalReferences, isInternalReferencesLoading] = useInternalReferences(
    useMemo(() => [publishedId, documentStore], [documentStore, publishedId])
  ), [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(
    useMemo(() => [publishedId, versionedClient], [publishedId, versionedClient])
  ), projectIds = useMemo(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => crossDatasetReference.projectId).filter(Boolean)
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), datasetNames = useMemo(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter((datasetName) => !!datasetName && datasetName !== "")
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), hasUnknownDatasetNames = useMemo(() => !!(crossDatasetReferences != null && crossDatasetReferences.references.some(
    (crossDatasetReference) => typeof crossDatasetReference.datasetName != "string"
  )), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}
const DialogBody = styled(Box)`
  box-sizing: border-box;
`, LoadingContainer = styled(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})`
  height: 110px;
`;
function ConfirmDeleteDialog({
  id,
  type,
  action = "delete",
  onCancel,
  onConfirm
}) {
  const { t } = useTranslation(structureLocaleNamespace), dialogId = `deletion-confirmation-${useId()}`, {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id), documentTitle = /* @__PURE__ */ jsx(DocTitle, { document: useMemo(() => ({ _id: id, _type: type }), [id, type]) }), showConfirmButton = !isLoading;
  return /* @__PURE__ */ jsx(
    Dialog,
    {
      width: 1,
      id: dialogId,
      header: t("confirm-delete-dialog.header.text", { context: action }),
      footer: {
        cancelButton: {
          onClick: onCancel,
          text: t("confirm-delete-dialog.cancel-button.text")
        },
        confirmButton: showConfirmButton ? {
          text: totalCount > 0 ? t("confirm-delete-dialog.confirm-anyway-button.text", { context: action }) : t("confirm-delete-dialog.confirm-button.text", { context: action }),
          onClick: onConfirm
        } : void 0
      },
      onClose: onCancel,
      onClickOutside: onCancel,
      children: /* @__PURE__ */ jsx(DialogBody, { children: crossDatasetReferences && internalReferences && !isLoading ? /* @__PURE__ */ jsx(
        ConfirmDeleteDialogBody,
        {
          crossDatasetReferences,
          internalReferences,
          documentTitle,
          isLoading,
          totalCount,
          action,
          projectIds,
          datasetNames,
          hasUnknownDatasetNames,
          onReferenceLinkClick: onCancel
        }
      ) : /* @__PURE__ */ jsx(LoadingContainer, { "data-testid": "loading-container", children: /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: t("confirm-delete-dialog.loading.text") }) }) })
    }
  );
}
function ConfirmDeleteDialogContainer(props) {
  const { t } = useTranslation(structureLocaleNamespace), id = useId(), [error, setError] = useState(null), handleRetry = useCallback(() => setError(null), []);
  return error ? /* @__PURE__ */ jsx(
    Dialog,
    {
      id: `dialog-error-${id}`,
      "data-testid": "confirm-delete-error-dialog",
      header: t("confirm-delete-dialog.error.title.text"),
      footer: {
        confirmButton: {
          text: t("confirm-delete-dialog.error.retry-button.text"),
          onClick: handleRetry,
          tone: "default"
        }
      },
      onClose: props.onCancel,
      children: /* @__PURE__ */ jsx(Box, { padding: 4, children: /* @__PURE__ */ jsx(Text, { size: 1, children: t("confirm-delete-dialog.error.message.text") }) })
    }
  ) : /* @__PURE__ */ jsx(ErrorBoundary, { onCatch: setError, children: /* @__PURE__ */ jsx(ConfirmDeleteDialog, { ...props }) });
}
function Delay({
  children,
  ms = 0
}) {
  const [ready, setReady] = useState(ms <= 0);
  return useEffect(() => {
    if (ms <= 0)
      return;
    const timeoutId = setTimeout(() => setReady(!0), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]), !ready || !children ? /* @__PURE__ */ jsx(Fragment, {}) : typeof children == "function" ? children() : children;
}
const PANE_DEBUG = !1, PANE_COLLAPSED_WIDTH = 51, PANE_DEFAULT_MIN_WIDTH = 204, Root$b = styled(Layer)`
  position: relative;
  width: 1px;
  min-width: 1px;

  &:before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 1px;
    background-color: var(--card-border-color);
  }

  &:not([data-disabled]) {
    cursor: ew-resize;
    width: 9px;
    min-width: 9px;
    margin: 0 -4px;

    &:before {
      left: 4px;
    }

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 9px;
      bottom: 0;
      background-color: var(--card-border-color);
      opacity: 0;
      transition: opacity 150ms;
    }

    &[data-dragging]:after,
    &:hover:after {
      opacity: 0.2;
    }
  }
`;
function PaneDivider({
  disabled,
  element
}) {
  const { resize } = usePaneLayout(), [dragging, setDragging] = useState(!1), handleMouseDown = useCallback(
    (event) => {
      if (!element) return;
      setDragging(!0), event.preventDefault();
      const startX = event.pageX;
      resize("start", element, 0);
      const handleMouseMove = (e) => {
        e.preventDefault();
        const deltaX = e.pageX - startX;
        resize("move", element, deltaX);
      }, handleMouseUp = (e) => {
        e.preventDefault(), setDragging(!1), window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp), resize("end", element, 0);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [element, resize]
  );
  return /* @__PURE__ */ jsx(
    Root$b,
    {
      "data-disabled": disabled ? "" : void 0,
      "data-dragging": dragging ? "" : void 0,
      onMouseDown: handleMouseDown
    }
  );
}
const Root$a = styled(Card)`
  outline: none;

  // NOTE: This will render a border to the right side of each pane
  // without taking up physical space.
  box-shadow: 1px 0 0 var(--card-border-color);
`, Pane = forwardRef(function(props, ref) {
  var _a, _b, _c;
  const {
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: flexProp = 1,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected = !1,
    ...restProps
  } = props, [rootElement, setRootElement] = useState(null), {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout(), pane2 = panes.find((p) => p.element === rootElement), paneIndex = pane2 && panes.indexOf(pane2), nextPane = typeof paneIndex == "number" ? panes[paneIndex + 1] : void 0, isLast = paneIndex === panes.length - 1, collapsed = layoutCollapsed ? !1 : (pane2 == null ? void 0 : pane2.collapsed) || !1, nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || !1, forwardedRef = useForwardedRef(ref), flex = (_a = pane2 == null ? void 0 : pane2.flex) != null ? _a : flexProp, currentMinWidth = (_b = pane2 == null ? void 0 : pane2.currentMinWidth) != null ? _b : currentMinWidthProp, currentMaxWidth = (_c = pane2 == null ? void 0 : pane2.currentMaxWidth) != null ? _c : currentMaxWidthProp, setRef = useCallback(
    (refValue) => {
      setRootElement(refValue), forwardedRef.current = refValue;
    },
    [forwardedRef]
  );
  useEffect(() => {
    if (rootElement)
      return mount(rootElement, {
        currentMinWidth: currentMinWidthProp,
        currentMaxWidth: currentMaxWidthProp,
        flex: flexProp,
        id,
        minWidth: minWidthProp,
        maxWidth: maxWidthProp
      });
  }, [
    currentMinWidthProp,
    currentMaxWidthProp,
    flexProp,
    id,
    minWidthProp,
    maxWidthProp,
    mount,
    rootElement
  ]);
  const handleCollapse = useCallback(() => {
    rootElement && collapse(rootElement);
  }, [collapse, rootElement]), handleExpand = useCallback(() => {
    rootElement && expand(rootElement);
  }, [expand, rootElement]), contextValue = useMemo(
    () => ({
      collapse: handleCollapse,
      collapsed: layoutCollapsed ? !1 : collapsed,
      expand: handleExpand,
      index: paneIndex,
      isLast,
      rootElement
    }),
    [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]
  ), minWidth = useMemo(() => {
    if (!layoutCollapsed)
      return collapsed ? PANE_COLLAPSED_WIDTH : currentMinWidth === 0 || isLast ? minWidthProp || PANE_DEFAULT_MIN_WIDTH : currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]), maxWidth = useMemo(() => {
    if (collapsed) return PANE_COLLAPSED_WIDTH;
    if (!(layoutCollapsed && isLast))
      return isLast ? maxWidthProp ? currentMaxWidth != null ? currentMaxWidth : maxWidthProp : void 0 : currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]), hidden = layoutCollapsed && !isLast, divider = useMemo(
    () => !isLast && !layoutCollapsed && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneResizer", children: /* @__PURE__ */ jsx(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }),
    [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]
  ), style = useMemo(
    () => ({
      flex,
      minWidth,
      maxWidth: maxWidth === 1 / 0 ? void 0 : maxWidth
    }),
    [flex, minWidth, maxWidth]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "pane", children: /* @__PURE__ */ jsx(PaneContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsx(IsLastPaneProvider, { isLastPane: isLast, children: /* @__PURE__ */ jsxs(
      Root$a,
      {
        "data-testid": "pane",
        "data-ui": "Pane",
        tone: "inherit",
        hidden,
        id,
        overflow: layoutCollapsed ? void 0 : "hidden",
        ...restProps,
        "data-pane-collapsed": collapsed ? "" : void 0,
        "data-pane-index": paneIndex,
        "data-pane-selected": selected ? "" : void 0,
        ref: setRef,
        style,
        children: [
          PANE_DEBUG,
          /* @__PURE__ */ jsx(BoundaryElementProvider, { element: rootElement, children: !hidden && /* @__PURE__ */ jsx(Flex, { direction: "column", height: "fill", children }) })
        ]
      }
    ) }) }) }),
    divider
  ] });
}), Root$9 = styled(Card)`
  position: relative;
  outline: none;
`;
Root$9.displayName = "PaneContent__root";
function usePane() {
  const pane2 = useContext(PaneContext);
  if (!pane2)
    throw new Error("Pane: missing context value");
  return pane2;
}
const PaneContent = forwardRef(function(props, ref) {
  const { as, children, overflow, padding, ...restProps } = props, { collapsed } = usePane(), { collapsed: layoutCollapsed } = usePaneLayout();
  return /* @__PURE__ */ jsx(
    Root$9,
    {
      "data-testid": "pane-content",
      forwardedAs: as,
      ...restProps,
      flex: 1,
      hidden: collapsed,
      overflow: layoutCollapsed ? void 0 : overflow,
      padding,
      ref,
      tone: "inherit",
      children
    }
  );
}), MENU_GROUP_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "left-start",
  portal: !0
};
function PaneMenuButtonItem(props) {
  const { disabled, isAfterGroup, node } = props, getI18nText = useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider")
    return /* @__PURE__ */ jsx(MenuDivider, {});
  const { title } = getI18nText(node);
  return node.type === "group" ? node.children.length === 0 ? null : node.expanded ? /* @__PURE__ */ jsxs(Fragment, { children: [
    isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}),
    node.children.map((child, childIndex) => {
      var _a;
      return /* @__PURE__ */ jsx(
        PaneMenuButtonItem,
        {
          disabled: disabled || !!node.disabled,
          isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
          node: child
        },
        child.key
      );
    })
  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
    isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}),
    /* @__PURE__ */ jsx(
      MenuGroup,
      {
        disabled,
        icon: node.icon,
        popover: MENU_GROUP_POPOVER_PROPS,
        text: title,
        children: node.children.map((child, childIndex) => {
          var _a;
          return /* @__PURE__ */ jsx(
            PaneMenuButtonItem,
            {
              disabled: disabled || !!node.disabled,
              isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
              node: child
            },
            child.key
          );
        })
      }
    )
  ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
    isAfterGroup && /* @__PURE__ */ jsx(MenuDivider, {}),
    /* @__PURE__ */ jsx(PaneContextMenuItemResolver, { disabled, node })
  ] });
}
function PaneContextMenuItemResolver(props) {
  const { node } = props;
  return node.intent ? /* @__PURE__ */ jsx(PaneContextIntentMenuItem, { ...props, intent: node.intent }) : /* @__PURE__ */ jsx(PaneContextMenuItem, { ...props });
}
function PaneContextMenuItem(props) {
  var _a;
  const { disabled, node } = props, tooltipContent = typeof node.disabled == "object" && /* @__PURE__ */ jsx(Text, { size: 1, children: node.disabled.reason }), { title } = useI18nText(node);
  return /* @__PURE__ */ jsx(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: /* @__PURE__ */ jsx(
    MenuItem,
    {
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      iconRight: node.iconRight || node.selected && CheckmarkIcon,
      onClick: node.onAction,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
function PaneContextIntentMenuItem(props) {
  var _a;
  const { disabled, intent, node } = props, tooltipContent = typeof node.disabled == "object" && /* @__PURE__ */ jsx(Text, { size: 1, children: node.disabled.reason }), intentLink = useIntentLink({ intent: intent.type, params: intent.params }), handleClick = useCallback(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { title } = useI18nText(node);
  return /* @__PURE__ */ jsx(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: /* @__PURE__ */ jsx(
    MenuItem,
    {
      as: "a",
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      iconRight: node.selected ? CheckmarkIcon : void 0,
      onClick: handleClick,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
const CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
};
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone));
}
function PaneContextMenuButton(props) {
  const { nodes, actionsNodes } = props, id = useId(), hasCritical = nodesHasTone(nodes, "critical"), hasCaution = nodesHasTone(nodes, "caution");
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(
        ContextMenuButton,
        {
          tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0,
          "data-testid": "pane-context-menu-button"
        }
      ),
      id,
      menu: /* @__PURE__ */ jsxs(Menu, { children: [
        actionsNodes && /* @__PURE__ */ jsxs(Fragment, { children: [
          actionsNodes,
          /* @__PURE__ */ jsx(MenuDivider, {})
        ] }),
        nodes.map((node, nodeIndex) => {
          var _a;
          const isAfterGroup = ((_a = nodes[nodeIndex - 1]) == null ? void 0 : _a.type) === "group";
          return /* @__PURE__ */ jsx(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
        })
      ] }),
      popover: CONTEXT_MENU_POPOVER_PROPS
    }
  );
}
const Root$8 = styled(Layer)`
  position: sticky;
  bottom: 0;

  &:before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -1px;
    border-bottom: 1px solid var(--card-border-color);
  }
`, RootCard = styled(Card)`
  padding-bottom: env(safe-area-inset-bottom);
`, PaneFooter = forwardRef(function(props, ref) {
  const { children, padding } = props, { collapsed } = usePane();
  return /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(Root$8, { "data-testid": "pane-footer", hidden: collapsed, ref, children: /* @__PURE__ */ jsx(RootCard, { tone: "inherit", children: /* @__PURE__ */ jsx(Box, { padding, children }) }) }) });
}), Root$7 = styled(Layer)(({ $border }) => css`
    line-height: 0;
    position: sticky;
    top: 0;

    &:not([data-collapsed]):after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      border-bottom: 1px solid ${$border ? "var(--card-border-color)" : "transparent"};
      opacity: 1;
    }
  `), Layout = styled(Flex)`
  transform-origin: calc(51px / 2);

  [data-collapsed] > div > & {
    transform: rotate(90deg);
  }
`, TitleCard = styled(Card)(({ theme }) => {
  const { fg, bg } = theme.sanity.color.card.enabled;
  return css`
    background-color: ${bg};

    [data-ui='Text'] {
      color: ${fg};
    }
  `;
}), TitleTextSkeleton = styled(TextSkeleton)`
  width: 66%;
  max-width: 175px;
`, TitleText = styled(Text)`
  cursor: default;
  outline: none;
`, TabsBox = styled(Box)(({ theme }) => {
  const { color, space } = theme.sanity;
  return css`
    overflow: hidden;
    overflow: clip;
    position: relative;

    & > div {
      white-space: nowrap;
      overflow: auto;
      /* Hide scrollbars */
      scrollbar-width: none;
      &::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
    }

    /* right padding */
    & > div:after {
      content: '';
      display: inline-block;
      top: 0;
      right: 0;
      bottom: 0;
      width: ${space[3]}px;
      height: 1px;
    }

    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */
    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to right, ${rgba(color.base.bg, 0)}, var(--card-bg-color));
      width: ${space[3]}px;
      pointer-events: none;
    }
  `;
}), PaneHeader$1 = forwardRef(function(props, ref) {
  const { actions, backButton, border, contentAfter, loading, subActions, tabs, tabIndex, title } = props, { collapse, collapsed, expand, rootElement: paneElement } = usePane(), paneRect = useElementRect(paneElement || null), layoutStyle = useMemo(
    () => ({
      width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0
    }),
    [collapsed, paneRect]
  ), handleTitleClick = useCallback(() => {
    collapsed || collapse();
  }, [collapse, collapsed]), handleLayoutClick = useCallback(() => {
    collapsed && expand();
  }, [collapsed, expand]);
  return /* @__PURE__ */ jsx(LayerProvider, { zOffset: 100, children: /* @__PURE__ */ jsx(
    Root$7,
    {
      $border: border,
      "data-collapsed": collapsed ? "" : void 0,
      "data-testid": "pane-header",
      ref,
      children: /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneHeader", children: /* @__PURE__ */ jsxs(Card, { "data-collapsed": collapsed ? "" : void 0, tone: "inherit", children: [
        /* @__PURE__ */ jsxs(
          Layout,
          {
            gap: 1,
            onClick: handleLayoutClick,
            padding: 3,
            paddingBottom: collapsed ? 3 : 2,
            sizing: "border",
            style: layoutStyle,
            children: [
              backButton && /* @__PURE__ */ jsx(Box, { flex: "none", children: backButton }),
              /* @__PURE__ */ jsxs(
                TitleCard,
                {
                  __unstable_focusRing: !0,
                  flex: 1,
                  forwardedAs: "button",
                  onClick: handleTitleClick,
                  paddingLeft: backButton ? 1 : 2,
                  padding: 2,
                  tabIndex,
                  children: [
                    loading && /* @__PURE__ */ jsx(TitleTextSkeleton, { animated: !0, radius: 1, size: 1 }),
                    !loading && /* @__PURE__ */ jsx(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title })
                  ]
                }
              ),
              actions && /* @__PURE__ */ jsx(Flex, { align: "center", hidden: collapsed, children: /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) })
            ]
          }
        ),
        !!(!collapsed && (tabs || subActions)) && /* @__PURE__ */ jsxs(
          Flex,
          {
            align: "center",
            hidden: collapsed,
            overflow: "auto",
            paddingBottom: 3,
            paddingX: 3,
            children: [
              /* @__PURE__ */ jsx(TabsBox, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }),
              subActions && subActions
            ]
          }
        ),
        !collapsed && contentAfter && contentAfter
      ] }) })
    }
  ) });
});
function getDisabledReason$1(node) {
  var _a;
  if (!node.disabled)
    return { disabledReason: void 0, ariaLabel: void 0, isDisabled: !1 };
  const disabledReason = typeof node.disabled == "object" ? node.disabled.reason : void 0, ariaLabel = typeof node.disabled == "object" && typeof ((_a = node.disabled) == null ? void 0 : _a.reason) == "string" ? node.disabled.reason : "This is disabled";
  return { disabledReason, ariaLabel, isDisabled: !!node.disabled };
}
function PaneHeaderActionButton(props) {
  const { node } = props;
  return node.type === "item" ? /* @__PURE__ */ jsx(PaneHeaderMenuItemActionButton, { node }) : node.type === "group" ? /* @__PURE__ */ jsx(PaneHeaderMenuGroupActionButton, { node }) : (console.warn('unknown menu node (expected `type: "item" | "group"`):', node), null);
}
function PaneHeaderMenuItemActionButton(props) {
  const { node } = props, { title } = useI18nText(node), { t } = useTranslation();
  if (node.intent)
    return /* @__PURE__ */ jsx(PaneHeaderActionIntentButton, { ...props, intent: node.intent });
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return /* @__PURE__ */ jsx(
    StatusButton,
    {
      disabled: isDisabled,
      icon: node.icon,
      onClick: node.onAction,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel || title || t("status-button.aria-label"),
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : title
      }
    }
  );
}
function PaneHeaderActionIntentButton(props) {
  const { intent, node } = props, intentLink = useIntentLink({ intent: intent.type, params: intent.params }), { t } = useTranslation(), handleClick = useCallback(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return /* @__PURE__ */ jsx(
    StatusButton,
    {
      forwardedAs: "a",
      disabled: isDisabled,
      href: intentLink.href,
      icon: node.icon,
      onClick: handleClick,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel || node.title || t("status-button.aria-label"),
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : node.title,
        placement: "bottom",
        portal: !0
      }
    }
  );
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a;
  const { node } = props, { title } = useI18nText(node);
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(
        Button,
        {
          disabled: !!node.disabled,
          icon: (_a = node.icon) != null ? _a : UnknownIcon,
          label: title,
          mode: "bleed",
          tooltipProps: { content: node.title, portal: !0 }
        }
      ),
      id: useId(),
      menu: /* @__PURE__ */ jsx(Menu, { children: node.children.map((child, idx) => {
        var _a2;
        return /* @__PURE__ */ jsx(
          PaneMenuButtonItem,
          {
            disabled: !!node.disabled,
            isAfterGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group",
            node: child
          },
          child.key
        );
      }) })
    }
  );
}
const Root$6 = styled(Card)`
  transition: opacity 200ms;
  position: relative;
  z-index: 1;
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  opacity: 0;

  &:not([hidden]) {
    display: flex;
  }

  &:not([data-collapsed]) {
    overflow: auto;
  }

  &[data-mounted] {
    opacity: 1;
  }

  &[data-resizing] {
    pointer-events: none;
  }
`;
function _calcPaneResize(cache, left, right, deltaX) {
  var _a, _b;
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  }, leftMinWidth = (_a = left.minWidth) != null ? _a : PANE_DEFAULT_MIN_WIDTH, rightMinWidth = (_b = right.minWidth) != null ? _b : PANE_DEFAULT_MIN_WIDTH, leftMaxWidth = Math.min(left.maxWidth || 1 / 0, sum.width - rightMinWidth), rightMaxWidth = Math.min(right.maxWidth || 1 / 0, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  minDeltaX < rightMinDeltaX && (minDeltaX = rightMinDeltaX);
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  maxDeltaX > leftMaxDeltaX && (maxDeltaX = leftMaxDeltaX);
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX), leftW = cache.left.width + _deltaX, rightW = cache.right.width - _deltaX, leftFlex = leftW / sum.width * sum.flex, rightFlex = rightW / sum.width * sum.flex;
  return { leftFlex, leftW, rightFlex, rightW };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const index = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements)
    map2.set(element, _getDOMPath(rootElement, element));
  const _sortByElementPath = (a, b) => {
    const _a = map2.get(a) || EMPTY_PATH, _b = map2.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [], elements = [], optionsMap = /* @__PURE__ */ new WeakMap(), userCollapsedElementSet = /* @__PURE__ */ new Set(), cache = {};
  let rootElement = null, rootWidth = 0, expandedElement = null, resizeDataMap = /* @__PURE__ */ new Map(), resizing = !1;
  function collapse(element) {
    userCollapsedElementSet.add(element), expandedElement === element && (expandedElement = null), _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element), expandedElement = element, _notifyObservers();
  }
  function mount(element, options) {
    return optionsMap.set(element, { ...options, original: options }), elements.push(element), rootElement && _sortElements(rootElement, elements), expand(element), () => {
      const idx = elements.indexOf(element);
      idx > -1 && elements.splice(idx, 1), optionsMap.delete(element), _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a, _b, _c, _d;
    const leftIndex = elements.indexOf(leftElement), leftOptions = optionsMap.get(leftElement);
    if (!leftOptions) return;
    const rightElement = elements[leftIndex + 1], rightOptions = optionsMap.get(rightElement);
    if (rightOptions) {
      if (type === "start" && (resizing = !0, cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      }, cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      }, _notifyObservers()), type === "move" && cache.left && cache.right) {
        resizeDataMap = /* @__PURE__ */ new Map();
        const { leftW, rightW, leftFlex, rightFlex } = _calcPaneResize(
          cache,
          leftOptions,
          rightOptions,
          deltaX
        );
        resizeDataMap.set(leftElement, { flex: leftFlex, width: leftW }), resizeDataMap.set(rightElement, { flex: rightFlex, width: rightW }), _notifyObservers();
      }
      if (type === "end") {
        resizing = !1;
        const leftResizeData = resizeDataMap.get(leftElement), rightResizeData = resizeDataMap.get(rightElement);
        optionsMap.set(leftElement, {
          ...leftOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_a = leftOptions.maxWidth) != null ? _a : 1 / 0,
          flex: (_b = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b : leftOptions.flex
        }), optionsMap.set(rightElement, {
          ...rightOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_c = leftOptions.maxWidth) != null ? _c : 1 / 0,
          flex: (_d = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d : rightOptions.flex
        }), resizeDataMap = /* @__PURE__ */ new Map(), delete cache.left, delete cache.right, _notifyObservers();
      }
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth, _notifyObservers();
  }
  function subscribe(observer) {
    return observers.push(observer), () => {
      const idx = observers.push(observer);
      idx > -1 && observers.splice(idx, 1);
    };
  }
  return { collapse, expand, mount, resize, setRootElement, setRootWidth, subscribe };
  function _notifyObservers() {
    var _a, _b, _c, _d;
    if (!rootWidth) return;
    const _elements = [];
    for (const element of elements)
      element !== expandedElement && _elements.unshift(element);
    expandedElement && _elements.unshift(expandedElement);
    const dataMap = /* @__PURE__ */ new WeakMap(), len = _elements.length, lastElement = _elements[0], collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options)
        continue;
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH, isLast = element === lastElement, userCollapsed = userCollapsedElementSet.has(element), sizeCollapsed = minWidth > remaingWidth, collapsed = isLast ? !1 : userCollapsed || sizeCollapsed, resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: (_a = resizeData == null ? void 0 : resizeData.width) != null ? _a : options.currentMinWidth,
        currentMaxWidth: (_b = resizeData == null ? void 0 : resizeData.width) != null ? _b : options.currentMaxWidth,
        flex: (_d = (_c = resizeData == null ? void 0 : resizeData.flex) != null ? _c : options.flex) != null ? _d : 1
      }), collapsed ? remaingWidth -= PANE_COLLAPSED_WIDTH : remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      data && panes.push(data);
    }
    for (const observer of observers)
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
  }
}
function PaneLayout(props) {
  const { children, minWidth, onCollapse, onExpand, ...restProps } = props, controller = useMemo(() => createPaneLayoutController(), []), [rootElement, setRootElement] = useState(null), rootRect = useElementRect(rootElement), width = (rootRect == null ? void 0 : rootRect.width) || 0, collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth, [state2, setState] = useState({
    expandedElement: null,
    panes: [],
    resizing: !1
  });
  useEffect(() => controller.setRootElement(rootElement), [controller, rootElement]), useEffect(() => controller.setRootWidth(width), [controller, width]), useEffect(() => controller.subscribe(setState), [controller]), useEffect(() => {
    collapsed !== void 0 && (collapsed && onCollapse && onCollapse(), !collapsed && onExpand && onExpand());
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = useMemo(
    () => ({
      collapse: controller.collapse,
      collapsed,
      expand: controller.expand,
      expandedElement: state2.expandedElement,
      mount: controller.mount,
      panes: state2.panes,
      resize: controller.resize,
      resizing: state2.resizing
    }),
    [collapsed, controller, state2.expandedElement, state2.panes, state2.resizing]
  );
  return /* @__PURE__ */ jsx(PaneLayoutContext.Provider, { value: paneLayout, children: /* @__PURE__ */ jsx(
    Root$6,
    {
      "data-ui": "PaneLayout",
      ...restProps,
      "data-collapsed": collapsed ? "" : void 0,
      "data-resizing": state2.resizing ? "" : void 0,
      "data-mounted": width ? "" : void 0,
      ref: setRootElement,
      children
    }
  ) });
}
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
const isNotMenuNodeButton = negate(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a, _b;
  const { fieldActions = [], menuItems, menuItemGroups } = params, nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, `${i}-${a.type}`));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups)
    groups.find((g) => g.key === itemGroup.id) || groups.push({
      type: "group",
      key: itemGroup.id,
      children: [],
      expanded: !0,
      renderAsButton: !1,
      title: itemGroup.title,
      i18n: itemGroup.i18n
    });
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    item.group && !group && (group = {
      type: "group",
      key: item.group,
      expanded: !0,
      icon: item.icon,
      title: item.group,
      children: [],
      renderAsButton: !1
    }, groups.push(group)), group ? group.children.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_a = item.showAsAction) != null ? _a : !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    }) : ungroupedItems.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_b = item.showAsAction) != null ? _b : !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    });
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a, _b, _c;
  return a.type === "divider" ? {
    type: "divider",
    key
  } : a.type === "group" ? {
    type: "group",
    key,
    children: a.children.map(
      (child, childIdx) => mapFieldActionToPaneMenuNode(child, `${key}-${childIdx}-${child.type}`)
    ),
    disabled: a.disabled,
    expanded: (_a = a.expanded) != null ? _a : !0,
    icon: a.icon,
    title: a.title,
    i18n: a.i18n,
    renderAsButton: (_b = a.renderAsButton) != null ? _b : !1
  } : {
    type: "item",
    key,
    intent: a.intent,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: (_c = a.renderAsButton) != null ? _c : !1,
    selected: a.selected,
    title: a.title,
    i18n: a.i18n,
    tone: a.tone
  };
}
const IntentButton = forwardRef(function(props, ref) {
  const { intent, ...restProps } = props, Link = useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      forwardRef(function(linkProps, linkRef) {
        return /* @__PURE__ */ jsx(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef });
      })
    ),
    [intent]
  );
  return props.disabled ? /* @__PURE__ */ jsx(Button, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : /* @__PURE__ */ jsx(Button, { ...restProps, as: Link, "data-as": "a", ref });
});
function InsufficientPermissionsMessageTooltip({
  reveal,
  context,
  loading,
  children
}) {
  const currentUser = useCurrentUser(), { t } = useTranslation(structureLocaleNamespace);
  return reveal ? /* @__PURE__ */ jsx(
    Tooltip,
    {
      content: loading ? t("insufficient-permissions-message-tooltip.loading-text") : /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context, currentUser }),
      portal: !0,
      children: /* @__PURE__ */ jsx("div", { children })
    }
  ) : /* @__PURE__ */ jsx(Fragment, { children });
}
const POPOVER_PROPS = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
}, getIntent = (schema, templates, item) => {
  var _a;
  const typeName = (_a = templates.find((t) => t.id === item.templateId)) == null ? void 0 : _a.schemaType;
  if (!typeName) return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams
  };
};
function PaneHeaderCreateButton({ templateItems }) {
  const schema = useSchema(), templates = useTemplates(), { t } = useTranslation(structureLocaleNamespace), getI18nText = useGetI18nText([...templateItems, ...templates]), [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  }), nothingGranted = useMemo(() => !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every((permission) => !permission.granted)), [isTemplatePermissionsLoading, templatePermissions]), permissionsById = useMemo(() => templatePermissions ? templatePermissions.reduce(
    (acc, permission) => (acc[permission.id] = permission, acc),
    {}
  ) : {}, [templatePermissions]);
  if (nothingGranted)
    return /* @__PURE__ */ jsx(
      InsufficientPermissionsMessageTooltip,
      {
        context: "create-document-type",
        reveal: !0,
        loading: isTemplatePermissionsLoading,
        children: /* @__PURE__ */ jsx(
          Button,
          {
            "aria-label": t("pane-header.disabled-created-button.aria-label"),
            icon: AddIcon,
            "data-testid": "action-intent-button",
            disabled: !0,
            mode: "bleed",
            tooltipProps: null
          }
        )
      }
    );
  if (templateItems.length === 1) {
    const firstItem = templateItems[0], permissions = permissionsById[firstItem.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema, templates, firstItem);
    return intent ? /* @__PURE__ */ jsx(
      InsufficientPermissionsMessageTooltip,
      {
        reveal: disabled,
        loading: isTemplatePermissionsLoading,
        context: "create-document-type",
        children: /* @__PURE__ */ jsx(
          IntentButton,
          {
            "aria-label": getI18nText(firstItem).title,
            icon: firstItem.icon || AddIcon,
            intent,
            mode: "bleed",
            disabled,
            "data-testid": "action-intent-button",
            tooltipProps: disabled ? null : { content: t("pane-header.create-new-button.tooltip") }
          }
        )
      }
    ) : null;
  }
  return /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(
        Button,
        {
          icon: AddIcon,
          mode: "bleed",
          "data-testid": "multi-action-intent-button",
          tooltipProps: { content: t("pane-header.create-new-button.tooltip") }
        }
      ),
      id: "create-menu",
      menu: /* @__PURE__ */ jsx(Menu, { children: templateItems.map((item, itemIndex) => {
        const permissions = permissionsById[item.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema, templates, item), template = templates.find((i) => i.id === item.templateId);
        if (!template || !intent) return null;
        const Link = forwardRef(
          (linkProps, linkRef) => disabled ? /* @__PURE__ */ jsx("button", { type: "button", disabled: !0, ...linkProps, ref: linkRef }) : /* @__PURE__ */ jsx(
            IntentLink,
            {
              ...linkProps,
              intent: intent.type,
              params: intent.params,
              ref: linkRef
            }
          )
        );
        Link.displayName = "Link";
        const { title } = getI18nText({
          ...item,
          // replace the title with the template title
          title: item.title || getI18nText(template).title
        });
        return /* @__PURE__ */ jsx(
          InsufficientPermissionsMessageTooltip,
          {
            context: "create-document-type",
            reveal: disabled,
            loading: isTemplatePermissionsLoading,
            children: /* @__PURE__ */ jsx(
              MenuItem,
              {
                as: Link,
                "data-as": disabled ? "button" : "a",
                text: title,
                "aria-label": disabled ? t("pane-header.disabled-created-button.aria-label") : title,
                disabled,
                "data-testid": `action-intent-button-${itemIndex}`
              }
            )
          },
          item.id
        );
      }) }),
      popover: POPOVER_PROPS
    }
  );
}
function isNonNullable(value) {
  return value != null;
}
const hashObject = (value) => {
  const sortObject = (v) => typeof v != "object" || !v ? v : Array.isArray(v) ? v.map(sortObject) : Object.entries(v).sort(([keyA], [keyB]) => keyA.localeCompare(keyB, "en"));
  return JSON.stringify(sortObject(((v) => JSON.parse(JSON.stringify(v)))(value)));
}, PaneHeaderActions = memo(function(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$3,
    menuItems = EMPTY_ARRAY$3,
    menuItemGroups = EMPTY_ARRAY$3,
    actionHandlers = EMPTY_OBJECT
  } = props, templates = useTemplates(), handleAction = useCallback(
    (item) => {
      if (typeof item.action == "string" && !(item.action in actionHandlers))
        return console.warn("No handler for action:", item.action), !1;
      const handler = (
        // eslint-disable-next-line no-nested-ternary
        typeof item.action == "function" ? item.action : typeof item.action == "string" ? actionHandlers[item.action] : null
      );
      return handler ? (handler(item.params), !0) : !1;
    },
    [actionHandlers]
  ), menuNodes = useMemo(
    () => resolveMenuNodes({
      actionHandler: handleAction,
      menuItemGroups,
      menuItems: menuItems.filter((item) => {
        var _a;
        return ((_a = item.intent) == null ? void 0 : _a.type) !== "create";
      })
    }),
    [handleAction, menuItemGroups, menuItems]
  ), actionNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), initialValueTemplateItemFromMenuItems = useMemo(() => menuItems.map((item, menuItemIndex) => {
    var _a;
    if (((_a = item.intent) == null ? void 0 : _a.type) !== "create") return null;
    const { params } = item.intent;
    if (!params) return null;
    const intentParams = Array.isArray(params) ? params[0] : params, templateParams = Array.isArray(params) ? params[1] : void 0, templateId = intentParams.template || intentParams.type;
    if (!templateId) return null;
    const template = templates.find((t) => t.id === templateId);
    if (!template) return null;
    const initialDocumentId = intentParams.id;
    return {
      item,
      template,
      templateParams,
      menuItemIndex,
      initialDocumentId
    };
  }).filter(isNonNullable).map(({ initialDocumentId, item, template, menuItemIndex, templateParams }) => ({
    id: `menuItem${menuItemIndex}`,
    initialDocumentId,
    templateId: template.id,
    type: "initialValueTemplateItem",
    title: item.title || template.title,
    i18n: item.i18n || template.i18n,
    icon: item.icon,
    description: template.description,
    parameters: templateParams,
    schemaType: template.schemaType
  })), [menuItems, templates]), combinedInitialValueTemplates = useMemo(() => uniqBy(
    [...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure],
    (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters])
  ), [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /* @__PURE__ */ jsxs(Flex, { gap: 1, children: [
    combinedInitialValueTemplates.length > 0 && /* @__PURE__ */ jsx(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }),
    actionNodes.map((node) => /* @__PURE__ */ jsx(PaneHeaderActionButton, { node }, node.key)),
    contextMenuNodes.length > 0 && /* @__PURE__ */ jsx(PaneContextMenuButton, { nodes: contextMenuNodes })
  ] });
});
function MissingSchemaType(props) {
  const { t } = useTranslation(structureLocaleNamespace), { layout, value } = props;
  return /* @__PURE__ */ jsx(
    SanityDefaultPreview,
    {
      title: /* @__PURE__ */ jsx("em", { children: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.title",
          components: { Code: "code" },
          values: { documentType: value._type }
        }
      ) }),
      subtitle: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.subtitle",
          components: { Code: "code" },
          values: { documentId: value._id }
        }
      ),
      media: () => /* @__PURE__ */ jsx(WarningOutlineIcon, {}),
      layout
    }
  );
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  return icon === !1 ? !1 : icon || schemaType && schemaType.icon || defaultIcon || !1;
}
function PaneItem(props) {
  const {
    icon,
    id,
    layout = "default",
    pressed,
    schemaType,
    selected,
    title,
    value,
    margin,
    marginBottom,
    marginTop
  } = props, schema = useSchema(), documentPreviewStore = useDocumentPreviewStore(), { ChildLink: ChildLink2 } = usePaneRouter(), documentPresence = useDocumentPresence(id), hasSchemaType = !!(schemaType && schemaType.name && schema.get(schemaType.name)), [clicked, setClicked] = useState(!1), preview = useMemo(() => value && isSanityDocument$1(value) ? !schemaType || !hasSchemaType ? /* @__PURE__ */ jsx(MissingSchemaType, { value }) : /* @__PURE__ */ jsx(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: getIconWithFallback(icon, schemaType, DocumentIcon),
      layout,
      schemaType,
      value,
      presence: documentPresence
    }
  ) : /* @__PURE__ */ jsx(
    SanityDefaultPreview,
    {
      status: /* @__PURE__ */ jsx(Box, { style: { opacity: 0.5 }, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsx(ChevronRightIcon, {}) }) }),
      icon: getIconWithFallback(icon, schemaType, FolderIcon),
      layout: "compact",
      title
    }
  ), [
    documentPreviewStore,
    hasSchemaType,
    icon,
    layout,
    schemaType,
    title,
    value,
    documentPresence
  ]), Link = useMemo(
    () => function(linkProps) {
      return /* @__PURE__ */ jsx(ChildLink2, { ...linkProps, childId: id });
    },
    [ChildLink2, id]
  ), handleClick = useCallback((e) => {
    if (e.metaKey) {
      setClicked(!1);
      return;
    }
    setClicked(!0);
  }, []);
  return useEffect(() => setClicked(!1), [selected]), /* @__PURE__ */ jsx(
    PreviewCard,
    {
      "data-testid": `pane-item-${title}`,
      __unstable_focusRing: !0,
      as: Link,
      "data-as": "a",
      margin,
      marginBottom,
      marginTop,
      onClick: handleClick,
      pressed,
      radius: 2,
      selected: selected || clicked,
      sizing: "border",
      tabIndex: -1,
      tone: "inherit",
      children: preview
    }
  );
}
const RenderActionCollectionState = (props) => {
  const { actions, children, actionProps, onActionComplete, group } = props;
  return /* @__PURE__ */ jsx(
    GetHookCollectionState,
    {
      onReset: onActionComplete,
      hooks: actions,
      args: actionProps,
      group,
      children
    }
  );
}, RenderBadgeCollectionState = (props) => {
  const { badges, children, badgeProps, ...rest } = props;
  return /* @__PURE__ */ jsx(GetHookCollectionState, { ...rest, hooks: badges, args: badgeProps, children });
};
function ErrorPane(props) {
  const {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title = "Error",
    tone = "critical"
  } = props;
  return /* @__PURE__ */ jsxs(
    Pane,
    {
      currentMinWidth,
      flex,
      id: paneKey,
      minWidth,
      tone,
      children: [
        /* @__PURE__ */ jsx(PaneHeader$1, { title }),
        /* @__PURE__ */ jsx(PaneContent, { overflow: "auto", children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children }) })
      ]
    }
  );
}
function getWaitMessages(path) {
  const thresholds = [
    { ms: 300, messageKey: "panes.resolving.default-message" },
    { ms: 5e3, messageKey: "panes.resolving.slow-resolve-message" }
  ];
  if (isDev) {
    const message = [
      "Check console for errors?",
      "Is your observable/promise resolving?",
      path.length > 0 ? `Structure path: ${path.join(" \u279D ")}` : ""
    ];
    thresholds.push({
      ms: 1e4,
      message: message.join(`
`)
    });
  }
  const src = of(null);
  return merge(
    ...thresholds.map(
      (threshold) => src.pipe(
        mapTo(
          "messageKey" in threshold ? { messageKey: threshold.messageKey } : { message: threshold.message }
        ),
        delay(threshold.ms)
      )
    )
  );
}
const DEFAULT_MESSAGE_KEY = "panes.resolving.default-message", Content$1 = styled(Flex)`
  opacity: 0;
  transition: opacity 200ms;

  &[data-mounted] {
    opacity: 1;
  }
`, LoadingPane = memo((props) => {
  const {
    delay: delay2 = 300,
    flex,
    message: messageProp = getWaitMessages,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props, { t } = useTranslation(structureLocaleNamespace), resolvedMessage = useMemo(() => typeof messageProp == "function" ? messageProp(path ? path.split(";") : []) : messageProp, [messageProp, path]), [currentMessage, setCurrentMessage] = useState(() => typeof resolvedMessage == "string" ? resolvedMessage : t(DEFAULT_MESSAGE_KEY));
  useEffect(() => {
    if (typeof resolvedMessage != "object" || typeof resolvedMessage.subscribe != "function") return;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, [resolvedMessage, t]);
  const [contentElement, setContentElement] = useState(null), [mounted, setMounted] = useState(!1);
  return useEffect(() => {
    if (contentElement)
      return _raf2(() => setMounted(!0));
  }, [contentElement]), /* @__PURE__ */ jsx(Pane, { flex, id: paneKey, minWidth, selected, tone, children: /* @__PURE__ */ jsx(PaneContent, { children: /* @__PURE__ */ jsx(
    Content$1,
    {
      align: "center",
      "data-mounted": mounted ? "" : void 0,
      direction: "column",
      height: "fill",
      justify: "center",
      ref: setContentElement,
      children: /* @__PURE__ */ jsx(LoadingBlock, { showText: !0, title: title || currentMessage })
    }
  ) }) });
});
LoadingPane.displayName = "LoadingPane";
function useDocumentPane() {
  const documentPane = useContext(DocumentPaneContext);
  if (!documentPane)
    throw new Error("DocumentPane: missing context value");
  return documentPane;
}
function CommentsWrapper(props) {
  const { children, documentId, documentType } = props;
  return /* @__PURE__ */ jsx(CommentsEnabledProvider, { documentId, documentType, children: /* @__PURE__ */ jsx(CommentsProviderWrapper, { documentId, documentType, children }) });
}
function CommentsProviderWrapper(props) {
  const { children, documentId, documentType } = props, { enabled } = useCommentsEnabled(), { connectionState, onPathOpen, inspector, openInspector } = useDocumentPane(), { params, setParams, createPathWithParams } = usePaneRouter(), selectedCommentId = params == null ? void 0 : params.comment, paramsRef = useRef(params);
  useLayoutEffect(() => {
    paramsRef.current = params;
  }, [params]);
  const getCommentLink = useCallback(
    (commentId) => {
      const path = createPathWithParams({
        ...paramsRef.current,
        comment: commentId,
        inspect: COMMENTS_INSPECTOR_NAME
      });
      return `${window.location.origin}${path}`;
    },
    [createPathWithParams]
  ), handleClearSelectedComment = useCallback(() => {
    setParams({ ...paramsRef.current, comment: void 0 });
  }, [setParams]), handleOpenCommentsInspector = useCallback(() => {
    (inspector == null ? void 0 : inspector.name) !== COMMENTS_INSPECTOR_NAME && openInspector(COMMENTS_INSPECTOR_NAME);
  }, [inspector == null ? void 0 : inspector.name, openInspector]);
  return enabled ? /* @__PURE__ */ jsx(
    CommentsProvider,
    {
      documentId,
      documentType,
      getCommentLink,
      isCommentsOpen: (inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME,
      isConnecting: connectionState === "connecting",
      onClearSelectedComment: handleClearSelectedComment,
      onCommentsOpen: handleOpenCommentsInspector,
      onPathOpen,
      selectedCommentId,
      sortOrder: "desc",
      type: "field",
      children
    }
  ) : /* @__PURE__ */ jsx(Fragment, { children });
}
const _DEBUG = !1, EMPTY_PARAMS$2 = {}, LOADING_PANE = Symbol("LOADING_PANE"), DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
function useStructureTool() {
  const structureTool2 = useContext(StructureToolContext);
  if (!structureTool2) throw new Error("StructureTool: missing context value");
  return structureTool2;
}
const DOCUMENT_PANEL_MIN_WIDTH = 320, DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600, DOCUMENT_INSPECTOR_MIN_WIDTH = 320, DOCUMENT_INSPECTOR_MAX_WIDTH = 540, EMPTY_PARAMS$1 = {}, INSPECT_ACTION_PREFIX = "inspect:", DEFAULT_MENU_ITEM_GROUPS = [{ id: "inspectors" }, { id: "links" }], HISTORY_INSPECTOR_NAME = "sanity/structure/history", VALIDATION_INSPECTOR_NAME = "sanity/structure/validation", InspectorMenuItem = memo(function(props) {
  const { documentId, documentType, index, setMenuItem, useMenuItem: useMenuItem2 } = props, node = useUnique(
    useMenuItem2({
      documentId,
      documentType
    })
  );
  return useEffect(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]), /* @__PURE__ */ jsx(Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const { documentId, documentType, inspectors: inspectors2, onMenuItems } = props, len = inspectors2.length, lenRef = useRef(len), [menuItems, setMenuItems] = useState(
    () => Array.from(new Array(len))
  ), menuItemsRef = useRef(menuItems);
  useEffect(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = menuItemsRef.current[i];
      lenRef.current = len, setMenuItems(() => (menuItemsRef.current = newFieldActions, newFieldActions));
    }
  }, [len]);
  const setMenuItem = useCallback((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      return next[index] = node, menuItemsRef.current = next, next;
    });
  }, []);
  return useEffect(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]), /* @__PURE__ */ jsx(Fragment, { children: inspectors2.map(
    (inspector, inspectorIndex) => inspector.useMenuItem && /* @__PURE__ */ jsx(
      InspectorMenuItem,
      {
        documentId,
        documentType,
        index: inspectorIndex,
        setMenuItem,
        useMenuItem: inspector.useMenuItem
      },
      inspector.name
    )
  ) });
}
function useDocumentTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  });
  return connectionState === "connecting" ? { error: void 0, title: void 0 } : title ? { error: void 0, title } : documentValue ? error ? { error: `Error: ${error.message}`, title: void 0 } : { error: void 0, title: value == null ? void 0 : value.title } : { error: void 0, title: `New ${(schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)}` };
}
const IGNORE_OPS = ["patch", "commit"], DocumentOperationResults = memo(function() {
  const { push: pushToast } = useToast(), { documentId, documentType } = useDocumentPane(), { title } = useDocumentTitle(), event = useDocumentOperationEvent(documentId, documentType), prevEvent = useRef(event), paneRouter = usePaneRouter(), { t } = useTranslation(structureLocaleNamespace), documentTitleBase = title || t("panes.document-operation-results.operation-undefined-title"), documentTitle = documentTitleBase.length > 25 ? `${documentTitleBase.slice(0, 25)}...` : documentTitleBase;
  return useEffect(() => {
    if (!event || event === prevEvent.current) return;
    let cleanupId;
    return event.type === "error" && pushToast({
      closable: !0,
      duration: 3e4,
      // 30s
      status: "error",
      title: t("panes.document-operation-results.operation-error", { context: event.op }),
      description: /* @__PURE__ */ jsxs("details", { children: [
        /* @__PURE__ */ jsx("summary", { children: t("panes.document-operation-results.error.summary.title") }),
        event.error.message
      ] })
    }), event.type === "success" && !IGNORE_OPS.includes(event.op) && pushToast({
      closable: !0,
      status: "success",
      title: /* @__PURE__ */ jsx(
        Translate,
        {
          context: event.op,
          i18nKey: "panes.document-operation-results.operation-success",
          t,
          values: {
            title: documentTitle
          },
          components: {
            Strong: "strong"
          }
        }
      )
    }), event.type === "success" && event.op === "delete" && (cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0)), prevEvent.current = event, () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast, t, documentTitle]), null;
}), Root$5 = styled(Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
});
function DocumentInspectorHeader(props) {
  const { as: forwardedAs, children, closeButtonLabel, onClose, title, ...restProps } = props, { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsxs(Root$5, { ...restProps, as: forwardedAs, children: [
    /* @__PURE__ */ jsxs(Flex, { padding: 2, children: [
      /* @__PURE__ */ jsx(Box, { flex: 1, padding: 3, children: /* @__PURE__ */ jsx(Text, { as: "h1", size: 1, weight: "medium", children: title }) }),
      /* @__PURE__ */ jsx(Box, { flex: "none", padding: 1, children: /* @__PURE__ */ jsx(
        Button,
        {
          "aria-label": closeButtonLabel,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t("document-inspector.close-button.tooltip") }
        }
      ) })
    ] }),
    children
  ] });
}
const Root$4 = styled.div`
  position: absolute;
  top: 0;
  left: -4px;
  bottom: 0;
  width: 9px;
  z-index: 201;
  cursor: ew-resize;

  /* Border */
  & > span:nth-child(1) {
    display: block;
    border-left: 1px solid var(--card-border-color);
    position: absolute;
    top: 0;
    left: 4px;
    bottom: 0;
    transition: opacity 200ms;
  }

  /* Hover effect */
  & > span:nth-child(2) {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 9px;
    bottom: 0;
    background-color: var(--card-border-color);
    opacity: 0;
    transition: opacity 150ms;
  }

  @media (hover: hover) {
    &:hover > span:nth-child(2) {
      opacity: 0.2;
    }
  }
`;
function Resizer(props) {
  const { onResize, onResizeStart } = props, mouseXRef = useRef(0), handleMouseDown = useCallback(
    (event) => {
      event.preventDefault(), mouseXRef.current = event.pageX, onResizeStart();
      const handleMouseMove = (e) => {
        e.preventDefault(), onResize(e.pageX - mouseXRef.current);
      }, handleMouseUp = () => {
        window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [onResize, onResizeStart]
  );
  return /* @__PURE__ */ jsxs(Root$4, { onMouseDown: handleMouseDown, children: [
    /* @__PURE__ */ jsx("span", {}),
    /* @__PURE__ */ jsx("span", {})
  ] });
}
const Root$3 = styled(Box)`
  position: relative;
  flex: 1;
  padding-left: 1px;
`;
function Resizable(props) {
  const { as: forwardedAs, children, minWidth, maxWidth, ...restProps } = props, [element, setElement] = useState(null), elementWidthRef = useRef(), [targetWidth, setTargetWidth] = useState(), handleResizeStart = useCallback(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]), handleResize = useCallback(
    (deltaX) => {
      const w = elementWidthRef.current;
      w && setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
    },
    [minWidth, maxWidth]
  ), style = useMemo(
    () => targetWidth ? { flex: "none", width: targetWidth } : { minWidth, maxWidth },
    [minWidth, maxWidth, targetWidth]
  );
  return /* @__PURE__ */ jsxs(Root$3, { as: forwardedAs, ...restProps, ref: setElement, style, children: [
    children,
    /* @__PURE__ */ jsx(Resizer, { onResize: handleResize, onResizeStart: handleResizeStart })
  ] });
}
function DocumentInspectorPanel(props) {
  const { documentId, documentType, flex } = props, { collapsed } = usePane(), { closeInspector, inspector } = useDocumentPane(), { features } = useStructureTool(), handleClose = useCallback(() => {
    inspector && closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector) return null;
  const element = createElement(inspector.component, {
    onClose: handleClose,
    documentId,
    documentType
  });
  return features.resizablePanes ? /* @__PURE__ */ jsx(
    Resizable,
    {
      as: "aside",
      "data-ui": "DocumentInspectorPanel",
      flex,
      maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH,
      minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH,
      children: element
    }
  ) : /* @__PURE__ */ jsx(Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element });
}
const STRUCTURE_TOOL_NAMESPACE = "studio.structure-tool";
function useStructureToolSetting(namespace, key, defaultValue) {
  const keyValueStore = useKeyValueStore(), [value, setValue] = useState(defaultValue), keyValueStoreKey = [STRUCTURE_TOOL_NAMESPACE, namespace, key].filter(Boolean).join("."), settings = useMemo(() => keyValueStore.getKey(keyValueStoreKey), [keyValueStore, keyValueStoreKey]);
  useEffect(() => {
    const sub = settings.pipe(
      startWith(defaultValue),
      map((fetchedValue) => fetchedValue === null ? defaultValue : fetchedValue)
    ).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, keyValueStoreKey, settings]);
  const set = useCallback(
    (newValue) => {
      newValue !== value && (setValue(newValue), keyValueStore.setKey(keyValueStoreKey, newValue));
    },
    [keyValueStore, keyValueStoreKey, value]
  );
  return useMemo(() => [value, set], [set, value]);
}
const VIEW_MODE_PARSED = { id: "parsed", title: "document-inspector.view-mode.parsed" }, VIEW_MODE_RAW = { id: "raw", title: "document-inspector.view-mode.raw-json" }, VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW], lru = new LRU({ maxSize: 1e3 });
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  return cached === void 0 ? (lru.set(keyPath, Array.isArray(value) || isRecord(value)), isExpanded(keyPath, value)) : cached;
}
function toggleExpanded(event) {
  const { path } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges(), range.selectNodeContents(element), sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  event.keyCode === 65 && (event.metaKey || event.ctrlKey) && (event.preventDefault(), selectElement(event.currentTarget));
}
function isDocumentLike(value) {
  return isRecord(value) && isString$1(value._id) && isString$1(value._type);
}
const JSONInspectorWrapper = styled.div(({ theme }) => {
  const { color, fonts, space } = theme.sanity;
  return css`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${rem(space[3])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: '▸ ';
      margin-left: calc(0 - ${rem(space[4])} + 3px);
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: '▾ ';
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${rem(space[3])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color.syntax.string};
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: '↔';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
});
function Search(props) {
  const { onChange, query } = props, handleChange = useCallback(
    (event) => onChange(event.target.value),
    [onChange]
  ), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(
    TextInput,
    {
      icon: SearchIcon,
      onChange: handleChange,
      placeholder: t("document-inspector.search.placeholder"),
      radius: 2,
      value: query || ""
    }
  );
}
function InspectDialog(props) {
  const { value } = props, { onInspectClose, paneKey } = useDocumentPane(), dialogIdPrefix = `${paneKey}_inspect_`, [viewModeId, onViewModeChange] = useStructureToolSetting(
    "inspect-view-mode",
    null,
    "parsed"
  ), viewMode = VIEW_MODES.find((mode) => mode.id === viewModeId), setParsedViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]), setRawViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(
    Dialog,
    {
      bodyHeight: "fill",
      id: `${dialogIdPrefix}dialog`,
      header: isDocumentLike(value) ? /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "document-inspector.dialog.title",
          components: {
            DocumentTitle: () => /* @__PURE__ */ jsx("em", { children: /* @__PURE__ */ jsx(DocTitle, { document: value }) })
          }
        }
      ) : /* @__PURE__ */ jsx("em", { children: t("document-inspector.dialog.title-no-value") }),
      onClose: onInspectClose,
      onClickOutside: onInspectClose,
      padding: !1,
      width: 2,
      children: /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", children: [
        /* @__PURE__ */ jsx(
          Card,
          {
            padding: 3,
            paddingTop: 0,
            shadow: 1,
            style: { position: "sticky", bottom: 0, zIndex: 3 },
            children: /* @__PURE__ */ jsxs(TabList, { space: 1, children: [
              /* @__PURE__ */ jsx(
                Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_PARSED.id}`,
                  label: t(VIEW_MODE_PARSED.title),
                  onClick: setParsedViewMode,
                  selected: viewMode === VIEW_MODE_PARSED
                }
              ),
              /* @__PURE__ */ jsx(
                Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_RAW.id}`,
                  label: t(VIEW_MODE_RAW.title),
                  onClick: setRawViewMode,
                  selected: viewMode === VIEW_MODE_RAW
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ jsxs(
          TabPanel,
          {
            "aria-labelledby": `${dialogIdPrefix}tab-${viewModeId}`,
            flex: 1,
            id: `${dialogIdPrefix}tabpanel`,
            overflow: "auto",
            padding: 4,
            style: { outline: "none" },
            children: [
              viewMode === VIEW_MODE_PARSED && /* @__PURE__ */ jsx(JSONInspectorWrapper, { children: /* @__PURE__ */ jsx(
                JSONInspector,
                {
                  data: value,
                  isExpanded,
                  onClick: toggleExpanded,
                  search: Search,
                  filterOptions: { ignoreCase: !0 }
                }
              ) }),
              viewMode === VIEW_MODE_RAW && /* @__PURE__ */ jsx(
                Code,
                {
                  language: "json",
                  tabIndex: 0,
                  onKeyDown: maybeSelectAll,
                  onDoubleClick: select,
                  onFocus: select,
                  size: 1,
                  children: JSON.stringify(value, null, 2)
                }
              )
            ]
          }
        )
      ] })
    }
  );
}
function SpacerButton({ size }) {
  return /* @__PURE__ */ jsx(
    Button,
    {
      "aria-hidden": !0,
      disabled: !0,
      size,
      style: {
        pointerEvents: "none",
        visibility: "hidden",
        width: 0
      },
      text: "-"
    }
  );
}
function Banner(props) {
  const { action, content, icon: Icon, tone = "transparent", ...rest } = props;
  return /* @__PURE__ */ jsx(Card, { borderBottom: !0, paddingX: 4, paddingY: 2, tone, ...rest, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    Icon && /* @__PURE__ */ jsx(Text, { size: 0, children: /* @__PURE__ */ jsx(Icon, {}) }),
    /* @__PURE__ */ jsx(Flex, { align: "center", flex: 1, gap: 2, paddingY: 3, children: content }),
    /* @__PURE__ */ jsx(SpacerButton, {}),
    action && /* @__PURE__ */ jsx(
      Button,
      {
        as: action == null ? void 0 : action.as,
        mode: "ghost",
        onClick: action == null ? void 0 : action.onClick,
        text: action.text,
        tone: action.tone || "default"
      }
    )
  ] }) });
}
function DeletedDocumentBanner({ revisionId }) {
  const { documentId, documentType } = useDocumentPane(), { restore } = useDocumentOperation(documentId, documentType), { navigateIntent } = useRouter(), handleRestore = useCallback(() => {
    revisionId && (restore.execute(revisionId), navigateIntent("edit", { id: documentId, type: documentType }));
  }, [documentId, documentType, navigateIntent, restore, revisionId]), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(
    Banner,
    {
      action: revisionId ? {
        onClick: handleRestore,
        text: t("banners.deleted-document-banner.restore-button.text")
      } : void 0,
      content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("banners.deleted-document-banner.text") }),
      "data-testid": "deleted-document-banner",
      icon: ReadOnlyIcon
    }
  );
}
function DeprecatedDocumentTypeBanner() {
  const { schemaType } = useDocumentPane(), { t } = useTranslation(structureLocaleNamespace);
  return isDeprecatedSchemaType(schemaType) ? /* @__PURE__ */ jsx(
    Banner,
    {
      content: /* @__PURE__ */ jsxs(Text, { size: 1, weight: "medium", children: [
        /* @__PURE__ */ jsx(Translate, { t, i18nKey: "banners.deprecated-document-type-banner.text" }),
        " ",
        schemaType.deprecated.reason
      ] }),
      "data-testid": "deprecated-document-type-banner",
      icon: ErrorOutlineIcon
    }
  ) : null;
}
function PermissionCheckBanner({ granted, requiredPermission }) {
  const currentUser = useCurrentUser(), listFormat = useListFormat({ style: "short" }), { t } = useTranslation(structureLocaleNamespace);
  if (granted) return null;
  const roleTitles = ((currentUser == null ? void 0 : currentUser.roles) || []).map((role) => role.title), roles = listFormat.formatToParts(roleTitles).map(
    (part) => part.type === "element" ? /* @__PURE__ */ jsx("code", { children: part.value }, part.value) : part.value
  );
  return /* @__PURE__ */ jsx(
    Banner,
    {
      content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "banners.permission-check-banner.missing-permission",
          components: { Roles: () => /* @__PURE__ */ jsx(Fragment, { children: roles }) },
          values: { count: roles.length, roles: roleTitles },
          context: requiredPermission
        }
      ) }),
      "data-testid": "permission-check-banner",
      icon: ReadOnlyIcon
    }
  );
}
const ReferenceChangedBanner = memo(() => {
  var _a, _b, _c, _d, _e, _f, _g;
  const documentPreviewStore = useDocumentPreviewStore(), { params, groupIndex, routerPanesState, replaceCurrent, BackLink: BackLink2 } = usePaneRouter(), routerReferenceId = (_a = routerPanesState[groupIndex]) == null ? void 0 : _a[0].id, parentGroup = routerPanesState[groupIndex - 1], parentSibling = parentGroup == null ? void 0 : parentGroup[0], parentId = parentSibling == null ? void 0 : parentSibling.id, hasHistoryOpen = !!((_b = parentSibling == null ? void 0 : parentSibling.params) != null && _b.rev), parentRefPath = useMemo(() => (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null, [params == null ? void 0 : params.parentRefPath]), { t } = useTranslation(structureLocaleNamespace), referenceInfo = useMemoObservable(
    () => {
      const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
      if (!parentId || !parentRefPathSegment || !parentRefPath)
        return of({ loading: !1 });
      const publishedId = getPublishedId(parentId), path = fromString(parentRefPathSegment), keyedSegmentIndex = path.findIndex(
        (p) => typeof p == "object" && "_key" in p
      );
      return concat(
        // emit a loading state instantly
        of({ loading: !0 }),
        // then emit the values from watching the published ID's path
        documentPreviewStore.unstable_observePathsDocumentPair(
          publishedId,
          keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)
        ).pipe(
          // this debounce time is needed to prevent flashing banners due to
          // the router state updating faster than the content-lake state. we
          // debounce to wait for more emissions because the value pulled
          // initially could be stale.
          debounceTime(750),
          map(
            ({ draft, published }) => {
              var _a2;
              return {
                loading: !1,
                result: {
                  availability: {
                    draft: draft.availability,
                    published: published.availability
                  },
                  refValue: (_a2 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a2._ref
                }
              };
            }
          )
        )
      );
    },
    [documentPreviewStore, parentId, parentRefPath],
    { loading: !0 }
  ), handleReloadReference = useCallback(() => {
    var _a2;
    referenceInfo.loading || (_a2 = referenceInfo.result) != null && _a2.refValue && replaceCurrent({
      id: referenceInfo.result.refValue,
      params
    });
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  return (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !((_c = referenceInfo.result) != null && _c.availability.draft.available) && !((_d = referenceInfo.result) != null && _d.availability.published.available) || // if the references are the same, then hide the reference changed banner
    ((_e = referenceInfo.result) == null ? void 0 : _e.refValue) === routerReferenceId ? null : /* @__PURE__ */ jsx(
      Banner,
      {
        action: (_f = referenceInfo.result) != null && _f.refValue ? {
          onClick: handleReloadReference,
          icon: SyncIcon,
          text: t("banners.reference-changed-banner.reason-changed.reload-button.text")
        } : {
          as: BackLink2,
          icon: CloseIcon,
          text: t("banners.reference-changed-banner.reason-removed.close-button.text")
        },
        "data-testid": "reference-changed-banner",
        content: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: (_g = referenceInfo.result) != null && _g.refValue ? t("banners.reference-changed-banner.reason-changed.text") : t("banners.reference-changed-banner.reason-removed.text") }),
        icon: WarningOutlineIcon,
        tone: "caution"
      }
    )
  );
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
const TitleContainer = styled(Stack)`
  ${({ theme }) => css`
      @supports not (container-type: inline-size) {
        display: none !important;
      }

      container-type: inline-size;

      [data-heading] {
        font-size: ${theme.sanity.fonts.heading.sizes[4].fontSize}px;
        line-height: ${theme.sanity.fonts.heading.sizes[4].lineHeight}px;
        overflow-wrap: break-word;
        text-wrap: pretty;
      }

      @container (max-width: 560px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[3].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[3].lineHeight}px;
        }
      }

      @container (max-width: 420px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[2].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[2].lineHeight}px;
        }
      }
    `}
`, FormHeader = ({ documentId, schemaType, title }) => {
  var _a;
  const isSingleton = documentId === schemaType.name, { t } = useTranslation$1(structureLocaleNamespace);
  return schemaType.__experimental_formPreviewTitle === !1 ? null : /* @__PURE__ */ jsxs(TitleContainer, { marginBottom: 6, space: 4, children: [
    !isSingleton && /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: (_a = schemaType.title) != null ? _a : schemaType.name }),
    /* @__PURE__ */ jsx(Heading, { as: "h2", "data-heading": !0, muted: !title, "data-testid": "document-panel-document-title", children: title != null ? title : t("document-view.form-view.form-title-fallback") })
  ] });
};
function usePrevious(value) {
  const ref = useRef();
  return useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
const LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast(), wasEnabled = usePrevious(params.enabled);
  useEffect(() => {
    !wasEnabled && params.enabled && toast.push({ ...params, duration: LONG_ENOUGH_BUT_NOT_TOO_LONG }), wasEnabled && !params.enabled && toast.push({
      ...params,
      // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
      duration: 0.01
    });
  }, [params, toast, wasEnabled]);
}
const preventDefault = (ev) => ev.preventDefault(), FormView = forwardRef(function(props, ref) {
  var _a;
  const { hidden, margins } = props, {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    connectionState,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup
  } = useDocumentPane(), documentStore = useDocumentStore(), presence = useDocumentPresence(documentId), { title } = useDocumentTitle(), patchChannel = useMemo(() => createPatchChannel(), []), isLocked = (_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled, { t } = useTranslation(structureLocaleNamespace);
  useConditionalToast({
    id: `sync-lock-${documentId}`,
    status: "warning",
    enabled: isLocked,
    title: t("document-view.form-view.sync-lock-toast.title"),
    description: t("document-view.form-view.sync-lock-toast.description")
  }), useEffect(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(
      tap((event) => {
        event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
      })
    ).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = !!(value != null && value._rev);
  useEffect(() => {
    hasRev && patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, [hasRev]);
  const [formRef, setFormRef] = useState(null);
  useEffect(() => {
    ready && !(formState != null && formState.focusPath.length) && formRef && focusFirstDescendant(formRef);
  }, [ready]);
  const setRef = useCallback(
    (node) => {
      setFormRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
    },
    [ref]
  );
  return /* @__PURE__ */ jsx(
    Container,
    {
      hidden,
      paddingX: 4,
      paddingTop: 5,
      paddingBottom: 9,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */ jsx(PresenceOverlay, { margins, children: /* @__PURE__ */ jsx(Box, { as: "form", onSubmit: preventDefault, ref: setRef, children: connectionState === "connecting" ? /* @__PURE__ */ jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsxs(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [
        /* @__PURE__ */ jsx(Spinner, { muted: !0 }),
        /* @__PURE__ */ jsx(Box, { marginTop: 3, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, size: 1, children: t("document-view.form-view.loading") }) })
      ] }) }) : formState === null || hidden ? /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { children: t("document-view.form-view.form-hidden") }) }) : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(FormHeader, { documentId, schemaType: formState.schemaType, title }),
        /* @__PURE__ */ jsx(
          FormBuilder,
          {
            __internal_fieldActions: fieldActions,
            __internal_patchChannel: patchChannel,
            collapsedFieldSets,
            collapsedPaths,
            focusPath: formState.focusPath,
            changed: formState.changed,
            focused: formState.focused,
            groups: formState.groups,
            id: "root",
            members: formState.members,
            onChange,
            onFieldGroupSelect: onSetActiveFieldGroup,
            onPathBlur: onBlur,
            onPathFocus: onFocus,
            onPathOpen,
            onSetFieldSetCollapsed: onSetCollapsedFieldSet,
            onSetPathCollapsed: onSetCollapsedPath,
            presence,
            readOnly: connectionState === "reconnecting" || formState.readOnly,
            schemaType: formState.schemaType,
            validation,
            value: (
              // note: the form state doesn't have a typed concept of a "document" value
              // but these should be compatible
              formState.value
            )
          }
        )
      ] }) }) })
    }
  );
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(
      fromMutationPatches("local", localPatches)
    )
  };
}
const DocumentBox = styled(Box)({
  position: "relative"
}), Scroller$1 = styled(ScrollContainer)(({ $disabled }) => $disabled ? { height: "100%" } : css`
    height: 100%;
    overflow: auto;
    position: relative;
    scroll-behavior: smooth;
    outline: none;
  `), DocumentPanel = function(props) {
  const { footerHeight, headerHeight, isInspectOpen, rootElement, setDocumentPanelPortalElement } = props, {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views: views2,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading,
    isDeleting,
    isDeleted,
    timelineStore
  } = useDocumentPane(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed } = usePane(), parentPortal = usePortal(), { features } = useStructureTool(), portalRef = useRef(null), [documentScrollElement, setDocumentScrollElement] = useState(null), formContainerElement = useRef(null), requiredPermission = value._createdAt ? "update" : "create", activeView = useMemo(
    () => views2.find((view) => view.id === activeViewId) || views2[0] || { type: "form" },
    [activeViewId, views2]
  ), portalElement = features.splitPanes && portalRef.current || parentPortal.element, margins = useMemo(() => layoutCollapsed ? [headerHeight || 0, 0, footerHeight ? footerHeight + 2 : 2, 0] : [0, 0, 2, 0], [layoutCollapsed, footerHeight, headerHeight]), formViewHidden = activeView.type !== "form", activeViewNode = useMemo(
    () => activeView.type === "component" && activeView.component && createElement(activeView.component, {
      document: {
        draft: (editState == null ? void 0 : editState.draft) || null,
        displayed: displayed || value,
        historical: displayed,
        published: (editState == null ? void 0 : editState.published) || null
      },
      documentId,
      options: activeView.options,
      schemaType
    }),
    [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]
  ), lastNonDeletedRevId = useTimelineSelector(
    timelineStore,
    (state2) => state2.lastNonDeletedRevId
  );
  useEffect(() => {
    documentScrollElement != null && documentScrollElement.scrollTo && documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]), useEffect(() => {
    portalElement && setDocumentPanelPortalElement(portalElement);
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = useMemo(() => isInspectOpen ? /* @__PURE__ */ jsx(InspectDialog, { value: displayed || value }) : null, [isInspectOpen, displayed, value]), showInspector = !!(!collapsed && inspector);
  return /* @__PURE__ */ jsx(PaneContent, { children: /* @__PURE__ */ jsxs(Flex, { height: "fill", children: [
    (features.resizablePanes || !showInspector) && /* @__PURE__ */ jsx(DocumentBox, { flex: 2, overflow: "hidden", children: /* @__PURE__ */ jsx(
      PortalProvider,
      {
        element: portalElement,
        __unstable_elements: { documentScrollElement },
        children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: documentScrollElement, children: /* @__PURE__ */ jsxs(
          VirtualizerScrollInstanceProvider,
          {
            scrollElement: documentScrollElement,
            containerElement: formContainerElement,
            children: [
              activeView.type === "form" && !isPermissionsLoading && ready && /* @__PURE__ */ jsxs(Fragment, { children: [
                /* @__PURE__ */ jsx(
                  PermissionCheckBanner,
                  {
                    granted: !!(permissions != null && permissions.granted),
                    requiredPermission
                  }
                ),
                !isDeleting && isDeleted && /* @__PURE__ */ jsx(DeletedDocumentBanner, { revisionId: lastNonDeletedRevId }),
                /* @__PURE__ */ jsx(ReferenceChangedBanner, {}),
                /* @__PURE__ */ jsx(DeprecatedDocumentTypeBanner, {})
              ] }),
              /* @__PURE__ */ jsxs(
                Scroller$1,
                {
                  $disabled: layoutCollapsed || !1,
                  "data-testid": "document-panel-scroller",
                  ref: setDocumentScrollElement,
                  children: [
                    /* @__PURE__ */ jsx(
                      FormView,
                      {
                        hidden: formViewHidden,
                        margins,
                        ref: formContainerElement
                      },
                      documentId + (ready ? "_ready" : "_pending")
                    ),
                    activeViewNode
                  ]
                }
              ),
              inspectDialog,
              /* @__PURE__ */ jsx("div", { "data-testid": "document-panel-portal", ref: portalRef })
            ]
          }
        ) })
      }
    ) }),
    showInspector && /* @__PURE__ */ jsx(BoundaryElementProvider, { element: rootElement, children: /* @__PURE__ */ jsx(
      DocumentInspectorPanel,
      {
        documentId,
        documentType: schemaType.name,
        flex: 1
      }
    ) })
  ] }) });
}, POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"], DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const { dialog, referenceElement } = props;
  return /* @__PURE__ */ jsx(
    Popover,
    {
      content: /* @__PURE__ */ jsx(ConfirmDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: !0,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      referenceElement
    }
  );
}
function ConfirmDialogContent(props) {
  const { dialog } = props, {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog, { t } = useTranslation(structureLocaleNamespace), { isTopLayer } = useLayer(), [element, setElement] = useState(null), handleClickOutside = useCallback(() => {
    isTopLayer && onCancel();
  }, [isTopLayer, onCancel]), handleGlobalKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && isTopLayer && onCancel();
    },
    [isTopLayer, onCancel]
  );
  return useClickOutside(handleClickOutside, [element]), useGlobalKeyDown(handleGlobalKeyDown), /* @__PURE__ */ jsxs(Flex, { direction: "column", ref: setElement, style: { minWidth: 304, maxWidth: 400 }, children: [
    /* @__PURE__ */ jsx(Box, { flex: 1, overflow: "auto", padding: 4, children: /* @__PURE__ */ jsx(Text, { children: message }) }),
    /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 3, style: { borderTop: "1px solid var(--card-border-color)" }, children: /* @__PURE__ */ jsxs(Grid, { columns: 2, gap: 2, children: [
      /* @__PURE__ */ jsx(
        Button$1,
        {
          "data-testid": "confirm-dialog-cancel-button",
          icon: cancelButtonIcon,
          onClick: onCancel,
          mode: "ghost",
          text: cancelButtonText || t("confirm-dialog.cancel-button.fallback-text")
        }
      ),
      /* @__PURE__ */ jsx(
        Button$1,
        {
          "data-testid": "confirm-dialog-confirm-button",
          icon: confirmButtonIcon,
          onClick: onConfirm,
          text: confirmButtonText || t("confirm-dialog.confirm-button.fallback-text"),
          tone
        }
      )
    ] }) })
  ] });
}
function ModalDialog(props) {
  const { dialog } = props, dialogId = useId(), footer = dialog.footer && /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 3, children: dialog.footer });
  return /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "fullscreen", children: /* @__PURE__ */ jsx(
    Dialog$1,
    {
      animate: !0,
      __unstable_hideCloseButton: dialog.showCloseButton === !1,
      footer,
      header: dialog.header,
      id: dialogId,
      onClose: dialog.onClose,
      onClickOutside: dialog.onClose,
      width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width],
      children: /* @__PURE__ */ jsx(Box, { padding: 4, children: dialog.content })
    }
  ) });
}
function PopoverDialog(props) {
  const { dialog, referenceElement } = props;
  return /* @__PURE__ */ jsx(
    Popover,
    {
      content: /* @__PURE__ */ jsx(PopoverDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: !0,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      referenceElement
    }
  );
}
function PopoverDialogContent(props) {
  const { dialog } = props, { content, onClose } = dialog, { isTopLayer } = useLayer(), [element, setElement] = useState(null), handleClickOutside = useCallback(() => {
    isTopLayer && onClose();
  }, [isTopLayer, onClose]), handleGlobalKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && isTopLayer && onClose();
    },
    [isTopLayer, onClose]
  );
  return useClickOutside(handleClickOutside, [element]), useGlobalKeyDown(handleGlobalKeyDown), /* @__PURE__ */ jsx("div", { ref: setElement, children: content });
}
function DocumentActionPortalProvider(props) {
  const { children } = props, { element, elements } = usePortal(), portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return /* @__PURE__ */ jsx(PortalProvider, { element: portalElement, children });
}
function ActionStateDialog(props) {
  const { dialog, referenceElement = null } = props, modalId = useId();
  if (dialog.type === "confirm")
    return /* @__PURE__ */ jsx(ConfirmDialog, { dialog, referenceElement });
  if (dialog.type === "popover")
    return /* @__PURE__ */ jsx(PopoverDialog, { dialog, referenceElement });
  if (dialog.type === "dialog" || !dialog.type)
    return /* @__PURE__ */ jsx(DocumentActionPortalProvider, { children: /* @__PURE__ */ jsx(ModalDialog, { dialog }) });
  if (dialog.type === "custom")
    return /* @__PURE__ */ jsx(DocumentActionPortalProvider, { children: dialog == null ? void 0 : dialog.component });
  const unknownModal = dialog;
  return console.warn(`Unsupported modal type ${unknownModal.type}`), /* @__PURE__ */ jsx(
    Dialog,
    {
      id: modalId,
      onClose: unknownModal.onClose,
      onClickOutside: unknownModal.onClose,
      width: 1,
      children: unknownModal.content || // eslint-disable-next-line i18next/no-literal-string
      /* @__PURE__ */ jsxs(Text, { size: 1, children: [
        "Unexpected modal type (",
        /* @__PURE__ */ jsx("code", { children: unknownModal.type }),
        ")"
      ] })
    }
  );
}
function ActionDialogWrapper({
  actionStates,
  children,
  referenceElement
}) {
  const [actionIndex, setActionIndex] = useState(-1), currentAction = actionStates[actionIndex], handleAction = useCallback((idx) => {
    setActionIndex(idx);
  }, []);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    currentAction && currentAction.dialog && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }),
    children({ handleAction })
  ] });
}
function ActionMenuButton(props) {
  const { actionStates, disabled } = props, idPrefix = useId(), [referenceElement, setReferenceElement] = useState(null), popoverProps = useMemo(
    () => ({
      placement: "top-end",
      portal: !0,
      preventOverflow: !0
    }),
    []
  ), { t } = useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsx(ActionDialogWrapper, { actionStates, referenceElement, children: ({ handleAction }) => /* @__PURE__ */ jsx(
    MenuButton,
    {
      id: `${idPrefix}-action-menu`,
      button: /* @__PURE__ */ jsx(
        ContextMenuButton,
        {
          "aria-label": t("buttons.action-menu-button.aria-label"),
          disabled,
          "data-testid": "action-menu-button",
          size: "large",
          tooltipProps: { content: t("buttons.action-menu-button.tooltip") }
        }
      ),
      menu: /* @__PURE__ */ jsx(Menu, { padding: 1, children: actionStates.map((actionState, idx) => /* @__PURE__ */ jsx(
        ActionMenuListItem,
        {
          actionState,
          disabled,
          index: idx,
          onAction: handleAction
        },
        idx
      )) }),
      popover: popoverProps,
      ref: setReferenceElement
    }
  ) });
}
function ActionMenuListItem(props) {
  const { actionState, disabled, index, onAction } = props, { onHandle } = actionState, handleClick = useCallback(() => {
    onAction(index), onHandle && onHandle();
  }, [index, onAction, onHandle]), hotkeys = useMemo(() => actionState.shortcut ? String(actionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1)) : void 0, [actionState.shortcut]);
  return /* @__PURE__ */ jsx(
    MenuItem,
    {
      "data-testid": `action-${actionState.label.replace(" ", "")}`,
      disabled: disabled || !!actionState.disabled,
      hotkeys,
      icon: actionState.icon,
      onClick: handleClick,
      text: actionState.label,
      tone: actionState.tone,
      ...actionState.disabled && { tooltipProps: { content: actionState.title } }
    }
  );
}
const TIMELINE_ICON_COMPONENTS = {
  create: AddCircleIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddCircleIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
const StackWrapper = styled(Stack)`
  max-width: 200px;
`, ListWrapper = styled(Flex)`
  max-height: calc(100vh - 198px);
  min-width: 244px;
`, Root$2 = styled(Box)(({ $visible }) => css`
    opacity: 0;
    pointer-events: none;

    ${$visible && css`
      opacity: 1;
      pointer-events: auto;
    `}
  `), TIMELINE_ITEM_I18N_KEY_MAPPING = {
  initial: "timeline.operation.created-initial",
  create: "timeline.operation.created",
  publish: "timeline.operation.published",
  editLive: "timeline.operation.edited-live",
  editDraft: "timeline.operation.edited-draft",
  unpublish: "timeline.operation.unpublished",
  discardDraft: "timeline.operation.draft-discarded",
  delete: "timeline.operation.deleted"
}, IconWrapper = styled(Flex)(({ theme }) => {
  var _a;
  const borderColor = (_a = theme.sanity.color.base.skeleton) == null ? void 0 : _a.from;
  return css`
    --timeline-hairline-width: 1px;
    position: relative;
    z-index: 2;
    margin: 0;
    padding: 0;

    &::before {
      position: absolute;
      content: '';
      height: 100%;
      width: var(--timeline-hairline-width);
      background: ${borderColor};
      top: 0;
      left: calc((100% - var(--timeline-hairline-width)) / 2);
      z-index: 1;
    }
  `;
}), Root$1 = styled(Button$1)(({ $selected, $disabled }) => css`
    position: relative;
    width: 100%;

    /* Line styling */
    &[data-first] ${IconWrapper}::before {
      height: 50%;
      top: unset;
      bottom: 0;
    }

    &[data-last] ${IconWrapper}::before {
      height: 50%;
    }

    ${$selected && css`
      ${IconWrapper}::before {
        background: transparent;
      }
    `}

    ${$disabled && css`
      cursor: not-allowed;
    `}
  `), IconBox = styled(Box)`
  background: var(--card-bg-color);
  border-radius: 50px;
  position: relative;
  z-index: 2;
`, TimestampBox = styled(Box)`
  min-width: 1rem;
  margin-left: ${({ theme }) => `-${rem(theme.sanity.space[1])}`};
`;
function UserAvatarStack({ maxLength, userIds }) {
  return /* @__PURE__ */ jsx(AvatarStack, { maxLength, children: userIds.map((userId) => /* @__PURE__ */ jsx(UserAvatar, { user: userId, withTooltip: !0 }, userId)) });
}
const TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem({
  chunk,
  isFirst,
  isLast,
  isLatest,
  isSelected,
  onSelect,
  timestamp,
  type
}) {
  const { t } = useTranslation("studio"), iconComponent = getTimelineEventIconComponent(type), authorUserIds = Array.from(chunk.authors), isSelectable = type !== "delete", dateFormat = useDateTimeFormat({ dateStyle: "medium", timeStyle: "short" }), formattedTimestamp = useMemo(() => {
    const parsedDate = new Date(timestamp);
    return dateFormat.format(parsedDate);
  }, [timestamp, dateFormat]), handleClick = useCallback(
    (evt) => {
      evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(chunk);
    },
    [onSelect, chunk, isSelectable]
  );
  return /* @__PURE__ */ jsx(
    Root$1,
    {
      $selected: isSelected,
      $disabled: !isSelectable,
      "data-chunk-id": chunk.id,
      "data-first": isFirst ? !0 : void 0,
      "data-last": isLast ? !0 : void 0,
      "data-ui": "timelineItem",
      mode: isSelected ? "default" : "bleed",
      onClick: handleClick,
      padding: 0,
      radius: 2,
      tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
      children: /* @__PURE__ */ jsx(Box, { paddingX: 2, children: /* @__PURE__ */ jsxs(Flex, { align: "stretch", children: [
        /* @__PURE__ */ jsx(IconWrapper, { align: "center", children: /* @__PURE__ */ jsx(IconBox, { padding: 2, children: /* @__PURE__ */ jsx(Text, { size: 2, children: iconComponent && createElement(iconComponent) }) }) }),
        /* @__PURE__ */ jsxs(Stack, { space: 2, margin: 2, children: [
          isLatest && /* @__PURE__ */ jsx(Flex, { children: /* @__PURE__ */ jsx(
            Card,
            {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 0, weight: "medium", children: t("timeline.latest") })
            }
          ) }),
          /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t(TIMELINE_ITEM_I18N_KEY_MAPPING[type]) || /* @__PURE__ */ jsx("code", { children: type }) }) }),
          /* @__PURE__ */ jsx(TimestampBox, { paddingX: 1, children: /* @__PURE__ */ jsx(Text, { as: "time", size: 0, muted: !0, dateTime: timestamp, children: formattedTimestamp }) })
        ] }),
        /* @__PURE__ */ jsx(Flex, { flex: 1, justify: "flex-end", align: "center", children: /* @__PURE__ */ jsx(UserAvatarStack, { maxLength: 3, userIds: authorUserIds }) })
      ] }) })
    }
  );
}
const Timeline = ({
  chunks,
  disabledBeforeFirstChunk,
  hasMoreChunks,
  lastChunk,
  onLoadMore,
  onSelect,
  firstChunk
}) => {
  const [mounted, setMounted] = useState(!1), { t } = useTranslation("studio"), filteredChunks = useMemo(() => chunks.filter((c) => disabledBeforeFirstChunk && firstChunk ? c.index < firstChunk.index : !0), [chunks, disabledBeforeFirstChunk, firstChunk]), selectedIndex = useMemo(
    () => lastChunk != null && lastChunk.id ? filteredChunks.findIndex((c) => c.id === lastChunk.id) : -1,
    [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]
  ), renderItem = useCallback(
    (chunk, { activeIndex }) => {
      const isFirst = activeIndex === 0, isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || !1;
      return /* @__PURE__ */ jsxs(Box, { paddingBottom: isLast ? 1 : 0, paddingTop: isFirst ? 1 : 0, paddingX: 1, children: [
        /* @__PURE__ */ jsx(
          TimelineItem,
          {
            chunk,
            isFirst,
            isLast,
            isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
            isSelected: activeIndex === selectedIndex,
            onSelect,
            timestamp: chunk.endTimestamp,
            type: chunk.type
          }
        ),
        activeIndex === filteredChunks.length - 1 && hasMoreChunks && /* @__PURE__ */ jsx(LoadingBlock, {})
      ] });
    },
    [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]
  );
  return useEffect(() => setMounted(!0), []), /* @__PURE__ */ jsxs(
    Root$2,
    {
      $visible: !selectedIndex || mounted,
      "data-ui": "timeline",
      children: [
        filteredChunks.length === 0 && /* @__PURE__ */ jsxs(StackWrapper, { padding: 3, space: 3, children: [
          /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }),
          /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("timeline.error.no-document-history-description") })
        ] }),
        filteredChunks.length > 0 && /* @__PURE__ */ jsx(ListWrapper, { direction: "column", children: /* @__PURE__ */ jsx(
          CommandList,
          {
            activeItemDataAttr: "data-hovered",
            ariaLabel: t("timeline.list.aria-label"),
            autoFocus: "list",
            initialIndex: selectedIndex,
            initialScrollAlign: "center",
            itemHeight: 40,
            items: filteredChunks,
            onEndReached: onLoadMore,
            onEndReachedIndexOffset: 20,
            overscan: 5,
            renderItem,
            wrapAround: !1
          }
        ) })
      ]
    }
  );
};
Timeline.displayName = "Timeline";
function TimelineError() {
  const { t } = useTranslation("studio");
  return /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, padding: 4, children: [
    /* @__PURE__ */ jsx(TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsx(ErrorOutlineIcon, {}) }),
    /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
      /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t("timeline.error.load-document-changes-title") }),
      /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: "critical", children: t("timeline.error.load-document-changes-description") })
    ] })
  ] });
}
const Root = styled(Popover$1)`
  overflow: hidden;
  overflow: clip;
`;
function TimelineMenu({ chunk, mode, placement }) {
  const { setTimelineRange, setTimelineMode, timelineError, ready, timelineStore } = useDocumentPane(), [open, setOpen] = useState(!1), [button, setButton] = useState(null), [popover, setPopover] = useState(null), toast = useToast(), chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks), loading = useTimelineSelector(timelineStore, (state2) => state2.isLoading), hasMoreChunks = useTimelineSelector(timelineStore, (state2) => state2.hasMoreChunks), realRevChunk = useTimelineSelector(timelineStore, (state2) => state2.realRevChunk), sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime), { t } = useTranslation("studio"), handleOpen = useCallback(() => {
    setTimelineMode(mode), setOpen(!0);
  }, [mode, setTimelineMode]), handleClose = useCallback(() => {
    setTimelineMode("closed"), setOpen(!1);
  }, [setTimelineMode]), handleClickOutside = useCallback(() => {
    open && handleClose();
  }, [handleClose, open]), handleGlobalKeyDown = useCallback(
    (event) => {
      open && (event.key === "Escape" || event.key === "Tab") && (handleClose(), button == null || button.focus());
    },
    [button, handleClose, open]
  );
  useClickOutside(handleClickOutside, [button, popover]), useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = useCallback(
    (revChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: !0,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), selectSince = useCallback(
    (sinceChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: !0,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), handleLoadMore = useCallback(() => {
    loading || timelineStore.loadMore();
  }, [loading, timelineStore]), content = timelineError ? /* @__PURE__ */ jsx(TimelineError, {}) : /* @__PURE__ */ jsxs(Fragment, { children: [
    mode === "rev" && /* @__PURE__ */ jsx(
      Timeline,
      {
        chunks,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: realRevChunk,
        onLoadMore: handleLoadMore,
        onSelect: selectRev
      }
    ),
    mode === "since" && /* @__PURE__ */ jsx(
      Timeline,
      {
        chunks,
        disabledBeforeFirstChunk: !0,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: sinceTime,
        onLoadMore: handleLoadMore,
        onSelect: selectSince
      }
    )
  ] }), formatParams = {
    timestamp: { dateStyle: "medium", timeStyle: "short" }
  }, revLabel = chunk ? t(TIMELINE_ITEM_I18N_KEY_MAPPING[chunk.type], {
    context: "timestamp",
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.latest-version"), sinceLabel = chunk ? t("timeline.since", {
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.since-version-missing");
  return /* @__PURE__ */ jsx(
    Root,
    {
      constrainSize: !0,
      content: open && content,
      "data-ui": "versionMenu",
      open,
      placement,
      portal: !0,
      ref: setPopover,
      children: /* @__PURE__ */ jsx(
        Button,
        {
          disabled: !ready,
          mode: "bleed",
          iconRight: ChevronDownIcon,
          onClick: open ? handleClose : handleOpen,
          ref: setButton,
          selected: open,
          style: { maxWidth: "100%" },
          text: ready ? mode === "rev" ? revLabel : sinceLabel : t("timeline.loading-history")
        }
      )
    }
  );
}
function DocumentHeaderTabs() {
  const { activeViewId, paneKey, views: views2 } = useDocumentPane(), tabPanelId = `${paneKey}tabpanel`;
  return /* @__PURE__ */ jsx(TabList, { space: 1, children: views2.map((view, index) => {
    var _a;
    return /* @__PURE__ */ jsx(
      DocumentHeaderTab,
      {
        icon: view.icon,
        id: `${paneKey}tab-${view.id}`,
        isActive: activeViewId === view.id,
        label: view.title,
        tabPanelId,
        viewId: index === 0 ? null : (_a = view.id) != null ? _a : null
      },
      view.id
    );
  }) });
}
function DocumentHeaderTab(props) {
  const { icon, id, isActive, label, tabPanelId, viewId, ...rest } = props, { ready } = useDocumentPane(), { setView } = usePaneRouter(), handleClick = useCallback(() => setView(viewId), [setView, viewId]);
  return /* @__PURE__ */ jsx(
    Tab,
    {
      ...rest,
      "aria-controls": tabPanelId,
      disabled: !ready,
      icon,
      id,
      label,
      onClick: handleClick,
      selected: isActive
    }
  );
}
function DocumentHeaderTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  }), { t } = useTranslation(structureLocaleNamespace);
  return connectionState === "connecting" ? /* @__PURE__ */ jsx(Fragment, {}) : title ? /* @__PURE__ */ jsx(Fragment, { children: title }) : documentValue ? error ? /* @__PURE__ */ jsx(Fragment, { children: t("panes.document-header-title.error.text", { error: error.message }) }) : /* @__PURE__ */ jsx(Fragment, { children: (value == null ? void 0 : value.title) || /* @__PURE__ */ jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("panes.document-header-title.untitled.text") }) }) : /* @__PURE__ */ jsx(Fragment, { children: t("panes.document-header-title.new.text", {
    schemaType: (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)
  }) });
}
const DocumentPanelHeader = memo(
  forwardRef(function(_props, ref) {
    const { menuItems } = _props, {
      actions,
      editState,
      onMenuAction,
      onPaneClose,
      onPaneSplit,
      menuItemGroups,
      schemaType,
      timelineStore,
      connectionState,
      views: views2,
      unstable_languageFilter
    } = useDocumentPane(), { features } = useStructureTool(), { index, BackLink: BackLink2, hasGroupSiblings } = usePaneRouter(), { actions: fieldActions } = useFieldActions(), [referenceElement, setReferenceElement] = useState(null), menuNodes = useMemo(
      () => resolveMenuNodes({ actionHandler: onMenuAction, fieldActions, menuItems, menuItemGroups }),
      [onMenuAction, fieldActions, menuItemGroups, menuItems]
    ), menuButtonNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), showTabs = views2.length > 1, rev = useTimelineSelector(timelineStore, (state2) => state2.revTime), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showSplitPaneButton = features.splitViews && onPaneSplit && views2.length > 1, showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings, showBackButton = features.backButton && index > 0, showPaneGroupCloseButton = !showSplitPaneCloseButton && !showBackButton && !!BackLink2, { t } = useTranslation(structureLocaleNamespace);
    return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(
      PaneHeader$1,
      {
        border: !0,
        ref,
        loading: connectionState === "connecting",
        title: /* @__PURE__ */ jsx(DocumentHeaderTitle, {}),
        tabs: showTabs && /* @__PURE__ */ jsx(DocumentHeaderTabs, {}),
        tabIndex,
        backButton: showBackButton && /* @__PURE__ */ jsx(
          Button,
          {
            as: BackLink2,
            "data-as": "a",
            icon: ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: t("pane-header.back-button.text") }
          }
        ),
        subActions: /* @__PURE__ */ jsx(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }),
        actions: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
          unstable_languageFilter.length > 0 && /* @__PURE__ */ jsx(Fragment, { children: unstable_languageFilter.map((languageFilterComponent, idx) => createElement(languageFilterComponent, {
            // eslint-disable-next-line react/no-array-index-key
            key: `language-filter-${idx}`,
            schemaType
          })) }),
          menuButtonNodes.map((item) => /* @__PURE__ */ jsx(PaneHeaderActionButton, { node: item }, item.key)),
          editState && /* @__PURE__ */ jsx(
            RenderActionCollectionState,
            {
              actions: actions || [],
              actionProps: editState,
              group: "paneActions",
              children: ({ states }) => /* @__PURE__ */ jsx(ActionDialogWrapper, { actionStates: states, referenceElement, children: ({ handleAction }) => /* @__PURE__ */ jsx("div", { ref: setReferenceElement, children: /* @__PURE__ */ jsx(
                PaneContextMenuButton,
                {
                  nodes: contextMenuNodes,
                  actionsNodes: states.length > 0 ? states.map((actionState, actionIndex) => /* @__PURE__ */ jsx(
                    ActionMenuListItem,
                    {
                      actionState,
                      disabled: !!actionState.disabled,
                      index: actionIndex,
                      onAction: handleAction
                    },
                    actionState.label
                  )) : void 0
                },
                "context-menu"
              ) }) })
            }
          ),
          showSplitPaneButton && /* @__PURE__ */ jsx(
            Button,
            {
              "aria-label": t("buttons.split-pane-button.aria-label"),
              icon: SplitVerticalIcon,
              mode: "bleed",
              onClick: onPaneSplit,
              tooltipProps: { content: t("buttons.split-pane-button.tooltip") }
            },
            "split-pane-button"
          ),
          showSplitPaneCloseButton && /* @__PURE__ */ jsx(
            Button,
            {
              icon: CloseIcon,
              mode: "bleed",
              onClick: onPaneClose,
              tooltipProps: { content: t("buttons.split-pane-close-button.title") }
            },
            "close-view-button"
          ),
          showPaneGroupCloseButton && /* @__PURE__ */ jsx(
            Button,
            {
              icon: CloseIcon,
              mode: "bleed",
              tooltipProps: { content: t("buttons.split-pane-close-group-button.title") },
              as: BackLink2
            },
            "close-view-button"
          )
        ] })
      }
    ) });
  })
), BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
function DocumentBadgesInner({ states }) {
  return states.length === 0 ? null : /* @__PURE__ */ jsx(Inline, { space: 1, children: states.map((badge, index) => /* @__PURE__ */ jsx(
    Tooltip,
    {
      content: badge.title,
      disabled: !badge.title,
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsx(
        Badge,
        {
          fontSize: 1,
          mode: "outline",
          paddingX: 2,
          paddingY: 1,
          radius: 4,
          tone: badge.color ? BADGE_TONES[badge.color] : void 0,
          style: { whiteSpace: "nowrap" },
          children: badge.label
        }
      )
    },
    String(index)
  )) });
}
function DocumentBadges() {
  const { badges, editState } = useDocumentPane();
  return !editState || !badges ? null : /* @__PURE__ */ jsx(RenderBadgeCollectionState, { badges, badgeProps: editState, children: ({ states }) => /* @__PURE__ */ jsx(DocumentBadgesInner, { states }) });
}
const DISABLED_REASON_TITLE_KEY$1 = {
  NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete",
  NOT_READY: "action.delete.disabled.not-ready"
}, DeleteAction = ({ id, type, draft, onComplete }) => {
  const { setIsDeleting: paneSetIsDeleting } = useDocumentPane(), { delete: deleteOp } = useDocumentOperation(id, type), [isDeleting, setIsDeleting] = useState(!1), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), { t } = useTranslation(structureLocaleNamespace), handleCancel = useCallback(() => {
    setConfirmDialogOpen(!1), onComplete();
  }, [onComplete]), handleConfirm = useCallback(() => {
    setIsDeleting(!0), setConfirmDialogOpen(!1), paneSetIsDeleting(!0), deleteOp.execute(), onComplete();
  }, [deleteOp, onComplete, paneSetIsDeleting]), handle = useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "delete"
  }), currentUser = useCurrentUser();
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: TrashIcon,
    disabled: !0,
    label: t("action.delete.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "delete-document", currentUser })
  } : {
    tone: "critical",
    icon: TrashIcon,
    disabled: isDeleting || !!deleteOp.disabled || isPermissionsLoading,
    title: deleteOp.disabled && t(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) || "",
    label: t(isDeleting ? "action.delete.running.label" : "action.delete.label"),
    shortcut: "Ctrl+Alt+D",
    onHandle: handle,
    dialog: isConfirmDialogOpen && {
      type: "custom",
      component: /* @__PURE__ */ jsx(
        ConfirmDeleteDialogContainer,
        {
          action: "delete",
          id: (draft == null ? void 0 : draft._id) || id,
          type,
          onCancel: handleCancel,
          onConfirm: handleConfirm
        }
      )
    }
  };
};
DeleteAction.action = "delete";
const DISABLED_REASON_KEY$2 = {
  NO_CHANGES: "action.discard-changes.disabled.no-changes",
  NOT_PUBLISHED: "action.discard-changes.disabled.not-published",
  NOT_READY: "action.discard-changes.disabled.not-ready"
}, DiscardChangesAction = ({
  id,
  type,
  published,
  liveEdit,
  onComplete
}) => {
  const { discardChanges } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "discardDraft"
  }), currentUser = useCurrentUser(), { t } = useTranslation(structureLocaleNamespace), handleConfirm = useCallback(() => {
    discardChanges.execute(), onComplete();
  }, [discardChanges, onComplete]), handle = useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), dialog = useMemo(
    () => isConfirmDialogOpen && {
      type: "confirm",
      tone: "critical",
      onCancel: onComplete,
      onConfirm: handleConfirm,
      message: t("action.discard-changes.confirm-dialog.confirm-discard-changes")
    },
    [handleConfirm, isConfirmDialogOpen, onComplete, t]
  );
  return !published || liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: ResetIcon,
    disabled: !0,
    label: t("action.discard-changes.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "discard-changes", currentUser })
  } : {
    tone: "critical",
    icon: ResetIcon,
    disabled: !!discardChanges.disabled || isPermissionsLoading,
    title: discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || "",
    label: t("action.discard-changes.label"),
    onHandle: handle,
    dialog
  };
};
DiscardChangesAction.action = "discardChanges";
const DISABLED_REASON_KEY$1 = {
  NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate",
  NOT_READY: "action.duplicate.disabled.not-ready"
}, DuplicateAction = ({ id, type, onComplete }) => {
  const documentStore = useDocumentStore(), { duplicate } = useDocumentOperation(id, type), { navigateIntent } = useRouter(), [isDuplicating, setDuplicating] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  }), { t } = useTranslation(structureLocaleNamespace), currentUser = useCurrentUser(), handle = useCallback(async () => {
    const dupeId = uuid();
    setDuplicating(!0);
    const duplicateSuccess = firstValueFrom(
      documentStore.pair.operationEvents(id, type).pipe(filter((e) => e.op === "duplicate" && e.type === "success"))
    );
    duplicate.execute(dupeId), await duplicateSuccess, navigateIntent("edit", { id: dupeId, type }), onComplete();
  }, [documentStore.pair, duplicate, id, navigateIntent, onComplete, type]);
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    icon: CopyIcon,
    disabled: !0,
    label: t("action.duplicate.label"),
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "duplicate-document", currentUser })
  } : {
    icon: CopyIcon,
    disabled: isDuplicating || !!duplicate.disabled || isPermissionsLoading,
    label: t(isDuplicating ? "action.duplicate.running.label" : "action.duplicate.label"),
    title: duplicate.disabled ? t(DISABLED_REASON_KEY$1[duplicate.disabled]) : "",
    onHandle: handle
  };
};
DuplicateAction.action = "duplicate";
const HistoryRestoreAction = ({ id, type, revision, onComplete }) => {
  const { restore } = useDocumentOperation(id, type), event = useDocumentOperationEvent(id, type), { navigateIntent } = useRouter(), prevEvent = useRef(event), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), { t } = useTranslation(structureLocaleNamespace), handleConfirm = useCallback(() => {
    restore.execute(revision), onComplete();
  }, [restore, revision, onComplete]);
  useEffect(() => {
    !event || event === prevEvent.current || (event.type === "success" && event.op === "restore" && navigateIntent("edit", { id, type }), prevEvent.current = event);
  }, [event, id, navigateIntent, type]);
  const handle = useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), dialog = useMemo(() => isConfirmDialogOpen ? {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: t("action.restore.confirm.message")
  } : null, [handleConfirm, isConfirmDialogOpen, onComplete, t]), isRevisionInitialVersion = revision === "@initial";
  return revision === void 0 ? null : {
    label: t("action.restore.label"),
    color: "primary",
    onHandle: handle,
    title: t(
      isRevisionInitialVersion ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip"
    ),
    icon: RestoreIcon,
    dialog,
    disabled: isRevisionInitialVersion
  };
};
HistoryRestoreAction.action = "restore";
const DocumentPublished = defineEvent({
  name: "Document Published",
  version: 1,
  description: 'User clicked the "Publish" button in the document pane'
}), DISABLED_REASON_TITLE_KEY = {
  LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled",
  ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip",
  NO_CHANGES: "action.publish.no-changes.tooltip",
  NOT_READY: "action.publish.disabled.not-ready"
};
function getDisabledReason(reason, publishedAt, t) {
  return reason === "ALREADY_PUBLISHED" && publishedAt ? /* @__PURE__ */ jsx(AlreadyPublished, { publishedAt }) : t(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished({ publishedAt }) {
  const { t } = useTranslation(structureLocaleNamespace), timeSincePublished = useRelativeTime(publishedAt, { useTemporalPhrase: !0 });
  return /* @__PURE__ */ jsx("span", { children: t("action.publish.already-published.tooltip", { timeSincePublished }) });
}
const PublishAction = (props) => {
  var _a;
  const { id, type, liveEdit, draft, published } = props, [publishState, setPublishState] = useState(null), { publish } = useDocumentOperation(id, type), validationStatus = useValidationStatus(id, type), syncState = useSyncState(id, type), { changesOpen, onHistoryOpen, documentId, documentType } = useDocumentPane(), editState = useEditState(documentId, documentType), { t } = useTranslation(structureLocaleNamespace), revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev, hasValidationErrors = validationStatus.validation.some(isValidationErrorMarker), [publishScheduled, setPublishScheduled] = useState(!1), isSyncing = syncState.isSyncing, isValidating = validationStatus.isValidating, [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "publish"
  }), currentUser = useCurrentUser(), title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t) || "" : hasValidationErrors ? t("action.publish.validation-issues.tooltip") : "", hasDraft = !!draft, doPublish = useCallback(() => {
    publish.execute(), setPublishState("publishing");
  }, [publish]);
  useEffect(() => {
    const validationComplete = validationStatus.isValidating === !1 && validationStatus.revision !== revision;
    !publishScheduled || isSyncing || !validationComplete || (hasValidationErrors || doPublish(), setPublishScheduled(!1));
  }, [
    isSyncing,
    doPublish,
    hasValidationErrors,
    publishScheduled,
    validationStatus.revision,
    revision,
    isValidating,
    validationStatus.isValidating
  ]), useEffect(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    didPublish && changesOpen && onHistoryOpen();
    const nextState = didPublish ? "published" : null, timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, didPublish ? 200 : 4e3);
    return () => clearTimeout(timer2);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const telemetry = useTelemetry(), handle = useCallback(() => {
    telemetry.log(DocumentPublished, {
      publishedImmediately: !(draft != null && draft._createdAt),
      previouslyPublished: !!published
    }), syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision ? setPublishScheduled(!0) : doPublish();
  }, [
    telemetry,
    draft == null ? void 0 : draft._createdAt,
    published,
    syncState.isSyncing,
    validationStatus.isValidating,
    validationStatus.revision,
    revision,
    doPublish
  ]);
  if (liveEdit)
    return {
      tone: "default",
      icon: PublishIcon,
      label: t("action.publish.live-edit.label"),
      title: t("action.publish.live-edit.tooltip"),
      disabled: !0
    };
  if (!isPermissionsLoading && !(permissions != null && permissions.granted))
    return {
      tone: "default",
      icon: PublishIcon,
      label: "Publish",
      title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "publish-document", currentUser }),
      disabled: !0
    };
  const disabled = !!(publishScheduled || (_a = editState == null ? void 0 : editState.transactionSyncLock) != null && _a.enabled || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "default",
    label: (
      // eslint-disable-next-line no-nested-ternary
      t(publishState === "published" ? "action.publish.published.label" : publishScheduled || publishState === "publishing" ? "action.publish.running.label" : "action.publish.draft.label")
    ),
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? t("action.publish.waiting") : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
const DISABLED_REASON_KEY = {
  NOT_PUBLISHED: "action.unpublish.disabled.not-published",
  NOT_READY: "action.unpublish.disabled.not-ready",
  LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled"
}, UnpublishAction = ({
  id,
  type,
  draft,
  onComplete,
  liveEdit
}) => {
  const { unpublish } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = useState(!1), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  }), currentUser = useCurrentUser(), { t } = useTranslation(structureLocaleNamespace), handleCancel = useCallback(() => {
    setConfirmDialogOpen(!1), onComplete();
  }, [onComplete]), handleConfirm = useCallback(() => {
    setConfirmDialogOpen(!1), unpublish.execute(), onComplete();
  }, [onComplete, unpublish]), dialog = useMemo(() => isConfirmDialogOpen ? {
    type: "dialog",
    onClose: onComplete,
    content: /* @__PURE__ */ jsx(
      ConfirmDeleteDialogContainer,
      {
        id: (draft == null ? void 0 : draft._id) || id,
        type,
        action: "unpublish",
        onCancel: handleCancel,
        onConfirm: handleConfirm
      }
    )
  } : null, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  return liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: UnpublishIcon,
    label: "Unpublish",
    title: /* @__PURE__ */ jsx(InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }),
    disabled: !0
  } : {
    tone: "critical",
    icon: UnpublishIcon,
    disabled: !!unpublish.disabled || isPermissionsLoading,
    label: t("action.unpublish.label"),
    title: unpublish.disabled ? t(DISABLED_REASON_KEY[unpublish.disabled]) : "",
    onHandle: () => setConfirmDialogOpen(!0),
    dialog
  };
};
UnpublishAction.action = "unpublish";
function DocumentStatusBarActionsInner(props) {
  const { disabled, showMenu, states } = props, { __internal_tasks } = useDocumentPane(), [firstActionState, ...menuActionStates] = states, [buttonElement, setButtonElement] = useState(null), tooltipContent = useMemo(() => !firstActionState || !firstActionState.title && !firstActionState.shortcut ? null : /* @__PURE__ */ jsxs(Flex, { style: { maxWidth: 300 }, align: "center", gap: 3, children: [
    firstActionState.title && /* @__PURE__ */ jsx(Text, { size: 1, children: firstActionState.title }),
    firstActionState.shortcut && /* @__PURE__ */ jsx(
      Hotkeys,
      {
        fontSize: 1,
        style: { marginTop: -4, marginBottom: -4 },
        keys: String(firstActionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
      }
    )
  ] }), [firstActionState]);
  return /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 1, children: [
    __internal_tasks && __internal_tasks.footerAction,
    firstActionState && /* @__PURE__ */ jsx(LayerProvider, { zOffset: 200, children: /* @__PURE__ */ jsx(Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: /* @__PURE__ */ jsx(Stack, { children: /* @__PURE__ */ jsx(
      Button,
      {
        "data-testid": `action-${firstActionState.label}`,
        disabled: disabled || !!firstActionState.disabled,
        icon: firstActionState.icon,
        onClick: firstActionState.onHandle,
        ref: setButtonElement,
        size: "large",
        text: firstActionState.label,
        tone: firstActionState.tone || "primary"
      }
    ) }) }) }),
    showMenu && menuActionStates.length > 0 && /* @__PURE__ */ jsx(ActionMenuButton, { actionStates: menuActionStates, disabled }),
    firstActionState && firstActionState.dialog && /* @__PURE__ */ jsx(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement })
  ] });
}
const DocumentStatusBarActions = memo(function() {
  const { actions, connectionState, documentId, editState } = useDocumentPane();
  return !actions || !editState ? null : /* @__PURE__ */ jsx(
    RenderActionCollectionState,
    {
      actions,
      actionProps: editState,
      group: "default",
      children: ({ states }) => /* @__PURE__ */ jsx(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected",
          showMenu: actions.length > 1,
          states
        },
        documentId
      )
    }
  );
}), HistoryStatusBarActions = memo(function() {
  const { connectionState, editState, timelineStore } = useDocumentPane(), revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime), revision = (revTime == null ? void 0 : revTime.id) || "", disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision, actionProps = useMemo(() => ({ ...editState || {}, revision }), [editState, revision]), historyActions = useMemo(() => [HistoryRestoreAction], []);
  return /* @__PURE__ */ jsx(
    RenderActionCollectionState,
    {
      actions: historyActions,
      actionProps,
      group: "default",
      children: ({ states }) => /* @__PURE__ */ jsx(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected" || !!disabled,
          showMenu: !1,
          states
        }
      )
    }
  );
}), StyledMotionPath = styled(motion.path)`
  transform-origin: center;
`, Circle = (props) => /* @__PURE__ */ jsx(motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props }), Arrows = (props) => /* @__PURE__ */ jsx(
  StyledMotionPath,
  {
    fill: "none",
    d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
    ...props
  }
), Checkmark = (props) => /* @__PURE__ */ jsx(motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props }), rotateAnimation = keyframes`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`, RotateGroup = styled.g`
  transform-origin: center;

  &[data-rotate] {
    animation: ${rotateAnimation} 1s ease-in-out infinite;
  }
`, root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: { transition: { duration: 0 } }
}, circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
}, arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
}, checkmark = {
  syncing: {
    pathLength: 0,
    transition: { duration: 0 }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
function AnimatedStatusIcon(props) {
  const { status } = props;
  return status ? /* @__PURE__ */ jsx(
    "svg",
    {
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.2",
      "data-sanity-icon": "animated-status-icon",
      children: /* @__PURE__ */ jsxs(motion.g, { variants: root, initial: status, animate: status, children: [
        /* @__PURE__ */ jsxs(RotateGroup, { "data-rotate": status === "changes" ? void 0 : "", children: [
          /* @__PURE__ */ jsx(Arrows, { variants: arrows, initial: status, animate: status }),
          /* @__PURE__ */ jsx(Circle, { variants: circle, initial: status, animate: status })
        ] }),
        /* @__PURE__ */ jsx(Checkmark, { variants: checkmark, initial: status, animate: status })
      ] })
    }
  ) : null;
}
const STATUS_DICTIONARY = {
  saved: {
    i18nKey: "status-bar.document-status-pulse.status.saved.text",
    tone: "positive"
  },
  syncing: {
    i18nKey: "status-bar.document-status-pulse.status.syncing.text",
    tone: "default"
  }
}, DocumentStatusPulse = (props) => {
  const { status } = props, { t } = useTranslation(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing")
    return null;
  const currentStatus = STATUS_DICTIONARY[status];
  return /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
    /* @__PURE__ */ jsx(TextWithTone, { size: 1, tone: currentStatus.tone, children: /* @__PURE__ */ jsx(AnimatedStatusIcon, { status }) }),
    /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t(currentStatus.i18nKey) })
  ] });
}, SYNCING_TIMEOUT = 1e3, SAVED_TIMEOUT = 3e3;
function DocumentStatusLine({ singleLine }) {
  const { documentId, documentType, editState, value } = useDocumentPane(), [status, setStatus] = useState(null), syncState = useSyncState(documentId, documentType), lastUpdated = value == null ? void 0 : value._updatedAt;
  return useEffect(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]), useLayoutEffect(() => {
    setStatus(null);
  }, [documentId]), useLayoutEffect(() => {
    syncState.isSyncing && setStatus("syncing");
  }, [syncState.isSyncing, lastUpdated]), status ? /* @__PURE__ */ jsx(DocumentStatusPulse, { status: status || void 0 }) : /* @__PURE__ */ jsx(
    Tooltip,
    {
      content: /* @__PURE__ */ jsx(DocumentStatus, { absoluteDate: !0, draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
      placement: "top",
      children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsx(DocumentStatusIndicator, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
        /* @__PURE__ */ jsx(
          DocumentStatus,
          {
            draft: editState == null ? void 0 : editState.draft,
            published: editState == null ? void 0 : editState.published,
            singleLine
          }
        )
      ] })
    }
  );
}
function useResizeObserver({
  element,
  onResize
}) {
  useLayoutEffect(() => (element && resizeObserver.observe(element, onResize), () => {
    element && resizeObserver.unobserve(element);
  }), [element, onResize]);
}
const CONTAINER_BREAKPOINT = 480;
function DocumentStatusBar(props) {
  const { actionsBoxRef } = props, { editState, timelineStore } = useDocumentPane(), showingRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), [collapsed, setCollapsed] = useState(null), [rootElement, setRootElement] = useState(null), handleResize = useCallback((event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, []);
  useResizeObserver({ element: rootElement, onResize: handleResize });
  const shouldRender = (editState == null ? void 0 : editState.ready) && typeof collapsed == "boolean";
  return /* @__PURE__ */ jsx(Flex, { direction: "column", ref: setRootElement, sizing: "border", children: shouldRender && /* @__PURE__ */ jsxs(
    Flex,
    {
      align: "stretch",
      gap: 1,
      justify: "space-between",
      paddingY: 2,
      paddingLeft: 4,
      paddingRight: 3,
      children: [
        /* @__PURE__ */ jsxs(Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [
          /* @__PURE__ */ jsxs(Flex, { align: "center", children: [
            /* @__PURE__ */ jsx(DocumentStatusLine, { singleLine: !collapsed }),
            /* @__PURE__ */ jsx(SpacerButton, { size: "large" })
          ] }),
          /* @__PURE__ */ jsx(DocumentBadges, {})
        ] }),
        /* @__PURE__ */ jsxs(
          Flex,
          {
            align: "flex-start",
            justify: "flex-end",
            ref: actionsBoxRef,
            style: { flexShrink: 0, marginLeft: "auto" },
            children: [
              /* @__PURE__ */ jsx(SpacerButton, { size: "large" }),
              showingRevision ? /* @__PURE__ */ jsx(HistoryStatusBarActions, {}) : /* @__PURE__ */ jsx(DocumentStatusBarActions, {})
            ]
          }
        )
      ]
    }
  ) });
}
function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    as = "div",
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props, activeAction = states[activeIndex], handleKeyDown = useCallback(
    (event) => {
      const matchingStates = states.filter(
        (state2) => state2.shortcut && isHotkey(state2.shortcut, event)
      ), matchingState = matchingStates[0];
      if (matchingStates.length > 1 && console.warn(
        `Keyboard shortcut conflict: More than one document action matches the shortcut "${matchingState.shortcut}"`
      ), matchingState && !matchingState.disabled && matchingState.onHandle) {
        event.preventDefault(), matchingState.onHandle(), onActionStart(states.indexOf(matchingState));
        return;
      }
      onKeyDown && onKeyDown(event);
    },
    [onActionStart, onKeyDown, states]
  );
  return createElement(
    as,
    {
      id,
      onKeyDown: handleKeyDown,
      tabIndex: -1,
      ...rest,
      ref: rootRef
    },
    [
      children,
      activeAction && activeAction.dialog && /* @__PURE__ */ jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsx(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) })
    ]
  );
}
const DocumentActionShortcuts = memo(
  (props) => {
    const { actionsBoxElement, as = "div", children, ...rest } = props, { actions, editState } = useDocumentPane(), [activeIndex, setActiveIndex] = useState(-1), onActionStart = useCallback((idx) => {
      setActiveIndex(idx);
    }, []), actionProps = useMemo(
      () => editState && {
        ...editState,
        // @todo: what to call here?
        onComplete: () => {
        },
        // @todo: get revision string
        revision: void 0
      },
      [editState]
    );
    return !actionProps || !actions ? null : /* @__PURE__ */ jsx(RenderActionCollectionState, { actionProps, actions, children: ({ states }) => /* @__PURE__ */ jsx(
      KeyboardShortcutResponder,
      {
        ...rest,
        activeIndex,
        actionsBoxElement,
        as,
        onActionStart,
        states,
        children
      }
    ) });
  }
);
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
function getInspectorItems({
  currentInspector,
  hasValue,
  inspectors: inspectors2,
  inspectorMenuItems
}) {
  return inspectors2.map((inspector, index) => {
    var _a;
    const menuItem = inspectorMenuItems[index];
    return !menuItem || menuItem.hidden ? null : {
      action: `${INSPECT_ACTION_PREFIX}${inspector.name}`,
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      isDisabled: !hasValue,
      selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name,
      shortcut: (_a = menuItem.hotkeys) == null ? void 0 : _a.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem({ hasValue, t }) {
  return {
    action: "inspect",
    group: "inspectors",
    title: t("document-inspector.menu-item.title"),
    icon: JsonIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getProductionPreviewItem({ previewUrl, t }) {
  return previewUrl ? {
    action: "production-preview",
    group: "links",
    title: t("production-preview.menu-item.title"),
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  } : null;
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params), items = [
    // Get production preview item
    getProductionPreviewItem(params)
  ].filter(Boolean);
  return [
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
const isSanityDocument = (value) => isRecord(value) && typeof value._id == "string" && typeof value._type == "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = useState(void 0), [error, setError] = useState(null), { resolveProductionUrl } = useSource().document, value$ = useAsObservable(value);
  if (error) throw error;
  return useEffect(() => {
    value$.pipe(
      // this so that the preview URL isn't fetched on every keystroke
      debounceTime(500),
      switchMap(
        (document2) => isSanityDocument(document2) ? from(resolveProductionUrl({ document: document2 })) : of(void 0)
      ),
      catchError((e) => {
        const message = isRecord(e) && typeof e.message == "string" ? e.message : "Unknown error";
        throw new Error(`An error was thrown while trying to get your preview url: ${message}`);
      })
    ).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]), previewUrl;
}
function DocumentLayoutError(props) {
  const { documentType, value, currentMinWidth, paneKey, minWidth } = props, { t } = useTranslation();
  return /* @__PURE__ */ jsx(
    ErrorPane,
    {
      currentMinWidth,
      flex: 2.5,
      minWidth,
      paneKey,
      title: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-unknown-type.title",
          values: { documentType }
        }
      ),
      tone: "caution",
      children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
        documentType && /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(
          Translate,
          {
            t,
            i18nKey: "panes.document-pane.document-unknown-type.text",
            values: { documentType }
          }
        ) }),
        !documentType && /* @__PURE__ */ jsx(Text, { as: "p", children: t("panes.document-pane.document-unknown-type.without-schema.text") }),
        isDev && value && /* eslint-disable i18next/no-literal-string */
        /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Text, { as: "p", children: "Here is the JSON representation of the document:" }),
          /* @__PURE__ */ jsx(Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsx(Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })
        ] })
      ] })
    }
  );
}
const EMPTY_ARRAY$1 = [], DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
], StyledChangeConnectorRoot = styled(ChangeConnectorRoot)`
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 0;
`;
function DocumentLayout() {
  const {
    changesOpen,
    documentId,
    documentType,
    fieldActions,
    inspectOpen,
    inspector,
    inspectors: inspectors2,
    onFocus,
    onHistoryOpen,
    onMenuAction,
    onPathOpen,
    paneKey,
    schemaType,
    value
  } = useDocumentPane(), { features } = useStructureTool(), { t } = useTranslation$1(structureLocaleNamespace), { collapsed: layoutCollapsed } = usePaneLayout(), zOffsets = useZIndex(), previewUrl = usePreviewUrl(value), [rootElement, setRootElement] = useState(null), [footerElement, setFooterElement] = useState(null), [headerElement, setHeaderElement] = useState(null), [actionsBoxElement, setActionsBoxElement] = useState(null), [documentPanelPortalElement, setDocumentPanelPortalElement] = useState(
    null
  ), [inspectorMenuItems, setInspectorMenuItems] = useState([]), [rootFieldActionNodes, setRootFieldActionNodes] = useState([]), footerRect = useElementRect(footerElement), headerRect = useElementRect(headerElement), footerHeight = footerRect == null ? void 0 : footerRect.height, headerHeight = headerRect == null ? void 0 : headerRect.height, currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), currentInspector = useMemo(
    () => inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === (inspector == null ? void 0 : inspector.name)),
    [inspectors2, inspector == null ? void 0 : inspector.name]
  ), hasValue = !!value, menuItems = useMemo(
    () => getMenuItems({
      currentInspector,
      features,
      hasValue,
      inspectorMenuItems,
      inspectors: inspectors2,
      previewUrl,
      t
    }),
    [currentInspector, features, hasValue, inspectorMenuItems, inspectors2, previewUrl, t]
  ), handleKeyUp = useCallback(
    (event) => {
      for (const item of menuItems)
        if (item.shortcut && isHotkey(item.shortcut, event)) {
          event.preventDefault(), event.stopPropagation(), onMenuAction(item);
          return;
        }
    },
    [onMenuAction, menuItems]
  ), onConnectorSetFocus = useCallback(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onPathOpen, onFocus]
  );
  return schemaType ? /* @__PURE__ */ jsxs(Fragment, { children: [
    inspectors2.length > 0 && /* @__PURE__ */ jsx(
      DocumentInspectorMenuItemsResolver,
      {
        documentId,
        documentType,
        inspectors: inspectors2,
        onMenuItems: setInspectorMenuItems
      }
    ),
    fieldActions.length > 0 && schemaType && /* @__PURE__ */ jsx(
      FieldActionsResolver,
      {
        actions: fieldActions,
        documentId,
        documentType,
        onActions: setRootFieldActionNodes,
        path: EMPTY_ARRAY$1,
        schemaType
      }
    ),
    /* @__PURE__ */ jsx(FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY$1, children: /* @__PURE__ */ jsxs(
      DocumentActionShortcuts,
      {
        actionsBoxElement,
        as: Pane,
        currentMinWidth,
        "data-testid": "document-pane",
        flex: 2.5,
        id: paneKey,
        minWidth,
        onKeyUp: handleKeyUp,
        rootRef: setRootElement,
        children: [
          /* @__PURE__ */ jsx(DocumentPanelHeader, { ref: setHeaderElement, menuItems }),
          /* @__PURE__ */ jsx(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.paneDialog, children: /* @__PURE__ */ jsx(Flex, { direction: "column", flex: 1, height: layoutCollapsed ? void 0 : "fill", children: /* @__PURE__ */ jsx(
            StyledChangeConnectorRoot,
            {
              "data-testid": "change-connector-root",
              isReviewChangesOpen: changesOpen,
              onOpenReviewChanges: onHistoryOpen,
              onSetFocus: onConnectorSetFocus,
              children: /* @__PURE__ */ jsx(
                DocumentPanel,
                {
                  footerHeight: footerHeight || null,
                  headerHeight: headerHeight || null,
                  isInspectOpen: inspectOpen,
                  rootElement,
                  setDocumentPanelPortalElement
                }
              )
            }
          ) }) }),
          /* @__PURE__ */ jsx(
            PortalProvider,
            {
              __unstable_elements: { [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement },
              children: /* @__PURE__ */ jsx(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.portal, children: /* @__PURE__ */ jsx(PaneFooter, { ref: setFooterElement, children: /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement }) }) }) })
            }
          ),
          /* @__PURE__ */ jsx(DocumentOperationResults, {})
        ]
      }
    ) })
  ] }) : /* @__PURE__ */ jsx(
    DocumentLayoutError,
    {
      currentMinWidth,
      documentType,
      minWidth,
      paneKey,
      value
    }
  );
}
function pick(plugin) {
  var _a, _b;
  return (_b = (_a = plugin.document) == null ? void 0 : _a.components) == null ? void 0 : _b.unstable_layout;
}
function useDocumentLayoutComponent() {
  return useMiddlewareComponents({
    pick,
    defaultComponent: DocumentLayout
  });
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {}, structureNodeTemplate = opts.templateName;
  opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate && console.warn(
    `Conflicting templates: URL says "${opts.urlTemplate}", structure node says "${structureNodeTemplate}". Using "${structureNodeTemplate}".`
  );
  const template = structureNodeTemplate || opts.urlTemplate, typeTemplates = templates.filter((t) => t.schemaType === opts.documentType), templateParams = {
    ...opts.templateParams,
    ...typeof payload == "object" ? payload || {} : {}
  };
  let templateName = template;
  return !template && typeTemplates.length === 1 && (templateName = typeTemplates[0].id), { templateName, templateParams };
}
const DocumentPaneProvider = memo((props) => {
  const { children, index, pane: pane2, paneKey, onFocusPath } = props, schema = useSchema(), templates = useTemplates(), {
    __internal_tasks,
    document: {
      actions: documentActions2,
      badges: documentBadges2,
      unstable_fieldActions: fieldActionsResolver,
      unstable_languageFilter: languageFilterResolver,
      inspectors: inspectorsResolver
    }
  } = useSource(), presenceStore = usePresenceStore(), paneRouter = usePaneRouter(), setPaneParams = paneRouter.setParams, { features } = useStructureTool(), { push: pushToast } = useToast(), {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane2, paneOptions = useUnique(options), documentIdRaw = paneOptions.id, documentId = getPublishedId(documentIdRaw), documentType = options.type, params = useUnique(paneRouter.params) || EMPTY_PARAMS$1, panePayload = useUnique(paneRouter.payload), { templateName, templateParams } = useMemo(
    () => getInitialValueTemplateOpts(templates, {
      documentType,
      templateName: paneOptions.template,
      templateParams: paneOptions.templateParameters,
      panePayload,
      urlTemplate: params.template
    }),
    [documentType, paneOptions, params, panePayload, templates]
  ), initialValueRaw = useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  }), initialValue = useUnique(initialValueRaw), { patch } = useDocumentOperation(documentId, documentType), editState = useEditState(documentId, documentType), { validation: validationRaw } = useValidationStatus(documentId, documentType), connectionState = useConnectionState(documentId, documentType), schemaType = schema.get(documentType), value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value, [isDeleting, setIsDeleting] = useState(!1), actions = useMemo(
    () => documentActions2({ schemaType: documentType, documentId }),
    [documentActions2, documentId, documentType]
  ), badges = useMemo(
    () => documentBadges2({ schemaType: documentType, documentId }),
    [documentBadges2, documentId, documentType]
  ), languageFilter = useMemo(
    () => languageFilterResolver({ schemaType: documentType, documentId }),
    [documentId, documentType, languageFilterResolver]
  ), validation = useUnique(validationRaw), views2 = useUnique(viewsProp), [focusPath, setFocusPath] = useState(
    () => params.path ? fromString(params.path) : EMPTY_ARRAY$3
  ), focusPathRef = useRef([]), activeViewId = params.view || views2[0] && views2[0].id || null, [timelineMode, setTimelineMode] = useState("closed"), [timelineError, setTimelineError] = useState(null);
  useEffect(() => {
    params.prefersLatestPublished && editState.published && setPaneParams({
      //ensure we only run on first load
      ...omit(params, "prefersLatestPublished"),
      rev: `${editState.published._updatedAt}/${editState.published._rev}`
    });
  }, [editState, setPaneParams, params]);
  const timelineStore = useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  }), onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime), sinceAttributes = useTimelineSelector(timelineStore, (state2) => state2.sinceAttributes), timelineDisplayed = useTimelineSelector(timelineStore, (state2) => state2.timelineDisplayed), timelineReady = useTimelineSelector(timelineStore, (state2) => state2.timelineReady), isPristine = useTimelineSelector(timelineStore, (state2) => state2.isPristine), isDeleted = useMemo(() => timelineReady ? !(editState != null && editState.draft) && !(editState != null && editState.published) && !isPristine : !1, [editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, isPristine, timelineReady]), previewUrl = usePreviewUrl(value), [presence, setPresence] = useState([]);
  useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors2 = useMemo(
    () => inspectorsResolver({ documentId, documentType }),
    [documentId, documentType, inspectorsResolver]
  ), [inspectorName, setInspectorName] = useState(() => params.inspect || null), inspectParamRef = useRef(params.inspect);
  useEffect(() => {
    inspectParamRef.current !== params.inspect && (inspectParamRef.current = params.inspect, setInspectorName(params.inspect || null));
  }, [params.inspect]);
  const currentInspector = inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === inspectorName), resolvedChangesInspector = inspectors2.find((i) => i.name === HISTORY_INSPECTOR_NAME), changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME, { t } = useTranslation(structureLocaleNamespace), inspectOpen = params.inspect === "on", compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null, fieldActions = useMemo(
    () => schemaType ? fieldActionsResolver({ documentId, documentType, schemaType }) : [],
    [documentId, documentType, fieldActionsResolver, schemaType]
  ), ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError), displayed = useMemo(
    () => onOlderRevision ? timelineDisplayed || { _id: value._id, _type: value._type } : value,
    [onOlderRevision, timelineDisplayed, value]
  ), setTimelineRange = useCallback(
    (newSince, newRev) => {
      setPaneParams({
        ...params,
        since: newSince,
        rev: newRev || void 0
      });
    },
    [params, setPaneParams]
  ), handleBlur = useCallback(
    (blurredPath) => {
      disableBlurRef.current || (setFocusPath(EMPTY_ARRAY$3), focusPathRef.current !== EMPTY_ARRAY$3 && (focusPathRef.current = EMPTY_ARRAY$3, onFocusPath == null || onFocusPath(EMPTY_ARRAY$3)));
    },
    [onFocusPath, setFocusPath]
  ), patchRef = useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = useCallback((event) => patchRef.current(event), []), closeInspector = useCallback(
    (closeInspectorName) => {
      var _a, _b, _c, _d;
      const inspector = closeInspectorName && inspectors2.find((i) => i.name === closeInspectorName);
      if (closeInspectorName && !inspector) {
        console.warn(`No inspector named "${closeInspectorName}"`);
        return;
      }
      if (currentInspector) {
        if (inspector) {
          const result = (_b = (_a = inspector.onClose) == null ? void 0 : _a.call(inspector, { params })) != null ? _b : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
          return;
        }
        if (currentInspector) {
          const result = (_d = (_c = currentInspector.onClose) == null ? void 0 : _c.call(currentInspector, { params })) != null ? _d : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
        }
      }
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), openInspector = useCallback(
    (nextInspectorName, paneParams) => {
      var _a, _b, _c, _d;
      const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
      if (!nextInspector) {
        console.warn(`No inspector named "${nextInspectorName}"`);
        return;
      }
      if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
        setPaneParams({ ...params, ...paneParams, inspect: nextInspector.name });
        return;
      }
      let currentParams = params;
      currentInspector && (currentParams = ((_b = (_a = nextInspector.onClose) == null ? void 0 : _a.call(nextInspector, { params: currentParams })) != null ? _b : {
        params: currentParams
      }).params);
      const result = (_d = (_c = nextInspector.onOpen) == null ? void 0 : _c.call(nextInspector, { params: currentParams })) != null ? _d : { params: currentParams };
      setInspectorName(nextInspector.name), inspectParamRef.current = nextInspector.name, setPaneParams({ ...result.params, ...paneParams, inspect: nextInspector.name });
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), handleHistoryClose = useCallback(() => {
    resolvedChangesInspector && closeInspector(resolvedChangesInspector.name);
  }, [closeInspector, resolvedChangesInspector]), handleHistoryOpen = useCallback(() => {
    features.reviewChanges && resolvedChangesInspector && openInspector(resolvedChangesInspector.name);
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]), handlePaneClose = useCallback(() => paneRouter.closeCurrent(), [paneRouter]), handlePaneSplit = useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]), toggleLegacyInspect = useCallback(
    (toggle = !inspectOpen) => {
      setPaneParams(toggle ? { ...params, inspect: "on" } : omit(params, "inspect"));
    },
    [inspectOpen, params, setPaneParams]
  ), handleMenuAction = useCallback(
    (item) => {
      if (item.action === "production-preview" && previewUrl)
        return window.open(previewUrl), !0;
      if (item.action === "inspect")
        return toggleLegacyInspect(!0), !0;
      if (item.action === "reviewChanges")
        return handleHistoryOpen(), !0;
      if (typeof item.action == "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
        const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length), nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
        if (nextInspector)
          return nextInspector.name === inspectorName ? closeInspector(nextInspector.name) : openInspector(nextInspector.name), !0;
      }
      return !1;
    },
    [
      closeInspector,
      handleHistoryOpen,
      inspectorName,
      inspectors2,
      openInspector,
      previewUrl,
      toggleLegacyInspect
    ]
  ), handleLegacyInspectClose = useCallback(
    () => toggleLegacyInspect(!1),
    [toggleLegacyInspect]
  ), [openPath, onSetOpenPath] = useState([]), [fieldGroupState, onSetFieldGroupState] = useState(), [collapsedPaths, onSetCollapsedPath] = useState(), [collapsedFieldSets, onSetCollapsedFieldSets] = useState(), handleOnSetCollapsedPath = useCallback((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = useCallback((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = useCallback(
    (path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)),
    []
  ), requiredPermission = value._createdAt ? "update" : "create", liveEdit = !!(schemaType != null && schemaType.liveEdit), docId = value._id ? value._id : "dummy-id", docPermissionsInput = useMemo(() => ({
    ...value,
    _id: liveEdit ? getPublishedId(docId) : getDraftId(docId)
  }), [liveEdit, value, docId]), [permissions, isPermissionsLoading] = useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  }), isNonExistent = !(value != null && value._id), readOnly = useMemo(() => {
    var _a;
    const hasNoPermission = !isPermissionsLoading && !(permissions != null && permissions.granted), updateActionDisabled = !isActionEnabled(schemaType, "update"), createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create"), reconnecting = connectionState === "reconnecting", isLocked = (_a = editState.transactionSyncLock) == null ? void 0 : _a.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked || isDeleting || isDeleted;
  }, [
    connectionState,
    editState.transactionSyncLock,
    isNonExistent,
    isDeleted,
    isDeleting,
    isPermissionsLoading,
    permissions == null ? void 0 : permissions.granted,
    ready,
    revTime,
    schemaType
  ]), formState = useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  }), formStateRef = useRef(formState);
  formStateRef.current = formState;
  const setOpenPath = useCallback(
    (path) => {
      getExpandOperations(formStateRef.current, path).forEach((op) => {
        op.type === "expandPath" && onSetCollapsedPath((prevState) => setAtPath(prevState, op.path, !1)), op.type === "expandFieldSet" && onSetCollapsedFieldSets((prevState) => setAtPath(prevState, op.path, !1)), op.type === "setSelectedGroup" && onSetFieldGroupState((prevState) => setAtPath(prevState, op.path, op.groupName));
      }), onSetOpenPath(path);
    },
    [formStateRef]
  ), updatePresence = useCallback(
    (nextFocusPath, payload) => {
      presenceStore.setLocation([
        {
          type: "document",
          documentId,
          path: nextFocusPath,
          lastActiveAt: (/* @__PURE__ */ new Date()).toISOString(),
          selection: payload == null ? void 0 : payload.selection
        }
      ]);
    },
    [documentId, presenceStore]
  ), updatePresenceThrottled = useMemo(
    () => throttle(updatePresence, 1e3, { leading: !0, trailing: !0 }),
    [updatePresence]
  ), handleFocus = useCallback(
    (nextFocusPath, payload) => {
      setFocusPath(nextFocusPath), deepEquals(focusPathRef.current, nextFocusPath) || (setOpenPath(nextFocusPath.slice(0, -1)), focusPathRef.current = nextFocusPath, onFocusPath == null || onFocusPath(nextFocusPath)), updatePresenceThrottled(nextFocusPath, payload);
    },
    [onFocusPath, setOpenPath, updatePresenceThrottled]
  ), documentPane = useMemo(
    () => ({
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      inspector: currentInspector || null,
      inspectors: inspectors2,
      __internal_tasks,
      onBlur: handleBlur,
      onChange: handleChange,
      onFocus: handleFocus,
      onPathOpen: setOpenPath,
      onHistoryClose: handleHistoryClose,
      onHistoryOpen: handleHistoryOpen,
      onInspectClose: handleLegacyInspectClose,
      onMenuAction: handleMenuAction,
      onPaneClose: handlePaneClose,
      onPaneSplit: handlePaneSplit,
      onSetActiveFieldGroup: handleSetActiveFieldGroup,
      onSetCollapsedPath: handleOnSetCollapsedPath,
      onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
      openInspector,
      index,
      inspectOpen,
      validation,
      menuItemGroups: menuItemGroups || [],
      paneKey,
      previewUrl,
      ready,
      schemaType,
      isPermissionsLoading,
      permissions,
      setTimelineMode,
      setTimelineRange,
      setIsDeleting,
      isDeleting,
      isDeleted,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      value,
      views: views2,
      formState,
      unstable_languageFilter: languageFilter
    }),
    [
      __internal_tasks,
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      currentInspector,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      formState,
      handleBlur,
      handleChange,
      handleFocus,
      handleHistoryClose,
      handleHistoryOpen,
      handleLegacyInspectClose,
      handleMenuAction,
      handleOnSetCollapsedFieldSet,
      handleOnSetCollapsedPath,
      handlePaneClose,
      handlePaneSplit,
      handleSetActiveFieldGroup,
      index,
      inspectOpen,
      inspectors2,
      isDeleted,
      isDeleting,
      isPermissionsLoading,
      languageFilter,
      menuItemGroups,
      openInspector,
      paneKey,
      permissions,
      previewUrl,
      ready,
      schemaType,
      setOpenPath,
      setTimelineRange,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      validation,
      value,
      views2
    ]
  );
  useEffect(() => {
    connectionState === "reconnecting" && pushToast({
      id: "sanity/structure/reconnecting",
      status: "warning",
      title: t("panes.document-pane-provider.reconnecting.title")
    });
  }, [connectionState, pushToast, t]);
  const disableBlurRef = useRef(!1);
  return useEffect(() => {
    var _a;
    if (ready && params.path) {
      const { path, ...restParams } = params, pathFromUrl = resolveKeyedPath((_a = formStateRef.current) == null ? void 0 : _a.value, fromString(path));
      disableBlurRef.current = !0, deepEquals(focusPathRef.current, pathFromUrl) || (setFocusPath(pathFromUrl), setOpenPath(pathFromUrl), focusPathRef.current = pathFromUrl, onFocusPath == null || onFocusPath(pathFromUrl));
      const timeout = setTimeout(() => {
        disableBlurRef.current = !1;
      }, 0);
      return paneRouter.setParams(restParams), () => clearTimeout(timeout);
    }
  }, [params, documentId, onFocusPath, setOpenPath, ready, paneRouter]), /* @__PURE__ */ jsx(DocumentPaneContext.Provider, { value: documentPane, children });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
const DocumentPane = memo(function(props) {
  const { name: parentSourceName } = useSource();
  return /* @__PURE__ */ jsx(SourceProvider, { name: props.pane.source || parentSourceName, children: /* @__PURE__ */ jsx(DocumentPaneInner, { ...props }) });
});
function DocumentPaneInner(props) {
  var _a;
  const { pane: pane2, paneKey } = props, { resolveNewDocumentOptions } = useSource().document, paneRouter = usePaneRouter(), options = usePaneOptions(pane2.options, paneRouter.params), { documentType, isLoaded: isDocumentLoaded } = useDocumentType(options.id, options.type), DocumentLayout2 = useDocumentLayoutComponent(), templateItems = useMemo(() => resolveNewDocumentOptions({
    type: "document",
    documentId: options.id,
    schemaType: options.type
  }), [options.id, options.type, resolveNewDocumentOptions]), [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  }), isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading, providerProps = useMemo(() => isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props, [props, documentType, isLoaded, options]), { ReferenceChildLink: ReferenceChildLink2, handleEditReference, groupIndex, routerPanesState } = paneRouter, childParams = ((_a = routerPanesState[groupIndex + 1]) == null ? void 0 : _a[0].params) || {}, routerPanesStateLength = routerPanesState.length, { parentRefPath } = childParams, activePath = useMemo(() => parentRefPath ? {
    path: fromString(parentRefPath),
    state: (
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    )
  } : { path: [], state: "none" }, [parentRefPath, groupIndex, routerPanesStateLength]), { t } = useTranslation(structureLocaleNamespace);
  return options.type === "*" && !isLoaded ? /* @__PURE__ */ jsx(
    LoadingPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.loading")
    }
  ) : documentType ? /* @__PURE__ */ jsx(
    DocumentPaneProvider,
    {
      ...providerProps,
      children: /* @__PURE__ */ jsx(
        ReferenceInputOptionsProvider,
        {
          EditReferenceLinkComponent: ReferenceChildLink2,
          onEditReference: handleEditReference,
          initialValueTemplateItems: templatePermissions,
          activePath,
          children: /* @__PURE__ */ jsx(CommentsWrapper, { documentId: options.id, documentType: options.type, children: /* @__PURE__ */ jsx(DocumentLayout2, { documentId: options.id, documentType: options.type }) })
        }
      )
    },
    `${documentType}-${options.id}`
  ) : /* @__PURE__ */ jsx(
    ErrorPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.title"),
      children: /* @__PURE__ */ jsx(Stack, { space: 4, children: /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-not-found.text",
          values: { id: options.id }
        }
      ) }) })
    }
  );
}
function usePaneOptions(options, params = {}) {
  const templates = useTemplates();
  return useMemo(() => {
    if (options.type && options.type !== "*")
      return options;
    const templateName = options.template || params.template, template = templateName ? templates.find((t) => t.id === templateName) : void 0, documentType = template == null ? void 0 : template.schemaType;
    return documentType ? { ...options, type: documentType } : options;
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: { ...options, type: documentType }
    }
  };
}
const PARTIAL_PAGE_LIMIT = 100, FULL_LIST_LIMIT = 2e3, DEFAULT_ORDERING = { by: [{ field: "_updatedAt", direction: "desc" }] }, EMPTY_RECORD = {}, RootBox = styled(Box)`
  position: relative;
`, CommandListBox = styled(Box)`
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
`, SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const { layout } = props;
  return /* @__PURE__ */ jsx(Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: SKELETON_ITEMS.map((num) => /* @__PURE__ */ jsx(SanityDefaultPreview, { isPlaceholder: !0, layout }, num)) });
}
function DocumentListPaneContent(props) {
  const {
    childItemId,
    error,
    filterIsSimpleTypeConstraint,
    hasMaxItems,
    hasSearchQuery,
    isActive,
    isLazyLoading,
    isLoading,
    items,
    layout,
    loadingVariant,
    onListChange,
    onRetry,
    paneTitle,
    searchInputElement,
    showIcons
  } = props, schema = useSchema(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed, index } = usePane(), [shouldRender, setShouldRender] = useState(!1), { t } = useTranslation(structureLocaleNamespace), handleEndReached = useCallback(() => {
    isLoading || isLazyLoading || !shouldRender || onListChange();
  }, [isLazyLoading, isLoading, onListChange, shouldRender]);
  useEffect(() => {
    if (collapsed) return;
    const timer2 = setTimeout(() => {
      setShouldRender(!0);
    }, 0);
    return () => {
      clearTimeout(timer2);
    };
  }, [collapsed, items]);
  const renderItem = useCallback(
    (item, { activeIndex }) => {
      const publishedId = getPublishedId(item._id), isSelected = childItemId === publishedId, pressed = !isActive && isSelected, selected = isActive && isSelected, isLastItem = activeIndex === items.length - 1, showSpinner = isLastItem && isLazyLoading, showMaxItemsMessage = isLastItem && hasMaxItems;
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          PaneItem,
          {
            icon: showIcons === !1 ? !1 : void 0,
            id: publishedId,
            layout,
            marginBottom: 1,
            pressed,
            schemaType: schema.get(item._type),
            selected,
            value: item
          }
        ),
        showSpinner && /* @__PURE__ */ jsx(LoadingBlock, {}),
        showMaxItemsMessage && /* @__PURE__ */ jsx(Box, { marginY: 1, paddingX: 3, paddingY: 4, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, size: 1, children: t("panes.document-list-pane.max-items.text", { limit: FULL_LIST_LIMIT }) }) })
      ] });
    },
    [childItemId, isActive, items.length, layout, schema, showIcons, hasMaxItems, isLazyLoading, t]
  ), noDocumentsContent = useMemo(() => hasSearchQuery ? /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container, { width: 1, children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, children: t("panes.document-list-pane.no-documents.text") }) }) }) }) : /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container, { width: 1, children: /* @__PURE__ */ jsx(Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsx(Text, { align: "center", muted: !0, children: t(filterIsSimpleTypeConstraint ? "panes.document-list-pane.no-documents-of-type.text" : "panes.document-list-pane.no-matching-documents.text") }) }) }) }), [filterIsSimpleTypeConstraint, hasSearchQuery, t]), mainContent = useMemo(() => {
    if (!shouldRender)
      return null;
    if (error)
      return /* @__PURE__ */ jsx(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container, { width: 1, children: /* @__PURE__ */ jsxs(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [
        /* @__PURE__ */ jsx(Heading, { as: "h3", children: t("panes.document-list-pane.error.title") }),
        /* @__PURE__ */ jsx(Text, { as: "p", children: /* @__PURE__ */ jsx(
          Translate,
          {
            t,
            i18nKey: "panes.document-list-pane.error.text",
            values: { error: error.message },
            components: { Code: ({ children }) => /* @__PURE__ */ jsx("code", { children }) }
          }
        ) }),
        onRetry && /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
          Button,
          {
            icon: SyncIcon,
            onClick: onRetry,
            text: t("panes.document-list-pane.error.retry-button.text"),
            tone: "primary"
          }
        ) })
      ] }) }) });
    if (!isLoading && items.length === 0)
      return noDocumentsContent;
    if (loadingVariant === "initial" && isLoading)
      return /* @__PURE__ */ jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsx(LoadingView, { layout }) });
    if (loadingVariant === "spinner" && isLoading)
      return null;
    const key = `${index}-${collapsed}`;
    return /* @__PURE__ */ jsx(RootBox, { overflow: "hidden", height: "fill", children: /* @__PURE__ */ jsx(CommandListBox, { children: /* @__PURE__ */ jsx(
      CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: paneTitle,
        canReceiveFocus: !0,
        inputElement: searchInputElement,
        itemHeight: 51,
        items,
        onEndReached: handleEndReached,
        onlyShowSelectionWhenActive: !0,
        overscan: 10,
        paddingBottom: 1,
        paddingX: 3,
        renderItem,
        wrapAround: !1
      },
      key
    ) }) });
  }, [
    collapsed,
    error,
    handleEndReached,
    index,
    isLoading,
    items,
    layout,
    loadingVariant,
    // noDocumentsContent,
    onRetry,
    renderItem,
    searchInputElement,
    shouldRender
  ]);
  return /* @__PURE__ */ jsx(
    PaneContent,
    {
      "data-testid": "document-list-pane",
      overflow: layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto",
      children: mainContent
    }
  );
}
function removePublishedWithDrafts(documents) {
  return collate(documents).map((entry) => ({
    ...entry.draft || entry.published,
    hasPublished: !!entry.published,
    hasDraft: !!entry.draft
  }));
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy = order.by.map((by) => {
    if (by.mapWith)
      return by;
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    return fieldType ? fieldExtendsType(fieldType, "datetime") ? { ...by, mapWith: "dateTime" } : fieldType.jsonType === "string" ? { ...by, mapWith: "lower" } : by : by;
  });
  return orderBy.every((item, index) => item === order.by[index]) ? order : { ...order, by: orderBy };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = PathUtils.fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current)
      return;
    if (typeof segment == "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    if (!(isKeySegment(segment) || isIndexSegment(segment)) || current.jsonType !== "array")
      return;
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType)
      return;
    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType)
      return;
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type))
    return;
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  for (; current; ) {
    if (current.name === ofType || !current.type && current.jsonType === ofType)
      return !0;
    current = current.type;
  }
  return !1;
}
function findTypes(node) {
  switch (node.type) {
    case "OpCall": {
      const { left, right } = node;
      switch (node.op) {
        case "==":
          return left.type === "AccessAttribute" && left.name === "_type" && !left.base ? right.type !== "Value" || typeof right.value != "string" ? null : /* @__PURE__ */ new Set([right.value]) : right.type === "AccessAttribute" && right.name === "_type" && !right.base ? left.type !== "Value" || typeof left.value != "string" ? null : /* @__PURE__ */ new Set([left.value]) : null;
        case "in": {
          if (left.type !== "AccessAttribute" || left.name !== "_type" || left.base || right.type !== "Array") return null;
          const types = /* @__PURE__ */ new Set();
          for (const element of right.elements) {
            if (element.isSplat || element.value.type !== "Value" || typeof element.value.value != "string") return null;
            types.add(element.value.value);
          }
          return types.size ? types : null;
        }
        default:
          return null;
      }
    }
    case "Group":
      return findTypes(node.base);
    case "Or": {
      const left = findTypes(node.left);
      if (!left) return null;
      const right = findTypes(node.right);
      return right ? /* @__PURE__ */ new Set([...left, ...right]) : null;
    }
    case "And": {
      const left = findTypes(node.left), right = findTypes(node.right);
      return !left && !right ? null : /* @__PURE__ */ new Set([...left || [], ...right || []]);
    }
    default:
      return null;
  }
}
function findStaticTypesInFilter(filter2, params = {}) {
  try {
    const types = findTypes(parse(filter2, { params }));
    return types ? Array.from(types).sort() : null;
  } catch {
    return null;
  }
}
const IMPLICIT_SCHEMA_TYPE_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path, strict = !1) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType))
    return "";
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_SCHEMA_TYPE_FIELDS.includes(head)) {
      const errorMessage = `The current ordering config targeted the nonexistent field "${head}" on schema type "${schemaType.name}". It should be one of ${schemaType.fields.map((field) => field.name).join(", ")}`;
      if (strict)
        throw new Error(errorMessage);
      console.warn(errorMessage);
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return `${head}->{${refTypes.map((refType) => joinReferences(refType, tail)).join(",")}}`;
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail), tailWrapper = tailFields ? `{${tailFields}}` : "";
  return tail.length > 0 ? `${head}${tailWrapper}` : head;
}
function getExtendedProjection(schemaType, orderBy, strict = !1) {
  return orderBy.map((ordering) => joinReferences(schemaType, ordering.field.split("."), strict)).join(", ");
}
function listenSearchQuery(options) {
  const {
    client,
    schema,
    sort,
    limit,
    params,
    filter: filter2,
    searchQuery,
    staticTypeNames,
    maxFieldDepth,
    enableLegacySearch
  } = options, sortBy = sort.by, extendedProjection = sort == null ? void 0 : sort.extendedProjection, events$ = defer(() => client.listen(`*[${filter2}]`, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeResult: !1,
    visibility: "query"
  })).pipe(
    mergeMap((ev, i) => i === 0 && ev.type !== "welcome" ? throwError(
      () => new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : of(ev)),
    share()
  ), [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === "welcome");
  return merge(
    welcome$.pipe(take(1)),
    mutationAndReconnect$.pipe(throttleTime(1e3, asyncScheduler, { leading: !0, trailing: !0 }))
  ).pipe(
    exhaustMapWithTrailing((event) => (staticTypeNames ? of(staticTypeNames) : client.observable.fetch(`array::unique(*[${filter2}][]._type)`, params)).pipe(
      mergeMap((typeNames) => {
        const types = getSearchableTypes(schema).filter((type) => typeNames.includes(type.name) ? (getExtendedProjection(type, sort.by, !0), !0) : !1), search = createSearch(types, client, {
          filter: filter2,
          params,
          enableLegacySearch,
          maxDepth: maxFieldDepth
        }), doFetch = () => search({
          query: searchQuery || "",
          types
        }, {
          __unstable_extendedProjection: extendedProjection,
          comments: [`findability-source: ${searchQuery ? "list-query" : "list"}`],
          limit,
          skipSortByScore: !0,
          sort: sortBy
        }).pipe(
          map$1(
            (result) => (
              // eslint-disable-next-line max-nested-callbacks
              result.hits.map(({ hit }) => hit)
            )
          )
        );
        return event.type === "mutation" && event.visibility !== "query" ? timer(1200).pipe(mergeMap(doFetch)) : doFetch();
      })
    ))
  );
}
const EMPTY_ARRAY = [], INITIAL_STATE = {
  error: null,
  onRetry: void 0,
  result: null
}, INITIAL_QUERY_RESULTS = {
  result: null,
  error: null
};
function useDocumentList(opts) {
  const { filter: filter2, params: paramsProp, sortOrder, searchQuery, apiVersion } = opts, client = useClient({
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion
  }), { enableLegacySearch = !1 } = useWorkspace().search, schema = useSchema(), maxFieldDepth = useSearchMaxFieldDepth(), [resultState, setResult] = useState(INITIAL_STATE), { onRetry, error, result } = resultState, documents = result == null ? void 0 : result.documents, items = useMemo(
    () => documents ? removePublishedWithDrafts(documents) : EMPTY_ARRAY,
    [documents]
  ), [isLazyLoading, setIsLazyLoading] = useState(!1), [hasFullList, setHasFullList] = useState(!1), [shouldFetchFullList, setShouldFetchFullList] = useState(!1), typeNameFromFilter = useMemo(
    () => findStaticTypesInFilter(filter2, paramsProp),
    [filter2, paramsProp]
  ), isLoading = result === null && !error, hasMaxItems = (documents == null ? void 0 : documents.length) === FULL_LIST_LIMIT, onListChange = useCallback(() => {
    isLoading || hasFullList || shouldFetchFullList || setShouldFetchFullList(!0);
  }, [isLoading, hasFullList, shouldFetchFullList]), handleSetResult = useCallback(
    (res) => {
      var _a, _b;
      if (res.error) {
        setResult(res);
        return;
      }
      const documentsLength = ((_b = (_a = res.result) == null ? void 0 : _a.documents) == null ? void 0 : _b.length) || 0;
      if (!res.error && (res == null ? void 0 : res.result) === null && shouldFetchFullList) {
        setIsLazyLoading(!0);
        return;
      }
      if (documentsLength < PARTIAL_PAGE_LIMIT && documentsLength !== 0 && !shouldFetchFullList && setHasFullList(!0), (res == null ? void 0 : res.result) === null) {
        setResult((prev) => ({ ...prev.error ? res : prev }));
        return;
      }
      setIsLazyLoading(!1), setResult(res);
    },
    [shouldFetchFullList]
  ), queryResults$ = useMemo(() => {
    const onRetry$ = new Subject(), _onRetry = () => onRetry$.next();
    return listenSearchQuery({
      client,
      filter: filter2,
      limit: shouldFetchFullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT,
      params: paramsProp,
      schema,
      searchQuery: searchQuery || "",
      sort: sortOrder || DEFAULT_ORDERING,
      staticTypeNames: typeNameFromFilter,
      maxFieldDepth,
      enableLegacySearch
    }).pipe(
      map((results) => ({
        result: { documents: results },
        error: null
      })),
      startWith(INITIAL_QUERY_RESULTS),
      catchError((err) => err instanceof ProgressEvent ? throwError(() => new Error("Request error")) : throwError(() => err)),
      catchError((err, caught$) => concat(
        of({ result: null, error: err }),
        merge(fromEvent(window, "online"), onRetry$).pipe(
          take$1(1),
          mergeMap$1(() => caught$)
        )
      )),
      scan((prev, next) => ({ ...prev, ...next, onRetry: _onRetry }))
    );
  }, [
    shouldFetchFullList,
    sortOrder,
    client,
    filter2,
    paramsProp,
    schema,
    searchQuery,
    typeNameFromFilter,
    maxFieldDepth,
    enableLegacySearch
  ]);
  useEffect(() => {
    const sub = queryResults$.subscribe(handleSetResult);
    return () => {
      sub.unsubscribe();
    };
  }, [handleSetResult, queryResults$]);
  const reset = useCallback(() => {
    setHasFullList(!1), setIsLazyLoading(!1), setResult(INITIAL_STATE), setShouldFetchFullList(!1);
  }, []);
  return useEffect(() => {
    reset();
  }, [reset, filter2, paramsProp, sortOrder, searchQuery]), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady: !error,
    items,
    onListChange,
    onRetry
  };
}
const rotate = keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styled(SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`, DocumentListPane = memo(function(props) {
  const { childItemId, isActive, pane: pane2, paneKey, sortOrder: sortOrderRaw, layout } = props, schema = useSchema(), { displayOptions, options } = pane2, { apiVersion, filter: filter2 } = options, params = useShallowUnique(options.params || EMPTY_RECORD), typeName = useMemo(() => {
    const staticTypes = findStaticTypesInFilter(filter2, params);
    return (staticTypes == null ? void 0 : staticTypes.length) === 1 ? staticTypes[0] : null;
  }, [filter2, params]), showIcons = (displayOptions == null ? void 0 : displayOptions.showIcons) !== !1, { t } = useTranslation(structureLocaleNamespace), { title } = useI18nText(pane2), [searchQuery, setSearchQuery] = useState(""), [searchInputValue, setSearchInputValue] = useState(""), [searchInputElement, setSearchInputElement] = useState(null), showSearchLoadingRef = useRef(!1), sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema.get(typeName)) : sortOrderRaw, sortOrder = useUnique(sortWithOrderingFn), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady,
    items,
    onListChange,
    onRetry
  } = useDocumentList({
    apiVersion,
    filter: filter2,
    params,
    searchQuery: searchQuery == null ? void 0 : searchQuery.trim(),
    sortOrder
  }), handleQueryChange = useObservableCallback(
    (event$) => event$.pipe(
      map$1((event) => event.target.value),
      tap$1(setSearchInputValue),
      debounce((value) => value === "" ? of("") : timer(300)),
      tap$1(setSearchQuery)
    ),
    []
  ), handleClearSearch = useCallback(() => {
    setSearchQuery(""), setSearchInputValue("");
  }, []), handleSearchKeyDown = useCallback(
    (event) => {
      event.key === "Escape" && handleClearSearch();
    },
    [handleClearSearch]
  );
  useEffect(() => (showSearchLoadingRef.current === !1 && !isLoading && (showSearchLoadingRef.current = !0), () => {
    showSearchLoadingRef.current = !1;
  }), [isLoading]), useEffect(() => {
    handleClearSearch(), showSearchLoadingRef.current = !1;
  }, [paneKey, handleClearSearch]);
  const loadingVariant = useMemo(() => isLoading && items.length === 0 && showSearchLoadingRef.current ? "spinner" : "initial", [isLoading, items.length]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Box, { paddingX: 3, paddingBottom: 3, children: /* @__PURE__ */ jsx(
      TextInput,
      {
        "aria-label": t("panes.document-list-pane.search-input.aria-label"),
        autoComplete: "off",
        border: !1,
        clearButton: !!searchQuery,
        disabled: !isSearchReady,
        fontSize: [2, 2, 1],
        icon: loadingVariant === "spinner" ? AnimatedSpinnerIcon : SearchIcon,
        onChange: handleQueryChange,
        onClear: handleClearSearch,
        onKeyDown: handleSearchKeyDown,
        padding: 2,
        placeholder: t("panes.document-list-pane.search-input.placeholder"),
        radius: 2,
        ref: setSearchInputElement,
        spellCheck: !1,
        value: searchInputValue
      }
    ) }),
    /* @__PURE__ */ jsx(
      DocumentListPaneContent,
      {
        childItemId,
        error,
        filterIsSimpleTypeConstraint: !!typeName,
        hasMaxItems,
        hasSearchQuery: !!searchQuery,
        isActive,
        isLazyLoading,
        isLoading,
        items,
        layout,
        loadingVariant,
        onListChange,
        onRetry,
        paneTitle: title,
        searchInputElement,
        showIcons
      },
      paneKey
    )
  ] });
});
function SheetListCell(props) {
  const { getValue, column, row, fieldType } = props, initialValue = getValue() || "", [value, setValue] = useState(initialValue), handleOnChange = useCallback((e) => {
    setValue(e.currentTarget.value);
  }, []);
  return useEffect(() => {
    setValue(initialValue || "");
  }, [initialValue]), fieldType.name === "boolean" ? /* @__PURE__ */ jsxs(
    Select,
    {
      radius: 0,
      style: {
        boxShadow: "none"
      },
      value: JSON.stringify(value),
      onChange: () => null,
      children: [
        /* @__PURE__ */ jsx("option", { value: "True", children: "True" }),
        /* @__PURE__ */ jsx("option", { value: "False", children: "False" })
      ]
    }
  ) : /* @__PURE__ */ jsx(
    TextInput,
    {
      size: 0,
      id: `cell-${column.id}-${row.id}`,
      radius: 0,
      border: !1,
      onChange: handleOnChange,
      value: typeof value == "string" || typeof value == "number" ? value : JSON.stringify(value)
    }
  );
}
const VISIBLE_COLUMN_LIMIT = 5, PreviewCell = (props) => {
  var _a, _b;
  const { documentPreviewStore, row, schemaType } = props, title = "Document title", { draft, published, isLoading } = useMemoObservable(
    () => getPreviewStateObservable(documentPreviewStore, schemaType, row.original._id, title),
    [documentPreviewStore, schemaType, row.original._id]
  );
  if (isLoading)
    return /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: "Loading..." });
  const displayValue = (_b = (_a = draft == null ? void 0 : draft.title) != null ? _a : published == null ? void 0 : published.title) != null ? _b : "Untitled";
  return /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsx(DocumentStatusIndicator, { draft, published }),
    /* @__PURE__ */ jsx(Text, { size: 1, children: displayValue })
  ] });
}, columnHelper = createColumnHelper(), SUPPORTED_FIELDS = ["string", "number", "boolean"], getColsFromSchemaType = (schemaType, parentalField) => schemaType.fields.reduce((tableColumns, field) => {
  const { type, name } = field;
  if (SUPPORTED_FIELDS.includes(type.name)) {
    const nextCol = columnHelper.accessor(
      // accessor must use dot notation for internal tanstack method of reading cell data
      parentalField ? `${parentalField}.${field.name}` : field.name,
      {
        id: parentalField ? `${parentalField}_${field.name}` : field.name,
        header: field.type.title,
        enableHiding: !0,
        cell: (info) => /* @__PURE__ */ jsx(SheetListCell, { ...info, fieldType: type })
      }
    );
    return [...tableColumns, nextCol];
  }
  return type.name === "object" && isObjectSchemaType(type) && !parentalField ? [
    ...tableColumns,
    columnHelper.group({ header: name, columns: getColsFromSchemaType(type, field.name) })
  ] : tableColumns;
}, []);
function isAccessorKeyColumnDef(column) {
  return "accessorKey" in column;
}
function isGroupColumnDef(column) {
  return "columns" in column;
}
const flatColumns = (cols) => cols.flatMap((col) => isAccessorKeyColumnDef(col) ? col : isGroupColumnDef(col) ? col.columns ? flatColumns(col.columns) : [] : []);
function useDocumentSheetColumns(documentSchemaType) {
  const documentPreviewStore = useDocumentPreviewStore(), columns = useMemo(() => documentSchemaType ? [
    columnHelper.display({
      id: "selected",
      enableHiding: !1,
      header: (info) => /* @__PURE__ */ jsx(
        Checkbox,
        {
          indeterminate: info.table.getIsSomeRowsSelected(),
          onChange: info.table.getToggleAllPageRowsSelectedHandler()
        }
      ),
      cell: (info) => /* @__PURE__ */ jsx(
        Checkbox,
        {
          checked: info.row.getIsSelected(),
          disabled: !info.row.getCanSelect(),
          onChange: () => info.row.toggleSelected()
        }
      )
    }),
    columnHelper.accessor("Preview", {
      enableHiding: !1,
      id: "Preview",
      cell: (info) => /* @__PURE__ */ jsx(
        PreviewCell,
        {
          ...info,
          documentPreviewStore,
          schemaType: documentSchemaType
        }
      )
    }),
    ...getColsFromSchemaType(documentSchemaType)
  ] : [], [documentPreviewStore, documentSchemaType]), [initialColumnsVisibility] = useMemo(
    () => flatColumns(columns).reduce(
      ([accCols, countAllowedVisible], column) => {
        if (!column.id) throw new Error("Column must have an id");
        const visibilityKey = column.id;
        return column.enableHiding ? countAllowedVisible === VISIBLE_COLUMN_LIMIT ? [{ ...accCols, [visibilityKey]: !1 }, countAllowedVisible] : [{ ...accCols, [visibilityKey]: !0 }, countAllowedVisible + 1] : [{ ...accCols, [visibilityKey]: !0 }, countAllowedVisible];
      },
      [{}, 0]
    ),
    [columns]
  );
  return { columns, initialColumnsVisibility };
}
function ColumnsControl({ table }) {
  const isVisibleLimitReached = table.getVisibleLeafColumns().filter((col) => col.getCanHide()).length >= VISIBLE_COLUMN_LIMIT, setInitialColumns = useCallback(() => {
    table.resetColumnVisibility();
  }, [table]), handleColumnOnChange = (column) => () => {
    column.toggleVisibility();
  }, getColumnVisibilityDisabled = (column) => {
    const isColumnVisible = column.getIsVisible(), isSingleColumnVisible = table.getVisibleLeafColumns().filter((col) => col.getCanHide()).length === 1;
    return isVisibleLimitReached && !isColumnVisible || isSingleColumnVisible && isColumnVisible;
  };
  return /* @__PURE__ */ jsx(
    MenuButton$1,
    {
      button: /* @__PURE__ */ jsx(Button$1, { text: "Columns" }),
      id: "columns-control",
      menu: /* @__PURE__ */ jsxs(Menu, { padding: 3, paddingBottom: 1, style: { maxHeight: 300, overflow: "scroll" }, children: [
        /* @__PURE__ */ jsx(Button$1, { size: 0, text: "Reset", onClick: setInitialColumns }),
        /* @__PURE__ */ jsxs(Stack, { children: [
          table.getAllLeafColumns().filter((column) => column.getCanHide()).map((column) => {
            var _a;
            return /* @__PURE__ */ jsxs(Flex, { marginY: 2, align: "center", children: [
              /* @__PURE__ */ jsx(
                Checkbox,
                {
                  readOnly: getColumnVisibilityDisabled(column),
                  checked: column.getIsVisible(),
                  onChange: handleColumnOnChange(column),
                  id: `col-visibility-${column.id}`,
                  style: { display: "block" }
                }
              ),
              /* @__PURE__ */ jsx(Box, { flex: 1, paddingLeft: 3, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx("label", { htmlFor: `col-visibility-${column.id}`, children: (_a = column.columnDef.header) == null ? void 0 : _a.toString() }) }) })
            ] }, column.id);
          }),
          isVisibleLimitReached && /* @__PURE__ */ jsx(
            Card,
            {
              padding: 2,
              style: { position: "sticky", bottom: 0 },
              radius: 2,
              shadow: 1,
              tone: "caution",
              children: /* @__PURE__ */ jsxs(Text, { size: 1, children: [
                "You may only have ",
                VISIBLE_COLUMN_LIMIT,
                " columns visible"
              ] })
            }
          )
        ] })
      ] }),
      placement: "bottom",
      popover: { portal: !0 }
    }
  );
}
const SearchContainer = styled(Flex)`
  flex-shrink: 0;
`;
function DocumentSheetListFilter() {
  const {
    state: { filtersVisible }
  } = useSearchState();
  return /* @__PURE__ */ jsxs(SearchContainer, { children: [
    /* @__PURE__ */ jsx(SearchHeader, {}),
    filtersVisible && /* @__PURE__ */ jsx(Filters, { showTypeFilter: !1 })
  ] });
}
function DocumentSheetListPaginator({ table }) {
  return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxs(Flex, { gap: 3, align: "center", children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => table.setPageIndex(0),
        disabled: !table.getCanPreviousPage(),
        icon: DoubleChevronLeftIcon,
        tooltipProps: {
          content: "Go to first page"
        }
      }
    ),
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => table.previousPage(),
        disabled: !table.getCanPreviousPage(),
        icon: ChevronLeftIcon,
        tooltipProps: {
          content: "Go to previous page"
        }
      }
    ),
    /* @__PURE__ */ jsxs(Text, { style: { whiteSpace: "nowrap" }, children: [
      table.getState().pagination.pageIndex + 1,
      " of ",
      table.getPageCount()
    ] }),
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => table.nextPage(),
        disabled: !table.getCanNextPage(),
        icon: ChevronRightIcon,
        tooltipProps: {
          content: "Go to next page"
        }
      }
    ),
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => table.setPageIndex(table.getPageCount() - 1),
        disabled: !table.getCanNextPage(),
        icon: DoubleChevronRightIcon,
        tooltipProps: {
          content: "Go to last page"
        }
      }
    ),
    /* @__PURE__ */ jsx(
      "select",
      {
        value: table.getState().pagination.pageSize,
        onChange: (e) => {
          table.setPageSize(Number(e.target.value));
        },
        children: [25, 50, 100].map((pageSize) => /* @__PURE__ */ jsx("option", { value: pageSize, children: pageSize }, pageSize))
      }
    )
  ] }) });
}
function createDocumentsSet(documents) {
  return documents.reduce((acc, doc) => ({ ...acc, [doc._id]: doc }), {});
}
function documentsReducer(state2, action) {
  switch (action.type) {
    case "DOCUMENTS_SET": {
      const documents = createDocumentsSet(action.documents);
      return {
        ...state2,
        documents
      };
    }
    case "DOCUMENT_RECEIVED": {
      const nextDocumentResult = action.payload;
      return {
        ...state2,
        documents: {
          ...state2.documents,
          [nextDocumentResult._id]: nextDocumentResult
        }
      };
    }
    case "DOCUMENT_DELETED": {
      const { [action.id]: _, ...restDocuments } = state2.documents;
      return {
        ...state2,
        documents: restDocuments
      };
    }
    case "DOCUMENT_UPDATED": {
      const updatedDocument = action.payload, id = updatedDocument._id, nextDocument = {
        // Add existing document data
        ...state2.documents[id],
        // Add incoming document data
        ...updatedDocument
      };
      return {
        ...state2,
        documents: {
          ...state2.documents,
          [id]: nextDocument
        }
      };
    }
    default:
      return state2;
  }
}
const LISTEN_OPTIONS = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query"
};
function useDocumentSheetListStore({
  filter: filter2,
  params,
  apiVersion
}) {
  const QUERY = `*[${filter2}][0...2000]`, client = useClient({
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion
  }), [state2, dispatch] = useReducer(documentsReducer, {
    documents: {}
  }), [isLoading, setIsLoading] = useState(client !== null), [error, setError] = useState(null), initialFetch = useCallback(async () => {
    if (!client) {
      setIsLoading(!1);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({ type: "DOCUMENTS_SET", documents: res }), setIsLoading(!1);
    } catch (err) {
      setError(err);
    }
  }, [client, params, QUERY]), handleListenerEvent = useCallback(
    async (event) => {
      if (event.type === "welcome" && (setIsLoading(!0), await initialFetch(), setIsLoading(!1)), event.type === "reconnect" && setIsLoading(!0), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextDocument = event.result;
          nextDocument && dispatch({
            type: "DOCUMENT_RECEIVED",
            payload: nextDocument
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "DOCUMENT_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedDocument = event.result;
          updatedDocument && dispatch({
            type: "DOCUMENT_UPDATED",
            payload: updatedDocument
          });
        }
      }
    },
    [initialFetch]
  ), listener$ = useMemo(() => client ? client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(
    catchError$1((err) => (setError(err), of(err)))
  ) : of(), [client, params, QUERY]);
  return useEffect(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: useMemo(() => {
      const uniques = Object.keys(state2.documents).reduce(
        (acc, key) => {
          const document2 = state2.documents[key], isDraft = document2._id === getDraftId(document2._id), id = isDraft ? document2._id : getDraftId(document2._id);
          return acc[id] && !isDraft || (acc[id] = document2), acc;
        },
        {}
      );
      return Object.values(uniques);
    }, [state2.documents]),
    isLoading,
    error
  };
}
function useDocumentSheetList({ typeName }) {
  const { state: state2 } = useSearchState(), items = useMemo(() => {
    const map2 = /* @__PURE__ */ new Map();
    return state2.result.hits.forEach((h) => map2.set(getPublishedId(h.hit._id), h.hit)), map2;
  }, [state2.result.hits]), { data, isLoading } = useDocumentSheetListStore({
    filter: `_type == "${typeName}"`
  });
  return { data: useMemo(() => data.filter((doc) => items.has(getPublishedId(doc._id))), [data, items]), isLoading };
}
const PaneContainer$1 = styled(Flex)`
  height: 100%;
`, TableContainer = styled.div`
  overflow: auto; //our scrollable table container
  position: relative; //needed for sticky header
`, Table = styled.table`
  border-collapse: collapse;
  border-spacing: 0;
  font-family: arial, sans-serif;
  table-layout: fixed;
  white-space: nowrap;
  width: 100%;
  border: 1px solid lightgray;

  thead {
    background: lightgray;
    display: grid;
    position: sticky;
    top: 0;
    z-index: 10;
  }
  tr {
    border-bottom: 1px solid lightgray;
    display: flex;
    padding: 0;
  }
  tr:last-child {
    border-bottom: none;
  }
  th {
    border-bottom: 1px solid lightgray;
    border-right: 1px solid lightgray;
    padding: 2px 4px;
    text-align: left;
  }

  td {
    padding: 0;
  }
`;
function DocumentSheetListPaneInner({
  documentSchemaType
}) {
  const { dispatch, state: state2 } = useSearchState(), { columns, initialColumnsVisibility } = useDocumentSheetColumns(documentSchemaType), { data } = useDocumentSheetList({
    typeName: documentSchemaType.name
  }), totalRows = state2.result.hits.length, table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    // Avoids resetting the page index when the data changes, e.g. a mutation is received
    autoResetPageIndex: !1,
    initialState: {
      pagination: { pageSize: 25 },
      columnVisibility: initialColumnsVisibility
    }
  }), { rows } = table.getRowModel();
  useEffect(() => (dispatch({ type: "TERMS_TYPE_ADD", schemaType: documentSchemaType }), () => {
    dispatch({ type: "TERMS_TYPE_REMOVE", schemaType: documentSchemaType });
  }), [documentSchemaType, dispatch]);
  const renderRow = useCallback((row) => /* @__PURE__ */ jsx(
    Box,
    {
      as: "tr",
      paddingY: 2,
      style: { display: "flex", width: "100%" },
      children: row.getVisibleCells().map((cell) => /* @__PURE__ */ jsx(
        "td",
        {
          style: {
            display: "flex",
            overflow: "hidden",
            width: cell.column.getSize()
          },
          children: flexRender(cell.column.columnDef.cell, cell.getContext())
        },
        row.original._id + cell.id
      ))
    },
    row.original._id + row.id
  ), []), rowsCount = `Total: ${totalRows} rows, showing ${rows.length} rows`;
  return /* @__PURE__ */ jsxs(PaneContainer$1, { direction: "column", paddingX: 3, "data-testid": "document-sheet-list-pane", children: [
    /* @__PURE__ */ jsx(DocumentSheetListFilter, {}),
    /* @__PURE__ */ jsx(Flex, { paddingBottom: 3, paddingLeft: 3, children: /* @__PURE__ */ jsx(Text, { size: 0, muted: !0, children: rowsCount }) }),
    /* @__PURE__ */ jsxs(TableContainer, { children: [
      /* @__PURE__ */ jsx(ColumnsControl, { table }),
      /* @__PURE__ */ jsxs(Table, { children: [
        /* @__PURE__ */ jsx("thead", { children: table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ jsx(
          Box,
          {
            as: "tr",
            style: { display: "flex", width: "100%" },
            paddingY: 1,
            children: headerGroup.headers.map((header) => /* @__PURE__ */ jsx("th", { style: { display: "flex", width: header.getSize() }, children: headerGroup.depth > 0 && !header.column.parent ? null : /* @__PURE__ */ jsx("div", { children: flexRender(header.column.columnDef.header, header.getContext()) }) }, header.id))
          },
          headerGroup.id
        )) }),
        /* @__PURE__ */ jsx("tbody", { children: table.getRowModel().rows.map(renderRow) })
      ] })
    ] }),
    /* @__PURE__ */ jsx(Flex, { justify: "flex-end", padding: 3, gap: 4, paddingY: 5, children: /* @__PURE__ */ jsx(DocumentSheetListPaginator, { table }) })
  ] });
}
function DocumentSheetListPane(props) {
  const schema = useSchema(), typeName = props.pane.schemaTypeName, schemaType = schema.get(typeName);
  if (!schemaType || !isDocumentSchemaType(schemaType))
    throw new Error(`Schema type "${typeName}" not found or not a document schema`);
  return /* @__PURE__ */ jsx(SearchProvider, { children: /* @__PURE__ */ jsx(DocumentSheetListPaneInner, { ...props, documentSchemaType: schemaType }) });
}
const PaneHeader = memo(
  ({
    contentAfter,
    index,
    initialValueTemplates = [],
    menuItemGroups = [],
    menuItems = [],
    setLayout,
    setSortOrder,
    title
  }) => {
    const { features } = useStructureTool(), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, actionHandlers = useMemo(() => ({
      setLayout: ({ layout: value }) => {
        setLayout(value);
      },
      setSortOrder: (sort) => {
        setSortOrder(sort);
      }
    }), [setLayout, setSortOrder]);
    return /* @__PURE__ */ jsx(TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsx(
      PaneHeader$1,
      {
        actions: /* @__PURE__ */ jsx(
          PaneHeaderActions,
          {
            initialValueTemplateItems: initialValueTemplates,
            actionHandlers,
            menuItemGroups,
            menuItems
          }
        ),
        backButton: features.backButton && index > 0 && /* @__PURE__ */ jsx(
          Button,
          {
            as: BackLink,
            "data-as": "a",
            icon: ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: "Back" }
          }
        ),
        contentAfter,
        tabIndex,
        title
      }
    ) });
  }
);
PaneHeader.displayName = "PaneHeader";
const addSelectedStateToMenuItems = (options) => {
  const { menuItems, sortOrderRaw, layout } = options;
  return menuItems == null ? void 0 : menuItems.map((item) => {
    var _a, _b, _c, _d;
    return (_a = item.params) != null && _a.layout ? {
      ...item,
      selected: layout === ((_b = item.params) == null ? void 0 : _b.layout)
    } : (_c = item == null ? void 0 : item.params) != null && _c.by ? {
      ...item,
      selected: isEqual(sortOrderRaw == null ? void 0 : sortOrderRaw.by, ((_d = item == null ? void 0 : item.params) == null ? void 0 : _d.by) || EMPTY_ARRAY$3)
    } : { ...item, selected: !1 };
  });
};
function useShallowUnique(value) {
  const valueRef = useRef(value);
  return shallowEquals(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
const PaneContainer = memo(function(props) {
  const { index, isSelected, pane: pane2, paneKey } = props, { name: parentSourceName } = useSource(), {
    defaultLayout = "default",
    initialValueTemplates = EMPTY_ARRAY$3,
    menuItemGroups,
    menuItems,
    options
  } = pane2, { defaultOrdering = EMPTY_ARRAY$3, filter: filter2 } = options, params = useShallowUnique(options.params || EMPTY_RECORD), sourceName = pane2.source, typeName = useMemo(() => {
    const staticTypes = findStaticTypesInFilter(filter2, params);
    return (staticTypes == null ? void 0 : staticTypes.length) === 1 ? staticTypes[0] : null;
  }, [filter2, params]), [layout, setLayout] = useStructureToolSetting(
    "layout",
    typeName != null ? typeName : pane2.id,
    //pane.id for anything that is not documentTypeList
    defaultLayout
  ), { title } = useI18nText(pane2), defaultSortOrder = useMemo(() => (defaultOrdering == null ? void 0 : defaultOrdering.length) > 0 ? { by: defaultOrdering } : DEFAULT_ORDERING, [defaultOrdering]), [sortOrderRaw, setSortOrder] = useStructureToolSetting(
    "sort-order",
    typeName != null ? typeName : pane2.id,
    //pane.id for anything that is not documentTypeList
    defaultSortOrder
  ), menuItemsWithSelectedState = useMemo(
    () => addSelectedStateToMenuItems({
      menuItems,
      sortOrderRaw,
      layout
    }),
    [layout, menuItems, sortOrderRaw]
  ), isSheetListLayout = layout === "sheetList", paneLayout = isSheetListLayout ? /* @__PURE__ */ createElement(DocumentSheetListPane, { ...props, key: props.pane.id }) : /* @__PURE__ */ jsx(DocumentListPane, { ...props, sortOrder: sortOrderRaw, layout });
  return /* @__PURE__ */ jsx(SourceProvider, { name: sourceName || parentSourceName, children: /* @__PURE__ */ jsxs(
    Pane,
    {
      "data-ui": "DocumentListPane",
      id: paneKey,
      minWidth: 320,
      ...isSheetListLayout ? {} : { currentMaxWidth: 350, maxWidth: 640 },
      selected: isSelected,
      children: [
        _DEBUG,
        /* @__PURE__ */ jsx(
          PaneHeader,
          {
            index,
            initialValueTemplates,
            menuItemGroups,
            menuItems: menuItemsWithSelectedState,
            setLayout,
            setSortOrder,
            title
          }
        ),
        paneLayout
      ]
    }
  ) });
});
var __defProp$e = Object.defineProperty, __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$e = (obj, key, value) => __defNormalProp$e(obj, typeof key != "symbol" ? key + "" : key, value);
class SerializeError extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message), __publicField$e(this, "path"), __publicField$e(this, "helpId"), this.name = "SerializeError";
    const segment = typeof pathSegment > "u" ? "<unknown>" : `${pathSegment}`;
    this.path = (parentPath || []).concat(hint ? `${segment} (${hint})` : segment);
  }
  withHelpUrl(id) {
    return this.helpId = id, this;
  }
}
var HELP_URL = /* @__PURE__ */ ((HELP_URL2) => (HELP_URL2.ID_REQUIRED = "structure-node-id-required", HELP_URL2.TITLE_REQUIRED = "structure-title-required", HELP_URL2.FILTER_REQUIRED = "structure-filter-required", HELP_URL2.INVALID_LIST_ITEM = "structure-invalid-list-item", HELP_URL2.COMPONENT_REQUIRED = "structure-view-component-required", HELP_URL2.DOCUMENT_ID_REQUIRED = "structure-document-id-required", HELP_URL2.DOCUMENT_TYPE_REQUIRED = "structure-document-type-required", HELP_URL2.SCHEMA_TYPE_REQUIRED = "structure-schema-type-required", HELP_URL2.SCHEMA_TYPE_NOT_FOUND = "structure-schema-type-not-found", HELP_URL2.LIST_ITEMS_MUST_BE_ARRAY = "structure-list-items-must-be-array", HELP_URL2.QUERY_PROVIDED_FOR_FILTER = "structure-query-provided-for-filter", HELP_URL2.ACTION_OR_INTENT_REQUIRED = "structure-action-or-intent-required", HELP_URL2.LIST_ITEM_IDS_MUST_BE_UNIQUE = "structure-list-item-ids-must-be-unique", HELP_URL2.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE = "structure-action-and-intent-mutually-exclusive", HELP_URL2.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER = "structure-api-version-required-for-custom-filter", HELP_URL2))(HELP_URL || {});
const ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  i18n: {
    title: {
      key: "menu-items.sort-by.last-edited",
      ns: structureLocaleNamespace
    }
  },
  name: "lastEditedDesc",
  by: [{ field: "_updatedAt", direction: "desc" }]
}, ORDER_BY_CREATED_AT = {
  title: "Created",
  i18n: {
    title: {
      key: "menu-items.sort-by.created",
      ns: structureLocaleNamespace
    }
  },
  name: "lastCreatedDesc",
  by: [{ field: "_createdAt", direction: "desc" }]
}, DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT, DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
var __defProp$d = Object.defineProperty, __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$d = (obj, key, value) => __defNormalProp$d(obj, key + "", value);
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
class MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context, __publicField$d(this, "spec"), this.spec = spec || {};
  }
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action) {
    return this.clone({ action });
  }
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction() {
    return this.spec.action;
  }
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent) {
    return this.clone({ intent });
  }
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent() {
    return this.spec.intent;
  }
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /**
   * Get menu item title. Note that the `i18n` configuration will take
   * precedence and this title is left here for compatibility.
   * @returns menu item title
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group) {
    return this.clone({ group });
  }
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup() {
    return this.spec.group;
  }
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params) {
    return this.clone({ params });
  }
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams() {
    return this.spec.params;
  }
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction(showAsAction = !0) {
    return this.clone({ showAsAction: !!showAsAction });
  }
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize(options = { path: [] }) {
    const { title, action, intent } = this.spec;
    if (!title) {
      const hint = typeof action == "string" ? `action: "${action}"` : void 0;
      throw new SerializeError(
        "`title` is required for menu item",
        options.path,
        options.index,
        hint
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent)
      throw new SerializeError(
        `\`action\` or \`intent\` required for menu item with title ${this.spec.title}`,
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    if (intent && action)
      throw new SerializeError(
        "cannot set both `action` AND `intent`",
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    return { ...this.spec, title };
  }
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec) {
    const builder = new MenuItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
function getOrderingMenuItem(context, { by, title, i18n }, extendedProjection) {
  let builder = new MenuItemBuilder(context).group("sorting").title(
    context.i18n.t("default-menu-item.fallback-title", {
      // note this lives in the `studio` bundle because that one is loaded by default
      ns: "studio",
      replace: { title }
      // replaces the `{{title}}` option
    })
  ).icon(SortIcon).action("setSortOrder").params({ by, extendedProjection });
  return i18n && (builder = builder.i18n(i18n)), builder;
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const { schema } = context, type = typeof typeName == "string" ? schema.get(typeName) : typeName;
  return !type || !("orderings" in type) ? [] : (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map(
    (ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by))
  );
}
var __defProp$c = Object.defineProperty, __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$c = (obj, key, value) => __defNormalProp$c(obj, typeof key != "symbol" ? key + "" : key, value);
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({ path, index }) : item;
}
class MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context, __publicField$c(this, "_id"), __publicField$c(this, "_title"), __publicField$c(this, "_i18n"), this._id = spec ? spec.id : "", this._title = spec ? spec.title : "", this._i18n = spec ? spec.i18n : void 0;
  }
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id) {
    return new MenuItemGroupBuilder(this._context, { id, title: this._title, i18n: this._i18n });
  }
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId() {
    return this._id;
  }
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title) {
    return new MenuItemGroupBuilder(this._context, { title, id: this._id, i18n: this._i18n });
  }
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle() {
    return this._title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
   */
  i18n(i18n) {
    return new MenuItemGroupBuilder(this._context, { i18n, id: this._id, title: this._title });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this._i18n;
  }
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize(options = { path: [] }) {
    const { _id, _title, _i18n } = this;
    if (!_id)
      throw new SerializeError(
        "`id` is required for a menu item group",
        options.path,
        options.index,
        _title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!_title)
      throw new SerializeError(
        "`title` is required for a menu item group",
        options.path,
        _id
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: _id,
      title: _title,
      i18n: _i18n
    };
  }
}
const disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id != "string")
    throw new SerializeError(
      `Structure node id must be of type string, got ${typeof id}`,
      parentPath,
      pathSegment
    );
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar)
    throw new SerializeError(
      `Structure node id cannot contain character "${disallowedChar}"`,
      parentPath,
      pathSegment
    );
  if (id.startsWith("__edit__"))
    throw new SerializeError(
      "Structure node id cannot start with __edit__",
      parentPath,
      pathSegment
    );
  return id;
}
function getStructureNodeId(title, id) {
  if (id)
    return id;
  const camelCased = camelCase(title);
  return disallowedPattern.test(camelCased) ? camelCase(speakingurl(title)) : camelCased;
}
var __defProp$b = Object.defineProperty, __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$b = (obj, key, value) => __defNormalProp$b(obj, key + "", value);
class ComponentBuilder {
  constructor(spec) {
    __publicField$b(this, "spec"), this.spec = { options: {}, ...spec || {} };
  }
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get ID
   * @returns ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Component title
   * @returns title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Component child
   * @returns child component
   */
  getChild() {
    return this.spec.child;
  }
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get Component
   * @returns component
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get Component options
   * @returns component options
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  canHandleIntent(canHandleIntent) {
    return this.clone({ canHandleIntent });
  }
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize(options = { path: [] }) {
    const { id, title, child, options: componentOptions, component: component2 } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!component2)
      throw new SerializeError(
        "`component` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component: component2,
      canHandleIntent: this.spec.canHandleIntent,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, options.path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, options.path)
      )
    };
  }
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new ComponentBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type", documentId = getPublishedId(id), draftId = getDraftId(id);
  return (await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(
    query,
    { documentId, draftId },
    { tag: "structure.resolve-type" }
  ))[0];
}
var __defProp$a = Object.defineProperty, __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$a = (obj, key, value) => __defNormalProp$a(obj, key + "", value);
class GenericViewBuilder {
  constructor() {
    __publicField$a(this, "spec", {});
  }
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic view ID
   * @returns generic view ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title) {
    return this.clone({ title, id: this.spec.id || kebabCase(title) });
  }
  /** Get generic view title
   * @returns generic view title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize(options = { path: [] }) {
    const { id, title, icon } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!title)
      throw new SerializeError(
        "`title` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
}
function isSerializable(view) {
  return typeof view.serialize == "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({ path, index }) : item;
}
var __defProp$9 = Object.defineProperty, __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$9 = (obj, key, value) => __defNormalProp$9(obj, key + "", value);
const isComponentSpec = (spec) => isRecord(spec) && spec.type === "component";
class ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? { ...componentOrSpec } : { options: {} };
    super(), __publicField$9(this, "spec"), this.spec = spec;
    const userComponent = typeof componentOrSpec == "function" ? componentOrSpec : this.spec.component;
    userComponent && (this.spec = this.component(userComponent).spec);
  }
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize(options = { path: [] }) {
    const base = super.serialize(options), component2 = this.spec.component;
    if (typeof component2 != "function")
      throw new SerializeError(
        "`component` is required and must be a function for `component()` view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    return {
      ...base,
      component: component2,
      options: this.spec.options || {},
      type: "component"
    };
  }
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec) {
    const builder = new ComponentViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
var __defProp$8 = Object.defineProperty, __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, key + "", value);
class FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super(), __publicField$8(this, "spec"), this.spec = { id: "editor", title: "Editor", ...spec || {} };
  }
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize(options = { path: [] }) {
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec) {
    const builder = new FormViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
const form = (spec) => new FormViewBuilder(spec), component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ComponentViewBuilder,
  FormViewBuilder,
  GenericViewBuilder,
  component,
  form,
  maybeSerializeView
}), __defProp$7 = Object.defineProperty, __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, key + "", value);
const createDocumentChildResolver = ({ resolveDocumentNode, getClient }) => async (itemId, { params, path }) => {
  let type = params.type;
  const parentPath = path.slice(0, path.length - 1), currentSegment = path[path.length - 1];
  if (type || (type = await resolveTypeForDocument(getClient, itemId)), !type)
    throw new SerializeError(
      "Failed to resolve document, and no type provided in parameters.",
      parentPath,
      currentSegment
    );
  return resolveDocumentNode({ documentId: itemId, schemaType: type });
};
class DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context, __publicField$7(this, "spec"), this.spec = spec || {};
  }
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...this.spec.options || {},
        id: documentId
      }
    });
  }
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.id;
  }
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        type: typeof documentType == "string" ? documentType : documentType.name
      }
    });
  }
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.type;
  }
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.template;
  }
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.templateParameters;
  }
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views2) {
    return this.clone({ views: views2 });
  }
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const urlId = path[index || path.length - 1], id = this.spec.id || urlId && `${urlId}` || "", options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for document nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options || !options.id)
      throw new SerializeError(
        "document id (`id`) is required for document nodes",
        path,
        id,
        hint
      ).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    if (!options || !options.type)
      throw new SerializeError(
        "document type (`schemaType`) is required for document nodes",
        path,
        id,
        hint
      );
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map(
      (item, i) => maybeSerializeView(item, i, path)
    ), viewIds = views2.map((view) => view.id), dupes = uniq(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0)
      throw new SerializeError(
        `document node has views with duplicate IDs: ${dupes.join(",  ")}`,
        path,
        id,
        hint
      );
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views: views2
    };
  }
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone(withSpec = {}) {
    const builder = new DocumentBuilder(this._context), options = { ...this.spec.options || {}, ...withSpec.options || {} };
    return builder.spec = { ...this.spec, ...withSpec, options }, builder;
  }
}
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  return spec.template && (opts.template = spec.template), spec.templateParameters && (opts.templateParameters = spec.templateParameters), opts;
}
function documentFromEditor(context, spec) {
  let doc = spec != null && spec.type ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({ schemaType: spec.type })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec) return doc;
  const { id, type, template, templateParameters } = spec.options;
  return doc = doc.id(spec.id).documentId(id), type && (doc = doc.schemaType(type)), template && (doc = doc.initialValueTemplate(template, templateParameters)), spec.child && (doc = doc.child(spec.child)), doc;
}
function documentFromEditorWithInitialValue({ resolveDocumentNode, templates }, templateId, parameters) {
  const template = templates.find((t) => t.id === templateId);
  if (!template)
    throw new Error(`Template with ID "${templateId}" not defined`);
  return resolveDocumentNode({ schemaType: template.schemaType }).initialValueTemplate(
    templateId,
    parameters
  );
}
var __defProp$6 = Object.defineProperty, __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, key + "", value);
class InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context, __publicField$6(this, "spec"), this.spec = spec || {};
  }
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description) {
    return this.clone({ description });
  }
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters) {
    return this.clone({ parameters });
  }
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const { spec, _context } = this, { templates } = _context;
    if (typeof spec.id != "string" || !spec.id)
      throw new SerializeError(
        "`id` is required for initial value template item nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!spec.templateId)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const template = templates.find((t) => t.id === spec.templateId);
    if (!template)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template.schemaType,
      type: "initialValueTemplateItem",
      description: spec.description || template.description,
      title: spec.title || template.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone(withSpec = {}) {
    const builder = new InitialValueTemplateItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec }, builder;
  }
}
function defaultInitialValueTemplateItems(context) {
  const { schema, getStructureBuilder, templates } = context, typeNames = schema.getTypeNames();
  return templates.filter((tpl) => {
    var _a;
    return !((_a = tpl.parameters) != null && _a.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType)).map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({ path, index }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const { schema, templates } = context;
  return templateItems.map((item) => {
    const template = templates.find((t) => t.id === item.templateId), title = item.title || (template == null ? void 0 : template.title) || "Create", params = {};
    template && template.schemaType && (params.type = template.schemaType), item.templateId && (params.template = item.templateId);
    const intentParams = item.parameters ? [params, item.parameters] : params, schemaType = template && schema.get(template.schemaType), i18n = item.i18n || (template == null ? void 0 : template.i18n);
    let builder = new MenuItemBuilder(context).title(title).icon(template && template.icon || (schemaType == null ? void 0 : schemaType.icon) || AddIcon).intent({ type: "create", params: intentParams });
    return i18n && (builder = builder.i18n(i18n)), builder.serialize();
  });
}
const DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent"), defaultIntentChecker = (intentName, params, { pane: pane2 }) => {
  var _a, _b;
  const isEdit = intentName === "edit", isCreate = intentName === "create", typedSpec = pane2, paneFilter = ((_a = typedSpec.options) == null ? void 0 : _a.filter) || "", paneParams = ((_b = typedSpec.options) == null ? void 0 : _b.params) || {}, typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams), initialValueTemplates = typedSpec.initialValueTemplates || [];
  return isCreate && params.template ? initialValueTemplates.some((tpl) => tpl.templateId === params.template) : isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
const layoutOptions = ["default", "card", "media", "detail", "block"];
var __defProp$5 = Object.defineProperty, __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key != "symbol" ? key + "" : key, value);
function noChildResolver() {
}
const shallowIntentChecker = (intentName, params, { pane: pane2, index }) => index <= 1 && defaultIntentChecker(intentName, params, { pane: pane2, index });
class GenericListBuilder {
  constructor() {
    __publicField$5(this, "initialValueTemplatesSpecified", !1), __publicField$5(this, "spec", {});
  }
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic list ID
   * @returns generic list ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get generic list title
   * @returns generic list title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout) {
    return this.clone({ defaultLayout });
  }
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get generic list child
   * @returns generic list child
   */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent) {
    return this.clone({ canHandleIntent });
  }
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons(enabled = !0) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcons: enabled }
    });
  }
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(templates) {
    return this.initialValueTemplatesSpecified = !0, this.clone({ initialValueTemplates: Array.isArray(templates) ? templates : [templates] });
  }
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id || "", path = options.path, defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout))
      throw new SerializeError(
        `\`layout\` must be one of ${layoutOptions.map((item) => `"${item}"`).join(", ")}`,
        path,
        id || options.index,
        this.spec.title
      );
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map(
      (item, i) => maybeSerializeInitialValueTemplateItem(item, i, path)
    );
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      i18n: this.spec.i18n,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, path)
      )
    };
  }
}
var __defProp$4 = Object.defineProperty, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, key + "", value);
const validateFilter = (spec, options) => {
  var _a;
  const filter2 = ((_a = spec.options) == null ? void 0 : _a.filter.trim()) || "";
  if (["*", "{"].includes(filter2[0]))
    throw new SerializeError(
      `\`filter\` cannot start with \`${filter2[0]}\` - looks like you are providing a query, not a filter`,
      options.path,
      spec.id,
      spec.title
    ).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  return filter2;
}, createDocumentChildResolverForItem = (context) => (itemId, options) => {
  var _a;
  const parentItem = options.parent, template = (_a = options.params) != null && _a.template ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0, type = template ? template.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then(
    (schemaType) => schemaType ? context.resolveDocumentNode({ schemaType, documentId: itemId }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType("")
  );
};
class DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, __publicField$4(this, "spec"), this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec != null && spec.initialValueTemplates);
  }
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, apiVersion } });
  }
  /** Get API version
   * @returns API version
   */
  getApiVersion() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.apiVersion;
  }
  /** Set Document list filter
   * @param filter - filter
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter2) {
    return this.clone({ options: { ...this.spec.options || {}, filter: filter2 } });
  }
  /** Get Document list filter
   * @returns filter
   */
  getFilter() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.filter;
  }
  /** Set Document list schema type name
   * @param type - schema type name.
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type) {
    const schemaTypeName = typeof type == "string" ? type : type.name;
    return this.clone({ schemaTypeName });
  }
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params) {
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, params }
    });
  }
  /** Get Document list options' parameters
   * @returns options
   */
  getParams() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.params;
  }
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering))
      throw new Error("`defaultOrdering` must be an array of order clauses");
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, defaultOrdering: ordering }
    });
  }
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.defaultOrdering;
  }
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize(options = { path: [] }) {
    var _a;
    if (typeof this.spec.id != "string" || !this.spec.id)
      throw new SerializeError(
        "`id` is required for document lists",
        options.path,
        options.index,
        this.spec.title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!this.spec.options || !this.spec.options.filter)
      throw new SerializeError(
        "`filter` is required for document lists",
        options.path,
        this.spec.id,
        this.spec.title
      ).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    return ((_a = this.spec.options) == null ? void 0 : _a.filter) !== "_type == $type" && this.spec.options.filter && !this.spec.options.apiVersion && console.warn(
      `No apiVersion specified for document type list with custom filter: \`${this.spec.options.filter}\`. This will be required in the future. See %s for more info.`,
      generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER)
    ), {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
        apiVersion: this.spec.options.apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
        filter: validateFilter(this.spec, options)
      }
    };
  }
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, this.initialValueTemplatesSpecified || (builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec)), builder.spec.schemaTypeName || (builder.spec.schemaTypeName = inferTypeName(builder.spec)), builder;
  }
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec() {
    return this.spec;
  }
}
function inferInitialValueTemplates(context, spec) {
  const { document: document2 } = context, { schemaTypeName, options } = spec, { filter: filter2, params } = options || { filter: "", params: {} }, typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter2, params)));
  if (typeNames.length !== 0)
    return typeNames.flatMap(
      (schemaType) => document2.resolveNewDocumentOptions({
        type: "structure",
        schemaType
      })
    ).map((option) => ({ ...option, icon: AddIcon }));
}
function inferTypeName(spec) {
  const { options } = spec, { filter: filter2, params } = options || { filter: "", params: {} }, typeNames = getTypeNamesFromFilter(filter2, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter2, params = {}) {
  let typeNames = getTypeNamesFromEqualityFilter(filter2, params);
  return typeNames.length === 0 && (typeNames = getTypeNamesFromInTypesFilter(filter2, params)), typeNames;
}
function getTypeNamesFromEqualityFilter(filter2, params = {}) {
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g, matches = [];
  let match;
  for (; (match = pattern.exec(filter2)) !== null; )
    matches.push(match[1] || match[2]);
  return matches.map((candidate) => ((candidate[0] === "$" ? params[candidate.slice(1)] : candidate) || "").trim().replace(/^["']|["']$/g, "")).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter2, params = {}) {
  const pattern = /\b_type\s+in\s+\[(.*?)\]/, matches = filter2.match(pattern);
  return matches ? matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean) : [];
}
var __defProp$3 = Object.defineProperty, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, key + "", value);
const getArgType = (thing) => thing instanceof ListBuilder ? "ListBuilder" : isPromise(thing) ? "Promise" : Array.isArray(thing) ? "array" : typeof thing, isListItem = (item) => item.type === "listItem", defaultCanHandleIntent = (intentName, params, context) => (context.pane.items || []).filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context), resolveChildForItem = (itemId, options) => {
  const target = (options.parent.items.filter(isListItem).find((item) => item.id === itemId) || { child: void 0 }).child;
  return !target || typeof target != "function" ? target : typeof target == "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder)
    return item.serialize({ path, index });
  const listItem = item;
  if (listItem && listItem.type === "divider")
    return item;
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem), helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError(
      `List items must be of type "listItem", got "${gotWhat}"${helpText}`,
      path,
      index
    ).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord(thing) && typeof thing.then == "function";
}
class ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, __publicField$3(this, "spec"), this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec && spec.initialValueTemplates);
  }
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items) {
    return this.clone({ items });
  }
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for lists",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const items = typeof this.spec.items > "u" ? [] : this.spec.items;
    if (!Array.isArray(items))
      throw new SerializeError(
        "`items` must be an array of items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    const path = (options.path || []).concat(id), serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path)), dupes = serializedItems.filter((val, i) => find(serializedItems, { id: val.id }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5), dupeDesc = dupes.length > 5 ? `${dupeIds.join(", ")}...` : dupeIds.join(", ");
      throw new SerializeError(
        `List items with same ID found (${dupeDesc})`,
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec) {
    const builder = new ListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
var __defProp$2 = Object.defineProperty, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, key + "", value);
class ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context, __publicField$2(this, "spec"), this.spec = spec || {};
  }
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon(enabled = !0) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcon: enabled }
    });
  }
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild() {
    return this.spec.child;
  }
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType) {
    return this.clone({ schemaType });
  }
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    return typeof schemaType == "string" ? this._context.schema.get(schemaType) : this.spec.schemaType;
  }
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize(options = { path: [] }) {
    const { id, title, child } = this.spec;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options.titleIsOptional && (typeof title != "string" || !title))
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(
        HELP_URL.TITLE_REQUIRED
      );
    let schemaType = this.spec.schemaType;
    if (typeof schemaType == "string") {
      const type = this._context.schema.get(schemaType);
      if (!type)
        throw new SerializeError(
          `Could not find type "${schemaType}" in schema`,
          options.path,
          id
        ).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      schemaType = type;
    }
    const serializeOptions = { path: options.path.concat(id), hint: "child" };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild == "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => originalChild(itemId, { ...childOptions, serializeOptions });
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec) {
    const builder = new ListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
var __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, key + "", value);
const createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType == "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({ schemaType, documentId }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
class DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec), this._context = _context, __publicField$1(this, "spec"), this.spec = spec || {};
  }
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize(options = { path: [] }) {
    const spec = super.serialize({ ...options, titleIsOptional: !0 });
    if (!spec.schemaType)
      throw new SerializeError(
        "`schemaType` is required for document list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return { ...spec, child, schemaType: spec.schemaType, _id: spec.id };
  }
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
function isDocumentListItem(item) {
  return isRecord(item) && typeof item.schemaType < "u" && typeof item._id == "string";
}
var __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp(obj, key + "", value);
class DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context), this._context = _context, __publicField(this, "spec"), this.spec = spec || {};
  }
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({ child });
  }
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec) {
    const parent = super.clone(withSpec), builder = new DocumentTypeListBuilder(this._context);
    return builder.spec = { ...this.spec, ...parent.getSpec(), ...withSpec || {} }, builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec), builder = new DocumentTypeListBuilder(this._context), canHandleIntent = this.spec.canHandleIntent, override = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER ? { canHandleIntent: void 0 } : {};
    return builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...withSpec || {},
      ...override
    }, builder;
  }
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a;
  return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes({ schema }) {
  return schema.getTypeNames().filter((n) => {
    const schemaType = schema.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter((n) => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  return getDocumentTypes(context).map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const { schema } = context, type = schema.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent, parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    return parentItem && parentItem.title && (list = list.title(parentItem.title)), list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const { schema, resolveDocumentNode } = context, schemaType = typeof typeNameOrSpec == "string" ? typeNameOrSpec : typeNameOrSpec.schemaType, typeName = typeof schemaType == "string" ? schemaType : schemaType.name, spec = typeof typeNameOrSpec == "string" ? { schemaType } : typeNameOrSpec, type = schema.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase(typeName);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({ type: typeName }).schemaType(type).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(
    spec.menuItemGroups || [
      {
        id: "sorting",
        title: "Sort",
        i18n: { title: { key: "menu-item-groups.actions-group", ns: structureLocaleNamespace } }
      },
      {
        id: "layout",
        title: "Layout",
        i18n: { title: { key: "menu-item-groups.layout-group", ns: structureLocaleNamespace } }
      },
      {
        id: "actions",
        title: "Actions",
        i18n: { title: { key: "menu-item-groups.sorting-group", ns: structureLocaleNamespace } }
      }
    ]
  ).child(
    spec.child || ((documentId) => resolveDocumentNode({ schemaType: typeName, documentId }))
  ).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(
    spec.menuItems || [
      // Create new (from action button) will be added in serialization step of GenericList
      // Sort by <Y>
      ...getOrderingMenuItemsForSchemaType(context, type),
      // Display as <Z>
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.compact-view", ns: structureLocaleNamespace } }).title("Compact view").icon(StackCompactIcon).action("setLayout").params({ layout: "default" }),
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.detailed-view", ns: structureLocaleNamespace } }).title("Detailed view").icon(StackIcon).action("setLayout").params({ layout: "detail" })
      // Create new (from menu) will be added in serialization step of GenericList
    ]
  );
}
function hasIcon(schemaType) {
  return !schemaType || typeof schemaType == "string" ? !1 : !!schemaType.icon;
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").i18n({ title: { key: "default-definition.content-title", ns: structureLocaleNamespace } }).items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder({
  defaultDocumentNode,
  source
}) {
  const configContext = getConfigContextFromSource(source), context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: (options) => {
      let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, { ...options, ...configContext })) || new DocumentBuilder(context);
      return builder.getId() || (builder = builder.id("documentEditor")), options.documentId && (builder = builder.documentId(getPublishedId(options.documentId))), builder.schemaType(options.schemaType);
    }
  }, structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: (...args) => getDocumentTypeList(context, ...args),
    documentTypeListItem: (...args) => getDocumentTypeListItem(context, ...args),
    documentTypeListItems: (...args) => getDocumentTypeListItems(context, ...args),
    document: (...args) => new DocumentBuilder(context, ...args),
    documentWithInitialValueTemplate: (...args) => documentFromEditorWithInitialValue(context, ...args),
    defaultDocument: context.resolveDocumentNode,
    list: (...args) => new ListBuilder(context, ...args),
    listItem: (...args) => new ListItemBuilder(context, ...args),
    menuItem: (...args) => new MenuItemBuilder(context, ...args),
    menuItemGroup: (...args) => new MenuItemGroupBuilder(context, ...args),
    menuItemsFromInitialValueTemplateItems: (...args) => menuItemsFromInitialValueTemplateItems(context, ...args),
    documentList: (...args) => new DocumentListBuilder(context, ...args),
    documentListItem: (...args) => new DocumentListItemBuilder(context, ...args),
    orderingMenuItem: (...args) => getOrderingMenuItem(context, ...args),
    orderingMenuItemsForType: (...args) => getOrderingMenuItemsForSchemaType(context, ...args),
    editor: (...args) => documentFromEditor(context, ...args),
    defaultInitialValueTemplateItems: (...args) => defaultInitialValueTemplateItems(context, ...args),
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: (spec) => isValidElementType(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec),
    divider: () => ({ id: uniqueId("__divider__"), type: "divider" }),
    view: views,
    context
  };
  return structureBuilder;
}
const LiveEditBadge = (props) => {
  const { liveEdit } = props;
  return liveEdit ? {
    label: "Live",
    color: "danger"
  } : null;
}, state = { activePanes: [] };
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a;
  const panes = (routerState == null ? void 0 : routerState.panes) || [], activePanes = state.activePanes || [], editDocumentId = params.id || uuid(), isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane2 = activePanes[i];
    if (typeof pane2 == "object" && ((_a = pane2.canHandleIntent) != null && _a.call(pane2, intent, params, {
      pane: pane2,
      index: i
    }) || // see `resolveIntent.ts` for more info
    pane2.type === "documentList" && pane2.schemaTypeName === params.type && pane2.options.filter === "_type == $type")) {
      const paneParams = isTemplate ? { template: params.template } : EMPTY_PARAMS$2;
      return {
        panes: panes.slice(0, i).concat([[{ id: editDocumentId, params: paneParams, payload }]])
      };
    }
  }
  return { intent, params, payload };
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */ new Map();
  return visitDiff(diff, (child) => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation)
      return !0;
    const { author, timestamp } = child.annotation, previous = authorMap.get(author);
    return (!previous || previous.timestamp < timestamp) && authorMap.set(author, child.annotation), !0;
  }), Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
const Scroller = styled(ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`;
function ChangesInspector(props) {
  const { onClose } = props, { documentId, schemaType, timelineError, timelineStore, value } = useDocumentPane(), scrollRef = useRef(null), diff = useTimelineSelector(timelineStore, (state2) => state2.diff), onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), selectionState = useTimelineSelector(timelineStore, (state2) => state2.selectionState), sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime), loading = selectionState === "loading", isComparingCurrent = !onOlderRevision, { t } = useTranslation("studio"), documentContext = useMemo(
    () => ({
      documentId,
      schemaType,
      FieldWrapper: ChangeFieldWrapper,
      rootDiff: diff,
      isComparingCurrent,
      value
    }),
    [documentId, diff, isComparingCurrent, schemaType, value]
  ), changeAnnotations = useMemo(
    () => diff ? collectLatestAuthorAnnotations(diff) : [],
    [diff]
  );
  return /* @__PURE__ */ jsxs(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    /* @__PURE__ */ jsx(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("changes.action.close-label"),
        flex: "none",
        onClose,
        title: t("changes.title"),
        children: /* @__PURE__ */ jsxs(Flex, { gap: 1, padding: 3, paddingTop: 0, paddingBottom: 2, children: [
          /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }) }),
          /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(
            DiffTooltip,
            {
              annotations: changeAnnotations,
              description: t("changes.changes-by-author"),
              portal: !0,
              children: /* @__PURE__ */ jsx(AvatarStack, { maxLength: 4, "aria-label": t("changes.changes-by-author"), children: changeAnnotations.map(({ author }) => /* @__PURE__ */ jsx(UserAvatar, { user: author }, author)) })
            }
          ) })
        ] })
      }
    ),
    /* @__PURE__ */ jsx(Card, { flex: 1, children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: scrollRef.current, children: /* @__PURE__ */ jsx(Scroller, { "data-ui": "Scroller", ref: scrollRef, children: /* @__PURE__ */ jsx(Box, { flex: 1, padding: 4, children: /* @__PURE__ */ jsx(
      Content,
      {
        diff,
        documentContext,
        error: timelineError,
        loading,
        schemaType
      }
    ) }) }) }) })
  ] });
}
function Content({
  error,
  diff,
  documentContext,
  loading,
  schemaType
}) {
  return error ? /* @__PURE__ */ jsx(NoChanges, {}) : loading ? /* @__PURE__ */ jsx(LoadingBlock, { showText: !0 }) : diff ? /* @__PURE__ */ jsx(DocumentChangeContext.Provider, { value: documentContext, children: /* @__PURE__ */ jsx(ChangeList, { diff, schemaType }) }) : /* @__PURE__ */ jsx(NoChanges, {});
}
const changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const { features } = useStructureTool(), { t } = useTranslation();
    return {
      hidden: !features.reviewChanges,
      icon: RestoreIcon,
      title: t("changes.title")
    };
  },
  component: ChangesInspector,
  onClose: ({ params }) => ({ params: { ...params, since: void 0 } }),
  onOpen: ({ params }) => ({ params: { ...params, since: "@lastPublished" } })
};
function getPathTitles(options) {
  const { path, schemaType, value } = options, result = [];
  let s = schemaType, v = value;
  for (const segment of path) {
    if (typeof segment == "string") {
      if (!isRecord(v) && v !== void 0)
        throw new Error(`Parent value is not an object, cannot get path segment: .${segment}`);
      if (s.jsonType !== "object")
        throw new Error(
          `Parent type is not an object schema type, cannot get path segment: .${segment}`
        );
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field)
        return result.push({ name: segment }), result;
      s = field.type, result.push(s);
      continue;
    }
    if (typeof segment == "number") {
      if (!isArray(v) && v !== void 0)
        throw new Error(`Parent value is not an array, cannot get path segment: [${segment}]`);
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: [${segment}]`
        );
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find((ofType) => typeof v == "string" ? ofType.jsonType === "string" : typeof v == "number" ? ofType.jsonType === "number" : typeof v == "boolean" ? ofType.jsonType === "boolean" : isRecord(v) ? ofType.name === (v == null ? void 0 : v._type) : !1);
      if (!itemType)
        throw new Error(`Item type not found: [${segment}]`);
      s = itemType, result.push(s);
      continue;
    }
    if (isRecord(segment) && segment._key) {
      if (!isArray(v))
        throw new Error(
          `Parent value is not an array, cannot get path segment: [_key == ${segment}]`
        );
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: .${segment}`
        );
      if (v = (v != null ? v : []).find((i) => isRecord(i) && i._key === segment._key), !isRecord(v))
        throw new Error(`Array item not found: [_key == ${segment._key}]`);
      const ofType = s.of.find((i) => isRecord(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType)
        throw new Error(`Array item type not found: .${v == null ? void 0 : v._type}`);
      s = ofType, result.push(s);
      continue;
    }
    throw new Error(`Invalid path segment: ${JSON.stringify(segment)}`);
  }
  return result;
}
const MARKER_ICON = {
  error: ErrorOutlineIcon,
  warning: WarningOutlineIcon,
  info: InfoOutlineIcon
}, MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const { onClose } = props, { onFocus, onPathOpen, schemaType, validation, value } = useDocumentPane(), { t } = useTranslation("validation"), handleOpen = useCallback(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onFocus, onPathOpen]
  );
  return /* @__PURE__ */ jsxs(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [
    /* @__PURE__ */ jsx(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("panel.close-button-aria-label"),
        flex: "none",
        onClose,
        title: t("panel.title")
      }
    ),
    /* @__PURE__ */ jsxs(Card, { flex: 1, overflow: "auto", padding: 3, children: [
      validation.length === 0 && /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("panel.no-errors-message") }) }),
      validation.length > 0 && /* @__PURE__ */ jsx(Stack, { space: 2, children: validation.map((marker, i) => /* @__PURE__ */ jsx(
        ValidationCard,
        {
          marker,
          onOpen: handleOpen,
          schemaType,
          value
        },
        i
      )) })
    ] })
  ] });
}
function ValidationCard(props) {
  const { marker, onOpen, schemaType, value } = props, handleOpen = useCallback(() => onOpen(marker.path), [marker, onOpen]), [errorInfo, setErrorInfo] = useState(null);
  return /* @__PURE__ */ jsxs(ErrorBoundary, { onCatch: setErrorInfo, children: [
    errorInfo && /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsx(Text, { size: 1, children: errorInfo.error.message }) }),
    !errorInfo && /* @__PURE__ */ jsx(
      Card,
      {
        __unstable_focusRing: !0,
        as: "button",
        onClick: handleOpen,
        padding: 3,
        radius: 2,
        tone: MARKER_TONE[marker.level],
        children: /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, children: [
          /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: createElement(MARKER_ICON[marker.level]) }) }),
          /* @__PURE__ */ jsxs(Stack, { flex: 1, space: 2, children: [
            /* @__PURE__ */ jsx(
              DocumentNodePathBreadcrumbs,
              {
                path: marker.path,
                schemaType,
                value
              }
            ),
            /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: marker.message })
          ] })
        ] })
      }
    )
  ] });
}
function DocumentNodePathBreadcrumbs(props) {
  const { path, schemaType, value } = props, pathTitles = useMemo(() => {
    try {
      return getPathTitles({ path, schemaType, value });
    } catch (e) {
      console.error(e);
    }
    return null;
  }, [path, schemaType, value]);
  return pathTitles != null && pathTitles.length ? /* @__PURE__ */ jsx(Text, { size: 1, children: pathTitles.map((t, i) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
    i > 0 && /* @__PURE__ */ jsx("span", { style: { color: "var(--card-muted-fg-color)", opacity: 0.5 }, children: " / " }),
    /* @__PURE__ */ jsx("span", { style: { fontWeight: 500 }, children: t.title || t.name })
  ] }, i)) }) : null;
}
function useMenuItem(props) {
  const { documentId, documentType } = props, { t } = useTranslation("validation"), { validation: validationMarkers } = useValidationStatus(documentId, documentType), validation = useMemo(
    () => validationMarkers.map((item) => ({
      level: item.level,
      message: item.message,
      path: item.path
    })),
    [validationMarkers]
  ), hasErrors = validation.some(isValidationError), hasWarnings = validation.some(isValidationWarning), icon = useMemo(() => hasErrors ? ErrorOutlineIcon : hasWarnings ? WarningOutlineIcon : CheckmarkCircleIcon, [hasErrors, hasWarnings]), tone = useMemo(() => hasErrors ? "critical" : hasWarnings ? "caution" : "positive", [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0,
    icon,
    title: t("panel.title"),
    tone,
    showAsAction: !0
  };
}
const validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
}, EMPTY_PARAMS = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch {
    return console.warn("Failed to parse JSON parameters"), {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
const router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [
    route.create({
      path: "/:params",
      transform: { params: { toState: legacyEditParamsToState, toPath: legacyEditParamsToPath } }
    })
  ]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: {
      panes: { toState, toPath }
    }
  })
]), panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i, isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str), isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str), exclusiveParams = ["view", "since", "rev", "inspect", "comment"], isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = { ...initial, params: EMPTY_PARAMS, payload: void 0 };
  return chunks.reduce((pane2, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("=")), value = chunk.slice(key.length + 1);
      pane2.params = { ...pane2.params, [decodeURIComponent(key)]: decodeURIComponent(value) };
    } else isPayloadLike(chunk) ? pane2.payload = tryParseBase64Payload(chunk) : console.warn("Unknown pane segment: %s - skipping", chunk);
    return pane2;
  }, sibling);
}
function encodeChunks(pane2, index, group) {
  const { payload, params = {}, id } = pane2, [firstSibling] = group, paneIsFirstSibling = pane2 === firstSibling, sameAsFirst = index !== 0 && id === firstSibling.id, encodedPayload = typeof payload > "u" ? void 0 : encodeJsonParams(payload), encodedParams = Object.entries(params).filter((entry) => {
    var _a;
    const [key, value] = entry;
    if (!value) return !1;
    if (paneIsFirstSibling) return !0;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    return !(value === valueFromFirstSibling && !exclusiveParams.includes(key));
  }).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  return str.indexOf(",{") !== -1 ? parseOldPanesSegment(str) : str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, { id });
    });
    return [
      firstSibling,
      ...restOfSiblings.map((sibling) => ({
        ...firstSibling,
        ...sibling,
        id: sibling.id || firstSibling.id,
        params: { ...omit(firstSibling.params, exclusiveParams), ...sibling.params },
        payload: sibling.payload || firstSibling.payload
      }))
    ];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  for (; buffer.length; ) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({ id, payload }), buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? decodeJsonParams(data) : void 0;
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
const documentActions = [
  PublishAction,
  UnpublishAction,
  DiscardChangesAction,
  DuplicateAction,
  DeleteAction,
  HistoryRestoreAction
], documentBadges = [LiveEditBadge], inspectors = [validationInspector, changesInspector], structureTool = definePlugin((options) => {
  const icon = (options == null ? void 0 : options.icon) || MasterDetailIcon;
  return {
    name: "sanity/structure",
    document: {
      actions: (prevActions) => Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions])),
      badges: (prevBadges) => Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges])),
      inspectors: (prevInspectors) => Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]))
    },
    tools: [
      {
        name: (options == null ? void 0 : options.name) || "structure",
        title: (options == null ? void 0 : options.title) || "Structure",
        icon,
        component: lazy(() => import("./index.esm3.js")),
        canHandleIntent: (intent, params) => intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : !1,
        getIntentState,
        // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
        controlsDocumentTitle: !0,
        options,
        router
      }
    ],
    i18n: {
      bundles: [structureUsEnglishLocaleBundle]
    }
  };
});
function canHandleCreateIntent(params) {
  return "type" in params ? "template" in params ? { template: !0 } : !0 : !1;
}
function canHandleEditIntent(params) {
  return "id" in params ? "mode" in params ? { mode: params.mode === "structure" } : !0 : !1;
}
function StructureToolProvider({
  defaultDocumentNode,
  structure: resolveStructure,
  children
}) {
  const [layoutCollapsed, setLayoutCollapsed] = useState(!1), source = useSource(), configContext = useConfigContextFromSource(source), documentStore = useDocumentStore(), S = useMemo(() => createStructureBuilder({
    defaultDocumentNode,
    source
  }), [defaultDocumentNode, source]), rootPaneNode = useMemo(() => resolveStructure ? resolveStructure(S, {
    ...configContext,
    documentStore
  }) : S.defaults(), [S, resolveStructure, configContext, documentStore]), features = useMemo(
    () => ({
      backButton: layoutCollapsed,
      resizablePanes: !layoutCollapsed,
      reviewChanges: !layoutCollapsed,
      splitPanes: !layoutCollapsed,
      splitViews: !layoutCollapsed
    }),
    [layoutCollapsed]
  ), structureTool2 = useMemo(() => ({
    features,
    layoutCollapsed,
    setLayoutCollapsed,
    rootPaneNode,
    structureContext: S.context
  }), [features, layoutCollapsed, rootPaneNode, S.context]);
  return /* @__PURE__ */ jsx(StructureToolContext.Provider, { value: structureTool2, children });
}
var pane$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: DocumentPane
}), pane = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: PaneContainer
});
export {
  BackLink,
  ChildLink,
  ComponentBuilder,
  ComponentViewBuilder,
  ConfirmDeleteDialogContainer,
  DEFAULT_INTENT_HANDLER,
  DocumentBuilder,
  DocumentInspectorHeader,
  DocumentListBuilder,
  DocumentListItemBuilder,
  DocumentPane,
  DocumentPaneProvider,
  DocumentTypeListBuilder,
  FormViewBuilder,
  GenericListBuilder,
  GenericViewBuilder,
  HELP_URL,
  InitialValueTemplateItemBuilder,
  LOADING_PANE,
  ListBuilder,
  ListItemBuilder,
  LoadingPane,
  MenuItemBuilder,
  MenuItemGroupBuilder,
  Pane,
  PaneContainer,
  PaneContent,
  PaneHeader$1 as PaneHeader,
  PaneHeaderActions,
  PaneItem,
  PaneLayout,
  ParameterizedLink,
  ReferenceChildLink,
  SerializeError,
  StructureToolProvider,
  _DEBUG,
  component,
  createStructureBuilder,
  defaultInitialValueTemplateItems,
  defaultIntentChecker,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  form,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  getTypeNamesFromFilter,
  isDocumentListItem,
  maybeSerializeInitialValueTemplateItem,
  maybeSerializeMenuItem,
  maybeSerializeMenuItemGroup,
  maybeSerializeView,
  menuItemsFromInitialValueTemplateItems,
  pane$1 as pane,
  pane as pane$1,
  setActivePanes,
  shallowIntentChecker,
  structureLocaleNamespace,
  structureTool,
  useDocumentPane,
  useDocumentTitle,
  usePane,
  usePaneLayout,
  usePaneRouter,
  useStructureTool
};
//# sourceMappingURL=pane.esm.js.map
