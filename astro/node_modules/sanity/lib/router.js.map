{"version":3,"file":"router.js","sources":["../src/router/useRouter.ts","../src/router/useLink.ts","../src/router/useIntentLink.ts","../src/router/IntentLink.tsx","../src/router/Link.tsx","../src/router/_parseRoute.ts","../src/router/utils/arrayify.ts","../src/router/_findMatchingRoutes.ts","../src/router/encodeURIComponentExcept.ts","../src/router/utils/debug.ts","../src/router/_resolvePathFromState.ts","../src/router/utils/parseScopedParams.ts","../src/router/_resolveStateFromPath.ts","../src/router/utils/base64url.ts","../src/router/utils/jsonParamsEncoding.ts","../src/router/utils/paramsEncoding.ts","../src/router/route.ts","../src/router/RouterProvider.tsx","../src/router/RouteScope.tsx","../src/router/useStateLink.ts","../src/router/StateLink.tsx","../src/router/useRouterState.ts","../src/router/withRouter.tsx"],"sourcesContent":["import {useContext} from 'react'\nimport {RouterContext} from 'sanity/_singletons'\n\nimport {type RouterContextValue} from './types'\n\n/**\n * Returns the router context value.\n * @public\n *\n * @returns The router context value.\n *  {@link RouterContextValue}\n * @throws An error if the router context value is missing.\n *\n * @example\n * ```tsx\n * const router = useRouter()\n * ```\n */\nexport function useRouter(): RouterContextValue {\n  const router = useContext(RouterContext)\n\n  if (!router) {\n    throw new Error('Router: missing context value')\n  }\n\n  return router\n}\n","import {useCallback} from 'react'\n\nimport {useRouter} from './useRouter'\n\nfunction isLeftClickEvent(event: React.MouseEvent) {\n  return event.button === 0\n}\n\nfunction isModifiedEvent(event: React.MouseEvent) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n}\n\n/**\n * @public\n */\nexport interface UseLinkOptions {\n  /**\n   * The URL that the link should navigate to.\n   */\n  href?: string\n\n  /**\n   * The event handler function that should be called when the link is clicked.\n   */\n  onClick?: React.MouseEventHandler<HTMLElement>\n\n  /**\n   * Whether the link should replace the current URL in the browser history.\n   */\n  replace?: boolean\n\n  /**\n   * The target window or frame that the linked document will open in.\n   */\n  target?: string\n}\n\n/**\n * Returns an object with an `onClick` function that can be used as a click handler for a link.\n *\n * @public\n *\n * @param options - An object containing the properties for the link.\n *  See {@link UseLinkOptions}\n *\n * @returns An object with an `onClick` function.\n *\n * @example\n * ```tsx\n * const linkProps = useLink({\n *  href: 'https://www.sanity.io',\n *  target: '_blank'\n * })\n *\n * <a {...linkProps}>Link</a>\n * ```\n */\nexport function useLink(options: UseLinkOptions): {onClick: React.MouseEventHandler<HTMLElement>} {\n  const {onClick: onClickProp, href, target, replace = false} = options\n  const {navigateUrl} = useRouter()\n\n  const onClick = useCallback(\n    (event: React.MouseEvent<HTMLElement>): void => {\n      if (event.isDefaultPrevented()) {\n        return\n      }\n\n      if (!href) return\n\n      if (onClickProp) {\n        onClickProp(event)\n      }\n\n      if (isModifiedEvent(event) || !isLeftClickEvent(event)) {\n        return\n      }\n\n      // If target prop is set (e.g. to \"_blank\") let browser handle link.\n      if (target) {\n        return\n      }\n\n      event.preventDefault()\n\n      navigateUrl({path: href, replace})\n    },\n    [href, navigateUrl, onClickProp, replace, target],\n  )\n\n  return {onClick: onClick}\n}\n","import {useMemo} from 'react'\n\nimport {type IntentParameters} from './types'\nimport {useLink} from './useLink'\nimport {useRouter} from './useRouter'\n\n/**\n * @public\n */\nexport interface UseIntentLinkOptions {\n  /**\n   * The name of the intent to trigger.\n   */\n  intent: string\n\n  /**\n   * An optional click event handler.\n   */\n  onClick?: React.MouseEventHandler<HTMLElement>\n\n  /**\n   * Optional parameters to pass to the intent. See {@link IntentParameters}\n   */\n  params?: IntentParameters\n\n  /**\n   * Whether to replace the current URL in the browser history.\n   */\n  replace?: boolean\n\n  /**\n   * The target window or frame to open the link in.\n   */\n  target?: string\n}\n\n/**\n *\n * Returns props for an anchor element that will trigger an intent when clicked.\n *\n * @example\n * ```tsx\n * const {onClick, href} = useIntentLink({\n *   intent: 'edit',\n *   params: {id: 'foo'}\n * })\n *\n * <a href={href} onClick={onClick}>Link to \"foo\" editor</a>\n * ```\n *\n * @public\n *\n * @param options - Options to use for the link\n *  {@link UseIntentLinkOptions}\n *\n * @returns - An object with `onClick` and `href` props to use for the link\n */\nexport function useIntentLink(options: UseIntentLinkOptions): {\n  onClick: React.MouseEventHandler<HTMLElement>\n  href: string\n} {\n  const {intent, onClick: onClickProp, params, replace, target} = options\n  const {resolveIntentLink} = useRouter()\n  const href = useMemo(() => resolveIntentLink(intent, params), [intent, params, resolveIntentLink])\n  const {onClick} = useLink({href, onClick: onClickProp, replace, target})\n\n  return {onClick, href}\n}\n","import {type ForwardedRef, forwardRef, type HTMLProps} from 'react'\n\nimport {type IntentParameters} from './types'\nimport {useIntentLink} from './useIntentLink'\n\n/**\n * Props for the {@link IntentLink} component.\n *\n * @public\n */\nexport interface IntentLinkProps {\n  /**\n   * The name of the intent.\n   */\n  intent: string\n\n  /**\n   * The parameters to include in the intent.\n   * {@link IntentParameters}\n   */\n  params?: IntentParameters\n\n  /**\n   * Whether to replace the current URL in the browser history instead of adding a new entry.\n   */\n  replace?: boolean\n}\n\n/**\n * @public\n *\n * @param props - Props to pass to `IntentLink` component.\n *  See {@link IntentLinkProps}\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *  return <IntentLink intent=\"edit\" params={{id: 'abc123'}}>Edit</IntentLink>\n * }\n * ```\n */\nexport const IntentLink = forwardRef(function IntentLink(\n  props: IntentLinkProps & HTMLProps<HTMLAnchorElement>,\n  ref: ForwardedRef<HTMLAnchorElement>,\n) {\n  const {intent, params, target, ...restProps} = props\n  const {onClick, href} = useIntentLink({\n    intent,\n    params,\n    target,\n    onClick: props.onClick,\n  })\n\n  return <a {...restProps} href={href} onClick={onClick} ref={ref} target={target} />\n})\n","import {type ForwardedRef, forwardRef, type HTMLProps} from 'react'\n\nimport {useLink} from './useLink'\n\n/**\n * Props for the {@link Link} component.\n *\n * @public\n */\nexport interface LinkProps {\n  /**\n   * Whether to replace the current URL in the browser history instead of adding a new entry.\n   */\n  replace?: boolean\n}\n\n/**\n * A component that creates an HTML anchor element.\n *\n * @public\n *\n * @param props - Props to pass to the `Link` component.\n *  See {@link LinkProps}\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   return (\n *    <Link href=\"https://www.sanity.io\" target=\"_blank\" replace>\n *      Go to Sanity\n *    </Link>\n *   )\n * }\n * ```\n */\nexport const Link = forwardRef(function Link(\n  props: LinkProps & HTMLProps<HTMLAnchorElement>,\n  ref: ForwardedRef<HTMLAnchorElement>,\n) {\n  const {onClick: onClickProp, href, target, replace, ...restProps} = props\n  const {onClick} = useLink({onClick: onClickProp, href, target, replace})\n\n  return <a {...restProps} onClick={onClick} href={href} target={target} ref={ref} />\n})\n","import {type Route, type RouteSegment} from './types'\n\nconst VALID_PARAM_SEGMENT = /^[a-zA-Z0-9_-]+$/\n\nfunction createSegment(segment: string): RouteSegment | null {\n  if (!segment) {\n    return null\n  }\n\n  if (segment.startsWith(':')) {\n    const paramName = segment.slice(1)\n\n    if (!VALID_PARAM_SEGMENT.test(paramName)) {\n      const addendum = segment.includes('*')\n        ? ' Splats are not supported. Consider using child routes instead'\n        : ''\n      // eslint-disable-next-line no-console\n      console.error(\n        new Error(`Warning: Param segments \"${segment}\" includes invalid characters.${addendum}`),\n      )\n    }\n\n    return {type: 'param', name: paramName}\n  }\n\n  return {type: 'dir', name: segment}\n}\n\n/** @internal */\nexport function _parseRoute(route: string): Route {\n  const [pathname] = route.split('?')\n\n  const segments = pathname.split('/').map(createSegment).filter(Boolean) as RouteSegment[]\n\n  return {\n    raw: route,\n    segments: segments,\n  }\n}\n","export function arrayify<T>(val: Array<T> | T): Array<T> {\n  if (Array.isArray(val)) {\n    return val\n  }\n\n  return val ? [val] : []\n}\n","import {difference, intersection, isPlainObject, pick} from 'lodash'\n\nimport {\n  type InternalSearchParam,\n  type MatchError,\n  type MatchOk,\n  type MatchResult,\n  type RouterNode,\n  type RouterState,\n} from './types'\nimport {arrayify} from './utils/arrayify'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return isPlainObject(value)\n}\n\nfunction createMatchError(\n  node: RouterNode,\n  missingKeys: string[],\n  unmappableStateKeys: string[],\n): MatchError {\n  return {type: 'error', node, missingKeys, unmappableStateKeys}\n}\n\nfunction createMatchOk(\n  node: RouterNode,\n  matchedState: Record<string, string>,\n  searchParams: InternalSearchParam[],\n  child?: MatchOk | undefined,\n): MatchOk {\n  return {type: 'ok', node, matchedState, searchParams, child}\n}\n\n/** @internal */\nexport function _findMatchingRoutes(node: RouterNode, _state?: RouterState): MatchResult {\n  if (!_state) {\n    return createMatchOk(node, {}, [])\n  }\n\n  const scopedState = node.scope ? (_state[node.scope] as RouterState) : _state\n\n  const {_searchParams: searchParams = [], ...state} = scopedState || {}\n\n  const requiredParams = node.route.segments\n    .filter((seg) => seg.type === 'param')\n    .map((seg) => seg.name)\n\n  const stateKeys = isRecord(state) ? Object.keys(state) : []\n\n  // These are params found in both the state and the route definition\n  const consumedParams = intersection(stateKeys, requiredParams)\n\n  // these are params found in the route definition but not in the state, can't map them to a route\n  const missingParams = difference(requiredParams, consumedParams)\n\n  // these are params found in the state but not in the route definition\n  const remainingParams = difference(stateKeys, consumedParams)\n\n  if (missingParams.length > 0) {\n    return createMatchError(node, missingParams, [])\n  }\n\n  const scopedParams = searchParams.map(([key, value]): InternalSearchParam => [[key], value])\n\n  const consumedState = pick(state, consumedParams) as Record<string, string>\n\n  if (remainingParams.length === 0) {\n    return createMatchOk(node, consumedState, scopedParams)\n  }\n\n  const children = arrayify(\n    (typeof node.children === 'function'\n      ? node.children(isRecord(state) ? state : {})\n      : node.children) || [],\n  )\n\n  if (remainingParams.length > 0 && children.length === 0) {\n    // our state includes extra keys that's not consumed by child routes\n    return createMatchError(node, [], remainingParams)\n  }\n\n  const remainingState = pick(state, remainingParams)\n\n  const childResult = children.map((childNode) => _findMatchingRoutes(childNode, remainingState))\n\n  // Look for a matching route\n  const found = childResult.find((res): res is MatchOk => res.type === 'ok')\n  return found\n    ? createMatchOk(node, consumedState, scopedParams, found)\n    : createMatchError(node, [], remainingParams)\n}\n","/**\n * Like encodeURIComponent, but supports a custom set of unescaped characters.\n * @param uriComponent - A value representing an unencoded URI component.\n * @param unescaped - a string containing characters to not escape\n */\nexport function encodeURIComponentExcept(\n  uriComponent: string | number | boolean,\n  unescaped: string,\n): string {\n  const chars = [...String(uriComponent)]\n  let res = ''\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    if (unescaped.includes(char)) {\n      res += char\n    } else {\n      res += encodeURIComponent(char)\n    }\n  }\n  return res\n}\n","import Debug from 'debug'\n\nexport const debug = Debug('state-router')\n","import {_findMatchingRoutes} from './_findMatchingRoutes'\nimport {encodeURIComponentExcept} from './encodeURIComponentExcept'\nimport {type InternalSearchParam, type MatchOk, type RouterNode, type RouterState} from './types'\nimport {debug} from './utils/debug'\n\n/** @internal */\nexport function _resolvePathFromState(node: RouterNode, _state: RouterState): string {\n  debug('Resolving path from state %o', _state)\n\n  const match = _findMatchingRoutes(node, _state)\n  if (match.type === 'error') {\n    const unmappable = match.unmappableStateKeys\n    if (unmappable.length > 0) {\n      throw new Error(\n        `Unable to find matching route for state. Could not map the following state key${\n          unmappable.length == 1 ? '' : 's'\n        } to a valid url: ${unmappable.map(quote).join(', ')}`,\n      )\n    }\n    const missingKeys = match.missingKeys\n    throw new Error(\n      `Unable to find matching route for state. State object is missing the following key${\n        missingKeys.length == 1 ? '' : 's'\n      } defined in route: ${missingKeys.map(quote).join(', ')}`,\n    )\n  }\n\n  const {path, searchParams} = pathFromMatchResult(match)\n\n  const search = searchParams.length > 0 ? encodeParams(searchParams) : ''\n\n  return `/${path.join('/')}${search ? `?${search}` : ''}`\n}\n\nfunction bracketify(value: string): string {\n  return `[${value}]`\n}\n\nfunction encodeParams(params: InternalSearchParam[]): string {\n  return params\n    .flatMap(([key, value]) => {\n      if (value === undefined) {\n        return []\n      }\n      return [encodeSearchParamKey(serializeScopedPath(key)), encodeSearchParamValue(value)].join(\n        '=',\n      )\n    })\n    .join('&')\n}\n\nfunction serializeScopedPath(scopedPath: string[]): string {\n  const [head, ...tail] = scopedPath\n\n  return tail.length > 0 ? [head, ...tail.map(bracketify)].join('') : head\n}\n\nfunction encodeSearchParamValue(value: string): string {\n  return encodeURIComponentExcept(value, '/')\n}\n\nfunction encodeSearchParamKey(value: string): string {\n  return encodeURIComponentExcept(value, '[]')\n}\n\nfunction pathFromMatchResult(match: MatchOk): {\n  path: string[]\n  searchParams: InternalSearchParam[]\n} {\n  const matchedState = match.matchedState\n\n  const base = match.node.route.segments.map((segment) => {\n    if (segment.type === 'dir') {\n      return segment.name\n    }\n\n    const transform = match.node.transform && match.node.transform[segment.name]\n\n    return transform\n      ? transform.toPath(matchedState[segment.name] as any)\n      : matchedState[segment.name]\n  })\n\n  const childMatch = match.child ? pathFromMatchResult(match.child) : undefined\n\n  const searchParams = childMatch?.searchParams\n    ? [...match.searchParams, ...childMatch.searchParams]\n    : match.searchParams\n\n  return {\n    searchParams: addNodeScope(match.node, searchParams),\n    path: [...(base || []), ...(childMatch?.path || [])],\n  }\n}\n\nfunction addNodeScope(\n  node: RouterNode,\n  searchParams: InternalSearchParam[],\n): InternalSearchParam[] {\n  const scope = node.scope\n  return scope && !node.__unsafe_disableScopedSearchParams\n    ? searchParams.map(([namespaces, value]) => [[scope, ...namespaces], value])\n    : searchParams\n}\n\nfunction quote(value: string): string {\n  return `\"${value}\"`\n}\n","import {type InternalSearchParam} from '../types'\n\nexport function parseScopedParams(params: [key: string, value: string][]): InternalSearchParam[] {\n  return params.map(([key, value]) => [parse(key), value])\n}\n\nconst OPEN = 1\nconst CLOSED = 0\n\nfunction parse(str: string) {\n  const result = []\n  let i = 0\n  let state = CLOSED\n  while (i < str.length) {\n    const nextBracketIdx = str.indexOf('[', i)\n    if (nextBracketIdx === -1) {\n      result.push(str.slice(i, str.length))\n      break\n    }\n    if (state === OPEN) {\n      throw new Error('Nested brackets not supported')\n    }\n    state = OPEN\n    if (nextBracketIdx > i) {\n      result.push(str.slice(i, nextBracketIdx))\n      i = nextBracketIdx\n    }\n\n    const nextClosing = str.indexOf(']', nextBracketIdx)\n    if (nextClosing === -1) {\n      if (state === OPEN) {\n        throw new Error('Unclosed bracket')\n      }\n      break\n    }\n    state = CLOSED\n    result.push(str.slice(i + 1, nextClosing))\n    i = nextClosing + 1\n  }\n  return result\n}\n","import {\n  type InternalSearchParam,\n  type RouterNode,\n  type RouterState,\n  type SearchParam,\n} from './types'\nimport {arrayify} from './utils/arrayify'\nimport {debug} from './utils/debug'\nimport {parseScopedParams} from './utils/parseScopedParams'\n\nfunction matchPath(\n  node: RouterNode,\n  path: string,\n  searchParams: InternalSearchParam[],\n): RouterState | null {\n  const parts = path.split('/').filter(Boolean)\n  const segmentsLength = node.route.segments.length\n\n  if (parts.length < segmentsLength) {\n    return null\n  }\n\n  const state: RouterState = {}\n  const isMatching = node.route.segments.every((segment, i) => {\n    if (segment.type === 'dir') {\n      return segment.name === parts[i]\n    }\n\n    const transform = node.transform && node.transform[segment.name]\n\n    state[segment.name] = transform ? transform.toState(parts[i]) : parts[i]\n\n    return true\n  })\n\n  if (!isMatching) {\n    return null\n  }\n\n  const rest = parts.slice(segmentsLength)\n\n  let childState: RouterState | null = null\n\n  const children =\n    typeof node.children === 'function' ? arrayify(node.children(state)) : node.children\n\n  const unscopedParams = removeScope(node.scope, searchParams)\n\n  children.some((childNode) => {\n    if (childNode) {\n      const childParams = childNode.scope\n        ? unscopedParams.filter(([namespaces]) => childNode.scope === namespaces[0])\n        : unscopedParams\n\n      childState = matchPath(childNode, rest.join('/'), childParams)\n      return childState\n    }\n    return undefined\n  })\n\n  if (rest.length > 0 && !childState) {\n    return null\n  }\n\n  const selfParams = unscopedParams.flatMap(([namespace, value]): SearchParam[] => {\n    return namespace.length === 1 ? [[namespace[0], value]] : []\n  })\n\n  const mergedState: RouterState = {\n    ...state,\n    ...(childState || {}),\n    ...(selfParams.length > 0 ? {_searchParams: selfParams} : {}),\n  }\n\n  return node.scope ? {[node.scope]: mergedState} : mergedState\n}\n\n/**\n * @internal\n */\nexport function _resolveStateFromPath(node: RouterNode, path: string): Record<string, any> | null {\n  debug('resolving state from path %s', path)\n\n  const [pathname, search] = path.split('?')\n  const urlSearchParams = Array.from(new URLSearchParams(search).entries())\n\n  const pathMatch = matchPath(node, pathname, parseScopedParams(urlSearchParams))\n\n  debug('resolved: %o', pathMatch || null)\n\n  return pathMatch || null\n}\n\nfunction removeScope(\n  scope: string | undefined,\n  searchParams: InternalSearchParam[],\n): InternalSearchParam[] {\n  return scope\n    ? searchParams.map(([namespaces, value]) => [\n        namespaces[0] === scope ? namespaces.slice(1) : namespaces,\n        value,\n      ])\n    : searchParams\n}\n","/**\n * `atob()` and `btoa()` do not support Unicode characters outside of the Latin1 range,\n * but we obviously want to support the full range of Unicode characters in our router.\n *\n * Additionally, we would prefer not to use characters like `+` and `=` in URLs, as they\n * have specific meanings there and may be misinterpreted. Thus, this uses base64url instead\n * of the more common base64.\n */\n\n/**\n * Encodes a string as base64url\n *\n * @param str - String to encode\n * @returns Encoded string\n * @internal\n */\nexport function encodeBase64Url(str: string): string {\n  return encodeBase64(str).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/[=]+$/, '')\n}\n\n/**\n * Decodes a base64url-encoded string\n *\n * @param str - String to decode\n * @returns Decoded string\n * @internal\n */\nexport function decodeBase64Url(str: string): string {\n  return decodeBase64(str.replace(/-/g, '+').replace(/_/g, '/'))\n}\n\nfunction percentToByte(p: string) {\n  return String.fromCharCode(parseInt(p.slice(1), 16))\n}\n\nfunction encodeBase64(str: string): string {\n  return btoa(encodeURIComponent(str).replace(/%[0-9A-F]{2}/g, percentToByte))\n}\n\nfunction byteToPercent(b: string) {\n  return `%${`00${b.charCodeAt(0).toString(16)}`.slice(-2)}`\n}\n\nfunction decodeBase64(str: string): string {\n  return decodeURIComponent(Array.from(atob(str), byteToPercent).join(''))\n}\n","import {decodeBase64Url, encodeBase64Url} from './base64url'\n\n/**\n * Decode a path segment containing JSON parameters\n *\n * @param pathSegment - The path segment to decode\n * @returns The decoded parameters\n * @internal\n * @hidden\n */\nexport function decodeJsonParams(pathSegment = ''): Record<string, unknown> {\n  const segment = decodeURIComponent(pathSegment)\n\n  if (!segment) {\n    return {}\n  }\n\n  // Because of high-unicode characters (eg outside of the latin1 range), we prefer base64url\n  // since it also removes characters we'd rather not put in our URLs (eg '=' and '/')\n  try {\n    return JSON.parse(decodeBase64Url(segment))\n  } catch (err) {\n    // Fall-through: previously we used plain base64 encoding instead of base64url\n  }\n\n  try {\n    return JSON.parse(atob(segment))\n  } catch (err) {\n    // Fall-through: before _that_, we used plain URI encoding\n  }\n\n  try {\n    return JSON.parse(segment)\n  } catch (err) {\n    console.warn('Failed to parse JSON parameters')\n  }\n\n  return {}\n}\n\n/**\n * Encodes a set of parameters as a path segment, using base64url\n *\n * @param params - Paramters to encode\n * @returns The encoded parameters as a path segment\n * @internal\n * @hidden\n */\nexport function encodeJsonParams(params?: Record<string, unknown>): string {\n  return params ? encodeBase64Url(JSON.stringify(params)) : ''\n}\n","export function decodeParams(pathSegment: string): Record<string, string> {\n  return pathSegment.split(';').reduce<Record<string, string>>((params, pair) => {\n    const [key, value] = pair.split('=')\n\n    params[decodeURIComponent(key)] = decodeURIComponent(value)\n\n    return params\n  }, {})\n}\n\nexport function encodeParams(params: Record<string, string | undefined | null>): string {\n  return Object.entries(params)\n    .filter(([, value]) => value !== undefined && value !== null)\n    .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value as string)}`)\n    .join(';')\n}\n","import {_parseRoute} from './_parseRoute'\nimport {_resolvePathFromState} from './_resolvePathFromState'\nimport {_resolveStateFromPath} from './_resolveStateFromPath'\nimport {type RouteChildren, type Router, type RouteTransform} from './types'\nimport {decodeJsonParams, encodeJsonParams} from './utils/jsonParamsEncoding'\nimport {decodeParams, encodeParams} from './utils/paramsEncoding'\n\n/**\n * @public\n */\nexport interface RouteNodeOptions {\n  /**\n   * The path of the route node.\n   */\n  path?: string\n  /**\n   * The children of the route node. See {@link RouteChildren}\n   */\n  children?: RouteChildren\n  /**\n   * The transforms to apply to the route node. See {@link RouteTransform}\n   */\n  transform?: {\n    [key: string]: RouteTransform<any>\n  }\n  /**\n   * The scope of the route node.\n   */\n  scope?: string\n\n  /**\n   * Optionally disable scoping of search params\n   * Scoped search params will be represented as scope[param]=value in the url\n   * Disabling this will still scope search params based on any parent scope unless the parent scope also has disabled search params scoping\n   * Caution: enabling this can cause conflicts with multiple plugins defining search params with the same name\n   */\n  __unsafe_disableScopedSearchParams?: boolean\n}\n\n/**\n * Interface for the {@link route} object.\n *\n * @public\n */\nexport interface RouteObject {\n  /**\n   * Creates a new router.\n   * Returns {@link Router}\n   * See {@link RouteNodeOptions} and {@link RouteChildren}\n   */\n  create: (\n    routeOrOpts: RouteNodeOptions | string,\n    childrenOrOpts?: RouteNodeOptions | RouteChildren | null,\n    children?: Router | RouteChildren,\n  ) => Router\n\n  /**\n   * Creates a new router for handling intents.\n   * Returns {@link Router}\n   */\n  intents: (base: string) => Router\n\n  /**\n   * Creates a new router scope.\n   * Returns {@link Router}\n   */\n  scope(\n    scopeName: string,\n    routeOrOpts: RouteNodeOptions | string,\n    childrenOrOpts?: RouteNodeOptions | RouteChildren | null,\n    children?: Router | RouteChildren,\n  ): Router\n}\n\n/**\n * An object containing functions for creating routers and router scopes.\n * See {@link RouteObject}\n *\n * @public\n *\n * @example\n * ```ts\n * const router = route.create({\n *   path: \"/foo\",\n *   children: [\n *     route.create({\n *       path: \"/bar\",\n *       children: [\n *         route.create({\n *           path: \"/:baz\",\n *           transform: {\n *             baz: {\n *               toState: (id) => ({ id }),\n *               toPath: (state) => state.id,\n *             },\n *           },\n *         }),\n *       ],\n *     }),\n *   ],\n * });\n * ```\n */\nexport const route: RouteObject = {\n  create: (routeOrOpts, childrenOrOpts, children) =>\n    _createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children)),\n  intents: (base: string) => {\n    const basePath = normalize(base).join('/')\n\n    return route.create(`${basePath}/:intent`, [\n      route.create(\n        ':params',\n        {\n          transform: {\n            params: {\n              toState: decodeParams,\n              toPath: encodeParams,\n            },\n          },\n        },\n        [\n          route.create(':payload', {\n            transform: {\n              payload: {\n                toState: decodeJsonParams,\n                toPath: encodeJsonParams,\n              },\n            },\n          }),\n        ],\n      ),\n    ])\n  },\n  scope(\n    scopeName: string,\n    routeOrOpts: RouteNodeOptions | string,\n    childrenOrOpts?: RouteNodeOptions | RouteChildren | null,\n    children?: Router | RouteChildren,\n  ) {\n    const options = normalizeArgs(routeOrOpts, childrenOrOpts, children)\n\n    return _createNode({\n      ...options,\n      scope: scopeName,\n    })\n  },\n}\n\nfunction normalizeChildren(children: any): RouteChildren {\n  if (Array.isArray(children) || typeof children === 'function') {\n    return children\n  }\n  return children ? [children] : []\n}\n\nfunction isRoute(val?: RouteNodeOptions | Router | RouteChildren) {\n  return val && '_isRoute' in val\n}\n\nfunction normalizeArgs(...args: any[]): RouteNodeOptions\nfunction normalizeArgs(\n  path: string | RouteNodeOptions,\n  childrenOrOpts?: RouteNodeOptions | Router | RouteChildren,\n  children?: Router | RouteChildren,\n): RouteNodeOptions {\n  if (typeof path === 'object') {\n    return path\n  }\n\n  if (\n    Array.isArray(childrenOrOpts) ||\n    typeof childrenOrOpts === 'function' ||\n    isRoute(childrenOrOpts)\n  ) {\n    return {path, children: normalizeChildren(childrenOrOpts)}\n  }\n\n  if (children) {\n    return {path, ...childrenOrOpts, children: normalizeChildren(children)}\n  }\n\n  return {path, ...childrenOrOpts}\n}\n\nfunction normalize(...paths: string[]) {\n  return paths.reduce<string[]>((acc, path) => acc.concat(path.split('/')), []).filter(Boolean)\n}\n\nconst EMPTY_STATE = {}\n\nfunction isRoot(pathname: string): boolean {\n  // it is the root if every segment is an empty string\n  return pathname.split('/').every((segment) => !segment)\n}\n\n/**\n * @internal\n * @param options - Route node options\n */\nexport function _createNode(options: RouteNodeOptions): Router {\n  // eslint-disable-next-line camelcase\n  const {path, scope, transform, children, __unsafe_disableScopedSearchParams} = options\n\n  if (!path) {\n    throw new TypeError('Missing path')\n  }\n\n  const parsedRoute = _parseRoute(path)\n\n  return {\n    _isRoute: true, // todo: make a Router class instead\n    scope,\n    // eslint-disable-next-line camelcase\n    __unsafe_disableScopedSearchParams,\n    route: parsedRoute,\n    children: children || [],\n    transform,\n    encode(state) {\n      return _resolvePathFromState(this, state)\n    },\n    decode(_path) {\n      return _resolveStateFromPath(this, _path)\n    },\n    isRoot: isRoot,\n    isNotFound(pathname: string): boolean {\n      return this.decode(pathname) === null\n    },\n    getBasePath(): string {\n      return this.encode(EMPTY_STATE)\n    },\n    getRedirectBase(pathname: string): string | null {\n      if (isRoot(pathname)) {\n        const basePath = this.getBasePath()\n        // Check if basepath is something different than given\n        if (pathname !== basePath) {\n          return basePath\n        }\n      }\n      return null\n    },\n  }\n}\n","import {type ReactElement, type ReactNode, useCallback, useMemo} from 'react'\nimport {RouterContext} from 'sanity/_singletons'\n\nimport {\n  type IntentParameters,\n  type NavigateOptions,\n  type Router,\n  type RouterContextValue,\n  type RouterState,\n} from './types'\n\n/**\n * The props for the {@link RouterProvider} component.\n *\n * @public\n */\nexport interface RouterProviderProps {\n  /**\n   * A function that is called when the user navigates to a new path.\n   * Takes an object containing the path to navigate to and an optional `replace` flag.\n   */\n  onNavigate: (opts: {path: string; replace?: boolean}) => void\n  /**\n   * The router object that is used to handle navigation. See {@link Router}\n   */\n  router: Router\n  /**\n   * The current state of the router. See {@link RouterState}\n   */\n  state: RouterState\n  /**\n   * The child elements to render.\n   */\n  children: ReactNode\n}\n\n/**\n * @example\n * ```tsx\n * import {\n *   NavigateOptions,\n *   route,\n *   RouterProvider,\n *   RouterState\n * } from 'sanity'\n * import {useCallback, useMemo} from 'react'\n *\n * function Root() {\n *   const router = useMemo(() => route.create('/'), [])\n *\n *   const [state, setState] = useState<RouterState>({})\n *\n *   const handleNavigate = useCallback((\n *     path: string,\n *     options?: NavigateOptions\n *   ) => {\n *     console.log('navigate', path, options)\n *\n *     setState(router.decode(path))\n *   }, [router])\n *\n *   return (\n *     <RouterProvider\n *       onNavigate={handleNavigate}\n *       router={router}\n *       state={state}\n *     >\n *       <div>This is a routed application</div>\n *     </RouterProvider>\n *   )\n * }\n * ```\n *\n * @param props - The component props.\n *  {@link RouterProviderProps}\n *\n * @public\n */\nexport function RouterProvider(props: RouterProviderProps): ReactElement {\n  const {onNavigate, router: routerProp, state} = props\n\n  const resolveIntentLink = useCallback(\n    (intentName: string, parameters?: IntentParameters): string => {\n      const [params, payload] = Array.isArray(parameters) ? parameters : [parameters]\n      return routerProp.encode({intent: intentName, params, payload})\n    },\n    [routerProp],\n  )\n\n  const resolvePathFromState = useCallback(\n    (nextState: Record<string, unknown>): string => {\n      return routerProp.encode(nextState)\n    },\n    [routerProp],\n  )\n\n  const navigate = useCallback(\n    (nextState: Record<string, unknown>, options: NavigateOptions = {}) => {\n      onNavigate({path: resolvePathFromState(nextState), replace: options.replace})\n    },\n    [onNavigate, resolvePathFromState],\n  )\n\n  const navigateIntent = useCallback(\n    (intentName: string, params?: IntentParameters, options: NavigateOptions = {}) => {\n      onNavigate({path: resolveIntentLink(intentName, params), replace: options.replace})\n    },\n    [onNavigate, resolveIntentLink],\n  )\n\n  const router: RouterContextValue = useMemo(\n    () => ({\n      navigate,\n      navigateIntent,\n      navigateUrl: onNavigate,\n      resolveIntentLink,\n      resolvePathFromState,\n      state,\n    }),\n    [navigate, navigateIntent, onNavigate, resolveIntentLink, resolvePathFromState, state],\n  )\n\n  return <RouterContext.Provider value={router}>{props.children}</RouterContext.Provider>\n}\n","/* eslint-disable camelcase */\nimport {type ReactElement, type ReactNode, useCallback, useMemo, useRef} from 'react'\nimport {RouterContext} from 'sanity/_singletons'\n\nimport {type RouterContextValue, type RouterState} from './types'\nimport {useRouter} from './useRouter'\n\nfunction addScope(\n  routerState: Record<string, any>,\n  scope: string,\n  scopedState: Record<string, any>,\n) {\n  return (\n    scopedState && {\n      ...routerState,\n      [scope]: scopedState,\n    }\n  )\n}\n\n/**\n * Props for the {@link RouteScope} component.\n *\n * @public\n */\nexport interface RouteScopeProps {\n  /**\n   * The scope for the nested routes.\n   */\n  scope: string\n\n  /**\n   * Optionally disable scoping of search params\n   * Scoped search params will be represented as scope[param]=value in the url\n   * Disabling this will still scope search params based on any parent scope unless the parent scope also has disabled search params scoping\n   * Caution: enabling this can cause conflicts with multiple plugins defining search params with the same name\n   */\n  __unsafe_disableScopedSearchParams?: boolean\n  /**\n   * The content to display inside the route scope.\n   */\n  children: ReactNode\n}\n\n/**\n * A component that wraps a scoped router context, so that calls to\n * `useRouter()`, `useRouterState()`, and usage of `<StateLink />`\n * will be prefixed with the scope segment.\n *\n * @public\n *\n * @param props - Props to pass `RouteScope` component.\n *  See {@link RouteScopeProps}\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *  return (\n *    <RouteScope scope=\"foo\">\n *      <StateLink state={{bar: 'baz'}}>Link</StateLink>\n *    </RouteScope>\n *  )\n * }\n * ```\n */\nexport function RouteScope(props: RouteScopeProps): ReactElement {\n  const {children, scope, __unsafe_disableScopedSearchParams} = props\n  const parentRouter = useRouter()\n  const {resolvePathFromState: parent_resolvePathFromState, navigate: parent_navigate} =\n    parentRouter\n\n  const parentStateRef = useRef(parentRouter.state)\n\n  parentStateRef.current = parentRouter.state\n\n  const resolveNextParentState = useCallback(\n    (_nextState: RouterState) => {\n      const {_searchParams, ...nextState} = _nextState\n      const nextParentState = addScope(parentStateRef.current, scope, nextState)\n      if (__unsafe_disableScopedSearchParams) {\n        // Move search params to parent scope\n        nextParentState._searchParams = _searchParams\n      } else {\n        nextParentState[scope]._searchParams = _searchParams\n      }\n      return nextParentState\n    },\n    [scope, __unsafe_disableScopedSearchParams],\n  )\n\n  const resolvePathFromState = useCallback(\n    (nextState: RouterState) => parent_resolvePathFromState(resolveNextParentState(nextState)),\n    [parent_resolvePathFromState, resolveNextParentState],\n  )\n\n  const navigate = useCallback(\n    (nextState: RouterState) => parent_navigate(resolveNextParentState(nextState)),\n    [parent_navigate, resolveNextParentState],\n  )\n\n  const childRouter: RouterContextValue = useMemo(() => {\n    const parentState = parentRouter.state\n    const childState = {...(parentState[scope] || {})} as RouterState\n    if (__unsafe_disableScopedSearchParams) {\n      childState._searchParams = parentState._searchParams\n    }\n    return {\n      ...parentRouter,\n      navigate,\n      resolvePathFromState,\n      state: childState,\n    }\n  }, [scope, parentRouter, navigate, resolvePathFromState, __unsafe_disableScopedSearchParams])\n\n  return <RouterContext.Provider value={childRouter}>{children}</RouterContext.Provider>\n}\n","import {type MouseEventHandler, useMemo} from 'react'\n\nimport {useLink} from './useLink'\nimport {useRouter} from './useRouter'\n\nconst EMPTY_STATE = {}\n\n/**\n * @public\n */\nexport interface UseStateLinkOptions {\n  /**\n   * The click event handler for the link.\n   */\n  onClick?: MouseEventHandler<HTMLElement>\n  /**\n   * Whether to replace the current history entry instead of adding a new one.\n   */\n  replace?: boolean\n  /**\n   * The state object to update when the link is clicked.\n   */\n  state?: Record<string, unknown>\n  /**\n   * The target window or frame to open the linked document in.\n   */\n  target?: string\n  /**\n   * Whether to navigate to the index page of the linked document.\n   */\n  toIndex?: boolean\n}\n\n/**\n * @public\n *\n * @param options - Options to use for the link\n *  {@link UseStateLinkOptions}\n *\n * @returns - An object with `onClick` and `href` props to use for the link\n *\n * @example\n * ```tsx\n * const {onClick, href} = useStateLink({state: {foo: 'bar'}})\n * ```\n */\nexport function useStateLink(options: UseStateLinkOptions): {\n  onClick: MouseEventHandler<HTMLElement>\n  href: string\n} {\n  const {onClick: onClickProp, replace, state, target, toIndex = false} = options\n\n  if (state && toIndex) {\n    throw new Error('Passing both `state` and `toIndex={true}` as props to StateLink is invalid')\n  }\n\n  if (!state && !toIndex) {\n    // eslint-disable-next-line no-console\n    console.error(\n      new Error(\n        'No state passed to StateLink. If you want to link to an empty state, its better to use the the `toIndex` property',\n      ),\n    )\n  }\n\n  const {resolvePathFromState} = useRouter()\n\n  const href = useMemo(\n    () => resolvePathFromState(toIndex ? EMPTY_STATE : state || EMPTY_STATE),\n    [resolvePathFromState, state, toIndex],\n  )\n\n  const {onClick} = useLink({href, onClick: onClickProp, replace, target})\n\n  return {onClick, href}\n}\n","import {type ForwardedRef, forwardRef, type HTMLProps} from 'react'\n\nimport {useStateLink} from './useStateLink'\n\n/**\n * Props for the {@link StateLink} component.\n *\n * @public\n */\nexport interface StateLinkProps {\n  /**\n   * Whether to replace the current history entry instead of adding a new one.\n   */\n  replace?: boolean\n  /**\n   * The state to associate with the link.\n   */\n  state?: Record<string, unknown>\n  /**\n   * Whether to navigate to the index page of the app.\n   */\n  toIndex?: boolean\n}\n\n/**\n * A component that creates a link that updates the URL state.\n *\n * @remarks\n * This component uses the {@link useStateLink} hook\n * to create a link that updates the URL state.\n *\n * @param props - Props to pass to the `StateLink` component.\n *  See {@link StateLinkProps}.\n *\n * @public\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *  return <StateLink state={{foo: 'bar'}}>Link</StateLink>\n * }\n * ```\n */\nexport const StateLink = forwardRef(function StateLink(\n  props: StateLinkProps & Omit<HTMLProps<HTMLAnchorElement>, 'href'>,\n  ref: ForwardedRef<HTMLAnchorElement>,\n) {\n  const {onClick: onClickProp, replace, state, target, toIndex = false, ...restProps} = props\n  const {onClick, href} = useStateLink({\n    onClick: onClickProp,\n    replace,\n    state,\n    target,\n    toIndex,\n  })\n\n  return <a {...restProps} href={href} onClick={onClick} ref={ref} />\n})\n","import {identity} from 'lodash'\nimport {useMemo} from 'react'\n\nimport {type RouterState} from './types'\nimport {useRouter} from './useRouter'\n\n/**\n * @public\n *\n * @param selector - A selector function that receives the router state and returns a value. See {@link RouterState}\n *\n * @returns The value returned by the selector function or RouterState. See {@link RouterState}\n *\n * @example\n * ```tsx\n * const {activeTool} = useRouterState(state => state.tool)\n * ```\n */\nexport function useRouterState<R = RouterState>(selector: (routerState: RouterState) => R): R\n\n/**\n * @public\n *\n * @returns The router state. See {@link RouterState}\n *\n * @example\n * ```tsx\n * const routerState = useRouterState()\n * ```\n */\nexport function useRouterState(): RouterState\n\n/**\n * @public\n */\nexport function useRouterState(\n  selector: (routerState: RouterState) => unknown = identity,\n): unknown {\n  const {state} = useRouter()\n  return useMemo(() => selector(state), [selector, state])\n}\n","import {type ComponentType, type FunctionComponent, type ReactElement} from 'react'\n\nimport {type RouterContextValue} from './types'\nimport {useRouter} from './useRouter'\n\n/**\n * A higher-order component that injects the `router` object from the `useRouter` hook\n * into the props of the wrapped component.\n *\n * @internal\n * @deprecated - Use the `useRouter` hook instead.\n *\n * @param Component - The component to wrap.\n *\n * @returns The wrapped component.\n *\n * @example\n * ```tsx\n * function MyComponent(props) {\n *  return <div>{props.router.state.myParam}</div>\n * }\n *\n * export default withRouter(MyComponent)\n * ```\n */\nexport function withRouter<Props extends {router: RouterContextValue}>(\n  Component: ComponentType<Props>,\n): FunctionComponent<Omit<Props, 'router'>> {\n  function WithRouter(props: Omit<Props, 'router'>) {\n    const router = useRouter()\n\n    return <Component {...(props as Props)} router={router} />\n  }\n\n  WithRouter.displayName = `withRouter(${Component.displayName || Component.name})`\n\n  return WithRouter\n}\n\n/**\n * @internal\n * @deprecated - Use the `useRouter` hook instead.\n */\nexport interface WithRouterProps {\n  /**\n   * The `router` object from the `useRouter` hook.\n   *  {@link RouterContextValue}\n   */\n  router: RouterContextValue\n  /**\n   * A function that renders the wrapped component with the `router` object as a parameter.\n   */\n  children: (router: RouterContextValue) => ReactElement\n}\n\n/**\n * A higher-order component that injects the router object into its child component.\n *\n * @internal\n * @deprecated - Use the `useRouter` hook instead.\n *\n * @returns The rendered component.\n *\n * @example\n * ```tsx\n * function MyComponent(props: {router: Router}) {\n *   const {location} = props.router\n *   const {pathname} = location\n *   return <p>The current path is: {pathname}</p>\n * }\n *\n * function App() {\n *   return (\n *     <Router>\n *       <WithRouter>\n *         {router => <MyComponent router={router} />}\n *       </WithRouter>\n *     </Router>\n *   )\n * }\n * ```\n */\nexport const WithRouter = withRouter((props: WithRouterProps) => props.children(props.router))\n"],"names":["useContext","RouterContext","useCallback","useMemo","forwardRef","route","isPlainObject","intersection","difference","pick","Debug","encodeParams","EMPTY_STATE","useRef","identity","WithRouter","jsx"],"mappings":"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"}