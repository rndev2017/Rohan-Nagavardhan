"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var jsxRuntime = require("react/jsx-runtime"), PathUtils = require("@sanity/util/paths"), React = require("react"), deepEquals$1 = require("react-fast-compare"), _singletons = require("sanity/_singletons"), debounce = require("lodash/debounce.js"), createPubSub = require("nano-pubsub"), ui = require("@sanity/ui"), resizeObserver$1 = require("@juggle/resize-observer"), TooltipDelayGroupProvider = require("./_chunks-cjs/TooltipDelayGroupProvider.js"), reactI18next = require("react-i18next"), theme = require("@sanity/ui/theme"), styledComponents = require("styled-components"), sortBy = require("lodash/sortBy.js"), types = require("@sanity/types"), reactVirtual = require("@tanstack/react-virtual"), throttle = require("lodash/throttle.js"), icons = require("@sanity/icons"), client = require("@sanity/client"), isEqual$2 = require("lodash/isEqual.js"), memoize$1 = require("lodash/memoize.js"), rxjs = require("rxjs"), operators = require("rxjs/operators"), shallowEquals = require("shallow-equals"), FocusLock = require("react-focus-lock"), useDevicePixelRatio = require("use-device-pixel-ratio"), uniqueId = require("lodash/uniqueId.js"), cloneDeep = require("lodash/cloneDeep.js"), get = require("lodash/get.js"), isPlainObject = require("lodash/isPlainObject.js"), legacyDateFormat = require("@sanity/util/legacyDateFormat"), client$1 = require("@sanity/util/client"), concurrencyLimiter = require("@sanity/util/concurrency-limiter"), flatten$1 = require("lodash/flatten.js"), uniqBy = require("lodash/uniqBy.js"), i18next = require("i18next"), observableCallback = require("observable-callback"), color = require("@sanity/color"), assetUtils = require("@sanity/asset-utils"), imageUrlBuilder = require("@sanity/image-url"), isHotkeyEsm = require("is-hotkey-esm"), classNames = require("classnames"), reactRx = require("react-rx"), reactIs = require("react-is"), groupBy = require("lodash/groupBy.js"), orderBy = require("lodash/orderBy.js"), _internal = require("@sanity/schema/_internal"), compact = require("lodash/compact.js"), flow = require("lodash/flow.js"), toLower = require("lodash/toLower.js"), trim = require("lodash/trim.js"), union = require("lodash/union.js"), uniq = require("lodash/uniq.js"), words = require("lodash/words.js"), uuid = require("@sanity/uuid"), DataLoader = require("dataloader"), content = require("@sanity/util/content"), intersection = require("lodash/intersection.js"), isEmpty$1 = require("lodash/isEmpty.js"), startCase = require("lodash/startCase.js"), capitalize = require("lodash/capitalize.js"), core = require("@dnd-kit/core"), modifiers = require("@dnd-kit/modifiers"), sortable = require("@dnd-kit/sortable"), utilities = require("@dnd-kit/utilities"), scrollIntoView$1 = require("scroll-into-view-if-needed"), getRandomValues = require("get-random-values-esm"), dateFns = require("date-fns"), range = require("lodash/range.js"), react$1 = require("@portabletext/react"), portableTextEditor = require("@sanity/portable-text-editor"), schema$1 = require("@sanity/schema"), telemetry = require("@sanity/telemetry"), omit = require("lodash/omit.js"), blockTools = require("@sanity/block-tools"), framerMotion = require("framer-motion"), partition = require("lodash/partition.js"), mutator = require("@sanity/mutator"), pick = require("lodash/pick.js"), sanity = require("sanity"), diffMatchPatch$1 = require("@sanity/diff-match-patch"), difference = require("lodash/difference.js"), index_js = require("use-sync-external-store/shim/index.js"), nanoid = require("nanoid"), sample = require("lodash/sample.js"), router = require("sanity/router"), color2k = require("color2k"), debug$7 = require("debug"), server = require("react-dom/server"), keyBy = require("lodash/keyBy.js"), isFinite = require("lodash/isFinite.js"), Refractor = require("react-refractor"), bash = require("refractor/lang/bash.js"), javascript = require("refractor/lang/javascript.js"), json = require("refractor/lang/json.js"), jsx2 = require("refractor/lang/jsx.js"), typescript = require("refractor/lang/typescript.js"), history$1 = require("history"), withSelector_js = require("use-sync-external-store/with-selector.js"), escapeRegExp$1 = require("lodash/escapeRegExp.js"), bifurClient = require("@sanity/bifur-client"), logos = require("@sanity/logos"), generateHelpUrl_esm = require("./_chunks-cjs/generate-help-url.esm.js"), useHotModuleReload = require("use-hot-module-reload"), react = require("@sanity/telemetry/react"), arrify = require("arrify"), isString$1 = require("lodash/isString.js"), template = require("lodash/template.js"), cloneObject = require("date-fns/_lib/cloneObject/index.js"), dateFnsFormat = require("date-fns/format/index.js"), toInteger = require("date-fns/_lib/toInteger/index.js"), getTimezoneOffsetInMilliseconds = require("date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js"), assignWith = require("lodash/assignWith.js"), upperFirst = require("lodash/upperFirst.js"), groqJs = require("groq-js"), deburr = require("lodash/deburr.js"), mendoza = require("mendoza"), castArray = require("lodash/castArray.js"), findIndex$1 = require("lodash/findIndex.js"), exif = require("exif-component"), isObject = require("lodash/isObject.js"), clone = require("lodash/clone.js"), identity = require("lodash/identity.js"), values = require("lodash/values.js"), jsonReduce = require("json-reduce"), rxjsExhaustmapWithTrailing = require("rxjs-exhaustmap-with-trailing"), diff = require("@sanity/diff"), raf = require("raf"), speakingurl = require("speakingurl"), find = require("lodash/find.js"), xor = require("lodash/xor.js"), sanityDiffPatch = require("sanity-diff-patch"), client$2 = require("react-dom/client"), polished = require("polished");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e == "object" && "default" in e) return e;
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, Object.freeze(n);
}
var PathUtils__namespace = /* @__PURE__ */ _interopNamespaceCompat(PathUtils), React__default = /* @__PURE__ */ _interopDefaultCompat(React), deepEquals__default = /* @__PURE__ */ _interopDefaultCompat(deepEquals$1), debounce__default = /* @__PURE__ */ _interopDefaultCompat(debounce), createPubSub__default = /* @__PURE__ */ _interopDefaultCompat(createPubSub), sortBy__default = /* @__PURE__ */ _interopDefaultCompat(sortBy), throttle__default = /* @__PURE__ */ _interopDefaultCompat(throttle), isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual$2), memoize__default = /* @__PURE__ */ _interopDefaultCompat(memoize$1), shallowEquals__default = /* @__PURE__ */ _interopDefaultCompat(shallowEquals), FocusLock__default = /* @__PURE__ */ _interopDefaultCompat(FocusLock), uniqueId__default = /* @__PURE__ */ _interopDefaultCompat(uniqueId), cloneDeep__default = /* @__PURE__ */ _interopDefaultCompat(cloneDeep), get__default = /* @__PURE__ */ _interopDefaultCompat(get), isPlainObject__default = /* @__PURE__ */ _interopDefaultCompat(isPlainObject), legacyDateFormat__namespace = /* @__PURE__ */ _interopNamespaceCompat(legacyDateFormat), flatten__default = /* @__PURE__ */ _interopDefaultCompat(flatten$1), uniqBy__default = /* @__PURE__ */ _interopDefaultCompat(uniqBy), imageUrlBuilder__default = /* @__PURE__ */ _interopDefaultCompat(imageUrlBuilder), classNames__default = /* @__PURE__ */ _interopDefaultCompat(classNames), groupBy__default = /* @__PURE__ */ _interopDefaultCompat(groupBy), orderBy__default = /* @__PURE__ */ _interopDefaultCompat(orderBy), compact__default = /* @__PURE__ */ _interopDefaultCompat(compact), flow__default = /* @__PURE__ */ _interopDefaultCompat(flow), toLower__default = /* @__PURE__ */ _interopDefaultCompat(toLower), trim__default = /* @__PURE__ */ _interopDefaultCompat(trim), union__default = /* @__PURE__ */ _interopDefaultCompat(union), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq), words__default = /* @__PURE__ */ _interopDefaultCompat(words), DataLoader__default = /* @__PURE__ */ _interopDefaultCompat(DataLoader), intersection__default = /* @__PURE__ */ _interopDefaultCompat(intersection), isEmpty__default = /* @__PURE__ */ _interopDefaultCompat(isEmpty$1), startCase__default = /* @__PURE__ */ _interopDefaultCompat(startCase), capitalize__default = /* @__PURE__ */ _interopDefaultCompat(capitalize), scrollIntoView__default = /* @__PURE__ */ _interopDefaultCompat(scrollIntoView$1), getRandomValues__default = /* @__PURE__ */ _interopDefaultCompat(getRandomValues), range__default = /* @__PURE__ */ _interopDefaultCompat(range), omit__default = /* @__PURE__ */ _interopDefaultCompat(omit), partition__default = /* @__PURE__ */ _interopDefaultCompat(partition), pick__default = /* @__PURE__ */ _interopDefaultCompat(pick), difference__default = /* @__PURE__ */ _interopDefaultCompat(difference), sample__default = /* @__PURE__ */ _interopDefaultCompat(sample), debug__default = /* @__PURE__ */ _interopDefaultCompat(debug$7), keyBy__default = /* @__PURE__ */ _interopDefaultCompat(keyBy), isFinite__default = /* @__PURE__ */ _interopDefaultCompat(isFinite), Refractor__default = /* @__PURE__ */ _interopDefaultCompat(Refractor), bash__default = /* @__PURE__ */ _interopDefaultCompat(bash), javascript__default = /* @__PURE__ */ _interopDefaultCompat(javascript), json__default = /* @__PURE__ */ _interopDefaultCompat(json), jsx2__default = /* @__PURE__ */ _interopDefaultCompat(jsx2), typescript__default = /* @__PURE__ */ _interopDefaultCompat(typescript), escapeRegExp__default = /* @__PURE__ */ _interopDefaultCompat(escapeRegExp$1), arrify__default = /* @__PURE__ */ _interopDefaultCompat(arrify), isString__default = /* @__PURE__ */ _interopDefaultCompat(isString$1), template__default = /* @__PURE__ */ _interopDefaultCompat(template), cloneObject__default = /* @__PURE__ */ _interopDefaultCompat(cloneObject), dateFnsFormat__default = /* @__PURE__ */ _interopDefaultCompat(dateFnsFormat), toInteger__default = /* @__PURE__ */ _interopDefaultCompat(toInteger), getTimezoneOffsetInMilliseconds__default = /* @__PURE__ */ _interopDefaultCompat(getTimezoneOffsetInMilliseconds), assignWith__default = /* @__PURE__ */ _interopDefaultCompat(assignWith), upperFirst__default = /* @__PURE__ */ _interopDefaultCompat(upperFirst), deburr__default = /* @__PURE__ */ _interopDefaultCompat(deburr), castArray__default = /* @__PURE__ */ _interopDefaultCompat(castArray), findIndex__default = /* @__PURE__ */ _interopDefaultCompat(findIndex$1), exif__default = /* @__PURE__ */ _interopDefaultCompat(exif), isObject__default = /* @__PURE__ */ _interopDefaultCompat(isObject), clone__default = /* @__PURE__ */ _interopDefaultCompat(clone), identity__default = /* @__PURE__ */ _interopDefaultCompat(identity), values__default = /* @__PURE__ */ _interopDefaultCompat(values), raf__default = /* @__PURE__ */ _interopDefaultCompat(raf), speakingurl__default = /* @__PURE__ */ _interopDefaultCompat(speakingurl), find__default = /* @__PURE__ */ _interopDefaultCompat(find), xor__default = /* @__PURE__ */ _interopDefaultCompat(xor);
function noop$6() {
}
function NoopTracker({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children });
}
function createNoopTrackerScope() {
  return {
    useReportedValues: noop$6,
    Tracker: NoopTracker,
    useReporter: noop$6
  };
}
function createStore() {
  const reportedValues = /* @__PURE__ */ new Map(), { publish: publish2, subscribe } = createPubSub__default.default(), debouncedPublish = debounce__default.default(publish2, 10, { trailing: !0 }), read2 = () => Array.from(reportedValues.entries());
  function add(id2, value) {
    reportedValues.has(id2), reportedValues.set(id2, value), debouncedPublish(read2());
  }
  function update(id2, value) {
    reportedValues.has(id2), reportedValues.set(id2, value), debouncedPublish(read2());
  }
  function remove2(id2) {
    reportedValues.has(id2), reportedValues.delete(id2), debouncedPublish(read2());
  }
  return {
    add,
    remove: remove2,
    update,
    read: read2,
    subscribe
  };
}
function isFunc(value) {
  return typeof value == "function";
}
function read(value) {
  return isFunc(value) ? value() : value;
}
const noop$5 = () => {
};
function createUseReporter(Context) {
  return function(id2, value, isEqual2 = Object.is) {
    const { add, update, remove: remove2 } = React.useContext(Context), previous = React.useRef();
    React.useLayoutEffect(() => {
      if (id2 === null)
        return noop$5;
      const current = read(value);
      return add(id2, current), previous.current = current, () => {
        remove2(id2);
      };
    }, [add, id2, remove2, value]), React.useLayoutEffect(() => {
      const current = read(value);
      typeof previous.current < "u" && !isEqual2(previous.current, current) && id2 !== null && update(id2, current), previous.current = current;
    });
  };
}
let didWarn = !1;
const useReporterGuard = (id2) => {
  didWarn || console.warn(
    new Error(
      `No context provided for reporter. Make sure that the component calling "useReporter(${id2}, ...)", is wrapped in a <Tracker> element`
    )
  ), didWarn = !0;
};
function useReportedValueGuard() {
  return didWarn || console.warn(
    new Error(
      'No context provided for reporter. Make sure that the component calling "useReportedValues()", is wrapped inside a <Tracker> element'
    )
  ), didWarn = !0, [];
}
const useSubscribeGuard = () => (didWarn || console.warn(
  new Error(
    'No context provided for reporter. Make sure that the component calling "useReportedValues()", is wrapped inside a <Tracker> element'
  )
), didWarn = !0, () => {
}), DEFAULT_CONTEXT = {
  add: useReporterGuard,
  update: useReporterGuard,
  remove: useReporterGuard,
  subscribe: useSubscribeGuard,
  read: useReportedValueGuard
};
let id$1 = 0;
const getNextId = () => ++id$1;
function createTrackerScope() {
  const Context = React.createContext(DEFAULT_CONTEXT);
  function useReportedValues2() {
    const context = React.useContext(Context), [values2, setValues] = React.useState(context.read());
    return React.useLayoutEffect(() => (setValues(context.read()), context.subscribe(setValues)), [context]), values2;
  }
  function Tracker2(props2) {
    const store = React.useMemo(() => createStore(), []);
    return /* @__PURE__ */ jsxRuntime.jsx(Context.Provider, { value: store, children: props2.children });
  }
  const useReporter2 = createUseReporter(Context);
  return {
    Tracker: Tracker2,
    useReportedValues: useReportedValues2,
    useReporter: useReporter2,
    useAutoIdReporter: (value, isEqual2 = Object.is) => useReporter2(`element-${React.useRef(getNextId()).current}`, value, isEqual2)
  };
}
const CORNER_RADIUS = 4, INTERACTIVE_STROKE_WIDTH = 16, CONNECTOR_MARGIN = 8, ARROW_MARGIN_X = 8, ARROW_MARGIN_Y = 2, ARROW_SIZE = 4, ARROW_THRESHOLD = 12, STROKE_WIDTH$2 = 1, DEBUG$1 = !1, DEBUG_LAYER_BOUNDS = !1, trackerScope = createTrackerScope(), Tracker$1 = trackerScope.Tracker, useReportedValues$1 = trackerScope.useReportedValues, useReporter$1 = trackerScope.useReporter, ChangeFieldWrapper = (props2) => {
  const ref = React.useRef(null), { onSetFocus } = React.useContext(_singletons.ConnectorContext), [isHover, setHover] = React.useState(!1), onMouseEnter = React.useCallback(() => {
    setHover(!0);
  }, []), onMouseLeave = React.useCallback(() => {
    setHover(!1);
  }, []);
  useReporter$1(
    `change-${PathUtils__namespace.toString(props2.path)}`,
    () => ({
      element: ref.current,
      path: props2.path,
      isChanged: !0,
      hasFocus: !1,
      hasHover: isHover,
      hasRevertHover: props2.hasHover
    }),
    // note: deepCompare should be ok here since we're not comparing deep values
    deepEquals__default.default
  );
  const handleClick = React.useCallback(
    (event) => {
      setFocusWithStopPropagation(event, onSetFocus, props2.path);
    },
    [onSetFocus, props2.path]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { ref, onClick: handleClick, onMouseLeave, onMouseEnter, children: props2.children });
};
function setFocusWithStopPropagation(event, onSetFocus, path) {
  event.stopPropagation(), onSetFocus(path);
}
function useUnique(value) {
  const valueRef = React.useRef(value);
  return isEqual__default.default(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
function createHookFromObservableFactory(observableFactory, initialValue) {
  const initialLoadingTuple = [initialValue, !0], initialResult = { type: "tuple", tuple: initialLoadingTuple };
  return function(_arg) {
    const memoArg = useUnique(_arg), result = reactRx.useMemoObservable(
      () => rxjs.of(memoArg).pipe(
        operators.switchMap(
          (arg) => rxjs.concat(
            rxjs.of({ type: "loading" }),
            observableFactory(arg).pipe(operators.map((value) => ({ type: "value", value })))
          )
        ),
        operators.scan(([prevValue], next) => next.type === "loading" ? [prevValue, !0] : [next.value, !1], initialLoadingTuple),
        operators.distinctUntilChanged(([prevValue, prevIsLoading], [nextValue, nextIsLoading]) => !(prevValue !== nextValue || prevIsLoading !== nextIsLoading)),
        operators.map((tuple) => ({ type: "tuple", tuple })),
        operators.catchError((error) => rxjs.of({ type: "error", error }))
      ),
      [memoArg],
      initialResult
    );
    if (result.type === "error") throw result.error;
    return result.tuple;
  };
}
function isNonNullable$3(value) {
  return value != null;
}
const DRAFTS_FOLDER = "drafts", DRAFTS_PREFIX = `${DRAFTS_FOLDER}.`;
function documentIdEquals(documentId, equalsDocumentId) {
  return getPublishedId(documentId) === getPublishedId(equalsDocumentId);
}
function isDraft(document2) {
  return isDraftId(document2._id);
}
function isDraftId(id2) {
  return id2.startsWith(DRAFTS_PREFIX);
}
function getIdPair(id2) {
  return {
    draftId: getDraftId(id2),
    publishedId: getPublishedId(id2)
  };
}
function isPublishedId(id2) {
  return !isDraftId(id2);
}
function getDraftId(id2) {
  return isDraftId(id2) ? id2 : DRAFTS_PREFIX + id2;
}
function getPublishedId(id2) {
  return isDraftId(id2) ? id2.slice(DRAFTS_PREFIX.length) : id2;
}
function createDraftFrom(document2) {
  return {
    ...document2,
    _id: getDraftId(document2._id)
  };
}
function newDraftFrom(document2) {
  return {
    ...document2,
    _id: DRAFTS_PREFIX
  };
}
function createPublishedFrom(document2) {
  return {
    ...document2,
    _id: getPublishedId(document2._id)
  };
}
function collate(documents) {
  const byId = documents.reduce((res, doc) => {
    const publishedId = getPublishedId(doc._id);
    let entry = res.get(publishedId);
    return entry || (entry = { id: publishedId, type: doc._type, published: void 0, draft: void 0 }, res.set(publishedId, entry)), entry[publishedId === doc._id ? "published" : "draft"] = doc, res;
  }, /* @__PURE__ */ new Map());
  return Array.from(byId.values());
}
function removeDupes(documents) {
  return collate(documents).map((entry) => entry.draft || entry.published).filter(isNonNullable$3);
}
const EMPTY_OBJECT = Object.freeze({}), EMPTY_ARRAY$t = Object.freeze([]);
function getGlobalScope() {
  if (typeof globalThis < "u") return globalThis;
  if (typeof window < "u") return window;
  if (typeof self < "u") return self;
  if (typeof global < "u") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope();
function isArray(value) {
  return Array.isArray(value);
}
function isRecord$4(value) {
  return !!value && typeof value == "object" && !Array.isArray(value);
}
function isString(value) {
  return typeof value == "string";
}
function isTruthy(value) {
  return !!value;
}
const ResizeObserver = typeof document == "object" && typeof window == "object" && window.ResizeObserver ? window.ResizeObserver : resizeObserver$1.ResizeObserver, createSharedResizeObserver = () => {
  const event = createPubSub__default.default(), resizeObserver2 = new ResizeObserver(
    (entries) => event.publish(entries)
  );
  return {
    observe: (element, observer, options) => {
      const unsubscribe = event.subscribe((entries) => {
        const entry = entries.find((e) => e.target === element);
        entry && observer(entry);
      });
      return resizeObserver2.observe(element, options), () => {
        unsubscribe(), resizeObserver2.unobserve(element);
      };
    },
    unobserve: (element) => resizeObserver2.unobserve(element)
  };
}, resizeObserver = createSharedResizeObserver(), BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function _isSanityDocumentTypeDefinition(def) {
  return def.type === "document" && BUNDLED_DOC_TYPES.includes(def.name);
}
function _isCustomDocumentTypeDefinition(def) {
  return def.type === "document" && !_isSanityDocumentTypeDefinition(def);
}
const GROQ_KEYWORDS = ["match", "in", "asc", "desc", "true", "false", "null"], VALID_FIELD = /^[a-zA-Z_][a-zA-Z0-9_]*$/, fieldNeedsEscape = (fieldName) => !VALID_FIELD.test(fieldName) || GROQ_KEYWORDS.includes(fieldName), escapeField = (fieldName) => `["${fieldName}"]`, escapeFirst = (fieldName) => `@${escapeField(fieldName)}`, isEmptyArray = (value) => Array.isArray(value) && value.length === 0, joinPath = (pathArray) => {
  let path = "";
  for (let i = 0; i < pathArray.length; i++) {
    const pathSegment = pathArray[i];
    if (isEmptyArray(pathSegment)) {
      path += "[]";
      continue;
    }
    if (typeof pathSegment == "number") {
      path += `[${pathSegment}]`;
      continue;
    }
    const isFirst = i === 0;
    fieldNeedsEscape(pathSegment) ? path = isFirst ? escapeFirst(pathSegment) : `${path}${escapeField(pathSegment)}` : path = isFirst ? pathSegment : `${path}.${pathSegment}`;
  }
  return path;
}, supportsTouch = isTouchDevice$1();
function isTouchDevice$1() {
  return typeof window > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
const FONT_SANS_SERIF = "-apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, \\'Helvetica Neue\\', Helvetica, Arial, system-ui, sans-serif", FONT_MONOSPACE = "-apple-system-ui-monospace, \\'SF Mono\\', Menlo, Monaco, Consolas, monospace", uncaughtErrorHandler = () => (
  // prettier-ignore
  [
    "window.onerror = function(m,u,l,c,e) {",
    "var p=window.location.port;",
    "var h=window.location.protocol+'//'+window.location.hostname+(p?':'+p:'');",
    "var r=document.getElementById('sanity');",
    "while(r.firstChild){r.removeChild(r.firstChild);}",
    "var s=document.createElement('style');",
    "s.appendChild(document.createTextNode('",
    "html,body,#sanityBody,#sanity,#sanityError{height:100%;}",
    "body{-webkit-font-smoothing:antialiased;margin:0;}",
    `#sanityError{position:fixed;top:0;left:0;width:100%;height:100%;overflow:auto;background-color:#fff;color:#121923;font-family:${FONT_SANS_SERIF};font-size:16px;line-height:21px;min-height:100%;}`,
    "#sanityError>div{background-color:#fff;max-width:960px;margin:0 auto;padding:47px 32px 52px;}",
    "@media(min-width:512px){",
    "#sanityError>div{",
    "padding:47px 84px;",
    "}",
    "}",
    "#sanityError button{-webkit-font-smoothing:inherit;font:inherit;font-weight:500;background-color:#2276FC;color:#fff;padding:7px 12px;border-radius:3px;border:0;}",
    "#sanityError button:hover{background-color:#1E63D0;}",
    "#sanityError button:active{background-color:#1B50A5;}",
    "'));",
    "document.head.appendChild(s);",
    "var f=document.createElement('div');",
    "f.id='sanityError';",
    "f.innerHTML='",
    "<div>",
    '<h1 style="font-size:21px;line-height:27px;margin: 0 0 10px;">Unhandled error</h1>',
    '<p style="color:#66758D;margin:10px 0 14px;">Encountered an unhandled error in this Studio.</p>',
    '<button class="sanity-error-handler__reload-btn" type="button">Reload page</button>',
    '<pre style="background-color:#FDEBEA;color:#C3362C;font-size:13px;line-height:17px;padding:8px 12px;border-radius:3px;margin:32px 0 0;overflow:auto;">',
    `<code style="font-family:${FONT_MONOSPACE};">`,
    "'+e.stack.replaceAll(h,'')+'",
    "</code>",
    "</pre>",
    "</div>",
    "';",
    "var b=f.querySelector('.sanity-error-handler__reload-btn');",
    "if(b){",
    "b.onclick=function() {",
    "window.location.reload();",
    "}",
    "};",
    "r.appendChild(f);",
    "};"
  ].join("")
), segmenter = typeof Intl == "object" && "Segmenter" in Intl ? new Intl.Segmenter() : void 0;
function sliceString(str, start, end) {
  if (end < start)
    throw new Error(
      "End must be greater than start, use `String.prototype.slice()` for negative values"
    );
  if (!segmenter)
    return str.slice(start, end);
  let i = 0, sliced = "";
  for (const value of segmenter.segment(str)) {
    if (i === end)
      return sliced;
    sliced += value.segment, i++;
  }
  return sliced;
}
function truncateString(str, maxLength) {
  const truncated = sliceString(str, 0, maxLength);
  return truncated === str ? truncated : `${truncated}\u2026`;
}
const LOADING_STATE$1 = {
  isLoading: !0,
  value: void 0,
  error: null
};
function useLoadable(value$, initialValue) {
  return reactRx.useMemoObservable(() => value$.pipe(asLoadable()), [value$], typeof initialValue > "u" ? LOADING_STATE$1 : { isLoading: !1, value: initialValue, error: null });
}
function asLoadable() {
  return (value$) => value$.pipe(
    operators.map((value) => ({ isLoading: !1, value, error: null })),
    operators.catchError(
      (error) => rxjs.of({ isLoading: !1, value: void 0, error })
    )
  );
}
function userHasRole(user, roleId) {
  return user !== null && user.roles.some((role) => role.name === roleId);
}
function useThrottledCallback(callback, wait, options) {
  return React.useMemo(
    () => throttle__default.default(callback, wait, options),
    [callback, options, wait]
  );
}
var _a$1;
const DEBUG_MODE$2 = typeof process > "u" ? !1 : (_a$1 = process == null ? void 0 : process.env) == null ? void 0 : _a$1.SANITY_STUDIO_DEBUG_I18N, DEBUG_I18N = !!DEBUG_MODE$2, debugWrappers = {
  reverse: (str) => `\u202E${str}`,
  triangles: (str) => `\u25E4 ${str} \u25E2`
};
function maybeWrapT(t2) {
  const wrapper = DEBUG_MODE$2 === "reverse" || DEBUG_MODE$2 === "triangles" ? debugWrappers[DEBUG_MODE$2] : null;
  return wrapper ? (...args) => wrapper(t2(...args)) : t2;
}
const translationOptionOverrides = {
  // We're manually forcing a re-render with the locale key in the LocaleProvider,
  // so we don't need to bind to the i18n instance for language change events.
  bindI18n: !1
};
function useTranslation(ns, options) {
  const { t: t2 } = reactI18next.useTranslation(
    // @ts-expect-error type check is failing after using `module: preserve` in tsconfig, which uses `moduleResolution: bundler` internally
    ns,
    options ? { keyPrefix: options.keyPrefix, lng: options.lng, ...translationOptionOverrides } : translationOptionOverrides
  );
  return { t: maybeWrapT(t2) };
}
const animationSpeed = 250, ChangeBarWrapper$1 = styledComponents.styled.div(
  ({ $changed, $disabled, $hasFocus, $isReviewChangeOpen }) => $disabled ? styledComponents.css`
        ${ChangeBarMarker}:after {
          display: none;
        }
      ` : styledComponents.css`
      --change-bar-offset: 4px;

      display: flex;
      position: relative;

      ${ChangeBarMarker}:after {
        opacity: 0.5;
      }

      @media (hover: hover) {
        &:hover {
          z-index: 10;
          ${ChangeBarMarker}:after {
            opacity: 1;
          }
        }
      }

      /* hide when field is not changed */
      ${$hasFocus && styledComponents.css`
        ${ChangeBarMarker}:after {
          opacity: 1;
        }
      `}

      /* hide when field is not changed */
      ${!$changed && styledComponents.css`
        ${ChangeBarMarker}:after {
          opacity: 0;
          pointer-events: none;
        }
      `}

      /* hide hover effect when review changes is open */
      ${$isReviewChangeOpen && styledComponents.css`
        ${ChangeBarButton} {
          opacity: 0;
        }
      `}
    `
), FieldWrapper$1 = styledComponents.styled.div`
  flex-grow: 1;
  min-width: 0;
`, ChangeBar = styledComponents.styled.div`
  position: relative;
  opacity: 1;
  transition: opacity 100ms;
  z-index: ${({ $zIndex }) => $zIndex};
`, ChangeBarMarker = styledComponents.styled.div((props2) => {
  const { media } = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    position: absolute;
    top: -1px;
    left: var(--change-bar-offset);
    width: 1px;
    bottom: -1px;
    background-color: var(--card-bg-color);

    @media (min-width: ${media[0]}px) {
      display: unset;
    }

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 1px;
      left: 0;
      width: 1px;
      bottom: 1px;
      background-color: var(--card-badge-caution-dot-color);
      border-radius: 0.5px;
    }
  `;
}), ChangeBarButton = styledComponents.styled.button((props2) => {
  const { $withHoverEffect } = props2;
  return styledComponents.css`
    appearance: none;
    border: 0;
    outline: 0;
    display: block;
    padding: 0;
    background: transparent;
    opacity: 0;
    position: absolute;
    height: 100%;
    cursor: pointer;
    pointer-events: all;
    left: calc(-0.25rem + var(--change-bar-offset));
    width: calc(1rem - 1px);
    transition: opacity ${animationSpeed}ms;

    &:focus {
      border: 0;
      outline: 0;
    }

    &:focus {
      border: 0;
      outline: 0;
    }

    ${$withHoverEffect && styledComponents.css`
      @media (hover: hover) {
        &:hover {
          opacity: 0.2;
        }
      }
    `}
  `;
});
function ElementWithChangeBar(props2) {
  const { children, disabled, hasFocus, isChanged, withHoverEffect = !0 } = props2, { onOpenReviewChanges, isReviewChangesOpen } = React.useContext(_singletons.ConnectorContext), { zIndex } = ui.useLayer(), { t: t2 } = useTranslation(), changeBar = React.useMemo(
    () => disabled || !isChanged ? null : /* @__PURE__ */ jsxRuntime.jsxs(ChangeBar, { "data-testid": "change-bar", $zIndex: zIndex, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ChangeBarMarker, { "data-testid": "change-bar__marker" }),
      /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: t2("changes.change-bar.aria-label"), portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
        ChangeBarButton,
        {
          "aria-label": t2("changes.change-bar.aria-label"),
          "data-testid": "change-bar__button",
          onClick: isReviewChangesOpen ? void 0 : onOpenReviewChanges,
          tabIndex: -1,
          type: "button",
          $withHoverEffect: withHoverEffect
        }
      ) })
    ] }),
    [disabled, isChanged, isReviewChangesOpen, onOpenReviewChanges, t2, withHoverEffect, zIndex]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ChangeBarWrapper$1,
    {
      "data-testid": "change-bar-wrapper",
      $changed: isChanged,
      $disabled: disabled,
      $hasFocus: hasFocus,
      $isReviewChangeOpen: isReviewChangesOpen,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(FieldWrapper$1, { "data-testid": "change-bar__field-wrapper", children }),
        changeBar
      ]
    }
  );
}
const ChangeBarWrapper = React.memo(function(props2) {
  const {
    children,
    disabled,
    hasFocus,
    isChanged,
    onMouseEnter: onMouseEnterProp,
    onMouseLeave: onMouseLeaveProp,
    path = EMPTY_ARRAY$t,
    withHoverEffect,
    ...restProps
  } = props2, layer = ui.useLayer(), [hasHover, setHover] = React.useState(!1), onMouseEnter = React.useCallback(
    (event) => {
      onMouseEnterProp == null || onMouseEnterProp(event), setHover(!0);
    },
    [onMouseEnterProp]
  ), onMouseLeave = React.useCallback(
    (event) => {
      onMouseLeaveProp == null || onMouseLeaveProp(event), setHover(!1);
    },
    [onMouseLeaveProp]
  ), ref = React.useRef(null);
  return useReporter$1(
    disabled ? null : `field-${PathUtils__namespace.toString(path)}`,
    () => ({
      element: ref.current,
      path,
      isChanged,
      hasFocus,
      hasHover,
      zIndex: layer.zIndex
    }),
    deepEquals__default.default
    // note: deepCompare should be ok here since we're not comparing deep values
  ), /* @__PURE__ */ jsxRuntime.jsx("div", { ...restProps, ref, onMouseEnter, onMouseLeave, children: /* @__PURE__ */ jsxRuntime.jsx(
    ElementWithChangeBar,
    {
      hasFocus,
      isChanged,
      disabled,
      withHoverEffect,
      children
    }
  ) });
});
function ChangeIndicator(props2) {
  const { children, hasFocus, isChanged, path, withHoverEffect, ...restProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ChangeBarWrapper,
    {
      ...restProps,
      path,
      hasFocus,
      isChanged,
      withHoverEffect,
      children
    }
  );
}
function useOnScroll(callback) {
  const parentContext = React.useContext(_singletons.ScrollContext);
  React.useEffect(() => parentContext == null ? void 0 : parentContext.subscribe(callback), [callback, parentContext]);
}
const noop$4 = () => {
}, ScrollContainer = React.forwardRef(function(props2, ref) {
  const { as = "div", onScroll, ...rest } = props2, forwardedRef = ui.useForwardedRef(ref), parentContext = React.useContext(_singletons.ScrollContext), childContext = React.useMemo(() => createPubSub__default.default(), []);
  return React.useEffect(() => onScroll ? childContext.subscribe(onScroll) : noop$4, [childContext, onScroll]), React.useEffect(() => parentContext ? childContext.subscribe(parentContext.publish) : noop$4, [parentContext, childContext]), React.useEffect(() => {
    const handleScroll = (event) => {
      childContext.publish(event);
    }, el = forwardedRef.current;
    if (el)
      return el.addEventListener("scroll", handleScroll, {
        passive: !0,
        capture: !0
      }), () => {
        el.removeEventListener("scroll", handleScroll);
      };
  }, [childContext, forwardedRef]), /* @__PURE__ */ jsxRuntime.jsx(_singletons.ScrollContext.Provider, { value: childContext, children: React.createElement(as, { ref: forwardedRef, "data-testid": "scroll-container", ...rest }) });
});
function ScrollMonitor({ onScroll, children }) {
  return useOnScroll(onScroll), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children });
}
function findMostSpecificTarget(targetType, id2, values2) {
  const pathString = id2.slice(id2.indexOf("-") + 1) || "[]", path = PathUtils__namespace.fromString(pathString), exactId = `${targetType}-${PathUtils__namespace.toString(path)}`;
  if (values2.has(exactId))
    return values2.get(exactId);
  let mostSpecific;
  for (const [targetId, target] of values2) {
    if (!("path" in target) || !targetId.startsWith(targetType))
      continue;
    const numEqual = PathUtils__namespace.numEqualSegments(path, target.path), lastPathSegment = target.path[target.path.length - 1], pathOnlyDiffersByKey = numEqual === target.path.length - 1 && types.isKeyedObject(lastPathSegment);
    if (numEqual !== 0 && !(numEqual !== target.path.length && !pathOnlyDiffersByKey) && (mostSpecific = target, numEqual === path.length))
      break;
  }
  return mostSpecific;
}
function hasOverflowScroll(el) {
  const overflow = getComputedStyle(el).overflow;
  return overflow.includes("auto") || overflow.includes("scroll");
}
function isScrollable(el) {
  return (el.scrollHeight !== el.offsetHeight || el.scrollWidth !== el.offsetWidth) && hasOverflowScroll(el);
}
const getOffsetsTo$1 = (source, target) => {
  const bounds = {
    top: 0,
    left: 0,
    height: target.offsetHeight,
    width: target.offsetWidth
  }, rect = {
    top: 0,
    left: 0,
    height: source.offsetHeight,
    width: source.offsetWidth
  };
  let foundScrollContainer = !1, el = source;
  for (; el && el !== target && target.contains(el); )
    foundScrollContainer && (bounds.top += el.offsetTop, bounds.left += el.offsetLeft), hasOverflowScroll(el) && (bounds.top = el.offsetTop, bounds.height = el.offsetHeight, bounds.left = el.offsetLeft, bounds.width = el.offsetWidth, foundScrollContainer = !0), rect.top += el.offsetTop - el.scrollTop, rect.left += el.offsetLeft - el.scrollLeft, el = el.offsetParent;
  return { rect, bounds };
};
function isChangeBar(v) {
  return v[0] !== "changePanel";
}
const SCROLL_INTO_VIEW_TOP_PADDING = -15;
function scrollIntoView(field) {
  let parentElementWithScroll = field.element;
  for (; !isScrollable(parentElementWithScroll); )
    if (parentElementWithScroll = parentElementWithScroll.parentElement, !parentElementWithScroll)
      return;
  parentElementWithScroll.scroll({
    top: parentElementWithScroll.scrollTop + field.rect.top - field.bounds.top + SCROLL_INTO_VIEW_TOP_PADDING,
    left: 0,
    behavior: "smooth"
  });
}
function ClampedRect(props2) {
  const { bounds, ...rest } = props2, x = Math.max(bounds.left, props2.left), y = Math.max(props2.top, bounds.top), height = Math.max(0, props2.height - (y - props2.top)), width = Math.max(0, props2.width - (x - props2.left));
  return /* @__PURE__ */ jsxRuntime.jsx("rect", { ...rest, x, y, height, width });
}
styledComponents.styled.rect`
  stroke: #ccc;
  fill: none;
  pointer-events: none;
  stroke-linecap: round;
`;
const ConnectorPath = styledComponents.styled.path`
  fill: none;
  pointer-events: none;
  stroke-linejoin: round;
  stroke: var(--card-badge-caution-dot-color);
`, InteractivePath = styledComponents.styled.path`
  fill: none;
  pointer-events: stroke;
  stroke: transparent;
  cursor: pointer;
  stroke-linecap: round;
  stroke-linejoin: round;
  opacity: 0;

  &:hover {
    opacity: 0.2;
  }
`, RightBarWrapper = styledComponents.styled(ClampedRect)`
  stroke: none;
  pointer-events: none;
  fill: var(--card-badge-caution-dot-color);
`;
function arrowPath(x, y, dir) {
  return [
    `M ${x - ARROW_SIZE} ${y - ARROW_SIZE * dir} `,
    `L ${x} ${y}`,
    `L ${x + ARROW_SIZE} ${y - ARROW_SIZE * dir}`
  ].join("");
}
function moveTo(x, y) {
  return `M${x} ${y}`;
}
function lineTo(x, y) {
  return `L${x} ${y}`;
}
function join(strings, delim = "") {
  return strings.join(delim);
}
function quadCurve(x1, y1, x, y) {
  return `Q${x1} ${y1} ${x} ${y}`;
}
function generateConnectorPath(line) {
  const { from, to } = line, { left: fromX, top: fromY } = from, { left: toX, top: toY } = to, cmds = [], r1 = Math.min(CORNER_RADIUS, Math.abs(fromY - toY) / 2);
  return from.isAbove ? cmds.push(
    moveTo(fromX + ARROW_MARGIN_X, fromY - ARROW_THRESHOLD + ARROW_MARGIN_Y),
    lineTo(fromX + ARROW_MARGIN_X, fromY - CORNER_RADIUS),
    quadCurve(fromX + ARROW_MARGIN_X, fromY, fromX + ARROW_MARGIN_X + CORNER_RADIUS, fromY)
  ) : from.isBelow ? cmds.push(
    moveTo(fromX + ARROW_MARGIN_X, fromY + ARROW_THRESHOLD - ARROW_MARGIN_Y),
    lineTo(fromX + ARROW_MARGIN_X, fromY + CORNER_RADIUS),
    quadCurve(fromX + ARROW_MARGIN_X, fromY, fromX + ARROW_MARGIN_X + CORNER_RADIUS, fromY)
  ) : cmds.push(moveTo(fromX, fromY)), to.isAbove ? fromY < to.bounds.top ? cmds.push(
    lineTo(to.bounds.left - 8 - r1, fromY),
    quadCurve(to.bounds.left - 8, fromY, to.bounds.left - 8, fromY + r1),
    lineTo(to.bounds.left - 8, toY - r1),
    quadCurve(to.bounds.left - 8, toY, to.bounds.left - 8 + r1, toY),
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, toY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      toY,
      to.bounds.left + ARROW_MARGIN_X,
      toY - CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY - ARROW_THRESHOLD + ARROW_MARGIN_Y)
  ) : cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY - CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY - ARROW_THRESHOLD + ARROW_MARGIN_Y)
  ) : to.isBelow ? fromY > to.bounds.top + to.bounds.height ? cmds.push(
    lineTo(to.bounds.left - ARROW_MARGIN_X - r1, fromY),
    quadCurve(
      to.bounds.left - ARROW_MARGIN_X,
      fromY,
      to.bounds.left - ARROW_MARGIN_X,
      fromY - r1
    ),
    lineTo(to.bounds.left - ARROW_MARGIN_X, toY + r1),
    quadCurve(to.bounds.left - ARROW_MARGIN_X, toY, to.bounds.left - ARROW_MARGIN_X + r1, toY),
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, toY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      toY,
      to.bounds.left + ARROW_MARGIN_X,
      toY + CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY + ARROW_THRESHOLD - ARROW_MARGIN_Y)
  ) : cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - CORNER_RADIUS, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY + CORNER_RADIUS
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY + ARROW_THRESHOLD - ARROW_MARGIN_Y)
  ) : fromY < toY ? cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - r1, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY + r1
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY - r1),
    quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X + r1, toY),
    lineTo(toX, toY)
  ) : cmds.push(
    lineTo(to.bounds.left + ARROW_MARGIN_X - r1, fromY),
    quadCurve(
      to.bounds.left + ARROW_MARGIN_X,
      fromY,
      to.bounds.left + ARROW_MARGIN_X,
      fromY - r1
    ),
    lineTo(to.bounds.left + ARROW_MARGIN_X, toY + r1),
    quadCurve(to.bounds.left + ARROW_MARGIN_X, toY, to.bounds.left + ARROW_MARGIN_X + r1, toY),
    lineTo(toX, toY)
  ), join(cmds);
}
function getConnectorLinePoint(rect, bounds) {
  const centerY = rect.top + rect.height / 2, isAbove = rect.top + rect.height < bounds.top + ARROW_MARGIN_Y, isBelow = rect.top > bounds.top + bounds.height - ARROW_MARGIN_Y;
  return {
    bounds,
    left: rect.left,
    top: centerY,
    centerY,
    startY: rect.top + CONNECTOR_MARGIN,
    endY: rect.top + rect.height - CONNECTOR_MARGIN,
    isAbove,
    isBelow,
    outOfBounds: isAbove || isBelow
  };
}
function mapConnectorToLine(connector) {
  const fromBounds = {
    top: connector.from.bounds.top + ARROW_THRESHOLD,
    bottom: connector.from.bounds.top + connector.from.bounds.height - ARROW_THRESHOLD,
    left: connector.from.bounds.left,
    right: connector.from.bounds.left + connector.from.bounds.width,
    width: connector.from.bounds.width,
    height: connector.from.bounds.height - ARROW_THRESHOLD * 2
  }, from = getConnectorLinePoint(connector.from.rect, fromBounds);
  from.left = connector.from.rect.left + connector.from.rect.width + 1;
  const toBounds = {
    top: connector.to.bounds.top + ARROW_THRESHOLD,
    bottom: connector.to.bounds.top + connector.to.bounds.height - ARROW_THRESHOLD,
    left: connector.to.bounds.left,
    right: connector.to.bounds.left + connector.to.bounds.width,
    width: connector.to.bounds.width,
    height: connector.to.bounds.height - ARROW_THRESHOLD * 2
  }, to = getConnectorLinePoint(connector.to.rect, toBounds), maxStartY = Math.max(to.startY, from.startY);
  return from.top = Math.min(maxStartY, from.endY), from.top < toBounds.top ? from.top = Math.min(toBounds.top, from.endY) : from.top > toBounds.bottom && (from.top = Math.max(toBounds.bottom, from.startY)), to.top = Math.min(maxStartY, to.endY), to.top < fromBounds.top ? to.top = Math.min(fromBounds.top, to.endY) : to.top > fromBounds.bottom && (to.top = Math.max(fromBounds.bottom, to.startY)), from.top = Math.min(Math.max(from.top, fromBounds.top), fromBounds.bottom), to.top = Math.min(Math.max(to.top, toBounds.top), toBounds.bottom), { from, to };
}
const Connector = React.memo(function({ from, to }) {
  const line = mapConnectorToLine({ from, to });
  if (line.from.outOfBounds && line.to.outOfBounds)
    return null;
  const linePathDescription = generateConnectorPath(line);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(InteractivePath, { d: linePathDescription, strokeWidth: INTERACTIVE_STROKE_WIDTH }),
    /* @__PURE__ */ jsxRuntime.jsx(ConnectorPath, { d: linePathDescription, strokeWidth: STROKE_WIDTH$2 }),
    /* @__PURE__ */ jsxRuntime.jsx(
      RightBarWrapper,
      {
        top: to.rect.top,
        left: to.rect.left - 0.5,
        height: to.rect.height,
        width: STROKE_WIDTH$2,
        bounds: to.bounds
      }
    ),
    line.from.isAbove && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.from.left + ARROW_MARGIN_X,
          line.from.bounds.top - ARROW_THRESHOLD + ARROW_MARGIN_Y,
          -1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    line.from.isBelow && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.from.left + ARROW_MARGIN_X,
          line.from.bounds.top + line.from.bounds.height + ARROW_THRESHOLD - ARROW_MARGIN_Y,
          1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    line.to.isAbove && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.to.bounds.left + ARROW_MARGIN_X,
          line.to.bounds.top - ARROW_THRESHOLD + ARROW_MARGIN_Y,
          -1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    line.to.isBelow && /* @__PURE__ */ jsxRuntime.jsx(
      ConnectorPath,
      {
        d: arrowPath(
          line.to.bounds.left + ARROW_MARGIN_X,
          line.to.bounds.top + line.to.bounds.height + ARROW_THRESHOLD - ARROW_MARGIN_Y,
          1
        ),
        strokeWidth: STROKE_WIDTH$2
      }
    ),
    DEBUG$1
  ] });
}), SvgWrapper = styledComponents.styled.svg`
  pointer-events: none;
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
`;
function useResizeObserver(element, onResize) {
  React.useEffect(() => resizeObserver.observe(element, onResize), [element, onResize]);
}
function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [], changeBarsWithFocus = [];
  for (const value of allReportedValues) {
    if (!isChangeBar(value) || !value[1].isChanged)
      continue;
    const [id2, reportedChangeBar] = value;
    if (id2 === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }
    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }
  const isHoverConnector = changeBarsWithHover.length > 0;
  return { connectors: (isHoverConnector ? changeBarsWithHover : changeBarsWithFocus).map(([id2]) => {
    const field = findMostSpecificTarget("field", id2, byId), change = findMostSpecificTarget("change", id2, byId);
    return !field || !change ? null : { field: { id: id2, ...field }, change: { id: id2, ...change } };
  }).filter(isNonNullable$3).map(({ field, change }) => ({
    hasHover: field.hasHover || change.hasHover,
    hasFocus: field.hasFocus,
    hasRevertHover: change.hasRevertHover,
    field: { ...field, ...getOffsetsTo$1(field.element, rootElement) },
    change: { ...change, ...getOffsetsTo$1(change.element, rootElement) }
  })), isHoverConnector };
}
function ConnectorsOverlay(props2) {
  const { rootElement, onSetFocus } = props2, [hovered, setHovered] = React.useState(null), allReportedValues = useReportedValues$1(), byId = React.useMemo(
    () => new Map(allReportedValues),
    [allReportedValues]
  ), [{ connectors }, setState] = React.useState(
    () => getState(allReportedValues, hovered, byId, rootElement)
  ), visibleConnectors = React.useMemo(
    () => sortBy__default.default(connectors, (c) => 0 - c.field.path.length).slice(0, 1),
    [connectors]
  ), handleScrollOrResize = React.useCallback(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  return useResizeObserver(rootElement, handleScrollOrResize), /* @__PURE__ */ jsxRuntime.jsx(ScrollMonitor, { onScroll: handleScrollOrResize, children: /* @__PURE__ */ jsxRuntime.jsx(SvgWrapper, { style: { zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex }, children: visibleConnectors.map(({ field, change }) => change ? /* @__PURE__ */ jsxRuntime.jsx(
    ConnectorGroup,
    {
      field,
      change,
      onSetFocus,
      setHovered
    },
    field.id
  ) : null) }) });
}
function ConnectorGroup(props2) {
  const { change, field, onSetFocus, setHovered } = props2, onConnectorClick = React.useCallback(() => {
    scrollIntoView(field), scrollIntoView(change), onSetFocus(field.path);
  }, [field, change, onSetFocus]), handleMouseEnter = React.useCallback(() => setHovered(field.id), [field, setHovered]), handleMouseLeave = React.useCallback(() => setHovered(null), [setHovered]), from = React.useMemo(
    () => ({
      rect: {
        ...field.rect,
        left: field.rect.left + 3
      },
      bounds: field.bounds
    }),
    [field.bounds, field.rect]
  ), to = React.useMemo(
    () => ({
      rect: {
        ...change.rect,
        left: change.rect.left + 1
      },
      bounds: change.bounds
    }),
    [change.bounds, change.rect]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("g", { onClick: onConnectorClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: /* @__PURE__ */ jsxRuntime.jsx(Connector, { from, to }) }),
    DEBUG_LAYER_BOUNDS
  ] });
}
function EnabledChangeConnectorRoot({
  children,
  className,
  isReviewChangesOpen,
  onOpenReviewChanges,
  onSetFocus,
  ...restProps
}) {
  const [rootElement, setRootElement] = React.useState(), contextValue = React.useMemo(
    () => ({
      isReviewChangesOpen,
      onOpenReviewChanges,
      onSetFocus
    }),
    [isReviewChangesOpen, onOpenReviewChanges, onSetFocus]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ConnectorContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntime.jsx(Tracker$1, { children: /* @__PURE__ */ jsxRuntime.jsxs(ScrollContainer, { ...restProps, ref: setRootElement, className, children: [
    children,
    rootElement && /* @__PURE__ */ jsxRuntime.jsx(ConnectorsOverlay, { rootElement, onSetFocus })
  ] }) }) });
}
function DisabledChangeConnectorRoot({
  children,
  className
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(ScrollContainer, { className, children });
}
const ChangeConnectorRoot = EnabledChangeConnectorRoot, separator = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}) }), renderItem = (item, index) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", size: 1, weight: "medium", children: item }) }, `${item}-${index}`);
function CommentBreadcrumbs(props2) {
  const { titlePath, maxLength } = props2, items = React.useMemo(() => {
    const len = titlePath.length, beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
    return maxLength && len > maxLength ? [
      ...titlePath.slice(0, beforeLength - 1),
      titlePath.slice(beforeLength - 1, len - afterLength),
      ...titlePath.slice(len - afterLength)
    ] : titlePath;
  }, [maxLength, titlePath]), nodes = React.useMemo(() => items.map((item, index) => {
    const key = `${item}-${index}`, showSeparator = index < items.length - 1;
    return Array.isArray(item) ? /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Tooltip,
        {
          content: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 2, children: item.map(renderItem) }),
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: renderItem("...", index) })
        }
      ),
      showSeparator && separator
    ] }, key) : /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
      renderItem(item, index),
      showSeparator && separator
    ] }, key);
  }), [items]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", as: "ol", gap: 2, children: nodes });
}
function BetaBadge(props2) {
  const { fontSize = 1, children = "Beta", ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { ...rest, fontSize, radius: 2, tone: "primary", children });
}
function focusRingBorderStyle$3(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
const AlignedBottomGrid$1 = styledComponents.styled(ui.Grid)`
  align-items: flex-end;
`;
function focusRingStyle$2(opts) {
  const { base, border, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border && focusRingBorderStyle$3(border),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
const LIST_ITEM_DATA_ATTR_ACTIVE = "data-active", LIST_ITEM_INTERACTIVE_SELECTOR = "a,button", FocusOverlayDiv = styledComponents.styled.div(({ theme: theme2, offset }) => styledComponents.css`
    bottom: ${-offset}px;
    border-radius: ${ui.rem(theme2.sanity.radius[1])};
    left: ${-offset}px;
    pointer-events: none;
    position: absolute;
    right: ${-offset}px;
    top: ${-offset}px;
    z-index: 2;

    ${VirtualListBox}:focus-visible & {
      box-shadow: ${focusRingStyle$2({
  base: theme2.sanity.color.base,
  focusRing: theme2.sanity.focusRing
})};
    }
  `), PointerOverlayDiv = styledComponents.styled.div`
  bottom: 0;
  display: none;
  left: 0;
  position: absolute;
  right: 0;
  top: 0;
  z-index: 1;

  @media (hover: hover) {
    &[data-enabled='true'] {
      display: block;
    }
  }
`, VirtualListBox = styledComponents.styled(ui.Box)`
  height: 100%;
  outline: none;
  overflow-x: hidden;
  overflow-y: auto;
  overscroll-behavior: contain;
  width: 100%;
`, VirtualListChildBox = styledComponents.styled(ui.Box).attrs(({ $height }) => ({
  style: { height: `${$height}px` }
}))`
  position: relative;
  width: 100%;
`, CommandList = React.forwardRef(function({
  activeItemDataAttr = LIST_ITEM_DATA_ATTR_ACTIVE,
  ariaLabel,
  ariaMultiselectable = !1,
  autoFocus,
  canReceiveFocus,
  fixedHeight,
  focusRingOffset = 0,
  getItemDisabled,
  getItemKey: getItemKey2,
  getItemSelected,
  initialIndex,
  initialScrollAlign = "start",
  inputElement,
  itemHeight,
  items,
  onEndReached,
  onEndReachedIndexOffset = 0,
  onlyShowSelectionWhenActive,
  overscan,
  renderItem: renderItem2,
  wrapAround = !0,
  ...responsivePaddingProps
}, ref) {
  const isMountedRef = React.useRef(!1), commandListId = React.useRef(React.useId()), activeIndexRef = React.useRef(initialIndex != null ? initialIndex : 0), [childContainerElement, setChildContainerElement] = React.useState(null), [hovered, setHovered] = React.useState(!1), [pointerOverlayElement, setPointerOverlayElement] = React.useState(null), [virtualListElement, setVirtualListElement] = React.useState(null), handleChange = React.useCallback(
    (v) => {
      if (!onEndReached) return;
      const [lastItem] = [...v.getVirtualItems()].reverse();
      lastItem && lastItem.index >= items.length - onEndReachedIndexOffset - 1 && isMountedRef.current && onEndReached();
    },
    [onEndReached, items.length, onEndReachedIndexOffset]
  ), virtualizer = reactVirtual.useVirtualizer({
    count: items.length,
    getItemKey: getItemKey2,
    getScrollElement: () => virtualListElement,
    estimateSize: () => itemHeight,
    onChange: handleChange,
    overscan
  }), itemIndices = React.useMemo(() => {
    let i = -1;
    return items.reduce((acc, _, index) => {
      var _a2, _b;
      const disabled = (_a2 = getItemDisabled == null ? void 0 : getItemDisabled(index)) != null ? _a2 : !1, selected = (_b = getItemSelected == null ? void 0 : getItemSelected(index)) != null ? _b : !1;
      return disabled || (i += 1), acc[index] = {
        activeIndex: disabled ? null : i,
        disabled,
        selected
      }, acc;
    }, []);
  }, [getItemDisabled, getItemSelected, items]), activeItemCount = React.useMemo(
    () => itemIndices.filter((v) => !v.disabled).length,
    [itemIndices]
  ), enableChildContainerPointerEvents = React.useCallback(
    (enabled) => pointerOverlayElement == null ? void 0 : pointerOverlayElement.setAttribute("data-enabled", (!enabled).toString()),
    [pointerOverlayElement]
  ), getChildDescendantId = React.useCallback(
    (index) => `${commandListId.current}-item-${index}`,
    []
  ), getCommandListChildrenId = React.useCallback(() => `${commandListId.current}-children`, []), showChildrenActiveState = React.useCallback(() => {
    const hasFocus = [inputElement, virtualListElement].some((el) => document.activeElement === el);
    if (onlyShowSelectionWhenActive && !hasFocus && !hovered)
      return;
    const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
    childElements == null || childElements.forEach((child) => {
      var _a2, _b, _c;
      const virtualIndex = Number((_a2 = child.dataset) == null ? void 0 : _a2.index), targetIndex = (_b = itemIndices[virtualIndex]) == null ? void 0 : _b.activeIndex;
      (_c = child.querySelector(LIST_ITEM_INTERACTIVE_SELECTOR)) == null || _c.toggleAttribute(activeItemDataAttr, targetIndex === activeIndexRef.current);
    });
  }, [
    activeItemDataAttr,
    childContainerElement == null ? void 0 : childContainerElement.children,
    hovered,
    inputElement,
    itemIndices,
    onlyShowSelectionWhenActive,
    virtualListElement
  ]), hideChildrenActiveState = React.useCallback(() => {
    const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
    childElements == null || childElements.forEach((child) => {
      var _a2;
      (_a2 = child.querySelector(LIST_ITEM_INTERACTIVE_SELECTOR)) == null || _a2.toggleAttribute(activeItemDataAttr, !1);
    });
  }, [activeItemDataAttr, childContainerElement == null ? void 0 : childContainerElement.children]), refreshChildrenActiveStateThrottled = React.useMemo(() => throttle__default.default(showChildrenActiveState, 200), [showChildrenActiveState]), handleUpdateActiveDescendant = React.useCallback(() => {
    const activeIndex = activeIndexRef == null ? void 0 : activeIndexRef.current;
    items.length > 0 ? (inputElement == null || inputElement.setAttribute("aria-activedescendant", getChildDescendantId(activeIndex)), virtualListElement == null || virtualListElement.setAttribute("aria-activedescendant", getChildDescendantId(activeIndex))) : (inputElement == null || inputElement.removeAttribute("aria-activedescendant"), virtualListElement == null || virtualListElement.removeAttribute("aria-activedescendant"));
  }, [getChildDescendantId, inputElement, items.length, virtualListElement]), handleGetTopIndex = React.useCallback(() => {
    var _a2, _b;
    const childContainerParentElement = childContainerElement == null ? void 0 : childContainerElement.parentElement;
    if (childContainerElement && childContainerParentElement) {
      const offset = childContainerParentElement.getBoundingClientRect().top - childContainerElement.getBoundingClientRect().top;
      return (_b = (_a2 = virtualizer.getVirtualItemForOffset(offset)) == null ? void 0 : _a2.index) != null ? _b : -1;
    }
    return -1;
  }, [childContainerElement, virtualizer]), setActiveIndex = React.useCallback(
    ({
      index,
      scrollAlign,
      scrollIntoView: scrollIntoView2 = !0
    }) => {
      if (activeIndexRef.current = index, handleUpdateActiveDescendant(), showChildrenActiveState(), scrollIntoView2) {
        const virtualListIndex = itemIndices.findIndex((i) => i.activeIndex === index);
        virtualListIndex > -1 && virtualizer.scrollToIndex(virtualListIndex, scrollAlign ? { align: scrollAlign } : {});
      }
    },
    [handleUpdateActiveDescendant, itemIndices, showChildrenActiveState, virtualizer]
  ), selectAdjacentItemIndex = React.useCallback(
    (direction) => {
      let nextIndex = -1;
      const lastIndex = activeItemCount - 1;
      if (direction === "next") {
        const wrapAroundIndex = wrapAround ? 0 : lastIndex;
        nextIndex = activeIndexRef.current < activeItemCount - 1 ? activeIndexRef.current + 1 : wrapAroundIndex;
      }
      if (direction === "previous") {
        const wrapAroundIndex = wrapAround ? lastIndex : 0;
        nextIndex = activeIndexRef.current > 0 ? activeIndexRef.current - 1 : wrapAroundIndex;
      }
      setActiveIndex({ index: nextIndex, scrollIntoView: !0 }), enableChildContainerPointerEvents(!1);
    },
    [activeItemCount, enableChildContainerPointerEvents, setActiveIndex, wrapAround]
  ), focusElement = React.useCallback(
    (type) => {
      switch (type) {
        case "input":
          inputElement == null || inputElement.focus();
          break;
        case "list":
          virtualListElement == null || virtualListElement.focus();
          break;
      }
    },
    [inputElement, virtualListElement]
  ), focusInputElement = React.useCallback(() => {
    inputElement == null || inputElement.focus();
  }, [inputElement]), focusListElement = React.useCallback(() => {
    virtualListElement == null || virtualListElement.focus();
  }, [virtualListElement]), handleChildMouseEnter = React.useCallback(
    (index) => () => {
      setActiveIndex({ index, scrollIntoView: !1 });
    },
    [setActiveIndex]
  ), handleFocus = React.useCallback(() => {
    showChildrenActiveState();
  }, [showChildrenActiveState]), handleKeyDown = React.useCallback(
    (type) => (event) => {
      const childElements = Array.from((childContainerElement == null ? void 0 : childContainerElement.children) || []);
      if (childElements.length && (event.key === "ArrowDown" && (event.preventDefault(), focusElement(type), selectAdjacentItemIndex("next")), event.key === "ArrowUp" && (event.preventDefault(), focusElement(type), selectAdjacentItemIndex("previous")), event.key === "Enter")) {
        event.preventDefault(), focusElement(type);
        const currentElement = childElements.find(
          (el) => Number(el.dataset.index) === itemIndices.findIndex((i) => i.activeIndex === activeIndexRef.current)
        );
        if (currentElement) {
          const clickableElement = currentElement == null ? void 0 : currentElement.querySelector(
            LIST_ITEM_INTERACTIVE_SELECTOR
          );
          clickableElement == null || clickableElement.click();
        }
      }
    },
    [childContainerElement == null ? void 0 : childContainerElement.children, focusElement, itemIndices, selectAdjacentItemIndex]
  ), handleKeyDownInput = React.useCallback(
    (event) => handleKeyDown("input")(event),
    [handleKeyDown]
  ), handleKeyDownList = React.useCallback(
    (event) => handleKeyDown("list")(event),
    [handleKeyDown]
  ), handleVirtualListMouseEnter = React.useCallback(() => {
    onlyShowSelectionWhenActive && (showChildrenActiveState(), setHovered(!0));
  }, [onlyShowSelectionWhenActive, showChildrenActiveState]), handleVirtualListMouseLeave = React.useCallback(() => {
    onlyShowSelectionWhenActive && (hideChildrenActiveState(), setHovered(!1));
  }, [hideChildrenActiveState, onlyShowSelectionWhenActive]);
  React.useImperativeHandle(
    ref,
    () => ({
      focusInputElement() {
        focusInputElement();
      },
      focusListElement() {
        focusListElement();
      },
      getTopIndex() {
        return handleGetTopIndex();
      },
      scrollToIndex(index) {
        setActiveIndex({ index }), enableChildContainerPointerEvents(!0);
      }
    }),
    [
      enableChildContainerPointerEvents,
      focusInputElement,
      focusListElement,
      handleGetTopIndex,
      setActiveIndex
    ]
  ), React.useEffect(() => {
    typeof initialIndex < "u" && !isMountedRef.current && setActiveIndex({
      index: initialIndex,
      scrollAlign: initialScrollAlign,
      scrollIntoView: !0
    }), isMountedRef.current = !0;
  }, [initialIndex, initialScrollAlign, onlyShowSelectionWhenActive, setActiveIndex]), React.useEffect(() => {
    function handleMouseEvent() {
      enableChildContainerPointerEvents(!0);
    }
    return virtualListElement == null || virtualListElement.addEventListener("mousemove", handleMouseEvent), virtualListElement == null || virtualListElement.addEventListener("wheel", handleMouseEvent, { passive: !0 }), () => {
      virtualListElement == null || virtualListElement.removeEventListener("mousemove", handleMouseEvent), virtualListElement == null || virtualListElement.removeEventListener("wheel", handleMouseEvent);
    };
  }, [enableChildContainerPointerEvents, virtualListElement]), React.useEffect(() => (inputElement == null || inputElement.addEventListener("focus", handleFocus), inputElement == null || inputElement.addEventListener("keydown", handleKeyDownInput), virtualListElement == null || virtualListElement.addEventListener("focus", handleFocus), virtualListElement == null || virtualListElement.addEventListener("keydown", handleKeyDownList), () => {
    inputElement == null || inputElement.removeEventListener("focus", handleFocus), inputElement == null || inputElement.removeEventListener("keydown", handleKeyDownInput), virtualListElement == null || virtualListElement.removeEventListener("focus", handleFocus), virtualListElement == null || virtualListElement.removeEventListener("keydown", handleKeyDownList);
  }), [
    canReceiveFocus,
    handleFocus,
    handleKeyDown,
    handleKeyDownInput,
    handleKeyDownList,
    hideChildrenActiveState,
    inputElement,
    showChildrenActiveState,
    virtualListElement
  ]), React.useEffect(() => {
    handleUpdateActiveDescendant();
  }, [handleUpdateActiveDescendant, items]), React.useEffect(() => {
    const mutationObserver = new MutationObserver(refreshChildrenActiveStateThrottled);
    return childContainerElement && mutationObserver.observe(childContainerElement, {
      childList: !0,
      subtree: !0
    }), () => {
      mutationObserver.disconnect();
    };
  }, [childContainerElement, refreshChildrenActiveStateThrottled]), React.useEffect(() => {
    inputElement == null || inputElement.setAttribute("aria-autocomplete", "list"), inputElement == null || inputElement.setAttribute("aria-expanded", "true"), inputElement == null || inputElement.setAttribute("aria-controls", getCommandListChildrenId()), inputElement == null || inputElement.setAttribute("role", "combobox");
  }, [getCommandListChildrenId, inputElement]), React.useEffect(() => {
    autoFocus && focusElement(autoFocus);
  }, [autoFocus, canReceiveFocus, focusListElement, focusInputElement, focusElement]);
  const rootTabIndex = canReceiveFocus ? 0 : -1;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    VirtualListBox,
    {
      id: getCommandListChildrenId(),
      onMouseEnter: handleVirtualListMouseEnter,
      onMouseLeave: handleVirtualListMouseLeave,
      ref: setVirtualListElement,
      sizing: "border",
      tabIndex: rootTabIndex,
      ...responsivePaddingProps,
      children: [
        canReceiveFocus && /* @__PURE__ */ jsxRuntime.jsx(FocusOverlayDiv, { offset: focusRingOffset }),
        /* @__PURE__ */ jsxRuntime.jsx(PointerOverlayDiv, { "aria-hidden": "true", "data-enabled": !0, ref: setPointerOverlayElement }),
        virtualizer && /* @__PURE__ */ jsxRuntime.jsx(
          VirtualListChildBox,
          {
            forwardedAs: "ul",
            $height: virtualizer.getTotalSize(),
            "aria-label": ariaLabel,
            "aria-multiselectable": ariaMultiselectable,
            flex: 1,
            ref: setChildContainerElement,
            role: "listbox",
            children: virtualizer.getVirtualItems().map((virtualRow) => {
              const virtualIndex = virtualRow.index, { activeIndex, disabled, selected } = itemIndices[virtualIndex], itemToRender = renderItem2(items[virtualIndex], {
                activeIndex,
                disabled,
                selected,
                virtualIndex
              }), clonedItem = React.cloneElement(itemToRender, {
                tabIndex: -1
              }), activeAriaAttributes = typeof activeIndex == "number" && !disabled ? {
                "aria-posinset": activeIndex + 1,
                ...ariaMultiselectable ? { "aria-selected": selected.toString() } : {},
                "aria-setsize": activeItemCount,
                id: getChildDescendantId(activeIndex),
                role: "option",
                onMouseEnter: handleChildMouseEnter(activeIndex)
              } : {};
              return /* @__PURE__ */ jsxRuntime.jsx(
                ui.Stack,
                {
                  as: "li",
                  "data-index": virtualIndex,
                  ref: fixedHeight ? void 0 : virtualizer.measureElement,
                  style: {
                    flex: 1,
                    ...fixedHeight ? { height: `${virtualRow.size}px` } : {},
                    left: 0,
                    position: "absolute",
                    top: 0,
                    transform: `translateY(${virtualRow.start}px)`,
                    width: "100%"
                  },
                  tabIndex: -1,
                  ...activeAriaAttributes,
                  children: clonedItem
                },
                virtualRow.key
              );
            })
          }
        )
      ]
    }
  );
}), ContextMenuButton = React.forwardRef(function(props2, ref) {
  const { mode = "bleed", tooltipProps, tone, ...rest } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      ...rest,
      icon: icons.EllipsisHorizontalIcon,
      mode,
      ref,
      tone,
      tooltipProps: {
        ...tooltipProps,
        content: (tooltipProps == null ? void 0 : tooltipProps.content) || t2("common.context-menu-button.tooltip")
      }
    }
  );
});
function Favicons({ basePath }) {
  const base = `${basePath.replace(/\/+$/, "")}/static`;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "icon", href: `${base}/favicon.ico`, sizes: "any" }),
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "icon", href: `${base}/favicon.svg`, type: "image/svg+xml" }),
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "apple-touch-icon", href: `${base}/apple-touch-icon.png` }),
    /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "manifest", href: `${base}/manifest.webmanifest` })
  ] });
}
const errorHandlerScript = `
;(function () {
  var _caughtErrors = []

  var errorChannel = (function () {
    var subscribers = []

    function publish(msg) {
      for (var i = 0; i < subscribers.length; i += 1) {
        subscribers[i](msg)
      }
    }

    function subscribe(subscriber) {
      subscribers.push(subscriber)

      return function () {
        var idx = subscribers.indexOf(subscriber)

        if (idx > -1) {
          subscribers.splice(idx, 1)
        }
      }
    }

    return {publish, subscribe, subscribers}
  })()

  // NOTE: Store the error channel instance in the global scope so that the Studio application can
  // access it and subscribe to errors.
  window.__sanityErrorChannel = {
    subscribe: errorChannel.subscribe,
  }

  function _nextTick(callback) {
    setTimeout(callback, 0)
  }

  function _handleError(error, params) {
    _nextTick(function () {
      // - If there are error channel subscribers, then we notify them (no console error).
      // - If there are no subscribers, then we log the error to the console and render the error overlay.
      if (errorChannel.subscribers.length) {
        errorChannel.publish({error, params})
      } else {
        console.error(error)

        _renderErrorOverlay(error, params)
      }
    })
  }

  var ERROR_BOX_STYLE = [
    'background: #fff',
    'border-radius: 6px',
    'box-sizing: border-box',
    'color: #121923',
    'flex: 1',
    "font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue','Liberation Sans',Helvetica,Arial,system-ui,sans-serif",
    'font-size: 16px',
    'line-height: 21px',
    'margin: 0 auto',
    'max-width: 960px',
    'overflow: auto',
    'padding: 20px',
    'width: 100%',
  ].join(';')

  var ERROR_CODE_STYLE = [
    'color: #972E2A',
    "font-family: -apple-system-ui-monospace, 'SF Mono', Menlo, Monaco, Consolas, monospace",
    'font-size: 13px',
    'line-height: 17px',
    'margin: 0',
  ].join(';')

  function _renderErrorOverlay(error, params) {
    var errorElement = document.querySelector('#__sanityError') || document.createElement('div')
    var colno = params.event.colno
    var lineno = params.event.lineno
    var filename = params.event.filename

    errorElement.id = '__sanityError'
    errorElement.innerHTML = [
      '<div style="' + ERROR_BOX_STYLE + '">',
      '<div style="font-weight: 700;">Uncaught error: ' + error.message + '</div>',
      '<div style="color: #515E72; font-size: 13px; line-height: 17px; margin: 10px 0;">' +
        filename +
        ':' +
        lineno +
        ':' +
        colno +
        '</div>',
      '<pre style="' + ERROR_CODE_STYLE + '">' + error.stack + '</pre>',
      '</div>',
    ].join('')

    errorElement.style.position = 'fixed'
    errorElement.style.zIndex = 1000000
    errorElement.style.top = 0
    errorElement.style.left = 0
    errorElement.style.right = 0
    errorElement.style.bottom = 0
    errorElement.style.padding = '20px'
    errorElement.style.background = 'rgba(16,17,18,0.66)'
    errorElement.style.display = 'flex'
    errorElement.style.alignItems = 'center'
    errorElement.style.justifyContent = 'center'

    document.body.appendChild(errorElement)
  }

  // NOTE:
  // Yes \u2013 we're attaching 2 error listeners below \u{1F440}
  // This is because React makes the same error throw twice (in development mode).
  // See: https://github.com/facebook/react/issues/10384

  // Error listener #1
  window.onerror = function (event, source, lineno, colno, error) {
    _nextTick(function () {
      if (_caughtErrors.indexOf(error) !== -1) return

      _caughtErrors.push(error)

      _handleError(error, {
        event,
        lineno,
        colno,
        source,
      })

      _nextTick(function () {
        var idx = _caughtErrors.indexOf(error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    // IMPORTANT: this callback must return \`true\` to prevent the error from being rendered in
    // the browser\u2019s console.
    return true
  }

  // Error listener #2
  window.addEventListener('error', function (event) {
    if (_caughtErrors.indexOf(event.error) !== -1) return true

    _caughtErrors.push(event.error)

    _handleError(event.error, {
      event,
      lineno: event.lineno,
      colno: event.colno,
    })

    _nextTick(function () {
      _nextTick(function () {
        var idx = _caughtErrors.indexOf(event.error)

        if (idx > -1) _caughtErrors.splice(idx, 1)
      })
    })

    return true
  })
})()
`;
function GlobalErrorHandler() {
  return /* @__PURE__ */ jsxRuntime.jsx("script", { dangerouslySetInnerHTML: { __html: errorHandlerScript } });
}
const NoJsStyles = `
.sanity-app-no-js__root {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  background: #fff;
}

.sanity-app-no-js__content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  font-family: helvetica, arial, sans-serif;
}
`;
function NoJavascript() {
  return /* @__PURE__ */ jsxRuntime.jsx("noscript", { children: /* @__PURE__ */ jsxRuntime.jsx("div", { className: "sanity-app-no-js__root", children: /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "sanity-app-no-js__content", children: [
    /* @__PURE__ */ jsxRuntime.jsx("style", { type: "text/css", children: NoJsStyles }),
    /* @__PURE__ */ jsxRuntime.jsx("h1", { children: "JavaScript disabled" }),
    /* @__PURE__ */ jsxRuntime.jsxs("p", { children: [
      "Please ",
      /* @__PURE__ */ jsxRuntime.jsx("a", { href: "https://www.enable-javascript.com/", children: "enable JavaScript" }),
      " in your browser and reload the page to proceed."
    ] })
  ] }) }) });
}
const globalStyles = `
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Italic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Medium.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-MediumItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Black.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BlackItalic.woff2") format("woff2");
  }
  html {
    background-color: #f1f3f6;
  }
  html,
  body,
  #sanity {
    height: 100%;
  }
  body {
    margin: 0;
    -webkit-font-smoothing: antialiased;
  }
`, EMPTY_ARRAY$s = [];
function DefaultDocument(props2) {
  const { entryPath, css = EMPTY_ARRAY$s, basePath = "/" } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs("html", { lang: "en", children: [
    /* @__PURE__ */ jsxRuntime.jsxs("head", { children: [
      /* @__PURE__ */ jsxRuntime.jsx("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsxRuntime.jsx(
        "meta",
        {
          name: "viewport",
          content: "width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx("meta", { name: "robots", content: "noindex" }),
      /* @__PURE__ */ jsxRuntime.jsx("meta", { name: "referrer", content: "same-origin" }),
      /* @__PURE__ */ jsxRuntime.jsx(Favicons, { basePath }),
      /* @__PURE__ */ jsxRuntime.jsx("title", { children: "Sanity Studio" }),
      /* @__PURE__ */ jsxRuntime.jsx(GlobalErrorHandler, {}),
      css.map((href) => /* @__PURE__ */ jsxRuntime.jsx("link", { rel: "stylesheet", href }, href)),
      /* @__PURE__ */ jsxRuntime.jsx("style", { dangerouslySetInnerHTML: { __html: globalStyles } }),
      !1
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs("body", { children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { id: "sanity" }),
      /* @__PURE__ */ jsxRuntime.jsx("script", { type: "module", src: entryPath }),
      /* @__PURE__ */ jsxRuntime.jsx(NoJavascript, {})
    ] })
  ] });
}
function getWorkspaceIdentifier({ name, title }, index) {
  return typeof name == "string" && name.trim().length > 0 ? name : getNamelessWorkspaceIdentifier(title, index);
}
function getNamelessWorkspaceIdentifier(title, index) {
  const withTitle = typeof title == "string" && title.trim().length > 0 ? ` (titled "${title}")` : "";
  return `at index ${index}${withTitle}`;
}
function useWorkspaces() {
  const workspaces = React.useContext(_singletons.WorkspacesContext);
  if (!workspaces) throw new Error("Could not find `workspaces` context");
  return workspaces;
}
var __defProp$h = Object.defineProperty, __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$h = (obj, key, value) => __defNormalProp$h(obj, typeof key != "symbol" ? key + "" : key, value);
class WorkspaceValidationError extends Error {
  constructor(message, options) {
    super(message), __publicField$h(this, "index"), __publicField$h(this, "identifier"), this.name = "WorkspaceValidationError", this.index = options == null ? void 0 : options.index, this.identifier = (options == null ? void 0 : options.workspace) && getWorkspaceIdentifier(options.workspace, options.index);
  }
}
function validateWorkspaces({ workspaces }) {
  if (workspaces.length === 0)
    throw new WorkspaceValidationError("At least one workspace is required.");
  validateNames(workspaces), validateBasePaths(workspaces);
}
function validateNames(workspaces) {
  const isSingleWorkspace = workspaces.length === 1, names = /* @__PURE__ */ new Map();
  workspaces.forEach((workspace, index) => {
    const { name: rawName, title } = workspace, thisIdentifier = getNamelessWorkspaceIdentifier(title, index);
    if (!rawName && !isSingleWorkspace)
      throw new WorkspaceValidationError(
        `All workspaces must have a \`name\`, unless only a single workspace is defined. Workspace ${thisIdentifier} did not define a \`name\`.`,
        { workspace, index }
      );
    const name = isSingleWorkspace && typeof rawName > "u" ? "default" : rawName;
    if (typeof name != "string")
      throw new WorkspaceValidationError(
        `Workspace at index ${index} defined an invalid \`name\` - must be a string.`,
        { workspace, index }
      );
    const normalized = name.toLowerCase(), existingWorkspace = names.get(normalized);
    if (existingWorkspace) {
      const prevIdentifier = getNamelessWorkspaceIdentifier(
        existingWorkspace.workspace.title,
        existingWorkspace.index
      );
      throw new WorkspaceValidationError(
        `\`name\`s must be unique. Workspace ${prevIdentifier} and workspace ${thisIdentifier} both have the \`name\` \`${name}\``,
        { workspace, index }
      );
    }
    if (names.set(normalized, { index, workspace }), !/^[a-z0-9][a-z0-9_-]*$/i.test(name))
      throw new WorkspaceValidationError(
        `All workspace \`name\`s must consist of only a-z, 0-9, underscore and dashes, and cannot begin with an underscore or dash. Workspace ${thisIdentifier} has the invalid name \`${name}\``,
        { workspace, index }
      );
  });
}
function validateBasePaths(workspaces) {
  workspaces.length > 1 && workspaces.every(hasBasePath), workspaces.every(validateBasePath);
  const [firstWorkspace, ...restOfWorkspaces] = workspaces, firstWorkspaceSegmentCount = (firstWorkspace.basePath || "/").slice(1).split("/").filter(Boolean).length;
  restOfWorkspaces.forEach((workspace, index) => {
    const workspaceSegmentCount = (workspace.basePath || "/").slice(1).split("/").length;
    if (firstWorkspaceSegmentCount !== workspaceSegmentCount)
      throw new WorkspaceValidationError(
        `All workspace \`basePath\`s must have the same amount of segments. Workspace \`${getWorkspaceIdentifier(
          firstWorkspace,
          index
        )}\` had ${firstWorkspaceSegmentCount} segment${firstWorkspaceSegmentCount === 1 ? "" : "s"} \`${firstWorkspace.basePath}\` but workspace \`${getWorkspaceIdentifier(
          workspace,
          index
        )}\` had ${workspaceSegmentCount} segment${workspaceSegmentCount === 1 ? "" : "s"} \`${workspace.basePath}\``,
        { workspace, index }
      );
  });
  const basePaths = /* @__PURE__ */ new Map();
  workspaces.forEach((workspace, index) => {
    const basePath = (workspace.basePath || "").toLowerCase(), existingWorkspace = basePaths.get(basePath);
    if (existingWorkspace)
      throw new WorkspaceValidationError(
        `\`basePath\`s must be unique. Workspaces \`${existingWorkspace}\` and \`${getWorkspaceIdentifier(
          workspace,
          index
        )}\` both have the \`basePath\` \`${basePath}\``,
        { workspace, index }
      );
    basePaths.set(basePath, getWorkspaceIdentifier(workspace, index));
  });
}
function hasBasePath(workspace, index) {
  const { name, basePath } = workspace;
  if (basePath && typeof basePath == "string")
    return !0;
  throw typeof basePath > "u" ? new WorkspaceValidationError(
    `If more than one workspace is defined, every workspace must have a \`basePath\` defined. Workspace \`${name}\` is missing a \`basePath\``,
    { workspace, index }
  ) : new WorkspaceValidationError(
    `If more than one workspace is defined, every workspace must have a \`basePath\` defined. Workspace \`${name}\` has an invalid \`basePath\` (must be a non-empty string)`,
    { workspace, index }
  );
}
function validateBasePath(workspace, index) {
  const { name, basePath } = workspace;
  if (!(!basePath || basePath === "/") && !/^\/[a-z0-9/_-]*[a-z0-9_-]+$/i.test(basePath))
    throw new WorkspaceValidationError(
      `All workspace \`basePath\`s must start with a leading \`/\`, consist of only URL safe characters, and cannot end with a trailing \`/\`. Workspace \`${name}\`'s basePath is \`${basePath}\``,
      { workspace, index }
    );
}
const emptyRender = () => React.createElement(React.Fragment);
function _createMiddlewareComponent(defaultComponent, middlewareComponents) {
  return (outerProps) => {
    let next = (props2) => React.createElement(defaultComponent, props2);
    for (const middleware2 of middlewareComponents) {
      const renderDefault = next;
      next = (props2) => React.createElement(middleware2, { ...props2, renderDefault });
    }
    return next({
      ...outerProps,
      // NOTE: it's safe to pass the empty render function, since it'll be overwritten in the next step (above).
      // NOTE: it's important that the default component does not use `renderDefault`, since it will
      // get the `emptyRender` callback will be passed when the middleware stack is empty.
      renderDefault: emptyRender
    });
  };
}
function useMiddlewareComponents(props2) {
  const { options } = useSource().__internal, { defaultComponent, pick: pick2 } = props2;
  return React.useMemo(() => {
    const flattened = [...flattenConfig(options, [])];
    flattened.reverse();
    const result = flattened.map(({ config }) => pick2(config)).filter(Boolean);
    return _createMiddlewareComponent(defaultComponent, result);
  }, [defaultComponent, options, pick2]);
}
var __defProp$g = Object.defineProperty, __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$g = (obj, key, value) => __defNormalProp$g(obj, typeof key != "symbol" ? key + "" : key, value);
class ConfigPropertyError extends Error {
  constructor({ propertyName, path, cause }) {
    const message = isRecord$4(cause) && typeof (cause == null ? void 0 : cause.message) == "string" ? `: ${cause.message}` : "";
    super(
      `An error occurred while resolving \`${propertyName}\` from ${path.join(" > ")}${message}`
    ), __publicField$g(this, "propertyName"), __publicField$g(this, "path"), __publicField$g(this, "cause"), this.name = "ConfigPropertyError", this.propertyName = propertyName, this.cause = cause, this.path = path;
  }
}
var __defProp$f = Object.defineProperty, __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$f = (obj, key, value) => __defNormalProp$f(obj, typeof key != "symbol" ? key + "" : key, value);
class ConfigResolutionError extends Error {
  constructor({ causes, name, type }) {
    const messages = causes.filter(Boolean).map(
      (cause) => isRecord$4(cause) && typeof (cause == null ? void 0 : cause.message) == "string" ? cause.message : String(cause)
    );
    super(
      `Could not resolve ${type}${name ? ` \`${name}\`` : ""}:
${messages.map((message) => `	- ${message}`).join(`
`)}

`
    ), __publicField$f(this, "name"), __publicField$f(this, "type"), __publicField$f(this, "causes"), this.name = name, this.causes = causes, this.type = type;
  }
}
function defineConfig(config) {
  return config;
}
function createConfig(config) {
  return config;
}
function validatePlugin(pluginResult) {
  const messages = [
    "projectId" in pluginResult && "`projectId` not allowed in plugin configuration",
    "dataset" in pluginResult && "`dataset` not allowed in plugin configuration"
  ].filter(isString__default.default);
  if (messages.length)
    throw new Error(
      `Invalid plugin configuration:
${messages.map((message) => `	${message}`).join(`
`)}`
    );
}
function definePlugin(arg) {
  if (typeof arg == "function") {
    const pluginFactory = arg;
    return (options) => {
      const result = pluginFactory(options);
      return validatePlugin(result), result;
    };
  }
  return validatePlugin(arg), () => arg;
}
function createPlugin(arg) {
  return definePlugin(arg);
}
function defineDocumentFieldAction(fieldAction) {
  return fieldAction;
}
const documentFieldActionsReducer = (prev, { document: document2 }, context) => {
  const documentFieldActions = document2 == null ? void 0 : document2.unstable_fieldActions;
  if (!documentFieldActions) return prev;
  if (typeof documentFieldActions == "function") return documentFieldActions(prev, context);
  if (Array.isArray(documentFieldActions)) return [...prev, ...documentFieldActions];
  throw new Error(
    `Expected \`document.unstable_fieldActions\` to be an array or a function, but received ${typeof documentFieldActions}`
  );
}, initialDocumentFieldActions = [];
function defineDocumentInspector(inspector) {
  return inspector;
}
function SchedulePublishingStudioLayout$1(props2) {
  const toast = ui.useToast();
  return React.useEffect(() => {
    console.error(
      `Scheduled publishing plugin is added by default, please remove this plugin from your config. 
        
If you have a custom date config, you can use the scheduledPublishing API to customize the date input.
        
See: https://www.sanity.io/docs/scheduled-publishing.
        `
    ), toast.push({
      id: "scheduled-publishing-deprecated",
      closable: !0,
      duration: 6e4,
      status: "error",
      title: "Scheduled publishing plugin is deprecated",
      description: "The scheduled publishing plugin is now deprecated, you should remove the plugin from your configuration. If you have a custom date config, you can use the scheduledPublishing API to customize the date input. See: https://www.sanity.io/docs/scheduled-publishing."
    });
  }, [toast]), props2.renderDefault(props2);
}
const deprecatedScheduledPublishingPlugin = definePlugin({
  name: "sanity/deprecated/scheduled-publishing",
  studio: {
    components: {
      layout: SchedulePublishingStudioLayout$1
    }
  }
}), DEPRECATED_PLUGINS = [
  // Scheduled publishing is added by default, we are filtering to avoid duplicates
  "scheduled-publishing"
], flattenConfig = ({ plugins = [], ...currentConfig }, path) => {
  const rootConfig = { config: currentConfig, path: [...path, currentConfig.name] }, allPlugins = plugins.flatMap(
    (plugin) => flattenConfig(plugin, [...path, currentConfig.name])
  ), deprecatedScheduledPublishing = allPlugins.find(
    (p) => p.config.name === "scheduled-publishing"
  );
  return deprecatedScheduledPublishing && allPlugins.push({
    path: deprecatedScheduledPublishing.path,
    config: deprecatedScheduledPublishingPlugin()
  }), [
    ...allPlugins.filter((plugin) => !DEPRECATED_PLUGINS.includes(plugin.config.name)),
    rootConfig
  ];
}, DEBUG_MODE$1 = !1, SPINNER_DELAY = 750, TEXT_DELAY = 2e3, StyledCard$4 = styledComponents.styled(ui.Card)(({ $fill }) => styledComponents.css`
    align-items: center;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;

    ${$fill ? styledComponents.css`
          bottom: 0;
          height: 100%;
          left: 0;
          position: absolute;
          right: 0;
          top: 0;
          width: 100%;
        ` : styledComponents.css`
          min-height: 75px;
          height: stretch;
          height: -webkit-fill-available;
          width: stretch;
          width: -webkit-fill-available;
        `}

    ${DEBUG_MODE$1}

    > * {
      position: absolute;
    }
  `), StyledSpinner = styledComponents.styled(ui.Spinner)(({ $animatePosition = !0 }) => styledComponents.css`
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    @keyframes slideUp {
      from {
        transform: translateY(0);
      }
      to {
        transform: translateY(-15px);
      }
    }
    animation: ${$animatePosition ? `500ms ease-out ${SPINNER_DELAY}ms 1 normal both running fadeIn, 750ms ease-out ${TEXT_DELAY}ms 1 normal both running slideUp` : `500ms ease-out ${SPINNER_DELAY}ms 1 normal both running fadeIn`};
  `), StyledText$6 = styledComponents.styled(ui.Text)`
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  @keyframes slideDown {
    from {
      transform: translateY(0);
    }
    to {
      transform: translateY(15px);
    }
  }
  animation:
    1500ms ease-out ${TEXT_DELAY}ms 1 normal both running fadeIn,
    750ms ease-out ${TEXT_DELAY}ms 1 normal both running slideDown;
`;
function LoadingBlock({ fill, showText, title }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(StyledCard$4, { $fill: fill, as: fill ? ui.Layer : "div", children: [
    /* @__PURE__ */ jsxRuntime.jsx(StyledSpinner, { $animatePosition: !!showText, muted: !0 }),
    showText && /* @__PURE__ */ jsxRuntime.jsx(LoadingText, { title })
  ] });
}
function LoadingText({ title }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(StyledText$6, { muted: !0, size: 1, children: title || t2("common.loading") });
}
function defineLocaleResourceBundle(bundle) {
  return bundle;
}
function defineLocale(locale) {
  return locale;
}
function isStaticResourceBundle(bundle) {
  return !("then" in bundle.resources && typeof bundle.resources.then == "function");
}
function defineLocalesResources(namespace, resources) {
  return resources;
}
function removeUndefinedLocaleResources(resources) {
  const result = {};
  for (const key in resources)
    typeof resources[key] < "u" && (result[key] = resources[key]);
  return result;
}
const studioLocaleNamespace = "studio", validationLocaleNamespace = "validation", studioLocaleStrings = defineLocalesResources("studio", {
  /** Menu item for deleting the asset */
  "asset-source.asset-list.menu.delete": "Delete",
  /** Menu item for showing where a particular asset is used */
  "asset-source.asset-list.menu.show-usage": "Show usage",
  /** Header in usage dialog for file assets */
  "asset-source.asset-usage-dialog.header_file": "Documents using file",
  /** Header in usage dialog for image assets */
  "asset-source.asset-usage-dialog.header_image": "Documents using image",
  /** Text shown in usage dialog when loading documents using the selected asset */
  "asset-source.asset-usage-dialog.loading": "Loading\u2026",
  /** Text for cancel action in delete-asset dialog */
  "asset-source.delete-dialog.action.cancel": "Cancel",
  /** Text for "confirm delete" action in delete-asset dialog */
  "asset-source.delete-dialog.action.delete": "Delete",
  /** Dialog header for delete-asset dialog when deleting a file */
  "asset-source.delete-dialog.header_file": "Delete file",
  /** Dialog header for delete-asset dialog when deleting an image */
  "asset-source.delete-dialog.header_image": "Delete image",
  /** Text shown in delete dialog when loading documents using the selected asset */
  "asset-source.delete-dialog.loading": "Loading\u2026",
  /** Message confirming to delete *named* file */
  "asset-source.delete-dialog.usage-list.confirm-delete-file_named": "You are about to delete the file <strong>{{filename}}</strong> and its metadata. Are you sure?",
  /** Message confirming to delete *unnamed* file */
  "asset-source.delete-dialog.usage-list.confirm-delete-file_unnamed": "You are about to delete the file and its metadata. Are you sure?",
  /** Message confirming to delete *named* image */
  "asset-source.delete-dialog.usage-list.confirm-delete-image_named": "You are about to delete the image <strong>{{filename}}</strong> and its metadata. Are you sure?",
  /** Message confirming to delete *unnamed* image */
  "asset-source.delete-dialog.usage-list.confirm-delete-image_unnamed": "You are about to delete the image and its metadata. Are you sure?",
  /** Alt text showing on image preview in delete asset dialog  */
  "asset-source.delete-dialog.usage-list.image-preview-alt": "Preview of image",
  /** Warning message showing when *named* file can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-file-is-in-use_named": "{{filename}} cannot be deleted because it's being used. In order to delete this file, you first need to remove all uses of it.",
  /** Warning message showing when *unnamed* file can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-file-is-in-use_unnamed": "This file cannot be deleted because it's being used. In order to delete it, you first need to remove all uses of it.",
  /** Warning message showing when *named* image can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-image-is-in-use_named": "{{filename}} cannot be deleted because it's being used. In order to delete this image, you first need to remove all uses of it.",
  /** Warning message showing when *unnamed* image can't be deleted because it is in use */
  "asset-source.delete-dialog.usage-list.warning-image-is-in-use_unnamed": "This image cannot be deleted because it's being used. In order to delete it, you first need to remove all uses of it.",
  /** Text shown when the list of assets only include a specific set of types */
  "asset-source.dialog.accept-message": "Only showing assets of accepted types: <strong>{{acceptTypes}}</strong>",
  /** Keys shared between both image asset source and file asset source */
  /** Select asset dialog title for files */
  "asset-source.dialog.default-title_file": "Select file",
  /** Select asset dialog title for images */
  "asset-source.dialog.default-title_image": "Select image",
  /** Select asset dialog load more items */
  "asset-source.dialog.load-more": "Load more",
  /** Text shown when selecting a file but there's no files to select from */
  "asset-source.dialog.no-assets_file": "No files",
  /** Text shown when selecting an image but there's no images to select from */
  "asset-source.dialog.no-assets_image": "No images",
  "asset-source.file.asset-list.action.delete.disabled-cannot-delete-current-file": "Cannot delete currently selected file",
  "asset-source.file.asset-list.action.delete.text": "Delete",
  "asset-source.file.asset-list.action.delete.title": "Delete file",
  "asset-source.file.asset-list.action.select-file.title": "Select the file {{filename}}",
  "asset-source.file.asset-list.action.show-usage.title": "Show usage",
  "asset-source.file.asset-list.delete-failed": "File could not be deleted",
  "asset-source.file.asset-list.delete-successful": "File was deleted",
  "asset-source.file.asset-list.header.date-added": "Date added",
  /** File asset source */
  "asset-source.file.asset-list.header.filename": "Filename",
  "asset-source.file.asset-list.header.size": "Size",
  "asset-source.file.asset-list.header.type": "Type",
  /** Text displayed on button or menu invoking the file asset source */
  "asset-source.file.title": "Uploaded files",
  "asset-source.image.asset-list.delete-failed": "Image could not be deleted",
  /** Image asset source */
  "asset-source.image.asset-list.delete-successful": "Image was deleted",
  /** Text displayed on button or menu invoking the image asset source */
  "asset-source.image.title": "Uploaded images",
  "asset-source.usage-list.documents-using-file_named_one": "One document is using file <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-file_named_other": "{{count}} documents are using file <code>{{filename}}</code>",
  /** Text shown in usage dialog for a file asset when there are zero, one or more documents using the *named* file **/
  "asset-source.usage-list.documents-using-file_named_zero": "No documents are using file <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-file_unnamed_one": "One document is using this file",
  "asset-source.usage-list.documents-using-file_unnamed_other": "{{count}} documents are using this file",
  /** Text shown in usage dialog for a file asset when there are zero, one or more documents using the *unnamed* file **/
  "asset-source.usage-list.documents-using-file_unnamed_zero": "No documents are using this file",
  "asset-source.usage-list.documents-using-image_named_one": "One document is using image <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-image_named_other": "{{count}} documents are using image <code>{{filename}}</code>",
  /** Text shown in usage dialog for an image asset when there are zero, one or more documents using the *named* image **/
  "asset-source.usage-list.documents-using-image_named_zero": "No documents are using image <code>{{filename}}</code>",
  "asset-source.usage-list.documents-using-image_unnamed_one": "One document is using this image",
  "asset-source.usage-list.documents-using-image_unnamed_other": "{{count}} documents are using this image",
  /** Text shown in usage dialog for an image asset when there are zero, one or more documents using the *unnamed* image **/
  "asset-source.usage-list.documents-using-image_unnamed_zero": "No documents are using this image",
  /** Action message for navigating to next month */
  "calendar.action.go-to-next-month": "Go to next month",
  /** Action message for navigating to next year */
  "calendar.action.go-to-next-year": "Go to next year",
  /** Action message for navigating to previous month */
  "calendar.action.go-to-previous-month": "Go to previous month",
  /** Action message for navigating to previous year */
  "calendar.action.go-to-previous-year": "Go to previous year",
  /* Label for navigating the calendar to "today", without _selecting_ today. Short form, eg `Today`, not `Go to today` */
  "calendar.action.go-to-today": "Today",
  /* Accessibility label for navigating the calendar to "today", without _selecting_ today */
  "calendar.action.go-to-today-aria-label": "Go to today",
  /* Label for navigating the calendar to "tomorrow", without _selecting_ tomorrow. Short form, eg `Tomorrow`, not `Go to tomorrow` */
  "calendar.action.go-to-tomorrow": "Tomorrow",
  /* Label for navigating the calendar to "yesterday", without _selecting_ yesterday. Short form, eg `Yesterday`, not `Go to yesterday` */
  "calendar.action.go-to-yesterday": "Yesterday",
  /** Label for switch that controls whether or not to include time in given timestamp */
  "calendar.action.include-time-label": "Include time",
  /** Action message for selecting the hour */
  "calendar.action.select-hour": "Select hour",
  /** Action message for selecting the minute */
  "calendar.action.select-minute": "Select minute",
  /** Action message for setting to the current time */
  "calendar.action.set-to-current-time": "Set to current time",
  /** Label for selecting an hour preset. Receives a `time` param as a string on hh:mm format and a `date` param as a Date instance denoting the preset date */
  "calendar.action.set-to-time-preset": "{{time}} on {{date, datetime}}",
  /** Error message displayed in calendar when entered date is not the correct format */
  "calendar.error.must-be-in-format": "Must be in the format: {{exampleDate}}",
  /** Month name for April */
  "calendar.month-names.april": "April",
  /** Month name for August */
  "calendar.month-names.august": "August",
  /** Month name for December */
  "calendar.month-names.december": "December",
  /** Month name for February */
  "calendar.month-names.february": "February",
  /** Month name for January */
  "calendar.month-names.january": "January",
  /** Month name for July */
  "calendar.month-names.july": "July",
  /** Month name for June */
  "calendar.month-names.june": "June",
  /** Month name for March */
  "calendar.month-names.march": "March",
  /** Month name for May */
  "calendar.month-names.may": "May",
  /** Month name for November */
  "calendar.month-names.november": "November",
  /** Month name for October */
  "calendar.month-names.october": "October",
  /** Month name for September */
  "calendar.month-names.september": "September",
  /** Short weekday name for Friday */
  "calendar.weekday-names.short.friday": "Fri",
  /** Short weekday name for Monday */
  "calendar.weekday-names.short.monday": "Mon",
  /** Short weekday name for Saturdayday */
  "calendar.weekday-names.short.saturday": "Sat",
  /** Short weekday name for Sunday */
  "calendar.weekday-names.short.sunday": "Sun",
  /** Short weekday name for Thursday */
  "calendar.weekday-names.short.thursday": "Thu",
  /** Short weekday name for Tuesday */
  "calendar.weekday-names.short.tuesday": "Tue",
  /** Short weekday name for Wednesday */
  "calendar.weekday-names.short.wednesday": "Wed",
  /** Label for the close button label in Review Changes pane */
  "changes.action.close-label": "Close review changes",
  /** Cancel label for revert button prompt action */
  "changes.action.revert-all-cancel": "Cancel",
  /** Revert all confirm label for revert button action - used on prompt button + review changes pane */
  "changes.action.revert-all-confirm": "Revert all",
  /** Prompt for reverting all changes in document in Review Changes pane. Includes a count of changes. */
  "changes.action.revert-all-description": "Are you sure you want to revert all {{count}} changes?",
  /** Prompt for confirming revert change (singular) label for field change action */
  "changes.action.revert-changes-confirm-change_one": "Revert change",
  /** Revert for confirming revert (plural) label for field change action */
  "changes.action.revert-changes-confirm-change_other": "Revert changes",
  /** Prompt for reverting changes for a field change */
  "changes.action.revert-changes-description": "Are you sure you want to revert the changes?",
  /** Prompt for reverting changes for a group change, eg multiple changes */
  "changes.action.revert-changes-description_one": "Are you sure you want to revert the change?",
  /** Label for when the action of the change was to set something that was previously empty, eg a field was given a value, an array item was added, an asset was selected or similar */
  "changes.added-label": "Added",
  /** Array diff: An item was added in a given position (`{{position}}`) */
  "changes.array.item-added-in-position": "Added in position {{position}}",
  "changes.array.item-moved_down_one": "Moved {{count}} position down",
  "changes.array.item-moved_down_other": "Moved {{count}} positions down",
  /**
   * Array diff: An item was moved within the array.
   * Receives `{{count}}` representing number of positions it moved.
   * Context is the direction of the move, either `up` or `down`.
   */
  "changes.array.item-moved_up_one": "Moved {{count}} position up",
  "changes.array.item-moved_up_other": "Moved {{count}} positions up",
  /** Array diff: An item was removed from a given position (`{{position}}`) */
  "changes.array.item-removed-from-position": "Removed from position {{position}}",
  /** Accessibility label for the "change bar" shown when there are edits on a field-level */
  "changes.change-bar.aria-label": "Review changes",
  /** Label for when the action of the change was _not_ an add/remove, eg a text field changed value, an image was changed from one asset to another or similar */
  "changes.changed-label": "Changed",
  /** Label and text for tooltip that indicates the authors of the changes */
  "changes.changes-by-author": "Changes by",
  /** Additional text shown in development mode when a diff component crashes during rendering */
  "changes.error-boundary.developer-info": "Check the developer console for more information",
  /** Text shown when a diff component crashes during rendering, triggering the error boundary */
  "changes.error-boundary.title": "Rendering the changes to this field caused an error",
  /** Error message shown when the value of a field is not the expected one */
  "changes.error.incorrect-type-message": 'Value error: Value is of type "<code>{{actualType}}</code>", expected "<code>{{expectedType}}</code>"',
  /** File diff: Fallback title for the meta info section when there is no original filename to use  */
  "changes.file.meta-info-fallback-title": "Untitled",
  /** Image diff: Text shown in tooltip when hovering hotspot that has changed in diff view */
  "changes.image.crop-changed": "Crop changed",
  /** Image diff: Text shown if the previous image asset was deleted (shouldn't theoretically happen) */
  "changes.image.deleted": "Image deleted",
  /** Image diff: Text shown if the image failed to be loaded when previewing it */
  "changes.image.error-loading-image": "Error loading image",
  /** Image diff: Text shown in tooltip when hovering hotspot that has changed in diff view */
  "changes.image.hotspot-changed": "Hotspot changed",
  /** Image diff: Fallback title for the meta info section when there is no original filename to use  */
  "changes.image.meta-info-fallback-title": "Untitled",
  /** Image diff: Text shown if no asset has been set for the field (but has metadata changes) */
  "changes.image.no-asset-set": "Image not set",
  /** Image diff: Text shown when the from/to state has/had no image */
  "changes.image.no-image-placeholder": "(no image)",
  /** Label for the "from" value in the change inspector */
  "changes.inspector.from-label": "From",
  /** Label for the "meta" (field path, action etc) information in the change inspector */
  "changes.inspector.meta-label": "Meta",
  /** Label for the "to" value in the change inspector */
  "changes.inspector.to-label": "To",
  /** Loading author of change in the differences tooltip in the review changes pane */
  "changes.loading-author": "Loading\u2026",
  /** Loading changes in Review Changes Pane */
  "changes.loading-changes": "Loading changes\u2026",
  /** No Changes description in the Review Changes pane */
  "changes.no-changes-description": "Edit the document or select an older version in the timeline to see a list of changes appear in this panel.",
  /** No Changes title in the Review Changes pane */
  "changes.no-changes-title": "There are no changes",
  /** Portable Text diff: An annotation was added */
  "changes.portable-text.annotation_added": "Added annotation",
  /** Portable Text diff: An annotation was changed */
  "changes.portable-text.annotation_changed": "Changed annotation",
  /** Portable Text diff: An annotation was removed */
  "changes.portable-text.annotation_removed": "Removed annotation",
  /** Portable Text diff: An annotation was left unchanged */
  "changes.portable-text.annotation_unchanged": "Unchanged annotation",
  /** Portable Text diff: A block changed from one style to another (eg `normal` to `h1` or similar) */
  "changes.portable-text.block-style-changed": 'Changed block style from "{{fromStyle}}" to "{{toStyle}}"',
  /** Portable Text diff: Change formatting of text (setting/unsetting marks, eg bold/italic etc) */
  "changes.portable-text.changed-formatting": "Changed formatting",
  /** Portable Text diff: An empty inline object is part of a change */
  "changes.portable-text.empty-inline-object": "Empty {{inlineObjectType}}",
  /** Portable Text diff: An empty object is the result of adding/removing an annotation */
  "changes.portable-text.empty-object-annotation": "Empty {{annotationType}}",
  /** Portable Text diff: Added a block containing no text (eg empty block) */
  "changes.portable-text.empty-text_added": "Added empty text",
  /** Portable Text diff: Changed a block that contained no text (eg empty block) */
  "changes.portable-text.empty-text_changed": "Changed empty text",
  /** Portable Text diff: Removed a block containing no text (eg empty block) */
  "changes.portable-text.empty-text_removed": "Removed empty text",
  /** Portable Text diff: An inline object was added */
  "changes.portable-text.inline-object_added": "Added inline object",
  /** Portable Text diff: An inline object was changed */
  "changes.portable-text.inline-object_changed": "Changed inline object",
  /** Portable Text diff: An inline object was removed */
  "changes.portable-text.inline-object_removed": "Removed inline object",
  /** Portable Text diff: An inline object was left unchanged */
  "changes.portable-text.inline-object_unchanged": "Unchanged inline object",
  /** Portable Text diff: Added a chunk of text */
  "changes.portable-text.text_added": "Added text",
  /** Portable Text diff: Removed a chunk of text */
  "changes.portable-text.text_removed": "Removed text",
  /** Portable Text diff: Annotation has an unknown schema type */
  "changes.portable-text.unknown-annotation-schema-type": "Unknown schema type",
  /** Portable Text diff: Inline object has an unknown schema type */
  "changes.portable-text.unknown-inline-object-schema-type": "Unknown schema type",
  /** Label for when the action of the change was a removal, eg a field was cleared, an array item was removed, an asset was deselected or similar */
  "changes.removed-label": "Removed",
  /** Title for the Review Changes pane */
  "changes.title": "Review changes",
  /** --- Common components --- */
  /** Tooltip text for context menu buttons */
  "common.context-menu-button.tooltip": "Show more",
  /** Default text for dialog cancel button */
  "common.dialog.cancel-button.text": "Cancel",
  /** Default text for dialog confirm button */
  "common.dialog.confirm-button.text": "Confirm",
  /** Default text in shared loader text / spinner lockup */
  "common.loading": "Loading",
  /** --- Configuration issues --- */
  /** Default label text on configuration issues button */
  "configuration-issues.button.label": "Configuration issues",
  /** Tooltip displayed on configuration issues button */
  "configuration-issues.button.tooltip": "Found configuration issues",
  /** The fallback title for an ordering menu item if no localized titles are provided. */
  "default-menu-item.fallback-title": "Sort by {{title}}",
  /** Title for the default ordering/SortOrder if no orderings are provided and the caption field is found */
  "default-orderings.caption": "Sort by Caption",
  /** Title for the default ordering/SortOrder if no orderings are provided and the description field is found */
  "default-orderings.description": "Sort by Description",
  /** Title for the default ordering/SortOrder if no orderings are provided and the header field is found */
  "default-orderings.header": "Sort by Header",
  /** Title for the default ordering/SortOrder if no orderings are provided and the heading field is found */
  "default-orderings.heading": "Sort by Heading",
  /** Title for the default ordering/SortOrder if no orderings are provided and the label field is found */
  "default-orderings.label": "Sort by Label",
  /** Title for the default ordering/SortOrder if no orderings are provided and the name field is found */
  "default-orderings.name": "Sort by Name",
  /** Title for the default ordering/SortOrder if no orderings are provided and the title field is found */
  "default-orderings.title": "Sort by Title",
  /** Label to show in the document footer indicating the last edited date of the document */
  "document-status.edited": "Edited {{date}}",
  /** Label to show in the document footer indicating the document is not published*/
  "document-status.not-published": "Not published",
  /** Label to show in the document footer indicating the published date of the document */
  "document-status.published": "Published {{date}}",
  /** The value of the <code>_key</code> property must be a unique string. */
  "form.error.duplicate-keys-alert.details.additional-description": "The value of the <code>_key</code> property must be a unique string.",
  /** This usually happens when items are created using an API client, and the <code>_key</code> property of each elements has been generated non-uniquely. */
  "form.error.duplicate-keys-alert.details.description": "This usually happens when items are created using an API client, and the <code>_key</code> property of each elements has been generated non-uniquely.",
  /** Developer info */
  "form.error.duplicate-keys-alert.details.title": "Developer info",
  /** Generate unique keys */
  "form.error.duplicate-keys-alert.generate-button.text": "Generate unique keys",
  /** Several items in this list share the same identifier (key). Every item must have an unique identifier. */
  "form.error.duplicate-keys-alert.summary": "Several items in this list share the same identifier (key). Every item must have an unique identifier.",
  /** Non-unique keys */
  "form.error.duplicate-keys-alert.title": "Non-unique keys",
  /** Error text shown when a field with a given name cannot be found in the schema or is conditionally hidden but explicitly told to render  */
  "form.error.field-not-found": 'Field "{{fieldName}}" not found among members \u2013 verify that it is defined in the schema and that it has not been conditionally hidden.',
  /** Add missing keys */
  "form.error.missing-keys-alert.add-button.text": "Add missing keys",
  /** The value of the <code>_key</code> property must be a unique string. */
  "form.error.missing-keys-alert.details.additional-description": "The value of the <code>_key</code> property must be a unique string.",
  /** This usually happens when items are created using an API client, and the <code>_key</code> property has not been included. */
  "form.error.missing-keys-alert.details.description": "This usually happens when items are created using an API client, and the <code>_key</code> property has not been included.",
  /** Developer info */
  "form.error.missing-keys-alert.details.title": "Developer info",
  /** Some items in the list are missing their keys. This must be fixed in order to edit the list. */
  "form.error.missing-keys-alert.summary": "Some items in the list are missing their keys. This must be fixed in order to edit the list.",
  /** Missing keys */
  "form.error.missing-keys-alert.title": "Missing keys",
  /** This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list. */
  "form.error.mixed-array-alert.details.description": "This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list.",
  /** Developer info */
  "form.error.mixed-array-alert.details.title": "Developer info",
  /**  Remove non-object values */
  "form.error.mixed-array-alert.remove-button.text": "Remove non-object values",
  /** Some items in this list are not objects. This must be fixed in order to edit the list. */
  "form.error.mixed-array-alert.summary": "Some items in this list are not objects. This must be fixed in order to edit the list.",
  /** Invalid list values */
  "form.error.mixed-array-alert.title": "Invalid list values",
  /** Error text shown when form is unable to find an array item at a given indexed path */
  "form.error.no-array-item-at-index": "No array item at index <code>{{index}}</code> found at path <code>{{path}}</code>",
  /** Error text shown when form is unable to find an array item at a given keyed path */
  "form.error.no-array-item-at-key": 'No array item with `_key` <code>"{{key}}"</code> found at path <code>{{path}}</code>',
  /** Form field deprecated label */
  "form.field.deprecated-label": "deprecated",
  /** Fallback title shown above field if it has no defined title */
  "form.field.untitled-field-label": "Untitled",
  /** Fallback title shown above fieldset if it has no defined title */
  "form.field.untitled-fieldset-label": "Untitled",
  /** Accessibility label for the icon that indicates the field has a validation error */
  "form.validation.has-error-aria-label": "Has error",
  /** Accessibility label for the icon that indicates the field has validation information */
  "form.validation.has-info-aria-label": "Has information",
  /** Accessibility label for the icon that indicates the field has a validation warning */
  "form.validation.has-warning-aria-label": "Has warning",
  /** Text shown when summarizing validation information, when the field has one or more errors */
  "form.validation.summary.errors-count_one": "{{count}} error",
  "form.validation.summary.errors-count_other": "{{count}} errors",
  /** Text shown when summarizing validation information, when the field has one or more warnings */
  "form.validation.summary.warnings-count_one": "{{count}} warning",
  "form.validation.summary.warnings-count_other": "{{count}} warnings",
  /** Tooltip for free trial navbar button indicating remaining days */
  "free-trial.tooltip.days-count_one": "{{count}} day left in trial",
  "free-trial.tooltip.days-count_other": "{{count}} days left in trial",
  /** Tooltip for free trial navbar button, once trial has ended */
  "free-trial.tooltip.trial-finished": "Upgrade your project",
  /**
   * Label for "contact sales" call to action
   * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
   */
  "help-resources.action.contact-sales": "Contact sales",
  /**
   * Label for "help and support" call to action
   * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
   */
  "help-resources.action.help-and-support": "Help and support",
  /**
   * Label for "join our community" call to action
   * These are titles for fallback links in the event the help & resources endpoint isn't able to be fetched
   */
  "help-resources.action.join-our-community": "Join our community",
  /** Information for what the latest sanity version is */
  "help-resources.latest-sanity-version": "Latest version is {{latestVersion}}",
  /** Information for what studio version the current studio is running */
  "help-resources.studio-version": "Sanity Studio version {{studioVersion}}",
  /** Title for help and resources menus */
  "help-resources.title": "Help and resources",
  /** Text for button to cancel an ongoing upload */
  "input.files.common.cancel-upload": "Cancel",
  /** Text for file input button in upload placeholder */
  "input.files.common.upload-placeholder.file-input-button.text": "Upload",
  /** Uploading <FileName/> */
  "input.files.common.upload-progress": "Uploading <FileName/>",
  /** The referenced document cannot be opened, because the URL failed to be resolved */
  "input.reference.document-cannot-be-opened.failed-to-resolve-url": "This document cannot be opened (unable to resolve URL to Studio)",
  /** Label for adding item after a specific array item */
  "inputs.array.action.add-after": "Add item after",
  /** Label for adding item before a specific array item */
  "inputs.array.action.add-before": "Add item before",
  /** Label for adding array item action when the schema allows for only one schema type */
  "inputs.array.action.add-item": "Add item",
  /**
   * Label for adding one array item action when the schema allows for multiple schema types,
   * eg. will prompt the user to select a type once triggered
   */
  "inputs.array.action.add-item-select-type": "Add item...",
  /** Array drag handle button tooltip */
  "inputs.array.action.drag.tooltip": "Drag to re-order",
  /** Label for duplicating an array item  */
  "inputs.array.action.duplicate": "Duplicate",
  /** Label for editing the item of a specific type, eg "Edit Person" */
  "inputs.array.action.edit": "Edit {{itemTypeTitle}}",
  /** Label for removing an array item action  */
  "inputs.array.action.remove": "Remove",
  /** Label for removing action when an array item has an error  */
  "inputs.array.action.remove-invalid-item": "Remove",
  /** Label for viewing the item of a specific type, eg "View Person" */
  "inputs.array.action.view": "View {{itemTypeTitle}}",
  /** Error description for the array item tooltip that explains that the current item can still be moved or deleted but not edited since the schema definition is not found */
  "inputs.array.error.can-delete-but-no-edit-description": "You can still move or delete this item, but it cannot be edited since the schema definition for its type is nowhere to be found.",
  /** Error label for toast when array could not resolve the initial value */
  "inputs.array.error.cannot-resolve-initial-value-title": "Unable to resolve initial value for type: {{schemaTypeTitle}}: {{errorMessage}}.",
  /** Error label for toast when trying to upload one array item of a type that cannot be converted to array */
  "inputs.array.error.cannot-upload-unable-to-convert_one": "The following item can't be uploaded because there's no known conversion from content type to array item:",
  /** Error label for toast when trying to upload multiple array items of a type that cannot be converted to array */
  "inputs.array.error.cannot-upload-unable-to-convert_other": "The following items can't be uploaded because there's no known conversion from content types to array item:",
  /** Error description for the array item tooltip that explains that the current type item is not valid for the list  */
  "inputs.array.error.current-schema-not-declare-description": "The current schema does not declare items of type <code>{{typeName}}</code> as valid for this list. This could mean that the type has been removed as a valid item type, or that someone else has added it to their own local schema that is not yet deployed.",
  /** Error description to show how the item is being represented in the json format */
  "inputs.array.error.json-representation-description": "JSON representation of this item:",
  /** Error description for the array item tooltip that explains what the error means with more context */
  "inputs.array.error.type-is-incompatible-prompt": "Item of type <code>{{typeName}}</code> not valid for this list",
  /** Error title for when an item type within an array input is incompatible, used in the tooltip */
  "inputs.array.error.type-is-incompatible-title": "Why is this happening?",
  /** Error label for unexpected errors in the Array Input */
  "inputs.array.error.unexpected-error": "Unexpected Error: {{error}}",
  /** Label for when the array input doesn't have any items */
  "inputs.array.no-items-label": "No items",
  /** Label for read only array fields */
  "inputs.array.read-only-label": "This field is read-only",
  /** Label for when the array input is resolving the initial value for the item */
  "inputs.array.resolving-initial-value": "Resolving initial value\u2026",
  /** Tooltip content when boolean input is disabled */
  "inputs.boolean.disabled": "Disabled",
  /** Placeholder value for datetime input */
  "inputs.datetime.placeholder": "e.g. {{example}}",
  /** Acessibility label for button to open file options menu */
  "inputs.file.actions-menu.file-options.aria-label": "Open file options menu",
  /** Browse */
  "inputs.file.browse-button.text": "Browse",
  /** Select file */
  "inputs.file.dialog.title": "Select file",
  /** Unknown member kind: `{{kind}}` */
  "inputs.file.error.unknown-member-kind": "Unknown member kind: {{kind}}",
  /** The value of this field is not a valid file. Resetting this field will let you choose a new file. */
  "inputs.file.invalid-file-warning.description": "The value of this field is not a valid file. Resetting this field will let you choose a new file.",
  /** Reset value */
  "inputs.file.invalid-file-warning.reset-button.text": "Reset value",
  /** Invalid file value */
  "inputs.file.invalid-file-warning.title": "Invalid file value",
  /** Select */
  "inputs.file.multi-browse-button.text": "Select",
  /** The upload could not be completed at this time. */
  "inputs.file.upload-failed.description": "The upload could not be completed at this time.",
  /** Upload failed */
  "inputs.file.upload-failed.title": "Upload failed",
  /** Clear field */
  "inputs.files.common.actions-menu.clear-field.label": "Clear field",
  /** Copy URL */
  "inputs.files.common.actions-menu.copy-url.label": "Copy URL",
  /** Download */
  "inputs.files.common.actions-menu.download.label": "Download",
  /** The URL is copied to the clipboard */
  "inputs.files.common.actions-menu.notification.url-copied": "The URL is copied to the clipboard",
  /** Replace */
  "inputs.files.common.actions-menu.replace.label": "Replace",
  /** Upload */
  "inputs.files.common.actions-menu.upload.label": "Upload",
  /** Drop to upload */
  "inputs.files.common.drop-message.drop-to-upload": "Drop to upload",
  /** Drop to upload `{{count}}` file */
  "inputs.files.common.drop-message.drop-to-upload-multi_one": "Drop to upload {{count}} file",
  /** Drop to upload `{{count}}` files */
  "inputs.files.common.drop-message.drop-to-upload-multi_other": "Drop to upload {{count}} files",
  /** Can't upload this file here */
  "inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message_one": "Can't upload this file here",
  /** Can't upload any of these files here */
  "inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message_other": "Can't upload any of these files here",
  /** `{{count}}` file can't be uploaded here */
  "inputs.files.common.drop-message.drop-to-upload.rejected-file-message_one": "{{count}} file can't be uploaded here",
  /** `{{count}}` files can't be uploaded here */
  "inputs.files.common.drop-message.drop-to-upload.rejected-file-message_other": "{{count}} files can't be uploaded here",
  /** Cannot upload `{{count}}` files */
  "inputs.files.common.placeholder.cannot-upload-some-files_one": "Cannot upload file",
  "inputs.files.common.placeholder.cannot-upload-some-files_other": "Cannot upload {{count}} files",
  /** Drag or paste type here */
  "inputs.files.common.placeholder.drag-or-paste-to-upload_file": "Drag or paste file here",
  /** Drag or paste image here */
  "inputs.files.common.placeholder.drag-or-paste-to-upload_image": "Drag or paste image here",
  /** Drop to upload file */
  "inputs.files.common.placeholder.drop-to-upload_file": "Drop to upload file",
  /** Drop to upload image */
  "inputs.files.common.placeholder.drop-to-upload_image": "Drop to upload image",
  /** Read only */
  "inputs.files.common.placeholder.read-only": "Read only",
  /** Can't upload files here */
  "inputs.files.common.placeholder.upload-not-supported": "Can't upload files here",
  /** Clear upload */
  "inputs.files.common.stale-upload-warning.clear": "Clear upload",
  /** An upload has made no progress for at least `{{staleThresholdMinutes}}` minutes and likely got interrupted. You can safely clear the incomplete upload and try uploading again. */
  "inputs.files.common.stale-upload-warning.description": "An upload has made no progress for at least {{staleThresholdMinutes}} minutes and likely got interrupted. You can safely clear the incomplete upload and try uploading again.",
  /** Incomplete upload */
  "inputs.files.common.stale-upload-warning.title": "Incomplete upload",
  /** Tooltip text for action to crop image */
  "inputs.image.actions-menu.crop-image-tooltip": "Crop image",
  /** Accessibility label for button to open image edit dialog */
  "inputs.image.actions-menu.edit-details.aria-label": "Open image edit dialog",
  /** Accessibility label for button to open image options menu */
  "inputs.image.actions-menu.options.aria-label": "Open image options menu",
  /** Select */
  "inputs.image.browse-menu.text": "Select",
  /** Cannot upload this file here */
  "inputs.image.drag-overlay.cannot-upload-here": "Cannot upload this file here",
  /** Drop image to upload */
  "inputs.image.drag-overlay.drop-to-upload-image": "Drop image to upload",
  /** This field is read only */
  "inputs.image.drag-overlay.this-field-is-read-only": "This field is read only",
  /** Unknown member kind: `{{kind}}` */
  "inputs.image.error.unknown-member-kind": "Unknown member kind: {{kind}}",
  /** Edit hotspot and crop */
  "inputs.image.hotspot-dialog.title": "Edit hotspot and crop",
  /** The value of this field is not a valid image. Resetting this field will let you choose a new image. */
  "inputs.image.invalid-image-warning.description": "The value of this field is not a valid image. Resetting this field will let you choose a new image.",
  /** Reset value */
  "inputs.image.invalid-image-warning.reset-button.text": "Reset value",
  /** Invalid image value */
  "inputs.image.invalid-image-warning.title": "Invalid image value",
  /** Preview of uploaded image */
  "inputs.image.preview-uploaded-image": "Preview of uploaded image",
  /** The upload could not be completed at this time. */
  "inputs.image.upload-error.description": "The upload could not be completed at this time.",
  /** Upload failed */
  "inputs.image.upload-error.title": "Upload failed",
  /** Adjust the rectangle to crop image. Adjust the circle to specify the area that should always be visible. */
  "inputs.imagetool.description": "Adjust the rectangle to crop image. Adjust the circle to specify the area that should always be visible.",
  /** Error: `{{errorMessage}}` */
  "inputs.imagetool.load-error": "Error: {{errorMessage}}",
  /** Hotspot & Crop */
  "inputs.imagetool.title": "Hotspot & Crop",
  /** Convert to `{{targetType}}` */
  "inputs.invalid-value.convert-button.text": "Convert to {{targetType}}",
  /** The current value (<code>`{{actualType}}`</code>) */
  "inputs.invalid-value.current-type": "The current value (<code>{{actualType}}</code>)",
  /** The property value is stored as a value type that does not match the expected type. */
  "inputs.invalid-value.description": "The property value is stored as a value type that does not match the expected type.",
  /** The value of this property must be of type <code>`{{validType}}`</code> according to the schema. */
  "inputs.invalid-value.details.description": "The value of this property must be of type <code>{{validType}}</code> according to the schema.",
  /** Only the following types are valid here according to schema: */
  "inputs.invalid-value.details.multi-type-description": "Only the following types are valid here according to schema:",
  /** Mismatching value types typically occur when the schema has recently been changed. */
  "inputs.invalid-value.details.possible-reason": "Mismatching value types typically occur when the schema has recently been changed.",
  /** Developer info */
  "inputs.invalid-value.details.title": "Developer info",
  /** -- Invalid Value Input -- */
  /** Reset value */
  "inputs.invalid-value.reset-button.text": "Reset value",
  /** Invalid property value */
  "inputs.invalid-value.title": "Invalid property value",
  /** Field groups */
  "inputs.object.field-group-tabs.aria-label": "Field groups",
  /** Read-only field description */
  "inputs.object.unknown-fields.read-only.description": "This field is <strong>read only</strong> according to the document\u2019s schema and cannot be unset. If you want to be able to unset this in Studio, make sure you remove the <code>readOnly</code> field from the enclosing type in the schema.",
  /** Remove field */
  "inputs.object.unknown-fields.remove-field-button.text": "Remove field",
  /** Encountered `{{count}}` fields that are not defined in the schema. */
  "inputs.object.unknown-fields.warning.description_one": "Encountered a field that is not defined in the schema.",
  "inputs.object.unknown-fields.warning.description_other": "Encountered {{count}} fields that are not defined in the schema.",
  /** Detailed description of unknown field warning */
  "inputs.object.unknown-fields.warning.details.description_one": "This field is not defined in the schema, which could mean that the field definition has been removed or that someone else has added it to their own local project and have not deployed their changes yet.",
  "inputs.object.unknown-fields.warning.details.description_other": "These fields are not defined in the document\u2019s schema, which could mean that the field definitions have been removed or that someone else has added them to their own local project and have not deployed their changes yet.",
  /** Developer info */
  "inputs.object.unknown-fields.warning.details.title": "Developer info",
  /** Unknown field found */
  "inputs.object.unknown-fields.warning.title_one": "Unknown field found",
  "inputs.object.unknown-fields.warning.title_other": "Unknown fields found",
  /** Collapse the editor to save screen space  */
  "inputs.portable-text.action.collapse-editor": "Collapse editor",
  /** Aria label for action to edit an existing annotation */
  "inputs.portable-text.action.edit-annotation-aria-label": "Edit annotation",
  /** Expand the editor to give more editing space */
  "inputs.portable-text.action.expand-editor": "Expand editor",
  /** Label label for action to insert a block of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-block": "Insert {{typeName}}",
  /** Accessibility label for action to insert a block of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-block-aria-label": "Insert {{typeName}} (block)",
  /** Label for action to insert an inline object of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-inline-object": "Insert {{typeName}}",
  /** Accessibility label for action to insert an inline object of a given type (`{{typeName}}`) */
  "inputs.portable-text.action.insert-inline-object-aria-label": "Insert {{typeName}} (inline)",
  /** Aria label for action to remove an annotation */
  "inputs.portable-text.action.remove-annotation-aria-label": "Remove annotation",
  /** Label for activate on focus with context of click and not focused */
  "inputs.portable-text.activate-on-focus-message_click": "Click to activate",
  /** Label for activate on focus with context of click and focused */
  "inputs.portable-text.activate-on-focus-message_click-focused": "Click or press space to activate",
  /** Label for activate on focus with context of tap and not focused */
  "inputs.portable-text.activate-on-focus-message_tap": "Tap to activate",
  /**Aria label for the annotation object */
  "inputs.portable-text.annotation-aria-label": "Annotation object",
  /** Title for dialog that allows editing an annotation */
  "inputs.portable-text.annotation-editor.title": "Edit {{schemaType}}",
  /** Title of the default "link" annotation */
  "inputs.portable-text.annotation.link": "Link",
  /**Aria label for the block object */
  "inputs.portable-text.block.aria-label": "Block object",
  /** Label for action to edit a block item, in the case where it is editable */
  "inputs.portable-text.block.edit": "Edit",
  /** Accessibility label for the button that opens the actions menu on blocks */
  "inputs.portable-text.block.open-menu-aria-label": "Open menu",
  /** Label for action to open a reference, in the case of block-level reference types */
  "inputs.portable-text.block.open-reference": "Open reference",
  /** Label for action to remove a block item */
  "inputs.portable-text.block.remove": "Remove",
  /** Label for action to view a block item, in the case where it is read-only and thus cannot be edited */
  "inputs.portable-text.block.view": "View",
  /** Title of the "code" decorator */
  "inputs.portable-text.decorator.code": "Code",
  /** Title of the "em" (emphasis) decorator */
  "inputs.portable-text.decorator.emphasis": "Italic",
  /** Title of the "strike-through" decorator */
  "inputs.portable-text.decorator.strike-through": "Strike",
  /** Title of the "strong" decorator */
  "inputs.portable-text.decorator.strong": "Strong",
  /** Title of the "underline" decorator */
  "inputs.portable-text.decorator.underline": "Underline",
  /** Placeholder text for when the editor is empty */
  "inputs.portable-text.empty-placeholder": "Empty",
  /**Aria label for the block object */
  "inputs.portable-text.inline-block.aria-label": "Inline object",
  /** Label for action to edit an inline object item */
  "inputs.portable-text.inline-object.edit": "Edit object",
  /** Aria label for icon for action to edit an inline object item */
  "inputs.portable-text.inline-object.edit-aria-label": "Edit object",
  /** Label for action to remove an inline object item */
  "inputs.portable-text.inline-object.remove": "Remove object",
  /** Aria label for icon for action to remove an inline object item */
  "inputs.portable-text.inline-object.remove-aria-label": "Remove object",
  /** Disclaimer text shown on invalid Portable Text value, when an action is available to unblock the user, but it is not guaranteed to be safe */
  "inputs.portable-text.invalid-value.action-disclaimer": "NOTE: It\u2019s generally safe to perform the action above, but if you are in doubt, get in touch with those responsible for configuring your studio.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` of type `{{childType}}` which is not allowed by the schema definition */
  "inputs.portable-text.invalid-value.disallowed-child-type.action": "Remove the object",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` of type `{{childType}}` which is not allowed by the schema definition */
  "inputs.portable-text.invalid-value.disallowed-child-type.description": "Child with key {{childKey}} of block with key <code>{{key}}</code> is of type <code>{{childType}}</code>, which is not allowed by the schema.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a type (`{{typeName}}`) that is not an allowed block type for this field */
  "inputs.portable-text.invalid-value.disallowed-type.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a type (`{{typeName}}`) that is not an allowed block type for this field */
  "inputs.portable-text.invalid-value.disallowed-type.description": "Block with key <code>{{key}}</code> is of type <code>{{typeName}}</code>, which is not allowed by the schema.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains no children */
  "inputs.portable-text.invalid-value.empty-children.action": "Insert empty text span",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains no children */
  "inputs.portable-text.invalid-value.empty-children.description": "Text block with key <code>{{key}}</code> has no text spans.",
  /** Label for the button to ignore invalid values in the Portable Text editor */
  "inputs.portable-text.invalid-value.ignore-button.text": "Ignore",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a `_type` property that is set to `block`, but the block type defined in schema has a different name (`{{expectedTypeName}}`) */
  "inputs.portable-text.invalid-value.incorrect-block-type.action": "Use type <code>{{expectedTypeName}}</code>",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a `_type` property that is set to `block`, but the block type defined in schema has a different name (`{{expectedTypeName}}`) */
  "inputs.portable-text.invalid-value.incorrect-block-type.description": "Block with key <code>{{key}}</code> has an invalid type name. According to the schema, it should be <code>{{expectedTypeName}}</code>.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a span with key `{{childKey}}` that has a missing or invalid `text` property */
  "inputs.portable-text.invalid-value.invalid-span-text.action": "Set empty text value",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a span with key `{{childKey}}` that has a missing or invalid `text` property */
  "inputs.portable-text.invalid-value.invalid-span-text.description": "Span with key {{childKey}} of block with key <code>{{key}}</code> has a missing or invalid <code>text</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property, but seems to be a block of type `{{expectedTypeName}}` */
  "inputs.portable-text.invalid-value.missing-block-type.action": "Use type <code>{{expectedTypeName}}</code>",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property, but seems to be a block of type `{{expectedTypeName}}` */
  "inputs.portable-text.invalid-value.missing-block-type.description": "Block with key <code>{{key}}</code> is missing a type name. According to the schema, it should be <code>{{expectedTypeName}}</code>.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child at `{{index}}` which is missing `_key` property */
  "inputs.portable-text.invalid-value.missing-child-key.action": "Assign random key",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child at `{{index}}` which is missing `_key` property */
  "inputs.portable-text.invalid-value.missing-child-key.description": "Child at index <code>{{index}}</code> of block with key <code>{{key}}</code> is missing <code>_key</code> property.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` which is missing a `_type` property */
  "inputs.portable-text.invalid-value.missing-child-type.action": "Remove the object",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` has a child with key `{{childKey}}` which is missing a `_type` property */
  "inputs.portable-text.invalid-value.missing-child-type.description": "Child with key {{childKey}} of block with key <code>{{key}}</code> is missing <code>_type</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child at `{{index}}` is missing the required `_key` property */
  "inputs.portable-text.invalid-value.missing-key.action": "Assign random key",
  /** Text explaining that the Portable Text field value is invalid, when child at `{{index}}` is missing the required `_key` property */
  "inputs.portable-text.invalid-value.missing-key.description": "Block at index <code>{{index}}</code> is missing required <code>_key</code> property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `children` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-children.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `children` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-children.description": "Text block with key <code>{{key}}</code> has an invalid or missing `children` property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `markDefs` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.action": "Add property",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` has a missing or invalid `markDefs` property */
  "inputs.portable-text.invalid-value.missing-or-invalid-markdefs.description": "Text block with key <code>{{key}}</code> has an invalid or missing `markDefs` property.",
  /** Action presented when the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property  */
  "inputs.portable-text.invalid-value.missing-type.action": "Remove the block",
  /** Text explaining that the Portable Text field value is invalid, when child with key `{{key}}` is missing a `_type` property  */
  "inputs.portable-text.invalid-value.missing-type.description": "Block with key <code>{{key}}</code> is missing a type name.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains a non-object child at index `{{index}}` */
  "inputs.portable-text.invalid-value.non-object-child.action": "Remove the item",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains a non-object child at index `{{index}}` */
  "inputs.portable-text.invalid-value.non-object-child.description": "Child at index <code>{{index}}</code> of block with key <code>{{key}}</code> is not an object.",
  /** Action presented when the Portable Text field value is invalid, when the Portable Text field is not an array, or the array is empty */
  "inputs.portable-text.invalid-value.not-an-array.action": "Unset the value",
  /** Text explaining that the Portable Text field value is invalid, when the Portable Text field is not an array, or the array is empty */
  "inputs.portable-text.invalid-value.not-an-array.description": "Value must be an array of Portable Text blocks, or undefined.",
  /** Action presented when the Portable Text field value is invalid, when child at `{{index}}` is not an object */
  "inputs.portable-text.invalid-value.not-an-object.action": "Remove item",
  /** Text explaining that the Portable Text field value is invalid, when child at `{{index}}` is not an object */
  "inputs.portable-text.invalid-value.not-an-object.description": "Item at <code>{{index}}</code> is not an object,.",
  /** Action presented when the Portable Text field value is invalid, when block with key `{{key}}` contains marks (`{{orphanedMarks}}`) that are not supported by the current schema */
  "inputs.portable-text.invalid-value.orphaned-marks.action": "Remove disallowed marks",
  /** Text explaining that the Portable Text field value is invalid, when block with key `{{key}}` contains marks (`{{orphanedMarks}}`) that are not supported by the current schema */
  "inputs.portable-text.invalid-value.orphaned-marks.description": "Text block with key <code>{{key}}</code> contains marks <code>({{orphanedMarks, list}})</code> that are not allowed by the schema.",
  /** Title for the alert indicating that the Portable Text field has an invalid value */
  "inputs.portable-text.invalid-value.title": "Invalid Portable Text value",
  /** Title of "bulleted" list type */
  "inputs.portable-text.list-type.bullet": "Bulleted list",
  /** Title of numbered list type */
  "inputs.portable-text.list-type.number": "Numbered list",
  /** Title of the "h1" block style */
  "inputs.portable-text.style.h1": "Heading 1",
  /** Title of the "h2" block style */
  "inputs.portable-text.style.h2": "Heading 2",
  /** Title of the "h3" block style */
  "inputs.portable-text.style.h3": "Heading 3",
  /** Title of the "h4" block style */
  "inputs.portable-text.style.h4": "Heading 4",
  /** Title of the "h5" block style */
  "inputs.portable-text.style.h5": "Heading 5",
  /** Title of the "h6" block style */
  "inputs.portable-text.style.h6": "Heading 6",
  /** Title shown when multiple blocks of varying styles is selected */
  "inputs.portable-text.style.multiple": "Multiple",
  /** Title of fallback when no style is given for a block */
  "inputs.portable-text.style.none": "No style",
  /** Title of the "normal" block style */
  "inputs.portable-text.style.normal": "Normal",
  /** Title of the "quote" block style */
  "inputs.portable-text.style.quote": "Quote",
  /** Label for action to clear the current value of the reference field */
  "inputs.reference.action.clear": "Clear",
  /** Label for action to create a new document from the reference input */
  "inputs.reference.action.create-new-document": "Create",
  /** Label for action to create a new document from the reference input, when there are multiple templates or document types to choose from */
  "inputs.reference.action.create-new-document-select": "Create\u2026",
  /** Label for action to duplicate the current item to a new item (used within arrays) */
  "inputs.reference.action.duplicate": "Duplicate",
  /** Label for action that opens the referenced document in a new tab */
  "inputs.reference.action.open-in-new-tab": "Open in new tab",
  /** Label for action to remove the reference from an array */
  "inputs.reference.action.remove": "Remove",
  /** Label for action to replace the current value of the field */
  "inputs.reference.action.replace": "Replace",
  /** Label for action to cancel a previously initiated replace action  */
  "inputs.reference.action.replace-cancel": "Cancel replace",
  /** The cross-dataset reference field currently has a reference, but the feature has been disabled since it was created. This explains what can/cannot be done in its current state. */
  "inputs.reference.cross-dataset.feature-disabled-actions": "You can still clear this field's existing reference, but it cannot be changed to a different document as long as the feature is disabled.",
  /** A cross-dataset reference field exists but the feature has been disabled. A <DocumentationLink> component is available. */
  "inputs.reference.cross-dataset.feature-disabled-description": "This feature has been disabled. Read how to enable it in <DocumentationLink>the documentation</DocumentationLink>.",
  /** Title for a warning telling the user that the current project does not have the "cross dataset references" feature */
  "inputs.reference.cross-dataset.feature-unavailable-title": "Unavailable feature: Cross dataset reference",
  /** The cross-dataset reference points to a document with an invalid type  */
  "inputs.reference.cross-dataset.invalid-type": "The referenced document is of invalid type ({{typeName}}) <JsonValue/>",
  /** The referenced document will open in a new tab (due to external studio) */
  "inputs.reference.document-opens-in-new-tab": "This document opens in a new tab",
  /** Error title for when the document is unavailable (for any possible reason) */
  "inputs.reference.error.document-unavailable-title": "Document unavailable",
  /** Error title for when the referenced document failed to be loaded */
  "inputs.reference.error.failed-to-load-document-title": "Failed to load referenced document",
  /** Error title for when the reference search returned a document that is not an allowed type for the field */
  "inputs.reference.error.invalid-search-result-type-title": `Search returned a type that's not valid for this reference: "{{returnedType}}"`,
  /** Error description for when the document referenced is not one of the types declared as allowed target types in schema */
  "inputs.reference.error.invalid-type-description": "Referenced document (<code>{{documentId}}</code>) is of type <code>{{actualType}}</code>. According to the schema, referenced documents can only be of type <AllowedTypes />.",
  /** Error title for when the document referenced is not one of the types declared as allowed target types in schema */
  "inputs.reference.error.invalid-type-title": "Document of invalid type",
  /** Error description for when the user does not have permissions to read the referenced document */
  "inputs.reference.error.missing-read-permissions-description": "The referenced document could not be accessed due to insufficient permissions",
  /** Error title for when the user does not have permissions to read the referenced document */
  "inputs.reference.error.missing-read-permissions-title": "Insufficient permissions",
  /** Error description for when the current reference value points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document-description": "The referenced document does not exist (ID: <code>{{documentId}}</code>). You can either remove the reference or replace it with another document.",
  /** Error title for when the current reference value points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document-title": "Not found",
  /** Label for button that clears the reference when it points to a document that does not exist (on weak references) */
  "inputs.reference.error.nonexistent-document.clear-button-label": "Clear",
  /** Error title for when the search for a reference failed. Note that the message sent by the backend may not be localized. */
  "inputs.reference.error.search-failed-title": "Reference search failed",
  /** Alternative text for the image shown in cross-dataset reference input */
  "inputs.reference.image-preview-alt-text": "Image preview of referenced document",
  /** Description for alert shown when a reference in a live-edit document is marked as being weak, the referenced document exists, AND the reference is supposed to be have been strengthened on publish */
  "inputs.reference.incomplete-reference.finalize-action-description": "<strong>{{referencedDocument}}</strong> is published and this reference should now be finalized.",
  /** Title for alert shown when a reference in a live-edit document is marked as being weak, the referenced document exists, AND the reference is supposed to be have been strengthened on publish */
  "inputs.reference.incomplete-reference.finalize-action-title": "Finalize reference",
  /** Description for alert shown when a reference in a live-edit document points to a document that exists and has been published, but the reference is still marked as weak */
  "inputs.reference.incomplete-reference.strengthen-action-description": "<strong>{{referencedDocument}}</strong> is published and this reference should now be converted to a strong reference.",
  /** Title for alert shown when a reference in a live-edit document points to a document that exists and has been published, but the reference is still marked as weak */
  "inputs.reference.incomplete-reference.strengthen-action-title": "Convert to strong reference",
  /** Label for button that triggers the action that strengthen a reference */
  "inputs.reference.incomplete-reference.strengthen-button-label": "Convert to strong reference",
  /** Label for button that triggers a retry attempt for reference metadata  */
  "inputs.reference.metadata-error.retry-button-label": "Retry",
  /** Title for alert shown when reference metadata fails to be loaded */
  "inputs.reference.metadata-error.title": "Unable to load reference metadata",
  /** Message shown when no documents were found that matched the given search string */
  "inputs.reference.no-results-for-query": "No results for <strong>\u201C{{searchTerm}}\u201D</strong>",
  /** Text for tooltip showing when a document was edited, using relative time (eg "how long ago was it edited?") */
  "inputs.reference.preview.edited-at-time": "Edited <RelativeTime/>",
  /** Accessibility label for icon indicating that document does _not_ have any unpublished changes */
  "inputs.reference.preview.has-no-unpublished-changes-aria-label": "No unpublished edits",
  /** Accessibility label for icon indicating that document has unpublished changes */
  "inputs.reference.preview.has-unpublished-changes-aria-label": "Edited",
  /** Accessibility label for icon indicating that document does _not_ have a published version */
  "inputs.reference.preview.is-not-published-aria-label": "Not published",
  /** Accessibility label for icon indicating that document has a published version */
  "inputs.reference.preview.is-published-aria-label": "Published",
  /** Text for tooltip indicating that a document has no unpublished edits */
  "inputs.reference.preview.no-unpublished-edits": "No unpublished edits",
  /** Text for tooltip indicating that a document has not yet been published */
  "inputs.reference.preview.not-published": "Not published",
  /** Text for tooltip showing when a document was published, using relative time (eg "how long ago was it published?") */
  "inputs.reference.preview.published-at-time": "Published <RelativeTime/>",
  /** The referenced document no longer exist and might have been deleted (for weak references) */
  "inputs.reference.referenced-document-does-not-exist": "The referenced document no longer exist and might have been deleted (document ID: <code>{{documentId}}</code>).",
  /** The referenced document could not be displayed to the user because of insufficient permissions */
  "inputs.reference.referenced-document-insufficient-permissions": "The referenced document could not be accessed due to insufficient permissions",
  /** Label for when the reference input is resolving the initial value for an item */
  "inputs.reference.resolving-initial-value": "Resolving initial value\u2026",
  /** Placeholder shown in a reference input with no current value */
  "inputs.reference.search-placeholder": "Type to search",
  /** Explanation of the consequences of leaving the reference as strong instead of weak */
  "inputs.reference.strength-mismatch.is-strong-consquences": "It will not be possible to delete the reference document without first removing this reference or converting it to weak.",
  /** Description for alert shown when a reference is supposed to be weak, but the actual value is strong */
  "inputs.reference.strength-mismatch.is-strong-description": "This reference is <em>strong</em>, but according to the current schema it should be <em>weak</em>.",
  /** Explanation of the consequences of leaving the reference as weak instead of strong */
  "inputs.reference.strength-mismatch.is-weak-consquences": "This makes it possible to delete the referenced document without first deleting this reference, leaving this field referencing a nonexisting document.",
  /** Description for alert shown when a reference is supposed to be strong, but the actual value is weak */
  "inputs.reference.strength-mismatch.is-weak-description": "This reference is <em>weak</em>, but according to the current schema it should be <em>strong</em>.",
  /** Label for button that triggers the action that strengthens a reference on strength mismatch */
  "inputs.reference.strength-mismatch.strengthen-button-label": "Convert to strong reference",
  /** Title for alert shown when a reference is supposed to be weak/strong, but the actual value is the opposite of what it is supposed to be */
  "inputs.reference.strength-mismatch.title": "Reference strength mismatch",
  /** Label for button that triggers the action that weakens a reference on strength mismatch */
  "inputs.reference.strength-mismatch.weaken-button-label": "Convert to weak reference",
  /** Action message for generating the slug */
  "inputs.slug.action.generate": "Generate",
  /** Loading message for when the input is actively generating a slug */
  "inputs.slug.action.generating": "Generating\u2026",
  /** Error message for when the source to generate a slug from is missing */
  "inputs.slug.error.missing-source": "Source is missing. Check source on type {{schemaType}} in schema",
  /** Placeholder for an empty tag input */
  "inputs.tags.placeholder": "Enter tag and press ENTER\u2026",
  /** Placeholder for an empty tag input on touch devices */
  "inputs.tags.placeholder_touch": "Enter tag\u2026",
  /** Convert to `{{targetType}}` */
  "inputs.untyped-value.convert-button.text": "Convert to {{targetType}}",
  /** Encountered an object value without a <code>_type</code> property. */
  "inputs.untyped-value.description": "Encountered an object value without a <code>_type</code> property.",
  /** Either remove the <code>name</code> property of the object declaration, or set <code>_type</code> property on items. */
  "inputs.untyped-value.details.description": "Either remove the <code>name</code> property of the object declaration, or set <code>_type</code> property on items.",
  /** Current value (<code>object</code>): */
  "inputs.untyped-value.details.json-dump-prefix": "Current value (<code>object</code>):",
  /** The following types are valid here according to schema: */
  "inputs.untyped-value.details.multi-type-description": "The following types are valid here according to schema:",
  /** Developer info */
  "inputs.untyped-value.details.title": "Developer info",
  /** Property value missing <code>_type</code> */
  "inputs.untyped-value.title": "Property value missing <code>_type</code>",
  /** Unset value */
  "inputs.untyped-value.unset-item-button.text": "Unset value",
  /** The fallback explanation if no context is provided */
  "insufficient-permissions-message.not-authorized-explanation": "You do not have permission to access this feature.",
  /** The explanation when unable to create any document at all */
  "insufficient-permissions-message.not-authorized-explanation_create-any-document": "You do not have permission to create a document.",
  /** The explanation when unable to create a particular document */
  "insufficient-permissions-message.not-authorized-explanation_create-document": "You do not have permission to create this document.",
  /** The explanation when unable to create a particular type of document */
  "insufficient-permissions-message.not-authorized-explanation_create-document-type": "You do not have permission to create this kind of document.",
  /** The explanation when unable to create a new reference in a document */
  "insufficient-permissions-message.not-authorized-explanation_create-new-reference": "You do not have permission to create a new reference.",
  /** The explanation when unable to delete a particular document */
  "insufficient-permissions-message.not-authorized-explanation_delete-document": "You do not have permission to delete this document.",
  /** The explanation when unable to delete a schedule on scheduled publishing */
  "insufficient-permissions-message.not-authorized-explanation_delete-schedules": "You do not have permission to delete schedules.",
  /** The explanation when unable to discard changes in a particular document */
  "insufficient-permissions-message.not-authorized-explanation_discard-changes": "You do not have permission to discard changes in this document.",
  /** The explanation when unable to duplicate a particular document */
  "insufficient-permissions-message.not-authorized-explanation_duplicate-document": "You do not have permission to duplicate this document.",
  /** The explanation when unable to edit a schedule on scheduled publishing */
  "insufficient-permissions-message.not-authorized-explanation_edit-schedules": "You do not have permission to edit schedules.",
  /** The explanation when unable to execute a schedule on scheduled publishing */
  "insufficient-permissions-message.not-authorized-explanation_execute-schedules": "You do not have permission to execute schedules.",
  /** The explanation when unable to publish a particular document */
  "insufficient-permissions-message.not-authorized-explanation_publish-document": "You do not have permission to publish this document.",
  /** The explanation when unable to unpublish a particular document */
  "insufficient-permissions-message.not-authorized-explanation_unpublish-document": "You do not have permission to unpublish this document.",
  /** Appears after the not-authorized message. Lists the current roles. */
  "insufficient-permissions-message.roles": "Your roles: <Roles/>",
  /** The title for the insufficient permissions message component */
  "insufficient-permissions-message.title": "Insufficient permissions",
  /** Unexpected error: `{{error}}` */
  "member-field-error.unexpected-error": "Unexpected error: {{error}}",
  /** Button label for "Create new document" button */
  "new-document.button": "Create",
  /**
   * Tooltip message displayed when hovering/activating the "Create new document" action,
   * when there are templates/types available for creation
   */
  "new-document.create-new-document-label": "New document\u2026",
  /** Placeholder for the "filter" input within the new document menu */
  "new-document.filter-placeholder": "Search document types",
  /** Loading indicator text within the new document menu */
  "new-document.loading": "Loading\u2026",
  /** Accessibility label for the list displaying options in the new document menu */
  "new-document.new-document-aria-label": "New document",
  /** Message for when there are no document type options in the new document menu */
  "new-document.no-document-types-found": "No document types found",
  /**
   * Tooltip message displayed when hovering/activating the "Create new document" action,
   * when there are no templates/types to create from
   */
  "new-document.no-document-types-label": "No document types",
  /** Message for when no results are found for a specific search query in the new document menu */
  "new-document.no-results": "No results for <strong>{{searchQuery}}</strong>",
  /** Aria label for the button that opens the "Create new document" popover/dialog */
  "new-document.open-dialog-aria-label": "Create new document",
  /** Title for "Create new document" dialog */
  "new-document.title": "Create new document",
  /** Label for action to manage members of the current studio project */
  "presence.action.manage-members": "Manage members",
  /** Accessibility label for presence menu button */
  "presence.aria-label": "Global presence",
  /** Message description for when no one else is currently present */
  "presence.no-one-else-description": "Invite people to the project to see their online status.",
  /** Message title for when no one else is currently present */
  "presence.no-one-else-title": "No one else is here",
  /** Message for when a user is not in a document (displayed in the global presence menu) */
  "presence.not-in-a-document": "Not in a document",
  /** Tooltip content text for presence menu button */
  "presence.tooltip-content": "Who is here",
  /** Fallback title shown when a preview does not provide a title */
  "preview.default.title-fallback": "Untitled",
  /** Fallback preview value for types that have "no value" (eg null, undefined) */
  "preview.fallback.no-value": "(no value)",
  /** Alternative text for image being shown while image is being uploaded, in previews */
  "preview.image.file-is-being-uploaded.alt-text": "The image currently being uploaded",
  /* Relative time, just now */
  "relative-time.just-now": "just now",
  /** Accessibility label to open search action when the search would go fullscreen (eg on narrower screens) */
  "search.action-open-aria-label": "Open search",
  /** Action label for adding a search filter */
  "search.action.add-filter": "Add filter",
  /** Action label for clearing search filters */
  "search.action.clear-filters": "Clear filters",
  /** Label for action to clear recent searches */
  "search.action.clear-recent-searches": "Clear recent searches",
  /** Accessibility label for action to clear all currently applied document type filters */
  "search.action.clear-type-filters-aria-label": "Clear checked filters",
  /** Label for action to clear all currently applied document type filters */
  "search.action.clear-type-filters-label": "Clear",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to close the search */
  "search.action.close-search-aria-label": "Close search",
  /** Accessibility label for filtering by document type */
  "search.action.filter-by-document-type-aria-label": "Filter by document type",
  /** Accessibility action label for removing an already applied search filter */
  "search.action.remove-filter-aria-label": "Remove filter",
  /**
   * Text displayed when either no document type(s) have been selected, or we need a fallback,
   * eg "Search for all types".
   */
  "search.action.search-all-types": "Search all documents",
  /**
   * Text displayed when we are able to determine one or more document types that will be used for
   * searching, and can fit within the space assigned by the design.
   */
  "search.action.search-specific-types": "Search for {{types, list}}",
  /**
   * Text displayed when we are able to determine one or more document types that will be used for
   * searching, but cannot list them all within the space assigned by the design, so we need an
   * additional "and X more" suffix. Allows using pluralization suffixes, eg `_one`, `_other` etc.
   */
  "search.action.search-specific-types-truncated": "Search for {{types, list}} +{{count}} more",
  /** Dialog title for action to select an asset of unknown type */
  "search.action.select-asset": "Select asset",
  /** Dialog title for action to select a file asset */
  "search.action.select-asset_file": "Select file",
  /** Dialog title for action to select an image asset */
  "search.action.select-asset_image": "Select image",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to hide filters */
  "search.action.toggle-filters-aria-label_hide": "Hide filters",
  /** Accessibility label for when the search is full screen (on narrow screens) and you want to show filters */
  "search.action.toggle-filters-aria-label_show": "Show filters",
  /** Label for when the search is full screen (on narrow screens) and you want to hide filters */
  "search.action.toggle-filters-label_hide": "Hide filters",
  /** Label for when the search is full screen (on narrow screens) and you want to show filters */
  "search.action.toggle-filters-label_show": "Show filters",
  /** Tooltip text for the global search button */
  "search.button.tooltip": "Search",
  /**
   * A list of provided types (use `list` formatter preferably).
   */
  "search.document-type-list": "{{types, list}}",
  /**
   * In the context of a list of document types - no filtering selection has been done,
   * thus the default is "all types".
   */
  "search.document-type-list-all-types": "All types",
  /**
   * A list of provided types that has been truncated - more types are included but not displayed,
   * thus we need to indicate that there are more. Allows using pluralization suffixes,
   * eg `_one`, `_other` etc.
   */
  "search.document-type-list-truncated": "{{types, list}} +{{count}} more",
  /** Accessibility label for list displaying the available document types */
  "search.document-types-aria-label": "Document types",
  /** Label for when no document types matching the filter are found */
  "search.document-types-no-matches-found": "No matches for {{filter}}",
  /** Description for error when a filter cannot be displayed, describes that you should check the schema */
  "search.error.display-filter-description": "This may indicate invalid options defined in your schema.",
  /** Title for error when a filter cannot be displayed (mainly a developer-oriented error) */
  "search.error.display-filter-title": "An error occurred whilst displaying this filter.",
  /** Description for error when no valid asset source is found, describes that you should check the the current studio config */
  "search.error.no-valid-asset-source-check-config-description": "Please ensure it's enabled in your studio configuration file.",
  /** Description for error when no valid asset source is found, describes that only the default asset is supported */
  "search.error.no-valid-asset-source-only-default-description": "Currently, only the default asset source is supported.",
  /** Title for error when no valid asset sources found */
  "search.error.no-valid-asset-source-title": "No valid asset sources found.",
  /** Helpful description for when search returned an error that we are not able to describe in detail */
  "search.error.unspecified-error-help-description": "Please try again or check your connection",
  /** Title label for when search returned an error that we are not able to describe in detail */
  "search.error.unspecified-error-title": "Something went wrong while searching",
  /**
   * Label for "All fields", a label that appears above the list of available fields when filtering.
   * If one or more document type has been chosen as filter, this label is replaced with a group of
   * fields per selected document type
   */
  "search.filter-all-fields-header": "All fields",
  /** Label for the action of changing from one file to a different file in asset search filter */
  "search.filter-asset-change_file": "Change file",
  /** Label for the action of changing from one image to a different image in asset search filter */
  "search.filter-asset-change_image": "Change image",
  /** Label for the action of clearing the currently selected asset in an image/file filter */
  "search.filter-asset-clear": "Clear",
  /** Label for the action of selecting a file in asset search filter */
  "search.filter-asset-select_file": "Select file",
  /** Label for the action of selecting an image in asset search filter */
  "search.filter-asset-select_image": "Select image",
  /** Label for boolean filter - false */
  "search.filter-boolean-false": "False",
  /** Label for boolean filter - true */
  "search.filter-boolean-true": "True",
  /** Accessibility label for list that lets you filter fields by title, when adding a new filter in search */
  "search.filter-by-title-aria-label": "Filter by title",
  /** Accessibility label for date filter input */
  "search.filter-date-aria-label": "Date",
  /** Accessibility label for selecting end date on the date range search filter */
  "search.filter-date-range-end-date-aria-label": "End date",
  /** Accessibility label for selecting start date on the date range search filter */
  "search.filter-date-range-start-date-aria-label": "Start date",
  /** Accessibility label for selecting the unit (day/month/year) when adding "X days ago" search filter */
  "search.filter-date-unit-aria-label": "Select unit",
  /**
   * Label for "Days"/"Months"/"Years" when selecting it as unit in "X days ago" search filter.
   * Capitalized, as it would be listed in a dropdown.
   */
  "search.filter-date-unit_days": "Days",
  "search.filter-date-unit_months": "Months",
  "search.filter-date-unit_years": "Years",
  /** Accessibility label for the input value (days/months/years) when adding "X days ago" search filter */
  "search.filter-date-value-aria-label": "Unit value",
  /** Label for "field description" shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-description": "Field description",
  /** Label for "field name" shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-name": "Field name",
  /** Label for "Used in document types", a list of the document types a field appears in. Shown in tooltip when navigating list of possible fields to filter */
  "search.filter-field-tooltip-used-in-document-types": "Used in document types",
  /** Label for when no fields/filters are found for the given term */
  "search.filter-no-matches-found": "No matches for {{filter}}",
  /** Placeholder value for maximum numeric value filter */
  "search.filter-number-max-value-placeholder": "Max value",
  /** Placeholder value for minimum numeric value filter */
  "search.filter-number-min-value-placeholder": "Min value",
  /** Placeholder value for the number filter */
  "search.filter-number-value-placeholder": "Value",
  /** Placeholder for the "Filter" input, when narrowing possible fields/filters */
  "search.filter-placeholder": "Filter",
  /** Label for the action of clearing the currently selected document in a reference filter */
  "search.filter-reference-clear": "Clear",
  /**
   * Label for "shared fields", a label that appears above a list of fields that all filtered types
   * have in common, when adding a new filter. For instance, if "book" and "employee" both have a
   * "title" field, this field would be listed under "shared fields".
   * */
  "search.filter-shared-fields-header": "Shared fields",
  /** Placeholder value for the string filter */
  "search.filter-string-value-placeholder": "Value",
  /** Label/placeholder prompting user to select one of the predefined, allowed values for a string field */
  "search.filter-string-value-select-predefined-value": "Select\u2026",
  /** Accessibility label for the "Filters" list, that is shown when using "Add filter" in search (singular) */
  "search.filters-aria-label_one": "Filter",
  /** Accessibility label for the "Filters" list, that is shown when using "Add filter" in search (plural) */
  "search.filters-aria-label_other": "Filters",
  /** Label for instructions on how to use the search - displayed when no recent searches are available */
  "search.instructions": "Use <ControlsIcon/> to refine your search",
  /** Helpful description for when no search results are found */
  "search.no-results-help-description": "Try another keyword or adjust your filters",
  /** Title label for when no search results are found */
  "search.no-results-title": "No results found",
  /**
   * Individual search operators.
   *
   * The `name` variant is the form we use when the user is building a query, and selecting from a
   * list of available operators for a field. Keep in mind that since the user knows what the field
   * represents, we do not need to contextualize too much, and that the user may not be a developer
   * eg prefer "quantity is" over "array has length". Additionally, (if applicable in language) use
   * lowercased names.
   *
   * The `description` variant is the form shown once the filter has enough information to apply,
   * and is shown in the list of applied filters. It is passed components that _should_ be used to
   * compose the filter string, and to format them correctly:
   *
   * `<Field/>` - eg "Bird species", "Category", "Date of birth"
   * `<Operator>operator text</Operator>` - eg "has ≤", "includes", "is"
   * `<Value>{{value}}</Value>` - eg "Hawk", "Sparrow", "Eagle"
   *
   * Where applicable, a `count` is passed, allowing you to pluralize where needed, by using
   * suffixes such as `_zero`, `_one`, `_other` etc.
   *
   * Prefer (reasonable) brevity since many filters may be applied. For instance:
   * `<Field/> has ≤ <Value/>` may be better than
   * `<Field/> has less than or equal to <Value/>`
   **/
  /* Array should have a count the given filter value */
  "search.operator.array-count-equal.description_one": "<Field/> <Operator>has</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-equal.description_other": "<Field/> <Operator>has</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-equal.name": "quantity is",
  /* Array should have a count greater than given filter value */
  "search.operator.array-count-gt.description_one": "<Field/> <Operator>has ></Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-gt.description_other": "<Field/> <Operator>has ></Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-gt.name": "quantity greater than",
  /* Array should have a count greater than or equal to the given filter value */
  "search.operator.array-count-gte.description_one": "<Field/> <Operator>has \u2265</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-gte.description_other": "<Field/> <Operator>has \u2265</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-gte.name": "quantity greater than or equal to",
  /* Array should have a count less than given filter value */
  "search.operator.array-count-lt.description_one": "<Field/> <Operator>has <</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-lt.description_other": "<Field/> <Operator>has <</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-lt.name": "quantity less than",
  /* Array should have a count less than or equal to the given filter value */
  "search.operator.array-count-lte.description_one": "<Field/> <Operator>has \u2264</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-lte.description_other": "<Field/> <Operator>has \u2264</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-lte.name": "quantity less than or equal to",
  /* Array should have a count that is not equal to the given filter value */
  "search.operator.array-count-not-equal.description_one": "<Field/> <Operator>does not have</Operator> <Value>{{count}} item</Value>",
  "search.operator.array-count-not-equal.description_other": "<Field/> <Operator>does not have</Operator> <Value>{{count}} items</Value>",
  "search.operator.array-count-not-equal.name": "quantity is not",
  /**
   * Array should have a count within the range of given filter values.
   * Gets passed `{{from}}` and `{{to}}` values.
   **/
  "search.operator.array-count-range.description": "<Field/> <Operator>has between</Operator> <Value>{{from}} \u2192 {{to}} items</Value>",
  "search.operator.array-count-range.name": "quantity is between",
  /* Array should include the given value */
  "search.operator.array-list-includes.description": "<Field/> <Operator>includes</Operator> <Value>{{value}}</Value>",
  "search.operator.array-list-includes.name": "includes",
  /* Array should not include the given value */
  "search.operator.array-list-not-includes.description": "<Field/> <Operator>does not include</Operator> <Value>{{value}}</Value>",
  "search.operator.array-list-not-includes.name": "does not include",
  /* Array should include the given reference */
  "search.operator.array-reference-includes.description": "<Field/> <Operator>includes</Operator> <Value>{{value}}</Value>",
  "search.operator.array-reference-includes.name": "includes",
  /* Array should not include the given reference */
  "search.operator.array-reference-not-includes.description": "<Field/> <Operator>does not include</Operator> <Value>{{value}}</Value>",
  "search.operator.array-reference-not-includes.name": "does not include",
  /* Asset (file) should be the selected asset */
  "search.operator.asset-file-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-file-equal.name": "is",
  /* Asset (file) should not be the selected asset */
  "search.operator.asset-file-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-file-not-equal.name": "is not",
  /* Asset (image) should be the selected asset */
  "search.operator.asset-image-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-image-equal.name": "is",
  /* Asset (image) should not be the selected asset */
  "search.operator.asset-image-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.asset-image-not-equal.name": "is not",
  /**
   * Boolean value should be the given filter value (true/false).
   * Context passed is `true` and `false`, allowing for more specific translations:
   * - `search.operator.boolean-equal.description_true`
   * - `search.operator.boolean-equal.description_false`
   */
  "search.operator.boolean-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.boolean-equal.name": "is",
  /* Date should be after (later than) given filter value */
  "search.operator.date-after.description": "<Field/> <Operator>is after</Operator> <Value>{{value}}</Value>",
  "search.operator.date-after.name": "after",
  /* Date should be before (earlier than) given filter value */
  "search.operator.date-before.description": "<Field/> <Operator>is before</Operator> <Value>{{value}}</Value>",
  "search.operator.date-before.name": "before",
  /* Date should be the given filter value */
  "search.operator.date-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.date-equal.name": "is",
  /* Date should be within the given filter value range (eg "within the last X days") */
  "search.operator.date-last.description": "<Field/> <Operator>is in the last</Operator> <Value>{{value}}</Value>",
  "search.operator.date-last.name": "last",
  /* Date should not be the given filter value */
  "search.operator.date-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.date-not-equal.name": "is not",
  /* Date should be within the range of given filter values */
  "search.operator.date-range.description": "<Field/> <Operator>is between</Operator> <Value/>",
  "search.operator.date-range.name": "is between",
  /* Date and time should be after (later than) given filter value */
  "search.operator.date-time-after.description": "<Field/> <Operator>is after</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-after.name": "after",
  /* Date and time should be before (earlier than) given filter value */
  "search.operator.date-time-before.description": "<Field/> <Operator>is before</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-before.name": "before",
  /* Date and time should be the given filter value */
  "search.operator.date-time-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-equal.name": "is",
  /* Date and time should be within the given filter value range (eg "within the last X days") */
  "search.operator.date-time-last.description": "<Field/> <Operator>is in the last</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-last.name": "last",
  /* Date and time should not be the given filter value */
  "search.operator.date-time-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.date-time-not-equal.name": "is not",
  /* Date and time should be within the range of given filter values */
  "search.operator.date-time-range.description": "<Field/> <Operator>is between</Operator> <Value/>",
  "search.operator.date-time-range.name": "is between",
  /* Value should be defined */
  "search.operator.defined.description": "<Field/> <Operator>is</Operator> <Value>not empty</Value>",
  "search.operator.defined.name": "not empty",
  /* Value should not be defined */
  "search.operator.not-defined.description": "<Field/> <Operator>is</Operator> <Value>empty</Value>",
  "search.operator.not-defined.name": "empty",
  /* Number should be the given filter value */
  "search.operator.number-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.number-equal.name": "is",
  /* Number should be greater than given filter value */
  "search.operator.number-gt.description": "<Field/> <Operator>></Operator> <Value>{{value}}</Value>",
  "search.operator.number-gt.name": "greater than",
  /* Number should be greater than or the given filter value */
  "search.operator.number-gte.description": "<Field/> <Operator>\u2265</Operator> <Value>{{value}}</Value>",
  "search.operator.number-gte.name": "greater than or equal to",
  /* Number should be less than given filter value */
  "search.operator.number-lt.description": "<Field/> <Operator><</Operator> <Value>{{value}}</Value>",
  "search.operator.number-lt.name": "less than",
  /* Number should be less than or the given filter value */
  "search.operator.number-lte.description": "<Field/> <Operator>\u2264</Operator> <Value>{{value}}</Value>",
  "search.operator.number-lte.name": "less than or equal to",
  /* Number should not be the given filter value */
  "search.operator.number-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.number-not-equal.name": "is not",
  /* Number should be within the range of given filter values */
  "search.operator.number-range.description": "<Field/> <Operator>is between</Operator> <Value>{{from}} \u2192 {{to}}</Value>",
  "search.operator.number-range.name": "is between",
  /* Portable Text should contain the given filter value */
  "search.operator.portable-text-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-contains.name": "contains",
  /* Portable Text should be the given filter value */
  "search.operator.portable-text-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-equal.name": "is",
  /* Portable Text should not contain the given filter value */
  "search.operator.portable-text-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-not-contains.name": "does not contain",
  /* Portable Text should not be the given filter value */
  "search.operator.portable-text-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.portable-text-not-equal.name": "is not",
  /* References the given asset (file) */
  "search.operator.reference-asset-file.description": "<Field/> <Operator>\u2192</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-asset-file.name": "file",
  /* References the given asset (image) */
  "search.operator.reference-asset-image.description": "<Field/> <Operator>\u2192</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-asset-image.name": "image",
  /* References the given document */
  "search.operator.reference-document.description": "<Field/> <Operator>\u2192</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-document.name": "document",
  /* Reference should be the given document */
  "search.operator.reference-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-equal.name": "is",
  /* Reference should not be the given document */
  "search.operator.reference-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.reference-not-equal.name": "is not",
  /* Slug contains the given value */
  "search.operator.slug-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-contains.name": "contains",
  /* Slug equals the given filter value */
  "search.operator.slug-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-equal.name": "is",
  /* Slug does not contain the given value */
  "search.operator.slug-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-not-contains.name": "does not contain",
  /* Slug does not equal the given filter value */
  "search.operator.slug-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.slug-not-equal.name": "is not",
  /* String contains the given filter value */
  "search.operator.string-contains.description": "<Field/> <Operator>contains</Operator> <Value>{{value}}</Value>",
  "search.operator.string-contains.name": "contains",
  /* String equals the given filter value */
  "search.operator.string-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.string-equal.name": "is",
  /* String equals one of the predefined allowed values */
  "search.operator.string-list-equal.description": "<Field/> <Operator>is</Operator> <Value>{{value}}</Value>",
  "search.operator.string-list-equal.name": "is",
  /* String does not equal one of the predefined allowed values */
  "search.operator.string-list-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.string-list-not-equal.name": "is not",
  /* String does not contain the given filter value */
  "search.operator.string-not-contains.description": "<Field/> <Operator>does not contain</Operator> <Value>{{value}}</Value>",
  "search.operator.string-not-contains.name": "does not contain",
  /* String does not equal the given filter value */
  "search.operator.string-not-equal.description": "<Field/> <Operator>is not</Operator> <Value>{{value}}</Value>",
  "search.operator.string-not-equal.name": "is not",
  /** Label for the "Best match" search ordering type */
  "search.ordering.best-match-label": "Best match",
  /** Label for the "Created: Oldest first" search ordering type */
  "search.ordering.created-ascending-label": "Created: Oldest first",
  /** Label for the "Created: Newest first" search ordering type */
  "search.ordering.created-descending-label": "Created: Newest first",
  /** Label for the "Updated: Oldest first" search ordering type */
  "search.ordering.updated-ascending-label": "Updated: Oldest first",
  /** Label for the "Updated: Newest first" search ordering type */
  "search.ordering.updated-descending-label": "Updated: Newest first",
  /** Placeholder text for the global search input field */
  "search.placeholder": "Search",
  /** Accessibility label for the recent searches section, shown when no valid search terms has been given */
  "search.recent-searches-aria-label": "Recent searches",
  /** Label/heading shown for the recent searches section */
  "search.recent-searches-label": "Recent searches",
  /** Accessibility label for the search results section, shown when the user has typed valid terms */
  "search.search-results-aria-label": "Search results",
  /** Accessibility label for the navbar status button */
  "status-button.aria-label": "Configuration status",
  /** Description for error when the timeline for the given document can't be loaded */
  "timeline.error.load-document-changes-description": "Document history transactions have not been affected.",
  /** Title for error when the timeline for the given document can't be loaded */
  "timeline.error.load-document-changes-title": "An error occurred whilst retrieving document changes.",
  /** Error description for when the document doesn't have history */
  "timeline.error.no-document-history-description": "When changing the content of the document, the document versions will appear in this menu.",
  /** Error title for when the document doesn't have history */
  "timeline.error.no-document-history-title": "No document history",
  /** Error prompt when revision cannot be loaded */
  "timeline.error.unable-to-load-revision": "Unable to load revision",
  /** Label for when the timeline item is the latest in the history */
  "timeline.latest": "Latest",
  /** Label for latest version for timeline menu dropdown */
  "timeline.latest-version": "Latest version",
  /** The aria-label for the list of revisions in the timeline */
  "timeline.list.aria-label": "Document revisions",
  /** Label for loading history */
  "timeline.loading-history": "Loading history\u2026",
  /** Label shown in review changes timeline when a document has been created */
  "timeline.operation.created": "Created",
  /** Label shown in review changes timeline when a document was initially created */
  "timeline.operation.created-initial": "Created",
  /** Label shown in review changes timeline when a document was initially created, with a timestamp */
  "timeline.operation.created-initial_timestamp": "Created: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been created, with a timestamp */
  "timeline.operation.created_timestamp": "Created: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been deleted */
  "timeline.operation.deleted": "Deleted",
  /** Label shown in review changes timeline when a document has been deleted, with a timestamp */
  "timeline.operation.deleted_timestamp": "Deleted: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a draft has been discarded */
  "timeline.operation.draft-discarded": "Discarded draft",
  /** Label shown in review changes timeline when a draft has been discarded, with a timestamp */
  "timeline.operation.draft-discarded_timestamp": "Discarded draft: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a draft has been edited */
  "timeline.operation.edited-draft": "Edited",
  /** Label shown in review changes timeline when a draft has been edited, with a timestamp */
  "timeline.operation.edited-draft_timestamp": "Edited: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document has been edited live */
  "timeline.operation.edited-live": "Live edited",
  /** Label shown in review changes timeline when a document has been edited live, with a timestamp */
  "timeline.operation.edited-live_timestamp": "Live edited: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document was published */
  "timeline.operation.published": "Published",
  /** Label shown in review changes timeline when a document was published, with a timestamp */
  "timeline.operation.published_timestamp": "Published: {{timestamp, datetime}}",
  /** Label shown in review changes timeline when a document was unpublished */
  "timeline.operation.unpublished": "Unpublished",
  /** Label shown in review changes timeline when a document was unpublished, with a timestamp */
  "timeline.operation.unpublished_timestamp": "Unpublished: {{timestamp, datetime}}",
  /**
   * Label for determining since which version the changes for timeline menu dropdown are showing.
   * Receives the time label as a parameter (`timestamp`).
   */
  "timeline.since": "Since: {{timestamp, datetime}}",
  /** Label for missing change version for timeline menu dropdown are showing */
  "timeline.since-version-missing": "Since: unknown version",
  /**Aria label for the action buttons in the PTE toolbar */
  "toolbar.portable-text.action-button-aria-label": "{{action}}",
  /** Label for the button showed after trial ended */
  "user-menu.action.free-trial-finished": "Upgrade from free",
  /** Label for button showing the free trial days left */
  "user-menu.action.free-trial_one": "{{count}} day left in trial",
  "user-menu.action.free-trial_other": "{{count}} days left in trial",
  /** Label for action to invite members to the current sanity project */
  "user-menu.action.invite-members": "Invite members",
  /** Accessibility label for action to invite members to the current sanity project */
  "user-menu.action.invite-members-aria-label": "Invite members",
  /** Label for action to manage the current sanity project */
  "user-menu.action.manage-project": "Manage project",
  /** Accessibility label for the action to manage the current project */
  "user-menu.action.manage-project-aria-label": "Manage project",
  /** Tooltip helper text when portable text annotation is disabled for empty block*/
  "user-menu.action.portable-text.annotation-disabled_empty-block": "Cannot apply {{name}} to empty block",
  /** Tooltip helper text when portable text annotation is disabled for multiple blocks */
  "user-menu.action.portable-text.annotation-disabled_multiple-blocks": "Cannot apply {{name}} to multiple blocks",
  /** Label for action to sign out of the current sanity project */
  "user-menu.action.sign-out": "Sign out",
  /** Title for appearance section for the current studio (dark / light / system scheme) */
  "user-menu.appearance-title": "Appearance",
  /** Label for close menu button for user menu */
  "user-menu.close-menu": "Close menu",
  /** Description for using the "dark theme" in the appearance user menu */
  "user-menu.color-scheme.dark-description": "Use dark appearance",
  /** Title for using the "dark theme" in the appearance user menu */
  "user-menu.color-scheme.dark-title": "Dark",
  /** Description for using the "light theme" in the appearance user menu */
  "user-menu.color-scheme.light-description": "Use light appearance",
  /** Title for using the "light theme" in the appearance user menu */
  "user-menu.color-scheme.light-title": "Light",
  /** Description for using "system apparence" in the appearance user menu */
  "user-menu.color-scheme.system-description": "Use system appearance",
  /** Title for using system apparence in the appearance user menu */
  "user-menu.color-scheme.system-title": "System",
  /** Title for locale section for the current studio */
  "user-menu.locale-title": "Language",
  /** Label for tooltip to show which provider the currently logged in user is using */
  "user-menu.login-provider": "Signed in with {{providerTitle}}",
  /** Label for open menu button for user menu */
  "user-menu.open-menu": "Open menu",
  /**
   * Label for action to add a workspace (currently a developer-oriented action, as this will
   * lead to the documentation on workspace configuration)
   */
  "workspaces.action.add-workspace": "Add workspace",
  /**
   * Label for action to choose a different workspace, in the case where you are not logged in,
   * have selected a workspace, and are faced with the authentication options for the selected
   * workspace. In other words, label for the action shown when you have reconsidered which
   * workspace to authenticate in.
   */
  "workspaces.action.choose-another-workspace": "Choose another workspace",
  /** Label for heading that indicates that you can choose your workspace */
  "workspaces.choose-your-workspace-label": "Choose your workspace",
  /** Label for the workspace menu */
  "workspaces.select-workspace-aria-label": "Select workspace",
  /** Button label for opening the workspace switcher */
  "workspaces.select-workspace-label": "Select workspace",
  /** Tooltip for the workspace menu */
  "workspaces.select-workspace-tooltip": "Select workspace",
  /** Title for Workplaces dropdown menu */
  "workspaces.title": "Workspaces"
}), studioDefaultLocaleResources = {
  locale: "en-US",
  namespace: studioLocaleNamespace,
  resources: studioLocaleStrings
}, validationLocaleStrings = defineLocalesResources("validation", {
  /** Array must have exactly "$wantedLength" items, but has more/less */
  "array.exact-length": "Must have exactly {{wantedLength}} items",
  /** Portable Text array must have exactly "$wantedLength" blocks, but has more/less */
  "array.exact-length_blocks": "Must have exactly {{wantedLength}} blocks",
  /** Array item is a duplicate, but array wants only unique items */
  "array.item-duplicate": "Can't be a duplicate",
  /** Array has more than the maximum of "$maxLength" items */
  "array.maximum-length": "Must have at most {{maxLength}} items",
  /** Portable Text array has more than the maximum of "$maxLength" items */
  "array.maximum-length_blocks": "Must have at most {{maxLength}} blocks",
  /** Array has less than the minimum of "$minLength" items */
  "array.minimum-length": "Must have at least {{minLength}} items",
  /** Portable Text array has less than the minimum of "$minLength" blocks */
  "array.minimum-length_blocks": "Must have at least {{minLength}} blocks",
  /** Date is not valid or not in the correct format (ISO-8601) */
  "date.invalid-format": "Must be a valid ISO-8601 formatted date string",
  /** Date is later than the given maximum date "$maxDate" */
  "date.maximum": "Must be at or before {{maxDate}}",
  /** Date is earlier than the given minimum date "$minDate" */
  "date.minimum": "Must be at or after {{minDate}}",
  /** A value of incorrect type is found, eg found `number` instead of `string` */
  "generic.incorrect-type": 'Expected type "{{expectedType}}", got "{{actualType}}"',
  /** Value is not one of the values specifically allowed */
  "generic.not-allowed": "Value did not match any allowed values",
  /** Value "$givenValue" is not one of the values specifically allowed */
  "generic.not-allowed_hint": 'Value "{{hint}}" did not match any allowed values',
  /** A value is expected, but none is provided */
  "generic.required": "Required",
  /** Number is less than the given minimum threshold value "$threshold" */
  "number.greater-than": "Must be greater than {{threshold}}",
  /** Number is greater than the given maximum threshold value "$threshold" */
  "number.less-than": "Must be less than {{threshold}}",
  /** Number is higher than the given maximum value "$maxNumber" */
  "number.maximum": "Must be lower than or equal to {{maxNumber}}",
  /** Number has more precision (decimals) than the allowed "$limit" */
  "number.maximum-precision": "Max precision is {{limit}}",
  /** Number is lower than the given minimum value "$minNumber" */
  "number.minimum": "Must be greater than or equal to {{minNumber}}",
  /** Number is not an integer ("whole number") */
  "number.non-integer": "Must be an integer",
  /** Object is missing a reference to an asset document in its `asset` field */
  "object.asset-required": "Asset is required",
  /** Object is missing a reference to a file asset document in its `asset` field */
  "object.asset-required_file": "File is required",
  /** Object is missing a reference to an image asset document in its `asset` field */
  "object.asset-required_image": "Image is required",
  /** Object is not a reference to a document (eg `{_ref: 'documentId'}`) */
  "object.not-reference": "Must be a reference to a document",
  /** Object references a document which is not published */
  "object.reference-not-published": "Referenced document must be published",
  /** Accessibility label for closing the validation panel */
  "panel.close-button-aria-label": "Close validation",
  /** Message shown when the validation panel is opened but there are no errors/warnings */
  "panel.no-errors-message": "No validation errors",
  /** Title for the actual "Validation" panel/feature */
  "panel.title": "Validation",
  /** Slug is an object, but is missing a `current` string property */
  "slug.missing-current": "Slug must have a value",
  /** Slug is not an object (eg `{current: 'some-slug'}`) */
  "slug.not-object": "Slug must be an object",
  /** Slug is already in use somewhere else, but needs to be unique */
  "slug.not-unique": "Slug is already in use",
  /** String is not a valid email address */
  "string.email": "Must be a valid email address",
  /** String has a different character length than the exact number "$wantedLength" */
  "string.exact-length": "Must be exactly {{wantedLength}} characters long",
  /** String contains characters that are not in lowercase  */
  "string.lowercase": "Must be all lowercase characters",
  /** String is longer than the limit of "$maxLength" characters */
  "string.maximum-length": "Must be at most {{maxLength}} characters long",
  /** String is shorter than the limit of "$minLength" characters */
  "string.minimum-length": "Must be at least {{minLength}} characters long",
  /** String does not match the given regular expression, but should */
  "string.regex-does-not-match": 'Does not match "{{name}}"-pattern',
  /** String matches the given regular expression, but should not */
  "string.regex-match": 'Should not match "{{name}}"-pattern',
  /** String contains characters that are not in uppercase */
  "string.uppercase": "Must be all uppercase characters",
  /** String contains a protocol/scheme that is not allowed, eg (`ftp`, `mailto`…) */
  "string.url.disallowed-scheme": "Does not match allowed protocols/schemes",
  /** String contains a URL with a username or password specified before the host */
  "string.url.includes-credentials": "Username/password not allowed",
  /** String is not a valid URL */
  "string.url.invalid": "Not a valid URL",
  /** String is not an absolute URL (eg it is missing a protocol/host) */
  "string.url.not-absolute": "Relative URLs are not allowed",
  /** String is not a relative URL (eg it contains a protocol/host) */
  "string.url.not-relative": "Only relative URLs are allowed"
}), validationLocaleResources = {
  locale: "en-US",
  namespace: validationLocaleNamespace,
  resources: validationLocaleStrings
}, usEnglishLocale = {
  id: "en-US",
  title: "English (US)",
  bundles: [studioDefaultLocaleResources, validationLocaleResources],
  weekInfo: {
    firstDay: 7,
    // Sunday
    weekend: [6, 7],
    // Saturday, Sunday
    minimalDays: 1
  }
}, defaultLocale = usEnglishLocale, supportsLocalStorage = (() => {
  const key = "__tmp_supports_local_storage";
  try {
    return typeof localStorage > "u" ? !1 : (localStorage.setItem(key, "---"), localStorage.removeItem(key), !0);
  } catch {
    return !1;
  }
})(), LOCAL_STORAGE_PREFIX = "sanity-locale";
function getPreferredLocale(projectId, sourceId) {
  if (!supportsLocalStorage)
    return;
  const locale = localStorage.getItem(getItemKey$2(projectId, sourceId));
  return locale != null ? locale : void 0;
}
function storePreferredLocale(projectId, sourceId, locale) {
  supportsLocalStorage && localStorage.setItem(getItemKey$2(projectId, sourceId), locale);
}
function getItemKey$2(projectId, sourceId) {
  return [LOCAL_STORAGE_PREFIX, projectId, sourceId].join(":");
}
function LocaleProvider(props2) {
  const {
    projectId,
    name: sourceId,
    i18n: { locales },
    __internal: { i18next: i18next2 }
  } = useSource();
  return /* @__PURE__ */ jsxRuntime.jsx(
    LocaleProviderBase,
    {
      ...props2,
      projectId,
      sourceId,
      locales,
      i18next: i18next2
    }
  );
}
function LocaleProviderBase({
  projectId,
  sourceId,
  locales,
  i18next: i18next2,
  children
}) {
  const subscribe = React.useCallback(
    (callback) => (i18next2.on("languageChanged", callback), () => i18next2.off("languageChanged", callback)),
    [i18next2]
  ), currentLocale = React.useSyncExternalStore(
    subscribe,
    () => locales.find((candidate) => i18next2.language === candidate.id) || defaultLocale
  ), context = React.useMemo(
    () => ({
      locales,
      currentLocale,
      __internal: { i18next: i18next2 },
      changeLocale: async (newLocale) => {
        storePreferredLocale(projectId, sourceId, newLocale), await i18next2.changeLanguage(newLocale);
      }
    }),
    [currentLocale, i18next2, locales, projectId, sourceId]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, {}), children: /* @__PURE__ */ jsxRuntime.jsx(reactI18next.I18nextProvider, { i18n: i18next2, children: /* @__PURE__ */ jsxRuntime.jsx(_singletons.LocaleContext.Provider, { value: context, children }, currentLocale.id) }) });
}
function useGetI18nText(input) {
  const items = Array.isArray(input) ? input : [input], stableNamespaces = JSON.stringify(
    items.flatMap((item) => item != null && item.i18n ? Object.values(item.i18n).map(({ ns }) => ns) : []).filter(isNonNullable$3).sort()
  ), namespaces = React.useMemo(() => JSON.parse(stableNamespaces), [stableNamespaces]), { t: t2 } = useTranslation(namespaces);
  return React.useCallback(
    function(node) {
      const { i18n } = node;
      return i18n ? new Proxy(node, {
        get: (target, property) => {
          const defaultValue2 = target[property];
          if (typeof property == "string" && property in i18n) {
            const { key, ns } = i18n[property];
            return t2(key, {
              ns,
              // `defaultValue` is a special key in the i18next `t` API that
              // allows us to provide a fallback value if no translation is found
              // using the given key and namespace. if the value on the node
              // is a string, then we'll use that as the fallback value
              ...typeof defaultValue2 == "string" && { defaultValue: defaultValue2 }
            });
          }
          return defaultValue2;
        }
      }) : node;
    },
    [t2]
  );
}
function useI18nText(node) {
  const namespaces = React.useMemo(() => node.i18n ? Array.from(new Set(Object.values(node.i18n).map(({ ns }) => ns))).sort() : [], [node.i18n]), { t: t2 } = useTranslation(namespaces);
  return React.useMemo(() => {
    const { i18n } = node;
    return i18n ? new Proxy(node, {
      get: (target, property) => {
        const defaultValue2 = target[property];
        if (typeof property == "string" && property in i18n) {
          const { key, ns } = i18n[property];
          return t2(key, {
            ns,
            // `defaultValue` is a special key in the i18next `t` API that
            // allows us to provide a fallback value if no translation is found
            // using the given key and namespace. if the value on the node
            // is a string, then we'll use that as the fallback value
            ...typeof defaultValue2 == "string" && { defaultValue: defaultValue2 }
          });
        }
        return defaultValue2;
      }
    }) : node;
  }, [node, t2]);
}
function useCurrentLocale() {
  return useLocale().currentLocale;
}
function useLocale() {
  const context = React.useContext(_singletons.LocaleContext);
  if (!context)
    throw new Error(
      "Sanity LocaleContext value missing. Is this hook being used outside LocaleContext.Provider?"
    );
  return context;
}
const intlCache = (() => {
  const caches = {
    dateTimeFormat: createCache(),
    listFormat: createCache(),
    numberFormat: createCache(),
    relativeTimeFormat: createCache()
  };
  function dateTimeFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.dateTimeFormat[key];
    return instance || (instance = new Intl.DateTimeFormat(locale, options), caches.dateTimeFormat[key] = instance, instance);
  }
  function listFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.listFormat[key];
    return instance || (instance = new Intl.ListFormat(locale, options), caches.listFormat[key] = instance, instance);
  }
  function numberFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.numberFormat[key];
    return instance || (instance = new Intl.NumberFormat(locale, options), caches.numberFormat[key] = instance, instance);
  }
  function relativeTimeFormat(locale, options) {
    const key = getCacheId(locale, options);
    let instance = caches.relativeTimeFormat[key];
    return instance || (instance = new Intl.RelativeTimeFormat(locale, options), caches.relativeTimeFormat[key] = instance, instance);
  }
  return {
    dateTimeFormat,
    listFormat,
    numberFormat,
    relativeTimeFormat
  };
})();
function createCache() {
  return /* @__PURE__ */ Object.create(null);
}
function getCacheId(locale, options) {
  return `${locale}-${JSON.stringify(orderedProps(options))}`;
}
function orderedProps(obj) {
  const segments = [];
  for (const [key, value] of Object.entries(obj))
    segments.push(`${key}=${JSON.stringify(value)}`);
  return segments.sort().join(`
`);
}
function useListFormat(options = {}) {
  try {
    const currentLocale = useCurrentLocale().id;
    return intlCache.listFormat(currentLocale, options);
  } catch {
    return intlCache.listFormat("en-US", { ...options, style: "narrow" });
  }
}
const OPEN_TAG_RE = /^<(?<tag>[^\s\d<][^/?><]+)\/?>/, CLOSE_TAG_RE = /<\/(?<tag>[^>]+)>/, SELF_CLOSING_RE = /<[^>]+\/>/, VALID_COMPONENT_NAME_RE = /^[A-Z][A-Za-z0-9]+$/, VALID_HTML_TAG_NAME_RE = /^[a-z]+$/, TEMPLATE_RE = /{{\s*?([^}]+)\s*?}}/g;
function simpleParser(input) {
  const tokens = [];
  let text = "", openTag = "", remainder = input;
  for (; remainder.length > 0; )
    if (!openTag && remainder[0] === "<") {
      const match = matchOpenTag(remainder);
      if (match) {
        const tagName = match.groups.tag;
        validateTagName(tagName), text && (tokens.push(...textTokenWithInterpolation(text)), text = ""), isSelfClosing(match[0]) ? tokens.push({ type: "tagOpen", selfClosing: !0, name: tagName }) : (tokens.push({ type: "tagOpen", name: tagName }), openTag = tagName), remainder = remainder.slice(match[0].length);
      } else
        text += remainder[0], remainder = remainder.slice(1);
    } else if (openTag && remainder[0] === "<" && remainder[1] !== "<") {
      const match = matchCloseTag(remainder);
      if (match) {
        const tagName = match.groups.tag;
        if (remainder[1] !== "/")
          throw new Error(
            `Expected closing tag for <${openTag}>, but found new opening tag <${tagName}>. Nested tags is not supported.`
          );
        if (tagName !== openTag)
          throw new Error(
            `Expected closing tag for <${openTag}>, but found closing tag </${tagName}> instead. Make sure each opening tag has a matching closing tag.`
          );
        text && (tokens.push(...textTokenWithInterpolation(text)), text = ""), tokens.push({ type: "tagClose", name: tagName }), openTag = "", remainder = remainder.slice(match[0].length);
      } else
        text += remainder[0], remainder = remainder.slice(1);
    } else
      text += remainder[0], remainder = remainder.slice(1);
  if (openTag)
    throw new Error(
      `No matching closing tag for <${openTag}> found. Either make it self closing (e.g. "<${openTag}/>") or close it (e.g "<${openTag}>...</${openTag}>").`
    );
  return text && tokens.push(...textTokenWithInterpolation(text)), tokens;
}
function textTokenWithInterpolation(text) {
  const tokens = [], interpolations = text.matchAll(TEMPLATE_RE);
  let lastIndex = 0;
  for (const match of interpolations) {
    if (typeof match.index > "u")
      continue;
    const pre = text.slice(lastIndex, match.index);
    pre.length > 0 && tokens.push({ type: "text", text: pre }), tokens.push(parseInterpolation(match[0])), lastIndex += pre.length + match[0].length;
  }
  return lastIndex < text.length && tokens.push({ type: "text", text: text.slice(lastIndex) }), tokens;
}
function parseInterpolation(interpolation) {
  const [variable, ...formatters2] = interpolation.replace(/^\{\{|\}\}$/g, "").trim().split(/\s*,\s*/);
  if (formatters2.length === 1 && formatters2[0] === "list")
    return { type: "interpolation", variable, formatters: formatters2 };
  if (formatters2.length > 0)
    throw new Error(
      `Interpolations with formatters are not supported when using <Translate>. Found "${interpolation}". Utilize "useTranslation" instead, or format the values passed to <Translate> ahead of time.`
    );
  return { type: "interpolation", variable };
}
function isSelfClosing(tag) {
  return SELF_CLOSING_RE.test(tag);
}
function matchOpenTag(input) {
  return input.match(OPEN_TAG_RE);
}
function matchCloseTag(input) {
  return input.match(CLOSE_TAG_RE);
}
function validateTagName(tagName) {
  if (!(VALID_COMPONENT_NAME_RE.test(tagName) || VALID_HTML_TAG_NAME_RE.test(tagName)))
    throw new Error(
      tagName.trim() === tagName ? `Invalid tag "<${tagName}>". Tag names must be lowercase HTML tags or start with an uppercase letter and can only include letters and numbers.` : `Invalid tag "<${tagName}>". No whitespace allowed in tags.`
    );
}
const COMPONENT_NAME_RE = /^[A-Z]/, RECOGNIZED_HTML_TAGS = [
  "abbr",
  "address",
  "cite",
  "code",
  "del",
  "em",
  "ins",
  "kbd",
  "q",
  "samp",
  "strong",
  "sub",
  "sup"
];
function Translate(props2) {
  const translated = props2.t(props2.i18nKey, {
    context: props2.context,
    skipInterpolation: !0,
    count: props2.values && "count" in props2.values && typeof props2.values.count == "number" ? props2.values.count : void 0
  }), tokens = React.useMemo(() => simpleParser(translated), [translated]), listFormat = useListFormat(), formatters2 = {
    list: (listValues) => listFormat.format(listValues)
  };
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: render(tokens, props2.values, props2.components || {}, formatters2) });
}
function render(tokens, values2, componentMap, formatters2) {
  const [head, ...tail] = tokens;
  if (!head)
    return null;
  if (head.type === "interpolation") {
    const value = values2 ? values2[head.variable] : void 0;
    if (typeof value > "u")
      return `{{${head.variable}}}`;
    const formattedValue = applyFormatters(value, head.formatters || [], formatters2);
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      formattedValue,
      render(tail, values2, componentMap, formatters2)
    ] });
  }
  if (head.type === "text")
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      head.text,
      render(tail, values2, componentMap, formatters2)
    ] });
  if (head.type === "tagOpen" && head.selfClosing) {
    const Component = componentMap[head.name];
    if (!Component)
      throw new Error(`Component not found: ${head.name}`);
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(Component, {}),
      render(tail, values2, componentMap, formatters2)
    ] });
  }
  if (head.type === "tagOpen" && !head.selfClosing) {
    const nextCloseIdx = tail.findIndex((token) => token.type === "tagClose"), nextClose = tail[nextCloseIdx];
    if (nextClose && head.name !== nextClose.name)
      throw new Error("Nested tags is not allowed");
    const Component = componentMap[head.name];
    if (!Component && COMPONENT_NAME_RE.test(head.name))
      throw new Error(`Component not defined: ${head.name}`);
    if (!Component && !RECOGNIZED_HTML_TAGS.includes(head.name))
      throw new Error(`HTML tag "${head.name}" is not allowed`);
    const children = tail.slice(0, nextCloseIdx), remaining = tail.slice(nextCloseIdx + 1);
    return Component ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(Component, { children: render(children, values2, componentMap, formatters2) }),
      render(remaining, values2, componentMap, formatters2)
    ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      React.createElement(head.name, {}, render(children, values2, componentMap, formatters2)),
      render(remaining, values2, componentMap, formatters2)
    ] });
  }
  return null;
}
function applyFormatters(value, formatters2, formatterFns) {
  let formattedValue = value;
  for (const formatter of formatters2)
    if (formatter === "list")
      if (Array.isArray(value))
        formattedValue = formatterFns.list(value);
      else
        throw new Error("List formatter used on non-array value");
  return `${formattedValue}`;
}
const DEFAULT_STUDIO_CLIENT_OPTIONS = {
  apiVersion: "2024-03-12"
};
function getSizeDiff(prev, next) {
  if (!prev || !next)
    return 0;
  const increase = next - prev;
  return Math.round(increase / prev * 100);
}
function getHumanFriendlyBytes(bytes, format2) {
  return bytes < 1e3 ? format2(bytes, "byte") : bytes < 1e3 * 1e3 ? format2(bytes / 1e3, "kilobyte") : bytes < 1e3 * 1e3 * 1e3 ? format2(bytes / (1e3 * 1e3), "megabyte") : bytes < 1e3 * 1e3 * 1e3 * 1e3 ? format2(bytes / (1e3 * 1e3 * 1e3), "gigabyte") : format2(bytes / (1e3 * 1e3 * 1e3 * 1e3), "terabyte");
}
function serverBackend({ client: _client }) {
  const client2 = _client.withConfig(DEFAULT_STUDIO_CLIENT_OPTIONS), keyValueLoader = new DataLoader__default.default(async (keys) => {
    const keyValuePairs = (await client2.request({
      uri: `/users/me/keyvalue/${keys.join(",")}`,
      withCredentials: !0
    }).catch((error) => (console.error("Error fetching data:", error), Array(keys.length).fill(null)))).reduce(
      (acc, next) => (next != null && next.key && (acc[next.key] = next.value), acc),
      {}
    );
    return keys.map((key) => keyValuePairs[key] || null);
  }), getKeys = (keys) => rxjs.from(keyValueLoader.loadMany(keys)), setKeys = (keyValuePairs) => rxjs.from(
    client2.request({
      method: "PUT",
      uri: "/users/me/keyvalue",
      body: keyValuePairs,
      withCredentials: !0
    })
  ).pipe(
    rxjs.map((response) => response.map((pair) => (keyValueLoader.clear(pair.key), keyValueLoader.prime(pair.key, pair.value), pair.value))),
    rxjs.catchError((error) => (console.error("Error setting data:", error), rxjs.of(Array(keyValuePairs.length).fill(null))))
  );
  return {
    getKey: (key) => getKeys([key]).pipe(rxjs.map((values2) => values2[0])),
    setKey: (key, nextValue) => setKeys([{ key, value: nextValue }]).pipe(rxjs.map((values2) => values2[0])),
    getKeys,
    setKeys
  };
}
function createKeyValueStore({ client: client2 }) {
  const storageBackend = serverBackend({ client: client2 }), setKey$ = new rxjs.Subject(), updates$ = setKey$.pipe(
    operators.switchMap((event) => storageBackend.setKey(event.key, event.value).pipe(
      operators.map((nextValue) => ({
        key: event.key,
        value: nextValue
      }))
    )),
    operators.shareReplay(1)
  );
  return { getKey: (key) => rxjs.merge(
    storageBackend.getKey(key),
    updates$.pipe(
      operators.filter((update) => update.key === key),
      operators.map((update) => update.value)
    )
  ), setKey: (key, value) => (setKey$.next({ key, value }), updates$.pipe(
    operators.filter((update) => update.key === key),
    operators.map((update) => update.value),
    operators.take(1)
  )) };
}
var __defProp$e = Object.defineProperty, __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$e = (obj, key, value) => __defNormalProp$e(obj, key + "", value);
class CorsOriginError extends Error {
  constructor({ projectId }) {
    super("CorsOriginError"), __publicField$e(this, "projectId"), this.name = "CorsOriginError", this.projectId = projectId;
  }
}
const memStore = {};
function setItem(key, value) {
  supportsLocalStorage ? localStorage[key] = value : memStore[key] = value;
}
function getItem(key) {
  return supportsLocalStorage ? localStorage[key] : memStore[key];
}
function removeItem(key) {
  supportsLocalStorage ? localStorage.removeItem(key) : delete memStore[key];
}
function createBroadcastChannel(namespace) {
  const storageEvents$ = typeof window > "u" ? rxjs.of() : rxjs.fromEvent(window, "storage"), storageKey = `__studio_local_storage_messaging_${namespace}`, broadcastedMessages$ = new rxjs.Subject(), messages$ = rxjs.merge(
    broadcastedMessages$,
    storageEvents$.pipe(
      operators.filter((event) => event.key === storageKey),
      operators.map((event) => event.newValue),
      operators.filter(isNonNullable$3),
      operators.map((newValue) => JSON.parse(newValue))
    )
  ).pipe(
    // this is important to ensure all new subscribers get a message on subscribe
    operators.shareReplay(1)
  );
  function broadcast(message) {
    try {
      setItem(storageKey, JSON.stringify(message)), removeItem(storageKey), broadcastedMessages$.next(message);
    } catch {
    }
  }
  return { messages: messages$, broadcast };
}
const GithubRootSvg = styledComponents.styled.svg(({ theme: theme2 }) => {
  const { fg } = theme2.sanity.color.base;
  return styledComponents.css`
    fill: ${fg};
  `;
}), CustomImage = styledComponents.styled.img`
  height: 19px;
  width: 19px;
  object-fit: contain;
`, GithubLogo = () => /* @__PURE__ */ jsxRuntime.jsx(
  GithubRootSvg,
  {
    width: "1em",
    height: "1em",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 438.55 438.55",
    children: /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M409.13 114.57a218.32 218.32 0 0 0-79.8-79.8Q278.94 5.36 219.27 5.36T109.21 34.77a218.29 218.29 0 0 0-79.8 79.8Q0 165 0 224.63q0 71.67 41.83 128.91t108.06 79.23q7.71 1.43 11.42-2a11.17 11.17 0 0 0 3.69-8.57q0-.86-.14-15.42t-.14-25.41l-6.57 1.14a83.77 83.77 0 0 1-15.85 1 120.73 120.73 0 0 1-19.84-2 44.34 44.34 0 0 1-19.11-8.51 36.23 36.23 0 0 1-12.56-17.6l-2.86-6.57a71.34 71.34 0 0 0-9-14.56q-6.14-8-12.42-10.85l-2-1.43a21 21 0 0 1-3.71-3.43 15.66 15.66 0 0 1-2.57-4q-.86-2 1.43-3.29C61.2 310.42 64 310 68 310l5.71.85q5.71 1.14 14.13 6.85a46.08 46.08 0 0 1 13.85 14.84q6.57 11.71 15.85 17.85t18.7 6.14a81.19 81.19 0 0 0 16.27-1.42 56.78 56.78 0 0 0 12.85-4.29q2.57-19.14 14-29.41a195.49 195.49 0 0 1-29.36-5.13 116.52 116.52 0 0 1-26.83-11.14 76.86 76.86 0 0 1-23-19.13q-9.14-11.42-15-30t-5.8-42.81q0-34.55 22.56-58.82-10.57-26 2-58.24 8.28-2.57 24.55 3.85t23.84 11q7.57 4.56 12.13 7.71a206.2 206.2 0 0 1 109.64 0l10.85-6.85a153.65 153.65 0 0 1 26.26-12.56q15.13-5.71 23.13-3.14 12.84 32.26 2.28 58.24 22.55 24.27 22.56 58.82 0 24.27-5.85 43t-15.12 30a79.82 79.82 0 0 1-23.13 19 116.74 116.74 0 0 1-26.84 11.14 195.29 195.29 0 0 1-29.23 5.07q14.8 12.84 14.81 40.58v60.2a11.37 11.37 0 0 0 3.57 8.56q3.57 3.42 11.28 2 66.24-22 108.07-79.23t41.83-128.91q-.03-59.62-29.43-110.05z" })
  }
), GoogleLogo = () => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    width: "1em",
    height: "1em",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 48 48",
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M11 24a13 13 0 0 1 .66-4.08l-7.4-5.66a22.18 22.18 0 0 0 0 19.49l7.4-5.67A13 13 0 0 1 11 24z",
          fill: "#fbbc05"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M24 11a12.72 12.72 0 0 1 8.1 2.9l6.4-6.4a22 22 0 0 0-34.24 6.75l7.4 5.66A13 13 0 0 1 24 11z",
          fill: "#ea4335"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M24 37a13 13 0 0 1-12.34-8.92l-7.4 5.66A21.93 21.93 0 0 0 24 46a21 21 0 0 0 14.33-5.48l-7-5.44A13.59 13.59 0 0 1 24 37zm-12.35-8.93l-7.4 5.67 7.4-5.66z",
          fill: "#34a853"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M44.5 20H24v8.5h11.8a9.91 9.91 0 0 1-4.49 6.58l7 5.44C42.37 36.76 45 31.17 45 24a18.25 18.25 0 0 0-.5-4z",
          fill: "#4285f4"
        }
      )
    ]
  }
);
function CustomLogo(props2) {
  const { provider } = props2;
  return provider.logo ? /* @__PURE__ */ jsxRuntime.jsx(CustomImage, { src: provider.logo, alt: `Logo for ${provider.name}` }) : void 0;
}
const providerLogos = {
  google: GoogleLogo,
  github: GithubLogo
  // sanity: () => <SanityMonogram data-sanity-icon="" />,
};
async function getProviders({
  client: client2,
  mode,
  providers: customProviders = []
}) {
  if (mode === "replace" && Array.isArray(customProviders))
    return customProviders;
  const { providers } = await client2.request({
    uri: "/auth/providers"
  });
  return typeof customProviders == "function" ? customProviders(providers) : customProviders.length === 0 ? providers : mode === "replace" ? customProviders : providers.filter((official) => customProviders.some((provider) => provider.url !== official.url)).concat(customProviders);
}
function createHrefForProvider({
  loginMethod = "dual",
  projectId,
  url,
  redirectPath
}) {
  const params = new URLSearchParams();
  return params.set("origin", `${window.location.origin}${redirectPath}`), params.set("projectId", projectId), loginMethod === "token" ? params.set("withSid", "true") : params.set("type", loginMethod), `${url}?${params}`;
}
function createLoginComponent({
  getClient,
  loginMethod,
  redirectOnSingle,
  ...providerOptions
}) {
  const useClient2 = createHookFromObservableFactory(getClient);
  function LoginComponent({ projectId, ...props2 }) {
    const redirectPath = props2.redirectPath || props2.basePath || "/", [providers, setProviders] = React.useState(null), [error, setError] = React.useState(null);
    if (error) throw error;
    const [client2] = useClient2();
    React.useEffect(() => {
      client2 && getProviders({ client: client2, ...providerOptions }).then(setProviders).catch(setError);
    }, [client2]);
    const redirectUrlForRedirectOnSingle = redirectOnSingle && (providers == null ? void 0 : providers.length) === 1 && (providers == null ? void 0 : providers[0]) && createHrefForProvider({
      loginMethod,
      projectId,
      url: providers[0].url,
      redirectPath
    }), loading = !providers || redirectUrlForRedirectOnSingle;
    return React.useEffect(() => {
      redirectUrlForRedirectOnSingle && (window.location.href = redirectUrlForRedirectOnSingle);
    }, [redirectUrlForRedirectOnSingle]), loading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { align: "center", size: 1, children: "Choose login provider" }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: providers.map((provider, index) => /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          as: "a",
          icon: providerLogos[provider.name] || /* @__PURE__ */ jsxRuntime.jsx(CustomLogo, { provider }),
          href: createHrefForProvider({
            loginMethod,
            projectId,
            url: provider.url,
            redirectPath
          }),
          mode: "ghost",
          size: "large",
          text: provider.title
        },
        `${provider.url}_${index}`
      )) })
    ] });
  }
  return LoginComponent;
}
const sidPattern = /sid=([^&]{20,})&?/;
function consumeSessionId() {
  if (typeof window > "u" || typeof window.location != "object")
    return null;
  const hash2 = window.location.hash, [, sidParam] = hash2.match(sidPattern) || [];
  if (!sidParam)
    return null;
  const newHash = hash2.replace(sidPattern, ""), newUrl = new URL(window.location.href);
  return newUrl.hash = newHash.length > 1 ? newHash : "", history.replaceState(null, "", newUrl), sidParam;
}
let sessionId$1 = consumeSessionId();
const getSessionId$1 = () => {
  const id2 = sessionId$1;
  return id2 && (sessionId$1 = null), id2;
};
function isAuthStore(maybeStore) {
  return isRecord$4(maybeStore) && "state" in maybeStore && isRecord$4(maybeStore.state) && "subscribe" in maybeStore.state && typeof maybeStore.state.subscribe == "function";
}
function isCookielessCompatibleLoginMethod(loginMethod) {
  return ["dual", "token"].includes(loginMethod);
}
const getStorageKey = (projectId) => {
  if (!projectId) throw new Error("Invalid project id");
  return `__studio_auth_token_${projectId}`;
}, getToken = (projectId) => {
  try {
    const item = getItem(getStorageKey(projectId));
    if (item) {
      const { token } = JSON.parse(item);
      if (token && typeof token == "string")
        return token;
    }
  } catch (err) {
    console.error(err);
  }
  return null;
}, clearToken = (projectId) => {
  try {
    removeItem(getStorageKey(projectId));
  } catch (err) {
    console.error(err);
  }
}, saveToken = ({ token, projectId }) => {
  try {
    setItem(
      getStorageKey(projectId),
      JSON.stringify({ token, time: (/* @__PURE__ */ new Date()).toISOString() })
    );
  } catch (err) {
    console.error(err);
  }
}, getCurrentUser = async (client2, broadcastToken) => {
  var _a2;
  try {
    const user = await client2.request({
      uri: "/users/me",
      withCredentials: !0,
      tag: "users.get-current"
    });
    return typeof (user == null ? void 0 : user.id) == "string" ? user : null;
  } catch (err) {
    if (err.statusCode === 401)
      return clearToken(client2.config().projectId || ""), broadcastToken(null), null;
    if (await client2.request({ uri: "/ping", withCredentials: !1, tag: "cors-check" }).then(
      () => !0,
      // Request succeeded, so likely the CORS origin is disallowed
      () => !1
      // Request failed, so likely a network error of some kind
    ))
      throw new CorsOriginError({ projectId: (_a2 = client2.config()) == null ? void 0 : _a2.projectId });
    if (err.isNetworkError && !err.message && err.request && err.request.url) {
      const host = new URL(err.request.url).host;
      throw new Error(`Unknown network error attempting to reach ${host}`);
    }
    throw err;
  }
};
function _createAuthStore({
  clientFactory: clientFactoryOption,
  projectId,
  dataset,
  apiHost,
  loginMethod = "dual",
  ...providerOptions
}) {
  const { broadcast, messages } = createBroadcastChannel(`dual_mode_auth_${projectId}`), clientFactory = clientFactoryOption != null ? clientFactoryOption : client.createClient, token$ = messages.pipe(
    operators.startWith(isCookielessCompatibleLoginMethod(loginMethod) ? getToken(projectId) : null)
  ), hostOptions = {};
  apiHost ? hostOptions.apiHost = apiHost : typeof __SANITY_STAGING__ < "u" && __SANITY_STAGING__ === !0 && (hostOptions.apiHost = "https://api.sanity.work");
  const state$ = token$.pipe(
    // // see above
    // debounce(() => firstMessage),
    operators.map(
      (token) => clientFactory({
        projectId,
        dataset,
        apiVersion: "2021-06-07",
        useCdn: !1,
        ...token && { token },
        withCredentials: !0,
        requestTagPrefix: "sanity.studio",
        ignoreBrowserTokenWarning: !0,
        allowReconfigure: !1,
        ...hostOptions
      })
    ),
    operators.switchMap(
      (client2) => rxjs.defer(async () => {
        const currentUser = await getCurrentUser(client2, broadcast);
        return {
          currentUser,
          client: client2,
          authenticated: !!currentUser
        };
      })
    ),
    operators.distinctUntilChanged(
      (prev, next) => (
        // Only notify subscribers if the the currentUser object has changed.
        // Using isEqual is OK since the currentUser object being a small data structure.
        isEqual__default.default(prev.currentUser, next.currentUser)
      )
    ),
    operators.shareReplay(1)
  );
  async function handleCallbackUrl() {
    const sessionId2 = getSessionId$1();
    if (!sessionId2) {
      broadcast(loginMethod === "cookie" ? null : getToken(projectId));
      return;
    }
    const requestClient = clientFactory({
      projectId,
      dataset,
      useCdn: !0,
      withCredentials: !0,
      apiVersion: "2021-06-07",
      requestTagPrefix: "sanity.studio",
      ...hostOptions
    });
    let currentUser;
    if ((loginMethod === "dual" || loginMethod === "cookie") && (currentUser = await getCurrentUser(requestClient, broadcast)), currentUser || loginMethod === "cookie") {
      broadcast(null);
      return;
    }
    const token = await tradeSessionForToken(requestClient, sessionId2);
    broadcast(token != null ? token : null);
  }
  async function tradeSessionForToken(client2, sessionId2) {
    const { token } = await client2.request({
      method: "GET",
      uri: "/auth/fetch",
      query: { sid: sessionId2 },
      tag: "auth.fetch-token"
    });
    return saveToken({ token, projectId }), token;
  }
  async function logout() {
    var _a2;
    const requestClient = clientFactory({
      projectId,
      dataset,
      useCdn: !0,
      withCredentials: !0,
      token: (_a2 = getToken(projectId)) != null ? _a2 : void 0,
      apiVersion: "2021-06-07",
      requestTagPrefix: "sanity.studio",
      ...hostOptions
    });
    clearToken(projectId), await requestClient.request({ uri: "/auth/logout", method: "POST" }), broadcast(null);
  }
  const LoginComponent = createLoginComponent({
    ...providerOptions,
    getClient: () => state$.pipe(operators.map((state) => state.client)),
    loginMethod
  });
  return {
    handleCallbackUrl,
    token: token$,
    state: state$,
    LoginComponent,
    logout
  };
}
function hash(value) {
  return typeof value != "object" || value === null ? `${value}` : JSON.stringify(
    Object.fromEntries(
      Object.entries(value).sort(([a], [b]) => a.localeCompare(b, "en")).map(([k, v]) => [k, hash(v)])
    )
  );
}
const createAuthStore = memoize__default.default(_createAuthStore, hash);
function createMockAuthStore({ client: client2, currentUser = null }) {
  return {
    state: rxjs.of({ authenticated: !0, client: client2, currentUser })
  };
}
function getProviderTitle(provider) {
  if (provider === "google")
    return "Google";
  if (provider === "github")
    return "GitHub";
  if (provider === "sanity")
    return "Sanity";
  if (provider != null && provider.startsWith("saml-"))
    return "SAML/SSO";
}
function catchWithCount(selector) {
  return (input$) => {
    let errors = [];
    const errorOp = operators.catchError((err, caught) => (errors.push(err), selector(err, errors.length, caught).pipe(errorOp)));
    return input$.pipe(
      operators.tap(() => {
        errors = [];
      }),
      errorOp
    );
  };
}
const onOnline$ = typeof window > "u" ? rxjs.of({}) : rxjs.fromEvent(window, "online"), onOffline$ = typeof window > "u" ? rxjs.of({}) : rxjs.fromEvent(window, "offline"), expBackoff = (retryCount) => Math.pow(2, retryCount) * 100, CONNECTING = { type: "connecting" }, _callback = observableCallback.observableCallback(), onRetry$ = _callback[0], onRetry = _callback[1], createErrorStatus = ({
  error,
  isOffline,
  attemptNo,
  retryAt
}) => ({
  type: "error",
  error,
  attemptNo,
  isOffline,
  retryAt
});
function createConnectionStatusStore({
  bifur
}) {
  return { connectionStatus$: rxjs.merge(
    bifur.heartbeats,
    onOffline$.pipe(operators.mergeMapTo(rxjs.throwError(new Error("The browser went offline"))))
  ).pipe(
    operators.map((ts) => ({ type: "connected", lastHeartbeat: ts })),
    catchWithCount((error, successiveErrorsCount, caught) => {
      const timeUntilRetry = Math.min(24e4, expBackoff(successiveErrorsCount)), retryAt = new Date((/* @__PURE__ */ new Date()).getTime() + timeUntilRetry), expiry$ = rxjs.timer(retryAt), isOffline = !navigator.onLine, initialErrorStatus = createErrorStatus({
        error,
        retryAt,
        isOffline,
        attemptNo: successiveErrorsCount
      }), triggerRetry$ = rxjs.NEVER.pipe(
        operators.takeUntil(isOffline ? onOnline$ : rxjs.merge(expiry$, onOnline$, onRetry$))
      );
      return rxjs.concat(rxjs.of(initialErrorStatus), triggerRetry$.pipe(operators.take(1)), caught);
    }),
    operators.startWith(CONNECTING)
  ) };
}
function isBlockType(type) {
  return type.type ? isBlockType(type.type) : type.name === "block";
}
function isArrayOfObjectsFieldMember(member) {
  return member.kind === "field" && member.field.schemaType.jsonType === "array";
}
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/;
function pathToString$1(path) {
  if (!Array.isArray(path))
    throw new Error("Path is not an array");
  return path.reduce((target, segment, i) => {
    if (types.isIndexSegment(segment))
      return `${target}[${segment}]`;
    if (types.isKeySegment(segment) && segment._key)
      return `${target}[_key=="${segment._key}"]`;
    if (types.isIndexTuple(segment)) {
      const [from, to] = segment;
      return `${target}[${from}:${to}]`;
    }
    if (typeof segment == "string")
      return `${target}${i === 0 ? "" : "."}${segment}`;
    throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
  }, "");
}
function getValueAtPath(rootValue, path) {
  const segment = path[0];
  if (!segment)
    return rootValue;
  const tail = path.slice(1);
  if (types.isIndexSegment(segment))
    return getValueAtPath(Array.isArray(rootValue) ? rootValue[segment] : void 0, tail);
  if (types.isKeySegment(segment))
    return getValueAtPath(
      Array.isArray(rootValue) ? rootValue.find((item) => item._key === segment._key) : void 0,
      tail
    );
  if (typeof segment == "string")
    return getValueAtPath(isRecord$4(rootValue) ? rootValue[segment] : void 0, tail);
  throw new Error(`Unknown segment type ${JSON.stringify(segment)}`);
}
function findIndex(array, segment) {
  return typeof segment != "number" && !types.isKeySegment(segment) ? -1 : typeof segment == "number" ? segment : array.findIndex((item) => types.isKeyedObject(item) && item._key === segment._key);
}
function stringToPath(path) {
  const segments = path.match(rePropName);
  if (!segments)
    throw new Error("Invalid path string");
  return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
  return types.isIndexSegment(segment) ? normalizeIndexSegment(segment) : types.isKeySegment(segment) ? normalizeKeySegment(segment) : types.isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;
}
function normalizeIndexSegment(segment) {
  return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
  const segments = segment.match(reKeySegment);
  if (!segments)
    throw new Error("Invalid key segment");
  return { _key: segments[1] };
}
function normalizeIndexTupleSegment(segment) {
  const [from, to] = segment.split(":").map((seg) => seg === "" ? seg : Number(seg));
  return [from, to];
}
function pathsAreEqual(pathA, pathB) {
  return pathA.length !== pathB.length ? !1 : pathA.every((segmentA, index) => {
    const segmentB = pathB[index];
    return types.isKeySegment(segmentA) && types.isKeySegment(segmentB) ? segmentA._key === segmentB._key : types.isIndexSegment(segmentA) ? Number(segmentA) === Number(segmentB) : types.isIndexTuple(segmentA) && types.isIndexTuple(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;
  });
}
function getItemKey$1(arrayItem) {
  return types.isKeyedObject(arrayItem) ? arrayItem._key : void 0;
}
function getItemKeySegment(arrayItem) {
  const key = getItemKey$1(arrayItem);
  return key ? { _key: key } : void 0;
}
function isEmptyObject$1(item) {
  return typeof item == "object" && item !== null && Object.keys(item).length <= 0;
}
function getAnnotationColor(colorManager, annotation) {
  return colorManager.get((annotation == null ? void 0 : annotation.author) || null);
}
function getAnnotationAtPath(diff2, diffPath) {
  const path = Array.isArray(diffPath) ? diffPath : stringToPath(diffPath);
  return getAnnotationAt(diff2, path);
}
function getDiffAtPath(diff2, diffPath) {
  const path = Array.isArray(diffPath) ? diffPath : stringToPath(diffPath);
  return getDiffAt(diff2, path);
}
function getAnnotationAt(diff2, path) {
  const diffAt = getDiffAt(diff2, path);
  if (diffAt && diffAt.action !== "unchanged")
    return diffAt.annotation || void 0;
}
function getDiffAt(diff2, path, parentPath = []) {
  if (path.length === 0)
    return diff2;
  const segment = path[0], tail = path.slice(1);
  if (types.isIndexTuple(segment))
    throw new Error("Index tuples are not supported in diff paths");
  if (types.isIndexSegment(segment) || types.isKeySegment(segment)) {
    const location = types.isIndexSegment(segment) ? `at index ${segment}` : `with key ${segment._key}`;
    if (diff2.type !== "array") {
      `${location}${pathToString$1(parentPath)}`;
      return;
    }
    const itemDiff = diff2.items.find(
      types.isIndexSegment(segment) ? (item) => item.toIndex === segment : (item) => itemMatchesKey(item, segment)
    );
    if (!itemDiff) {
      `${location}${pathToString$1(parentPath)}`;
      return;
    }
    return getDiffAt(itemDiff.diff, tail, parentPath.concat(segment));
  }
  if (diff2.type !== "object") {
    `${segment}${pathToString$1(parentPath)}`;
    return;
  }
  const fieldDiff = diff2.fields[segment];
  if (typeof fieldDiff > "u") {
    `${segment}${pathToString$1(parentPath)}`;
    return;
  }
  return getDiffAt(fieldDiff, tail, parentPath.concat(segment));
}
function itemMatchesKey(item, key) {
  const itemDiff = item.diff;
  return itemDiff.type !== "object" || !itemDiff.toValue ? !1 : itemDiff.toValue._key === key;
}
function visitDiff(diff2, visitor, path = []) {
  if (visitor(diff2, path)) {
    if (diff2.type === "array") {
      visitArrayDiff(diff2, visitor, path);
      return;
    }
    if (diff2.type === "object") {
      visitObjectDiff(diff2, visitor, path);
      return;
    }
    diff2.type === "string" && visitStringDiff(diff2, visitor, path);
  }
}
function visitArrayDiff(diff2, visitor, path) {
  diff2.action !== "unchanged" && diff2.items.forEach((itemDiff) => {
    var _a2;
    const _key = itemDiff.diff.type === "object" && ((_a2 = itemDiff.diff.toValue) == null ? void 0 : _a2._key), segment = _key ? { _key } : getItemDiffIndex(itemDiff);
    visitDiff(itemDiff.diff, visitor, path.concat(segment));
  });
}
function visitObjectDiff(diff2, visitor, path) {
  diff2.action !== "unchanged" && Object.keys(diff2.fields).forEach((fieldName) => {
    const fieldDiff = diff2.fields[fieldName];
    visitDiff(fieldDiff, visitor, path.concat(fieldName));
  });
}
function visitStringDiff(diff2, visitor, path) {
  diff2.action !== "unchanged" && diff2.segments.forEach((segment) => {
    visitDiff(segment, visitor, path);
  });
}
function getItemDiffIndex(itemDiff) {
  return typeof itemDiff.toIndex > "u" ? itemDiff.fromIndex || 0 : itemDiff.toIndex;
}
function useUserColorManager() {
  const userColorManager = React.useContext(_singletons.UserColorManagerContext);
  if (!userColorManager)
    throw new Error("UserColorManager: missing context value");
  return userColorManager;
}
function useUserColor(userId) {
  const manager = useUserColorManager();
  return reactRx.useMemoObservable(userId ? manager.listen(userId) : rxjs.EMPTY, [userId], manager.get(null));
}
const DEFAULT_CURRENT_USER_HUE = "purple", USER_COLOR_EXCLUDE_HUES = ["green", "red", "gray"], defaultHues = color.COLOR_HUES.filter(
  (hue) => !USER_COLOR_EXCLUDE_HUES.includes(hue)
), getTints = (scheme) => {
  const isDarkScheme = scheme === "dark";
  return {
    background: isDarkScheme ? "900" : "100",
    border: isDarkScheme ? "700" : "300",
    text: isDarkScheme ? "200" : "700"
  };
}, getDefaultColors = (scheme) => {
  const { background, border, text } = getTints(scheme);
  return defaultHues.reduce(
    (colors, hue) => (colors[hue] = {
      name: hue,
      background: color.hues[hue][background].hex,
      border: color.hues[hue][border].hex,
      text: color.hues[hue][text].hex,
      tints: color.hues[hue]
    }, colors),
    {}
  );
}, getAnonymousColor = (scheme) => {
  const { background, border, text } = getTints(scheme);
  return {
    name: "gray",
    background: color.hues.gray[background].hex,
    border: color.hues.gray[border].hex,
    text: color.hues.gray[text].hex,
    tints: color.hues.gray
  };
};
function createUserColorManager(options) {
  const {
    anonymousColor: anonymousColorProp,
    colors,
    currentUserColor: currentUserColorProp,
    scheme
  } = options, userColors = colors || getDefaultColors(scheme), anonymousColor = anonymousColorProp || getAnonymousColor(scheme), currentUserColor = currentUserColorProp || DEFAULT_CURRENT_USER_HUE;
  if (!userColors.hasOwnProperty(currentUserColor))
    throw new Error(`'colors' must contain 'currentUserColor' (${currentUserColor})`);
  const userColorKeys = Object.keys(userColors), subscriptions = /* @__PURE__ */ new Map(), previouslyAssigned = /* @__PURE__ */ new Map(), assignedCounts = userColorKeys.reduce(
    (counts, color2) => (counts[color2] = 0, counts),
    {}
  ), assigned = /* @__PURE__ */ new Map();
  let currentUserId;
  return options != null && options.userStore && options.userStore.me.subscribe((user) => setCurrentUser(user ? user.id : null)), { get: get2, listen: listen2 };
  function get2(userId) {
    return userId ? userColors[getUserHue(userId)] : anonymousColor;
  }
  function getUserHue(userId) {
    if (userId === currentUserId)
      return currentUserColor;
    const assignedHue = assigned.get(userId);
    if (assignedHue)
      return assignedHue;
    const prevHue = previouslyAssigned.get(userId);
    if (prevHue && (assignedCounts[prevHue] === 0 || !hasUnusedColor()))
      return assignHue(userId, prevHue);
    const preferredHue = getPreferredHue(userId);
    return assignedCounts[preferredHue] === 0 ? assignHue(userId, preferredHue) : assignHue(userId, getLeastUsedHue(prevHue));
  }
  function listen2(userId) {
    let subscription = subscriptions.get(userId);
    if (subscription)
      return subscription;
    const hue = getUserHue(userId);
    return subscription = getObservableColor(userId, hue), subscriptions.set(userId, subscription), subscription;
  }
  function assignHue(userId, hue) {
    return assigned.set(userId, hue), previouslyAssigned.set(userId, hue), assignedCounts[hue]++, hue;
  }
  function unassignHue(userId, hue) {
    assigned.delete(userId), assignedCounts[hue]--;
  }
  function getUnusedColor() {
    return userColorKeys.find((colorHue) => assignedCounts[colorHue] === 0);
  }
  function hasUnusedColor() {
    return !!getUnusedColor();
  }
  function getLeastUsedHue(tieBreakerPreference) {
    let leastUses = 1 / 0, leastUsed = [];
    return userColorKeys.forEach((colorHue) => {
      const uses = assignedCounts[colorHue];
      uses === leastUses ? leastUsed.push(colorHue) : uses < leastUses && (leastUses = uses, leastUsed = [colorHue]);
    }), tieBreakerPreference && leastUsed.includes(tieBreakerPreference) ? tieBreakerPreference : leastUsed[0];
  }
  function getObservableColor(userId, hue) {
    return new rxjs.Observable((subscriber) => {
      const userColor = userColors[hue];
      return subscriber.next(userColor), () => {
        subscriptions.delete(userId), unassignHue(userId, hue);
      };
    }).pipe(operators.shareReplay({ refCount: !0 }));
  }
  function setCurrentUser(userId) {
    currentUserId = userId, assignedCounts[currentUserColor] += userId ? 1 : -1;
  }
  function getPreferredHue(userId) {
    let hash2 = 0;
    for (let i = 0; i < userId.length; i++)
      hash2 = (hash2 << 5) - hash2 + userId.charCodeAt(i) | 0;
    return userColorKeys[Math.abs(hash2) % userColorKeys.length];
  }
}
function UserColorManagerProvider({
  children,
  manager: managerFromProps
}) {
  const { scheme } = useColorScheme(), manager = React.useMemo(() => managerFromProps || createUserColorManager({ scheme }), [managerFromProps, scheme]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.UserColorManagerContext.Provider, { value: manager, children });
}
function useAnnotationColor(annotation) {
  const userColorManager = useUserColorManager();
  return getAnnotationColor(userColorManager, annotation);
}
function useDiffAnnotationColor(diff2, path = []) {
  const userColorManager = useUserColorManager(), annotation = React.useMemo(() => getAnnotationAtPath(diff2, path), [diff2, path]);
  return React.useMemo(
    () => getAnnotationColor(userColorManager, annotation),
    [annotation, userColorManager]
  );
}
function DiffTooltip(props2) {
  if (!("diff" in props2))
    return /* @__PURE__ */ jsxRuntime.jsx(DiffTooltipWithAnnotation, { ...props2 });
  const { diff: diff2, path = [], ...restProps } = props2, annotation = getAnnotationAtPath(diff2, path);
  return /* @__PURE__ */ jsxRuntime.jsx(DiffTooltipWithAnnotation, { ...restProps, annotations: annotation ? [annotation] : [] });
}
function DiffTooltipWithAnnotation(props2) {
  const { annotations, children, description, ...restProps } = props2, { t: t2 } = useTranslation();
  if (!annotations)
    return children;
  const content2 = /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: description || t2("changes.changed-label") }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: annotations.map((annotation, idx) => /* @__PURE__ */ jsxRuntime.jsx(AnnotationItem, { annotation }, idx)) })
  ] });
  return /* @__PURE__ */ jsxRuntime.jsx(LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: content2, portal: !0, ...restProps, children }) });
}
function AnnotationItem({ annotation }) {
  const { author, timestamp } = annotation, [user] = useUser(author), color2 = useAnnotationColor(annotation), timeAgo = useRelativeTime(timestamp, { minimal: !0 }), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Flex,
      {
        align: "center",
        paddingRight: 3,
        style: {
          backgroundColor: color2.background,
          color: color2.text,
          borderRadius: "calc(23px / 2)"
        },
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { user: author }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { paddingLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, style: { color: color2.text }, children: user ? user.displayName : t2("changes.loading-author") }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "time", muted: !0, size: 1, dateTime: timestamp, children: timeAgo })
  ] });
}
const StyledCard$3 = styledComponents.styled(ui.Card)`
  --diff-card-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[2])};
  --diff-card-bg-color: ${({ theme: theme2 }) => theme2.sanity.color.card.enabled.bg};

  max-width: 100%;
  position: relative;
  border-radius: var(--diff-card-radius);

  &:not(del) {
    text-decoration: none;
  }

  &[data-hover] {
    &::after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
    }

    &:hover {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;

      &::after {
        bottom: -3px;
        border-top: 1px solid var(---diff-card-bg-color);
        border-bottom: 2px solid currentColor;
        border-bottom-left-radius: var(--diff-card-radius);
        border-bottom-right-radius: var(--diff-card-radius);
      }
    }

    [data-from-to-layout]:hover & {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;

      &::after {
        bottom: -3px;
        border-top: 1px solid var(---diff-card-bg-color);
        border-bottom: 2px solid currentColor;
        border-bottom-left-radius: var(--diff-card-radius);
        border-bottom-right-radius: var(--diff-card-radius);
      }
    }
  }
`, EMPTY_PATH$1 = [], DiffCard = React.forwardRef(function(props2, ref) {
  const {
    annotation: annotationProp,
    as = "div",
    children,
    className,
    diff: diff2,
    disableHoverEffect,
    path = EMPTY_PATH$1,
    style = {},
    tooltip,
    ...restProps
  } = props2, annotation = React.useMemo(
    () => annotationProp || getAnnotationAtPath(diff2, path),
    [annotationProp, diff2, path]
  ), color2 = useAnnotationColor(annotation), element = /* @__PURE__ */ jsxRuntime.jsx(
    StyledCard$3,
    {
      ...restProps,
      as,
      className,
      "data-hover": disableHoverEffect || !annotation ? void 0 : "",
      ref,
      radius: 1,
      style: {
        ...style,
        backgroundColor: color2.background,
        color: color2.text
      },
      children
    }
  );
  return tooltip && annotation ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffTooltip,
    {
      annotations: [annotation],
      description: tooltip && typeof tooltip == "object" && tooltip.description,
      children: element
    }
  ) : element;
}), RoundedCard$1 = styledComponents.styled.div`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[2])};
  padding: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
`, AnnotationText = styledComponents.styled(ui.Text)`
  &:not([hidden]) {
    color: inherit;
  }
`;
function ChangeTitleSegment(props2) {
  const { change, segment } = props2;
  if (typeof segment == "string")
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { title: segment, size: 1, weight: "medium", textOverflow: "ellipsis", children: segment }) });
  const { hasMoved, fromIndex, toIndex, annotation } = segment, created = typeof fromIndex > "u", deleted = typeof toIndex > "u";
  if (created)
    return /* @__PURE__ */ jsxRuntime.jsx(CreatedTitleSegment, { annotation, change, toIndex });
  if (deleted)
    return /* @__PURE__ */ jsxRuntime.jsx(DeletedTitleSegment, { annotation, fromIndex });
  if (hasMoved && typeof toIndex < "u" && typeof fromIndex < "u")
    return /* @__PURE__ */ jsxRuntime.jsx(MovedTitleSegment, { annotation, fromIndex, toIndex });
  const readableIndex = (toIndex || 0) + 1;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "medium", children: [
    "#",
    readableIndex
  ] }) });
}
function CreatedTitleSegment(props2) {
  const { annotation: annotationProp, change, toIndex = 0 } = props2, { t: t2 } = useTranslation(), readableIndex = toIndex + 1, description = t2("changes.array.item-added-in-position", { position: readableIndex }), content2 = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    "#",
    readableIndex
  ] }), annotation = (change != null && change.diff ? getAnnotationAtPath(change.diff, []) : void 0) || annotationProp;
  return annotation ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation, tooltip: { description }, as: RoundedCard$1, children: /* @__PURE__ */ jsxRuntime.jsx(AnnotationText, { size: 1, weight: "medium", forwardedAs: "ins", style: { textDecoration: "none" }, children: content2 }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: content2 });
}
function DeletedTitleSegment(props2) {
  const { annotation, fromIndex = 0 } = props2, { t: t2 } = useTranslation(), readableIndex = fromIndex + 1, description = t2("changes.array.item-removed-from-position", { position: readableIndex });
  return /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: annotation || null, as: RoundedCard$1, tooltip: { description }, children: /* @__PURE__ */ jsxRuntime.jsxs(AnnotationText, { size: 1, weight: "medium", forwardedAs: "del", children: [
    "#",
    readableIndex
  ] }) });
}
function MovedTitleSegment(props2) {
  const { annotation, fromIndex, toIndex } = props2, { t: t2 } = useTranslation(), indexDiff = toIndex - fromIndex, indexSymbol = indexDiff < 0 ? "\u2191" : "\u2193", positions = Math.abs(indexDiff), direction = indexDiff < 0 ? "up" : "down", description = t2("changes.array.item-moved", {
    count: positions,
    context: direction
  });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(AnnotationText, { size: 1, weight: "medium", children: [
      "#",
      toIndex + 1
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation, as: RoundedCard$1, tooltip: { description }, children: /* @__PURE__ */ jsxRuntime.jsxs(AnnotationText, { size: 1, weight: "medium", children: [
      indexSymbol,
      Math.abs(indexDiff)
    ] }) })
  ] });
}
function ChangeBreadcrumb(props2) {
  const { change, titlePath } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Breadcrumbs,
    {
      maxLength: 4,
      separator: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}) }),
      children: titlePath.map((titleSegment, idx) => typeof titleSegment == "string" || !change || change.showIndex ? /* @__PURE__ */ jsxRuntime.jsx(ChangeTitleSegment, { change, segment: titleSegment }, idx) : null)
    }
  );
}
function isThenable(value) {
  return isRecord$4(value) && typeof (value == null ? void 0 : value.then) == "function";
}
function useCheckCondition(checkProperty, checkPropertyName, context) {
  const { currentUser, document: document2, parent, value } = context, didWarn2 = React.useRef(!1);
  return React.useMemo(() => {
    let isTrueIsh = !1;
    if (typeof checkProperty == "boolean" || checkProperty === void 0)
      return checkProperty || !1;
    try {
      isTrueIsh = checkProperty({
        document: document2,
        parent,
        value,
        currentUser
      });
    } catch (err) {
      return console.error(
        `An error occurred while running the callback from \`${checkPropertyName}\`: ${err.message}`
      ), !1;
    }
    return isThenable(isTrueIsh) && !didWarn2.current ? (console.warn(
      `The \`${checkPropertyName}\` option is either a promise or a promise returning function. Async callbacks for \`${checkPropertyName}\` option is not currently supported.`
    ), !1) : (typeof isTrueIsh > "u" && console.warn(
      `The \`${checkPropertyName}\` option is or returned \`undefined\`. \`${checkPropertyName}\` should return a boolean.`
    ), isTrueIsh);
  }, [checkProperty, document2, parent, value, currentUser, checkPropertyName]);
}
const useConditionalProperty = (props2) => {
  const { checkProperty = !1, checkPropertyKey, document: document2, parent, value: valueProp } = props2, value = useUnique(valueProp), currentUser = useCurrentUser();
  return useCheckCondition(checkProperty, checkPropertyKey, {
    currentUser,
    document: document2,
    parent,
    value
  });
};
function resolveTypeName$1(value) {
  return types.isTypedObject(value) ? value._type : resolveJSType$1(value);
}
function getArrayDiffItemType(diff2, schemaType) {
  return diff2.action === "added" ? {
    toType: resolveArrayMemberType(schemaType, diff2.toValue)
  } : diff2.action === "changed" ? {
    fromType: resolveArrayMemberType(schemaType, diff2.fromValue),
    toType: resolveArrayMemberType(schemaType, diff2.toValue)
  } : diff2.action === "removed" ? {
    fromType: resolveArrayMemberType(schemaType, diff2.fromValue)
  } : {
    toType: resolveArrayMemberType(schemaType, diff2.toValue)
  };
}
function resolveArrayMemberType(schemaType, value) {
  const typeName = resolveTypeName$1(value);
  return schemaType.of.find((candidate) => candidate.name === typeName) || (schemaType.of.length === 1 ? schemaType.of[0] : void 0);
}
function resolveJSType$1(val) {
  return Array.isArray(val) ? "array" : val === null ? "null" : typeof val;
}
const ANNOTATION_SYMBOLS = [
  // [startTag, endTag]
  ["\uF050", "\uF051"],
  ["\uF052", "\uF053"],
  ["\uF054", "\uF055"],
  ["\uF056", "\uF057"],
  ["\uF058", "\uF059"],
  ["\uF05A", "\uF05B"],
  ["\uF05C", "\uF05D"],
  ["\uF05F", "\uF060"],
  ["\uF061", "\uF062"],
  ["\uF063", "\uF064"],
  ["\uF065", "\uF066"],
  ["\uF067", "\uF068"],
  ["\uF069", "\uF06A"],
  ["\uF06B", "\uF06C"],
  ["\uF06E", "\uF06F"],
  ["\uF070", "\uF071"],
  ["\uF072", "\uF073"],
  ["\uF074", "\uF075"],
  ["\uF076", "\uF077"],
  ["\uF078", "\uF079"],
  ["\uF07A", "\uF07B"],
  ["\uF07C", "\uF07D"],
  ["\uF07E", "\uF07F"],
  ["\uF080", "\uF081"],
  ["\uF082", "\uF083"],
  ["\uF084", "\uF085"],
  ["\uF086", "\uF087"],
  ["\uF088", "\uF089"],
  ["\uF08A", "\uF08B"],
  ["\uF08C", "\uF08D"],
  ["\uF08E", "\uF08F"]
], CHILD_SYMBOL$1 = "\uF0D0", DECORATOR_SYMBOLS = [
  // [startTag, endTag]
  ["\uF000", "\uF001"],
  ["\uF002", "\uF003"],
  ["\uF004", "\uF005"],
  ["\uF006", "\uF007"],
  ["\uF008", "\uF009"],
  ["\uF00A", "\uF00B"],
  ["\uF00C", "\uF00D"],
  ["\uF00F", "\uF010"],
  ["\uF011", "\uF012"],
  ["\uF013", "\uF014"],
  ["\uF015", "\uF016"],
  ["\uF017", "\uF018"],
  ["\uF019", "\uF01A"],
  ["\uF01B", "\uF01C"],
  ["\uF01E", "\uF01F"],
  ["\uF020", "\uF021"]
], EMPTY_BLOCK_SYMBOL = "\u21B2", INLINE_SYMBOLS = [
  "\uF090",
  "\uF091",
  "\uF092",
  "\uF093",
  "\uF094",
  "\uF095",
  "\uF096",
  "\uF097",
  "\uF098",
  "\uF099",
  "\uF09A",
  "\uF09B",
  "\uF09C",
  "\uF09D",
  "\uF09E",
  "\uF09F",
  "\uF0A0",
  "\uF0A1",
  "\uF0A2",
  "\uF0A3",
  "\uF0A4",
  "\uF0A5",
  "\uF0A6",
  "\uF0A7",
  "\uF0A8",
  "\uF0A9",
  "\uF0AA",
  "\uF0AB",
  "\uF0AC",
  "\uF0AD",
  "\uF0AE",
  "\uF0AF",
  "\uF0B0",
  "\uF0B1",
  "\uF0B2",
  "\uF0B3",
  "\uF0B4",
  "\uF0B5",
  "\uF0B6",
  "\uF0B7",
  "\uF0B8",
  "\uF0B9",
  "\uF0BA",
  "\uF0BB",
  "\uF0BC",
  "\uF0BD",
  "\uF0BE",
  "\uF0BF"
], TRAILING_SPACE_SYMBOL = "\u205F", SEGMENT_START_SYMBOL = "\u2060";
function hasPTMemberType(schemaType) {
  return schemaType.of.some(isPTSchemaType);
}
const startMarkSymbols = DECORATOR_SYMBOLS.map((set2) => set2[0]).concat(
  ANNOTATION_SYMBOLS.map((set2) => set2[0])
), endMarkSymbols = DECORATOR_SYMBOLS.map((set2) => set2[1]).concat(
  ANNOTATION_SYMBOLS.map((set2) => set2[1])
), allSymbols = startMarkSymbols.concat(endMarkSymbols).concat(INLINE_SYMBOLS).concat(CHILD_SYMBOL$1).concat(SEGMENT_START_SYMBOL), symbolRegex = new RegExp(`${allSymbols.join("|")}`, "g"), segmentRegex = new RegExp(`${allSymbols.join("|")}|
`, "g");
function isPTSchemaType(schemaType) {
  return schemaType.jsonType === "object" && schemaType.name === "block";
}
function isHeader(node) {
  return types.isPortableTextTextBlock(node) && !!node.style && ["h1", "h2", "h3", "h4", "h5", "h6"].includes(node.style);
}
function findChildDiff(diff2, child) {
  return diff2.fields.children.items.filter(
    (item) => item.diff.isChanged && (item.diff.toValue === child || item.diff.fromValue === child)
  ).map((item) => item.diff).map((childDiff) => childDiff)[0];
}
function getChildSchemaType(fields, child) {
  const childrenField = fields.find((f) => f.name === "children");
  return childrenField && childrenField.type && childrenField.type.jsonType === "array" && childrenField.type.of.find((type) => type.name === child._type) || void 0;
}
function getDecorators(spanSchemaType) {
  return spanSchemaType.decorators ? orderBy__default.default(spanSchemaType.decorators, ["value"], ["asc"]) : [];
}
function isDecorator(name, schemaType) {
  return getDecorators(schemaType).some((dec2) => dec2.value === name);
}
function blockToSymbolizedText(diff2, block, decoratorMap, annotationMap, inlineMap) {
  return block ? block.children.map((child) => {
    var _a2;
    let returned = types.isPortableTextSpan(child) ? (_a2 = child.text) == null ? void 0 : _a2.replace(symbolRegex, "") : "";
    if (types.isPortableTextSpan(child)) {
      const spanDiff = findSpanDiffFromChild(diff2, child), textDiff = spanDiff == null ? void 0 : spanDiff.fields.text;
      textDiff && textDiff.toValue === child.text && textDiff.type === "string" && textDiff.action !== "unchanged" && (returned = textDiff.segments.filter((seg) => seg.action !== "removed").map((seg) => seg.text.replace(symbolRegex, "")).join(SEGMENT_START_SYMBOL)), child.marks && child.marks.forEach((mark) => {
        decoratorMap[mark] ? returned = `${decoratorMap[mark][0]}${returned}${decoratorMap[mark][1]}` : annotationMap[mark] && (returned = `${annotationMap[mark][0]}${returned}${annotationMap[mark][1]}`);
      });
    } else
      returned = inlineMap[child._key];
    return `${CHILD_SYMBOL$1}${returned}`;
  }).join("") : "";
}
function createPortableTextDiff(diff2, schemaType) {
  const displayValue = diff2.action === "removed" ? diff2.fromValue : diff2.toValue, _diff = {
    ...diff2,
    origin: diff2,
    displayValue
  };
  if (displayValue) {
    const annotationMap = {}, decoratorMap = {}, inlineMap = {}, spanSchemaType = getChildSchemaType(schemaType.fields, {
      _key: "bogus",
      _type: "span"
    });
    spanSchemaType && getDecorators(spanSchemaType).forEach((dec2, index) => {
      decoratorMap[dec2.value] = DECORATOR_SYMBOLS[index];
    }), getAllMarkDefs(_diff.origin).forEach((markDef, index) => {
      annotationMap[markDef._key] = ANNOTATION_SYMBOLS[index];
    }), getInlineObjects(_diff.origin).forEach((inline, index) => {
      inlineMap[inline._key] = INLINE_SYMBOLS[index];
    });
    const fromText = blockToSymbolizedText(
      _diff.origin,
      _diff.fromValue,
      decoratorMap,
      annotationMap,
      inlineMap
    ), toText = blockToSymbolizedText(
      _diff.origin,
      _diff.toValue,
      decoratorMap,
      annotationMap,
      inlineMap
    ), toPseudoValue = {
      ...displayValue,
      children: [
        {
          _type: "span",
          _key: "pseudoSpanKey",
          text: toText,
          marks: []
        }
      ]
    }, fromPseudoValue = {
      displayValue,
      children: [
        {
          _type: "span",
          _key: "pseudoSpanKey",
          text: fromText,
          marks: []
        }
      ]
    };
    return {
      origin: diff2,
      action: "changed",
      type: "object",
      displayValue: toPseudoValue,
      fromValue: fromPseudoValue,
      toValue: toPseudoValue,
      isChanged: !0,
      fields: {
        children: {
          action: "changed",
          type: "array",
          isChanged: !0,
          items: [
            {
              diff: {
                action: "changed",
                type: "object",
                isChanged: !0,
                fields: {
                  text: {
                    type: "string",
                    action: "changed",
                    isChanged: !0,
                    fromValue: fromText,
                    toValue: toText,
                    segments: buildSegments(fromText, toText).map((seg) => ({
                      ...seg,
                      ..._diff.action !== "unchanged" && _diff.annotation ? { annotation: _diff.annotation } : {}
                    }))
                  }
                },
                fromValue: fromPseudoValue.children[0],
                toValue: toPseudoValue.children[0]
              },
              annotation: null,
              fromIndex: 0,
              toIndex: 0,
              hasMoved: !1
            }
          ],
          fromValue: fromPseudoValue.children,
          toValue: toPseudoValue.children
        }
      }
    };
  }
  throw new Error("Can not display this diff");
}
function buildSegments(fromInput, toInput) {
  const segments = [], dmpDiffs = diffMatchPatch$1.cleanupEfficiency(diffMatchPatch$1.makeDiff(fromInput, toInput));
  let fromIdx = 0, toIdx = 0;
  for (const [op, text] of dmpDiffs)
    switch (op) {
      case diffMatchPatch$1.DIFF_EQUAL:
        segments.push({
          type: "stringSegment",
          action: "unchanged",
          text
        }), fromIdx += text.length, toIdx += text.length;
        break;
      case diffMatchPatch$1.DIFF_DELETE:
        segments.push({
          type: "stringSegment",
          action: "removed",
          text: fromInput.slice(fromIdx, fromIdx + text.length),
          annotation: null
        }), fromIdx += text.length;
        break;
      case diffMatchPatch$1.DIFF_INSERT:
        segments.push({
          type: "stringSegment",
          action: "added",
          text: toInput.slice(toIdx, toIdx + text.length),
          annotation: null
        }), toIdx += text.length;
        break;
    }
  return flatten__default.default(
    segments.map((seg) => {
      const newSegments = [];
      if (seg.text.length > 1) {
        const markMatches = [...seg.text.matchAll(segmentRegex)];
        let lastIndex = -1;
        markMatches.forEach((match) => {
          const index = match.index || 0;
          index > lastIndex && (newSegments.push({ ...seg, text: seg.text.slice(lastIndex + 1, index) }), newSegments.push({ ...seg, text: match[0] })), match === markMatches[markMatches.length - 1] && newSegments.push({ ...seg, text: seg.text.slice(Math.max(0, index + 1)) }), lastIndex = index;
        }), markMatches.length === 0 && newSegments.push(seg);
      } else
        newSegments.push(seg);
      return newSegments;
    })
  );
}
function getInlineObjects(diff2) {
  const allChildren = [
    ...diff2.toValue ? diff2.toValue.children.filter((cld) => cld._type !== "span") : []
  ];
  return (diff2.fromValue ? diff2.fromValue.children.filter((cld) => cld._type !== "span") : []).forEach((oCld) => {
    allChildren.some((cld) => oCld._key === cld._key) || allChildren.push(oCld);
  }), orderBy__default.default(allChildren, ["_key"], ["asc"]);
}
function findSpanDiffFromChild(diff2, child) {
  const candidate = diff2.fields.children && diff2.fields.children.action !== "unchanged" && diff2.fields.children.type === "array" && diff2.fields.children.items.find(
    (item) => item.diff && item.diff.type === "object" && (item.diff.action === "removed" ? item.diff.fromValue && item.diff.fromValue._key === child._key : (item.diff.toValue && item.diff.toValue._key) === child._key)
  );
  if (candidate)
    return candidate.diff;
}
function findAnnotationDiff(diff2, markDefKey) {
  var _a2;
  return diff2.fields.markDefs && diff2.fields.markDefs.isChanged && diff2.fields.markDefs.type === "array" && ((_a2 = diff2.fields.markDefs.items.find(
    (item) => item.diff && item.diff.type === "object" && (item.diff.toValue && item.diff.toValue._key && item.diff.toValue._key === markDefKey || item.diff.fromValue && item.diff.fromValue._key && item.diff.fromValue._key === markDefKey)
  )) == null ? void 0 : _a2.diff) || void 0;
}
function isEmptyObject(object) {
  return object && isEqual__default.default(Object.keys(object), ["_key", "_type"]) || !1;
}
function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function getAllMarkDefs(diff2) {
  const allDefs = [
    ...diff2.toValue && diff2.toValue.markDefs ? diff2.toValue.markDefs : []
  ];
  return (diff2.fromValue && diff2.fromValue.markDefs ? diff2.fromValue.markDefs : []).forEach((oDef) => {
    allDefs.some((def) => oDef._key === def._key) || allDefs.push(oDef);
  }), orderBy__default.default(allDefs, ["_key"], ["asc"]);
}
function getPrintableType(value) {
  const nativeType = typeof value;
  if (nativeType === "object") {
    if (value === null) return "null";
    if (Array.isArray(value)) return "array";
    if (value instanceof Object && value.constructor.name !== "Object")
      return value.constructor.name;
  }
  return nativeType;
}
function getValueError(value, schemaType) {
  const { jsonType } = schemaType, valueType = Array.isArray(value) ? "array" : typeof value;
  if (!(value === null || valueType === "undefined")) {
    if (valueType !== jsonType)
      return {
        messageKey: "changes.error.incorrect-type-message",
        value,
        expectedType: jsonType,
        actualType: getPrintableType(value)
      };
    if (isObjectType(schemaType) && isObjectValue(value))
      for (const field of schemaType.fields) {
        const fieldError = getValueError(value[field.name], field.type);
        if (fieldError)
          return fieldError;
      }
  }
}
function isObjectType(schemaType) {
  return schemaType.jsonType === "object";
}
function isObjectValue(value) {
  return value !== null && !Array.isArray(value) && typeof value == "object";
}
function noop$3() {
}
function isFieldChange(change) {
  return change.type === "field";
}
function isGroupChange(change) {
  return change.type === "group";
}
function isAddedItemDiff(item) {
  return item.diff.action === "added";
}
function isRemovedItemDiff(item) {
  return item.diff.action === "removed";
}
function isUnchangedDiff(diff2) {
  return diff2.action === "unchanged";
}
const diffResolvers = [];
function Checkbox({ checked, color: color2 }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      width: "17",
      height: "17",
      viewBox: "0 0 17 17",
      xmlns: "http://www.w3.org/2000/svg",
      fill: color2 == null ? void 0 : color2.background,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "0", y: "0", width: "17", height: "17", rx: "2.5" }),
        typeof checked > "u" && /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M4.07996 8.5H12.92", stroke: color2 == null ? void 0 : color2.text, strokeWidth: "2" }),
        checked && /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M3.5 8L7 11.5L13.5 5", stroke: color2 == null ? void 0 : color2.text, strokeWidth: "2" })
      ]
    }
  );
}
function Switch({ checked, color: color2 }) {
  return /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "38", height: "22", viewBox: "0 0 38 22", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "38", height: "22", rx: "11", fill: checked ? color2 == null ? void 0 : color2.border : color2 == null ? void 0 : color2.background }),
    typeof checked > "u" && /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "11", y: "3", width: "16", height: "16", rx: "8", fill: "white" }),
    checked && /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "18", y: "3", width: "16", height: "16", rx: "8", fill: "white" }),
    typeof checked == "boolean" && !checked && /* @__PURE__ */ jsxRuntime.jsx("rect", { x: "4", y: "3", width: "16", height: "16", rx: "8", fill: "white" })
  ] });
}
const BooleanFieldDiff = ({ diff: diff2, schemaType }) => {
  const { fromValue, toValue } = diff2, { title, options } = schemaType, Preview2 = (options == null ? void 0 : options.layout) === "checkbox" ? Checkbox : Switch, userColor = useDiffAnnotationColor(diff2, []), showToValue = toValue != null;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(Preview2, { checked: fromValue, color: userColor }),
      showToValue && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FromToArrow, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(Preview2, { checked: toValue, color: userColor })
      ] })
    ] }) }),
    showToValue && title && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: title }) })
  ] });
}, DatetimeWrapper = styledComponents.styled.div`
  display: inline-block;
  word-wrap: break-word;
`, DatetimePreview = function({
  value,
  schemaType
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: DatetimeWrapper, paddingX: 2, paddingY: 1, children: formatDateTime(value, schemaType) });
};
function formatDateTime(value, schemaType) {
  const { options, name } = schemaType, dateFormat = (options == null ? void 0 : options.dateFormat) || legacyDateFormat__namespace.DEFAULT_DATE_FORMAT, timeFormat = (options == null ? void 0 : options.timeFormat) || legacyDateFormat__namespace.DEFAULT_TIME_FORMAT;
  return legacyDateFormat__namespace.format(
    new Date(value),
    name === "date" ? dateFormat : `${dateFormat} ${timeFormat}`
  );
}
const DatetimeFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  DiffFromTo,
  {
    align: "center",
    diff: diff2,
    layout: "grid",
    previewComponent: DatetimePreview,
    schemaType
  }
);
function useDocumentChange() {
  const documentChange = React.useContext(_singletons.DocumentChangeContext);
  if (!documentChange)
    throw new Error("DocumentChange: missing context value");
  return documentChange;
}
function useRefValue(refId) {
  const [value, setValue] = React.useState(void 0), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return React.useEffect(() => {
    if (!refId)
      return;
    const subscription = client2.observable.getDocument(refId).subscribe(setValue);
    return () => {
      subscription.unsubscribe();
    };
  }, [client2, refId]), refId ? value : void 0;
}
const SizeDiff = styledComponents.styled.div`
  ${({ theme: theme2 }) => `
    --size-diff-positive: ${theme2.sanity.color.solid.positive.enabled.bg};
    --size-diff-negative: ${theme2.sanity.color.solid.critical.enabled.bg};
  `}
  &:not([hidden]) {
    display: inline-block;
  }

  [data-number='positive'] {
    color: var(--size-diff-positive);
  }

  [data-number='negative'] {
    color: var(--size-diff-negative);
  }
`, FileFieldDiff = ({ diff: diff2, schemaType }) => {
  const { fromValue, toValue, fields } = diff2, fromAsset = fromValue == null ? void 0 : fromValue.asset, toAsset = toValue == null ? void 0 : toValue.asset, { t: t2 } = useTranslation(), prev = useRefValue(fromAsset == null ? void 0 : fromAsset._ref), next = useRefValue(toAsset == null ? void 0 : toAsset._ref), formatUnit = useUnitFormatter({ unitDisplay: "short", maximumFractionDigits: 2 }), changedFields = Object.entries(fields).filter(([name, field]) => field.isChanged && name !== "_type").map(([name]) => name), didAssetChange = changedFields.includes("asset"), nestedFields = schemaType.fields.filter((field) => field.name !== "asset" && changedFields.includes(field.name)).map((field) => field.name), pctDiff = getSizeDiff(prev == null ? void 0 : prev.size, next == null ? void 0 : next.size), prevSize = (prev == null ? void 0 : prev.size) && getHumanFriendlyBytes(prev.size, formatUnit), nextSize = (next == null ? void 0 : next.size) && getHumanFriendlyBytes(next.size, formatUnit), cardStyles2 = React.useMemo(() => ({ display: "block", flex: 1 }), []), from = prev && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "del", diff: diff2, path: "asset._ref", style: cardStyles2, children: /* @__PURE__ */ jsxRuntime.jsx(
    MetaInfo,
    {
      title: prev.originalFilename || t2("changes.file.meta-info-fallback-title"),
      icon: icons.DocumentIcon,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, style: { color: "inherit" }, children: prevSize })
    }
  ) }), to = next && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "ins", diff: diff2, path: "asset._ref", style: cardStyles2, children: /* @__PURE__ */ jsxRuntime.jsx(
    MetaInfo,
    {
      title: next.originalFilename || t2("changes.file.meta-info-fallback-title"),
      icon: icons.DocumentIcon,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, style: { color: "inherit" }, children: nextSize }),
        pctDiff !== 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, padding: 1, as: SizeDiff, marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 0, "data-number": pctDiff > 0 ? "positive" : "negative", children: [
          pctDiff > 0 ? "+" : "-",
          pctDiff,
          "%"
        ] }) })
      ] })
    }
  ) }), FileAssetChange = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    from && !to && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "asset._ref", description: t2("changes.removed-label"), children: from }),
    from && to && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "asset._ref", children: /* @__PURE__ */ jsxRuntime.jsx(FromTo, { from, layout: "grid", to }) }),
    !from && to && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "asset._ref", description: t2("changes.added-label"), children: to })
  ] });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    didAssetChange && FileAssetChange,
    nestedFields.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: didAssetChange ? 4 : 3, children: /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType, fields: nestedFields }) })
  ] });
};
function hexToRgba(hex, opacity) {
  return `rgba(${(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex) || []).slice(1).map((num) => parseInt(num, 16)).concat(opacity).join(", ")})`;
}
function simpleHash(str) {
  let hash2 = 0;
  if (str.length == 0)
    return hash2.toString();
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + char, hash2 &= hash2;
  }
  return hash2.toString();
}
function getDeviceDpr() {
  const base = Math.ceil(window.devicePixelRatio || 1);
  return Math.min(3, Math.max(1, base));
}
function HotspotCropSVG(props2) {
  const { crop, diff: diff2, hash: hash2, hotspot, width = 100, height = 100, ...restProps } = props2, { t: t2 } = useTranslation(), cropColor = useDiffAnnotationColor(diff2, "crop"), hotspotColor = useDiffAnnotationColor(diff2, "hotspot");
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      ...restProps,
      fill: "none",
      width,
      height,
      viewBox: `0 0 ${width} ${height}`,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("defs", { children: crop && hotspot && /* @__PURE__ */ jsxRuntime.jsxs("mask", { id: `mask-hotspot-${hash2}`, children: [
          /* @__PURE__ */ jsxRuntime.jsx("rect", { x: 0, y: 0, width, height, fill: "#fff" }),
          /* @__PURE__ */ jsxRuntime.jsx(
            HotspotSVG,
            {
              hotspot,
              fill: "#000",
              offset: 1,
              width,
              height,
              stroke: "#000",
              strokeWidth: 3
            }
          )
        ] }) }),
        crop && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "crop", description: t2("changes.image.crop-changed"), children: /* @__PURE__ */ jsxRuntime.jsx("g", { children: /* @__PURE__ */ jsxRuntime.jsx(
          CropSVG,
          {
            crop,
            fill: hexToRgba(cropColor.border, 0.25),
            mask: hotspot ? `url(#mask-hotspot-${hash2})` : void 0,
            stroke: cropColor.border,
            strokeWidth: 1,
            width,
            height
          }
        ) }) }),
        hotspot && /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { diff: diff2, path: "hotspot", description: t2("changes.image.crop-changed"), children: /* @__PURE__ */ jsxRuntime.jsx("g", { children: /* @__PURE__ */ jsxRuntime.jsx(
          HotspotSVG,
          {
            hotspot,
            fill: hexToRgba(hotspotColor.border, 0.25),
            stroke: hotspotColor.border,
            strokeWidth: 1,
            width,
            height
          }
        ) }) })
      ]
    }
  );
}
function CropSVG({
  crop,
  width,
  height,
  ...restProps
}) {
  const rectProps = {
    x: crop.left * width,
    y: crop.top * height,
    width: (1 - crop.right - crop.left) * width,
    height: (1 - crop.bottom - crop.top) * height
  };
  return /* @__PURE__ */ jsxRuntime.jsx("rect", { ...restProps, ...rectProps, style: { vectorEffect: "non-scaling-stroke" } });
}
function HotspotSVG({
  hotspot,
  offset = 0,
  width,
  height,
  ...restProps
}) {
  const ellipseProps = {
    cx: hotspot.x * width,
    cy: hotspot.y * height,
    rx: hotspot.width / 2 * width + offset,
    ry: hotspot.height / 2 * height + offset
  };
  return /* @__PURE__ */ jsxRuntime.jsx("ellipse", { ...restProps, ...ellipseProps, style: { vectorEffect: "non-scaling-stroke" } });
}
const ASSET_FIELDS = ["originalFilename"], NoImagePreview = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: 1, tone: "transparent", padding: 4, radius: 2, height: "stretch", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t2("changes.image.no-image-placeholder") }) }) });
}, ImageWrapper = styledComponents.styled.div`
  height: 100%;
  max-height: 190px;
  position: relative;

  /* Ideally the checkerboard component currently in the form builder should be made available and used here */
  background-color: ${color.hues.gray[100].hex};
  background-image: linear-gradient(45deg, ${color.hues.gray[50].hex} 25%, transparent 25%),
    linear-gradient(-45deg, ${color.hues.gray[50].hex} 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, ${color.hues.gray[50].hex} 75%),
    linear-gradient(-45deg, transparent 75%, ${color.hues.gray[50].hex} 75%);
  background-size: 16px 16px;
  background-position:
    0 0,
    0 8px,
    8px -8px,
    -8px 0;

  &::after {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    box-shadow: inset 0 0 0 1px var(--card-border-color);
    pointer-events: none;
  }

  &[data-changed] {
    opacity: 0.45;
  }
`, Image$7 = styledComponents.styled.img`
  display: block;
  flex: 1;
  min-height: 0;
  object-fit: contain;
  width: 100%;
  height: 100%;

  &[data-action='removed'] {
    opacity: 0.45;
  }
`, HotspotDiff = styledComponents.styled.div`
  svg {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
`;
function ImagePreview$2(props2) {
  var _a2, _b, _c, _d;
  const { id: id2, action, diff: diff2, hotspot, crop, is: is2 } = props2, { t: t2 } = useTranslation(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), [imageError, setImageError] = React.useState(), { value: asset } = useDocumentValues(id2, ASSET_FIELDS), dimensions = assetUtils.getImageDimensions(id2), imageBuilder = React.useMemo(() => imageUrlBuilder__default.default(client2), [client2]), assetIsDeleted = asset === null, title = asset && asset.originalFilename, imageSource = imageBuilder.image(id2).height(190).dpr(getDeviceDpr()).fit("max"), assetChanged = ((_b = (_a2 = diff2.fromValue) == null ? void 0 : _a2.asset) == null ? void 0 : _b._ref) !== ((_d = (_c = diff2.toValue) == null ? void 0 : _c.asset) == null ? void 0 : _d._ref);
  let printAction;
  action && action !== "changed" && (printAction = t2(action === "added" ? "changes.added-label" : "changes.removed-label"));
  const metaAction = action === "changed" ? void 0 : action;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", flex: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, padding: 2, paddingBottom: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Flex,
      {
        as: ImageWrapper,
        direction: "column",
        "data-changed": is2 === "from" && assetChanged ? "" : void 0,
        "data-error": imageError ? "" : void 0,
        children: [
          !assetIsDeleted && !imageError && /* @__PURE__ */ jsxRuntime.jsx(
            Image$7,
            {
              src: imageSource.toString() || "",
              alt: title,
              "data-action": metaAction,
              onError: setImageError,
              width: dimensions.width,
              height: dimensions.height
            }
          ),
          (assetIsDeleted || imageError) && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, align: "center", children: t2(assetIsDeleted ? "changes.image.deleted" : "changes.image.error-loading-image") }) }),
          /* @__PURE__ */ jsxRuntime.jsx(HotspotDiff, { children: /* @__PURE__ */ jsxRuntime.jsx(
            HotspotCropSVG,
            {
              crop: crop && !assetUtils.isDefaultCrop(crop) ? crop : void 0,
              diff: diff2,
              hash: simpleHash(`${imageSource.toString() || ""}-${is2}`),
              hotspot: hotspot && !assetUtils.isDefaultHotspot(hotspot) ? hotspot : void 0,
              width: dimensions.width,
              height: dimensions.height
            }
          ) })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      MetaInfo,
      {
        title: title || t2("changes.image.meta-info-fallback-title"),
        icon: icons.ImageIcon,
        markRemoved: assetChanged && is2 === "from",
        children: printAction ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: printAction }) : /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
          dimensions.width,
          " \xD7 ",
          dimensions.height
        ] })
      }
    )
  ] });
}
const IMAGE_META_FIELDS = ["crop", "hotspot"], BASE_IMAGE_FIELDS = ["asset", ...IMAGE_META_FIELDS], CARD_STYLES = {
  flex: 1
}, ImageFieldDiff = ({ diff: diff2, schemaType }) => {
  var _a2, _b;
  const { t: t2 } = useTranslation(), { fromValue, toValue, fields, isChanged } = diff2, fromRef = (_a2 = fromValue == null ? void 0 : fromValue.asset) == null ? void 0 : _a2._ref, toRef = (_b = toValue == null ? void 0 : toValue.asset) == null ? void 0 : _b._ref, assetAnnotation = getAnnotationAtPath(diff2, ["asset", "_ref"]), changedFields = Object.keys(fields).filter(
    (name) => fields[name].isChanged && name !== "_type"
  ), nestedFields = schemaType.fields.filter(
    (field) => !BASE_IMAGE_FIELDS.includes(field.name) && changedFields.includes(field.name)
  ).map((field) => field.name);
  let assetAction = "changed";
  !fromRef && toRef ? assetAction = "added" : !toRef && fromRef && (assetAction = "removed");
  const didAssetChange = changedFields.includes("asset"), didCropChange = changedFields.includes("crop"), didHotspotChange = changedFields.includes("hotspot"), didMetaChange = didCropChange || didHotspotChange, showImageDiff = didAssetChange || didMetaChange, showMetaChange = didMetaChange && !didAssetChange, from = fromValue && fromRef ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: /* @__PURE__ */ jsxRuntime.jsx(
    ImagePreview$2,
    {
      is: "from",
      id: fromRef,
      diff: diff2,
      action: assetAction,
      hotspot: showMetaChange && didHotspotChange ? fromValue.hotspot : void 0,
      crop: showMetaChange && didCropChange ? fromValue.crop : void 0
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(NoImagePreview, {}), to = toValue && toRef ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: /* @__PURE__ */ jsxRuntime.jsx(
    ImagePreview$2,
    {
      is: "to",
      id: toRef,
      diff: diff2,
      hotspot: showMetaChange && didHotspotChange ? toValue.hotspot : void 0,
      crop: showMetaChange && didCropChange ? toValue.crop : void 0
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(NoImagePreview, {});
  if (!from && !to)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, align: "center", children: t2("changes.image.no-asset-set") }) });
  if (!isChanged)
    return toRef ? /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { annotation: assetAnnotation, style: CARD_STYLES, children: /* @__PURE__ */ jsxRuntime.jsx(ImagePreview$2, { id: toRef, is: "to", diff: diff2 }) }) : null;
  const imageDiff = /* @__PURE__ */ jsxRuntime.jsx(FromTo, { align: "center", from, layout: "grid", to });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    showImageDiff && (didAssetChange ? /* @__PURE__ */ jsxRuntime.jsx(
      DiffTooltip,
      {
        annotations: assetAnnotation ? [assetAnnotation] : [],
        description: getChangeDescription(assetAction, t2),
        children: imageDiff
      }
    ) : imageDiff),
    nestedFields.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: showImageDiff ? 4 : 3, children: /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType, fields: nestedFields }) })
  ] });
};
function getChangeDescription(action, t2) {
  switch (action) {
    case "changed":
      return t2("changes.changed-label");
    case "added":
      return t2("changes.added-label");
    case "removed":
      return t2("changes.removed-label");
    default:
      return "Unknown change";
  }
}
const NumberWrapper = styledComponents.styled.div`
  display: inline-block;
  word-break: break-all;
`, NumberPreview = (props2) => {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: NumberWrapper, paddingX: 2, paddingY: 1, children: value });
}, NumberFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  DiffFromTo,
  {
    diff: diff2,
    schemaType,
    previewComponent: NumberPreview,
    layout: "inline"
  }
), InlineBox$1 = styledComponents.styled(ui.Box)`
  &:not([hidden]) {
    display: inline;
    align-items: center;

    &[data-changed] {
      cursor: pointer;
    }
  }
`, InlineText$1 = styledComponents.styled(ui.Text)`
  &:not([hidden]) {
    display: inline;
    color: inherit;
  }
`, PreviewContainer$1 = styledComponents.styled(ui.Box)`
  &:not([hidden]) {
    display: inline-flex;
    align-items: center;

    ${InlineBox$1} [data-ui="Text"] {
      opacity: 0.5;
    }
  }
`, PopoverContainer$1 = styledComponents.styled(ui.Box)`
  min-width: 160px;
  max-height: 40vh;
  overflow-y: auto;
`, AnnotationWrapper = styledComponents.styled.div`
  text-decoration: none;
  display: inline;
  position: relative;
  border: 0;
  padding: 0;
  border-bottom: 2px dotted currentColor;
  box-shadow: inset 0 0 0 1px var(--card-border-color);
  white-space: nowrap;
  align-items: center;
  background-color: color(var(--card-fg-color) a(10%));

  &[data-changed] {
    cursor: pointer;
  }

  &[data-removed] {
    text-decoration: line-through;
  }

  &:hover ${PreviewContainer$1} {
    opacity: 1;
  }
`;
function Annotation$1({
  children,
  diff: diff2,
  object,
  schemaType,
  path,
  ...restProps
}) {
  const { t: t2 } = useTranslation();
  return schemaType ? diff2 && diff2.action !== "unchanged" ? /* @__PURE__ */ jsxRuntime.jsx(
    AnnnotationWithDiff,
    {
      ...restProps,
      diff: diff2,
      object,
      schemaType,
      path,
      children
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(AnnotationWrapper, { children }) : /* @__PURE__ */ jsxRuntime.jsx(AnnotationWrapper, { ...restProps, children: t2("changes.portable-text.unknown-annotation-schema-type") });
}
function AnnnotationWithDiff({
  diff: diff2,
  children,
  object,
  schemaType,
  path,
  ...restProps
}) {
  const { onSetFocus } = React.useContext(_singletons.ConnectorContext), { path: fullPath } = React.useContext(_singletons.DiffContext), [popoverElement, setPopoverElement] = React.useState(null), { t: t2 } = useTranslation(), color2 = useDiffAnnotationColor(diff2, []), style = React.useMemo(
    () => color2 ? { background: color2.background, color: color2.text } : {},
    [color2]
  ), isRemoved = diff2.action === "removed", [open, setOpen] = React.useState(!1), emptyObject = object && isEmptyObject(object), markDefPath = React.useMemo(
    () => [path[0]].concat(["markDefs", { _key: object._key }]),
    [object._key, path]
  ), prefix = React.useMemo(
    () => fullPath.slice(
      0,
      fullPath.findIndex((seg) => types.isKeySegment(seg) && seg._key === object._key)
    ),
    [fullPath, object._key]
  ), annotationPath = React.useMemo(() => prefix.concat(path), [path, prefix]), myPath = React.useMemo(() => prefix.concat(markDefPath), [markDefPath, prefix]), myValue = `field-${PathUtils.toString(myPath)}`, values2 = useReportedValues$1(), isEditing = React.useMemo(
    () => values2.filter(([p]) => p.startsWith(myValue)).length > 0,
    [myValue, values2]
  );
  React.useEffect(() => {
    !open && isEditing && (setOpen(!0), onSetFocus(myPath));
  }, [isEditing, myPath, onSetFocus, open]);
  const handleOpenPopup = React.useCallback(
    (event) => {
      event.stopPropagation(), setOpen(!0), isRemoved || (event.preventDefault(), onSetFocus(annotationPath), setTimeout(() => onSetFocus(myPath), 10));
    },
    [annotationPath, isRemoved, myPath, onSetFocus]
  ), handleClickOutside = React.useCallback(() => {
    isEditing || setOpen(!1);
  }, [isEditing]);
  ui.useClickOutside(handleClickOutside, [popoverElement]);
  const annotation = diff2.action !== "unchanged" && diff2.annotation || null, annotations = React.useMemo(() => annotation ? [annotation] : [], [annotation]), popoverContent = /* @__PURE__ */ jsxRuntime.jsx(_singletons.DiffContext.Provider, { value: { path: myPath }, children: /* @__PURE__ */ jsxRuntime.jsx(PopoverContainer$1, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
    emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("changes.portable-text.empty-object-annotation", {
      annotationType: schemaType.title || schemaType.name
    }) }),
    !emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType })
  ] }) }) });
  return /* @__PURE__ */ jsxRuntime.jsx(
    AnnotationWrapper,
    {
      ...restProps,
      onClick: handleOpenPopup,
      style,
      "data-changed": "",
      "data-removed": diff2.action === "removed" ? "" : void 0,
      children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Popover, { content: popoverContent, open, ref: setPopoverElement, portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(PreviewContainer$1, { paddingLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        DiffTooltip,
        {
          annotations,
          description: t2("changes.portable-text.annotation", { context: diff2.action }),
          children: /* @__PURE__ */ jsxRuntime.jsxs(InlineBox$1, { style: { display: "inline-flex" }, children: [
            /* @__PURE__ */ jsxRuntime.jsx("span", { children }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(InlineText$1, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) }) })
          ] })
        }
      ) }) })
    }
  );
}
const Quote = styledComponents.styled.blockquote`
  margin: 0;
`;
function Blockquote({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(Quote, { children }) });
}
const headingSizes = {
  h1: 2,
  h2: 1,
  h3: 0,
  h4: 0,
  h5: 0,
  h6: 0
}, StyledHeading = styledComponents.styled(ui.Heading)`
  &:not([hidden]) {
    display: inline;
    text-transform: none;
    margin: 0;

    &::before,
    &::after {
      content: unset;
    }
  }
`;
function Header$1({ style, children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(StyledHeading, { size: headingSizes[style], children });
}
const StyledParagraph = styledComponents.styled.div`
  text-transform: none;
  white-space: wrap;
  overflow-wrap: break-word;
  margin: 0;
`;
function Paragraph({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(StyledParagraph, { children });
}
const EMPTY_PATH = [];
function Block(props2) {
  var _a2, _b, _c;
  const { diff: diff2, block, children } = props2, color2 = useDiffAnnotationColor(diff2, EMPTY_PATH), { path: fullPath } = React.useContext(_singletons.DiffContext), { onSetFocus } = React.useContext(_singletons.ConnectorContext), { t: t2 } = useTranslation(), isRemoved = diff2.action === "removed";
  let returned = children;
  const handleClick = React.useCallback(
    (event) => {
      event.stopPropagation(), isRemoved || onSetFocus(fullPath);
    },
    [fullPath, isRemoved, onSetFocus]
  );
  block.style === "blockquote" ? returned = /* @__PURE__ */ jsxRuntime.jsx(Blockquote, { children: returned }) : block.style && isHeader(block) ? returned = /* @__PURE__ */ jsxRuntime.jsx(Header$1, { style: block.style, children: returned }) : returned = /* @__PURE__ */ jsxRuntime.jsx(Paragraph, { children: returned });
  let fromStyle;
  if (diff2.origin.action === "changed" && diff2.origin.fields.style && diff2.origin.fields.style.action === "changed" && diff2.origin.fields.style.annotation) {
    fromStyle = (_b = (_a2 = diff2 == null ? void 0 : diff2.origin) == null ? void 0 : _a2.fromValue) == null ? void 0 : _b.style;
    const style = color2 ? { background: color2.background, color: color2.text } : {};
    returned = /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        padding: 3,
        border: !0,
        radius: 2,
        style: { borderStyle: "dotted" },
        "diff-block-action": diff2.action,
        "data-block-note": `changed_from_style_${fromStyle || "undefined"}`,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            DiffTooltip,
            {
              annotations: [(_c = diff2.origin.fields.style) == null ? void 0 : _c.annotation],
              diff: diff2.origin.fields.style,
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: t2("changes.portable-text.block-style-changed", { fromStyle, toStyle: block.style }) })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style, children: returned })
        ] })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntime.jsx(
    "div",
    {
      onClick: handleClick,
      "data-diff-block-action": diff2.action,
      "data-block-note": `changed_from_style_${fromStyle || "undefined"}`,
      children: returned
    }
  );
}
const DecoratorWrapper = styledComponents.styled.span`
  display: inline;
  ${({ theme: theme2, decoration }) => {
  switch (decoration) {
    case "strong":
      return "font-weight: bold;";
    case "em":
      return "font-style: italic;";
    case "underline":
      return "text-decoration: underline;";
    case "overline":
      return "text-decoration: overline;";
    case "strike-through":
      return "text-decoration: line-through;";
    case "code":
      return `
          font-family: ${theme2.sanity.fonts.code.family};
          background: ${theme2.sanity.color.muted.default.enabled.bg};
        `;
    default:
      return "";
  }
}}
`;
function Decorator$1({ mark, children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(DecoratorWrapper, { decoration: mark, children });
}
const InlineObjectWrapper = styledComponents.styled(ui.Card)`
  &:not([hidden]) {
    display: inline;
    cursor: pointer;
    white-space: nowrap;
    align-items: center;

    &[data-removed] {
      text-decoration: line-through;
    }

    ${InlineBox$1} {
      display: inline-flex;
    }
  }
`;
function InlineObject$1({ diff: diff2, object, schemaType, ...restProps }) {
  const { t: t2 } = useTranslation();
  return schemaType ? diff2 ? /* @__PURE__ */ jsxRuntime.jsx(InlineObjectWithDiff, { ...restProps, diff: diff2, object, schemaType }) : /* @__PURE__ */ jsxRuntime.jsx(InlineObjectWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(Preview$1, { schemaType, value: object, layout: "inline" }) }) : /* @__PURE__ */ jsxRuntime.jsx(InlineObjectWrapper, { ...restProps, border: !0, radius: 1, children: t2("changes.portable-text.unknown-inline-object-schema-type", { schemaType: object._type }) });
}
function InlineObjectWithDiff({
  diff: diff2,
  object,
  path,
  schemaType,
  ...restProps
}) {
  const { path: fullPath } = React.useContext(_singletons.DiffContext), { onSetFocus } = React.useContext(_singletons.ConnectorContext), { t: t2 } = useTranslation(), color2 = useDiffAnnotationColor(diff2, []), style = React.useMemo(
    () => color2 ? { background: color2.background, color: color2.text } : {},
    [color2]
  ), [open, setOpen] = React.useState(!1), emptyObject = object && isEmptyObject(object), isRemoved = diff2.action === "removed", myPath = fullPath.slice(
    0,
    fullPath.findIndex((seg) => types.isKeySegment(seg) && seg._key === object._key)
  ).concat(path), myValue = `field-${PathUtils.toString(myPath)}`, isEditing = useReportedValues$1().filter(([p]) => p.startsWith(myValue)).length > 0, focusPath = fullPath.slice(0, -1).concat(path).concat([PathUtils.FOCUS_TERMINATOR]);
  React.useEffect(() => {
    isEditing && (setOpen(!0), onSetFocus(focusPath));
  }, [focusPath, isEditing, onSetFocus]);
  const handleOpenPopup = React.useCallback(
    (event) => {
      if (event.stopPropagation(), setOpen(!0), !isRemoved) {
        onSetFocus(focusPath);
        return;
      }
      event.preventDefault();
    },
    [focusPath, isRemoved, onSetFocus]
  ), handleClose = React.useCallback(() => {
    setOpen(!1);
  }, []), popoverContent = /* @__PURE__ */ jsxRuntime.jsx(_singletons.DiffContext.Provider, { value: { path: myPath }, children: /* @__PURE__ */ jsxRuntime.jsx(
    PopoverContent$1,
    {
      diff: diff2,
      emptyObject,
      onClose: handleClose,
      schemaType
    }
  ) }), annotation = diff2.action !== "unchanged" && diff2.annotation || null, annotations = annotation ? [annotation] : [];
  return /* @__PURE__ */ jsxRuntime.jsx(
    InlineObjectWrapper,
    {
      ...restProps,
      onClick: handleOpenPopup,
      style,
      "data-removed": diff2.action === "removed" ? "" : void 0,
      border: !0,
      radius: 2,
      children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Popover, { content: popoverContent, open, portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(PreviewContainer$1, { children: /* @__PURE__ */ jsxRuntime.jsx(
        DiffTooltip,
        {
          annotations,
          description: t2("changes.portable-text.inline-object", { context: diff2.action }),
          children: /* @__PURE__ */ jsxRuntime.jsxs(InlineBox$1, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(Preview$1, { schemaType, value: object, layout: "inline" }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(InlineText$1, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) }) })
          ] })
        }
      ) }) })
    }
  );
}
function PopoverContent$1({
  diff: diff2,
  emptyObject,
  onClose,
  schemaType
}) {
  const { t: t2 } = useTranslation(), [popoverElement, setPopoverElement] = React.useState(null);
  return ui.useClickOutside(onClose, [popoverElement]), /* @__PURE__ */ jsxRuntime.jsxs(PopoverContainer$1, { ref: setPopoverElement, padding: 3, children: [
    emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("changes.portable-text.empty-inline-object", {
      inlineObjectType: schemaType.title || schemaType.name
    }) }),
    !emptyObject && /* @__PURE__ */ jsxRuntime.jsx(ChangeList, { diff: diff2, schemaType })
  ] });
}
function Text({
  diff: diff2,
  childDiff,
  children,
  path,
  segment,
  ...restProps
}) {
  const diffWithFallback = diff2 || childDiff;
  return diffWithFallback && diffWithFallback.action !== "unchanged" && segment.action !== "unchanged" ? /* @__PURE__ */ jsxRuntime.jsx(TextWithDiff, { ...restProps, childDiff, diff: diff2, segment, path, children }) : /* @__PURE__ */ jsxRuntime.jsx(InlineBox$1, { children });
}
function TextWithDiff({ diff: diff2, childDiff, children, path, segment, ...restProps }) {
  const { onSetFocus } = React.useContext(_singletons.ConnectorContext), { path: fullPath } = React.useContext(_singletons.DiffContext), spanSegment = React.useMemo(() => path.slice(-2, 1)[0], [path]), { t: t2 } = useTranslation(), isRemoved = diff2 && diff2.action === "removed", focusPath = fullPath.slice(
    0,
    fullPath.findIndex(
      (seg) => types.isKeySegment(seg) && types.isKeySegment(spanSegment) && seg._key === spanSegment._key
    )
  ).concat(path), handleClick = React.useCallback(
    (event) => {
      event.stopPropagation(), isRemoved || (event.preventDefault(), onSetFocus(focusPath));
    },
    [focusPath, isRemoved, onSetFocus]
  ), diffWithFallback = diff2 && diff2.segments.find((rSeg) => rSeg.text === segment.text) || diff2 || childDiff, annotation = diffWithFallback && diffWithFallback.action !== "unchanged" && diffWithFallback.annotation || null, diffCard = annotation && segment.action !== "unchanged" ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation,
      as: segment.action === "removed" ? "del" : "ins",
      tooltip: { description: t2("changes.portable-text.text", { context: segment.action }) },
      children
    }
  ) : null;
  return /* @__PURE__ */ jsxRuntime.jsx(InlineBox$1, { ...restProps, onClick: handleClick, "data-changed": "", children: /* @__PURE__ */ jsxRuntime.jsx("span", { children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: diffCard || children }) }) });
}
const decoratorSymbolsStart = DECORATOR_SYMBOLS.map((set2) => set2[0]), decoratorSymbolsEnd = DECORATOR_SYMBOLS.map((set2) => set2[1]), annotationSymbolsStart = ANNOTATION_SYMBOLS.map((set2) => set2[0]), annotationSymbolsEnd = ANNOTATION_SYMBOLS.map((set2) => set2[1]), allSymbolsStart = decoratorSymbolsStart.concat(annotationSymbolsStart), allSymbolsEnd = decoratorSymbolsEnd.concat(annotationSymbolsEnd), allDecoratorSymbols = decoratorSymbolsStart.concat(decoratorSymbolsEnd), markRegex = new RegExp(`${allDecoratorSymbols.concat(allSymbolsEnd).join("|")}`, "g");
function PortableText(props2) {
  const { diff: diff2, schemaType } = props2, block = diff2.origin.toValue || diff2.origin.fromValue, { t: t2 } = useTranslation(), inlineObjects = React.useMemo(
    () => diff2.origin.toValue ? getInlineObjects(diff2.origin) : [],
    [diff2.origin]
  ), renderChild2 = React.useCallback(
    (ptDiffChild) => {
      const spanSchemaType = getChildSchemaType(schemaType.fields, ptDiffChild);
      let decoratorTypes = [];
      if (spanSchemaType) {
        decoratorTypes = getDecorators(spanSchemaType);
        const childrenDiff = diff2.fields.children, segments = childrenDiff.items[0].diff && childrenDiff.items[0].diff.type === "object" && childrenDiff.items[0].diff.fields.text.type === "string" && childrenDiff.items[0].diff.fields.text.segments || [], returnedChildren = [], annotationSegments = {};
        if (isEmptyTextChange(block, diff2) && (diff2.origin.action === "added" || diff2.origin.action === "removed")) {
          const textDiff = findChildDiff(diff2.origin, block.children[0]) || diff2.origin;
          if (textDiff && textDiff.action !== "unchanged")
            return /* @__PURE__ */ jsxRuntime.jsx(
              DiffCard,
              {
                annotation: textDiff.annotation,
                as: textDiff.action === "removed" ? "del" : "ins",
                tooltip: {
                  description: t2("changes.portable-text.empty-text", { context: textDiff.action })
                },
                children: /* @__PURE__ */ jsxRuntime.jsx("span", { children: EMPTY_BLOCK_SYMBOL })
              },
              `empty-block-${block._key}`
            );
        }
        let childToIndex = -1, segIndex = -1;
        const activeAnnotations = [];
        let endedAnnotation;
        const allMarkDefs = getAllMarkDefs(diff2.origin);
        return segments.forEach((seg) => {
          var _a2, _b, _c;
          segIndex++;
          const isInline = INLINE_SYMBOLS.includes(seg.text), isMarkStart = allSymbolsStart.includes(seg.text), isMarkEnd = allSymbolsEnd.includes(seg.text), isChildStart = seg.text === CHILD_SYMBOL$1, isRemoved = seg.action === "removed";
          if (isChildStart)
            isRemoved || childToIndex++;
          else if (isMarkStart || isMarkEnd) {
            if (isMarkStart && annotationSymbolsStart.includes(seg.text)) {
              const object = allMarkDefs[annotationSymbolsStart.indexOf(seg.text)];
              object && activeAnnotations.push({
                mark: object._key,
                symbols: [
                  seg.text,
                  annotationSymbolsEnd[annotationSymbolsStart.indexOf(seg.text)]
                ],
                object
              });
            }
            isMarkEnd && annotationSymbolsEnd.includes(seg.text) && (endedAnnotation = activeAnnotations.pop());
          } else if (isInline) {
            const indexOfSymbol = INLINE_SYMBOLS.findIndex((sym) => sym === seg.text), key = (_a2 = inlineObjects[indexOfSymbol]) == null ? void 0 : _a2._key, originChild = inlineObjects[indexOfSymbol];
            if (key) {
              const objectSchemaType = getChildSchemaType(schemaType.fields, originChild), objectDiff = findChildDiff(diff2.origin, originChild);
              returnedChildren.push(
                /* @__PURE__ */ jsxRuntime.jsx(
                  InlineObject$1,
                  {
                    object: originChild,
                    path: [{ _key: block._key }, "children", { _key: originChild._key }],
                    diff: objectDiff,
                    schemaType: objectSchemaType
                  },
                  `inline-object-${originChild._key}`
                )
              );
            }
          } else if (seg.text) {
            const getChildFromFromValue = () => {
              var _a22;
              return (_a22 = diff2.origin.fromValue) == null ? void 0 : _a22.children.find(
                (cld) => cld.text && cld.text.match(escapeRegExp(seg.text))
              );
            }, child = block.children[childToIndex] || getChildFromFromValue(), childDiff = child && findSpanDiffFromChild(diff2.origin, child);
            if (!child)
              throw new Error("Could not find child");
            const textDiff = (_b = childDiff == null ? void 0 : childDiff.fields) != null && _b.text ? (_c = childDiff == null ? void 0 : childDiff.fields) == null ? void 0 : _c.text : void 0, text = /* @__PURE__ */ jsxRuntime.jsx(
              Text,
              {
                diff: textDiff,
                path: [{ _key: block._key }, "children", { _key: child._key }],
                childDiff,
                segment: seg,
                children: renderTextSegment({
                  diff: diff2,
                  child,
                  decoratorTypes,
                  seg,
                  segIndex,
                  spanSchemaType,
                  t: t2
                })
              },
              `text-${child._key}-${segIndex}`
            );
            if (activeAnnotations.length > 0 && activeAnnotations.forEach((active) => {
              annotationSegments[active.mark] = annotationSegments[active.mark] || [], annotationSegments[active.mark].push(text);
            }), endedAnnotation) {
              const key = `annotation-${endedAnnotation.object._key}`, lastChild = returnedChildren[returnedChildren.length - 1];
              if (lastChild && lastChild.key !== key) {
                const annotationDiff = findAnnotationDiff(diff2.origin, endedAnnotation.mark), objectSchemaType = endedAnnotation && spanSchemaType.annotations && spanSchemaType.annotations.find(
                  (type) => endedAnnotation && endedAnnotation.object && type.name === endedAnnotation.object._type
                );
                returnedChildren.push(
                  /* @__PURE__ */ jsxRuntime.jsx(
                    Annotation$1,
                    {
                      object: endedAnnotation.object,
                      diff: annotationDiff,
                      path: [{ _key: block._key }, "children", { _key: child._key }],
                      schemaType: objectSchemaType,
                      children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: annotationSegments[endedAnnotation.mark] })
                    },
                    key
                  )
                );
              }
              endedAnnotation = void 0;
            }
            activeAnnotations.length === 0 && returnedChildren.push(text);
          }
        }), React.createElement("div", { key: block._key }, ...returnedChildren);
      }
      throw new Error("'span' schemaType not found");
    },
    [block, diff2, inlineObjects, schemaType, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Block, { block: diff2.displayValue, diff: diff2, children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: (diff2.displayValue.children || []).map((child) => renderChild2(child)) }) });
}
function renderTextSegment({
  diff: diff2,
  child,
  decoratorTypes,
  seg,
  segIndex,
  spanSchemaType,
  t: t2
}) {
  if (seg.text === `
`)
    return /* @__PURE__ */ jsxRuntime.jsx("br", {});
  let children = /* @__PURE__ */ jsxRuntime.jsx("span", { children: seg.text.replace(/ /g, TRAILING_SPACE_SYMBOL) }, `text-${segIndex}`);
  const spanDiff = child && findSpanDiffFromChild(diff2.origin, child), activeMarks = types.isPortableTextSpan(child) ? child.marks || [] : [];
  return spanDiff && (children = renderDecorators({
    activeMarks,
    decoratorTypes,
    diff: diff2,
    children,
    seg,
    segIndex,
    spanDiff,
    spanSchemaType,
    t: t2
  })), activeMarks && activeMarks.length > 0 && activeMarks.forEach((mark) => {
    isDecorator(mark, spanSchemaType) && (children = // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ jsxRuntime.jsx(Decorator$1, { mark, children }, `decorator-${mark}-${child._key}-${segIndex}`));
  }), children;
}
function renderDecorators({
  activeMarks,
  decoratorTypes,
  diff: diff2,
  children,
  seg,
  segIndex,
  spanDiff,
  spanSchemaType,
  t: t2
}) {
  var _a2;
  let returned = /* @__PURE__ */ jsxRuntime.jsx("span", { children }, `text-segment-${segIndex}`);
  const fromPtDiffText = diff2.origin.fromValue && diff2.fromValue && diff2.fromValue.children[0].text || "", indirectMarksAnnotation = spanDiff && spanDiff.action !== "unchanged" && spanDiff.annotation || void 0, marksDiff = (_a2 = spanDiff == null ? void 0 : spanDiff.fields) == null ? void 0 : _a2.marks, marksAnnotation = marksDiff && marksDiff.action !== "unchanged" && marksDiff.annotation || indirectMarksAnnotation;
  let marksChanged = [];
  const ptDiffMatchString = fromPtDiffText.split(CHILD_SYMBOL$1).filter((text) => !!text).join(""), controlString = ptDiffMatchString.slice(
    0,
    Math.max(0, ptDiffMatchString.indexOf(seg.text) + seg.text.length)
  ), toTest = controlString.slice(0, Math.max(0, controlString.indexOf(seg.text))), marks = [];
  return [...toTest.matchAll(markRegex)].forEach((match) => {
    var _a22;
    const sym = match[0], set2 = DECORATOR_SYMBOLS.concat(ANNOTATION_SYMBOLS).find(
      (aSet) => aSet.indexOf(sym) > -1
    );
    if (set2) {
      const isMarkStart = sym === set2[0], mark = ((_a22 = decoratorTypes[isMarkStart ? decoratorSymbolsStart.indexOf(sym) : decoratorSymbolsEnd.indexOf(sym)]) == null ? void 0 : _a22.value) || sym;
      toTest.lastIndexOf(sym) > toTest.lastIndexOf(set2[1]) && marks.push(mark);
    }
  }), marksChanged = xor__default.default(activeMarks, uniq__default.default(marks)), marksAnnotation && marksChanged.length > 0 && marksChanged.some((m) => isDecorator(m, spanSchemaType)) && (returned = /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation: marksAnnotation,
      as: "ins",
      tooltip: {
        description: t2("changes.portable-text.changed-formatting")
      },
      children: returned
    },
    `diffcard-annotation-${segIndex}-${marksChanged.join("-")}`
  )), returned;
}
function isEmptyTextChange(block, diff2) {
  return block.children.length === 1 && block.children[0]._type === "span" && typeof block.children[0].text == "string" && block.children[0].text === "" && diff2.origin.action !== "unchanged";
}
const PTDiff = (props2) => {
  const { diff: diff2, schemaType } = props2, ptDiff = React.useMemo(() => createPortableTextDiff(diff2, schemaType), [diff2, schemaType]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", { "data-diff-action": diff2.action, children: /* @__PURE__ */ jsxRuntime.jsx(PortableText, { diff: ptDiff, schemaType }) });
}, ReferenceWrapper = styledComponents.styled.div`
  word-wrap: break-word;
`, ReferencePreview$1 = ({ value, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: ReferenceWrapper, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(Preview$1, { schemaType, value, layout: "default" }) }), ReferenceFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  DiffFromTo,
  {
    align: "center",
    diff: diff2,
    layout: "grid",
    path: "_ref",
    previewComponent: ReferencePreview$1,
    schemaType
  }
), StringWrapper$1 = styledComponents.styled.div`
  display: inline-block;
  word-break: break-all;
  white-space: pre-wrap;
`, StringPreview = (props2) => {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: StringWrapper$1, paddingX: 2, paddingY: 1, children: value });
}, StringWrapper = styledComponents.styled.div`
  white-space: pre-wrap;
  word-wrap: break-word;
`, StringFieldDiff = ({ diff: diff2, schemaType }) => {
  const { options } = schemaType;
  return options != null && options.list ? /* @__PURE__ */ jsxRuntime.jsx(DiffFromTo, { diff: diff2, previewComponent: StringPreview, schemaType }) : /* @__PURE__ */ jsxRuntime.jsx(StringWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(DiffString, { diff: diff2 }) });
}, defaultComponents = {
  block: PTDiff,
  boolean: { component: BooleanFieldDiff, showHeader: !1 },
  date: DatetimeFieldDiff,
  datetime: DatetimeFieldDiff,
  file: FileFieldDiff,
  image: ImageFieldDiff,
  number: NumberFieldDiff,
  reference: ReferenceFieldDiff,
  string: StringFieldDiff
};
function resolveDiffComponent(type, parentSchemaType) {
  var _a2;
  let itType = type;
  for (; itType; ) {
    const resolved = ((_a2 = itType == null ? void 0 : itType.components) == null ? void 0 : _a2.diff) || tryResolve(itType, parentSchemaType) || defaultComponents[itType.name];
    if (resolved)
      return resolved;
    itType = itType.type;
  }
  const defaultComponentKey = ["date", "datetime"].includes(type.name) ? type.name : type.jsonType;
  return defaultComponents[defaultComponentKey];
}
function tryResolve(schemaType, parentSchemaType) {
  const resolvers = diffResolvers;
  let resolved;
  for (const resolver of resolvers) {
    if (typeof resolver != "function") {
      console.error("Diff component resolver is not a function: ", resolver);
      continue;
    }
    if (resolved = resolver({ schemaType, parentSchemaType }), resolved)
      return resolved;
  }
}
function buildChangeList(schemaType, diff2, path = [], titlePath = [], context = {}) {
  if (!resolveDiffComponent(schemaType, context.parentSchema)) {
    if (schemaType.jsonType === "object" && diff2.type === "object")
      return buildObjectChangeList(schemaType, diff2, path, titlePath, context);
    if (schemaType.jsonType === "array" && diff2.type === "array")
      return buildArrayChangeList(schemaType, diff2, path, titlePath);
  }
  return getFieldChange(schemaType, diff2, path, titlePath, context);
}
function buildObjectChangeList(schemaType, diff2, path = [], titlePath = [], diffContext = {}) {
  const changes = [], childContext = { ...diffContext, parentSchema: schemaType }, fieldSets = schemaType.fieldsets || schemaType.fields.map((field) => ({ single: !0, field }));
  for (const fieldSet of fieldSets)
    fieldSet.single ? changes.push(...buildFieldChange(fieldSet.field, diff2, path, titlePath, childContext)) : changes.push(
      ...buildFieldsetChangeList(fieldSet, diff2, path, titlePath, childContext)
    );
  return changes.length < 2 ? changes : [
    {
      type: "group",
      key: pathToString$1(path) || "root",
      path,
      titlePath,
      changes: reduceTitlePaths(changes, titlePath.length),
      schemaType
    }
  ];
}
function buildFieldChange(field, diff2, path, titlePath, diffContext = {}) {
  const { fieldFilter, ...context } = diffContext, fieldDiff = diff2.fields[field.name];
  if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name))
    return [];
  const fieldPath = path.concat([field.name]), fieldTitlePath = titlePath.concat([field.type.title || field.name]);
  return buildChangeList(field.type, fieldDiff, fieldPath, fieldTitlePath, context);
}
function buildFieldsetChangeList(fieldSet, diff2, path, titlePath, diffContext = {}) {
  const { fields, name, title, readOnly, hidden } = fieldSet, { fieldFilter, ...context } = diffContext, fieldSetHidden = hidden, fieldsetReadOnly = readOnly, fieldSetTitlePath = titlePath.concat([title || name]), changes = [];
  for (const field of fields) {
    const fieldDiff = diff2.fields[field.name];
    if (!fieldDiff || !fieldDiff.isChanged || fieldFilter && !fieldFilter.includes(field.name))
      continue;
    const fieldPath = path.concat([field.name]), fieldTitlePath = fieldSetTitlePath.concat([field.type.title || field.name]);
    changes.push(
      ...buildChangeList(
        {
          readOnly: fieldsetReadOnly,
          hidden: fieldSetHidden,
          ...field.type
        },
        fieldDiff,
        fieldPath,
        fieldTitlePath,
        context
      )
    );
  }
  return changes.length < 2 ? changes : [
    {
      type: "group",
      key: pathToString$1(path) || "root",
      fieldsetName: name,
      path,
      titlePath: fieldSetTitlePath,
      changes: reduceTitlePaths(changes, fieldSetTitlePath.length),
      readOnly: fieldsetReadOnly,
      hidden: fieldSetHidden
    }
  ];
}
function buildArrayChangeList(schemaType, diff2, path = [], titlePath = []) {
  const changedOrMoved = diff2.items.filter(
    (item) => item.hasMoved && item.fromIndex !== item.toIndex || item.diff.action !== "unchanged"
  );
  if (changedOrMoved.length === 0)
    return [];
  const isPortableText2 = hasPTMemberType(schemaType), list = [], changes = changedOrMoved.reduce((acc, itemDiff) => {
    const memberTypes = getArrayDiffItemType(itemDiff.diff, schemaType), memberType = memberTypes.toType || memberTypes.fromType;
    if (!memberType)
      return console.warn("Could not determine schema type for item at %s", pathToString$1(path)), acc;
    const segment = getItemKeySegment(itemDiff.diff.fromValue) || getItemKeySegment(itemDiff.diff.toValue) || diff2.items.indexOf(itemDiff), itemPath = path.concat(segment), itemContext = { itemDiff, parentDiff: diff2, parentSchema: schemaType }, itemTitlePath = titlePath.concat({
      hasMoved: itemDiff.hasMoved,
      toIndex: itemDiff.toIndex,
      fromIndex: itemDiff.fromIndex,
      annotation: itemDiff.diff.action === "unchanged" ? itemDiff.annotation : itemDiff.diff.annotation
    }), attachItemDiff = (change) => (change.type === "field" && pathsAreEqual(itemPath, change.path) && (change.itemDiff = itemDiff), change), children = buildChangeList(
      memberType,
      itemDiff.diff,
      itemPath,
      itemTitlePath,
      itemContext
    ).map(attachItemDiff);
    return isPortableText2 && children.filter(isFieldChange).forEach((field, index, siblings) => {
      field.showHeader = siblings.length === 1, field.showIndex = itemDiff.fromIndex !== itemDiff.toIndex && itemDiff.hasMoved;
    }), children.length === 0 ? acc.push(...getFieldChange(memberType, itemDiff.diff, itemPath, itemTitlePath, itemContext)) : acc.push(...children), acc;
  }, list);
  return changes.length > 1 ? [
    {
      type: "group",
      key: pathToString$1(path) || "root",
      path,
      titlePath,
      changes: reduceTitlePaths(changes, titlePath.length),
      schemaType
    }
  ] : changes;
}
function getFieldChange(schemaType, diff2, path, titlePath, { itemDiff, parentDiff, parentSchema } = {}) {
  const { fromValue, toValue, type } = diff2;
  if (type === "array" && isEmpty(fromValue) && isEmpty(toValue))
    return [];
  let error;
  typeof fromValue < "u" && (error = getValueError(fromValue, schemaType)), !error && typeof toValue < "u" && (error = getValueError(toValue, schemaType));
  let showHeader = !0, component;
  const diffComponent = resolveDiffComponent(schemaType, parentSchema);
  return diffComponent && typeof diffComponent == "function" ? component = diffComponent : diffComponent && (component = diffComponent.component, showHeader = typeof diffComponent.showHeader > "u" ? showHeader : diffComponent.showHeader), [
    {
      type: "field",
      diff: diff2,
      path,
      error,
      itemDiff,
      parentDiff,
      titlePath,
      schemaType,
      showHeader,
      showIndex: !0,
      key: pathToString$1(path) || "root",
      diffComponent: error ? void 0 : component,
      parentSchema
    }
  ];
}
function reduceTitlePaths(changes, byLength = 1) {
  return changes.map((change) => (change.titlePath = change.titlePath.slice(byLength), change));
}
function isEmpty(item) {
  return Array.isArray(item) && item.length === 0 || item === null || typeof item > "u";
}
const isAddedAction = (change) => change.type === "field" && change.diff.action === "added", flattenChangeNode = (changeNode) => {
  if (changeNode.type !== "group")
    return [changeNode];
  const newSubChanges = [];
  return changeNode.changes.forEach((cChange) => {
    newSubChanges.push(...flattenChangeNode(cChange));
  }), newSubChanges;
}, isSubpathOf = (subPath, parentPath) => {
  if (parentPath.length >= subPath.length)
    return !1;
  for (let i = 0; i < parentPath.length; i++)
    if (parentPath[i] !== subPath[i])
      return !1;
  return !0;
}, pathSegmentOfCorrectType = (item, child) => {
  const nextItem = item[child], key = getItemKey$1(nextItem);
  return key ? { _key: key } : Array.isArray(item) ? parseInt(child, 10) : child;
}, diffOptions = {
  diffMatchPatch: { enabled: !1, lengthThresholdAbsolute: 30, lengthThresholdRelative: 1.2 }
};
function undoChange(change, rootDiff, documentOperations) {
  if (!rootDiff)
    return;
  const patches = [];
  if (change.type === "group") {
    const allChanges = flattenChangeNode(change), unsetChanges = allChanges.filter(isAddedAction);
    allChanges.filter((child) => !isAddedAction(child)).forEach((child) => undoChange(child, rootDiff, documentOperations)), patches.push(
      ...buildUnsetPatches(rootDiff, unsetChanges.map((unsetChange) => unsetChange.path).reverse())
    );
  } else change.diff.action === "added" ? patches.push(...buildUnsetPatches(rootDiff, [change.path])) : change.type === "field" && change.itemDiff && change.parentDiff && change.parentDiff.type === "array" && change.itemDiff.hasMoved ? patches.push(...buildMovePatches(change.itemDiff, change.parentDiff, change.path)) : patches.push(...buildUndoPatches(change.diff, rootDiff, change.path));
  documentOperations.patch.execute(patches);
}
function buildUnsetPatch(rootDiff, path, concurrentUnsetPaths) {
  const previousValue = rootDiff.toValue;
  return furthestEmptyAncestor(previousValue, path, concurrentUnsetPaths);
}
function buildUnsetPatches(rootDiff, paths) {
  const patches = [];
  for (let i = 0; i < paths.length; i++)
    patches.some((patch2) => isSubpathOf(paths[i], patch2)) || patches.push(buildUnsetPatch(rootDiff, paths[i], paths));
  return [{ unset: [...new Set(patches.map(pathToString$1))] }];
}
function furthestEmptyAncestor(previousValue, currentPath, ignorePaths = [], initialPath) {
  if (currentPath.length <= 0)
    throw new Error("Root has no ancestor");
  const ancestorPath = currentPath.slice(0, -1), ancestorValue = getValueAtPath(previousValue, ancestorPath), updatedIgnorePaths = [
    ancestorPath,
    /*
     * We can filter out all the subpaths from under this ancestor
     * because since we ignore it higher up in the tree it doesn't
     * matter anymore what the values of subpaths are.
     */
    ...ignorePaths.filter((path) => !isSubpathOf(path, ancestorPath))
  ];
  return isStub(ancestorValue, ancestorPath, ignorePaths) ? furthestEmptyAncestor(previousValue, ancestorPath, updatedIgnorePaths) : currentPath;
}
function buildMovePatches(itemDiff, parentDiff, path) {
  const basePath = path.slice(0, -1), { parentValue, fromIndex, fromValue } = getFromItem(parentDiff, itemDiff);
  let insertLocation;
  if (fromIndex === 0)
    insertLocation = { before: pathToString$1([...basePath, 0]) };
  else {
    const prevIndex = fromIndex - 1, prevSegment = getItemKeySegment(parentValue[prevIndex]) || prevIndex;
    insertLocation = { after: pathToString$1([...basePath, prevSegment]) };
  }
  return [
    {
      unset: [pathToString$1(path)]
    },
    {
      insert: { ...insertLocation, items: [fromValue] }
    }
  ];
}
function buildUndoPatches(diff2, rootDiff, path) {
  const patches = sanityDiffPatch.diffItem(diff2.toValue, diff2.fromValue, diffOptions, path), inserts = patches.filter((patch2) => patch2.op === "insert").map(({ after, items }) => ({ insert: { after: pathToString$1(after), items } })), unsets = patches.filter((patch2) => patch2.op === "unset").reduce((acc, patch2) => acc.concat(pathToString$1(patch2.path)), []), stubbedPaths = /* @__PURE__ */ new Set(), stubs = [];
  let hasSets = !1;
  const sets = patches.filter((patch2) => patch2.op === "set").reduce(
    (acc, patch2) => (hasSets = !0, stubs.push(...getParentStubs(patch2.path, rootDiff, stubbedPaths)), acc[pathToString$1(patch2.path)] = patch2.value, acc),
    {}
  );
  return [
    ...stubs,
    ...inserts,
    ...unsets.length > 0 ? [{ unset: unsets }] : [],
    ...hasSets ? [{ set: sets }] : []
  ];
}
function getParentStubs(path, rootDiff, stubbed) {
  const value = rootDiff.fromValue, nextValue = rootDiff.toValue, stubs = [];
  for (let i = 1; i <= path.length; i++) {
    const subPath = path.slice(0, i), pathStr = pathToString$1(subPath);
    if (stubbed.has(pathStr))
      continue;
    const nextSegment = path[i], nextIsArrayElement = types.isKeySegment(nextSegment) || types.isIndexSegment(nextSegment), itemValue = getValueAtPath(value, subPath), stub = getStubValue(itemValue);
    if (nextIsArrayElement && Array.isArray(itemValue) && !getValueAtPath(nextValue, path.slice(0, i + 1))) {
      const indexAtPrev = findIndex(itemValue, nextSegment), prevItem = itemValue[indexAtPrev - 1], nextItem = getValueAtPath(value, subPath.concat(nextSegment)), prevSeg = types.isKeyedObject(prevItem) ? { _key: prevItem._key } : indexAtPrev - 1, after = pathToString$1(subPath.concat(indexAtPrev < 1 ? 0 : prevSeg));
      stubs.push({ setIfMissing: { [pathStr]: [] } }), stubs.push({ insert: { after, items: [getStubValue(nextItem)] } }), i++;
      continue;
    }
    typeof stub > "u" || (stubbed.add(pathStr), stubs.push({ setIfMissing: { [pathStr]: stub } }));
  }
  return stubs;
}
function onlyContainsStubs(item, path, ignorePaths) {
  if (!isRecord$4(item) || !Array.isArray(item))
    return !1;
  for (const child in item) {
    if (!Object.prototype.hasOwnProperty.call(item, child) || child === "_type" || child === "_key")
      continue;
    const nextPath = [...path, pathSegmentOfCorrectType(item, child)];
    if (!isStub(item[child], nextPath, ignorePaths))
      return !1;
  }
  return !0;
}
function isStub(item, path, ignorePaths) {
  const isIgnoredPath = ignorePaths == null ? void 0 : ignorePaths.some(
    (ignorePath) => pathToString$1(ignorePath) === pathToString$1(path)
  ), isEmptyArray2 = Array.isArray(item) && item.length <= 0;
  return isIgnoredPath || item === void 0 || item === null || isEmptyArray2 || isEmptyObject$1(item) || onlyContainsStubs(item, path, ignorePaths);
}
function getStubValue(item) {
  if (Array.isArray(item))
    return [];
  if (typeof item != "object" || item === null)
    return;
  const props2 = {};
  return types.isKeyedObject(item) && (props2._key = item._key), types.isTypedObject(item) && (props2._type = item._type), props2;
}
function getFromItem(parentDiff, itemDiff) {
  if (parentDiff.fromValue && typeof itemDiff.fromIndex == "number") {
    const fromValue = parentDiff.fromValue[itemDiff.fromIndex];
    return {
      parentValue: parentDiff.fromValue,
      fromIndex: itemDiff.fromIndex,
      fromValue
    };
  }
  throw new Error(`Failed to find item at index ${itemDiff.fromIndex}`);
}
const ChangeListWrapper$1 = styledComponents.styled.div`
  display: grid;
  grid-template-columns: minmax(0, 1fr);
`, isDev = process.env.NODE_ENV !== "production", isProd = !isDev;
var __defProp$d = Object.defineProperty, __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$d = (obj, key, value) => __defNormalProp$d(obj, key + "", value);
class DiffErrorBoundary extends React.Component {
  constructor() {
    super(...arguments), __publicField$d(this, "state", {});
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  // eslint-disable-next-line class-methods-use-this
  componentDidCatch(error) {
    console.error("Error rendering diff component: "), console.error(error);
  }
  render() {
    const { t: t2 } = this.props, { error } = this.state;
    return error ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { paddingLeft: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h3", size: 1, weight: "medium", children: t2("changes.error-boundary.title") }),
        isDev && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: t2("changes.error-boundary.developer-info") }) })
      ] })
    ] }) }) : this.props.children;
  }
}
const arrowComponents = {
  down: icons.ArrowDownIcon,
  right: icons.ArrowRightIcon
};
function FromToArrow(props2) {
  const { direction = "right", ...restProps } = props2, arrowComponent = arrowComponents[direction];
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, ...restProps, children: React.createElement(arrowComponent) });
}
const CodeWrapper$1 = styledComponents.styled.pre`
  overflow-x: auto;
  position: relative;
`, Meta = styledComponents.styled.div`
  position: absolute;
  top: 0;
  right: 0;
`;
function DiffInspectWrapper(props2) {
  const { children, as, change, ...restProps } = props2, isHovering = React.useRef(!1), [isInspecting, setIsInspecting] = React.useState(!1), toggleInspect = React.useCallback(() => setIsInspecting((state) => !state), [setIsInspecting]), handleMouseEnter = React.useCallback(() => isHovering.current = !0, []), handleMouseLeave = React.useCallback(() => isHovering.current = !1, [isHovering]);
  return React.useEffect(() => {
    function onKeyDown(evt) {
      const { metaKey, key } = evt;
      metaKey && key === "i" && isHovering.current && toggleInspect();
    }
    return window.addEventListener("keydown", onKeyDown, !1), () => window.removeEventListener("keydown", onKeyDown, !1);
  }, [toggleInspect]), /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...restProps, children: isInspecting ? /* @__PURE__ */ jsxRuntime.jsx(DiffInspector, { change }) : children });
}
const MetaLabel = ({ title }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, display: "inline-block", as: Meta, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: title }) });
function DiffInspector({ change }) {
  var _a2, _b, _c;
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { padding: 3, tone: "transparent", as: CodeWrapper$1, radius: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(MetaLabel, { title: t2("changes.inspector.meta-label") }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: printMeta({
        path: pathToString$1(change.path),
        fromIndex: (_a2 = change.itemDiff) == null ? void 0 : _a2.fromIndex,
        toIndex: (_b = change.itemDiff) == null ? void 0 : _b.toIndex,
        hasMoved: (_c = change.itemDiff) == null ? void 0 : _c.hasMoved,
        action: change.diff.action,
        isChanged: change.diff.isChanged
      }) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { as: CodeWrapper$1, tone: "critical", padding: 3, radius: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(MetaLabel, { title: t2("changes.inspector.from-label") }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: jsonify(change.diff.fromValue) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(FromToArrow, { direction: "down", align: "center" }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { as: CodeWrapper$1, tone: "positive", padding: 3, radius: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(MetaLabel, { title: t2("changes.inspector.to-label") }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: jsonify(change.diff.toValue) })
    ] })
  ] });
}
function jsonify(value) {
  return typeof value > "u" ? "undefined" : JSON.stringify(value, null, 2);
}
function printMeta(keys) {
  const lines = [];
  return Object.entries(keys).forEach(([key, value]) => {
    typeof value < "u" && value !== null && lines.push(`${key}: ${value}`);
  }), lines.join(`
`);
}
function useChangeVerb(diff2) {
  const { t: t2 } = useTranslation(), hadPrevValue = hasValue(diff2.fromValue), hasNextValue = hasValue(diff2.toValue);
  return t2(!hadPrevValue && hasNextValue ? "changes.added-label" : !hasNextValue && hadPrevValue ? "changes.removed-label" : "changes.changed-label");
}
function hasValue(value) {
  return value !== null && typeof value < "u" && value !== "";
}
const INLINE_COLUMN_STYLES = { flexShrink: 0 }, BLOCK_COLUMN_STYLES = { alignItems: "stretch" }, FLEX_ALIGN = {
  top: "flex-start",
  center: "center",
  bottom: "flex-end",
  default: "flex-start"
}, FromTo = React.forwardRef(function(props2, ref) {
  const { align: align2 = "top", layout = "inline", from, to, style, ...restProps } = props2, theme2 = ui.useTheme(), Layout2 = layout === "inline" ? ui.Flex : ui.Grid, layoutStyles = React.useMemo(
    () => ({
      ...style,
      ...layout === "inline" ? { maxWidth: "100%", display: "inline-flex" } : { gridTemplateColumns: `minmax(0, 1fr) ${ui.rem(theme2.sanity.space[5])} minmax(0, 1fr)` }
    }),
    [layout, style, theme2]
  ), columnStyles = layout === "inline" ? INLINE_COLUMN_STYLES : BLOCK_COLUMN_STYLES;
  return /* @__PURE__ */ jsxRuntime.jsxs(Layout2, { ...restProps, ref, style: layoutStyles, "data-from-to-layout": !0, children: [
    from && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: FLEX_ALIGN[align2], style: columnStyles, children: from }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FromToArrow, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: FLEX_ALIGN[align2], style: columnStyles, children: to })
  ] });
}), cardStyles = {
  flex: 1,
  minWidth: 0,
  display: "block",
  whiteSpace: "break-spaces"
};
function DiffFromTo(props2) {
  const { align: align2, cardClassName, diff: diff2, layout, path, previewComponent, schemaType } = props2, { action } = diff2, changeVerb = useChangeVerb(diff2);
  if (action === "unchanged")
    return /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { className: cardClassName, style: cardStyles, children: React.createElement(previewComponent, { schemaType, value: diff2.toValue }) });
  const from = diff2.fromValue !== void 0 && diff2.fromValue !== null && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "del", className: cardClassName, diff: diff2, path, style: cardStyles, children: React.createElement(previewComponent, { schemaType, value: diff2.fromValue }) }), to = diff2.toValue !== void 0 && diff2.toValue !== null && /* @__PURE__ */ jsxRuntime.jsx(DiffCard, { as: "ins", className: cardClassName, diff: diff2, path, style: cardStyles, children: React.createElement(previewComponent, { schemaType, value: diff2.toValue }) });
  return from && !to ? /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { description: changeVerb, diff: diff2, path, children: from }) : !from && to ? /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { description: changeVerb, diff: diff2, path, children: to }) : /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { description: changeVerb, diff: diff2, path, children: /* @__PURE__ */ jsxRuntime.jsx(FromTo, { align: align2, from, layout, to }) });
}
const FallbackPreview = ({ value, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(Preview$1, { schemaType, value, layout: "default" }) }), FallbackDiff = (props2) => {
  const { diff: diff2, schemaType } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    DiffFromTo,
    {
      diff: diff2,
      schemaType,
      previewComponent: FallbackPreview,
      layout: "grid"
    }
  );
}, FieldChangeContainer = styledComponents.styled.div`
  --field-change-error: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
  &[data-revert-all-changes-hover] [data-revert-all-hover]::before {
    border-left: 2px solid var(--field-change-error);
  }
`, DiffBorder = styledComponents.styled.div`
  --field-change-error: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
  --diff-inspect-padding-xsmall: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
  --diff-inspect-padding-small: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[2])};

  position: relative;
  padding: var(--diff-inspect-padding-xsmall) 0 var(--diff-inspect-padding-xsmall)
    var(--diff-inspect-padding-small);

  &::before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    border-left: 1px solid var(--card-border-color);
  }

  &[data-error]:hover::before,
  &[data-revert-field-hover]:hover::before {
    border-left: 2px solid var(--field-change-error);
  }
`, Root$w = styledComponents.styled(TooltipDelayGroupProvider.Button)`
  [data-ui='Text'] {
    font-weight: normal;
  }

  div[data-ui='Box'] {
    display: none;
  }

  &:not([data-disabled='true']):hover,
  &:not([data-disabled='true']):focus {
    --card-fg-color: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
    --card-bg-color: transparent;
    --card-border-color: transparent;

    div[data-ui='Box'] {
      display: block;
    }
  }
`, RevertChangesButton = React.forwardRef(function(props2, ref) {
  const { selected, changeCount, ...restProps } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$w,
    {
      icon: icons.RevertIcon,
      selected,
      text: t2("changes.action.revert-changes-confirm-change", { count: changeCount }),
      mode: "bleed",
      ref,
      tooltipProps: null,
      ...restProps
    }
  );
});
function ValueError({ error }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "critical", padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, as: "p", children: t2(error.messageKey, {
      expectedType: error.expectedType,
      actualType: error.actualType
    }) }) })
  ] }) });
}
function FieldChange(props2) {
  var _a2;
  const { change, hidden, readOnly } = props2, DiffComponent = change.diffComponent || FallbackDiff, {
    documentId,
    schemaType,
    rootDiff,
    isComparingCurrent,
    FieldWrapper: FieldWrapper2 = React.Fragment
  } = useDocumentChange(), ops = useDocumentOperation(documentId, schemaType.name), [confirmRevertOpen, setConfirmRevertOpen] = React.useState(!1), [revertHovered, setRevertHovered] = React.useState(!1), [revertButtonElement, setRevertButtonElement] = React.useState(null), { t: t2 } = useTranslation(), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: documentId,
    type: schemaType.name,
    permission: "update"
  }), handleRevertChanges = React.useCallback(() => {
    undoChange(change, rootDiff, ops);
  }, [change, rootDiff, ops]), handleRevertChangesConfirm = React.useCallback(() => {
    setConfirmRevertOpen(!0);
  }, []), closeRevertChangesConfirmDialog = React.useCallback(() => {
    setConfirmRevertOpen(!1);
  }, []), handleRevertButtonMouseEnter = React.useCallback(() => {
    setRevertHovered(!0);
  }, []), handleRevertButtonMouseLeave = React.useCallback(() => {
    setRevertHovered(!1);
  }, []), handleClickOutside = React.useCallback(() => setConfirmRevertOpen(!1), []);
  ui.useClickOutside(handleClickOutside, [revertButtonElement]);
  const fieldPath = ((_a2 = change.parentSchema) == null ? void 0 : _a2.jsonType) === "array" ? change.path.slice(0, -1) : change.path;
  return React.useMemo(
    () => hidden ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, as: FieldChangeContainer, children: [
      change.showHeader && /* @__PURE__ */ jsxRuntime.jsx(ChangeBreadcrumb, { change, titlePath: change.titlePath }),
      /* @__PURE__ */ jsxRuntime.jsx(FieldWrapper2, { path: fieldPath, hasHover: revertHovered, children: /* @__PURE__ */ jsxRuntime.jsxs(
        DiffInspectWrapper,
        {
          change,
          as: DiffBorder,
          "data-revert-field-hover": revertHovered ? "" : void 0,
          "data-error": change.error ? "" : void 0,
          "data-revert-all-hover": !0,
          children: [
            change.error ? /* @__PURE__ */ jsxRuntime.jsx(ValueError, { error: change.error }) : /* @__PURE__ */ jsxRuntime.jsx(DiffErrorBoundary, { t: t2, children: /* @__PURE__ */ jsxRuntime.jsx(_singletons.DiffContext.Provider, { value: { path: change.path }, children: /* @__PURE__ */ jsxRuntime.jsx(
              DiffComponent,
              {
                diff: change.diff,
                schemaType: change.schemaType
              }
            ) }) }),
            isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.Popover,
              {
                content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
                  /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("changes.action.revert-changes-description", { count: 1 }) }) }),
                  /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, justify: "flex-end", children: [
                    /* @__PURE__ */ jsxRuntime.jsx(
                      TooltipDelayGroupProvider.Button,
                      {
                        mode: "ghost",
                        onClick: closeRevertChangesConfirmDialog,
                        text: t2("changes.action.revert-all-cancel")
                      }
                    ),
                    /* @__PURE__ */ jsxRuntime.jsx(
                      TooltipDelayGroupProvider.Button,
                      {
                        tone: "critical",
                        onClick: handleRevertChanges,
                        text: t2("changes.action.revert-changes-confirm-change", { count: 1 })
                      }
                    )
                  ] })
                ] }),
                open: confirmRevertOpen,
                padding: 3,
                portal: !0,
                placement: "left",
                ref: setRevertButtonElement,
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  RevertChangesButton,
                  {
                    changeCount: 1,
                    onClick: handleRevertChangesConfirm,
                    onMouseEnter: handleRevertButtonMouseEnter,
                    onMouseLeave: handleRevertButtonMouseLeave,
                    selected: confirmRevertOpen,
                    disabled: readOnly,
                    "data-testid": `single-change-revert-button-${change == null ? void 0 : change.key}`
                  }
                )
              }
            )
          ]
        }
      ) })
    ] }),
    [
      change,
      closeRevertChangesConfirmDialog,
      confirmRevertOpen,
      DiffComponent,
      fieldPath,
      FieldWrapper2,
      handleRevertButtonMouseEnter,
      handleRevertButtonMouseLeave,
      handleRevertChanges,
      handleRevertChangesConfirm,
      hidden,
      isComparingCurrent,
      isPermissionsLoading,
      permissions == null ? void 0 : permissions.granted,
      readOnly,
      revertHovered,
      t2
    ]
  );
}
function useHover() {
  const ref = React.useRef(null), [value, setValue] = React.useState(!1);
  return React.useEffect(() => {
    const node = ref.current;
    if (!node)
      return () => {
      };
    const handleMouseOver = () => setValue(!0), handleMouseOut = () => setValue(!1);
    return node.addEventListener("mouseover", handleMouseOver), node.addEventListener("mouseout", handleMouseOut), () => {
      node.removeEventListener("mouseover", handleMouseOver), node.removeEventListener("mouseout", handleMouseOut);
    };
  }, []), [ref, value];
}
const ChangeListWrapper = styledComponents.styled.div`
  display: grid;
  grid-template-columns: minmax(0, 1fr);
`, GroupChangeContainer = styledComponents.styled.div`
  --field-change-error: ${({ theme: theme2 }) => theme2.sanity.color.solid.critical.enabled.bg};
  --diff-inspect-padding-xsmall: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
  --diff-inspect-padding-small: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[2])};

  position: relative;
  padding: var(--diff-inspect-padding-xsmall) var(--diff-inspect-padding-small);

  &::before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    border-left: 1px solid var(--card-border-color);
  }

  &[data-error]:hover::before,
  &[data-revert-group-hover]:hover::before,
  &[data-revert-all-groups-hover]::before {
    border-left: 2px solid var(--field-change-error);
  }
`;
function GroupChange(props2) {
  const { change: group2, readOnly, hidden, ...restProps } = props2, { titlePath, changes, path: groupPath } = group2, { path: diffPath } = React.useContext(_singletons.DiffContext), { documentId, schemaType, FieldWrapper: FieldWrapper2, rootDiff, isComparingCurrent } = useDocumentChange(), { t: t2 } = useTranslation(), isPortableText2 = changes.every(
    (change) => isFieldChange(change) && isPTSchemaType(change.schemaType)
  ), isNestedInDiff = pathsAreEqual(diffPath, groupPath), [revertButtonRef, isRevertButtonHovered] = useHover(), docOperations = useDocumentOperation(documentId, schemaType.name), [confirmRevertOpen, setConfirmRevertOpen] = React.useState(!1), [revertPopoverElement, setRevertPopoverElement] = React.useState(null), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: documentId,
    type: schemaType.name,
    permission: "update"
  }), handleRevertChanges = React.useCallback(
    () => undoChange(group2, rootDiff, docOperations),
    [group2, rootDiff, docOperations]
  ), handleRevertChangesConfirm = React.useCallback(() => {
    setConfirmRevertOpen(!0);
  }, []), closeRevertChangesConfirmDialog = React.useCallback(() => {
    setConfirmRevertOpen(!1);
  }, []);
  ui.useClickOutside(() => setConfirmRevertOpen(!1), [revertPopoverElement]);
  const content2 = React.useMemo(
    () => hidden ? null : /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Stack,
      {
        space: 1,
        as: GroupChangeContainer,
        "data-revert-group-hover": isRevertButtonHovered ? "" : void 0,
        "data-portable-text": isPortableText2 ? "" : void 0,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: ChangeListWrapper, space: 5, children: changes.map((change) => /* @__PURE__ */ jsxRuntime.jsx(
            ChangeResolver,
            {
              change,
              readOnly,
              hidden
            },
            change.key
          )) }),
          isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Popover,
            {
              content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
                /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("changes.action.revert-changes-description", { count: changes.length }) }) }),
                /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, justify: "flex-end", children: [
                  /* @__PURE__ */ jsxRuntime.jsx(
                    TooltipDelayGroupProvider.Button,
                    {
                      mode: "ghost",
                      onClick: closeRevertChangesConfirmDialog,
                      text: t2("changes.action.revert-all-cancel")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntime.jsx(
                    TooltipDelayGroupProvider.Button,
                    {
                      tone: "critical",
                      onClick: handleRevertChanges,
                      text: t2("changes.action.revert-changes-confirm-change", { count: 1 })
                    }
                  )
                ] })
              ] }),
              padding: 3,
              portal: !0,
              placement: "left",
              open: confirmRevertOpen,
              ref: setRevertPopoverElement,
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
                RevertChangesButton,
                {
                  changeCount: changes.length,
                  onClick: handleRevertChangesConfirm,
                  ref: revertButtonRef,
                  selected: confirmRevertOpen,
                  disabled: readOnly,
                  "data-testid": `group-change-revert-button-${group2.fieldsetName}`
                }
              ) })
            }
          )
        ]
      }
    ),
    [
      changes,
      closeRevertChangesConfirmDialog,
      confirmRevertOpen,
      group2.fieldsetName,
      handleRevertChanges,
      handleRevertChangesConfirm,
      hidden,
      isComparingCurrent,
      isPermissionsLoading,
      isPortableText2,
      isRevertButtonHovered,
      permissions == null ? void 0 : permissions.granted,
      readOnly,
      revertButtonRef,
      t2
    ]
  );
  return hidden ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, ...restProps, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ChangeBreadcrumb, { titlePath }),
    isNestedInDiff || !FieldWrapper2 ? content2 : /* @__PURE__ */ jsxRuntime.jsx(FieldWrapper2, { hasHover: isRevertButtonHovered, path: group2.path, children: content2 })
  ] });
}
function ChangeResolver(props2) {
  var _a2, _b;
  const { change, hidden, readOnly } = props2, { value } = useDocumentChange(), isHidden = useConditionalProperty({
    // @todo: is parent missing here?
    document: value,
    checkProperty: hidden || ((_a2 = change.schemaType) == null ? void 0 : _a2.hidden),
    checkPropertyKey: "hidden",
    value: change.type === "field" ? change.diff.toValue : void 0
  }), isReadOnly = useConditionalProperty({
    // @todo: is parent missing here?
    document: value,
    checkProperty: readOnly || ((_b = change.schemaType) == null ? void 0 : _b.readOnly),
    checkPropertyKey: "readOnly",
    value: change.type === "field" ? change.diff.toValue : void 0
  });
  return isHidden ? null : change.type === "field" ? /* @__PURE__ */ jsxRuntime.jsx(FieldChange, { change, readOnly: isReadOnly }) : change.type === "group" ? /* @__PURE__ */ jsxRuntime.jsx(
    GroupChange,
    {
      change,
      "data-testid": `group-change-${change.fieldsetName}`,
      readOnly: isReadOnly
    }
  ) : (
    // eslint-disable-next-line i18next/no-literal-string
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { children: [
      "Unknown change type: ",
      /* @__PURE__ */ jsxRuntime.jsx("code", { children: change.type || "undefined" })
    ] })
  );
}
function NoChanges() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", as: "h3", children: t2("changes.no-changes-title") }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, muted: !0, children: t2("changes.no-changes-description") })
  ] });
}
function ChangeList({ diff: diff2, fields, schemaType }) {
  const { documentId, isComparingCurrent, value } = useDocumentChange(), docOperations = useDocumentOperation(documentId, schemaType.name), { path } = React.useContext(_singletons.DiffContext), isRoot = path.length === 0, [confirmRevertAllOpen, setConfirmRevertAllOpen] = React.useState(!1), [confirmRevertAllHover, setConfirmRevertAllHover] = React.useState(!1), { t: t2 } = useTranslation(), isReadOnly = useConditionalProperty({
    document: value,
    value: void 0,
    checkProperty: schemaType.readOnly,
    checkPropertyKey: "readOnly"
  });
  if (schemaType.jsonType !== "object")
    throw new Error("Only object schema types are allowed in ChangeList");
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: documentId,
    type: schemaType.name,
    permission: "update"
  }), allChanges = React.useMemo(
    () => buildObjectChangeList(schemaType, diff2, path, [], { fieldFilter: fields }),
    [schemaType, fields, path, diff2]
  ), changes = React.useMemo(
    () => fields && fields.length === 0 ? [] : maybeFlatten(allChanges),
    [allChanges, fields]
  ), rootChange = allChanges[0], revertAllChanges = React.useCallback(() => {
    undoChange(rootChange, diff2, docOperations), setConfirmRevertAllOpen(!1);
  }, [rootChange, diff2, docOperations]), handleRevertAllChangesClick = React.useCallback(() => {
    setConfirmRevertAllOpen(!0);
  }, []), handleRevertAllChangesMouseEnter = React.useCallback(() => {
    setConfirmRevertAllHover(!0);
  }, []), handleRevertAllChangesMouseLeave = React.useCallback(() => {
    setConfirmRevertAllHover(!1);
  }, []), closeRevertAllChangesConfirmDialog = React.useCallback(() => {
    setConfirmRevertAllOpen(!1);
  }, []), [revertAllContainerElement, setRevertAllContainerElement] = React.useState(
    null
  ), handleClickOutside = React.useCallback(() => setConfirmRevertAllOpen(!1), []);
  if (ui.useClickOutside(handleClickOutside, [revertAllContainerElement]), changes.length === 0)
    return isRoot ? /* @__PURE__ */ jsxRuntime.jsx(NoChanges, {}) : null;
  const showFooter = isRoot && changes.length > 1;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: ChangeListWrapper$1, space: 5, children: changes.map((change) => /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
      ChangeResolver,
      {
        change,
        "data-revert-all-changes-hover": confirmRevertAllHover ? "" : void 0,
        readOnly: isReadOnly || (change == null ? void 0 : change.readOnly),
        hidden: change == null ? void 0 : change.hidden
      },
      change.key
    ) }, change.key)) }),
    showFooter && isComparingCurrent && !isPermissionsLoading && (permissions == null ? void 0 : permissions.granted) && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Popover,
      {
        content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("changes.action.revert-all-description", {
            count: changes.length
          }) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, justify: "flex-end", children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.Button,
              {
                mode: "ghost",
                text: t2("changes.action.revert-all-cancel"),
                onClick: closeRevertAllChangesConfirmDialog
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.Button,
              {
                tone: "critical",
                text: t2("changes.action.revert-all-confirm"),
                onClick: revertAllChanges
              }
            )
          ] })
        ] }),
        open: confirmRevertAllOpen,
        padding: 3,
        placement: "left",
        portal: !0,
        ref: setRevertAllContainerElement,
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            tone: "critical",
            mode: "ghost",
            text: t2("changes.action.revert-all-confirm"),
            icon: icons.RevertIcon,
            onClick: handleRevertAllChangesClick,
            onMouseEnter: handleRevertAllChangesMouseEnter,
            onMouseLeave: handleRevertAllChangesMouseLeave,
            disabled: isReadOnly,
            size: "large"
          }
        ) })
      }
    )
  ] }) });
}
function maybeFlatten(changes) {
  return changes.length === 1 && changes[0].type === "group" && changes[0].path.length === 0 ? changes[0].changes : changes;
}
const RoundedCard = styledComponents.styled.span`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[1])};
`, ChangeSegment = styledComponents.styled(ui.Text)`
  &:not([hidden]) {
    display: inline;
    line-height: calc(1.25em + 2px);
  }

  &:hover {
    background-color: none !important;
    background-image: linear-gradient(
      to bottom,
      var(--card-bg-color) 0,
      var(--card-bg-color) 33.333%,
      currentColor 33.333%,
      currentColor 100%
    );
    background-size: 1px 3px;
    background-repeat: repeat-x;
    background-position-y: bottom;
    padding-bottom: 3px;
    box-shadow: 0 0 0 1px var(--card-bg-color);
    z-index: 1;
  }
`;
function DiffStringSegment(props2) {
  const { segment } = props2, { text } = segment, { t: t2 } = useTranslation();
  return segment.action === "added" ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation: segment.annotation,
      disableHoverEffect: !0,
      tooltip: { description: t2("changes.added-label") },
      as: RoundedCard,
      children: /* @__PURE__ */ jsxRuntime.jsx(ChangeSegment, { as: "ins", style: { textDecoration: "none" }, children: text })
    }
  ) : segment.action === "removed" ? /* @__PURE__ */ jsxRuntime.jsx(
    DiffCard,
    {
      annotation: segment.annotation,
      as: RoundedCard,
      disableHoverEffect: !0,
      tooltip: { description: t2("changes.removed-label") },
      children: /* @__PURE__ */ jsxRuntime.jsx(ChangeSegment, { as: "del", children: text })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "span", radius: 2, style: { display: "inline" }, children: text });
}
function DiffString(props2) {
  const { diff: diff2 } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: (diff2.segments || []).map((segment, segmentIndex) => /* @__PURE__ */ jsxRuntime.jsx(
    DiffStringSegment,
    {
      segment
    },
    segmentIndex
  )) });
}
const MetaText = styledComponents.styled(ui.Text)`
  color: inherit;
`;
function MetaInfo(props2) {
  const { title, action, icon, children, markRemoved } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 2, align: "center", children: [
    icon && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(MetaText, { size: 4, forwardedAs: markRemoved ? "del" : "div", children: React.createElement(icon) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, paddingLeft: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        MetaText,
        {
          size: 1,
          weight: "medium",
          forwardedAs: markRemoved ? "del" : "h3",
          textOverflow: "ellipsis",
          children: title
        }
      ),
      action && /* @__PURE__ */ jsxRuntime.jsx("div", { children: action }),
      /* @__PURE__ */ jsxRuntime.jsx(MetaText, { size: 0, textOverflow: "ellipsis", children })
    ] })
  ] });
}
function isEqual$1(item, otherItem) {
  if (item === otherItem)
    return !0;
  if (typeof item != typeof otherItem)
    return !1;
  if (typeof item != "object" && !Array.isArray(item))
    return item === otherItem;
  if (types.isKeyedObject(item) && types.isKeyedObject(otherItem) && item._key === otherItem._key)
    return !0;
  if (Array.isArray(item) && Array.isArray(otherItem))
    return item.length !== otherItem.length ? !1 : item.every((child, i) => isEqual$1(child, otherItem[i]));
  if (item === null || otherItem === null)
    return item === otherItem;
  const obj = item, otherObj = otherItem, keys = Object.keys(obj), otherKeys = Object.keys(otherObj);
  return keys.length !== otherKeys.length ? !1 : keys.every((keyName) => isEqual$1(obj[keyName], otherObj[keyName]));
}
const ArrayOfOptionsFieldDiff = ({ diff: diff2, schemaType }) => {
  var _a2;
  const options = (_a2 = schemaType.options) == null ? void 0 : _a2.list, colorManager = useUserColorManager(), { t: t2 } = useTranslation();
  return Array.isArray(options) ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: diff2.items.map((item) => normalizeItems$1(item, diff2, schemaType)).filter((item) => item !== null).sort(sortItems).map((item, index) => {
    const { annotation, isPresent, value, memberType, title } = item, color2 = getAnnotationColor(colorManager, annotation), action = t2(isPresent ? "changes.added-label" : "changes.removed-label");
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(DiffTooltip, { annotations: annotation ? [annotation] : [], description: action, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(Checkbox, { checked: !isPresent, color: color2 }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FromToArrow, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(Checkbox, { checked: isPresent, color: color2 })
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ItemPreview, { value: title || value, memberType }) })
    ] }, getItemKey(diff2, index));
  }) }) : null;
};
function normalizeItems$1(item, parentDiff, schemaType) {
  if (item.diff.action === "unchanged")
    return null;
  const { fromValue, toValue } = parentDiff, value = getValue$1(item.diff), wasPresent = isInArray(value, fromValue), isPresent = isInArray(value, toValue);
  return wasPresent === isPresent ? null : {
    title: getItemTitle(value, schemaType),
    memberType: resolveMemberType(getValue$1(item.diff), schemaType),
    itemIndex: getOptionIndex(value, schemaType),
    annotation: item.annotation,
    isPresent,
    value
  };
}
function sortItems(itemA, itemB) {
  return itemA.itemIndex - itemB.itemIndex;
}
function ItemPreview({ value, memberType }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginX: 2, marginY: 1, children: typeof value == "string" || typeof value == "number" ? value : /* @__PURE__ */ jsxRuntime.jsx(Preview$1, { schemaType: memberType, value, layout: "default" }) });
}
function isInArray(value, parent) {
  const array = parent || [];
  return typeof value == "object" && value !== null ? array.some((item) => isEqual$1(item, value)) : array.includes(value);
}
function getItemKey(diff2, index) {
  const value = diff2.toValue || diff2.fromValue;
  return types.isKeyedObject(value) ? value._key : index;
}
function getValue$1(diff2) {
  return typeof diff2.toValue > "u" ? diff2.fromValue : diff2.toValue;
}
function resolveMemberType(item, schemaType) {
  const itemTypeName = resolveTypeName(item);
  return schemaType.of.find((memberType) => memberType.name === itemTypeName);
}
function resolveTypeName(value) {
  const jsType = resolveJSType(value);
  if (jsType !== "object")
    return jsType;
  const obj = value;
  return "_type" in obj && obj._type || jsType;
}
function resolveJSType(val) {
  return val === null ? "null" : Array.isArray(val) ? "array" : typeof val;
}
function isNamedOption(item) {
  return typeof item == "object" && item !== null && "title" in item;
}
function getOptionIndex(item, schemaType) {
  var _a2;
  return (((_a2 = schemaType.options) == null ? void 0 : _a2.list) || []).findIndex((opt) => isEqual$1(isNamedOption(opt) ? opt.value : opt, item));
}
function getItemTitle(item, schemaType) {
  var _a2;
  const list = ((_a2 = schemaType.options) == null ? void 0 : _a2.list) || [], index = getOptionIndex(item, schemaType);
  return index === -1 ? void 0 : list[index].title || void 0;
}
const SlugWrapper = styledComponents.styled.div`
  display: inline-block;
  word-break: break-all;
  white-space: pre-wrap;
`, SlugPreview = (props2) => {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: SlugWrapper, paddingX: 2, paddingY: 1, children: value.current });
}, SlugFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(
  DiffFromTo,
  {
    layout: "inline",
    diff: diff2,
    schemaType,
    previewComponent: SlugPreview
  }
), UrlFieldDiff = ({ diff: diff2, schemaType }) => /* @__PURE__ */ jsxRuntime.jsx(DiffFromTo, { diff: diff2, schemaType, previewComponent: StringPreview }), diffResolver = ({ schemaType }) => {
  var _a2;
  if (["datetime", "date"].includes(schemaType.name))
    return DatetimeFieldDiff;
  if (schemaType.name === "url")
    return UrlFieldDiff;
  if (schemaType.name === "slug")
    return SlugFieldDiff;
  if (schemaType.jsonType === "array" && Array.isArray((_a2 = schemaType.options) == null ? void 0 : _a2.list))
    return ArrayOfOptionsFieldDiff;
}, IGNORE_KEYS = ["_key", "_type", "_weak"];
function isEmptyItem(value) {
  return Object.keys(value).every((key) => IGNORE_KEYS.includes(key));
}
function immutableReconcile(previous, next) {
  return _immutableReconcile(previous, next, /* @__PURE__ */ new WeakSet());
}
function _immutableReconcile(previous, next, parents) {
  if (previous === next) return previous;
  if (parents.has(next) || previous == null || next == null || typeof previous != typeof next) return next;
  if (Array.isArray(next)) {
    parents.add(next);
    let allEqual = previous.length === next.length;
    const result = [];
    for (let index = 0; index < next.length; index++) {
      const nextItem = _immutableReconcile(previous[index], next[index], parents);
      nextItem !== previous[index] && (allEqual = !1), result[index] = nextItem;
    }
    return parents.delete(next), allEqual ? previous : result;
  }
  if (typeof next == "object") {
    parents.add(next);
    const nextKeys = Object.keys(next);
    let allEqual = Object.keys(previous).length === nextKeys.length;
    const result = {};
    for (const key of nextKeys) {
      const nextValue = _immutableReconcile(previous[key], next[key], parents);
      nextValue !== previous[key] && (allEqual = !1), result[key] = nextValue;
    }
    return parents.delete(next), allEqual ? previous : result;
  }
  return next;
}
function PresenceProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.PresenceContext.Provider, { value: props2.presence, children: props2.children });
}
function useFormFieldPresence() {
  const ctx = React.useContext(_singletons.PresenceContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function useChildPresence(path, inclusive) {
  const presence = useFormFieldPresence(), prev = React.useRef(presence), next = immutableReconcile(
    prev.current,
    presence.filter(
      (item) => PathUtils.startsWith(path, item.path) && inclusive
    )
  );
  return prev.current = next, next;
}
function useFormBuilder() {
  const formBuilder = React.useContext(_singletons.FormBuilderContext);
  if (!formBuilder)
    throw new Error("FormBuilder: missing context value");
  return formBuilder;
}
const getIcon = (level) => level === "error" ? /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) : level === "warning" ? /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {}), IconText = styledComponents.styled(ui.Text)(({ theme: theme2 }) => styledComponents.css`
    &[data-info] {
      color: ${theme2.sanity.color.muted.primary.enabled.fg};
    }

    &[data-warning] {
      color: ${theme2.sanity.color.muted.caution.enabled.fg};
    }

    &[data-error] {
      color: ${theme2.sanity.color.muted.critical.enabled.fg};
    }
  `);
function DefaultMarkers(props2) {
  const { markers, validation: validation2, renderCustomMarkers } = props2, { CustomMarkers } = useFormBuilder().__internal.components;
  return markers.length === 0 && validation2.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, children: [
    validation2.length > 0 && validation2.map(({ message, level }, index) => (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 2, marginBottom: index + 1 === validation2.length ? 0 : 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          IconText,
          {
            size: 1,
            "data-error": level === "error" ? "" : void 0,
            "data-warning": level === "warning" ? "" : void 0,
            "data-info": level === "info" ? "" : void 0,
            children: getIcon(level)
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: message || "Error" }) })
      ] }, `validationItem-${index}`)
    )),
    markers.length > 0 && /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { marginTop: validation2.length > 0 ? 3 : 0, children: [
      renderCustomMarkers && renderCustomMarkers(markers),
      !renderCustomMarkers && /* @__PURE__ */ jsxRuntime.jsx(CustomMarkers, { markers })
    ] })
  ] });
}
function ValidationProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ValidationContext.Provider, { value: props2.validation, children: props2.children });
}
function useValidationMarkers() {
  const ctx = React.useContext(_singletons.ValidationContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function useChildValidation(path, inclusive = !1) {
  const validation2 = useValidationMarkers();
  return React.useMemo(
    () => validation2.filter((item) => PathUtils.startsWith(path, item.path) && (inclusive || !PathUtils.isEqual(path, item.path))).map((marker) => ({
      message: marker.message,
      level: marker.level,
      path: marker.path
    })),
    [inclusive, path, validation2]
  );
}
const NONEXISTENT_PATH = ["@@_NONEXISTENT_PATH_@@"];
function useMemberValidation(member) {
  const prev = React.useRef(null), memberValidation = member != null && member.validation && member.validation.length > 0 ? member.validation : EMPTY_ARRAY$t, childValidation = useChildValidation((member == null ? void 0 : member.path) || NONEXISTENT_PATH), validation2 = React.useMemo(
    () => member != null && member.schemaType && isBlockType(member == null ? void 0 : member.schemaType) ? memberValidation : memberValidation.concat(childValidation),
    [childValidation, member, memberValidation]
  ), [hasError, hasWarning, hasInfo] = React.useMemo(
    () => [
      validation2.filter((v) => v.level === "error").length > 0,
      validation2.filter((v) => v.level === "warning").length > 0,
      validation2.filter((v) => v.level === "info").length > 0
    ],
    [validation2]
  ), reconciled = immutableReconcile(prev.current, validation2);
  return prev.current = reconciled, React.useMemo(() => ({
    validation: reconciled,
    hasError,
    hasWarning,
    hasInfo
  }), [reconciled, hasError, hasWarning, hasInfo]);
}
function usePortableTextMarkers(path) {
  const ctx = React.useContext(_singletons.PortableTextMarkersContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return React.useMemo(() => ctx.filter((m) => PathUtils.isEqual(m.path, path)), [ctx, path]);
}
const POPOVER_PROPS$7 = {
  placement: "right",
  fallbackPlacements: ["top", "bottom"]
};
function FieldActionMenuGroup(props2) {
  const { group: group2 } = props2, { title } = useI18nText(group2);
  return group2.expanded ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, paddingTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: title }) }),
    group2.children.map((item, idx) => {
      var _a2;
      return /* @__PURE__ */ jsxRuntime.jsx(
        FieldActionMenuNode,
        {
          action: item,
          isFirst: idx === 0,
          prevIsGroup: ((_a2 = group2.children[idx - 1]) == null ? void 0 : _a2.type) === "group"
        },
        idx
      );
    })
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.MenuGroup, { icon: group2.icon, popover: POPOVER_PROPS$7, text: title, tone: group2.tone, children: group2.children.map((item, idx) => {
    var _a2;
    return /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionMenuNode,
      {
        action: item,
        isFirst: idx === 0,
        prevIsGroup: ((_a2 = group2.children[idx - 1]) == null ? void 0 : _a2.type) === "group"
      },
      idx
    );
  }) });
}
function FieldActionMenuItem(props2) {
  const { action } = props2, { title } = useI18nText(action), handleClick = React.useCallback(() => {
    action.onAction();
  }, [action]), disabledTooltipContent = typeof action.disabled == "object" && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: action.disabled.reason });
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipOfDisabled, { content: disabledTooltipContent, placement: "left", children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuItem,
    {
      disabled: !!action.disabled,
      icon: action.icon,
      iconRight: action.iconRight || (action.selected ? icons.CheckmarkIcon : void 0),
      onClick: handleClick,
      pressed: action.selected,
      text: title,
      tone: action.tone
    }
  ) });
}
function FieldActionMenuNode(props2) {
  const { action, isFirst, prevIsGroup } = props2;
  return action.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}) : action.type === "group" ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    !isFirst && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionMenuGroup, { group: action })
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    prevIsGroup && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionMenuItem, { action })
  ] });
}
const STATUS_BUTTON_TOOLTIP_PROPS = {
  placement: "top"
};
function renderAsButton(node) {
  return "renderAsButton" in node && node.renderAsButton;
}
const FieldActionMenu = React.memo(function(props2) {
  const { nodes, onMenuOpenChange } = props2, [open, setOpen] = React.useState(!1), handleOpen = React.useCallback(() => {
    onMenuOpenChange(!0), setOpen(!0);
  }, [onMenuOpenChange]), handleClose = React.useCallback(() => {
    onMenuOpenChange(!1), setOpen(!1);
  }, [onMenuOpenChange]), buttonNodes = React.useMemo(() => nodes.filter(renderAsButton), [nodes]), menuNodesProp = React.useMemo(() => nodes.filter((node) => !renderAsButton(node)), [nodes]), menuNodes = React.useMemo(() => {
    const len = menuNodesProp.length;
    if (len === 0 || len > 1) return menuNodesProp;
    const node = menuNodesProp[0];
    return node.type === "group" ? [{ ...node, expanded: !0 }] : menuNodesProp;
  }, [menuNodesProp]), rootNodes = React.useMemo(
    () => [
      ...menuNodes.length ? [
        {
          type: "group",
          children: menuNodes,
          icon: icons.EllipsisHorizontalIcon,
          title: "Field actions"
        }
      ] : [],
      ...buttonNodes
    ],
    [buttonNodes, menuNodes]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: rootNodes.map((node, idx) => /* @__PURE__ */ jsxRuntime.jsx(
    RootFieldActionMenuNode,
    {
      node,
      onOpen: handleOpen,
      onClose: handleClose,
      open
    },
    idx
  )) });
}), RootFieldActionMenuNode = React.memo(function(props2) {
  const { node, onOpen, onClose, open } = props2;
  return node.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderLeft: !0, flex: "none" }) : node.type === "action" ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      icon: node.icon,
      mode: "bleed",
      onClick: node.onAction,
      tooltipProps: {
        ...STATUS_BUTTON_TOOLTIP_PROPS,
        content: node.title
      }
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(RootFieldActionMenuGroup, { node, onOpen, onClose, open });
}), ROOT_MENU_BUTTON_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "right",
  portal: !0,
  fallbackPlacements: ["top", "bottom"]
};
function RootFieldActionMenuGroup(props2) {
  const { node, onOpen, onClose, open } = props2, { title } = useI18nText(node);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          icon: node.icon,
          label: open ? void 0 : title,
          mode: "bleed",
          tooltipProps: {
            ...STATUS_BUTTON_TOOLTIP_PROPS,
            content: node.title
          }
        }
      ),
      id: React.useId(),
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: node.children.map((action, idx) => {
        var _a2;
        return /* @__PURE__ */ jsxRuntime.jsx(
          FieldActionMenuNode,
          {
            action,
            isFirst: idx === 0,
            prevIsGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group"
          },
          idx
        );
      }) }),
      onOpen,
      onClose,
      popover: ROOT_MENU_BUTTON_POPOVER_PROPS
    }
  );
}
function useHoveredField() {
  return React.useContext(_singletons.HoveredFieldContext);
}
function FieldActionsProvider(props2) {
  const { actions, children, path, focused } = props2, { onMouseEnter: onFieldMouseEnter, onMouseLeave: onFieldMouseLeave } = useHoveredField(), hoveredPath = useHoveredField().hoveredStack[0], hovered = supportsTouch || (hoveredPath ? pathToString$1(path) === hoveredPath : !1), handleMouseEnter = React.useCallback(() => {
    onFieldMouseEnter(path);
  }, [onFieldMouseEnter, path]), handleMouseLeave = React.useCallback(() => {
    onFieldMouseLeave(path);
  }, [onFieldMouseLeave, path]), context = React.useMemo(
    () => ({
      actions,
      focused,
      hovered,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave
    }),
    [actions, focused, handleMouseEnter, handleMouseLeave, hovered]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.FieldActionsContext.Provider, { value: context, children });
}
function filterActions(actions) {
  return actions.filter(Boolean).filter((node) => "hidden" in node ? node.hidden !== !0 : !0).map((node) => node.type === "group" ? {
    ...node,
    children: filterActions(node.children)
  } : node);
}
const FieldActionsResolver = React.memo(function(props2) {
  const { actions, documentId, documentType, onActions, path, schemaType } = props2, len = actions.length, lenRef = React.useRef(len), [fieldActions, setFieldActions] = React.useState(
    () => Array.from(new Array(len))
  ), fieldActionsRef = React.useRef(fieldActions), setFieldAction = React.useCallback((index, node) => {
    setFieldActions((prev) => {
      const next = [...prev];
      return next[index] = node, next;
    });
  }, []);
  return React.useEffect(() => {
    fieldActionsRef.current !== fieldActions && (fieldActionsRef.current = fieldActions, onActions(filterActions(fieldActions)));
  }, [fieldActions, onActions]), React.useEffect(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = fieldActionsRef.current[i];
      lenRef.current = len, setFieldActions(newFieldActions), fieldActionsRef.current = newFieldActions;
    }
  }, [len]), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: actions.map((a, aIdx) => /* @__PURE__ */ jsxRuntime.jsx(
    FieldAction,
    {
      action: a,
      index: aIdx,
      documentId,
      documentType,
      path,
      schemaType,
      setFieldAction
    },
    aIdx
  )) });
}), FieldAction = React.memo(function(props2) {
  const { action, documentId, documentType, index, path, schemaType, setFieldAction } = props2, node = useUnique(
    action.useAction({
      documentId,
      documentType,
      path,
      schemaType
    })
  );
  return React.useEffect(() => {
    setFieldAction(index, node);
  }, [index, node, setFieldAction]), null;
});
function useFieldActions() {
  return React.useContext(_singletons.FieldActionsContext);
}
function HoveredFieldProvider(props2) {
  const { children } = props2, [hoveredStack, setHoveredStack] = React.useState([]), handleMouseEnter = React.useCallback((path) => {
    const pathString = pathToString$1(path);
    setHoveredStack((prev) => prev.includes(pathString) ? prev : [pathString, ...prev]);
  }, []), handleMouseLeave = React.useCallback((path) => {
    const pathString = pathToString$1(path);
    setHoveredStack((prev) => prev.includes(pathString) ? prev.filter((item) => item !== pathString) : prev);
  }, []), context = React.useMemo(
    () => ({
      hoveredStack,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave
    }),
    [handleMouseEnter, handleMouseLeave, hoveredStack]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.HoveredFieldContext.Provider, { value: context, children });
}
const PRESENCE_MENU_POPOVER_PROPS = {
  portal: !0
}, AvatarStackBox = styledComponents.styled.div((props2) => {
  const { space } = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    margin: ${0 - space[1]}px;
  `;
}), getTooltipText = (presence) => {
  if (presence.length === 1)
    return `${presence[0].user.displayName} is editing this document`;
  if (presence.length > 1)
    return `${presence.length} people are editing this document right now`;
};
function DocumentPreviewPresence(props2) {
  const { presence } = props2, uniqueUsers = React.useMemo(
    () => Array.from(new Set(presence.map((a) => a.user.id))).map((id2) => presence.find((a) => a.user.id === id2)).filter(isNonNullable$3),
    [presence]
  ), tooltipContent = React.useMemo(() => getTooltipText(uniqueUsers), [uniqueUsers]);
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: tooltipContent, ...PRESENCE_MENU_POPOVER_PROPS, children: /* @__PURE__ */ jsxRuntime.jsx(AvatarStackBox, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarStack, { maxLength: 2, "aria-label": getTooltipText(uniqueUsers), size: 0, children: uniqueUsers.map((item) => /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 0, user: item.user }, item.user.id)) }) }) });
}
const symbols = /[^\p{Alpha}\p{White_Space}]/gu, whitespace = new RegExp("\\p{White_Space}+", "u"), LEGACY_TO_UI_AVATAR_SIZES = {
  small: 0,
  medium: 1,
  large: 2
};
function nameToInitials$1(fullName) {
  const namesArray = fullName.replace(symbols, "").split(whitespace);
  return namesArray.length === 1 ? `${namesArray[0].charAt(0)}`.toUpperCase() : `${namesArray[0].charAt(0)}${namesArray[namesArray.length - 1].charAt(0)}`;
}
function UserAvatar(props2) {
  const { user, withTooltip, ...restProps } = props2;
  return isRecord$4(user) ? withTooltip ? /* @__PURE__ */ jsxRuntime.jsx(TooltipUserAvatar, { ...restProps, user }) : /* @__PURE__ */ jsxRuntime.jsx(StaticUserAvatar, { ...restProps, user }) : /* @__PURE__ */ jsxRuntime.jsx(UserAvatarLoader, { ...props2, user });
}
function TooltipUserAvatar(props2) {
  const {
    user: { displayName }
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: displayName, placement: "top", portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx("div", { style: { display: "inline-block" }, children: /* @__PURE__ */ jsxRuntime.jsx(StaticUserAvatar, { ...props2 }) }) });
}
const StaticUserAvatar = React.forwardRef(function(props2, ref) {
  const { user, animateArrowFrom, position, size, status, tone, ...restProps } = props2, [imageLoadError, setImageLoadError] = React.useState(null), userColor = useUserColor(user.id), imageUrl = imageLoadError || user == null ? void 0 : user.imageUrl;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Avatar,
    {
      __unstable_hideInnerStroke: !0,
      animateArrowFrom,
      arrowPosition: position,
      color: userColor.name,
      "data-legacy-tone": tone,
      initials: (user == null ? void 0 : user.displayName) && nameToInitials$1(user.displayName),
      src: imageUrl,
      onImageLoadError: setImageLoadError,
      ref,
      size: typeof size == "string" ? LEGACY_TO_UI_AVATAR_SIZES[size] : size,
      status,
      title: user == null ? void 0 : user.displayName,
      ...restProps
    }
  );
});
function UserAvatarLoader({ user, ...loadedProps }) {
  const [value] = useUser(user);
  return value ? /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { ...loadedProps, user: value }) : null;
}
const MAX_AVATARS_DOCK = 3, DEFAULT_MAX_AVATARS_FIELDS = 3, AVATAR_DISTANCE = -4, AVATAR_SIZE = 25, AVATAR_ARROW_HEIGHT = 4, INTERSECTION_THRESHOLDS = [0, 0.25, 0.75, 1], INTERSECTION_ELEMENT_PADDING = 23, SNAP_TO_DOCK_DISTANCE_TOP = 8, SNAP_TO_DOCK_DISTANCE_BOTTOM = 8, SLIDE_RIGHT_THRESHOLD_TOP = 20, SLIDE_RIGHT_THRESHOLD_BOTTOM = 20, DEBUG = !1, FlexWrapper$1 = styledComponents.styled(ui.Flex)`
  & > div:first-child {
    flex: 1;
    min-width: 0;
  }
`, InnerBox = styledComponents.styled(ui.Flex)`
  height: ${AVATAR_SIZE}px;
  min-width: 23px;
  vertical-align: top;
`, { Tracker, useReporter, useReportedValues } = createTrackerScope();
function PresenceTooltip(props2) {
  const { children, items } = props2, content2 = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { sizing: "border", children: items.map((item) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { user: item.user, status: "online" }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: item.user.displayName })
    ] }, item.user.id)) }),
    [items]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: content2, placement: "top", portal: "documentScrollElement", children });
}
const splitRight = (array, max) => {
  const indexFromMax = array.length > max ? max - 1 : max, idx = Math.max(0, array.length - indexFromMax);
  return [array.slice(0, idx), array.slice(idx)];
};
function calcAvatarStackWidth(len) {
  return -AVATAR_DISTANCE + (AVATAR_SIZE + AVATAR_DISTANCE) * len;
}
const FieldPresenceInner = React.memo(function({
  presence,
  position = "inside",
  animateArrowFrom = "inside",
  maxAvatars = DEFAULT_MAX_AVATARS_FIELDS,
  stack = !0
}) {
  const uniquePresence = uniqBy__default.default(presence || [], (item) => item.user.id), sorted = sortBy__default.default(uniquePresence, (_presence) => _presence.lastActiveAt), [hidden, visible] = stack ? splitRight(sorted, maxAvatars) : [[], sorted], avatars = [
    ...visible.reverse().map((_visible) => ({
      key: _visible.user.id,
      element: /* @__PURE__ */ jsxRuntime.jsx(
        UserAvatar,
        {
          animateArrowFrom,
          position,
          status: "online",
          user: _visible.user
        }
      )
    })),
    hidden.length >= 2 ? {
      key: "counter",
      element: /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarCounter, { count: hidden.length })
    } : null
  ].filter(Boolean);
  return /* @__PURE__ */ jsxRuntime.jsxs(FlexWrapper$1, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", {}),
    /* @__PURE__ */ jsxRuntime.jsx(InnerBox, { direction: "row-reverse", children: avatars.map(
      (av, i) => av && /* @__PURE__ */ jsxRuntime.jsx(
        "div",
        {
          style: {
            position: "absolute",
            transform: `translate3d(${-i * (AVATAR_SIZE + AVATAR_DISTANCE)}px, 0px, 0px)`,
            transitionProperty: "transform",
            transitionDuration: "200ms",
            transitionTimingFunction: "cubic-bezier(0.85, 0, 0.15, 1)",
            zIndex: 100 - i
          },
          children: av.element
        },
        av.key
      )
    ) })
  ] });
});
function FieldPresenceWithOverlay(props2) {
  const contextPresence = React.useContext(_singletons.FormFieldPresenceContext), { presence = contextPresence, maxAvatars = DEFAULT_MAX_AVATARS_FIELDS } = props2, ref = React.useRef(null);
  useReporter(React.useId(), () => ({ presence, element: ref.current, maxAvatars }));
  const uniquePresence = React.useMemo(() => uniqBy__default.default(presence || [], (item) => item.user.id), [presence]);
  return /* @__PURE__ */ jsxRuntime.jsx(PresenceTooltip, { items: uniquePresence, children: /* @__PURE__ */ jsxRuntime.jsx(FlexWrapper$1, { ref, style: { minHeight: AVATAR_SIZE, minWidth: AVATAR_SIZE } }) });
}
function FieldPresenceWithoutOverlay(props2) {
  const contextPresence = React.useContext(_singletons.FormFieldPresenceContext), { presence = contextPresence, maxAvatars = DEFAULT_MAX_AVATARS_FIELDS } = props2;
  return presence.length ? /* @__PURE__ */ jsxRuntime.jsx(FieldPresenceInner, { presence, maxAvatars }) : null;
}
const FieldPresence = FieldPresenceWithOverlay, createIntersectionObserver = (options) => {
  const entries$ = new rxjs.Subject(), intersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      entries$.next(entry);
    });
  }, options);
  return {
    observe: (element) => new rxjs.Observable((subscriber) => {
      const subscription = entries$.pipe(operators.filter((entry) => entry.target === element)).subscribe(subscriber);
      return intersectionObserver.observe(element), () => {
        subscription.unsubscribe(), intersectionObserver.unobserve(element);
      };
    })
  };
}, WithIntersection = (props2) => {
  const { onIntersection, io, id: id2, ...rest } = props2, element = React.useRef(null);
  return React.useEffect(() => {
    const el = element.current;
    if (!el) return;
    const subscription = io.observe(el).pipe(operators.tap((entry) => onIntersection(id2, entry))).subscribe();
    return () => subscription.unsubscribe();
  }, [io, id2, onIntersection]), /* @__PURE__ */ jsxRuntime.jsx("div", { ref: element, ...rest });
}, RootWrapper = styledComponents.styled.div`
  position: relative;
`, OverlayWrapper = styledComponents.styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: 13;
`, RegionWrapper = styledComponents.css`
  overflow: hidden;
  overflow: clip;
  pointer-events: none;
  position: absolute;
`, TopRegionWrapper = styledComponents.styled(WithIntersection)(({ $debug, margins }) => styledComponents.css`
    ${RegionWrapper}

    z-index: 100;
    position: sticky;
    height: 1px;
    top: ${margins ? `${margins[0] - 1}px` : void 0};
    background-color: ${$debug ? "red" : "none"};
  `), MiddleRegionWrapper = styledComponents.styled(WithIntersection)(({ $debug }) => styledComponents.css`
    ${RegionWrapper}

    visibility: none;

    ${$debug && styledComponents.css`
      background: rgba(255, 0, 0, 0.25);
      outline: 1px solid #00b;
      visibility: visible;
    `}
  `), BottomRegionWrapper = styledComponents.styled(WithIntersection)(({ $debug }) => styledComponents.css`
    ${RegionWrapper}

    position: sticky;
    bottom: -1px;
    height: 1px;
    background-color: ${$debug ? "blue" : "transparent"};
  `), toPx = (num) => `${num}px`, negate = (num) => 0 - num, RegionsWithIntersections = React.forwardRef(function(props2, ref) {
  const { regions, render: render2, children, margins: marginsProp } = props2, overlayRef = React.useRef(null), margins = React.useMemo(() => marginsProp, [JSON.stringify(marginsProp)]), io = React.useMemo(
    () => createIntersectionObserver({
      rootMargin: margins.map(negate).map(toPx).join(" "),
      threshold: INTERSECTION_THRESHOLDS
    }),
    [margins]
  ), [intersections, setIntersections] = React.useState({}), onIntersection = React.useCallback((id2, entry) => {
    setIntersections((current) => ({ ...current, [id2]: entry }));
  }, []), top = intersections["::top"], bottom2 = intersections["::bottom"], regionsWithIntersectionDetails = React.useMemo(
    () => top && bottom2 ? regions.filter((region) => {
      var _a2;
      return ((_a2 = region.presence) == null ? void 0 : _a2.length) > 0;
    }).map((region) => {
      const intersection2 = intersections[region.id];
      if (!intersection2)
        return null;
      const { bottom: boundsBottom, top: boundsTop } = intersection2.boundingClientRect, aboveTop = intersection2.boundingClientRect.top < top.boundingClientRect.bottom, belowBottom = intersection2.boundingClientRect.top < bottom2.boundingClientRect.top, distanceTop = intersection2.isIntersecting ? boundsTop - (intersection2.intersectionRect.top - INTERSECTION_ELEMENT_PADDING) : aboveTop ? -top.boundingClientRect.bottom : bottom2.boundingClientRect.top, distanceBottom = intersection2.isIntersecting ? -(boundsBottom - (intersection2.intersectionRect.bottom + INTERSECTION_ELEMENT_PADDING)) : belowBottom ? bottom2.boundingClientRect.top : -top.boundingClientRect.bottom, position = (
        // eslint-disable-next-line no-nested-ternary
        distanceTop <= SNAP_TO_DOCK_DISTANCE_TOP ? "top" : distanceBottom <= SNAP_TO_DOCK_DISTANCE_BOTTOM ? "bottom" : "inside"
      );
      return {
        distanceTop,
        distanceBottom,
        region,
        position
      };
    }).filter(Boolean) : [],
    [bottom2, intersections, regions, top]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(RootWrapper, { ref, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      TopRegionWrapper,
      {
        $debug: DEBUG,
        io,
        id: "::top",
        onIntersection,
        margins
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx("div", { children }),
    /* @__PURE__ */ jsxRuntime.jsx(OverlayWrapper, { ref: overlayRef, children: overlayRef.current && render2(regionsWithIntersectionDetails, overlayRef.current.offsetWidth) }),
    regions.map((region) => {
      const forceWidth = region.rect.width === 0;
      return /* @__PURE__ */ jsxRuntime.jsx(
        MiddleRegionWrapper,
        {
          $debug: DEBUG,
          io,
          onIntersection,
          id: region.id,
          style: {
            width: forceWidth ? 1 : region.rect.width,
            left: region.rect.left - (forceWidth ? 1 : 0),
            top: region.rect.top - INTERSECTION_ELEMENT_PADDING,
            height: region.rect.height + INTERSECTION_ELEMENT_PADDING * 2
          }
        },
        region.id
      );
    }),
    /* @__PURE__ */ jsxRuntime.jsx(BottomRegionWrapper, { $debug: DEBUG, id: "::bottom", io, onIntersection })
  ] });
}), ITEM_TRANSITION = {
  transitionProperty: "transform",
  transitionDuration: "200ms",
  transitionTimingFunction: "cubic-bezier(0.85, 0, 0.15, 1)"
}, bottom = (rect) => rect.top + rect.height;
function withSpacerHeight(regionsWithIntersectionDetails) {
  return regionsWithIntersectionDetails.map(
    (withIntersection, idx, _regionsWithIntersectionDetails) => {
      var _a2;
      const prevRect = (_a2 = _regionsWithIntersectionDetails[idx - 1]) == null ? void 0 : _a2.region.rect, prevBottom = prevRect ? bottom(prevRect) : 0;
      return { ...withIntersection, spacerHeight: withIntersection.region.rect.top - prevBottom };
    }
  );
}
const orderByTop = (regionsWithIntersectionDetails) => orderBy__default.default(regionsWithIntersectionDetails, (withIntersection) => withIntersection.region.rect.top), plus = (a, b) => a + b, sum = (array) => array.reduce(plus, 0);
function group(regionsWithIntersectionDetails) {
  const regionsWithSpacerHeight = withSpacerHeight(orderByTop(regionsWithIntersectionDetails)), grouped = {
    top: [],
    inside: [],
    bottom: [],
    ...groupBy__default.default(regionsWithSpacerHeight, (_withSpacerHeight) => _withSpacerHeight.position)
  };
  return {
    top: orderByTop(grouped.top).map(
      (withIntersection, i, grp) => ({
        ...withIntersection,
        indent: grp.slice(i + 1).reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0)
      })
    ),
    inside: orderByTop(grouped.inside).map(
      (withIntersection) => ({
        ...withIntersection,
        indent: 0
      })
    ),
    bottom: orderByTop(grouped.bottom).map(
      (withIntersection, i, grp) => ({
        ...withIntersection,
        indent: grp.slice(0, i).reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0)
      })
    )
  };
}
const Spacer = ({ height, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx("div", { style: { height: Math.max(0, height), ...rest == null ? void 0 : rest.style } }), DEFAULT_MARGINS$1 = [0, 0, 0, 0], getOffsetsTo = (source, target) => {
  let el = source, top = -el.scrollTop, left = 0;
  for (; el && el !== target; )
    top += el.offsetTop - el.scrollTop, left += el.offsetLeft, el = el.offsetParent instanceof HTMLElement ? el.offsetParent : null;
  return { top, left };
};
function getRelativeRect(element, parent) {
  return {
    ...getOffsetsTo(element, parent),
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function regionsWithComputedRects(regions, parent) {
  return regions.map(([id2, region]) => ({
    ...region,
    id: id2,
    rect: getRelativeRect(region.element, parent)
  }));
}
function StickyOverlay(props2) {
  const { children, margins = DEFAULT_MARGINS$1 } = props2, reportedValues = useReportedValues(), ref = React.useRef(null), regions = React.useMemo(
    () => ref.current ? regionsWithComputedRects(reportedValues, ref.current) : EMPTY_ARRAY$r,
    [reportedValues]
  ), renderCallback = React.useCallback(
    (regionsWithIntersectionDetails, containerWidth) => {
      const grouped = group(
        regionsWithIntersectionDetails.filter((item) => item.region.presence.length > 0)
      ), topSpacing = sum(grouped.top.map((n) => n.region.rect.height + n.spacerHeight)), bottomSpacing = sum(
        [...grouped.inside, ...grouped.bottom].map((n) => n.region.rect.height + n.spacerHeight)
      ), counts = grouped.inside.reduce(
        (_counts, withIntersection) => {
          const { distanceTop, distanceBottom } = withIntersection, nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP, nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM;
          return {
            nearTop: _counts.nearTop + (nearTop ? withIntersection.region.presence.length : 0),
            nearBottom: _counts.nearBottom + (nearBottom ? withIntersection.region.presence.length : 0)
          };
        },
        { nearTop: 0, nearBottom: 0 }
      );
      return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          PresenceDock,
          {
            closeCount: counts.nearTop,
            margins,
            position: "top",
            regionsWithIntersectionDetails: grouped.top
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(Spacer, { height: topSpacing }),
        /* @__PURE__ */ jsxRuntime.jsx(
          PresenceInside,
          {
            containerWidth,
            regionsWithIntersectionDetails: grouped.inside
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(Spacer, { height: bottomSpacing }),
        /* @__PURE__ */ jsxRuntime.jsx(
          PresenceDock,
          {
            closeCount: counts.nearBottom,
            margins,
            position: "bottom",
            regionsWithIntersectionDetails: grouped.bottom
          }
        )
      ] });
    },
    [margins]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(RegionsWithIntersections, { ref, margins, regions, render: renderCallback, children });
}
const EMPTY_ARRAY$r = [], PresenceDock = React.memo(function(props2) {
  const { closeCount, margins, position, regionsWithIntersectionDetails } = props2, dir = position === "top" ? 1 : -1, allPresenceItems = React.useMemo(() => regionsWithIntersectionDetails.length ? flatten__default.default(
    sortBy__default.default(regionsWithIntersectionDetails, (r) => r.region.rect.top * dir).map(
      (withIntersection) => withIntersection.region.presence || EMPTY_ARRAY$r
    )
  ) : EMPTY_ARRAY$r, [dir, regionsWithIntersectionDetails]), [topMargin, rightMargin, bottomMargin, leftMargin] = margins, leftOffset = (leftMargin || 0) + (allPresenceItems.length > 0 ? -closeCount * (AVATAR_SIZE + AVATAR_DISTANCE) : 0) - rightMargin, margin = position === "top" ? topMargin : bottomMargin, style = React.useMemo(
    () => ({
      zIndex: 2,
      position: "sticky",
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-end",
      ...ITEM_TRANSITION,
      transform: `translate3d(${leftOffset}px, 0px, 0px)`,
      top: AVATAR_ARROW_HEIGHT + 1 + margin,
      bottom: AVATAR_ARROW_HEIGHT + 1 + margin
    }),
    [leftOffset, margin]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { "data-dock": position, style, children: /* @__PURE__ */ jsxRuntime.jsx(
    FieldPresenceInner,
    {
      position,
      maxAvatars: MAX_AVATARS_DOCK,
      presence: allPresenceItems
    }
  ) }, `sticky-${position}`);
});
function PresenceInside(props2) {
  const { regionsWithIntersectionDetails, containerWidth } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: regionsWithIntersectionDetails.map((withIntersection) => {
    const originalLeft = withIntersection.region.rect.left, { distanceTop, distanceBottom } = withIntersection, nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP, nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM, diffRight = containerWidth - originalLeft - withIntersection.region.rect.width, { presence, maxAvatars } = withIntersection.region;
    return /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(
      "div",
      {
        style: {
          zIndex: 2,
          position: "absolute",
          ...ITEM_TRANSITION,
          left: originalLeft,
          transform: `translate3d(${nearTop || nearBottom ? diffRight : 0}px, 0px, 0px)`,
          height: withIntersection.region.rect.height,
          top: withIntersection.region.rect.top
        },
        children: /* @__PURE__ */ jsxRuntime.jsx(DebugValue, { value: () => `\u2912${distanceTop} | ${distanceBottom}\u2913`, children: /* @__PURE__ */ jsxRuntime.jsx(
          FieldPresenceInner,
          {
            stack: !nearTop && !nearBottom,
            position: nearTop ? "top" : nearBottom ? "bottom" : "inside",
            maxAvatars,
            presence
          }
        ) })
      }
    ) }, withIntersection.region.id);
  }) });
}
const PassThrough = (props2) => props2.children, DebugValue = PassThrough, DEFAULT_MARGINS = [0, 0, 0, 0];
function OverlayEnabled({ children, margins }) {
  return /* @__PURE__ */ jsxRuntime.jsx(Tracker, { children: /* @__PURE__ */ jsxRuntime.jsx(StickyOverlay, { margins: margins || DEFAULT_MARGINS, children }) });
}
function OverlayDisabled(props2) {
  return props2.children;
}
const PresenceOverlay = OverlayEnabled, EMPTY_ARRAY$q = [];
function trimChildPath(path, childPath) {
  return PathUtils__namespace.startsWith(path, childPath) ? PathUtils__namespace.trimLeft(path, childPath) : EMPTY_ARRAY$q;
}
function PresenceScope(props2) {
  const { readOnly, path, children } = props2, contextPresence = React.useContext(_singletons.FormFieldPresenceContext), childPresence = React.useMemo(() => readOnly ? EMPTY_ARRAY$q : (contextPresence || EMPTY_ARRAY$q).filter((presence) => PathUtils__namespace.startsWith(path, presence.path)).map((presence) => ({
    ...presence,
    path: trimChildPath(path, presence.path)
  })), [contextPresence, path, readOnly]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.FormFieldPresenceContext.Provider, { value: childPresence, children });
}
const Root$v = styledComponents.styled(ui.Flex)(({ theme: theme2, $floatingCardWidth, $slotWidth, $floatingCardVisible }) => {
  const { space } = theme2.sanity;
  return styledComponents.css`
    /* Prevent buttons from taking up extra vertical space */
    line-height: 1;
    width: 100%;
    /* For floating actions menu */
    position: relative;

    [data-ui='PresenceBox'] {
      position: absolute;
      bottom: 0;
      right: ${$slotWidth + $floatingCardWidth + space[1]}px;
    }
    @media (hover: hover) {
      // If hover is supported, we hide the floating card by default, so only add space for it when it's visible.
      [data-ui='PresenceBox'] {
        position: absolute;
        bottom: 0;
        right: ${$slotWidth + ($floatingCardVisible ? $floatingCardWidth : 0) + space[1]}px;
      }
    }
  `;
}), ContentBox = styledComponents.styled(ui.Box)(({ theme: theme2, $presenceMaxWidth }) => {
  const { space } = theme2.sanity;
  return styledComponents.css`
    max-width: calc(100% - ${$presenceMaxWidth + space[1]}px);
    min-width: 75%;
  `;
}), SlotBox = styledComponents.styled(ui.Box)(({ theme: theme2, $right, $fieldActionsVisible }) => {
  const { space } = theme2.sanity, right = $fieldActionsVisible ? $right + space[1] : $right;
  return styledComponents.css`
    position: absolute;
    bottom: 0;
    right: ${right}px;
  `;
}), FieldActionsFloatingCard = styledComponents.styled(ui.Card)`
  align-items: center;
  bottom: 0;
  position: absolute;
  right: 0;
  transition: opacity 150ms ease;
  line-height: 1;

  @media (hover: hover) {
    // If hover is supported, we hide the floating card by default
    // and only show it when it has focus within or when the field is hovered or focused.
    opacity: 0;
    pointer-events: none;

    [data-ui='FieldActionsFlex'] {
      opacity: 0;
    }

    &[data-actions-visible='false']:not(:focus-within) {
      // Remove the shadow when the field actions are not visible
      box-shadow: none;

      // Since the field actions always will be present in the DOM (to make them focusable) –
      // they will always affect the width of the floating card, even when they are not visible.
      // Therefore, we remove the background of the floating card when the field actions are not visible.
      background: transparent;
    }

    // Remove the shadow when the field has comments but no actions
    &[data-has-comments='true']:not([data-has-actions='true']) {
      box-shadow: none;
    }

    // Show the floating card when it has focus within (ie when field actions are focused).
    &:focus-within {
      opacity: 1;
      pointer-events: auto;
      width: max-content;

      [data-ui='FieldActionsFlex'] {
        opacity: 1;
        pointer-events: auto;
        width: max-content;
      }
    }
  }

  &[data-visible='true'] {
    opacity: 1;
    pointer-events: auto;
    width: max-content;
  }

  &[data-actions-visible='true'] {
    [data-ui='FieldActionsFlex'] {
      opacity: 1;
      pointer-events: auto;
      width: max-content;
    }
  }
`, FieldActionsFlex = styledComponents.styled(ui.Flex)`
  gap: inherit;
  transition: opacity 150ms ease;
`, MAX_AVATARS = 4;
function FormFieldBaseHeader(props2) {
  const {
    __internal_comments: comments2,
    __internal_slot: slot,
    actions,
    content: content2,
    fieldFocused,
    fieldHovered,
    presence
  } = props2, [focused, setFocused] = React.useState(!1), [menuOpen, setMenuOpen] = React.useState(!1), [floatingCardElement, setFloatingCardElement] = React.useState(null), [floatingCardWidth, setFloatingCardWidth] = React.useState(0), [slotElement, setSlotElement] = React.useState(null), [slotWidth, setSlotWidth] = React.useState(0), {
    hasComments = !1,
    button: commentButton = null,
    isAddingComment = !1
  } = comments2 || {}, hasActions = actions && actions.length > 0, showFieldActions = fieldFocused || fieldHovered || menuOpen || isAddingComment, hasCommentsButtonOrActions = (comments2 == null ? void 0 : comments2.button) || hasActions, shouldShowFloatingCard = focused || showFieldActions || hasComments, handleSetFloatingCardElementWidth = React.useCallback(() => {
    if (floatingCardElement) {
      const { width } = floatingCardElement.getBoundingClientRect();
      setFloatingCardWidth(width || 0);
    }
  }, [floatingCardElement]), handleFocusCapture = React.useCallback(() => {
    handleSetFloatingCardElementWidth(), setFocused(!0);
  }, [handleSetFloatingCardElementWidth]), handleBlurCapture = React.useCallback(() => {
    handleSetFloatingCardElementWidth(), setFocused(!1);
  }, [handleSetFloatingCardElementWidth]);
  React.useEffect(() => {
    handleSetFloatingCardElementWidth();
  }, [handleSetFloatingCardElementWidth, showFieldActions]), React.useEffect(() => {
    if (slotElement) {
      const { width } = slotElement.getBoundingClientRect();
      setSlotWidth(width || 0);
    }
  }, [slotElement]);
  const slotEl = React.useMemo(() => slot ? /* @__PURE__ */ jsxRuntime.jsx(
    SlotBox,
    {
      $fieldActionsVisible: !!showFieldActions,
      $right: floatingCardWidth,
      ref: setSlotElement,
      children: slot
    }
  ) : null, [floatingCardWidth, showFieldActions, slot]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$v,
    {
      align: "flex-end",
      justify: "space-between",
      $floatingCardVisible: shouldShowFloatingCard,
      $floatingCardWidth: floatingCardWidth,
      $slotWidth: slotWidth,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ContentBox,
          {
            "data-ui": "fieldHeaderContentBox",
            flex: 1,
            paddingY: 2,
            $presenceMaxWidth: calcAvatarStackWidth(MAX_AVATARS),
            children: content2
          }
        ),
        presence && presence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-ui": "PresenceBox", flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { maxAvatars: MAX_AVATARS, presence }) }),
        slotEl,
        (hasCommentsButtonOrActions || hasComments) && /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(
          FieldActionsFloatingCard,
          {
            "data-actions-visible": showFieldActions ? "true" : "false",
            "data-has-actions": hasActions ? "true" : "false",
            "data-has-comments": hasComments ? "true" : "false",
            "data-visible": shouldShowFloatingCard ? "true" : "false",
            display: "flex",
            onBlurCapture: handleBlurCapture,
            onFocusCapture: handleFocusCapture,
            ref: setFloatingCardElement,
            sizing: "border",
            children: [
              hasActions && /* @__PURE__ */ jsxRuntime.jsx(FieldActionsFlex, { align: "center", "data-ui": "FieldActionsFlex", children: /* @__PURE__ */ jsxRuntime.jsx(FieldActionMenu, { nodes: actions, onMenuOpenChange: setMenuOpen }) }),
              commentButton
            ]
          }
        ) })
      ]
    }
  );
}
function createDescriptionId(id2, description) {
  if (!(!description || !id2))
    return `desc_${id2}`;
}
const EMPTY_ARRAY$p = [], VALIDATION_ICONS = {
  error: ValidationErrorIcon,
  warning: ValidationWarningIcon,
  info: ValidationInfoIcon
}, StyledStack = styledComponents.styled(ui.Stack)`
  max-width: 200px;
`, StatusText = styledComponents.styled(ui.Text)(({ $status }) => $status === "error" ? { "--card-icon-color": "var(--card-badge-critical-icon-color)" } : $status === "warning" ? { "--card-icon-color": "var(--card-badge-caution-icon-color)" } : $status === "info" ? { "--card-icon-color": "var(--card-badge-primary-icon-color)" } : {});
function FormFieldValidationStatus(props2) {
  const { validation: validation2 = EMPTY_ARRAY$p, __unstable_showSummary: showSummary, fontSize, placement } = props2, hasErrors = validation2.some((v) => v.level === "error"), hasWarnings = validation2.some((v) => v.level === "warning"), status = hasErrors ? "error" : hasWarnings ? "warning" : "info", StatusIcon = VALIDATION_ICONS[status];
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsxs(StyledStack, { space: 3, children: [
        showSummary && /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationSummary, { validation: validation2 }),
        !showSummary && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: validation2.map((item, itemIndex) => (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatusItem, { validation: item }, itemIndex)
        )) })
      ] }),
      portal: !0,
      placement,
      fallbackPlacements: ["bottom", "right", "left"],
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(StatusText, { $status: status, size: fontSize, weight: "medium", children: StatusIcon && /* @__PURE__ */ jsxRuntime.jsx(StatusIcon, {}) }) })
    }
  );
}
function FormFieldValidationStatusItem(props2) {
  const { validation: validation2 } = props2, StatusIcon = VALIDATION_ICONS[validation2.level];
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 2, children: /* @__PURE__ */ jsxRuntime.jsx(StatusText, { $status: validation2.level, size: 1, children: StatusIcon && /* @__PURE__ */ jsxRuntime.jsx(StatusIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: validation2.message }) })
  ] });
}
function FormFieldValidationSummary({ validation: validation2 }) {
  const { t: t2 } = useTranslation(), listFormatter = useListFormat(), errorCount = validation2.reduce(
    (count, item) => item.level === "error" ? count + 1 : count,
    0
  ), warningCount = validation2.reduce(
    (count, item) => item.level === "warning" ? count + 1 : count,
    0
  ), hasErrors = errorCount > 0, hasWarnings = warningCount > 0;
  if (!hasErrors && !hasWarnings)
    return null;
  const errorText = hasErrors && t2("form.validation.summary.errors-count", { count: errorCount }), warningText = hasWarnings && t2("form.validation.summary.warnings-count", { count: warningCount });
  return errorText && warningText ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: listFormatter.format([errorText, warningText]) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: errorText || warningText });
}
function ValidationErrorIcon() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    icons.ErrorOutlineIcon,
    {
      "data-testid": "input-validation-icon-error",
      "aria-label": t2("form.validation.has-error-aria-label"),
      "aria-hidden": !0,
      role: "presentation"
    }
  );
}
function ValidationWarningIcon() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    icons.WarningOutlineIcon,
    {
      "data-testid": "input-validation-icon-warning",
      "aria-label": t2("form.validation.has-warning-aria-label"),
      "aria-hidden": !0,
      role: "presentation"
    }
  );
}
function ValidationInfoIcon() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    icons.InfoOutlineIcon,
    {
      "data-testid": "input-validation-icon-info",
      "aria-label": t2("form.validation.has-info-aria-label"),
      "aria-hidden": !0,
      role: "presentation"
    }
  );
}
const LabelSuffix = styledComponents.styled(ui.Flex)`
  /*
   * Prevent the block size of appended elements (such as the deprecated field badge) affecting
   * the intrinsic block size of the label.
   */
  contain: size;
`, EMPTY_ARRAY$o = [], FormFieldHeaderText = React.memo(function(props2) {
  const { description, inputId, title, deprecated, validation: validation2 = EMPTY_ARRAY$o } = props2, { t: t2 } = useTranslation(), hasValidations = validation2.length > 0, hasLabelSuffix = deprecated || hasValidations;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", paddingY: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "label", htmlFor: inputId, weight: "medium", size: 1, children: title || /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("form.field.untitled-field-label") }) }),
      hasLabelSuffix && /* @__PURE__ */ jsxRuntime.jsxs(LabelSuffix, { align: "center", flex: 1, children: [
        deprecated && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { "data-testid": `deprecated-badge-${title}`, tone: "caution", children: t2("form.field.deprecated-label") }) }),
        hasValidations && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { fontSize: 1, placement: "top", validation: validation2 }) })
      ] })
    ] }),
    deprecated && /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { "data-testid": `deprecated-message-${title}`, tone: "caution", size: 1, children: deprecated.reason }),
    description && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, id: createDescriptionId(inputId, description), children: description })
  ] });
}), EMPTY_ARRAY$n = [], FormField = React.memo(function(props2) {
  const {
    __unstable_headerActions: actions = EMPTY_ARRAY$n,
    __unstable_presence: presence = EMPTY_ARRAY$n,
    __internal_slot: slot = null,
    __internal_comments: comments2,
    children,
    description,
    inputId,
    level,
    title,
    validation: validation2,
    deprecated,
    ...restProps
  } = props2, { focused, hovered, onMouseEnter, onMouseLeave } = useFieldActions();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Stack,
    {
      ...restProps,
      "data-level": level,
      onMouseEnter,
      onMouseLeave,
      space: 2,
      children: [
        title && /* @__PURE__ */ jsxRuntime.jsx(
          FormFieldBaseHeader,
          {
            __internal_comments: comments2,
            __internal_slot: slot,
            actions,
            fieldFocused: !!focused,
            fieldHovered: hovered,
            presence,
            content: /* @__PURE__ */ jsxRuntime.jsx(
              FormFieldHeaderText,
              {
                description,
                inputId,
                title,
                validation: validation2,
                deprecated
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("div", { children })
      ]
    }
  );
}), Root$u = styledComponents.styled.legend`
  /* See: https://thatemil.com/blog/2015/01/03/reset-your-fieldset/ */
  padding: 0;
  display: table;
`, ToggleButton = styledComponents.styled(ui.Flex).attrs({ forwardedAs: "button" })((props2) => {
  const { theme: theme2 } = props2, { focusRing, radius } = theme2.sanity, { base } = theme2.sanity.color;
  return styledComponents.css`
    appearance: none;
    border: 0;
    background: none;
    color: inherit;
    -webkit-font-smoothing: inherit;
    font: inherit;
    outline: none;
    border-radius: ${ui.rem(radius[2])};
    position: relative;

    &:not([hidden]) {
      display: flex;
    }

    &:focus {
      box-shadow: ${focusRingStyle$2({ base, focusRing })};
    }

    &:focus:not(:focus-visible) {
      box-shadow: none;
    }

    /* Added to increase the hit area of the collapsible fieldset */
    &::after {
      content: '';
      position: absolute;
      top: -10px;
      right: -10px;
      bottom: -10px;
      left: -10px;
    }
  `;
}), ToggleIconBox = styledComponents.styled(ui.Box)`
  width: 9px;
  height: 9px;
  margin-right: 3px;

  & svg {
    transition: transform 100ms;
  }
`, FormFieldSetLegend = React.memo(function(props2) {
  const { collapsed, collapsible, onClick, title } = props2, { t: t2 } = useTranslation(), text = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: title || /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("form.field.untitled-fieldset-label") }) });
  return collapsible ? /* @__PURE__ */ jsxRuntime.jsx(Root$u, { children: /* @__PURE__ */ jsxRuntime.jsxs(ToggleButton, { type: "button", onClick, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ToggleIconBox, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      icons.ToggleArrowRightIcon,
      {
        style: {
          transform: `rotate(${collapsed ? "0" : "90deg"}) translate3d(0, 0, 0)`
        }
      }
    ) }) }),
    text
  ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(Root$u, { children: text });
});
function getChildren(children) {
  return typeof children == "function" ? children() : children;
}
const Root$t = styledComponents.styled(ui.Stack).attrs({ forwardedAs: "fieldset" })`
  border: none;

  /* See: https://thatemil.com/blog/2015/01/03/reset-your-fieldset/ */
  body:not(:-moz-handler-blocked) & {
    display: table-cell;
  }
`, Content$1 = styledComponents.styled(ui.Box)((props2) => {
  const { $borderLeft, theme: theme2 } = props2, { focusRing } = theme2.sanity, { base } = theme2.sanity.color;
  return styledComponents.css`
    outline: none;
    border-left: ${$borderLeft ? "1px solid var(--card-border-color)" : void 0};

    &:focus {
      box-shadow: ${focusRingStyle$2({ base, focusRing: { ...focusRing, offset: 2 } })};
    }

    &:focus:not(:focus-visible) {
      box-shadow: none;
    }
  `;
}), EMPTY_ARRAY$m = [], FormFieldSet = React.forwardRef(function(props2, ref) {
  const {
    __internal_comments: comments2,
    __internal_slot: slot = null,
    __unstable_headerActions: actions = EMPTY_ARRAY$m,
    __unstable_presence: presence = EMPTY_ARRAY$m,
    children,
    collapsed,
    collapsible,
    columns,
    description,
    level = 0,
    onCollapse,
    onExpand,
    onFocus,
    tabIndex,
    title,
    validation: validation2 = EMPTY_ARRAY$m,
    inputId,
    deprecated,
    ...restProps
  } = props2, { focused, hovered, onMouseEnter, onMouseLeave } = useFieldActions(), hasValidationMarkers = validation2.length > 0, forwardedRef = ui.useForwardedRef(ref), { t: t2 } = useTranslation(), handleFocus = React.useCallback(
    (event) => {
      forwardedRef.current === event.target && onFocus && onFocus(event);
    },
    [forwardedRef, onFocus]
  ), handleToggle = React.useCallback(
    () => collapsed ? onExpand == null ? void 0 : onExpand() : onCollapse == null ? void 0 : onCollapse(),
    [collapsed, onCollapse, onExpand]
  ), content2 = React.useMemo(() => collapsed ? null : /* @__PURE__ */ jsxRuntime.jsx(AlignedBottomGrid$1, { columns, gapX: 4, gapY: 5, children: getChildren(children) }), [children, collapsed, columns]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$t,
    {
      "data-level": level,
      ...restProps,
      onMouseEnter,
      onMouseLeave,
      space: 2,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          FormFieldBaseHeader,
          {
            __internal_comments: comments2,
            __internal_slot: slot,
            actions,
            fieldFocused: !!focused,
            fieldHovered: hovered,
            presence,
            content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  FormFieldSetLegend,
                  {
                    collapsed: !!collapsed,
                    collapsible,
                    onClick: collapsible ? handleToggle : void 0,
                    title
                  }
                ),
                deprecated && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { "data-testid": `deprecated-badge-${title}`, tone: "caution", children: t2("form.field.deprecated-label") }) }),
                hasValidationMarkers && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { fontSize: 1, placement: "top", validation: validation2 }) })
              ] }),
              deprecated && /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { "data-testid": `deprecated-message-${title}`, tone: "caution", size: 1, children: deprecated.reason }),
              description && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, id: createDescriptionId(inputId, description), children: description })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          Content$1,
          {
            $borderLeft: level > 0,
            hidden: collapsed,
            paddingLeft: level === 0 ? 0 : 3,
            onFocus: typeof tabIndex == "number" && tabIndex > -1 ? handleFocus : void 0,
            ref: forwardedRef,
            tabIndex,
            children: !collapsed && content2
          }
        )
      ]
    }
  );
}), Root$s = styledComponents.styled.div`
  display: flex;
  justify-content: flex-end;
  box-sizing: border-box;
  min-height: var(--avatar-height);
  width: 77px;
  margin-left: var(--small-padding);

  &[data-max-avatars='1'] {
    max-width: 23px;
  }

  &[data-position='top'] {
    align-self: flex-start;
  }

  &[data-position='bottom'] {
    align-self: flex-end;
  }
`;
function FormFieldStatus({ children, maxAvatars, position = "bottom" }) {
  return /* @__PURE__ */ jsxRuntime.jsx(Root$s, { "data-max-avatars": maxAvatars, "data-position": position, children });
}
function usePrevious(value, initial) {
  const ref = React.useRef(initial || null);
  return React.useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
function useDidUpdate(current, didUpdate, compare2 = shallowEquals__default.default) {
  const previous = usePrevious(current);
  React.useEffect(() => {
    compare2(previous, current) || didUpdate(previous, current);
  }, [didUpdate, current, previous, compare2]);
}
const SANITY_PATCH_TYPE = Symbol.for("sanity.patch");
function setIfMissing(value, path = []) {
  return {
    patchType: SANITY_PATCH_TYPE,
    type: "setIfMissing",
    path,
    value
  };
}
function insert(items, position, path = []) {
  return {
    patchType: SANITY_PATCH_TYPE,
    type: "insert",
    path,
    position,
    items
  };
}
function set(value, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "set", path, value };
}
function unset(path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "unset", path };
}
function diffMatchPatch(value, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "diffMatchPatch", path, value };
}
function inc(amount = 1, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "inc", path, value: amount };
}
function dec(amount = 1, path = []) {
  return { patchType: SANITY_PATCH_TYPE, type: "dec", path, value: amount };
}
function prefixPath(patch2, segment) {
  return {
    ...patch2,
    path: [segment, ...patch2.path]
  };
}
function createPatchChannel() {
  const _subscribers = [];
  return {
    publish(msg) {
      for (const subscriber of _subscribers)
        subscriber(msg);
    },
    subscribe(subscriber) {
      return _subscribers.push(subscriber), () => {
        const idx = _subscribers.indexOf(subscriber);
        idx > -1 && _subscribers.splice(idx, 1);
      };
    }
  };
}
var __defProp$c = Object.defineProperty, __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$c = (obj, key, value) => __defNormalProp$c(obj, key + "", value);
class PatchEvent {
  constructor(patches) {
    __publicField$c(this, "patches"), this.patches = patches;
  }
  static from(input) {
    return input instanceof PatchEvent ? input : new PatchEvent(Array.isArray(input) ? flatten__default.default(input) : [input]);
  }
  prepend(...patches) {
    return PatchEvent.from([...flatten__default.default(patches), ...this.patches]);
  }
  append(...patches) {
    return PatchEvent.from([...this.patches, ...flatten__default.default(patches)]);
  }
  prefixAll(segment) {
    return PatchEvent.from(this.patches.map((patch2) => prefixPath(patch2, segment)));
  }
}
const FormCallbacksProvider = React.memo(function(props2) {
  const ref = React.useRef(props2);
  ref.current = props2;
  const transformPatches = React.useCallback(
    (patches) => {
      var _a2, _b, _c;
      return (_c = (_b = (_a2 = ref.current) == null ? void 0 : _a2.transformPatches) == null ? void 0 : _b.call(_a2, patches)) != null ? _c : [];
    },
    [ref]
  ), onChange = React.useCallback((patchEvent) => {
    ref.current.onChange(patchEvent);
  }, []), onPathFocus = React.useCallback((path, payload) => {
    ref.current.onPathFocus(path, payload);
  }, []), onPathBlur = React.useCallback((path) => {
    ref.current.onPathBlur(path);
  }, []), onPathOpen = React.useCallback((path) => {
    ref.current.onPathOpen(path);
  }, []), onSetPathCollapsed = React.useCallback((path, collapsed) => {
    ref.current.onSetPathCollapsed(path, collapsed);
  }, []), onSetFieldSetCollapsed = React.useCallback((path, collapsed) => {
    ref.current.onSetFieldSetCollapsed(path, collapsed);
  }, []), onFieldGroupSelect = React.useCallback((path, fieldGroupName) => {
    ref.current.onFieldGroupSelect(path, fieldGroupName);
  }, []), contextValue = React.useMemo(
    () => ({
      transformPatches,
      onChange,
      onPathFocus,
      onPathBlur,
      onPathOpen,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      onFieldGroupSelect
    }),
    [
      onChange,
      onFieldGroupSelect,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      transformPatches
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.FormCallbacksContext.Provider, { value: contextValue, children: props2.children });
});
function useFormCallbacks() {
  const ctx = React.useContext(_singletons.FormCallbacksContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function createProtoValue(type) {
  if (types.isObjectSchemaType(type))
    return type.name === "object" ? {} : { _type: type.name };
  if (types.isArraySchemaType(type))
    return [];
  if (type.jsonType === "string")
    return "";
  if (type.jsonType === "number")
    return 0;
  if (type.jsonType === "boolean")
    return !1;
}
function whatwgRNG(length = 16) {
  const rnds8 = new Uint8Array(length);
  return getRandomValues__default.default(rnds8), rnds8;
}
const getByteHexTable = /* @__PURE__ */ (() => {
  let table2;
  return () => {
    if (table2)
      return table2;
    table2 = [];
    for (let i = 0; i < 256; ++i)
      table2[i] = (i + 256).toString(16).slice(1);
    return table2;
  };
})();
function randomKey(length) {
  const table2 = getByteHexTable();
  return whatwgRNG(length).reduce((str, n) => str + table2[n], "").slice(0, length);
}
function hasKey$1(item) {
  return item._key !== void 0;
}
function ensureKey(item) {
  return hasKey$1(item) ? item : { ...item, _key: randomKey(12) };
}
const getMemberTypeOfItem$2 = (schemaType, item) => {
  const itemTypeName = content.resolveTypeName(item);
  return schemaType.of.find((memberType) => memberType.name === itemTypeName);
};
function assign(values2, path) {
  return Object.entries(values2).map(([key, value]) => set(value, [...path, key]));
}
function resolveInitialArrayValues(items, schemaType, resolver) {
  return rxjs.from(items).pipe(
    operators.mergeMap((item) => {
      const itemPathSegment = { _key: item._key };
      return rxjs.of(getMemberTypeOfItem$2(schemaType, item)).pipe(
        operators.mergeMap((memberType) => memberType ? rxjs.of(memberType) : rxjs.EMPTY),
        operators.mergeMap((memberType) => !isEmptyItem(item) || !resolver ? rxjs.EMPTY : rxjs.concat(
          rxjs.of({
            type: "patch",
            patches: [set(!0, [itemPathSegment, "_resolvingInitialValue"])]
          }),
          rxjs.defer(() => resolver(memberType, item)).pipe(
            operators.filter(isNonNullable$3),
            operators.map((initial) => ({
              type: "patch",
              patches: assign(initial, [itemPathSegment])
            })),
            operators.catchError(
              (error) => rxjs.of({ type: "error", error, item, schemaType: memberType })
            )
          ),
          rxjs.of({
            type: "patch",
            patches: [unset([itemPathSegment, "_resolvingInitialValue"])]
          })
        ))
      );
    })
  );
}
function ArrayOfObjectsItem(props2) {
  const focusRef = React.useRef(), {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  } = props2, { t: t2 } = useTranslation(), {
    onPathBlur,
    onPathFocus,
    onChange,
    onPathOpen,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onFieldGroupSelect
  } = useFormCallbacks(), resolveInitialValue2 = useResolveInitialValueForType();
  useDidUpdate(member.item.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const onRemove = React.useCallback(() => {
    onChange(PatchEvent.from([unset([{ _key: member.key }])]));
  }, [member.key, onChange]), handleOpenItem = React.useCallback(
    (path) => {
      onPathOpen(path), onSetPathCollapsed(path, !1);
    },
    [onPathOpen, onSetPathCollapsed]
  ), toast = ui.useToast(), handleInsert = React.useCallback(
    (event) => {
      if (event.items.length === 0)
        throw new Error("Insert event should include at least one item");
      const itemsWithKeys = event.items.map((item) => ensureKey(item));
      onChange(PatchEvent.from([insert(itemsWithKeys, event.position, [{ _key: member.key }])]));
      const focusItemKey = itemsWithKeys[0]._key, itemPath = [...member.item.path.slice(0, -1), { _key: focusItemKey }];
      onPathFocus(itemPath);
      const shouldOpen = event.open !== !1;
      event.skipInitialValue ? shouldOpen && handleOpenItem(itemPath) : resolveInitialArrayValues(itemsWithKeys, member.parentSchemaType, resolveInitialValue2).pipe(
        operators.tap((result) => {
          result.type === "patch" ? onChange(PatchEvent.from(result.patches)) : toast.push({
            title: t2("inputs.array.error.cannot-resolve-initial-value-title"),
            description: t2("inputs.array.error.cannot-resolve-initial-value-description", {
              schemaTypeTitle: result.schemaType.title,
              errorMessage: result.error.message
            }),
            status: "error"
          });
        })
      ).subscribe({
        complete: () => {
          shouldOpen && handleOpenItem(itemPath);
        }
      });
    },
    [
      handleOpenItem,
      member.item.path,
      member.key,
      member.parentSchemaType,
      onChange,
      onPathFocus,
      resolveInitialValue2,
      toast,
      t2
    ]
  ), handleBlur = React.useCallback(() => {
    onPathBlur(member.item.path);
  }, [member.item.path, onPathBlur]), handleFocus = React.useCallback(() => {
    onPathFocus(member.item.path);
  }, [member.item.path, onPathFocus]), handleFocusChildPath = React.useCallback(
    (path) => {
      onPathFocus(member.item.path.concat(path));
    },
    [member.item.path, onPathFocus]
  ), handleChange = React.useCallback(
    (event) => {
      onChange(
        PatchEvent.from(event).prepend(setIfMissing(createProtoValue(member.item.schemaType))).prefixAll({ _key: member.key })
      );
    },
    [onChange, member.item.schemaType, member.key]
  ), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.item.path, !0);
  }, [onSetPathCollapsed, member.item.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.item.path, !1);
  }, [onSetPathCollapsed, member.item.path]), handleCollapseField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.item.path.concat(fieldName), !0);
    },
    [onSetPathCollapsed, member.item.path]
  ), handleExpandField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.item.path.concat(fieldName), !1);
    },
    [onSetPathCollapsed, member.item.path]
  ), handleCloseField = React.useCallback(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]), handleOpenField = React.useCallback(
    (fieldName) => {
      onPathOpen(member.item.path.concat(fieldName));
    },
    [onPathOpen, member.item.path]
  ), handleExpandFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), !1);
    },
    [onSetFieldSetCollapsed, member.item.path]
  ), handleCollapseFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), !0);
    },
    [onSetFieldSetCollapsed, member.item.path]
  ), handleOpen = React.useCallback(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]), isEmptyValue = !member.item.value || isEmptyItem(member.item.value), handleClose = React.useCallback(() => {
    isEmptyValue && onRemove();
    const parentPath = member.item.path.slice(0, -1);
    onPathOpen(parentPath), onPathFocus(parentPath);
  }, [isEmptyValue, onPathOpen, member.item.path, onPathFocus, onRemove]), handleSelectFieldGroup = React.useCallback(
    (groupName) => {
      onFieldGroupSelect(member.item.path, groupName);
    },
    [onFieldGroupSelect, member.item.path]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.item.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.item.id, member.item.schemaType.description)
    }),
    [handleBlur, handleFocus, member.item.id, member.item.schemaType.description]
  ), inputProps = React.useMemo(() => ({
    changed: member.item.changed,
    focusPath: member.item.focusPath,
    focused: member.item.focused,
    groups: member.item.groups,
    id: member.item.id,
    level: member.item.level,
    members: member.item.members,
    onChange: handleChange,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldSetCollapse: handleCollapseFieldSet,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onFieldGroupSelect: handleSelectFieldGroup,
    onPathFocus: handleFocusChildPath,
    onFieldOpen: handleOpenField,
    path: member.item.path,
    presence: member.item.presence,
    readOnly: member.item.readOnly,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    schemaType: member.item.schemaType,
    validation: member.item.validation,
    value: member.item.value,
    elementProps
  }), [
    elementProps,
    handleChange,
    handleCloseField,
    handleCollapseField,
    handleCollapseFieldSet,
    handleExpandField,
    handleExpandFieldSet,
    handleFocusChildPath,
    handleOpenField,
    handleSelectFieldGroup,
    member.item.changed,
    member.item.focusPath,
    member.item.focused,
    member.item.groups,
    member.item.id,
    member.item.level,
    member.item.members,
    member.item.path,
    member.item.presence,
    member.item.readOnly,
    member.item.schemaType,
    member.item.validation,
    member.item.value,
    renderAnnotation,
    renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem2,
    renderPreview
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), itemProps = React.useMemo(() => ({
    key: member.key,
    index: member.index,
    level: member.item.level,
    value: member.item.value,
    title: member.item.schemaType.title,
    description: member.item.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    schemaType: member.item.schemaType,
    parentSchemaType: member.parentSchemaType,
    onInsert: handleInsert,
    onRemove,
    presence: member.item.presence,
    validation: member.item.validation,
    open: member.open,
    onOpen: handleOpen,
    onClose: handleClose,
    onExpand: handleExpand,
    onCollapse: handleCollapse,
    readOnly: member.item.readOnly,
    focused: member.item.focused,
    onFocus: handleFocus,
    onBlur: handleBlur,
    inputId: member.item.id,
    path: member.item.path,
    children: renderedInput,
    changed: member.item.changed,
    inputProps
  }), [
    member.key,
    member.index,
    member.item.level,
    member.item.value,
    member.item.schemaType,
    member.parentSchemaType,
    member.item.presence,
    member.item.validation,
    member.item.readOnly,
    member.item.focused,
    member.item.id,
    member.item.path,
    member.item.changed,
    member.collapsible,
    member.collapsed,
    member.open,
    handleInsert,
    onRemove,
    handleOpen,
    handleClose,
    handleExpand,
    handleCollapse,
    handleFocus,
    handleBlur,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onPathOpen,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderItem2(itemProps), [itemProps, renderItem2])
    }
  );
}
const PopoverCard$2 = styledComponents.styled(ui.Card)`
  max-width: ${({ theme: theme2 }) => theme2.sanity.container[1]}px;
`;
function IncompatibleItemType$2(props2) {
  const { value, onFocus, vertical, ...rest } = props2, [showDetails, setShowDetails] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), { t: t2 } = useTranslation();
  ui.useClickOutside(() => setShowDetails(!1), [popoverRef]);
  const handleKeyDown = React.useCallback((e) => {
    (e.key === "Escape" || e.key === "Tab") && setShowDetails(!1);
  }, []), handleShowDetails = React.useCallback(() => {
    setShowDetails((v) => !v);
  }, []), typeName = content.resolveTypeName(value);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      open: showDetails,
      ref: setPopoverRef,
      onKeyDown: handleKeyDown,
      portal: !0,
      constrainSize: !0,
      tone: "default",
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverCard$2, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.type-is-incompatible-prompt",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.type-is-incompatible-title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.current-schema-not-declare-description",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(icons.BulbOutlineIcon, {}),
          " ",
          t2("inputs.array.error.can-delete-but-no-edit-description")
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.json-representation-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, overflow: "auto", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })
        ] })
      ] }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: "button",
          type: "button",
          radius: 2,
          tone: "inherit",
          paddingX: 2,
          paddingY: 3,
          flex: 1,
          onFocus,
          onClick: handleShowDetails,
          onKeyDown: handleKeyDown,
          __unstable_focusRing: !0,
          ...rest,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(
              Translate,
              {
                t: t2,
                i18nKey: "inputs.array.error.type-is-incompatible-prompt",
                values: { typeName }
              }
            ) }) })
          ] })
        }
      )
    }
  );
}
function MemberItemError(props2) {
  const { member } = props2, { t: t2 } = useTranslation();
  return member.error.type === "INVALID_ITEM_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType$2, { value: member.error.value }) : /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("inputs.array.error.unexpected-error", { error: member.error.type }) });
}
function ArrayOfObjectsInputMember(props2) {
  const {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  } = props2;
  return member.kind === "item" ? /* @__PURE__ */ jsxRuntime.jsx(
    ArrayOfObjectsItem,
    {
      member,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview
    },
    member.key
  ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberItemError, { member }, member.key) : (console.warn(new Error(`Unhandled member kind ${member.kind}`)), null);
}
function ArrayOfObjectsInputMembers(props2) {
  const { members, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: members.map((member) => /* @__PURE__ */ jsxRuntime.jsx(ArrayOfObjectsInputMember, { member, ...rest }, member.key)) });
}
function getEmptyValue(type) {
  switch (type.jsonType) {
    case "string":
      return "";
    case "number":
      return -0;
    case "boolean":
      return !1;
    default:
      throw new Error(`Unable to create value from type "${type.jsonType}"`);
  }
}
function resolveNativeNumberInputValue(schemaType, value, localValue) {
  return types.isNumberSchemaType(schemaType) && typeof localValue == "string" && Number(localValue) === value ? localValue : String(value != null ? value : "");
}
function ArrayOfPrimitivesItem(props2) {
  const focusRef = React.useRef(), { member, renderItem: renderItem2, renderInput } = props2, [localValue, setLocalValue] = React.useState(), { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
  useDidUpdate(member.item.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleBlur = React.useCallback(
    (event) => {
      onPathBlur(member.item.path);
    },
    [member.item.path, onPathBlur]
  ), handleFocus = React.useCallback(
    (event) => {
      onPathFocus(member.item.path);
    },
    [member.item.path, onPathFocus]
  ), handleChange = React.useCallback(
    (event) => {
      onChange(PatchEvent.from(event).prefixAll(member.index));
    },
    [onChange, member.index]
  ), handleNativeChange = React.useCallback(
    (event) => {
      let inputValue = event.currentTarget.value;
      if (types.isNumberSchemaType(member.item.schemaType)) {
        if (inputValue = event.currentTarget.valueAsNumber, inputValue > Number.MAX_SAFE_INTEGER || inputValue < Number.MIN_SAFE_INTEGER)
          return;
      } else types.isBooleanSchemaType(member.item.schemaType) && (inputValue = event.currentTarget.checked);
      const hasEmptyValue = inputValue === "" || typeof inputValue == "number" && isNaN(inputValue);
      types.isNumberSchemaType(member.item.schemaType) && setLocalValue(hasEmptyValue ? void 0 : event.currentTarget.value), handleChange(
        set(
          hasEmptyValue ? (
            // Map direct unset patches to empty value instead in order to not *remove* elements as the user clears out the value
            // note: this creates the rather curious case where the input renders ´0´ when you try to clear it.
            getEmptyValue(member.item.schemaType)
          ) : inputValue
        )
      );
    },
    [handleChange, member.item.schemaType]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.item.id,
      ref: focusRef,
      onChange: handleNativeChange,
      value: resolveNativeInputValue(member.item.schemaType, member.item.value, localValue),
      readOnly: !!member.item.readOnly,
      placeholder: member.item.schemaType.placeholder,
      "aria-describedby": createDescriptionId(member.item.id, member.item.schemaType.description)
    }),
    [
      handleBlur,
      handleFocus,
      handleNativeChange,
      member.item.id,
      member.item.readOnly,
      member.item.schemaType,
      member.item.value,
      localValue
    ]
  ), inputProps = React.useMemo(() => ({
    changed: member.item.changed,
    level: member.item.level,
    value: member.item.value,
    readOnly: member.item.readOnly,
    schemaType: member.item.schemaType,
    id: member.item.id,
    path: member.item.path,
    focused: member.item.focused,
    onChange: handleChange,
    validation: member.item.validation,
    presence: member.item.presence,
    elementProps
  }), [
    member.item.changed,
    member.item.level,
    member.item.value,
    member.item.readOnly,
    member.item.schemaType,
    member.item.id,
    member.item.path,
    member.item.focused,
    member.item.validation,
    member.item.presence,
    handleChange,
    elementProps
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), onRemove = React.useCallback(() => {
    onChange(PatchEvent.from([unset([member.index])]));
  }, [member.index, onChange]), onInsert = React.useCallback(
    (event) => {
      onChange(PatchEvent.from([insert(event.items, event.position, [member.index])]));
    },
    [member.index, onChange]
  ), itemProps = React.useMemo(() => ({
    key: member.key,
    index: member.index,
    level: member.item.level,
    value: member.item.value,
    title: member.item.schemaType.title,
    description: member.item.schemaType.description,
    schemaType: member.item.schemaType,
    parentSchemaType: member.parentSchemaType,
    onInsert,
    onRemove,
    presence: member.item.presence,
    validation: member.item.validation,
    readOnly: member.item.readOnly,
    focused: member.item.focused,
    onFocus: handleFocus,
    onBlur: handleBlur,
    inputId: member.item.id,
    path: member.item.path,
    children: renderedInput
  }), [
    member.key,
    member.index,
    member.item.level,
    member.item.value,
    member.item.schemaType,
    member.item.presence,
    member.item.validation,
    member.item.readOnly,
    member.item.focused,
    member.item.id,
    member.item.path,
    member.parentSchemaType,
    onInsert,
    onRemove,
    handleFocus,
    handleBlur,
    renderedInput
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: React.useMemo(() => renderItem2(itemProps), [itemProps, renderItem2]) });
}
function resolveNativeInputValue(schemaType, value, localValue) {
  return Object.is(value, -0) ? "" : resolveNativeNumberInputValue(schemaType, value, localValue);
}
function createProtoArrayValue(type) {
  if (!types.isObjectSchemaType(type))
    throw new Error(
      `Invalid item type: "${type.type}". Default array input can only contain objects (for now)`
    );
  return { ...createProtoValue(type), _key: content.randomKey(12) };
}
const BEFORE = "before", AFTER = "after";
function arrayInsert(array, position, index, ...args) {
  if (position !== BEFORE && position !== AFTER)
    throw new Error(`Invalid position "${position}", must be either ${BEFORE} or ${AFTER}`);
  const items = flatten(...args);
  if (array.length === 0)
    return items;
  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === "after" ? idx + 1 : idx, copy = array.slice();
  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;
}
function flatten(...values2) {
  return values2.reduce((prev, item) => prev.concat(item), []);
}
const hasOwn = (obj, property) => Object.prototype.hasOwnProperty.call(obj, property);
function move$1(arr, from, to) {
  const nextValue = arr.slice(), val = nextValue[from];
  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;
}
function findTargetIndex(array, pathSegment) {
  if (typeof pathSegment == "number")
    return pathSegment;
  const index = findIndex__default.default(array, pathSegment);
  return index === -1 ? !1 : index;
}
function _arrayApply(value, patch2) {
  const nextValue = value.slice();
  if (patch2.path.length === 0) {
    if (patch2.type === "setIfMissing") {
      if (!Array.isArray(patch2.value))
        throw new Error("Cannot set value of an array to a non-array");
      return value === void 0 ? patch2.value : value;
    } else if (patch2.type === "set") {
      if (!Array.isArray(patch2.value))
        throw new Error("Cannot set value of an array to a non-array");
      return patch2.value;
    } else {
      if (patch2.type === "unset")
        return;
      if (patch2.type === "move") {
        if (!patch2.value || !hasOwn(patch2.value, "from") || !hasOwn(patch2.value, "to"))
          throw new Error(
            `Invalid value of 'move' patch. Expected a value with "from" and "to" indexes, instead got: ${JSON.stringify(
              patch2.value
            )}`
          );
        return move$1(nextValue, patch2.value.from, patch2.value.to);
      }
    }
    throw new Error(`Invalid array operation: ${patch2.type}`);
  }
  const [head, ...tail] = patch2.path, index = findTargetIndex(value, head);
  if (index === !1)
    return nextValue;
  if (tail.length === 0) {
    if (patch2.type === "insert") {
      const { position, items } = patch2;
      return arrayInsert(value, position, index, items);
    } else if (patch2.type === "unset") {
      if (typeof index != "number")
        throw new Error(`Expected array index to be a number, instead got "${index}"`);
      return nextValue.splice(index, 1), nextValue;
    }
  }
  return nextValue[index] = applyPatch(nextValue[index], {
    ...patch2,
    path: tail
  }), nextValue;
}
function _objectApply(value, patch2) {
  const nextValue = clone__default.default(value);
  if (patch2.path.length === 0) {
    if (patch2.type === "set") {
      if (!isObject__default.default(patch2.value))
        throw new Error("Cannot set value of an object to a non-object");
      return patch2.value;
    } else {
      if (patch2.type === "unset")
        return;
      if (patch2.type === "setIfMissing")
        return value === void 0 ? patch2.value : value;
    }
    throw new Error(`Invalid object operation: ${patch2.type}`);
  }
  const [head, ...tail] = patch2.path;
  if (typeof head != "string")
    throw new Error(`Expected field name to be a string, instad got: ${head}`);
  return tail.length === 0 && patch2.type === "unset" ? omit__default.default(nextValue, head) : (nextValue[head] = applyPatch(nextValue[head], {
    ...patch2,
    path: tail
  }), nextValue);
}
const OPERATIONS$1 = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
  },
  inc(currentValue, nextValue) {
    return currentValue + nextValue;
  },
  dec(currentValue, nextValue) {
    return currentValue - nextValue;
  }
}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function _primitiveApply(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES$1.includes(patch2.type))
    throw new Error(
      `Received patch of unsupported type "${patch2.type}" for primitives. This is most likely a bug.`
    );
  if (patch2.path.length > 0)
    throw new Error(
      `Cannot apply deep operations on primitive values. Received patch with type "${patch2.type}" and path "${patch2.path.map((path) => JSON.stringify(path)).join(".")} that targeted the value "${JSON.stringify(value)}"`
    );
  return OPERATIONS$1[patch2.type](value, patch2.value);
}
const OPERATIONS = {
  replace(currentValue, nextValue) {
    return nextValue;
  },
  set(currentValue, nextValue) {
    return nextValue;
  },
  setIfMissing(currentValue, nextValue) {
    return currentValue === void 0 ? nextValue : currentValue;
  },
  unset(currentValue, nextValue) {
  },
  diffMatchPatch(currentValue, dmpPatch) {
    const [result] = diffMatchPatch$1.applyPatches(diffMatchPatch$1.parsePatch(dmpPatch), currentValue, { allowExceedingIndices: !0 });
    return result;
  }
}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function _stringApply(value, patch2) {
  if (!SUPPORTED_PATCH_TYPES.includes(patch2.type))
    throw new Error(
      `Received patch of unsupported type: "${JSON.stringify(
        patch2.type
      )}" for string. This is most likely a bug.`
    );
  if (patch2.path.length > 0)
    throw new Error(
      `Cannot apply deep operations on string values. Received patch with type "${patch2.type}" and path "${patch2.path.join(".")} that targeted the value "${JSON.stringify(value)}"`
    );
  return OPERATIONS[patch2.type](value, patch2.value);
}
function applyAll(value, patches) {
  return patches.reduce(applyPatch, value);
}
function _applyPatch(value, patch2) {
  return Array.isArray(value) ? _arrayApply(value, patch2) : isString__default.default(value) ? _stringApply(value, patch2) : isObject__default.default(value) ? _objectApply(value, patch2) : _primitiveApply(value, patch2);
}
function applyPatch(value, patch2) {
  return _applyPatch(value, patch2);
}
function DocumentFieldActionsProvider(props2) {
  const value = React.useMemo(() => ({ actions: props2.actions || EMPTY_ARRAY$t }), [props2.actions]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.DocumentFieldActionsContext.Provider, { value, children: props2.children });
}
function useDocumentFieldActions() {
  const context = React.useContext(_singletons.DocumentFieldActionsContext);
  if (!context)
    throw new Error("useDocumentFieldActions must be used within a DocumentFieldActionsProvider");
  return context.actions;
}
function is$1(typeName, type) {
  return type.name === typeName || !!(type.type && is$1(typeName, type.type));
}
function accepts(file, acceptedFiles) {
  if (!file || !acceptedFiles)
    return !0;
  const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(","), fileName = file.name || "", mimeType = (file.type || "").toLowerCase(), baseMimeType = mimeType.replace(/\/.*$/, "");
  return acceptedFilesArray.some((type) => {
    const validType = type.trim().toLowerCase();
    return validType.charAt(0) === "." ? fileName ? fileName.toLowerCase().endsWith(validType) : !0 : validType.endsWith("/*") ? baseMimeType === validType.replace(/\/.*$/, "") : mimeType === validType;
  });
}
const DEFAULT_CONCURRENCY = 4;
function remove(array, item) {
  const index = array.indexOf(item);
  return index > -1 && array.splice(index, 1), array;
}
function withMaxConcurrency(func, concurrency = DEFAULT_CONCURRENCY) {
  const throttler = createThrottler(concurrency);
  return (...args) => rxjs.from(throttler(func(...args)));
}
function createThrottler(concurrency = DEFAULT_CONCURRENCY) {
  const currentSubscriptions = [], pendingObservables = [], ready$ = new rxjs.Subject();
  return request;
  function request(observable) {
    return new rxjs.Observable((observer) => {
      if (currentSubscriptions.length >= concurrency)
        return scheduleAndWait(observable).pipe(operators.mergeMap(request)).subscribe(observer);
      const subscription = observable.subscribe(observer);
      return currentSubscriptions.push(subscription), () => {
        remove(currentSubscriptions, subscription), remove(pendingObservables, observable), subscription.unsubscribe(), check();
      };
    });
  }
  function scheduleAndWait(observable) {
    return pendingObservables.push(observable), ready$.asObservable().pipe(operators.first((obs) => obs === observable));
  }
  function check() {
    for (; pendingObservables.length > 0 && currentSubscriptions.length < concurrency; )
      ready$.next(pendingObservables.shift());
  }
}
const MAX_CONCURRENT_UPLOADS = 4;
function uploadSanityAsset(client2, assetType, file, options = {}) {
  const extract = options.metadata, preserveFilename = options.storeOriginalFilename, { label, title, description, creditLine, source } = options;
  return hashFile(file).pipe(
    operators.catchError(
      () => (
        // ignore if hashing fails for some reason
        rxjs.of(null)
      )
    ),
    operators.mergeMap(
      (hash2) => (
        // note: the sanity api will still dedupe unique files, but this saves us from uploading the asset file entirely
        hash2 ? fetchExisting(client2, `sanity.${assetType}Asset`, hash2) : rxjs.of(null)
      )
    ),
    operators.mergeMap((existing) => existing ? rxjs.of({
      // complete with the existing asset document
      type: "complete",
      id: existing._id,
      asset: existing
    }) : client2.observable.assets.upload(assetType, file, {
      tag: "asset.upload",
      extract,
      preserveFilename,
      label,
      title,
      description,
      creditLine,
      source
    }).pipe(
      operators.map(
        (event) => event.type === "response" ? {
          // rewrite to a 'complete' event
          type: "complete",
          id: event.body.document._id,
          asset: event.body.document
        } : event
      )
    ))
  );
}
const uploadAsset = withMaxConcurrency(uploadSanityAsset, MAX_CONCURRENT_UPLOADS), uploadImageAsset = (client2, file, options) => uploadAsset(client2, "image", file, options), uploadFileAsset = (client2, file, options) => uploadAsset(client2, "file", file, options);
function observeAssetDoc(documentPreviewStore, id2) {
  return documentPreviewStore.observePaths({ _type: "reference", _ref: id2 }, [
    "originalFilename",
    "url",
    "metadata",
    "label",
    "title",
    "description",
    "creditLine",
    "source",
    "size"
  ]);
}
function observeImageAsset(documentPreviewStore, id2) {
  return observeAssetDoc(documentPreviewStore, id2);
}
function observeFileAsset(documentPreviewStore, id2) {
  return observeAssetDoc(documentPreviewStore, id2);
}
function fetchExisting(client2, type, hash2) {
  return client2.observable.fetch(
    "*[_type == $documentType && sha1hash == $hash][0]",
    { documentType: type, hash: hash2 },
    { tag: "asset.find-duplicate" }
  );
}
function readFile(file) {
  return new rxjs.Observable((subscriber) => {
    const reader = new FileReader();
    return reader.onload = () => {
      subscriber.next(reader.result), subscriber.complete();
    }, reader.onerror = (err) => {
      subscriber.error(err);
    }, reader.readAsArrayBuffer(file), () => {
      reader.abort();
    };
  });
}
function hashFile(file) {
  return !window.crypto || !window.crypto.subtle || !window.FileReader ? rxjs.of(null) : readFile(file).pipe(
    operators.mergeMap((arrayBuffer) => crypto.subtle.digest("SHA-1", arrayBuffer)),
    operators.map(hexFromBuffer)
  );
}
function hexFromBuffer(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x) => `00${x.toString(16)}`.slice(-2)).join("");
}
const UPLOAD_STATUS_KEY = "_upload", UNSET_UPLOAD_PATCH = unset([UPLOAD_STATUS_KEY]);
function createUploadEvent(patches = []) {
  return {
    type: "uploadProgress",
    patches
  };
}
const CLEANUP_EVENT = createUploadEvent([UNSET_UPLOAD_PATCH]);
function createInitialUploadEvent(file) {
  const now = (/* @__PURE__ */ new Date()).toISOString(), value = {
    progress: 2,
    createdAt: now,
    updatedAt: now,
    file: { name: file.name, type: file.type }
  };
  return createUploadEvent([set(value, [UPLOAD_STATUS_KEY])]);
}
function uploadFile(client2, file, options) {
  const upload$ = uploadFileAsset(client2, file, options).pipe(
    operators.map((event) => event.type === "complete" ? createUploadEvent([
      set({ _type: "reference", _ref: event.asset._id }, ["asset"]),
      set(100, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updated"])
    ]) : createUploadEvent([
      set(event.percent, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updated"])
    ]))
  );
  return rxjs.concat(rxjs.of(createInitialUploadEvent(file)), upload$, rxjs.of(CLEANUP_EVENT));
}
function rotated(n) {
  return [5, 6, 7, 8].indexOf(n) > -1;
}
function rotate$1(ctx, options) {
  const x = options.x, y = options.y, radians = (options.degrees || 0) * (Math.PI / 180);
  ctx == null || ctx.translate(x, y), ctx == null || ctx.rotate(radians), ctx == null || ctx.translate(-x, -y);
}
function flip(canvas, x, y) {
  const ctx = canvas.getContext("2d");
  ctx == null || ctx.translate(x ? canvas.width : 0, y ? canvas.height : 0), ctx == null || ctx.scale(x ? -1 : 1, y ? -1 : 1);
}
const ORIENTATION_OPS = [
  { op: "none", degrees: 0 },
  { op: "flip-x", degrees: 0 },
  {
    op: "none",
    degrees: 180
  },
  { op: "flip-y", degrees: 0 },
  { op: "flip-x", degrees: 90 },
  { op: "none", degrees: 90 },
  {
    op: "flip-x",
    degrees: -90
  },
  { op: "none", degrees: -90 }
], ORIENTATIONS = [
  "top-left",
  "top-right",
  "bottom-right",
  "bottom-left",
  "left-top",
  "right-top",
  "right-bottom",
  "left-bottom"
], DEFAULT_ORIENTATION = "top-left", THUMB_SIZE = 120;
function _orient(img, orientationNumber) {
  const orientation = ORIENTATION_OPS[orientationNumber - 1], ratio = img.height / img.width;
  img.width = THUMB_SIZE / ratio, img.height = img.width * ratio;
  const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
  if (rotated(orientationNumber) ? (canvas.height = img.width, canvas.width = img.height) : (canvas.width = img.width, canvas.height = img.height), orientation.op === "flip-x" && flip(canvas, !0, !1), orientation.op === "flip-y" && flip(canvas, !1, !0), orientation.degrees && (rotate$1(ctx, {
    degrees: orientation.degrees,
    x: canvas.width / 2,
    y: canvas.height / 2
  }), rotated(orientationNumber))) {
    const d = canvas.width - canvas.height;
    ctx == null || ctx.translate(d / 2, -d / 2);
  }
  return ctx == null || ctx.drawImage(img, 0, 0, img.width, img.height), canvas;
}
function orient(image, orientationId) {
  return new rxjs.Observable((observer) => {
    const orientation = ORIENTATIONS.indexOf(orientationId) + 1, canvas = _orient(image, orientation);
    observer.next(canvas.toDataURL("image/jpeg", 0.1)), observer.complete();
  });
}
function readFileAsArrayBuffer(file, length) {
  return new rxjs.Observable((observer) => {
    const reader = new window.FileReader();
    return reader.onerror = (err) => observer.error(err), reader.onload = () => {
      observer.next(reader.result), observer.complete();
    }, reader.readAsArrayBuffer(file.slice(0, length)), () => reader.abort();
  });
}
const SKIP_EXIF_ERROR_RE = /(invalid image format)|(No exif data)/i, EXIF_BUFFER_LENGTH = 128e3;
function readExif(file) {
  return rxjs.from(readFileAsArrayBuffer(file, EXIF_BUFFER_LENGTH)).pipe(
    operators.map((buf) => exif__default.default(buf)),
    operators.catchError((error) => (SKIP_EXIF_ERROR_RE.test(error.message) || console.warn(`Exif read failed, continuing anyway: ${error.message}`), rxjs.of({})))
  );
}
function loadImage$1(url) {
  return new rxjs.Observable((observer) => {
    const image = new window.Image();
    return image.onerror = () => {
      observer.error(
        new Error(`Could not load image from url "${url}". Image may be of an unsupported format`)
      );
    }, image.onload = () => {
      observer.next(image), observer.complete();
    }, image.src = url, () => {
    };
  });
}
function rotateImage(file, orientation) {
  return loadImage$1(window.URL.createObjectURL(file)).pipe(
    operators.mergeMap((image) => orient(image, orientation))
  );
}
function uploadImage(client2, file, options) {
  const upload$ = uploadImageAsset(client2, file, options).pipe(
    operators.filter((event) => event.stage !== "download"),
    operators.map((event) => ({
      ...event,
      progress: 2 + event.percent / 100 * 98
    })),
    operators.map((event) => event.type === "complete" ? createUploadEvent([
      set({ _type: "reference", _ref: event.asset._id }, ["asset"]),
      set(100, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updatedAt"])
    ]) : createUploadEvent([
      set(event.percent, [UPLOAD_STATUS_KEY, "progress"]),
      set((/* @__PURE__ */ new Date()).toISOString(), [UPLOAD_STATUS_KEY, "updatedAt"])
    ]))
  ), setPreviewUrl$ = readExif(file).pipe(
    operators.mergeMap(
      (exifData) => rotateImage(file, exifData.orientation || DEFAULT_ORIENTATION)
    ),
    operators.catchError((error) => (console.warn(
      'Image preprocessing failed for "%s" with the error: %s',
      file.name,
      error.message
    ), rxjs.of(null))),
    operators.filter(Boolean),
    operators.map((imageUrl) => createUploadEvent([set(imageUrl, [UPLOAD_STATUS_KEY, "previewImage"])]))
  );
  return rxjs.concat(
    rxjs.of(createInitialUploadEvent(file)),
    rxjs.merge(upload$, setPreviewUrl$),
    rxjs.of(CLEANUP_EVENT)
  );
}
const UPLOAD_IMAGE = {
  type: "image",
  accepts: "image/*",
  upload: (client2, file, type, options) => uploadImage(client2, file, options)
}, UPLOAD_FILE = {
  type: "file",
  accepts: "",
  upload: (client2, file, type, options) => uploadFile(client2, file, options)
}, UPLOAD_TEXT = {
  type: "string",
  accepts: "text/*",
  upload: (client2, file, type, options) => uploadFile(client2, file, options).pipe(
    operators.map((content2) => ({
      type: "uploadProgress",
      patches: [set(content2)]
    }))
  )
  // Todo: promote this to a "first-class" form-builder abstraction
  // and make it possible to register custom uploaders
}, uploaders = [UPLOAD_IMAGE, UPLOAD_TEXT, UPLOAD_FILE].map(
  (uploader, i) => ({
    ...uploader,
    priority: i
  })
);
function resolveUploader(type, file) {
  return uploaders.find((uploader) => {
    var _a2;
    return is$1(uploader.type, type) && accepts(file, uploader.accepts) && accepts(file, ((_a2 = type.options) == null ? void 0 : _a2.accept) || "");
  }) || null;
}
function ArrayOfObjectsField(props2) {
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onPathOpen,
    onFieldGroupSelect
  } = useFormCallbacks(), {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), uploadSubscriptions = React.useRef({});
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleFocus = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathFocus(member.field.path);
    },
    [member.field.path, onPathFocus]
  ), handleBlur = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathBlur(member.field.path);
    },
    [member.field.path, onPathBlur]
  ), valueRef = React.useRef(member.field.value);
  React.useEffect(() => {
    valueRef.current = member.field.value;
  }, [member.field.value]);
  const handleChange = React.useCallback(
    (event) => {
      const patches = PatchEvent.from(event).patches;
      if (patches.some(
        (patch2) => patch2.type === "unset" && patch2.path.length === 1
      ) && (valueRef.current = applyAll(valueRef.current || [], patches), Array.isArray(valueRef.current) && !valueRef.current.length)) {
        onChange(PatchEvent.from(unset([member.name])));
        return;
      }
      onChange(PatchEvent.from(event).prepend(setIfMissing([])).prefixAll(member.name));
    },
    [onChange, member.name, valueRef]
  ), resolveInitialValue2 = useResolveInitialValueForType(), toast = ui.useToast(), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !0);
  }, [onSetPathCollapsed, member.field.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !1);
  }, [onSetPathCollapsed, member.field.path]), handleCollapseItem = React.useCallback(
    (itemKey) => {
      onSetPathCollapsed(member.field.path.concat({ _key: itemKey }), !0);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleExpandItem = React.useCallback(
    (itemKey) => {
      onSetPathCollapsed(member.field.path.concat({ _key: itemKey }), !1);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleOpenItem = React.useCallback(
    (path) => {
      onPathOpen(path), onSetPathCollapsed(path, !1);
    },
    [onPathOpen, onSetPathCollapsed]
  ), handleCloseItem = React.useCallback(() => {
    onPathOpen(member.field.path), onSetPathCollapsed(member.field.path, !0);
  }, [onPathOpen, member.field.path, onSetPathCollapsed]), handleInsert = React.useCallback(
    (event) => {
      if (event.items.length === 0)
        throw new Error("Insert event should include at least one item");
      const itemsWithKeys = event.items.map((item) => ensureKey(item));
      handleChange(PatchEvent.from([insert(itemsWithKeys, event.position, [event.referenceItem])]));
      const focusItemKey = itemsWithKeys[0]._key, itemPath = [...member.field.path, { _key: focusItemKey }];
      onPathFocus(itemPath);
      const shouldOpen = event.open !== !1;
      event.skipInitialValue ? shouldOpen && handleOpenItem(itemPath) : resolveInitialArrayValues(itemsWithKeys, member.field.schemaType, resolveInitialValue2).pipe(
        operators.tap((result) => {
          result.type === "patch" ? handleChange(result.patches) : toast.push({
            title: "Could not resolve initial value",
            description: `Unable to resolve initial value for type: ${result.schemaType.title}: ${result.error.message}.`,
            status: "error"
          });
        })
      ).subscribe({
        complete: () => {
          shouldOpen && handleOpenItem(itemPath);
        }
      });
    },
    [
      handleChange,
      handleOpenItem,
      member.field.path,
      member.field.schemaType,
      onPathFocus,
      resolveInitialValue2,
      toast
    ]
  ), handleMoveItem = React.useCallback(
    (event) => {
      const value = member.field.value, item = value == null ? void 0 : value[event.fromIndex], refItem = value == null ? void 0 : value[event.toIndex];
      if (event.fromIndex !== event.toIndex) {
        if (!(item != null && item._key) || !(refItem != null && refItem._key)) {
          console.error(
            "Neither the item you are moving nor the item you are moving to have a key. Cannot continue."
          );
          return;
        }
        handleChange([
          unset([{ _key: item._key }]),
          insert([item], event.fromIndex > event.toIndex ? "before" : "after", [
            { _key: refItem._key }
          ])
        ]);
      }
    },
    [handleChange, member.field.value]
  ), handlePrependItem = React.useCallback(
    (item) => {
      handleChange([setIfMissing([]), insert([ensureKey(item)], "before", [0])]);
    },
    [handleChange]
  ), handleAppendItem = React.useCallback(
    (item) => {
      handleChange([setIfMissing([]), insert([ensureKey(item)], "after", [-1])]);
    },
    [handleChange]
  ), handleRemoveItem = React.useCallback(
    (itemKey) => {
      uploadSubscriptions.current[itemKey] && (uploadSubscriptions.current[itemKey].unsubscribe(), delete uploadSubscriptions.current[itemKey]), handleChange([unset([{ _key: itemKey }])]);
    },
    [handleChange]
  ), handleFocusChildPath = React.useCallback(
    (path, payload) => {
      onPathFocus(member.field.path.concat(path), payload);
    },
    [member.field.path, onPathFocus]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]
  ), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), formBuilder = useFormBuilder(), supportsImageUploads = formBuilder.__internal.image.directUploads, supportsFileUploads = formBuilder.__internal.file.directUploads, resolveUploader$1 = React.useCallback(
    (type, file) => is$1("image", type) && !supportsImageUploads || is$1("file", type) && !supportsFileUploads ? null : resolveUploader(type, file),
    [supportsFileUploads, supportsImageUploads]
  ), handleUpload = React.useCallback(
    ({ file, schemaType, uploader }) => {
      const item = createProtoArrayValue(schemaType), key = item._key;
      handleInsert({
        items: [item],
        position: "after",
        referenceItem: -1,
        open: !1
      });
      const events$ = uploader.upload(client2, file, schemaType).pipe(
        operators.map(
          (uploadProgressEvent) => PatchEvent.from(uploadProgressEvent.patches || []).prefixAll({ _key: key })
        ),
        operators.tap((event) => handleChange(event.patches))
      );
      uploadSubscriptions.current = {
        ...uploadSubscriptions.current,
        [key]: events$.subscribe()
      };
    },
    [client2, handleChange, handleInsert]
  ), inputProps = React.useMemo(() => ({
    level: member.field.level,
    members: member.field.members,
    value: member.field.value,
    readOnly: member.field.readOnly,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    onItemExpand: handleExpandItem,
    onItemCollapse: handleCollapseItem,
    onItemClose: handleCloseItem,
    onItemOpen: handleOpenItem,
    focusPath: member.field.focusPath,
    focused: member.field.focused,
    path: member.field.path,
    onChange: handleChange,
    onInsert: handleInsert,
    onItemMove: handleMoveItem,
    onItemRemove: handleRemoveItem,
    onItemAppend: handleAppendItem,
    onItemPrepend: handlePrependItem,
    onPathFocus: handleFocusChildPath,
    resolveInitialValue: resolveInitialValue2,
    onUpload: handleUpload,
    resolveUploader: resolveUploader$1,
    validation: member.field.validation,
    presence: member.field.presence,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderInlineBlock,
    renderInput,
    renderField,
    renderItem: renderItem2,
    renderPreview,
    elementProps
  }), [
    member.field.level,
    member.field.members,
    member.field.value,
    member.field.readOnly,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.focusPath,
    member.field.focused,
    member.field.path,
    member.field.validation,
    member.field.presence,
    handleExpandItem,
    handleCollapseItem,
    handleCloseItem,
    handleOpenItem,
    handleChange,
    handleInsert,
    handleMoveItem,
    handleRemoveItem,
    handleAppendItem,
    handlePrependItem,
    handleFocusChildPath,
    resolveInitialValue2,
    handleUpload,
    resolveUploader$1,
    renderAnnotation,
    renderBlock2,
    renderInlineBlock,
    renderInput,
    renderField,
    renderItem2,
    renderPreview,
    elementProps
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    name: member.name,
    index: member.index,
    level: member.field.level,
    value: member.field.value,
    title: member.field.schemaType.title,
    description: member.field.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    changed: member.field.changed,
    onCollapse: handleCollapse,
    onExpand: handleExpand,
    schemaType: member.field.schemaType,
    inputId: member.field.id,
    path: member.field.path,
    presence: member.field.presence,
    validation: member.field.validation,
    children: renderedInput,
    inputProps
  }), [
    fieldActions,
    member.name,
    member.index,
    member.field.level,
    member.field.value,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.presence,
    member.field.validation,
    member.collapsible,
    member.collapsed,
    handleCollapse,
    handleExpand,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      onPathOpen,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderField(fieldProps), [fieldProps, renderField])
    }
  );
}
function readAsText(file, encoding) {
  return new rxjs.Observable((observer) => {
    const reader = new FileReader();
    return reader.onerror = (error) => observer.error(error), reader.onload = () => {
      observer.next(reader.result), observer.complete();
    }, reader.readAsText(file, encoding), () => {
      reader.abort();
    };
  });
}
function move(arr, from, to) {
  const copy = arr.slice(), val = copy[from];
  return copy.splice(from, 1), copy.splice(to, 0, val), copy;
}
function insertAfter(index, arr, items) {
  const copy = arr.slice();
  return copy.splice(index + 1, 0, ...items), copy;
}
function isStringNumeric(input) {
  return /^\d+$/.test(input);
}
function convertToSchemaType(line, candidates) {
  let acceptsBooleans = !1, acceptsNumbers = !1, acceptsStrings = !1;
  return candidates.forEach((candidate) => {
    types.isBooleanSchemaType(candidate) && (acceptsBooleans = !0), types.isStringSchemaType(candidate) && (acceptsStrings = !0), types.isNumberSchemaType(candidate) && (acceptsNumbers = !0);
  }), acceptsBooleans && (line === "true" || line === "false") ? line === "true" : acceptsNumbers && isStringNumeric(line) ? Number(line) : acceptsStrings ? line : void 0;
}
function createPlainTextUploader(itemTypes) {
  return {
    priority: 0,
    accepts: "text/*",
    type: "string",
    upload(client2, file) {
      return readAsText(file, "utf-8").pipe(
        operators.map(
          (textContent) => textContent == null ? void 0 : textContent.split(/[\n\r]/).map((value) => convertToSchemaType(value, itemTypes)).filter((v) => v !== void 0)
        ),
        operators.filter((v) => Array.isArray(v)),
        operators.map((lines) => ({
          type: "uploadProgress",
          patches: [insert(lines, "after", [-1])]
        }))
      );
    }
  };
}
function ArrayOfPrimitivesField(props2) {
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onPathOpen,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onFieldGroupSelect
  } = useFormCallbacks(), {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), uploadSubscriptions = React.useRef(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleFocus = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathFocus(member.field.path);
    },
    [member.field.path, onPathFocus]
  ), handleBlur = React.useCallback(
    (event) => {
      event.currentTarget === event.target && event.currentTarget === focusRef.current && onPathBlur(member.field.path);
    },
    [member.field.path, onPathBlur]
  ), handleChange = React.useCallback(
    (event) => {
      const patches = PatchEvent.from(event).patches;
      if (patches.some(
        (patch2) => patch2.type === "unset" && patch2.path.length === 1
      )) {
        const result = applyAll(member.field.value || [], patches);
        if (Array.isArray(result) && !result.length) {
          onChange(PatchEvent.from(unset([member.name])));
          return;
        }
      }
      onChange(PatchEvent.from(event).prepend(setIfMissing([])).prefixAll(member.name));
    },
    [onChange, member.name, member.field.value]
  ), handleSetCollapsed = React.useCallback(
    (collapsed) => {
      onSetPathCollapsed(member.field.path, collapsed);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !0);
  }, [onSetPathCollapsed, member.field.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !1);
  }, [onSetPathCollapsed, member.field.path]), setValue = React.useCallback(
    (nextValue) => {
      handleChange(nextValue.length === 0 ? unset() : set(nextValue));
    },
    [handleChange]
  ), handleMoveItem = React.useCallback(
    (event) => {
      const { value = [] } = member.field;
      event.fromIndex !== event.toIndex && setValue(move(value, event.fromIndex, event.toIndex));
    },
    [member.field, setValue]
  ), handleAppend = React.useCallback(
    (itemValue) => {
      const { value = [] } = member.field;
      setValue(value.concat(itemValue));
    },
    [member.field, setValue]
  ), handlePrepend = React.useCallback(
    (itemValue) => {
      const { value = [] } = member.field;
      setValue([itemValue].concat(value || []));
    },
    [member.field, setValue]
  ), handleInsert = React.useCallback(
    (event) => {
      const { value = [] } = member.field, insertIndex = event.referenceIndex + (event.position === "before" ? -1 : 0);
      setValue(insertAfter(insertIndex, value, event.items));
    },
    [member.field, setValue]
  ), handleRemoveItem = React.useCallback(
    (index) => {
      handleChange(unset([index]));
    },
    [handleChange]
  ), handleFocusIndex = React.useCallback(
    (index) => {
      onPathFocus(member.field.path.concat([index]));
    },
    [member.field.path, onPathFocus]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]
  ), plainTextUploader = React.useMemo(
    () => createPlainTextUploader(member.field.schemaType.of),
    [member.field.schemaType.of]
  ), resolveUploader2 = React.useCallback(
    (schemaType, file) => accepts(file, "text/*") ? plainTextUploader : null,
    [plainTextUploader]
  ), handleUpload = React.useCallback(
    ({ file, schemaType, uploader }) => {
      const events$ = uploader.upload(client2, file, schemaType).pipe(
        operators.map(
          (uploadProgressEvent) => PatchEvent.from(uploadProgressEvent.patches || [])
        ),
        operators.tap((event) => handleChange(event.patches))
      );
      uploadSubscriptions.current && uploadSubscriptions.current.unsubscribe(), uploadSubscriptions.current = events$.subscribe();
    },
    [client2, handleChange]
  ), inputProps = React.useMemo(() => ({
    level: member.field.level,
    members: member.field.members,
    value: member.field.value,
    readOnly: member.field.readOnly,
    onSetCollapsed: handleSetCollapsed,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    elementProps,
    path: member.field.path,
    focusPath: member.field.focusPath,
    focused: member.field.focused,
    onChange: handleChange,
    onInsert: handleInsert,
    onMoveItem: handleMoveItem,
    onItemRemove: handleRemoveItem,
    onItemAppend: handleAppend,
    onItemPrepend: handlePrepend,
    validation: member.field.validation,
    presence: member.field.presence,
    resolveUploader: resolveUploader2,
    onUpload: handleUpload,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    onIndexFocus: handleFocusIndex,
    renderPreview
  }), [
    member.field.level,
    member.field.members,
    member.field.value,
    member.field.readOnly,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.focusPath,
    member.field.focused,
    member.field.validation,
    member.field.presence,
    handleSetCollapsed,
    elementProps,
    handleChange,
    handleInsert,
    handleMoveItem,
    handleRemoveItem,
    handleAppend,
    handlePrepend,
    resolveUploader2,
    handleUpload,
    renderAnnotation,
    renderBlock2,
    renderInlineBlock,
    renderInput,
    renderItem2,
    handleFocusIndex,
    renderPreview
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    name: member.name,
    index: member.index,
    level: member.field.level,
    value: member.field.value,
    title: member.field.schemaType.title,
    description: member.field.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    onExpand: handleExpand,
    changed: member.field.changed,
    onCollapse: handleCollapse,
    schemaType: member.field.schemaType,
    inputId: member.field.id,
    path: member.field.path,
    presence: member.field.presence,
    validation: member.field.validation,
    children: renderedInput,
    inputProps
  }), [
    fieldActions,
    member.name,
    member.index,
    member.field.level,
    member.field.value,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.presence,
    member.field.validation,
    member.collapsible,
    member.collapsed,
    handleExpand,
    handleCollapse,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onPathOpen,
      onSetFieldSetCollapsed,
      onSetPathCollapsed,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderField(fieldProps), [fieldProps, renderField])
    }
  );
}
function isMemberObject(member) {
  return types.isObjectSchemaType(member.field.schemaType);
}
function isMemberArrayOfPrimitives(member) {
  return types.isArraySchemaType(member.field.schemaType) && member.field.schemaType.of.every((ofType) => types.isPrimitiveSchemaType(ofType));
}
function isMemberArrayOfObjects(member) {
  return types.isArraySchemaType(member.field.schemaType) && member.field.schemaType.of.every((ofType) => types.isObjectSchemaType(ofType));
}
const ObjectField = function(props2) {
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onPathOpen,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onFieldGroupSelect
  } = useFormCallbacks(), {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), pendingValue = React.useRef(member.field.value);
  React.useEffect(() => {
    pendingValue.current = member.field.value;
  }, [member.field.value]), useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = focusRef.current) == null || _a2.focus());
  });
  const handleBlur = React.useCallback(() => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]), handleFocus = React.useCallback(() => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]), handleFocusChildPath = React.useCallback(
    (path) => {
      onPathFocus(member.field.path.concat(path));
    },
    [member.field.path, onPathFocus]
  ), handleChange = React.useCallback(
    (event) => {
      if (member.field.path.length !== 0) {
        const patches = PatchEvent.from(event).patches;
        if (pendingValue.current = applyAll(pendingValue.current || {}, patches), pendingValue.current && content.isShallowEmptyObject(pendingValue.current)) {
          onChange(PatchEvent.from(unset([member.name])));
          return;
        }
      }
      onChange(
        PatchEvent.from(event).prepend(setIfMissing(createProtoValue(member.field.schemaType))).prefixAll(member.name)
      );
    },
    [onChange, member, pendingValue]
  ), handleCollapse = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !0);
  }, [onSetPathCollapsed, member.field.path]), handleExpand = React.useCallback(() => {
    onSetPathCollapsed(member.field.path, !1);
  }, [onSetPathCollapsed, member.field.path]), handleCollapseField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.field.path.concat(fieldName), !0);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleExpandField = React.useCallback(
    (fieldName) => {
      onSetPathCollapsed(member.field.path.concat(fieldName), !1);
    },
    [onSetPathCollapsed, member.field.path]
  ), handleOpenField = React.useCallback(
    (fieldName) => {
      onPathOpen(member.field.path.concat(fieldName));
    },
    [onPathOpen, member.field.path]
  ), handleCloseField = React.useCallback(() => {
    onPathOpen(member.field.path);
  }, [onPathOpen, member.field.path]), handleExpandFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.field.path.concat(fieldsetName), !1);
    },
    [onSetFieldSetCollapsed, member.field.path]
  ), handleCollapseFieldSet = React.useCallback(
    (fieldsetName) => {
      onSetFieldSetCollapsed(member.field.path.concat(fieldsetName), !0);
    },
    [onSetFieldSetCollapsed, member.field.path]
  ), handleOpen = React.useCallback(() => {
    onPathOpen(member.field.path);
  }, [onPathOpen, member.field.path]), handleClose = React.useCallback(() => {
    onPathOpen(member.field.path.slice(0, -1));
  }, [onPathOpen, member.field.path]), handleSelectFieldGroup = React.useCallback(
    (groupName) => {
      onFieldGroupSelect(member.field.path, groupName);
    },
    [onFieldGroupSelect, member.field.path]
  ), elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [handleBlur, handleFocus, member.field.id, member.field.schemaType.description]
  ), inputProps = React.useMemo(() => ({
    elementProps,
    level: member.field.level,
    members: member.field.members,
    value: member.field.value,
    readOnly: member.field.readOnly,
    validation: member.field.validation,
    presence: member.field.presence,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    onFieldGroupSelect: handleSelectFieldGroup,
    onFieldOpen: handleOpenField,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onFieldSetCollapse: handleCollapseFieldSet,
    onPathFocus: handleFocusChildPath,
    path: member.field.path,
    focusPath: member.field.focusPath,
    focused: member.field.focused,
    groups: member.field.groups,
    onChange: handleChange,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  }), [
    elementProps,
    member.field.level,
    member.field.members,
    member.field.value,
    member.field.readOnly,
    member.field.validation,
    member.field.presence,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.focusPath,
    member.field.focused,
    member.field.groups,
    handleSelectFieldGroup,
    handleOpenField,
    handleCloseField,
    handleCollapseField,
    handleExpandField,
    handleExpandFieldSet,
    handleCollapseFieldSet,
    handleFocusChildPath,
    handleChange,
    renderAnnotation,
    renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem2,
    renderPreview
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    name: member.name,
    index: member.index,
    level: member.field.level,
    value: member.field.value,
    validation: member.field.validation,
    presence: member.field.presence,
    title: member.field.schemaType.title,
    description: member.field.schemaType.description,
    collapsible: member.collapsible,
    collapsed: member.collapsed,
    onCollapse: handleCollapse,
    onExpand: handleExpand,
    open: member.open,
    changed: member.field.changed,
    onOpen: handleOpen,
    onClose: handleClose,
    schemaType: member.field.schemaType,
    inputId: member.field.id,
    path: member.field.path,
    children: renderedInput,
    inputProps
  }), [
    fieldActions,
    member.name,
    member.index,
    member.field.level,
    member.field.value,
    member.field.validation,
    member.field.presence,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.collapsible,
    member.collapsed,
    member.open,
    handleCollapse,
    handleExpand,
    handleOpen,
    handleClose,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onFieldGroupSelect,
      onChange: handleChange,
      onSetFieldSetCollapsed,
      onPathOpen,
      onSetPathCollapsed,
      onPathBlur,
      onPathFocus,
      children: React.useMemo(() => renderField(fieldProps), [fieldProps, renderField])
    }
  );
};
function PrimitiveField$1(props2) {
  const { member, renderInput, renderField } = props2, fieldActions = useDocumentFieldActions(), focusRef = React.useRef(), [localValue, setLocalValue] = React.useState(), { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
  React.useEffect(() => {
    var _a2;
    member.field.focused && ((_a2 = focusRef.current) == null || _a2.focus());
  }, [member.field.focused]);
  const handleBlur = React.useCallback(() => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]), handleFocus = React.useCallback(() => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]), handleChange = React.useCallback(
    (event) => {
      onChange(PatchEvent.from(event).prefixAll(member.name));
    },
    [onChange, member.name]
  ), handleNativeChange = React.useCallback(
    (event) => {
      let inputValue = event.currentTarget.value;
      if (types.isNumberSchemaType(member.field.schemaType)) {
        if (inputValue = event.currentTarget.valueAsNumber, inputValue > Number.MAX_SAFE_INTEGER || inputValue < Number.MIN_SAFE_INTEGER)
          return;
      } else types.isBooleanSchemaType(member.field.schemaType) && (inputValue = event.currentTarget.checked);
      const hasEmptyValue = inputValue === "" || typeof inputValue == "number" && isNaN(inputValue);
      types.isNumberSchemaType(member.field.schemaType) && setLocalValue(hasEmptyValue ? void 0 : event.currentTarget.value), onChange(PatchEvent.from(hasEmptyValue ? unset() : set(inputValue)).prefixAll(member.name));
    },
    [member.name, member.field.schemaType, onChange]
  ), validationError = React.useMemo(
    () => member.field.validation.filter((item) => item.level === "error").map((item) => item.message).join(`
`),
    [member.field.validation]
  ) || void 0, elementProps = React.useMemo(
    () => ({
      onBlur: handleBlur,
      onFocus: handleFocus,
      id: member.field.id,
      ref: focusRef,
      onChange: handleNativeChange,
      value: resolveNativeNumberInputValue(
        member.field.schemaType,
        member.field.value,
        localValue
      ),
      readOnly: !!member.field.readOnly,
      placeholder: member.field.schemaType.placeholder,
      "aria-describedby": createDescriptionId(member.field.id, member.field.schemaType.description)
    }),
    [
      handleBlur,
      handleFocus,
      handleNativeChange,
      member.field.id,
      member.field.readOnly,
      member.field.schemaType,
      member.field.value,
      localValue
    ]
  ), inputProps = React.useMemo(() => ({
    value: member.field.value,
    readOnly: member.field.readOnly,
    schemaType: member.field.schemaType,
    changed: member.field.changed,
    id: member.field.id,
    path: member.field.path,
    focused: member.field.focused,
    level: member.field.level,
    onChange: handleChange,
    validation: member.field.validation,
    presence: member.field.presence,
    validationError,
    elementProps
  }), [
    member.field.value,
    member.field.readOnly,
    member.field.schemaType,
    member.field.changed,
    member.field.id,
    member.field.path,
    member.field.focused,
    member.field.level,
    member.field.validation,
    member.field.presence,
    handleChange,
    validationError,
    elementProps
  ]), renderedInput = React.useMemo(() => renderInput(inputProps), [inputProps, renderInput]), fieldProps = React.useMemo(() => ({
    actions: fieldActions,
    changed: member.field.changed,
    children: renderedInput,
    description: member.field.schemaType.description,
    index: member.index,
    inputId: member.field.id,
    inputProps,
    level: member.field.level,
    name: member.name,
    path: member.field.path,
    presence: member.field.presence,
    schemaType: member.field.schemaType,
    title: member.field.schemaType.title,
    validation: member.field.validation,
    value: member.field.value
  }), [
    fieldActions,
    member.field.level,
    member.field.value,
    member.field.schemaType,
    member.field.id,
    member.field.path,
    member.field.validation,
    member.field.presence,
    member.field.changed,
    member.name,
    member.index,
    renderedInput,
    inputProps
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderField(fieldProps) });
}
const MemberField = React.memo(function(props2) {
  const {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  } = props2;
  return isMemberObject(member) ? /* @__PURE__ */ jsxRuntime.jsx(
    ObjectField,
    {
      member,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview
    }
  ) : isMemberArrayOfPrimitives(member) ? /* @__PURE__ */ jsxRuntime.jsx(
    ArrayOfPrimitivesField,
    {
      member,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInput,
      renderInlineBlock,
      renderItem: renderItem2,
      renderPreview
    }
  ) : isMemberArrayOfObjects(member) ? /* @__PURE__ */ jsxRuntime.jsx(
    ArrayOfObjectsField,
    {
      member,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(PrimitiveField$1, { member, renderField, renderInput });
}), STATUS_TONES$1 = {
  warning: "caution",
  error: "critical"
}, SuffixBox = styledComponents.styled(ui.Box)`
  border-top: 1px solid var(--card-border-color);
`;
function Alert(props2) {
  const { children, status = "warning", suffix, title, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { radius: 2, tone: STATUS_TONES$1[status], ...rest, "data-ui": "Alert", children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
        status === "warning" && /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}),
        status === "error" && /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {})
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, marginLeft: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: title }),
        children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children })
      ] })
    ] }),
    suffix && /* @__PURE__ */ jsxRuntime.jsx(SuffixBox, { children: suffix })
  ] });
}
const HeaderButton = styledComponents.styled.button`
  display: block;
  -webkit-font-smoothing: inherit;
  appearance: none;
  font: inherit;
  background: none;
  width: 100%;
  text-align: left;
  border: 0;
  margin: 0;
  padding: 0;
  outline: none;
`, ToggleArrow = styledComponents.styled(icons.ToggleArrowRightIcon)`
  transform: ${(props2) => props2.open ? "rotate(90deg)" : ""};
`, Header = styledComponents.styled(ui.Flex)`
  cursor: default;
`, IconBox = styledComponents.styled(ui.Box)`
  & > div > svg {
    transform: rotate(0);
    transition: transform 100ms;
  }

  &[data-open] > div > svg {
    transform: rotate(90deg);
  }
`;
function Details(props2) {
  const { children, open: openProp, icon, title = "Details", ...restProps } = props2, [open, setOpen] = React.useState(openProp || !1), handleToggle = React.useCallback(() => setOpen((v) => !v), []);
  return React.useEffect(() => setOpen(openProp || !1), [openProp]), /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { ...restProps, children: [
    /* @__PURE__ */ jsxRuntime.jsx(HeaderButton, { type: "button", onClick: handleToggle, children: /* @__PURE__ */ jsxRuntime.jsx(Header, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(IconBox, { "data-open": open ? "" : void 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ToggleArrow, { open }) }) }),
      icon && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 1, children: icon }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: title }) })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { hidden: !open, marginTop: 3, children })
  ] });
}
const TRUTHY_STRINGS = ["yes", "true", "1"], FALSEY_STRINGS = ["false", "no", "false", "0", "null"], BOOL_STRINGS = TRUTHY_STRINGS.concat(FALSEY_STRINGS), TRUE = () => !0, has = (prop) => (val) => val && val[prop], is = (typeName) => (val) => (val && val._type) === typeName;
function toLocalDate(input) {
  const newDate = new Date(input.getTime() + input.getTimezoneOffset() * 60 * 1e3), offset = input.getTimezoneOffset() / 60, hours = input.getHours();
  return newDate.setHours(hours - offset), newDate;
}
function getTZName() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch {
  }
  return null;
}
const converters = {
  string: {
    number: {
      test: Number,
      convert: Number
    },
    boolean: {
      test: (value) => BOOL_STRINGS.includes(value.toLowerCase()),
      convert: (value) => TRUTHY_STRINGS.includes(value.toLowerCase()) || !FALSEY_STRINGS.includes(value.toLowerCase())
    },
    richDate: {
      test: (value) => dateFns.isValid(value),
      convert: (value) => ({
        _type: "richDate",
        local: toLocalDate(new Date(value)).toJSON(),
        utc: new Date(value).toJSON(),
        timezone: getTZName(),
        offset: (/* @__PURE__ */ new Date()).getTimezoneOffset()
      })
    }
  },
  date: {
    richDate: {
      test: is("date"),
      convert: (value) => Object.assign({}, value, { _type: "richDate" })
    }
  },
  richDate: {
    datetime: {
      test: has("utc"),
      convert: (value) => value.utc
    }
  },
  number: {
    string: {
      test: TRUE,
      convert: String
    },
    boolean: {
      test: TRUE,
      convert: Number
    }
  },
  boolean: {
    string: {
      test: TRUE,
      convert: (value) => value ? "Yes" : "No"
    },
    number: {
      test: TRUE,
      convert: Number
    }
  }
};
function SetMissingTypeButton({
  value,
  targetType,
  onChange
}) {
  const itemValue = React.useMemo(() => ({ ...value, _type: targetType }), [targetType, value]), handleClick = React.useCallback(
    () => onChange(PatchEvent.from(setIfMissing(targetType, ["_type"])), itemValue),
    [itemValue, onChange, targetType]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      onClick: handleClick,
      text: t2("inputs.untyped-value.convert-button.text", {
        targetType
      })
    }
  );
}
function UnsetItemButton({
  value,
  onChange,
  validTypes
}) {
  const itemValue = React.useMemo(() => ({ ...value, _type: validTypes[0] }), [validTypes, value]), handleClick = React.useCallback(
    () => onChange(PatchEvent.from(unset()), itemValue),
    [itemValue, onChange]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      onClick: handleClick,
      tone: "critical",
      text: t2("inputs.untyped-value.unset-item-button.text")
    }
  );
}
function UntypedValueInput({ validTypes, value, onChange }) {
  const schema2 = useSchema(), isSingleValidType = validTypes.length === 1, isHoistedType = schema2.has(validTypes[0]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    Alert,
    {
      status: "warning",
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.untyped-value.title" }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(Details, { open: isDev, title: t2("inputs.untyped-value.details.title"), children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.untyped-value.description" }) }),
        isSingleValidType && !isHoistedType && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.untyped-value.details.description" }) }),
        !isSingleValidType && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.untyped-value.details.multi-type-description") }),
        !isSingleValidType && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 2, children: validTypes.map((validType) => /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "li", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx("code", { children: validType }) }, validType)) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h4", weight: "medium", size: 1, children: t2("inputs.untyped-value.details.json-dump-prefix") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, overflow: "auto", padding: 2, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", children: JSON.stringify(value, null, 2) }) })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: [1, 2, 2], gap: 1, children: [
          isSingleValidType && /* @__PURE__ */ jsxRuntime.jsx(SetMissingTypeButton, { onChange, targetType: validTypes[0], value }),
          /* @__PURE__ */ jsxRuntime.jsx(UnsetItemButton, { onChange, validTypes, value })
        ] })
      ] }) })
    }
  );
}
function getConverters(value, actualType, validTypes) {
  return actualType in converters ? Object.keys(converters[actualType]).filter((targetType) => validTypes.includes(targetType)).map((targetType) => ({
    from: actualType,
    to: targetType,
    ...converters[actualType][targetType]
  })).filter((converter) => converter.test(value)) : [];
}
const InvalidValueInput = React.forwardRef(
  (props2, ref) => {
    const { value, actualType, validTypes, onChange } = props2;
    React.useImperativeHandle(ref, () => ({
      // @todo
      focus: () => {
      }
    }));
    const handleClearClick = React.useCallback(() => {
      onChange(PatchEvent.from(unset()));
    }, [onChange]), handleConvertTo = React.useCallback(
      (converted) => {
        onChange(PatchEvent.from(set(converted)));
      },
      [onChange]
    ), converters2 = React.useMemo(
      () => getConverters(value, actualType, validTypes),
      [value, actualType, validTypes]
    ), { t: t2 } = useTranslation();
    if (isPlainObject__default.default(value) && !("_type" in value))
      return /* @__PURE__ */ jsxRuntime.jsx(
        UntypedValueInput,
        {
          value,
          validTypes,
          onChange
        }
      );
    const suffix = /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        onClick: handleClearClick,
        tone: "critical",
        text: t2("inputs.invalid-value.reset-button.text")
      }
    ) });
    return /* @__PURE__ */ jsxRuntime.jsxs(Alert, { status: "error", suffix, title: t2("inputs.invalid-value.title"), children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.invalid-value.description") }),
      /* @__PURE__ */ jsxRuntime.jsx(Details, { marginTop: 4, open: isDev, title: t2("inputs.invalid-value.details.title"), children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        validTypes.length === 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.invalid-value.details.description",
            values: {
              validType: validTypes[0]
            }
          }
        ) }),
        validTypes.length === 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.invalid-value.details.possible-reason") }),
        validTypes.length !== 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.invalid-value.details.multi-type-description") }),
        validTypes.length !== 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 2, children: validTypes.map((validType) => /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx("code", { children: validType }) }, validType)) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { marginTop: 2, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(
            Translate,
            {
              t: t2,
              i18nKey: "inputs.invalid-value.current-type",
              values: {
                actualType
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 2, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: JSON.stringify(value, null, 2) }) })
        ] }),
        converters2.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: converters2.map((converter) => /* @__PURE__ */ jsxRuntime.jsx(
          ConvertButton,
          {
            converter,
            onConvert: handleConvertTo,
            value
          },
          `${converter.from}-${converter.to}`
        )) })
      ] }) })
    ] });
  }
);
InvalidValueInput.displayName = "InvalidValueInput";
function ConvertButton({
  converter,
  onConvert,
  value
}) {
  const handleClick = React.useCallback(
    () => onConvert(converter.convert(value)),
    [converter, onConvert, value]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      onClick: handleClick,
      text: t2("inputs.invalid-value.convert-button.text", { targetType: converter.to })
    }
  );
}
function DuplicateKeysAlert(props2) {
  const { error, onChange } = props2, handleFixDuplicateKeys = React.useCallback(() => {
    onChange(
      PatchEvent.from(
        (error.duplicates || []).map(
          ([index, key]) => set(`${key}_deduped_${index}`, [index, "_key"])
        )
      )
    );
  }, [error.duplicates, onChange]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(FormField, { title: error.schemaType.title, description: error.schemaType.description, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "warning",
      suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          onClick: handleFixDuplicateKeys,
          text: t2("form.error.duplicate-keys-alert.generate-button.text"),
          tone: "caution"
        }
      ) }),
      title: t2("form.error.duplicate-keys-alert.title"),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.duplicate-keys-alert.summary") }),
        /* @__PURE__ */ jsxRuntime.jsx(
          Details,
          {
            marginTop: 4,
            open: isDev,
            title: t2("form.error.duplicate-keys-alert.details.title"),
            children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.duplicate-keys-alert.details.description" }) }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  t: t2,
                  i18nKey: "form.error.duplicate-keys-alert.details.additional-description"
                }
              ) })
            ] })
          }
        )
      ]
    }
  ) });
}
function MissingKeysAlert(props2) {
  const { error, onChange } = props2, handleFixMissingKeys = React.useCallback(() => {
    onChange(
      PatchEvent.from((error.value || []).map((val, i) => setIfMissing(content.randomKey(), [i, "_key"])))
    );
  }, [error.value, onChange]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(FormField, { title: error.schemaType.title, description: error.schemaType.description, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "warning",
      suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          onClick: handleFixMissingKeys,
          text: t2("form.error.missing-keys-alert.add-button.text"),
          tone: "caution"
        }
      ) }),
      title: t2("form.error.missing-keys-alert.title"),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.missing-keys-alert.summary") }),
        /* @__PURE__ */ jsxRuntime.jsx(
          Details,
          {
            marginTop: 4,
            open: isDev,
            title: t2("form.error.missing-keys-alert.details.title"),
            children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.missing-keys-alert.details.description" }) }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  t: t2,
                  i18nKey: "form.error.missing-keys-alert.details.additional-description"
                }
              ) })
            ] })
          }
        )
      ]
    }
  ) });
}
function MixedArrayAlert(props2) {
  const { error, onChange } = props2, handleRemoveNonObjectValues = () => {
    const patches = (error.value || []).flatMap((item, index) => isPlainObject__default.default(item) ? [] : [index]).reverse().map((index) => unset([index]));
    onChange(PatchEvent.from(patches));
  }, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(FormField, { title: error.schemaType.title, description: error.schemaType.description, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "error",
      suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          onClick: handleRemoveNonObjectValues,
          text: t2("form.error.mixed-array-alert.remove-button.text"),
          tone: "critical"
        }
      ) }),
      title: t2("form.error.mixed-array-alert.title"),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.mixed-array-alert.summary") }),
        /* @__PURE__ */ jsxRuntime.jsx(Details, { marginTop: 4, open: isDev, title: t2("form.error.mixed-array-alert.details.title"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("form.error.mixed-array-alert.details.description") }) }) })
      ]
    }
  ) });
}
function MemberFieldError(props2) {
  const { member } = props2, { onChange } = useFormCallbacks(), handleChange = React.useCallback(
    (event) => {
      onChange(PatchEvent.from(event).prefixAll(member.fieldName));
    },
    [onChange, member.fieldName]
  ), { t: t2 } = useTranslation();
  return member.error.type === "INCOMPATIBLE_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(
    InvalidValueInput,
    {
      value: member.error.value,
      onChange: handleChange,
      actualType: member.error.resolvedValueType,
      validTypes: [member.error.expectedSchemaType.name]
    }
  ) : member.error.type === "MISSING_KEYS" ? /* @__PURE__ */ jsxRuntime.jsx(MissingKeysAlert, { error: member.error, onChange: handleChange }) : member.error.type === "DUPLICATE_KEYS" ? /* @__PURE__ */ jsxRuntime.jsx(DuplicateKeysAlert, { error: member.error, onChange: handleChange }) : member.error.type === "MIXED_ARRAY" ? /* @__PURE__ */ jsxRuntime.jsx(MixedArrayAlert, { onChange: handleChange, error: member.error }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: t2("member-field-error.unexpected-error", { error: props2.member.error.type }) });
}
const MemberFieldSet = React.memo(function(props2) {
  var _a2;
  const {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview
  } = props2, { onSetFieldSetCollapsed } = useFormCallbacks(), handleCollapse = React.useCallback(() => {
    onSetFieldSetCollapsed(member.fieldSet.path, !0);
  }, [member.fieldSet.path, onSetFieldSetCollapsed]), handleExpand = React.useCallback(() => {
    onSetFieldSetCollapsed(member.fieldSet.path, !1);
  }, [member.fieldSet.path, onSetFieldSetCollapsed]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormFieldSet,
    {
      title: member.fieldSet.title || capitalize__default.default(member.fieldSet.name),
      description: member.fieldSet.description,
      level: member.fieldSet.level,
      collapsible: member.fieldSet.collapsible,
      collapsed: member.fieldSet.collapsed,
      onCollapse: handleCollapse,
      onExpand: handleExpand,
      columns: (_a2 = member == null ? void 0 : member.fieldSet) == null ? void 0 : _a2.columns,
      "data-testid": `fieldset-${member.fieldSet.name}`,
      inputId: member.fieldSet.name,
      children: member.fieldSet.members.map((fieldsetMember) => fieldsetMember.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member: fieldsetMember }, member.key) : /* @__PURE__ */ jsxRuntime.jsx(
        MemberField,
        {
          member: fieldsetMember,
          renderAnnotation,
          renderBlock: renderBlock2,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem: renderItem2,
          renderPreview
        },
        fieldsetMember.key
      ))
    }
  );
}), ObjectInputMember = React.memo(function(props2) {
  const {
    member,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderInput,
    renderInlineBlock,
    renderField,
    renderItem: renderItem2,
    renderPreview
  } = props2;
  return member.kind === "field" ? /* @__PURE__ */ jsxRuntime.jsx(
    MemberField,
    {
      member,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderInlineBlock,
      renderInput,
      renderField,
      renderItem: renderItem2,
      renderPreview
    },
    member.key
  ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member }, member.key) : member.kind === "fieldSet" ? /* @__PURE__ */ jsxRuntime.jsx(
    MemberFieldSet,
    {
      member,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderInlineBlock,
      renderInput,
      renderField,
      renderItem: renderItem2,
      renderPreview
    },
    member.key
  ) : (console.warn(new Error(`Unhandled member kind ${member.kind}`)), null);
});
function ObjectInputMembers(props2) {
  const {
    members,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderInput,
    renderInlineBlock,
    renderField,
    renderItem: renderItem2,
    renderPreview
  } = props2, renderMembers = React.useMemo(
    () => members.map((member) => /* @__PURE__ */ jsxRuntime.jsx(
      ObjectInputMember,
      {
        member,
        renderAnnotation,
        renderBlock: renderBlock2,
        renderField,
        renderInlineBlock,
        renderInput,
        renderItem: renderItem2,
        renderPreview
      },
      member.key
    )),
    [
      members,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderMembers });
}
const ObjectMembers = ObjectInputMembers;
function isObjectInputProps$1(inputProps) {
  return types.isObjectSchemaType(inputProps.schemaType);
}
function isArrayInputProps(inputProps) {
  return types.isArraySchemaType(inputProps.schemaType);
}
const pass = ({ children }) => children;
function hasAbsolutePath(a) {
  return "absolutePath" in a;
}
const FormInput = React.memo(function(props2) {
  const absolutePath = React.useMemo(() => hasAbsolutePath(props2) ? props2.absolutePath : props2.path.concat(props2.relativePath), [props2]), nullRender = React.useCallback(() => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: "Missing destination render function" }), []);
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormInputInner,
    {
      ...props2,
      absolutePath,
      destinationRenderAnnotation: props2.renderAnnotation || nullRender,
      destinationRenderBlock: props2.renderBlock || nullRender,
      destinationRenderField: props2.renderField,
      destinationRenderInlineBlock: props2.renderInlineBlock || nullRender,
      destinationRenderInput: props2.renderInput,
      destinationRenderItem: props2.renderItem,
      destinationRenderPreview: props2.renderPreview
    }
  );
}), FormInputInner = React.memo(function FormInputInner2(props2) {
  const {
    absolutePath,
    destinationRenderAnnotation,
    destinationRenderBlock,
    destinationRenderField,
    destinationRenderInlineBlock,
    destinationRenderInput,
    destinationRenderItem,
    destinationRenderPreview
  } = props2, { t: t2 } = useTranslation(), renderInput = React.useCallback(
    (inputProps) => {
      if (PathUtils.isEqual(inputProps.path, absolutePath) || PathUtils.startsWith(absolutePath, inputProps.path))
        return destinationRenderInput(inputProps);
      if (!isObjectInputProps$1(inputProps) && !isArrayInputProps(inputProps))
        throw new Error(
          `Expected either object input props or array input props for: ${JSON.stringify(
            inputProps.path
          )}`
        );
      return /* @__PURE__ */ jsxRuntime.jsx(
        FormInputInner2,
        {
          ...inputProps,
          absolutePath,
          destinationRenderAnnotation,
          destinationRenderBlock,
          destinationRenderInput,
          destinationRenderItem,
          destinationRenderField,
          destinationRenderInlineBlock,
          destinationRenderPreview
        }
      );
    },
    [
      absolutePath,
      destinationRenderAnnotation,
      destinationRenderBlock,
      destinationRenderField,
      destinationRenderInlineBlock,
      destinationRenderInput,
      destinationRenderItem,
      destinationRenderPreview
    ]
  ), renderField = React.useCallback(
    (fieldProps) => PathUtils.startsWith(absolutePath, fieldProps.path) && (props2.includeField || !PathUtils.isEqual(absolutePath, fieldProps.path)) ? destinationRenderField(fieldProps) : pass(fieldProps),
    [absolutePath, destinationRenderField, props2.includeField]
  ), renderItem2 = React.useCallback(
    (itemProps) => PathUtils.startsWith(absolutePath, itemProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, itemProps.path)) ? destinationRenderItem(itemProps) : pass(itemProps),
    [absolutePath, destinationRenderItem, props2.includeItem]
  ), renderBlock2 = React.useCallback(
    (blockProps) => PathUtils.startsWith(absolutePath, blockProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, blockProps.path)) ? destinationRenderBlock(blockProps) : pass(blockProps),
    [absolutePath, destinationRenderBlock, props2.includeItem]
  ), renderInlineBlock = React.useCallback(
    (blockProps) => PathUtils.startsWith(absolutePath, blockProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, blockProps.path)) ? destinationRenderInlineBlock(blockProps) : pass(blockProps),
    [absolutePath, destinationRenderInlineBlock, props2.includeItem]
  ), renderAnnotation = React.useCallback(
    (annotationProps) => PathUtils.startsWith(absolutePath, annotationProps.path) && (props2.includeItem || !PathUtils.isEqual(absolutePath, annotationProps.path)) ? destinationRenderAnnotation(annotationProps) : pass(annotationProps),
    [absolutePath, destinationRenderAnnotation, props2.includeItem]
  );
  if (isArrayInputProps(props2)) {
    const childPath = PathUtils.trimLeft(props2.path, absolutePath), itemMember = props2.members.find(
      (member) => member.kind == "item" && types.isKeySegment(childPath[0]) && member.key === childPath[0]._key
    );
    if (!itemMember) {
      const path = pathToString$1(props2.path), relativePath = PathUtils.trimLeft(props2.path, absolutePath);
      if (types.isKeySegment(relativePath[0])) {
        const key = relativePath[0]._key;
        return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.no-array-item-at-key", values: { key, path } }) });
      }
      const index = types.isIndexSegment(relativePath[0]) ? relativePath[0] : relativePath[0][0];
      return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "form.error.no-array-item-at-index", values: { index, path } }) });
    }
    return itemMember.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberItemError, { member: itemMember }) : /* @__PURE__ */ jsxRuntime.jsx(
      ArrayOfObjectsItem,
      {
        member: itemMember,
        renderAnnotation,
        renderBlock: renderBlock2,
        renderInput,
        renderField,
        renderInlineBlock,
        renderItem: renderItem2,
        renderPreview: destinationRenderPreview
      }
    );
  }
  if (isObjectInputProps$1(props2)) {
    const childPath = PathUtils.trimLeft(props2.path, absolutePath), fieldMember = props2.members.find(
      (member) => member.kind == "field" && childPath[0] === member.name
    );
    if (!fieldMember) {
      const fieldName = typeof childPath[0] == "string" ? childPath[0] : JSON.stringify(childPath[0]);
      return /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("form.error.field-not-found", { fieldName }) });
    }
    return /* @__PURE__ */ jsxRuntime.jsx(
      MemberField,
      {
        member: fieldMember,
        renderAnnotation,
        renderBlock: renderBlock2,
        renderInput,
        renderInlineBlock,
        renderField,
        renderItem: renderItem2,
        renderPreview: destinationRenderPreview
      }
    );
  }
  throw new Error("FormInput can only be used with arrays or objects");
});
function usePortableTextMemberItem(key) {
  const ctx = React.useContext(_singletons.PortableTextMemberItemsContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx.find((m) => m.key === key);
}
function usePortableTextMemberItems() {
  const ctx = React.useContext(_singletons.PortableTextMemberItemsContext);
  if (!ctx)
    throw new Error("Form context not provided");
  return ctx;
}
function usePortableTextMemberItemsFromProps(props2) {
  const portableTextMemberItemsRef = React.useRef([]);
  return reconcilePortableTextMembers({ props: props2, ref: portableTextMemberItemsRef }), portableTextMemberItemsRef.current;
}
const reconcilePortableTextMembers = ({
  props: props2,
  ref
}) => {
  var _a2;
  const result = [], {
    members,
    path,
    schemaType,
    renderAnnotation,
    renderField,
    renderBlock: renderBlock2,
    renderInput,
    renderItem: renderItem2,
    renderInlineBlock,
    renderPreview
  } = props2;
  for (const member of members)
    if (member.kind === "item")
      if (!isBlockType(member.item.schemaType))
        result.push({ kind: "objectBlock", member, node: member.item });
      else {
        (member.item.validation.length > 0 || member.item.changed || (_a2 = member.item.presence) != null && _a2.length || member.open || member.item.focusPath.length || member.item.focused) && result.push({ kind: "textBlock", member, node: member.item });
        const childrenField = member.item.members.find(
          (f) => f.kind === "field" && f.name === "children"
        );
        if (childrenField && childrenField.kind === "field" && isMemberArrayOfObjects(childrenField))
          for (const child of childrenField.field.members)
            child.kind === "item" && child.item.schemaType.name !== "span" && result.push({ kind: "inlineObject", member: child, node: child.item });
        const markDefArrayMember = member.item.members.filter(isArrayOfObjectsFieldMember).find((f) => f.name === "markDefs");
        if (markDefArrayMember)
          for (const child of markDefArrayMember.field.members)
            child.kind === "item" && child.item.schemaType.jsonType === "object" && result.push({
              kind: "annotation",
              member: child,
              node: child.item
            });
      }
  const items = result.map((item) => {
    const key = pathToString$1(item.node.path), existingItem = ref.current.find((refItem) => refItem.key === key), isObject2 = item.kind !== "textBlock";
    let input = null;
    if (isObject2 && item.member !== (existingItem == null ? void 0 : existingItem.member) || item.node !== (existingItem == null ? void 0 : existingItem.node)) {
      const _renderInput = (renderInputProps) => PathUtils.isEqual(renderInputProps.path, item.member.item.path) ? renderInput({
        ...renderInputProps,
        elementProps: {
          ...renderInputProps.elementProps,
          onFocus: () => {
          }
        }
      }) : renderInput(renderInputProps), inputProps = {
        absolutePath: PathUtils.pathFor(item.node.path),
        includeField: !1,
        members,
        path: PathUtils.pathFor(path),
        renderAnnotation,
        renderBlock: renderBlock2,
        renderField,
        renderInlineBlock,
        renderInput: _renderInput,
        renderItem: renderItem2,
        renderPreview,
        schemaType
      };
      input = /* @__PURE__ */ jsxRuntime.jsx(FormInput, { ...inputProps });
    }
    return existingItem ? (existingItem.member = item.member, existingItem.node = item.node, existingItem.input = input || existingItem.input, existingItem) : {
      kind: item.kind,
      key,
      member: item.member,
      node: item.node,
      elementRef: React.createRef(),
      input
    };
  });
  return ref.current = items, items;
}, Root$r = styledComponents.styled.span(
  (props2) => {
    var _a2, _b, _c, _d;
    const { $toneKey = "default", theme: theme2 } = props2;
    return styledComponents.css`
      text-decoration: none;
      display: inline;
      background-color: ${(_a2 = theme2.sanity.color.selectable) == null ? void 0 : _a2[$toneKey].enabled.bg};
      border-bottom: 1px dashed ${(_b = theme2.sanity.color.selectable) == null ? void 0 : _b[$toneKey].enabled.fg};
      color: ${(_c = theme2.sanity.color.selectable) == null ? void 0 : _c[$toneKey].enabled.fg};

      &[data-link] {
        border-bottom: 1px solid ${(_d = theme2.sanity.color.selectable) == null ? void 0 : _d[$toneKey].enabled.fg};
      }

      &[data-custom-markers] {
        background-color: ${theme2.sanity.color.dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
      }

      &[data-warning] {
        background-color: ${theme2.sanity.color.muted.caution.hovered.bg};
      }

      &[data-error] {
        background-color: ${theme2.sanity.color.muted.critical.hovered.bg};
      }
    `;
  }
), TooltipBox$3 = styledComponents.styled(ui.Box).attrs({ forwardedAs: "span" })`
  max-width: 250px;
`, POPOVER_FALLBACK_PLACEMENTS$6 = ["top", "bottom"];
function AnnotationToolbarPopover(props2) {
  const {
    annotationOpen,
    floatingBoundary,
    onOpen,
    onRemove,
    referenceBoundary,
    referenceElement,
    selected,
    title
  } = props2, [renderPopover, setRenderPopover] = React.useState(!1), [popoverOpen, setPopoverOpen] = React.useState(!1), [cursorRect, setCursorRect] = React.useState(null), rangeRef = React.useRef(null), { sanity: sanity2 } = ui.useTheme(), { t: t2 } = useTranslation(), popoverRef = React.useRef(null), popoverScheme = sanity2.color.dark ? "light" : "dark", handleOpenPopover = React.useCallback((open) => {
    setRenderPopover(open), open ? React.startTransition(() => {
      setPopoverOpen(open);
    }) : setPopoverOpen(open);
  }, []), cursorElement = React.useMemo(() => cursorRect ? {
    getBoundingClientRect: () => cursorRect
  } : null, [cursorRect]);
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        popoverOpen && event.key === "Escape" && handleOpenPopover(!1);
      },
      [handleOpenPopover, popoverOpen]
    )
  );
  const handleSelectionChange = React.useCallback(() => {
    if (annotationOpen) {
      handleOpenPopover(!1), setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return;
    const range2 = sel.getRangeAt(0);
    if (!(referenceElement != null && referenceElement.contains(range2.commonAncestorContainer))) {
      handleOpenPopover(!1), setCursorRect(null);
      return;
    }
    const rect = range2 == null ? void 0 : range2.getBoundingClientRect();
    rect && (setCursorRect(rect), handleOpenPopover(!0));
  }, [annotationOpen, referenceElement, handleOpenPopover]);
  React.useEffect(() => (document.addEventListener("selectionchange", handleSelectionChange, { passive: !0 }), () => {
    document.removeEventListener("selectionchange", handleSelectionChange);
  }), [handleSelectionChange]);
  const handleEditButtonClicked = React.useCallback(() => {
    handleOpenPopover(!1), onOpen();
  }, [onOpen, handleOpenPopover]);
  React.useEffect(() => {
    !annotationOpen && selected && cursorRect && handleOpenPopover(!0), annotationOpen && handleOpenPopover(!1);
  }, [annotationOpen, selected, cursorRect, handleOpenPopover]);
  const handleRemoveButtonClicked = React.useCallback(() => {
    handleOpenPopover(!1), onRemove();
  }, [onRemove, handleOpenPopover]), handleScroll = React.useCallback(() => {
    rangeRef.current && setCursorRect(rangeRef.current.getBoundingClientRect());
  }, []);
  return React.useEffect(() => {
    const sel = window.getSelection();
    sel && sel.rangeCount > 0 && (rangeRef.current = sel.getRangeAt(0));
  }, [popoverOpen]), React.useEffect(() => {
    if (popoverOpen && referenceBoundary)
      return referenceBoundary.addEventListener("scroll", handleScroll), () => referenceBoundary.removeEventListener("scroll", handleScroll);
    if (popoverOpen)
      return referenceBoundary == null || referenceBoundary.addEventListener("scroll", handleScroll), () => {
        referenceBoundary == null || referenceBoundary.removeEventListener("scroll", handleScroll);
      };
  }, [popoverOpen, referenceBoundary, handleScroll]), renderPopover ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      open: popoverOpen,
      floatingBoundary,
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, "data-testid": "annotation-toolbar-popover", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: title }) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            "aria-label": t2("inputs.portable-text.action.edit-annotation-aria-label"),
            "data-testid": "edit-annotation-button",
            icon: icons.EditIcon,
            mode: "bleed",
            onClick: handleEditButtonClicked,
            tabIndex: 0,
            tooltipProps: null
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            "aria-label": t2("inputs.portable-text.action.remove-annotation-aria-label"),
            "data-testid": "remove-annotation-button",
            icon: icons.TrashIcon,
            mode: "bleed",
            onClick: handleRemoveButtonClicked,
            tabIndex: 0,
            tone: "critical",
            tooltipProps: null
          }
        )
      ] }) }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$6,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      ref: popoverRef,
      referenceBoundary,
      referenceElement: cursorElement,
      scheme: popoverScheme
    }
  ) : null;
}
const parseResponsiveWidth = (value) => Array.isArray(value) ? value.flatMap(parseResponsiveWidth) : typeof value == "number" ? [value] : value === "auto" ? ["auto"] : [], parseModalType = (value) => value === "dialog" || value === "popover" ? value : void 0;
function _getModalOption(schemaType) {
  var _a2;
  const raw = (_a2 = schemaType.options) == null ? void 0 : _a2.modal;
  return typeof raw == "object" && raw !== null ? {
    type: parseModalType(raw.type),
    width: parseResponsiveWidth(raw.width)
  } : void 0;
}
function VirtualizerScrollInstanceProvider(props2) {
  const { scrollElement, containerElement } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    _singletons.VirtualizerScrollInstanceContext.Provider,
    {
      value: { scrollElement, containerElement },
      children: props2.children
    }
  );
}
function DefaultEditDialog(props2) {
  const { onClose, children, title, width = 1, autoFocus } = props2, dialogId = React.useId(), [contentElement, setContentElement] = React.useState(null), containerElement = React.useRef(null);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      header: title,
      id: dialogId,
      onClickOutside: onClose,
      onClose,
      portal: "default",
      width,
      contentRef: setContentElement,
      "data-testid": "default-edit-object-dialog",
      __unstable_autoFocus: autoFocus,
      children: /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { margins: [0, 0, 1, 0], children: /* @__PURE__ */ jsxRuntime.jsx(
        VirtualizerScrollInstanceProvider,
        {
          scrollElement: contentElement,
          containerElement,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ref: containerElement, children })
        }
      ) })
    }
  );
}
const RootPopover = styledComponents.styled(TooltipDelayGroupProvider.Popover)`
  & > div {
    overflow: hidden;
    overflow: clip;
  }
`, ContentScrollerBox = styledComponents.styled(ui.Box)`
  /* Prevent overflow caused by change indicator */
  overflow-x: hidden;
  overflow-y: auto;
`, ContentHeaderBox = styledComponents.styled(ui.Box)`
  box-shadow: 0 1px 0 var(--card-shadow-outline-color);
  position: relative;
  z-index: 10;
  min-height: auto;
`, POPOVER_FALLBACK_PLACEMENTS$5 = ["top", "bottom"];
function PopoverEditDialog(props2) {
  const { floatingBoundary, referenceBoundary, referenceElement, width = 1 } = props2, [open, setOpen] = React.useState(!1);
  return React.useEffect(() => {
    setOpen(!0);
  }, []), /* @__PURE__ */ jsxRuntime.jsx(
    RootPopover,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(Content, { ...props2 }),
      constrainSize: !0,
      "data-testid": "popover-edit-dialog",
      "data-ui": "PopoverEditDialog",
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$5,
      floatingBoundary,
      open,
      overflow: "auto",
      placement: "bottom",
      portal: "default",
      preventOverflow: !0,
      referenceBoundary,
      referenceElement,
      width
    }
  );
}
function Content(props2) {
  const { onClose, referenceBoundary, referenceElement, title, autoFocus } = props2;
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        event.key === "Escape" && onClose();
      },
      [onClose]
    )
  ), ui.useClickOutside(onClose, referenceElement ? [referenceElement] : [], referenceBoundary);
  const [contentElement, setContentElement] = React.useState(null), containerElement = React.useRef(null);
  return /* @__PURE__ */ jsxRuntime.jsx(
    VirtualizerScrollInstanceProvider,
    {
      scrollElement: contentElement,
      containerElement,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { ref: containerElement, direction: "column", height: "fill", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ContentHeaderBox, { flex: "none", padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: title }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Button,
            {
              autoFocus: !!autoFocus,
              icon: icons.CloseIcon,
              mode: "bleed",
              onClick: onClose,
              tooltipProps: { content: "Close" }
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ContentScrollerBox, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { margins: [0, 0, 1, 0], children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, ref: setContentElement, children: props2.children }) }) })
      ] })
    }
  );
}
function ObjectEditModal(props2) {
  const {
    autoFocus,
    defaultType,
    floatingBoundary,
    onClose,
    referenceBoundary,
    referenceElement,
    schemaType
  } = props2, { t: t2 } = useTranslation(), schemaModalOption = React.useMemo(() => _getModalOption(schemaType), [schemaType]), modalType = (schemaModalOption == null ? void 0 : schemaModalOption.type) || defaultType, schemaTypeTitle = schemaType.i18nTitleKey ? t2(schemaType.i18nTitleKey) : schemaType.title || schemaType.name, modalTitle = t2("inputs.portable-text.annotation-editor.title", {
    schemaType: schemaTypeTitle
  }), handleClose = React.useCallback(() => {
    onClose();
  }, [onClose]), modalWidth = schemaModalOption == null ? void 0 : schemaModalOption.width;
  return modalType === "popover" ? /* @__PURE__ */ jsxRuntime.jsx(
    PopoverEditDialog,
    {
      autoFocus,
      floatingBoundary,
      onClose: handleClose,
      referenceBoundary,
      referenceElement,
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: modalTitle }),
      width: modalWidth,
      children: props2.children
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    DefaultEditDialog,
    {
      onClose: handleClose,
      title: modalTitle,
      width: modalWidth,
      autoFocus,
      children: props2.children
    }
  );
}
function Annotation(props2) {
  var _a2;
  const {
    children,
    editorNodeFocused,
    floatingBoundary,
    focused,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderCustomMarkers,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    schemaType,
    selected,
    value
  } = props2, { Markers = DefaultMarkers } = useFormBuilder().__internal.components, editor2 = portableTextEditor.usePortableTextEditor(), markDefPath = React.useMemo(
    () => path.slice(0, path.length - 2).concat(["markDefs", { _key: value._key }]),
    [path, value._key]
  ), [spanElement, setSpanElement] = React.useState(null), memberItem = usePortableTextMemberItem(pathToString$1(markDefPath)), { validation: validation2 } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), markers = usePortableTextMarkers(path), text = React.useMemo(() => /* @__PURE__ */ jsxRuntime.jsx("span", { "data-annotation": "", children }), [children]), onOpen = React.useCallback(() => {
    memberItem && (portableTextEditor.PortableTextEditor.blur(editor2), onItemOpen(memberItem.node.path));
  }, [editor2, memberItem, onItemOpen]), onClose = React.useCallback(() => {
    onItemClose(), isEmptyItem(value) && portableTextEditor.PortableTextEditor.removeAnnotation(editor2, schemaType), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2, onItemClose, schemaType, value]), onRemove = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.removeAnnotation(editor2, schemaType), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2, schemaType]), markersToolTip = React.useMemo(
    () => validation2.length > 0 || markers.length > 0 ? /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Tooltip,
      {
        placement: "bottom",
        portal: "default",
        content: /* @__PURE__ */ jsxRuntime.jsx(TooltipBox$3, { children: /* @__PURE__ */ jsxRuntime.jsx(
          Markers,
          {
            markers,
            renderCustomMarkers,
            validation: validation2
          }
        ) }),
        children: text
      }
    ) : void 0,
    [Markers, markers, renderCustomMarkers, text, validation2]
  ), presence = useChildPresence(path, !0), rootPresence = React.useMemo(
    () => presence.filter((p) => PathUtils.isEqual(p.path, path)),
    [path, presence]
  ), isOpen = !!(memberItem != null && memberItem.member.open), input = memberItem == null ? void 0 : memberItem.input, nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$t, referenceElement = spanElement, componentProps = React.useMemo(
    () => ({
      __unstable_floatingBoundary: floatingBoundary,
      __unstable_referenceBoundary: referenceBoundary,
      __unstable_referenceElement: referenceElement,
      __unstable_textElementFocus: editorNodeFocused,
      // Is there focus on the related text element for this object?
      children: input,
      focused,
      markers,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      open: isOpen,
      parentSchemaType: editor2.schemaTypes.block,
      path: nodePath,
      presence: rootPresence,
      readOnly: !!readOnly,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderPreview,
      renderItem: renderItem2,
      renderDefault: DefaultAnnotationComponent,
      schemaType,
      selected,
      textElement: markersToolTip || text,
      validation: validation2,
      value
    }),
    [
      editor2.schemaTypes.block,
      editorNodeFocused,
      floatingBoundary,
      focused,
      input,
      isOpen,
      markers,
      markersToolTip,
      nodePath,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      readOnly,
      referenceBoundary,
      referenceElement,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview,
      rootPresence,
      schemaType,
      selected,
      text,
      validation2,
      value
    ]
  ), CustomComponent = (_a2 = schemaType.components) == null ? void 0 : _a2.annotation, setRef = React.useCallback(
    (elm) => {
      memberItem != null && memberItem.elementRef && (memberItem.elementRef.current = elm), setSpanElement(elm);
    },
    [memberItem]
  );
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx("span", { ref: setRef, style: void 0, children: CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultAnnotationComponent, { ...componentProps }) }),
    [CustomComponent, componentProps, setRef]
  );
}
const DefaultAnnotationComponent = (props2) => {
  const {
    __unstable_floatingBoundary: floatingBoundary,
    __unstable_referenceBoundary: referenceBoundary,
    __unstable_referenceElement: referenceElement,
    children,
    focused,
    markers,
    onClose,
    onOpen,
    onRemove,
    open,
    readOnly,
    selected,
    schemaType,
    textElement,
    validation: validation2
  } = props2, isLink = schemaType.name === "link", hasError = validation2.some((v) => v.level === "error"), hasWarning = validation2.some((v) => v.level === "warning"), hasMarkers = markers.length > 0, { t: t2 } = useTranslation(), toneKey = React.useMemo(() => hasError ? "critical" : hasWarning ? "caution" : isLink ? "primary" : "default", [isLink, hasError, hasWarning]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$r,
    {
      $toneKey: toneKey,
      "aria-label": t2("inputs.portable-text.annotation-aria-label"),
      "data-link": isLink ? "" : void 0,
      "data-error": hasError ? "" : void 0,
      "data-warning": hasWarning ? "" : void 0,
      "data-markers": hasMarkers || void 0,
      onClick: readOnly ? onOpen : void 0,
      children: [
        textElement,
        /* @__PURE__ */ jsxRuntime.jsx(
          AnnotationToolbarPopover,
          {
            annotationOpen: open,
            floatingBoundary,
            onOpen,
            onRemove,
            referenceBoundary,
            referenceElement,
            selected,
            title: schemaType.i18nTitleKey ? t2(schemaType.i18nTitleKey) : schemaType.title || schemaType.name
          }
        ),
        open && /* @__PURE__ */ jsxRuntime.jsx(
          ObjectEditModal,
          {
            defaultType: "popover",
            floatingBoundary,
            onClose,
            autoFocus: focused,
            referenceBoundary,
            referenceElement,
            schemaType,
            children
          }
        )
      ]
    }
  );
};
function useReferenceInputOptions() {
  return React.useContext(_singletons.ReferenceInputOptionsContext);
}
function ReferenceInputOptionsProvider(props2) {
  const {
    children,
    activePath,
    EditReferenceLinkComponent,
    onEditReference,
    initialValueTemplateItems
  } = props2, contextValue = React.useMemo(
    () => ({
      activePath,
      EditReferenceLinkComponent,
      onEditReference,
      initialValueTemplateItems
    }),
    [activePath, EditReferenceLinkComponent, onEditReference, initialValueTemplateItems]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ReferenceInputOptionsContext.Provider, { value: contextValue, children });
}
function useReviewChanges() {
  const reviewChanges = React.useContext(_singletons.ReviewChangesContext);
  if (!reviewChanges)
    throw new Error("Review changes: missing context value");
  return reviewChanges;
}
function DocumentIdProvider(props2) {
  const value = React.useMemo(() => ({ id: props2.id }), [props2.id]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.DocumentIdContext.Provider, { value, children: props2.children });
}
function useGivenDocumentId() {
  const ctx = React.useContext(_singletons.DocumentIdContext);
  if (!ctx)
    throw new Error("useDocumentId must be used within a DocumentIdProvider");
  return ctx.id;
}
function usePublishedId$1() {
  return getPublishedId(useGivenDocumentId());
}
function useScrollIntoViewOnFocusWithin(elementRef, hasFocusWithin) {
  return useDidUpdate(
    hasFocusWithin,
    React.useCallback(
      (hadFocus, hasFocus) => {
        elementRef.current && !hadFocus && hasFocus && scrollIntoView__default.default(elementRef.current, { scrollMode: "always" });
      },
      [elementRef]
    )
  );
}
const Root$q = styledComponents.styled(ui.Text)`
  &[data-status='edited'] {
    --card-icon-color: var(--card-badge-caution-dot-color);
  }
  &[data-status='unpublished'] {
    --card-icon-color: var(--card-badge-default-dot-color);
    opacity: 0.5 !important;
  }
`;
function DocumentStatusIndicator({ draft, published }) {
  const $draft = !!draft, $published = !!published, status = React.useMemo(() => $draft && !$published ? "unpublished" : "edited", [$draft, $published]);
  return !$draft && !$published || !$draft && $published ? null : /* @__PURE__ */ jsxRuntime.jsx(Root$q, { "data-status": status, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DotIcon, {}) });
}
function ReferencePreview(props2) {
  var _a2, _b;
  const { id: id2, layout, preview, refType, renderPreview, showTypeLabel } = props2, documentPresence = useDocumentPresence(id2), previewId = ((_a2 = preview.draft) == null ? void 0 : _a2._id) || ((_b = preview.published) == null ? void 0 : _b._id) || // note: during publish of the referenced document we might have both a missing draft and a missing published version
  // this happens because the preview system tries to optimistically re-fetch as soon as it sees a mutation, but
  // when publishing, the draft is deleted, and therefore both the draft and the published may be missing for a brief
  // moment before the published version appears. In this case, it's safe to fallback to the given id, which is always
  // the published id
  id2, previewStub = React.useMemo(
    () => ({ _id: previewId, _type: refType.name }),
    [previewId, refType.name]
  ), { draft, published } = preview, previewProps = React.useMemo(
    () => ({
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 3, children: [
        showTypeLabel && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { mode: "outline", children: refType.title }),
        documentPresence && documentPresence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(DocumentPreviewPresence, { presence: documentPresence }),
        /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusIndicator, { draft: preview.draft, published: preview.published })
      ] }) }),
      layout,
      schemaType: refType,
      tooltip: /* @__PURE__ */ jsxRuntime.jsx(DocumentStatus, { draft, published }),
      value: previewStub
    }),
    [
      documentPresence,
      draft,
      layout,
      preview.draft,
      preview.published,
      previewStub,
      published,
      refType,
      showTypeLabel
    ]
  );
  return renderPreview(previewProps);
}
function PreviewReferenceValue$1(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const { layout = "default", referenceInfo, renderPreview, type, value, showTypeLabel } = props2, { t: t2 } = useTranslation();
  if (referenceInfo.isLoading || referenceInfo.error)
    return /* @__PURE__ */ jsxRuntime.jsx(SanityDefaultPreview, { isPlaceholder: !0, layout });
  if (((_a2 = referenceInfo.result) == null ? void 0 : _a2.availability.reason) === "NOT_FOUND" && value._strengthenOnPublish) {
    const refType2 = type.to.find((toType) => {
      var _a22;
      return toType.name === ((_a22 = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _a22.type);
    });
    if (!refType2)
      return /* @__PURE__ */ jsxRuntime.jsx(
        InvalidType,
        {
          documentId: value._ref,
          actualType: (_b = value._strengthenOnPublish) == null ? void 0 : _b.type,
          declaredTypes: type.to.map((toType) => toType.name)
        }
      );
    const stub = (_c = value._strengthenOnPublish) != null && _c.type ? {
      _id: value._ref,
      _type: (_d = value._strengthenOnPublish) == null ? void 0 : _d.type
    } : value;
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: renderPreview({
        layout,
        schemaType: refType2,
        value: stub,
        skipVisibilityCheck: !0
      }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 4, children: showTypeLabel && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { mode: "outline", children: refType2.title }) }) })
    ] });
  }
  const availability = referenceInfo.result.availability, notFound = availability.reason === "NOT_FOUND", insufficientPermissions = availability.reason === "PERMISSION_DENIED";
  if (insufficientPermissions || notFound)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: t2("inputs.reference.error.document-unavailable-title") }) }) }) }),
      insufficientPermissions || notFound ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Tooltip,
        {
          portal: !0,
          content: notFound ? /* @__PURE__ */ jsxRuntime.jsx(
            UnavailableMessage,
            {
              title: t2("inputs.reference.error.nonexistent-document-title"),
              icon: icons.HelpCircleIcon,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  i18nKey: "inputs.reference.error.nonexistent-document-description",
                  t: t2,
                  values: { documentId: value._ref }
                }
              )
            }
          ) : /* @__PURE__ */ jsxRuntime.jsx(
            UnavailableMessage,
            {
              title: t2("inputs.reference.error.missing-read-permissions-title"),
              icon: icons.AccessDeniedIcon,
              children: t2("inputs.reference.error.missing-read-permissions-description")
            }
          ),
          children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(icons.HelpCircleIcon, {}) })
        }
      ) }) : null
    ] });
  const refTypeName = (_e = referenceInfo.result) == null ? void 0 : _e.type, refType = type.to.find((toType) => toType.name === refTypeName);
  return refType ? /* @__PURE__ */ jsxRuntime.jsx(
    ReferencePreview,
    {
      id: value._ref,
      layout,
      preview: (_f = referenceInfo.result) == null ? void 0 : _f.preview,
      refType,
      renderPreview,
      showTypeLabel
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    InvalidType,
    {
      documentId: value._ref,
      actualType: refTypeName || "<unknown>",
      declaredTypes: type.to.map((toType) => toType.name)
    }
  );
}
function UnavailableMessage(props2) {
  const Icon = props2.icon;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Icon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: props2.title }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: props2.children }) })
    ] })
  ] });
}
function InvalidType({
  declaredTypes,
  documentId,
  actualType
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: t2("inputs.reference.error.invalid-type-title") }) }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Tooltip,
      {
        portal: !0,
        content: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.reference.error.invalid-type-description",
            values: { documentId, actualType },
            components: {
              AllowedTypes: () => /* @__PURE__ */ jsxRuntime.jsx(HumanizedList, { values: declaredTypes })
            }
          }
        ) }) }),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(icons.HelpCircleIcon, {}) }) })
      }
    ) })
  ] });
}
function HumanizedList(props2) {
  const parts = useListFormat({ type: "disjunction" }).formatToParts(props2.values);
  return /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: parts.map(
    (segment) => segment.type === "element" ? /* @__PURE__ */ jsxRuntime.jsx("code", { children: segment.value }, segment.value) : segment.value
  ) });
}
const STATUS_TONES = {
  warning: "caution",
  error: "critical",
  info: "positive"
}, STATUS_ICONS = {
  warning: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}),
  error: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}),
  info: /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {})
};
function AlertStrip(props2) {
  const { children, status = "warning", title, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, tone: STATUS_TONES[status], ...rest, "data-ui": "Alert", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { padding: 1, children: children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Details, { icon: STATUS_ICONS[status], title, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 3, marginTop: 3, children }) }) }) }) });
}
function ReferenceFinalizeAlertStrip({
  schemaType,
  handleRemoveStrengthenOnPublish
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    AlertStrip,
    {
      padding: 1,
      title: t2(
        schemaType.weak ? "inputs.reference.incomplete-reference.finalize-action-title" : "inputs.reference.incomplete-reference.strengthen-action-title"
      ),
      status: "info",
      "data-testid": "alert-reference-published",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: schemaType.weak ? "inputs.reference.incomplete-reference.finalize-action-description" : "inputs.reference.incomplete-reference.strengthen-action-description"
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "ghost",
            onClick: handleRemoveStrengthenOnPublish,
            size: "large",
            text: t2("inputs.reference.incomplete-reference.strengthen-button-label"),
            tone: "positive"
          }
        )
      ] })
    }
  );
}
const StyledCard$2 = styledComponents.styled(ui.Card)`
  /* this is a hack to avoid layout jumps while previews are loading
     there's probably better ways of solving this */
  min-height: 33px;
  position: relative;

  /* TextWithTone uses its own logic to set color, and we therefore need */
  /* to override this logic in order to set the correct color in different states */
  &[data-selected],
  &[data-pressed],
  &:active {
    [data-ui='TextWithTone'] {
      color: inherit;
    }
  }
`, ReferenceLinkCard = React.forwardRef(function(props2, ref) {
  const { as, documentId, documentType, ...cardProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledCard$2,
    {
      ...cardProps,
      ...documentId && documentType && {
        // this will make @sanity/ui style it as a link
        "data-as": "a",
        // this determines the actual tag inserted into the DOM (either a HTML element or a component)
        forwardedAs: as,
        documentId,
        documentType
      },
      "data-ui": "ReferenceLinkCard",
      ref
    }
  );
});
function ReferenceMetadataLoadErrorAlertStrip({
  errorMessage,
  onHandleRetry
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    AlertStrip,
    {
      padding: 1,
      title: t2("inputs.reference.metadata-error.title"),
      status: "warning",
      "data-testid": "alert-reference-info-failed",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: errorMessage }),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "ghost",
            onClick: onHandleRetry,
            size: "large",
            text: t2("inputs.reference.metadata-error.retry-button-label"),
            tone: "primary"
          }
        )
      ] })
    }
  );
}
function ReferenceStrengthMismatchAlertStrip({
  actualStrength,
  handleFixStrengthMismatch
}) {
  const shouldBe = actualStrength === "weak" ? "strong" : "weak", { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    AlertStrip,
    {
      padding: 1,
      title: t2("inputs.reference.strength-mismatch.title"),
      status: "warning",
      "data-testid": "alert-reference-strength-mismatch",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: actualStrength === "weak" ? "inputs.reference.strength-mismatch.is-weak-description" : "inputs.reference.strength-mismatch.is-strong-description"
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2(
          shouldBe === "weak" ? "inputs.reference.strength-mismatch.is-strong-consquences" : "inputs.reference.strength-mismatch.is-weak-consquences"
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "ghost",
            onClick: handleFixStrengthMismatch,
            size: "large",
            text: t2(
              shouldBe === "weak" ? "inputs.reference.strength-mismatch.weaken-button-label" : "inputs.reference.strength-mismatch.strengthen-button-label"
            ),
            tone: "caution"
          }
        )
      ] })
    }
  );
}
const noop$2 = () => {
}, INITIAL_LOADING_STATE$3 = {
  isLoading: !0,
  result: void 0,
  error: void 0,
  retry: noop$2
}, EMPTY_STATE$1 = {
  isLoading: !1,
  result: void 0,
  error: void 0,
  retry: noop$2
};
function useReferenceInfo$1(id2, getReferenceInfo2) {
  const msgSubject = React.useMemo(() => new rxjs.Subject(), []), msg$ = React.useMemo(() => msgSubject.asObservable(), [msgSubject]), retry = React.useCallback(() => {
    msgSubject.next({ type: "retry" });
  }, [msgSubject]), referenceInfo = reactRx.useMemoObservable(
    () => rxjs.concat(rxjs.of(null), msg$).pipe(
      operators.map(() => id2),
      operators.concatMap(
        (refId) => refId ? getReferenceInfo2(refId).pipe(
          operators.map((result) => ({
            isLoading: !1,
            result,
            error: void 0,
            retry
          })),
          operators.startWith(INITIAL_LOADING_STATE$3),
          operators.catchError((err) => (console.error(err), rxjs.of({ isLoading: !1, result: void 0, error: err, retry })))
        ) : rxjs.of(EMPTY_STATE$1)
      )
    ),
    [getReferenceInfo2, id2, msg$, retry],
    INITIAL_LOADING_STATE$3
  ), previousId = usePrevious(id2, id2);
  return id2 && previousId !== id2 ? INITIAL_LOADING_STATE$3 : referenceInfo;
}
function FormValueProvider(props2) {
  const value = React.useMemo(() => ({ value: props2.value }), [props2.value]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.FormValueContext.Provider, { value, children: props2.children });
}
function useFormValue(path) {
  const uniquePath = PathUtils.pathFor(path), ctx = React.useContext(_singletons.FormValueContext);
  if (!ctx)
    throw new Error("useFormValue must be used within a FormValueProvider");
  return getValueAtPath(ctx == null ? void 0 : ctx.value, uniquePath);
}
const CACHE = /* @__PURE__ */ new WeakMap(), PREVIEW_FIELD_WEIGHT_MAP = {
  title: 10,
  subtitle: 5,
  description: 1.5
}, BASE_WEIGHTS = {
  _id: { weight: 1, type: "string" },
  _type: { weight: 1, type: "string" }
}, builtInObjectTypes = ["reference", "crossDatasetReference"], getTypeChain$2 = (type) => type ? [type, ...getTypeChain$2(type.type)] : [], isPtField = (type) => (type == null ? void 0 : type.jsonType) === "array" && type.of.some((arrType) => getTypeChain$2(arrType).some(({ name }) => name === "block")), isStringField = (schemaType) => getTypeChain$2(schemaType).some((type) => type.name === "string"), isSearchConfiguration = (options) => isRecord$4(options) && "search" in options && isRecord$4(options.search);
function isSchemaType(input) {
  return typeof input < "u" && "name" in input;
}
function getLeafWeights(schemaType, maxDepth, getWeight) {
  function traverse2(type, path, depth) {
    if (!type) return [];
    if (depth > maxDepth) return [];
    const typeChain = getTypeChain$2(type);
    if (isStringField(type) || isPtField(type)) {
      const weight = getWeight(type, path);
      return typeof weight != "number" ? [] : [{ path, weight, type: isPtField(type) ? "pt" : "string" }];
    }
    const results = [], objectTypes = typeChain.filter(
      (t2) => {
        var _a2;
        return t2.jsonType === "object" && !!((_a2 = t2.fields) != null && _a2.length) && !builtInObjectTypes.includes(t2.name);
      }
    );
    for (const objectType of objectTypes)
      for (const field of objectType.fields) {
        const nextPath = PathUtils.toString([path, field.name].filter(Boolean));
        results.push(...traverse2(field.type, nextPath, depth + 1));
      }
    const arrayTypes = typeChain.filter(
      (t2) => {
        var _a2;
        return t2.jsonType === "array" && !!((_a2 = t2.of) != null && _a2.length);
      }
    );
    for (const arrayType of arrayTypes)
      for (const arrayItemType of arrayType.of) {
        const nextPath = `${path}[]`;
        results.push(...traverse2(arrayItemType, nextPath, depth + 1));
      }
    return results;
  }
  return isSchemaType(schemaType) ? traverse2(schemaType, "", 0).reduce(
    (acc, { path, weight, type }) => (acc[path] = { weight, type, path }, acc),
    {}
  ) : {};
}
const getUserSetWeight = (schemaType) => {
  var _a2;
  const searchOptions = getTypeChain$2(schemaType).map((type) => type.options).find(isSearchConfiguration);
  return typeof ((_a2 = searchOptions == null ? void 0 : searchOptions.search) == null ? void 0 : _a2.weight) == "number" ? searchOptions.search.weight : null;
}, getHiddenWeight = (schemaType) => getTypeChain$2(schemaType).some((type) => type.hidden) ? 0 : null, getDefaultWeights = (schemaType) => {
  var _a2;
  return typeof ((_a2 = getUserSetWeight(schemaType)) != null ? _a2 : getHiddenWeight(schemaType)) == "number" ? null : 1;
}, getPreviewWeights = (schemaType, maxDepth, isCrossDataset) => {
  var _a2;
  const select2 = (_a2 = schemaType == null ? void 0 : schemaType.preview) == null ? void 0 : _a2.select;
  if (!select2) return null;
  const selectionKeysBySelectionPath = Object.fromEntries(
    Object.entries(select2).map(([selectionKey, selectionPath]) => [
      // replace indexed paths with `[]`
      // e.g. `arrayOfObjects.0.myField` becomes `arrayOfObjects[].myField`
      selectionPath.replace(/\.\d+/g, "[]"),
      selectionKey
    ])
  ), defaultWeights = getLeafWeights(schemaType, maxDepth, getDefaultWeights), nestedWeightsBySelectionPath = Object.fromEntries(
    Object.entries(defaultWeights).map(([path, { type }]) => ({ path, type })).filter(({ path }) => selectionKeysBySelectionPath[path]).map(({ path, type }) => [
      path,
      {
        type,
        weight: PREVIEW_FIELD_WEIGHT_MAP[selectionKeysBySelectionPath[path]]
      }
    ])
  );
  return isCrossDataset ? Object.fromEntries(
    Object.values(selectionKeysBySelectionPath).map((path) => [
      path,
      {
        path,
        type: "string",
        weight: PREVIEW_FIELD_WEIGHT_MAP[path]
      }
    ])
  ) : getLeafWeights(schemaType, maxDepth, (_, path) => {
    const nested = nestedWeightsBySelectionPath[path];
    return nested ? nested.weight : null;
  });
};
function deriveSearchWeightsFromType({
  schemaType,
  maxDepth,
  isCrossDataset,
  processPaths = (paths) => paths
}) {
  const cached = CACHE.get(schemaType);
  if (cached) return cached;
  const userSetWeights = getLeafWeights(schemaType, maxDepth, getUserSetWeight), hiddenWeights = getLeafWeights(schemaType, maxDepth, getHiddenWeight), defaultWeights = getLeafWeights(schemaType, maxDepth, getDefaultWeights), previewWeights = getPreviewWeights(schemaType, maxDepth, isCrossDataset), weights = {
    ...BASE_WEIGHTS,
    ...defaultWeights,
    ...hiddenWeights,
    ...previewWeights,
    ...userSetWeights
  }, result = {
    typeName: isSchemaType(schemaType) ? schemaType.name : schemaType.type,
    paths: processPaths(
      Object.entries(weights).map(([path, { type, weight }]) => ({
        path,
        weight,
        ...type === "pt" && { mapWith: "pt::text" }
      }))
    )
  };
  return CACHE.set(schemaType, result), result;
}
const isDocumentType = (type) => !!(type.type && type.type.name === "document"), isIgnoredType = (type) => type.name.startsWith("sanity.") && type.name !== "sanity.previewUrlSecret", getSearchableTypes = (schema2) => schema2.getTypeNames().map((typeName) => schema2.get(typeName)).filter(isNonNullable$3).filter(isDocumentType).filter((type) => !isIgnoredType(type)), DEFAULT_LIMIT$1 = 1e3, WILDCARD_TOKEN = "*", NEGATION_TOKEN = "-", TOKEN_REGEX = /(?:[^\s"]+|"[^"]*")+/g;
function normalizeSearchTerms(searchParams, fallbackTypes) {
  return typeof searchParams == "string" ? {
    query: searchParams,
    types: fallbackTypes
  } : {
    ...searchParams,
    types: searchParams.types.length ? searchParams.types : fallbackTypes
  };
}
function optimizeSearchWeights(paths) {
  return paths.filter((path) => path.weight !== 1);
}
function getDocumentTypeConfiguration(searchOptions, searchTerms) {
  return searchTerms.types.map(
    (schemaType) => deriveSearchWeightsFromType({
      schemaType,
      maxDepth: searchOptions.maxDepth || _internal.DEFAULT_MAX_FIELD_DEPTH,
      processPaths: optimizeSearchWeights
    })
  ).filter(({ paths }) => paths.length).reduce((nextTypes, spec) => ({
    ...nextTypes,
    [spec.typeName]: spec.paths.reduce(
      (nextType, { path, weight }) => ({
        ...nextType,
        weights: {
          ...nextType.weights,
          [path]: weight
        }
      }),
      {}
    )
  }), {});
}
function getOrder(sort = []) {
  return sort.map(
    ({ field, direction }) => ({
      attribute: field,
      direction
    }),
    {}
  );
}
function isNegationToken(token) {
  return typeof token < "u" && token.trim().at(0) === NEGATION_TOKEN;
}
function isPrefixToken(token) {
  return typeof token < "u" && token.trim().at(-1) === WILDCARD_TOKEN;
}
function prefixLast(query) {
  var _a2;
  const tokens = ((_a2 = query.match(TOKEN_REGEX)) != null ? _a2 : []).map((token) => token.trim()), finalNonNegationTokenIndex = tokens.findLastIndex((token) => !isNegationToken(token)), finalNonNegationToken = tokens[finalNonNegationTokenIndex];
  if (tokens.length === 0)
    return WILDCARD_TOKEN;
  if (isPrefixToken(finalNonNegationToken) || typeof finalNonNegationToken > "u")
    return tokens.join(" ");
  const prefixedTokens = [...tokens];
  return prefixedTokens.splice(finalNonNegationTokenIndex, 1, `${finalNonNegationToken}${WILDCARD_TOKEN}`), prefixedTokens.join(" ");
}
function getQueryString(query, { queryType = "prefixLast" }) {
  return queryType === "prefixLast" ? prefixLast(query) : query;
}
const createTextSearch = (typesFromFactory, client2, factoryOptions) => function(searchParams, searchOptions = {}) {
  var _a2;
  const searchTerms = normalizeSearchTerms(searchParams, typesFromFactory), filters = [
    "_type in $__types",
    searchOptions.includeDrafts === !1 && "!(_id in path('drafts.**'))",
    factoryOptions.filter ? `(${factoryOptions.filter})` : !1,
    searchTerms.filter ? `(${searchTerms.filter})` : !1
  ].filter((baseFilter) => !!baseFilter), textSearchParams = {
    query: {
      string: getQueryString(searchTerms.query, searchOptions)
    },
    filter: filters.join(" && "),
    params: {
      __types: searchTerms.types.map((type) => "name" in type ? type.name : type.type),
      ...factoryOptions.params,
      ...searchTerms.params
    },
    types: getDocumentTypeConfiguration(searchOptions, searchTerms),
    ...searchOptions.sort ? { order: getOrder(searchOptions.sort) } : {},
    includeAttributes: ["_id", "_type"],
    fromCursor: searchOptions.cursor,
    limit: (_a2 = searchOptions.limit) != null ? _a2 : DEFAULT_LIMIT$1
  };
  return client2.observable.request({
    uri: `/data/textsearch/${client2.config().dataset}`,
    method: "POST",
    json: !0,
    body: textSearchParams,
    tag: factoryOptions.tag
  }).pipe(
    operators.map((response) => {
      let documents = response.hits.map((hit) => hit.attributes);
      return factoryOptions.unique && (documents = removeDupes(documents)), {
        type: "text",
        hits: documents.map((hit) => ({ hit })),
        nextCursor: response.nextCursor
      };
    })
  );
}, calculateScore = (searchTerms, value) => {
  const { phrases: uniqueSearchPhrases, words: uniqueSearchWords } = partitionAndSanitizeSearchTerms(searchTerms), [phraseScore, phraseWhy] = calculatePhraseScore(uniqueSearchPhrases, value), [wordScore, wordWhy] = calculateWordScore(uniqueSearchWords, value);
  return [phraseScore + wordScore, [wordWhy, phraseWhy].join(", ")];
}, stringify = (value) => typeof value == "string" ? value : JSON.stringify(value);
function applyWeights(searchSpec, hits, terms = []) {
  const specByType = keyBy__default.default(searchSpec, (spec) => spec.typeName);
  return hits.map((hit, index) => {
    var _a2;
    const stories = (_a2 = specByType[hit._type].paths || []) == null ? void 0 : _a2.map((pathSpec, idx) => {
      const value = stringify(hit[`w${idx}`]);
      if (!value)
        return { path: pathSpec.path, score: 0, why: "No match" };
      const [score, why] = calculateScore(terms, value);
      return {
        path: pathSpec.path,
        score: score * pathSpec.weight,
        why: `${why} (*${pathSpec.weight})`
      };
    }), totalScore = stories.reduce((acc, rank) => acc + rank.score, 0);
    return { hit, resultIndex: hits.length - index, score: totalScore, stories };
  });
}
function calculatePhraseScore(uniqueSearchPhrases, value) {
  const sanitizedValue = value.toLowerCase().trim();
  let fieldScore = 0, matchCount = 0;
  return uniqueSearchPhrases.forEach((term) => {
    sanitizedValue.includes(term) && (fieldScore += term.length / sanitizedValue.length, matchCount += term.length);
  }), fieldScore === 1 ? [1, "[Phrase] Exact match"] : [fieldScore / 2, `[Phrase] Matched ${matchCount} of ${sanitizedValue.length} characters`];
}
function calculateWordScore(uniqueSearchTerms, value) {
  const uniqueValueTerms = uniq__default.default(compact__default.default(words__default.default(toLower__default.default(value)))), matches = intersection__default.default(uniqueSearchTerms, uniqueValueTerms), all = union__default.default(uniqueValueTerms, uniqueSearchTerms), fieldScore = matches.length / all.length;
  return fieldScore === 1 ? [1, "[Word] Exact match"] : [
    fieldScore / 2,
    `[Word] Matched ${matches.length} of ${all.length} terms: [${matches.join(", ")}]`
  ];
}
function partitionAndSanitizeSearchTerms(searchTerms) {
  const uniqueSearchTerms = uniq__default.default(searchTerms.map(toLower__default.default)), [searchPhrases, searchWords] = partition__default.default(uniqueSearchTerms, (term) => /^".*"$/.test(term));
  return {
    phrases: uniq__default.default(searchPhrases).map(toLower__default.default).map(stripWrappingQuotes),
    //
    words: uniq__default.default(searchWords.map(toLower__default.default))
  };
}
function stripWrappingQuotes(str) {
  return str.replace(/^"(.*)"$/, "$1");
}
const FINDABILITY_MVI = 4, DEFAULT_LIMIT = 1e3, combinePaths = flow__default.default([flatten__default.default, union__default.default, compact__default.default]), pathWithMapper = ({ mapWith, path }) => mapWith ? `${mapWith}(${path})` : path;
function createConstraints(terms, specs) {
  const combinedSearchPaths = combinePaths(
    specs.map((configForType) => (configForType.paths || []).map((opt) => pathWithMapper(opt)))
  );
  return terms.map((_term, i) => combinedSearchPaths.map((joinedPath) => `${joinedPath} match $t${i}`)).filter((constraint) => constraint.length > 0).map((constraint) => `(${constraint.join(" || ")})`);
}
const SPECIAL_CHARS = /([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g, STRIP_EDGE_CHARS = /(^[.]+)|([.]+$)/;
function tokenize(string) {
  return (string.match(SPECIAL_CHARS) || []).map((token) => token.replace(STRIP_EDGE_CHARS, ""));
}
function extractTermsFromQuery(query) {
  const quotedQueries = [], unquotedQuery = query.replace(/("[^"]*")/g, (match) => words__default.default(match).length > 1 ? (quotedQueries.push(match), "") : match), quotedTerms = quotedQueries.map((str) => trim__default.default(toLower__default.default(str))), remainingTerms = uniq__default.default(compact__default.default(tokenize(toLower__default.default(unquotedQuery))));
  return [...quotedTerms, ...remainingTerms];
}
function toOrderClause(orderBy2) {
  function wrapFieldWithFn(ordering) {
    return ordering.mapWith ? `${ordering.mapWith}(${ordering.field})` : ordering.field;
  }
  return (orderBy2 || []).map(
    (ordering) => [wrapFieldWithFn(ordering), (ordering.direction || "").toLowerCase()].map((str) => str.trim()).filter(Boolean).join(" ")
  ).join(",");
}
function createSearchQuery(searchTerms, searchOpts = {}) {
  var _a2;
  const { filter, params, tag } = searchOpts, specs = searchTerms.types.map(
    (schemaType) => deriveSearchWeightsFromType({
      schemaType,
      maxDepth: searchOpts.maxDepth || _internal.DEFAULT_MAX_FIELD_DEPTH,
      isCrossDataset: searchOpts.isCrossDataset
    })
  ).filter(({ paths }) => paths.length), terms = extractTermsFromQuery(searchTerms.query), filters = [
    "_type in $__types",
    searchOpts.includeDrafts === !1 && "!(_id in path('drafts.**'))",
    ...createConstraints(terms, specs),
    filter ? `(${filter})` : "",
    searchTerms.filter ? `(${searchTerms.filter})` : ""
  ].filter(Boolean), selections = specs.map((spec) => {
    const constraint = `_type == "${spec.typeName}" => `, selection2 = `{ ${spec.paths.map((cfg, i) => `"w${i}": ${pathWithMapper(cfg)}`)} }`;
    return `${constraint}${selection2}`;
  }), sortOrder = toOrderClause((searchOpts == null ? void 0 : searchOpts.sort) || [{ field: "_id", direction: "asc" }]), projectionFields = ["_type", "_id"], selection = selections.length > 0 ? `...select(${selections.join(`,
`)})` : "", finalProjection = projectionFields.join(", ") + (selection ? `, ${selection}` : "");
  let query = `*[${filters.join(" && ")}]| order(${sortOrder})[0...$__limit]{${finalProjection}}`;
  if (searchOpts != null && searchOpts.__unstable_extendedProjection) {
    const extendedProjection = searchOpts == null ? void 0 : searchOpts.__unstable_extendedProjection, firstProjection = projectionFields.concat(extendedProjection).join(", ");
    query = [
      `*[${filters.join(" && ")}]{${firstProjection}}`,
      `order(${sortOrder})[0...$__limit]{${finalProjection}}`
    ].join("|");
  }
  const groqComments = [`findability-mvi:${FINDABILITY_MVI}`].concat((searchOpts == null ? void 0 : searchOpts.comments) || []).map((s) => `// ${s}`).join(`
`), updatedQuery = groqComments ? `${groqComments}
${query}` : query, limit = (_a2 = searchOpts == null ? void 0 : searchOpts.limit) != null ? _a2 : DEFAULT_LIMIT;
  return {
    query: updatedQuery,
    params: {
      ...toGroqParams(terms),
      __types: specs.map((spec) => spec.typeName),
      __limit: limit,
      ...params || {}
    },
    options: { tag },
    searchSpec: specs,
    terms
  };
}
const toGroqParams = (terms) => {
  const params = {};
  return terms.reduce((acc, term, i) => (acc[`t${i}`] = `${term}*`, acc), params);
};
function getSearchTerms(searchParams, types2) {
  return typeof searchParams == "string" ? {
    query: searchParams,
    types: types2
  } : searchParams.types.length ? searchParams : { ...searchParams, types: types2 };
}
const createWeightedSearch = (types2, client2, factoryOptions) => function(searchParams, searchOptions = {}) {
  const searchTerms = getSearchTerms(searchParams, types2), { query, params, options, searchSpec, terms } = createSearchQuery(searchTerms, {
    ...factoryOptions,
    ...searchOptions
  });
  return client2.observable.fetch(query, params, options).pipe(
    factoryOptions.unique ? operators.map(removeDupes) : operators.tap(),
    // Assign weighting and scores based on current search terms.
    // No scores will be assigned when terms are empty.
    operators.map((hits) => applyWeights(searchSpec, hits, terms)),
    // Optionally skip client-side score sorting.
    // This can be relevant when ordering results by specific fields, especially dates.
    searchOptions != null && searchOptions.skipSortByScore ? operators.tap() : operators.map((hits) => sortBy__default.default(hits, (hit) => -hit.score)),
    operators.map((hits) => ({ type: "weighted", hits }))
  );
}, createSearch = (searchableTypes, client2, options) => (options.enableLegacySearch ? createWeightedSearch : createTextSearch)(searchableTypes, client2, options), READABLE = {
  available: !0,
  reason: "READABLE"
}, PERMISSION_DENIED = {
  available: !1,
  reason: "PERMISSION_DENIED"
}, NOT_FOUND = {
  available: !1,
  reason: "NOT_FOUND"
};
function getReferenceInfo(documentPreviewStore, id2, referenceType) {
  const { publishedId, draftId } = getIdPair(id2);
  return documentPreviewStore.unstable_observeDocumentPairAvailability(id2).pipe(
    operators.switchMap((pairAvailability) => {
      if (!pairAvailability.draft.available && !pairAvailability.published.available) {
        const availability = pairAvailability.draft.reason === "PERMISSION_DENIED" || pairAvailability.published.reason === "PERMISSION_DENIED" ? PERMISSION_DENIED : NOT_FOUND;
        return rxjs.of({
          id: id2,
          type: void 0,
          availability,
          preview: {
            draft: void 0,
            published: void 0
          }
        });
      }
      const draftRef = { _type: "reference", _ref: draftId }, publishedRef = { _type: "reference", _ref: publishedId };
      return rxjs.combineLatest([
        documentPreviewStore.observeDocumentTypeFromId(draftId),
        documentPreviewStore.observeDocumentTypeFromId(publishedId)
      ]).pipe(
        // assume draft + published are always same type
        operators.map(([draftTypeName, publishedTypeName]) => draftTypeName || publishedTypeName)
      ).pipe(
        operators.switchMap((typeName) => {
          if (!typeName)
            return rxjs.of({
              id: id2,
              type: void 0,
              availability: { available: !0, reason: "READABLE" },
              preview: {
                draft: void 0,
                published: void 0
              }
            });
          const refSchemaType = referenceType.to.find((memberType) => memberType.name === typeName);
          if (!refSchemaType)
            return rxjs.of({
              id: id2,
              type: typeName,
              availability: { available: !0, reason: "READABLE" },
              preview: {
                draft: void 0,
                published: void 0
              }
            });
          const previewPaths = getPreviewPaths(refSchemaType == null ? void 0 : refSchemaType.preview) || [], draftPreview$ = documentPreviewStore.observePaths(draftRef, previewPaths).pipe(
            operators.map(
              (result) => result ? {
                _id: draftId,
                ...prepareForPreview(result, refSchemaType)
              } : void 0
            ),
            operators.startWith(void 0)
          ), publishedPreview$ = documentPreviewStore.observePaths(publishedRef, previewPaths).pipe(
            operators.map(
              (result) => result ? {
                _id: publishedId,
                ...prepareForPreview(result, refSchemaType)
              } : void 0
            ),
            operators.startWith(void 0)
          );
          return rxjs.combineLatest([draftPreview$, publishedPreview$]).pipe(
            operators.map(([draft, published]) => ({ draft, published }))
          ).pipe(
            operators.map((value) => {
              const availability = (
                // eslint-disable-next-line no-nested-ternary
                pairAvailability.draft.available || pairAvailability.published.available ? READABLE : pairAvailability.draft.reason === "PERMISSION_DENIED" || pairAvailability.published.reason === "PERMISSION_DENIED" ? PERMISSION_DENIED : NOT_FOUND
              );
              return {
                type: typeName,
                id: publishedId,
                availability,
                preview: {
                  draft: isRecord$4(value.draft) ? value.draft : void 0,
                  published: isRecord$4(value.published) ? value.published : void 0
                }
              };
            })
          );
        })
      );
    })
  );
}
function getCounterpartIds(collatedHits) {
  return collatedHits.filter(
    (collatedHit) => (
      // we're interested in hits where either draft or published is missing
      !collatedHit.draft || !collatedHit.published
    )
  ).map(
    (collatedHit) => (
      // if we have the draft, return the published id or vice versa
      collatedHit.draft ? collatedHit.id : getDraftId(collatedHit.id)
    )
  );
}
function getExistingCounterparts(client2, ids) {
  return ids.length === 0 ? rxjs.of([]) : client2.observable.fetch("*[_id in $ids]._id", { ids }, { tag: "get-counterpart-ids" });
}
function referenceSearch(client2, textTerm, type, options, enableLegacySearch) {
  return createSearch(type.to, client2, {
    ...options,
    enableLegacySearch,
    maxDepth: options.maxFieldDepth || _internal.DEFAULT_MAX_FIELD_DEPTH
  })(textTerm, { includeDrafts: !0 }).pipe(
    operators.map(({ hits }) => hits.map(({ hit }) => hit)),
    operators.map(collate),
    // pick the 100 best matches
    operators.map((collated) => collated.slice(0, 100)),
    operators.mergeMap((collated) => getExistingCounterparts(client2, getCounterpartIds(collated)).pipe(
      operators.map((existingCounterpartIds) => collated.map((entry) => {
        const draftId = getDraftId(entry.id);
        return {
          id: entry.id,
          type: entry.type,
          draft: entry.draft || existingCounterpartIds.includes(draftId) ? { _id: draftId, _type: entry.type } : void 0,
          published: entry.published || existingCounterpartIds.includes(entry.id) ? { _id: entry.id, _type: entry.type } : void 0
        };
      }))
    ))
  );
}
function useValueRef$2(value) {
  const ref = React.useRef(value);
  return ref.current = value, ref;
}
function useReferenceInput(options) {
  var _a2, _b, _c, _d;
  const { path, schemaType } = options, schema2 = useSchema(), documentPreviewStore = useDocumentPreviewStore(), { EditReferenceLinkComponent, onEditReference, activePath, initialValueTemplateItems } = useReferenceInputOptions(), documentValue = useFormValue([]), documentTypeName = (_a2 = useValueRef$2(documentValue).current) == null ? void 0 : _a2._type, isCurrentDocumentLiveEdit = React.useMemo(() => {
    var _a22;
    return (_a22 = schema2.get(documentTypeName)) == null ? void 0 : _a22.liveEdit;
  }, [documentTypeName, schema2]), disableNew = ((_b = schemaType.options) == null ? void 0 : _b.disableNew) === !0, template2 = (_d = (_c = options.value) == null ? void 0 : _c._strengthenOnPublish) == null ? void 0 : _d.template, EditReferenceLink = React.useMemo(
    () => React.forwardRef(function(_props, forwardedRef) {
      return EditReferenceLinkComponent ? /* @__PURE__ */ jsxRuntime.jsx(
        EditReferenceLinkComponent,
        {
          ..._props,
          ref: forwardedRef,
          parentRefPath: path,
          template: template2
        }
      ) : null;
    }),
    [EditReferenceLinkComponent, path, template2]
  ), handleEditReference = React.useCallback(
    (event) => {
      onEditReference == null || onEditReference({
        parentRefPath: path,
        id: event.id,
        type: event.type,
        template: event.template
      });
    },
    [onEditReference, path]
  ), selectedState = PathUtils__namespace.startsWith(path, (activePath == null ? void 0 : activePath.path) || []) ? activePath == null ? void 0 : activePath.state : "none", createOptions = React.useMemo(() => disableNew ? [] : (initialValueTemplateItems || []).filter((i) => schemaType.to.some((refType) => {
    var _a22;
    return refType.name === ((_a22 = i.template) == null ? void 0 : _a22.schemaType);
  })).map(
    (item) => {
      var _a22;
      return (_a22 = item.template) != null && _a22.schemaType ? {
        id: item.id,
        title: item.title || `${item.template.schemaType} from template ${item.template.id}`,
        type: item.template.schemaType,
        icon: item.icon,
        template: {
          id: item.template.id,
          params: item.parameters
        },
        permission: { granted: item.granted, reason: item.reason }
      } : void 0;
    }
  ).filter(isNonNullable$3), [disableNew, initialValueTemplateItems, schemaType.to]), getReferenceInfo$1 = React.useCallback(
    (id2) => getReferenceInfo(documentPreviewStore, id2, schemaType),
    [documentPreviewStore, schemaType]
  );
  return {
    selectedState,
    isCurrentDocumentLiveEdit,
    handleEditReference,
    EditReferenceLink,
    createOptions,
    getReferenceInfo: getReferenceInfo$1
  };
}
function getTone$3({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$a = { portal: !0, tone: "default" };
function ReferenceField(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const elementRef = React.useRef(null), { schemaType, path, open, inputId, children, inputProps } = props2, { readOnly, focused, renderPreview, onChange } = props2.inputProps, [fieldActionsNodes, setFieldActionNodes] = React.useState([]), documentId = usePublishedId$1(), handleClear = React.useCallback(() => inputProps.onChange(unset()), [inputProps]), value = props2.value, { EditReferenceLink, getReferenceInfo: getReferenceInfo2, selectedState, isCurrentDocumentLiveEdit } = useReferenceInput({
    path,
    schemaType,
    value
  });
  useScrollIntoViewOnFocusWithin(elementRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    !hadFocus && hasFocus && elementRef.current && elementRef.current.focus();
  });
  const hasErrors = props2.validation.some((v) => v.level === "error"), hasWarnings = props2.validation.some((v) => v.level === "warning"), loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2), refTypeName = ((_a2 = loadableReferenceInfo.result) == null ? void 0 : _a2.type) || ((_b = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _b.type), refType = refTypeName ? schemaType.to.find((toType) => toType.name === refTypeName) : void 0, pressed = selectedState === "pressed", selected = selectedState === "selected", hasRef = value == null ? void 0 : value._ref, publishedReferenceExists = hasRef && ((_e = (_d = (_c = loadableReferenceInfo.result) == null ? void 0 : _c.preview) == null ? void 0 : _d.published) == null ? void 0 : _e._id), handleRemoveStrengthenOnPublish = React.useCallback(() => {
    onChange([
      schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]),
      unset(["_strengthenOnPublish"])
    ]);
  }, [onChange, schemaType.weak]), handleFixStrengthMismatch = React.useCallback(() => {
    onChange(schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]));
  }, [onChange, schemaType]), handleReplace = React.useCallback(() => {
    inputProps.onPathFocus(["_ref"]);
  }, [inputProps]), actualStrength = value != null && value._weak ? "weak" : "strong", weakShouldBe = schemaType.weak === !0 ? "weak" : "strong", weakWarningOverride = hasRef && !loadableReferenceInfo.isLoading && (value == null ? void 0 : value._strengthenOnPublish), showWeakRefMismatch = !loadableReferenceInfo.isLoading && ((_f = loadableReferenceInfo.result) == null ? void 0 : _f.availability.available) && hasRef && actualStrength !== weakShouldBe && !weakWarningOverride, tone = getTone$3({ readOnly, hasErrors, hasWarnings }), isEditing = !(value != null && value._ref) || inputProps.focusPath[0] === "_ref", { t: t2 } = useTranslation(), footer = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    isCurrentDocumentLiveEdit && publishedReferenceExists && value._strengthenOnPublish && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceFinalizeAlertStrip,
      {
        schemaType,
        handleRemoveStrengthenOnPublish
      }
    ),
    showWeakRefMismatch && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceStrengthMismatchAlertStrip,
      {
        actualStrength,
        handleFixStrengthMismatch
      }
    ),
    loadableReferenceInfo.error && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceMetadataLoadErrorAlertStrip,
      {
        errorMessage: loadableReferenceInfo.error.message,
        onHandleRetry: loadableReferenceInfo.retry
      }
    )
  ] }), OpenLink = React.useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      React.forwardRef(function(restProps, _ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(
          router.IntentLink,
          {
            ...restProps,
            intent: "edit",
            params: { id: value == null ? void 0 : value._ref, type: refType == null ? void 0 : refType.name },
            target: "_blank",
            rel: "noopener noreferrer",
            ref: _ref
          }
        );
      })
    ),
    [refType == null ? void 0 : refType.name, value == null ? void 0 : value._ref]
  ), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
        id: `${inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          !readOnly && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                text: t2("inputs.reference.action.clear"),
                tone: "critical",
                icon: icons.TrashIcon,
                onClick: handleClear
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                text: t2("inputs.reference.action.replace"),
                icon: icons.SyncIcon,
                onClick: handleReplace
              }
            )
          ] }),
          !readOnly && (value == null ? void 0 : value._ref) && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          (value == null ? void 0 : value._ref) && /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              as: OpenLink,
              "data-as": "a",
              text: t2("inputs.reference.action.open-in-new-tab"),
              icon: icons.LaunchIcon
            }
          )
        ] }),
        popover: MENU_POPOVER_PROPS$a
      }
    ) }),
    [handleClear, handleReplace, inputId, OpenLink, readOnly, t2, value == null ? void 0 : value._ref]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && props2.actions && props2.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: props2.actions,
        documentId,
        documentType: schemaType.name,
        onActions: setFieldActionNodes,
        path,
        schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsProvider,
      {
        actions: fieldActionsNodes,
        focused: !!props2.inputProps.focused,
        path,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          FormField,
          {
            __internal_comments: props2.__internal_comments,
            __internal_slot: props2.__internal_slot,
            __unstable_headerActions: fieldActionsNodes,
            __unstable_presence: props2.presence,
            description: props2.description,
            level: props2.level,
            title: props2.title,
            validation: props2.validation,
            deprecated: props2.schemaType.deprecated,
            children: isEditing ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 2, padding: 1, tone, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { gap: 1, align: "center", style: { lineHeight: 0 }, children: /* @__PURE__ */ jsxRuntime.jsxs(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  ReferenceLinkCard,
                  {
                    __unstable_focusRing: !0,
                    as: EditReferenceLink,
                    "data-pressed": pressed ? !0 : void 0,
                    "data-selected": selected ? !0 : void 0,
                    documentId: value == null ? void 0 : value._ref,
                    documentType: refType == null ? void 0 : refType.name,
                    flex: 1,
                    pressed,
                    radius: 2,
                    ref: elementRef,
                    selected,
                    tone: "inherit",
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      PreviewReferenceValue$1,
                      {
                        value,
                        referenceInfo: loadableReferenceInfo,
                        renderPreview,
                        type: schemaType
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: menu })
              ] }) }),
              footer
            ] }) })
          }
        )
      }
    )
  ] });
}
function getOption(type, optionName) {
  return get__default.default(type.options, optionName);
}
const PSEUDO_OBJECTS = ["array", "file", "image", "reference", "slug"], HIDDEN_FIELDS = ["asset", "crop", "hotspot", "_ref", "_weak"], NO_LEVEL_LAYOUTS = ["tags"], NO_LEVEL_TYPES = ["slug"];
function getTypeChain$1(type, visited) {
  if (!type) return [];
  if (visited.has(type)) return [];
  visited.add(type);
  const next = type.type ? getTypeChain$1(type.type, visited) : [];
  return [type, ...next];
}
function getFieldLevel(schemaType, currentLevel) {
  return types.isArraySchemaType(schemaType) ? getArrayFieldLevel(schemaType, currentLevel) : getObjectFieldLevel(schemaType, currentLevel);
}
function getObjectFieldLevel(schemaType, currentLevel) {
  var _a2, _b, _c;
  const { type, options } = schemaType, typeIfRelevant = asType(type, PSEUDO_OBJECTS), fields = (schemaType == null ? void 0 : schemaType.jsonType) === "object" ? schemaType.fields : void 0, typeName = (typeIfRelevant == null ? void 0 : typeIfRelevant.name) || "";
  if (NO_LEVEL_TYPES.includes(typeName))
    return 0;
  const isPseudoObject = PSEUDO_OBJECTS.includes(typeName), hasVisibleFields = ((_a2 = fields == null ? void 0 : fields.filter((f) => !HIDDEN_FIELDS.includes(f.name)).length) != null ? _a2 : 0) > 0, hasListOptions2 = ((_c = (_b = options == null ? void 0 : options.list) == null ? void 0 : _b.length) != null ? _c : 0) > 0;
  return hasVisibleFields || hasListOptions2 || !isPseudoObject ? currentLevel : 0;
}
function getArrayFieldLevel(schemaType, currentLevel) {
  var _a2;
  const { options } = schemaType, hasListOptions2 = ((_a2 = (options == null ? void 0 : options.list) || []) == null ? void 0 : _a2.length) > 0, isNoLevelLayout = NO_LEVEL_LAYOUTS.includes((options == null ? void 0 : options.layout) || "");
  return hasListOptions2 && !isNoLevelLayout ? currentLevel : 0;
}
function asType(schemaType, asOneOfTypes) {
  if (schemaType != null && schemaType.name && asOneOfTypes.includes(schemaType == null ? void 0 : schemaType.name))
    return schemaType;
  if (schemaType)
    return asType(schemaType.type, asOneOfTypes);
}
const EMPTY_ARRAY$l = [];
function BooleanField(field) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    ChangeIndicator,
    {
      hasFocus: !!field.inputProps.focused,
      isChanged: field.inputProps.changed,
      path: field.path,
      children: field.children
    }
  );
}
function PrimitiveField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = React.useState(EMPTY_ARRAY$l), documentId = usePublishedId$1(), focused = !!field.inputProps.focused;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && field.actions && field.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: field.actions,
        documentId,
        documentType: field.schemaType.name,
        onActions: setFieldActionNodes,
        path: field.path,
        schemaType: field.schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormField,
      {
        __internal_slot: field.__internal_slot,
        __internal_comments: field.__internal_comments,
        __unstable_headerActions: fieldActionsNodes,
        __unstable_presence: field.presence,
        "data-testid": `field-${field.inputId}`,
        description: field.description,
        inputId: field.inputId,
        level: field.level,
        title: field.title,
        validation: field.validation,
        deprecated: field.schemaType.deprecated,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ChangeIndicator,
          {
            hasFocus: focused,
            isChanged: field.inputProps.changed,
            path: field.path,
            children: field.children
          }
        )
      }
    ) })
  ] });
}
function ObjectOrArrayField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = React.useState(EMPTY_ARRAY$l), documentId = usePublishedId$1(), focused = !!field.inputProps.focused;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && field.actions && field.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: field.actions,
        documentId,
        documentType: field.schemaType.name,
        onActions: setFieldActionNodes,
        path: field.path,
        schemaType: field.schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormFieldSet,
      {
        __internal_comments: field.__internal_comments,
        __internal_slot: field.__internal_slot,
        __unstable_headerActions: fieldActionsNodes,
        __unstable_presence: field.presence,
        collapsed: field.collapsed,
        collapsible: field.collapsible,
        "data-testid": `field-${field.inputId}`,
        description: field.description,
        level: field.level,
        onCollapse: field.onCollapse,
        onExpand: field.onExpand,
        title: field.title,
        validation: field.validation,
        inputId: field.inputId,
        deprecated: field.schemaType.deprecated,
        children: field.children
      }
    ) })
  ] });
}
function ImageOrFileField(field) {
  const [fieldActionsNodes, setFieldActionNodes] = React.useState(EMPTY_ARRAY$l), documentId = usePublishedId$1(), focused = !!field.inputProps.focused, hotspotField = field.inputProps.members.find(
    (member) => member.kind === "field" && member.name === "hotspot"
  ), presence = hotspotField != null && hotspotField.open ? field.presence : field.presence.concat((hotspotField == null ? void 0 : hotspotField.field.presence) || EMPTY_ARRAY$l);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    documentId && field.actions && field.actions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      FieldActionsResolver,
      {
        actions: field.actions,
        documentId,
        documentType: field.schemaType.name,
        onActions: setFieldActionNodes,
        path: field.path,
        schemaType: field.schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(FieldActionsProvider, { actions: fieldActionsNodes, focused, path: field.path, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormFieldSet,
      {
        __internal_comments: field.__internal_comments,
        __internal_slot: field.__internal_slot,
        __unstable_headerActions: fieldActionsNodes,
        __unstable_presence: presence,
        collapsed: field.collapsed,
        collapsible: field.collapsible,
        description: field.description,
        level: field.level,
        onCollapse: field.onCollapse,
        onExpand: field.onExpand,
        title: field.title,
        validation: field.validation,
        inputId: field.inputId,
        deprecated: field.schemaType.deprecated,
        children: field.children
      }
    ) })
  ] });
}
function defaultResolveFieldComponent(schemaType) {
  var _a2;
  if ((_a2 = schemaType.components) != null && _a2.field) return schemaType.components.field;
  if (types.isBooleanSchemaType(schemaType))
    return BooleanField;
  const typeChain = getTypeChain$1(schemaType, /* @__PURE__ */ new Set());
  return typeChain.some((t2) => t2.name === "image" || t2.name === "file") ? ImageOrFileField : typeChain.some((t2) => types.isCrossDatasetReferenceSchemaType(t2)) || typeChain.some((t2) => t2.name === "slug") ? PrimitiveField : typeChain.some((t2) => types.isReferenceSchemaType(t2)) ? ReferenceField : schemaType.jsonType !== "object" && schemaType.jsonType !== "array" ? PrimitiveField : ObjectOrArrayField;
}
function WorkspaceProvider({ children, workspace }) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.WorkspaceContext.Provider, { value: workspace, children });
}
function useWorkspace() {
  const workspace = React.useContext(_singletons.WorkspaceContext);
  if (!workspace) throw new Error("Workspace: missing context value");
  return workspace;
}
const DEFAULT_API_FIELD_DEPTH = 0, INITIAL_LOADING_STATE$2 = {
  isLoading: !0,
  settings: {
    partialIndexSettings: {
      maxFieldDepth: DEFAULT_API_FIELD_DEPTH
    }
  }
};
function fetchMaxDepth({ client: client2 }) {
  const { projectId, dataset } = client2.config();
  return client2.observable.request({
    uri: `/projects/${projectId}/datasets/${dataset}/settings/indexing`,
    tag: "search.getPartialIndexSettings"
  });
}
const cachedSettings = /* @__PURE__ */ new Map();
function useSearchMaxFieldDepth(overrideClient) {
  var _a2, _b, _c, _d;
  const isEnabled = (_b = (_a2 = useWorkspace().search) == null ? void 0 : _a2.unstable_partialIndexing) == null ? void 0 : _b.enabled, workspaceClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), client2 = React.useMemo(() => overrideClient || workspaceClient, [overrideClient, workspaceClient]), dataset = React.useMemo(() => client2.config().dataset, [client2]);
  isEnabled || cachedSettings.set(dataset, rxjs.of(INITIAL_LOADING_STATE$2.settings)), cachedSettings.has(dataset) || cachedSettings.set(dataset, fetchMaxDepth({ client: client2 }).pipe(operators.shareReplay()));
  const indexSettings = reactRx.useMemoObservable(
    () => cachedSettings.get(dataset).pipe(
      operators.map((settings) => ({
        isLoading: !1,
        settings
      })),
      operators.startWith(INITIAL_LOADING_STATE$2),
      operators.catchError((err) => (console.error(err), rxjs.of({
        isLoading: !1,
        enabled: !0,
        settings: { partialIndexSettings: { maxFieldDepth: DEFAULT_API_FIELD_DEPTH } }
      })))
    ),
    [dataset],
    INITIAL_LOADING_STATE$2
  ), maxFieldDepth = (_d = (_c = indexSettings == null ? void 0 : indexSettings.settings) == null ? void 0 : _c.partialIndexSettings) == null ? void 0 : _d.maxFieldDepth;
  return isFinite__default.default(maxFieldDepth) ? Math.min(maxFieldDepth, _internal.DEFAULT_MAX_FIELD_DEPTH) : _internal.DEFAULT_MAX_FIELD_DEPTH;
}
function useOnClickOutside(refs, handler) {
  React.useEffect(() => {
    const listener = (event) => {
      const target = event.target;
      if (target instanceof HTMLElement) {
        if (refs.some((ref) => {
          var _a2;
          return (_a2 = ref.current) == null ? void 0 : _a2.contains(target);
        }))
          return;
        handler(event);
      }
    };
    return document.addEventListener("mousedown", listener), document.addEventListener("touchstart", listener), () => {
      document.removeEventListener("mousedown", listener), document.removeEventListener("touchstart", listener);
    };
  }, [refs, handler]);
}
const NARROW_LAYOUT = styledComponents.css`
  grid-template-columns: minmax(0px, 1fr);
`, WIDE_LAYOUT = styledComponents.css`
  grid-template-columns: 1fr min-content;
`, Root$p = styledComponents.styled(ui.Grid)(
  (props2) => props2.$narrow ? NARROW_LAYOUT : WIDE_LAYOUT
), AutocompleteContainer = React.forwardRef(function(props2, forwardedRef) {
  const [rootElement, setRootElement] = React.useState(null), handleNewRef = React.useCallback(
    (element) => {
      setForwardedRef(forwardedRef, element), setRootElement(element);
    },
    [forwardedRef]
  ), inputWrapperRect = ui.useElementRect(rootElement);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$p, { ref: handleNewRef, gap: 1, $narrow: ((inputWrapperRect == null ? void 0 : inputWrapperRect.width) || 0) < 480, children: props2.children });
});
function setForwardedRef(ref, instance) {
  typeof ref == "function" ? ref(instance) : ref && (ref.current = instance);
}
const INLINE_BLOCK_STYLE = { display: "inline-flex" }, FULL_WIDTH = { width: "100%" }, POPOVER_PROPS$6 = {
  portal: !0,
  tone: "default",
  constrainSize: !0,
  fallbackPlacements: ["bottom", "left", "top"],
  placement: "right",
  preventOverflow: !0
};
function CreateButton(props2) {
  const { createOptions, onCreate, id: id2, menuRef, ...rest } = props2, currentUser = useCurrentUser(), { t: t2 } = useTranslation(), getI18nText = useGetI18nText(createOptions);
  return createOptions.some((option) => option.permission.granted) ? createOptions.length > 1 ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          ...rest,
          disabled: props2.readOnly,
          text: t2("inputs.reference.action.create-new-document-select"),
          mode: "ghost",
          icon: icons.AddIcon,
          size: "large"
        }
      ),
      id: id2,
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { ref: menuRef, children: createOptions.map((createOption) => /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Tooltip,
        {
          disabled: createOption.permission.granted,
          content: /* @__PURE__ */ jsxRuntime.jsx(
            InsufficientPermissionsMessage,
            {
              currentUser,
              context: "create-document-type"
            }
          ),
          portal: !0,
          children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              disabled: !createOption.permission.granted,
              icon: createOption.icon,
              text: getI18nText(createOption).title,
              onClick: () => onCreate(createOption)
            }
          ) })
        },
        createOption.id
      )) }),
      popover: POPOVER_PROPS$6
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      ...rest,
      text: t2("inputs.reference.action.create-new-document-select"),
      mode: "ghost",
      disabled: !createOptions[0].permission.granted || props2.readOnly,
      onClick: () => onCreate(createOptions[0]),
      icon: icons.AddIcon,
      size: "large"
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(
        InsufficientPermissionsMessage,
        {
          currentUser,
          context: "create-new-reference"
        }
      ),
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { style: INLINE_BLOCK_STYLE, children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          text: t2("inputs.reference.action.create-new-document"),
          mode: "ghost",
          disabled: !0,
          icon: icons.AddIcon,
          style: FULL_WIDTH
        }
      ) })
    }
  );
}
function OptionPreview$1(props2) {
  const { getReferenceInfo: getReferenceInfo2, id: documentId, renderPreview } = props2, { isLoading, result: referenceInfo, error } = useReferenceInfo$1(documentId, getReferenceInfo2), { t: t2 } = useTranslation();
  if (isLoading)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, padding: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: !0 })
    ] });
  if (error)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Alert, { title: t2("inputs.reference.error.failed-to-load-document-title"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: error.message }) }) });
  if (!referenceInfo)
    return null;
  if (referenceInfo.availability.reason === "PERMISSION_DENIED")
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.missing-read-permissions-description") });
  const refType = props2.type.to.find((toType) => toType.name === referenceInfo.type);
  return refType ? referenceInfo && refType && /* @__PURE__ */ jsxRuntime.jsx(
    ReferencePreview,
    {
      id: referenceInfo.id,
      layout: "default",
      preview: referenceInfo.preview,
      refType,
      renderPreview,
      showTypeLabel: props2.type.to.length > 1
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.invalid-search-result-type-title", {
    returnedType: referenceInfo.type
  }) });
}
const StyledPopover$5 = styledComponents.styled(TooltipDelayGroupProvider.Popover)`
  & > div {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }
`, StyledText$5 = styledComponents.styled(ui.Text)`
  word-break: break-word;
`, FALLBACK_PLACEMENTS$2 = ["top-start", "bottom-start"], ReferenceAutocomplete$2 = React.forwardRef(function(props2, ref) {
  const { searchString, loading, portalRef, referenceElement, ...restProps } = props2, { t: t2 } = useTranslation(), hasResults = props2.options && props2.options.length > 0, renderPopover = React.useCallback(
    ({
      content: content2,
      hidden,
      inputElement,
      onMouseEnter,
      onMouseLeave
    }, contentRef) => /* @__PURE__ */ jsxRuntime.jsx(
      StyledPopover$5,
      {
        placement: "bottom-start",
        fallbackPlacements: FALLBACK_PLACEMENTS$2,
        arrow: !1,
        constrainSize: !0,
        onMouseEnter,
        onMouseLeave,
        content: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: contentRef, children: hasResults ? content2 : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(StyledText$5, { align: "center", muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.reference.no-results-for-query",
            values: { searchTerm: searchString || "" }
          }
        ) }) }) }) }),
        open: !loading && !hidden,
        ref: portalRef,
        portal: !0,
        referenceElement: referenceElement || inputElement,
        matchReferenceWidth: !0
      }
    ),
    [hasResults, t2, searchString, loading, portalRef, referenceElement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Autocomplete, { ...restProps, loading, ref, renderPopover });
});
function useReferenceItemRef() {
  return React.useContext(_singletons.ReferenceItemRefContext) || { menuRef: { current: null }, containerRef: { current: null } };
}
let StyledPreviewCardImpl;
const StyledPreviewCard = React.forwardRef(function(props2, ref) {
  return StyledPreviewCardImpl || (StyledPreviewCardImpl = styledComponents.styled(PreviewCard)`
      /* this is a hack to avoid layout jumps while previews are loading
      there's probably better ways of solving this */
      min-height: 36px;
    `), /* @__PURE__ */ jsxRuntime.jsx(StyledPreviewCardImpl, { ref, ...props2 });
}), INITIAL_SEARCH_STATE$2 = {
  hits: [],
  isLoading: !1
}, NO_FILTER$2 = () => !0;
function nonNullable$1(v) {
  return v !== null;
}
function ReferenceInput(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const {
    createOptions,
    onChange,
    onEditReference,
    onSearch,
    schemaType,
    readOnly,
    id: id2,
    onPathFocus,
    value,
    renderPreview,
    path,
    elementProps,
    focusPath
  } = props2, { getReferenceInfo: getReferenceInfo2 } = useReferenceInput({
    path,
    schemaType,
    value
  }), [searchState, setSearchState] = React.useState(INITIAL_SEARCH_STATE$2), handleCreateNew = React.useCallback(
    (option) => {
      const newDocumentId = uuid.uuid(), patches = [
        setIfMissing({}),
        set(schemaType.name, ["_type"]),
        set(newDocumentId, ["_ref"]),
        set(!0, ["_weak"]),
        set({ type: option.type, weak: schemaType.weak, template: option.template }, [
          "_strengthenOnPublish"
        ])
      ].filter(isNonNullable$3);
      onChange(patches), onEditReference({ id: newDocumentId, type: option.type, template: option.template }), onPathFocus([]);
    },
    [onChange, onEditReference, onPathFocus, schemaType]
  ), handleChange = React.useCallback(
    (nextId) => {
      if (!nextId) {
        onChange(unset()), onPathFocus([]);
        return;
      }
      const hit = searchState.hits.find((h) => h.id === nextId);
      if (!hit)
        throw new Error("Selected an item that wasnt part of the result set");
      const patches = [
        setIfMissing({}),
        set(schemaType.name, ["_type"]),
        set(getPublishedId(nextId), ["_ref"]),
        hit.published && !schemaType.weak ? unset(["_weak"]) : set(!0, ["_weak"]),
        hit.published ? unset(["_strengthenOnPublish"]) : set({ type: hit == null ? void 0 : hit.type, weak: schemaType.weak }, ["_strengthenOnPublish"])
      ].filter(isNonNullable$3);
      onChange(patches), onPathFocus([]);
    },
    [onChange, onPathFocus, schemaType.name, schemaType.weak, searchState.hits]
  ), handleClear = React.useCallback(() => {
    onChange(unset());
  }, [onChange]), handleCancelEdit = React.useCallback(() => {
    value != null && value._ref || handleClear();
  }, [handleClear, value == null ? void 0 : value._ref]), handleAutocompleteKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && onPathFocus([]);
    },
    [onPathFocus]
  ), loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2), autocompletePopoverReferenceElementRef = React.useRef(null), { push } = ui.useToast(), { t: t2 } = useTranslation(), handleQueryChange = reactRx.useObservableCallback(
    (inputValue$) => inputValue$.pipe(
      operators.filter(nonNullable$1),
      operators.switchMap(
        (searchString) => rxjs.concat(
          rxjs.of({ isLoading: !0 }),
          onSearch(searchString).pipe(
            operators.map((hits2) => ({ hits: hits2, searchString, isLoading: !1 })),
            operators.catchError((error) => (push({
              title: t2("inputs.reference.error.search-failed-title"),
              description: error.message,
              status: "error",
              id: `reference-search-fail-${id2}`
            }), console.error(error), rxjs.of({ hits: [] })))
          )
        )
      ),
      operators.scan(
        (prevState, nextState) => ({ ...prevState, ...nextState }),
        INITIAL_SEARCH_STATE$2
      ),
      operators.tap(setSearchState)
    ),
    [id2, onSearch, push, t2]
  ), handleAutocompleteOpenButtonClick = React.useCallback(() => {
    handleQueryChange("");
  }, [handleQueryChange]), handleCreateButtonKeyDown = React.useCallback(
    (e) => {
      e.key === "Escape" && onPathFocus([]);
    },
    [onPathFocus]
  ), renderOption = React.useCallback(
    (option) => {
      var _a22, _b2;
      const documentId = ((_a22 = option.hit.draft) == null ? void 0 : _a22._id) || ((_b2 = option.hit.published) == null ? void 0 : _b2._id) || option.value;
      return /* @__PURE__ */ jsxRuntime.jsx(StyledPreviewCard, { forwardedAs: "button", type: "button", radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(
        OptionPreview$1,
        {
          getReferenceInfo: getReferenceInfo2,
          id: documentId,
          renderPreview,
          type: schemaType
        }
      ) });
    },
    [schemaType, getReferenceInfo2, renderPreview]
  ), renderValue = React.useCallback(() => {
    var _a22, _b2, _c2, _d2;
    return ((_b2 = (_a22 = loadableReferenceInfo.result) == null ? void 0 : _a22.preview.draft) == null ? void 0 : _b2.title) || ((_d2 = (_c2 = loadableReferenceInfo.result) == null ? void 0 : _c2.preview.published) == null ? void 0 : _d2.title) || "";
  }, [
    (_b = (_a2 = loadableReferenceInfo.result) == null ? void 0 : _a2.preview.draft) == null ? void 0 : _b.title,
    (_d = (_c = loadableReferenceInfo.result) == null ? void 0 : _c.preview.published) == null ? void 0 : _d.title
  ]), handleFocus = React.useCallback(() => onPathFocus(["_ref"]), [onPathFocus]), handleBlur = React.useCallback(
    (event) => {
      var _a22;
      (_a22 = autocompletePopoverReferenceElementRef.current) != null && _a22.contains(event.relatedTarget) || props2.elementProps.onBlur(event);
    },
    [props2.elementProps]
  ), isWeakRefToNonexistent = ((_f = (_e = loadableReferenceInfo == null ? void 0 : loadableReferenceInfo.result) == null ? void 0 : _e.availability) == null ? void 0 : _f.reason) === "NOT_FOUND" && !(value != null && value._strengthenOnPublish) && (value == null ? void 0 : value._weak);
  useDidUpdate((focusPath == null ? void 0 : focusPath[0]) === "_ref", (hadFocusAtRef, hasFocusAtRef) => {
    var _a22;
    !hadFocusAtRef && hasFocusAtRef && ((_a22 = elementProps.ref.current) == null || _a22.focus());
  });
  const hits = React.useMemo(
    () => searchState.hits.map((hit) => ({
      value: hit.id,
      hit
    })),
    [searchState.hits]
  ), isEditing = focusPath.length === 1 && focusPath[0] === "_ref", { menuRef, containerRef } = useReferenceItemRef(), clickOutsideBoundaryRef = React.useRef(null), autoCompletePortalRef = React.useRef(null), createButtonMenuPortalRef = React.useRef(null);
  return useOnClickOutside(
    [
      containerRef,
      clickOutsideBoundaryRef,
      autoCompletePortalRef,
      createButtonMenuPortalRef,
      menuRef
    ],
    () => {
      isEditing && handleCancelEdit();
    }
  ), /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, "data-testid": "reference-input", ref: clickOutsideBoundaryRef, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    isWeakRefToNonexistent ? /* @__PURE__ */ jsxRuntime.jsx(
      Alert,
      {
        "data-testid": "alert-nonexistent-document",
        title: t2("inputs.reference.error.nonexistent-document-title"),
        suffix: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            text: t2("inputs.reference.error.nonexistent-document.clear-button-label"),
            onClick: handleClear
          }
        ) }),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            i18nKey: "inputs.reference.error.nonexistent-document-description",
            t: t2,
            values: { documentId: value._ref }
          }
        ) })
      }
    ) : null,
    /* @__PURE__ */ jsxRuntime.jsxs(AutocompleteContainer, { ref: autocompletePopoverReferenceElementRef, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ReferenceAutocomplete$2,
        {
          ...elementProps,
          onFocus: handleFocus,
          onBlur: handleBlur,
          "data-testid": "autocomplete",
          loading: searchState.isLoading,
          referenceElement: autocompletePopoverReferenceElementRef.current,
          options: hits,
          radius: 2,
          placeholder: t2("inputs.reference.search-placeholder"),
          onKeyDown: handleAutocompleteKeyDown,
          readOnly: loadableReferenceInfo.isLoading || readOnly,
          onQueryChange: handleQueryChange,
          searchString: searchState.searchString,
          onChange: handleChange,
          filterOption: NO_FILTER$2,
          renderOption,
          renderValue,
          openButton: { onClick: handleAutocompleteOpenButtonClick },
          portalRef: autoCompletePortalRef,
          value: value == null ? void 0 : value._ref
        }
      ),
      createOptions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
        CreateButton,
        {
          id: `${id2}-selectTypeMenuButton`,
          readOnly,
          createOptions,
          onCreate: handleCreateNew,
          onKeyDown: handleCreateButtonKeyDown,
          menuRef: createButtonMenuPortalRef
        }
      )
    ] })
  ] }) });
}
async function resolveUserDefinedFilter$1(options, document2, valuePath, getClient) {
  if (!options)
    return {};
  if (typeof options.filter == "function") {
    const parentPath = valuePath.slice(0, -1), parent = PathUtils.get(document2, parentPath);
    return await options.filter({ document: document2, parentPath, parent, getClient });
  }
  return {
    filter: options.filter,
    params: "filterParams" in options ? options.filterParams : void 0
  };
}
function useValueRef$1(value) {
  const ref = React.useRef(value);
  return ref.current = value, ref;
}
function StudioReferenceInput(props2) {
  var _a2, _b, _c, _d;
  const source = useSource(), searchClient = source.getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), schema2 = useSchema(), maxFieldDepth = useSearchMaxFieldDepth(), documentPreviewStore = useDocumentPreviewStore(), { path, schemaType } = props2, { EditReferenceLinkComponent, onEditReference, activePath, initialValueTemplateItems } = useReferenceInputOptions(), { enableLegacySearch = !1 } = source.search, documentValue = useFormValue([]), documentRef = useValueRef$1(documentValue), documentTypeName = (_a2 = documentRef.current) == null ? void 0 : _a2._type, refType = schema2.get(documentTypeName), isDocumentLiveEdit = React.useMemo(() => refType == null ? void 0 : refType.liveEdit, [refType]), disableNew = ((_b = schemaType.options) == null ? void 0 : _b.disableNew) === !0, getClient = source.getClient, handleSearch = React.useCallback(
    (searchString) => rxjs.from(resolveUserDefinedFilter$1(schemaType.options, documentRef.current, path, getClient)).pipe(
      operators.mergeMap(
        ({ filter, params }) => referenceSearch(
          searchClient,
          searchString,
          schemaType,
          {
            ...schemaType.options,
            filter,
            params,
            tag: "search.reference",
            maxFieldDepth
          },
          enableLegacySearch
        )
      ),
      operators.catchError((err) => {
        var _a22;
        const isQueryError = err.details && err.details.type === "queryParseError";
        return (_a22 = schemaType.options) != null && _a22.filter && isQueryError && (err.message = 'Invalid reference filter, please check the custom "filter" option'), rxjs.throwError(err);
      })
    ),
    [schemaType, documentRef, path, getClient, searchClient, maxFieldDepth, enableLegacySearch]
  ), template2 = (_d = (_c = props2.value) == null ? void 0 : _c._strengthenOnPublish) == null ? void 0 : _d.template, EditReferenceLink = React.useMemo(
    () => React.forwardRef(function(_props, forwardedRef) {
      return EditReferenceLinkComponent ? /* @__PURE__ */ jsxRuntime.jsx(
        EditReferenceLinkComponent,
        {
          ..._props,
          ref: forwardedRef,
          parentRefPath: path,
          template: template2
        }
      ) : null;
    }),
    [EditReferenceLinkComponent, path, template2]
  ), handleEditReference = React.useCallback(
    (event) => {
      onEditReference == null || onEditReference({
        parentRefPath: path,
        id: event.id,
        type: event.type,
        template: event.template
      });
    },
    [onEditReference, path]
  ), selectedState = PathUtils__namespace.startsWith(path, (activePath == null ? void 0 : activePath.path) || []) ? activePath == null ? void 0 : activePath.state : "none", createOptions = React.useMemo(() => disableNew ? [] : (initialValueTemplateItems || []).filter((i) => schemaType.to.some((_refType) => {
    var _a22;
    return _refType.name === ((_a22 = i.template) == null ? void 0 : _a22.schemaType);
  })).map(
    (item) => {
      var _a22, _b2, _c2;
      return (_a22 = item.template) != null && _a22.schemaType ? {
        id: item.id,
        title: item.title || `${item.template.schemaType} from template ${(_b2 = item.template) == null ? void 0 : _b2.id}`,
        i18n: item.i18n,
        type: item.template.schemaType,
        icon: item.icon,
        template: {
          id: (_c2 = item.template) == null ? void 0 : _c2.id,
          params: item.parameters
        },
        permission: { granted: item.granted, reason: item.reason }
      } : void 0;
    }
  ).filter(isNonNullable$3), [disableNew, initialValueTemplateItems, schemaType.to]), getReferenceInfo$1 = React.useCallback(
    (id2, _type) => getReferenceInfo(documentPreviewStore, id2, _type),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ReferenceInput,
    {
      ...props2,
      onSearch: handleSearch,
      liveEdit: isDocumentLiveEdit,
      getReferenceInfo: getReferenceInfo$1,
      selectedState,
      editReferenceLinkComponent: EditReferenceLink,
      createOptions,
      onEditReference: handleEditReference
    }
  );
}
function isObjectItemProps(item) {
  return types.isObjectSchemaType(item.schemaType);
}
function isObjectInputProps(inputProps) {
  return types.isObjectSchemaType(inputProps.schemaType);
}
function isStringInputProps(inputProps) {
  return types.isStringSchemaType(inputProps.schemaType);
}
function isNumberInputProps(inputProps) {
  return types.isNumberSchemaType(inputProps.schemaType);
}
function isBooleanInputProps(inputProps) {
  return types.isBooleanSchemaType(inputProps.schemaType);
}
function isArrayOfObjectsInputProps(inputProps) {
  return types.isArrayOfObjectsSchemaType(inputProps.schemaType);
}
function isArrayOfBlocksInputProps(inputProps) {
  return types.isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function isArrayOfPrimitivesInputProps(inputProps) {
  return types.isArrayOfPrimitivesSchemaType(inputProps.schemaType);
}
function restrictToBoundingRect(transform, rect, boundingRect, margins) {
  const value = {
    ...transform
  }, marginY = margins.y || 0, marginX = margins.x || 0;
  return rect.top + value.y <= boundingRect.top + marginY ? value.y = boundingRect.top - rect.top + marginY : rect.bottom + value.y >= boundingRect.top + boundingRect.height - marginY && (value.y = boundingRect.top + boundingRect.height - rect.bottom - marginY), rect.left + value.x <= boundingRect.left - marginX ? value.x = boundingRect.left - rect.left + marginX : rect.right + value.x >= boundingRect.left + boundingRect.width + marginX && (value.x = boundingRect.left + boundingRect.width - rect.right + marginX), value;
}
const restrictToParentElementWithMargins = (margins) => ({ containerNodeRect, draggingNodeRect, transform }) => !draggingNodeRect || !containerNodeRect ? transform : restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect, margins), MOVING_ITEM_CLASS_NAME = "moving", ListItem$2 = styledComponents.styled(ui.Box)`
  ${(props2) => props2.$moving && styledComponents.css`
      z-index: 10000;
      /* prevents hover-effects etc on the dragged element  */
      pointer-events: none;
    `}
`, AUTO_SCROLL_OPTIONS = {
  threshold: {
    x: 0,
    y: 0.02
  }
}, SENSOR_OPTIONS = {
  coordinateGetter: sortable.sortableKeyboardCoordinates
}, TRANSITION$1 = {
  duration: 200,
  easing: "ease"
};
function restrictToAxis(axis) {
  return axis === "x" ? modifiers.restrictToHorizontalAxis : modifiers.restrictToVerticalAxis;
}
function sortingStrategy(axis) {
  return axis === "x" ? sortable.horizontalListSortingStrategy : sortable.verticalListSortingStrategy;
}
const SortableList = React.memo(function(props2) {
  const { items, axis, onItemMove, onItemMoveStart, onItemMoveEnd, children, ...rest } = props2, sensors = core.useSensors(core.useSensor(core.PointerSensor), core.useSensor(core.KeyboardSensor, SENSOR_OPTIONS)), handleDragEnd = React.useCallback(
    (event) => {
      var _a2, _b, _c, _d;
      const { active, over } = event;
      active.id !== (over == null ? void 0 : over.id) && (onItemMove == null || onItemMove({
        fromIndex: (_b = (_a2 = active.data.current) == null ? void 0 : _a2.sortable) == null ? void 0 : _b.index,
        toIndex: (_d = (_c = over == null ? void 0 : over.data.current) == null ? void 0 : _c.sortable) == null ? void 0 : _d.index
      })), onItemMoveEnd == null || onItemMoveEnd();
    },
    [onItemMove, onItemMoveEnd]
  ), modifiers2 = React.useMemo(
    () => [restrictToParentElementWithMargins({ y: 4 }), ...axis ? [restrictToAxis(axis)] : []],
    [axis]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    core.DndContext,
    {
      sensors,
      autoScroll: AUTO_SCROLL_OPTIONS,
      modifiers: modifiers2,
      collisionDetection: core.closestCenter,
      onDragEnd: handleDragEnd,
      onDragStart: onItemMoveStart,
      children: /* @__PURE__ */ jsxRuntime.jsx(sortable.SortableContext, { items, strategy: axis ? sortingStrategy(axis) : void 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { ...rest, children }) })
    }
  );
}), SortableListItem = React.forwardRef(
  function(props2, ref) {
    const { id: id2, children, disableTransition } = props2, { setNodeRef, transform, transition, active } = sortable.useSortable({
      id: id2,
      transition: disableTransition ? null : TRANSITION$1
    }), isActive = id2 === (active == null ? void 0 : active.id), style = React.useMemo(
      () => ({
        transform: utilities.CSS.Translate.toString(transform),
        transition,
        pointerEvents: active ? "none" : void 0
      }),
      [transform, transition, active]
    ), setRef = React.useCallback(
      (node) => {
        setNodeRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
      },
      [ref, setNodeRef]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(
      ListItem$2,
      {
        ref: setRef,
        style,
        $moving: isActive,
        className: isActive ? MOVING_ITEM_CLASS_NAME : "",
        "data-index": props2["data-index"],
        children
      }
    );
  }
);
function List(props2) {
  const { onItemMove, onItemMoveEnd, onItemMoveStart, sortable: sortable2, ...rest } = props2, handleSortEnd = React.useCallback(
    (event) => {
      onItemMove == null || onItemMove(event);
    },
    [onItemMove]
  );
  return sortable2 ? /* @__PURE__ */ jsxRuntime.jsx(
    SortableList,
    {
      onItemMove: handleSortEnd,
      onItemMoveStart,
      onItemMoveEnd,
      ...rest
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { ...rest });
}
const Item = React.forwardRef(function(props2, ref) {
  const { sortable: sortable2, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.SortableItemIdContext.Provider, { value: props2.id, children: sortable2 ? /* @__PURE__ */ jsxRuntime.jsx(SortableListItem, { ref, ...rest }) : /* @__PURE__ */ jsxRuntime.jsx(ListItem$2, { ref, ...rest }) });
});
function focusRingBorderStyle$2(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
function focusRingStyle$1(opts) {
  const { base, border, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border && focusRingBorderStyle$2(border),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
function withFocusRing(component) {
  return styledComponents.styled(component)(
    (props2) => {
      const { $border, $radius } = props2, { card, color: color2, radius } = theme.getTheme_v2(props2.theme), border = { width: $border ? 1 : 0, color: "var(--card-border-color)" };
      return styledComponents.css`
        --card-focus-box-shadow: ${focusRingBorderStyle$2(border)};

        border-radius: ${ui.rem(radius[$radius != null ? $radius : 1])};
        outline: none;
        box-shadow: var(--card-focus-box-shadow);

        &:focus {
          --card-focus-box-shadow: ${focusRingStyle$1({
        border,
        base: color2,
        focusRing: {
          ...card.focusRing,
          // An offset of 0 is needed to avoid the focus ring overlap the border of the inner items, the theme has an offset of -1
          // Detected in empty array items.
          offset: 0
        }
      })};
        }
      `;
    }
  );
}
function extractPastedFiles(dataTransfer) {
  return dataTransfer.files && dataTransfer.files.length > 0 ? Promise.resolve(Array.from(dataTransfer.files || [])) : normalizeItems(Array.from(dataTransfer.items || [])).then(flatten__default.default);
}
function extractDroppedFiles(dataTransfer) {
  const files = Array.from(dataTransfer.files || []), items = Array.from(dataTransfer.items || []);
  return files && files.length > 0 ? Promise.resolve(files) : normalizeItems(items).then(flatten__default.default);
}
function toArray(v) {
  return v === null ? [] : [v];
}
function normalizeItems(items) {
  return Promise.all(
    items.map((item) => {
      if (item.kind === "file" && item.webkitGetAsEntry) {
        let entry;
        try {
          entry = item.webkitGetAsEntry();
        } catch {
          return toArray(item.getAsFile());
        }
        return entry ? entry.isDirectory ? walk(entry) : toArray(item.getAsFile()) : [];
      }
      if (item.kind === "file") {
        const file = item.getAsFile();
        return Promise.resolve(file ? [file] : []);
      }
      return item.kind === "string" ? (console.warn('DataTransfer with kind="string" is currently not supported'), Promise.resolve([])) : (console.warn("Unknown DataTransferItem.kind: %s", item.kind), Promise.resolve([]));
    })
  );
}
function walk(entry) {
  if (entry.isFile)
    return new Promise((resolve, reject) => entry.file(resolve, reject)).then(
      (file) => [file]
    );
  if (entry.isDirectory) {
    const dir = entry.createReader();
    return new Promise((resolve, reject) => dir.readEntries(resolve, reject)).then((entries) => entries.filter((entr) => !entr.name.startsWith("."))).then((entries) => Promise.all(entries.map(walk)).then(flatten__default.default));
  }
  return Promise.resolve([]);
}
function imageUrlToBlob(imageUrl, format2 = "image/jpeg", quality = 1) {
  return imageUrl.match(/^webkit-fake-url:\/\//) ? Promise.reject(new Error("Cannot read image contents from webkit fake url")) : new Promise((resolve, reject) => {
    const loader = new Image();
    loader.crossOrigin = "anonymous", loader.referrerPolicy = "strict-origin-when-cross-origin", loader.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = loader.width, canvas.height = loader.height;
      const ctx = canvas.getContext("2d");
      ctx == null || ctx.drawImage(loader, 0, 0, canvas.width, canvas.height);
      try {
        canvas.toBlob(resolve, format2, quality);
      } catch (error) {
        reject(error);
      }
    }, loader.src = imageUrl;
  });
}
const PASTE_INPUT_STYLE = { opacity: 0, position: "absolute" };
function fileTarget(Component) {
  return React.forwardRef(function(props2, ref) {
    const { onFiles, onFilesOver, onFilesOut, disabled, ...rest } = props2, [showPasteInput, setShowPasteInput] = React.useState(!1), pasteInput = React.useRef(null), forwardedRef = ui.useForwardedRef(ref), enteredElements = React.useRef([]), emitFiles = React.useCallback(
      (files) => {
        onFiles == null || onFiles(files);
      },
      [onFiles]
    ), handleKeyDown = React.useCallback(
      (event) => {
        event.target === forwardedRef.current && (event.ctrlKey || event.metaKey) && event.key === "v" && setShowPasteInput(!0);
      },
      [forwardedRef]
    ), handlePaste = React.useCallback(
      (event) => {
        extractPastedFiles(event.clipboardData).then((files) => pasteInput.current ? files.length > 0 ? files : (
          // Invoke Safari hack if we didn't get any files
          convertImagesToFilesAndClearContentEditable(pasteInput.current, "image/jpeg")
        ) : []).then((files) => {
          var _a2;
          emitFiles(files), setShowPasteInput(!1), (_a2 = forwardedRef.current) == null || _a2.focus();
        });
      },
      [emitFiles, forwardedRef]
    ), handleDrop = React.useCallback(
      (event) => {
        enteredElements.current = [], event.preventDefault(), event.stopPropagation();
        const dataTransfer = event.nativeEvent.dataTransfer;
        onFiles && dataTransfer && extractDroppedFiles(dataTransfer).then((files) => {
          files && emitFiles(files);
        }), onFilesOut == null || onFilesOut();
      },
      [emitFiles, onFiles, onFilesOut]
    ), handleDragOver = React.useCallback(
      (event) => {
        onFiles && (event.preventDefault(), event.stopPropagation());
      },
      [onFiles]
    ), handleDragEnter = React.useCallback(
      (event) => {
        if (event.stopPropagation(), onFilesOver && forwardedRef.current === event.currentTarget) {
          enteredElements.current = [...new Set(enteredElements.current), event.currentTarget];
          const fileTypes = Array.from(event.dataTransfer.items).map((item) => ({
            type: item.type,
            kind: item.kind
          }));
          onFilesOver(fileTypes);
        }
      },
      [onFilesOver, forwardedRef]
    ), handleDragLeave = React.useCallback(
      (event) => {
        event.stopPropagation();
        const idx = enteredElements.current.indexOf(event.currentTarget);
        idx > -1 && enteredElements.current.splice(idx, 1), enteredElements.current.length === 0 && (onFilesOut == null || onFilesOut());
      },
      [onFilesOut]
    ), prevShowPasteInput = React.useRef(!1);
    return React.useEffect(() => {
      var _a2;
      !prevShowPasteInput.current && showPasteInput && pasteInput.current ? (pasteInput.current.focus(), select(pasteInput.current)) : prevShowPasteInput.current && !showPasteInput && ((_a2 = pasteInput.current) == null || _a2.focus()), prevShowPasteInput.current = showPasteInput;
    }, [showPasteInput]), /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        Component,
        {
          ...rest,
          ref: forwardedRef,
          onKeyDown: disabled ? void 0 : handleKeyDown,
          onDragOver: disabled ? void 0 : handleDragOver,
          onDragEnter: disabled ? void 0 : handleDragEnter,
          onDragLeave: disabled ? void 0 : handleDragLeave,
          onDrop: disabled ? void 0 : handleDrop
        }
      ),
      !disabled && showPasteInput && /* @__PURE__ */ jsxRuntime.jsx("div", { contentEditable: !0, onPaste: handlePaste, ref: pasteInput, style: PASTE_INPUT_STYLE })
    ] });
  });
}
function convertImagesToFilesAndClearContentEditable(element, targetFormat = "image/jpeg") {
  return element.isContentEditable ? new Promise((resolve) => setTimeout(resolve, 10)).then(() => Array.from(element.querySelectorAll("img"))).then((imageElements) => (element.innerHTML = "", imageElements)).then((images) => Promise.all(images.map((img) => imageUrlToBlob(img.src)))).then(
    (imageBlobs) => imageBlobs.map((blob) => new File([blob], "pasted-image.jpg", { type: targetFormat }))
  ) : Promise.reject(
    new Error(
      `Expected element to be contentEditable="true". Instead found a non contenteditable ${element.tagName}`
    )
  );
}
function select(el) {
  const range2 = document.createRange();
  range2.selectNodeContents(el);
  const sel = window.getSelection();
  sel == null || sel.removeAllRanges(), sel == null || sel.addRange(range2);
}
function DropMessage(props2) {
  const { hoveringFiles, types: types2, resolveUploader: resolveUploader2 } = props2, acceptedFiles = hoveringFiles.filter(
    (file) => types2.some((type) => resolveUploader2(type, file))
  ), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, multiple = types2.length > 1, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: acceptedFiles.length > 0 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.UploadIcon, {}) }),
      multiple ? t2("inputs.files.common.drop-message.drop-to-upload-multi", {
        count: acceptedFiles.length
      }) : t2("inputs.files.common.drop-message.drop-to-upload"),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, {})
    ] }),
    rejectedFilesCount > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t2("inputs.files.common.drop-message.drop-to-upload.rejected-file-message", {
        count: rejectedFilesCount
      }) })
    ] }) })
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: t2("inputs.files.common.drop-message.drop-to-upload.no-accepted-file-message", {
      count: hoveringFiles.length
    }) })
  ] }) });
}
const Overlay$1 = styledComponents.styled(ui.Layer)`
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  background-color: var(--card-bg-color);
  opacity: 0.8;
`, Root$o = styledComponents.styled.div`
  position: relative;
`;
function getUploadCandidates$1(types2, resolveUploader2, file) {
  return types2.map((memberType) => ({
    type: memberType,
    uploader: resolveUploader2(memberType, file)
  })).filter((member) => member.uploader);
}
function uploadTarget(Component) {
  const FileTarget2 = fileTarget(Component);
  return React.forwardRef(function(props2, forwardedRef) {
    const { children, resolveUploader: resolveUploader2, onUpload, types: types2, ...rest } = props2, { push: pushToast } = ui.useToast(), { t: t2 } = useTranslation(), uploadFile2 = React.useCallback(
      (file, resolvedUploader) => {
        const { type, uploader } = resolvedUploader;
        onUpload == null || onUpload({ file, schemaType: type, uploader });
      },
      [onUpload]
    ), handleFiles = React.useCallback(
      (files) => {
        if (!resolveUploader2)
          return;
        const tasks2 = files.map((file) => ({
          file,
          uploaderCandidates: getUploadCandidates$1(types2, resolveUploader2, file)
        })), ready = tasks2.filter((task) => task.uploaderCandidates.length > 0), rejected = tasks2.filter((task) => task.uploaderCandidates.length === 0);
        rejected.length > 0 && pushToast({
          closable: !0,
          status: "warning",
          title: t2("inputs.array.error.cannot-upload-unable-to-convert", {
            count: rejected.length
          }),
          description: rejected.map((task, i) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, padding: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: task.file.name }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
              "(",
              task.file.type,
              ")"
            ] }) })
          ] }, i))
        }), ready.forEach((task) => {
          uploadFile2(
            task.file,
            // eslint-disable-next-line max-nested-callbacks
            sortBy__default.default(task.uploaderCandidates, (candidate) => candidate.uploader.priority)[0]
          );
        });
      },
      [pushToast, resolveUploader2, types2, uploadFile2, t2]
    ), [hoveringFiles, setHoveringFiles] = React.useState([]), handleFilesOut = React.useCallback(() => setHoveringFiles([]), []);
    return /* @__PURE__ */ jsxRuntime.jsx(Root$o, { children: /* @__PURE__ */ jsxRuntime.jsxs(
      FileTarget2,
      {
        ...rest,
        ref: forwardedRef,
        onFiles: handleFiles,
        onFilesOver: setHoveringFiles,
        onFilesOut: handleFilesOut,
        children: [
          resolveUploader2 && hoveringFiles.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(Overlay$1, { zOffset: 10, children: /* @__PURE__ */ jsxRuntime.jsx(
            DropMessage,
            {
              hoveringFiles,
              types: types2,
              resolveUploader: resolveUploader2
            }
          ) }),
          children
        ]
      }
    ) });
  });
}
const UploadTargetCard = withFocusRing(uploadTarget(ui.Card)), POPOVER_PROPS$5 = {
  constrainSize: !0,
  portal: !0,
  fallbackPlacements: ["top", "bottom"]
};
function ArrayOfObjectsFunctions(props2) {
  const { schemaType, readOnly, children, onValueCreate, onItemAppend } = props2, menuButtonId = React.useId(), { t: t2 } = useTranslation(), insertItem = React.useCallback(
    (itemType) => {
      const item = onValueCreate(itemType);
      onItemAppend(item);
    },
    [onValueCreate, onItemAppend]
  ), handleAddBtnClick = React.useCallback(() => {
    insertItem(schemaType.of[0]);
  }, [schemaType, insertItem]), addItemI18nKey = schemaType.of.length > 1 ? "inputs.array.action.add-item-select-type" : "inputs.array.action.add-item";
  return readOnly ? /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { portal: !0, content: t2("inputs.array.read-only-label"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { icon: icons.AddIcon, mode: "ghost", disabled: !0, size: "large", text: t2(addItemI18nKey) }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: { gridTemplateColumns: "repeat(auto-fit, minmax(100px, 1fr))" }, children: [
    schemaType.of.length === 1 ? /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.AddIcon,
        mode: "ghost",
        onClick: handleAddBtnClick,
        size: "large",
        text: t2(addItemI18nKey)
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { icon: icons.AddIcon, mode: "ghost", size: "large", text: t2(addItemI18nKey) }),
        id: menuButtonId || "",
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: schemaType.of.map((memberDef, i) => {
          var _a2, _b;
          const referenceIcon = types.isReferenceSchemaType(memberDef) && (memberDef.to || []).length === 1 && memberDef.to[0].icon, icon = memberDef.icon || ((_a2 = memberDef.type) == null ? void 0 : _a2.icon) || referenceIcon;
          return /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: memberDef.title || ((_b = memberDef.type) == null ? void 0 : _b.name),
              onClick: () => insertItem(memberDef),
              icon
            },
            i
          );
        }) }),
        popover: POPOVER_PROPS$5
      }
    ),
    children
  ] });
}
const DragHandleButton = styledComponents.styled(TooltipDelayGroupProvider.Button)((props2) => {
  const { $grid, disabled } = props2;
  return disabled ? styledComponents.css`` : styledComponents.css`
    cursor: ${$grid ? "move" : "ns-resize"};
  `;
}), DragHandle = function(props2) {
  const id2 = React.useContext(_singletons.SortableItemIdContext), { mode = "bleed", readOnly, ...rest } = props2, { listeners, attributes } = sortable.useSortable({ id: id2, disabled: readOnly }), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    DragHandleButton,
    {
      icon: icons.DragHandleIcon,
      tooltipProps: {
        content: t2("inputs.array.action.drag.tooltip"),
        delay: { open: 1e3 },
        disabled: !!readOnly
      },
      mode,
      "data-ui": "DragHandleButton",
      ...rest,
      ...attributes,
      ...listeners,
      disabled: readOnly
    }
  );
}, FooterFlex = styledComponents.styled(ui.Flex)`
  min-height: 33px;
`, PresenceFlex = styledComponents.styled(ui.Flex)`
  position: absolute;
  top: 0;
  right: 0;
  height: 33px;
`, DragHandleCard = styledComponents.styled(ui.Card)`
  position: absolute;
  top: 0;
  left: 0;
`, Root$n = styledComponents.styled(ui.Card)`
  transition: border-color 250ms;
  box-sizing: border-box;
  position: relative;

  @media (hover: hover) {
    ${DragHandleCard} {
      opacity: 0;
    }

    &:hover,
    &:focus-within {
      ${DragHandleCard} {
        opacity: 1;
      }
    }
  }

  .${MOVING_ITEM_CLASS_NAME} & {
    box-shadow:
      0 0 0 0,
      0 8px 17px 2px var(--card-shadow-umbra-color),
      0 3px 14px 2px var(--card-shadow-penumbra-color),
      0 5px 5px -3px var(--card-shadow-ambient-color);
  }

  &[aria-selected='true'] {
    box-shadow: 0 0 0 2px var(--card-focus-ring-color);
  }
`;
function CellLayout(props2) {
  const {
    validation: validation2,
    selected,
    tone,
    presence,
    children,
    dragHandle,
    menu,
    footer,
    readOnly,
    ...rest
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Root$n,
    {
      forwardedAs: ui.Flex,
      direction: "column",
      border: !0,
      selected,
      "aria-selected": selected,
      radius: 1,
      tone,
      ...rest,
      children: [
        children,
        dragHandle && /* @__PURE__ */ jsxRuntime.jsx(
          DragHandleCard,
          {
            margin: 1,
            radius: 2,
            display: "flex",
            tone: "inherit",
            "data-ui": "DragHandleCard",
            children: /* @__PURE__ */ jsxRuntime.jsx(DragHandle, { $grid: !0, mode: "ghost", readOnly: !!readOnly })
          }
        ),
        presence && /* @__PURE__ */ jsxRuntime.jsx(PresenceFlex, { align: "center", marginX: 1, children: presence }),
        /* @__PURE__ */ jsxRuntime.jsxs(FooterFlex, { align: "center", paddingX: 1, sizing: "border", justify: "space-between", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: validation2 }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: footer }),
          menu
        ] })
      ]
    }
  );
}
const PopoverCard$1 = styledComponents.styled(ui.Card)`
  max-width: ${({ theme: theme2 }) => theme2.sanity.container[1]}px;
`;
function IncompatibleItemType$1(props2) {
  const { value, onFocus, vertical, ...rest } = props2, [showDetails, setShowDetails] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), { t: t2 } = useTranslation();
  ui.useClickOutside(() => setShowDetails(!1), [popoverRef]);
  const handleKeyDown = React.useCallback((e) => {
    (e.key === "Escape" || e.key === "Tab") && setShowDetails(!1);
  }, []), handleShowDetails = React.useCallback(() => {
    setShowDetails((v) => !v);
  }, []), typeName = content.resolveTypeName(value);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      open: showDetails,
      ref: setPopoverRef,
      onKeyDown: handleKeyDown,
      portal: !0,
      constrainSize: !0,
      tone: "default",
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverCard$1, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: t2("inputs.array.error.type-is-incompatible-title") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.current-schema-not-declare-description",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(icons.BulbOutlineIcon, {}),
          " ",
          t2("inputs.array.error.can-delete-but-no-edit-description")
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.json-representation-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, overflow: "auto", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })
        ] })
      ] }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: "button",
          type: "button",
          radius: 2,
          tone: "inherit",
          paddingX: 2,
          paddingY: 3,
          style: { height: "100%" },
          onFocus,
          onClick: handleShowDetails,
          onKeyDown: handleKeyDown,
          __unstable_focusRing: !0,
          ...rest,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, marginTop: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 4, children: /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
              Translate,
              {
                t: t2,
                i18nKey: "inputs.array.error.type-is-incompatible-prompt",
                values: { typeName }
              }
            ) })
          ] })
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS$9 = { portal: !0, tone: "default" };
function ErrorItem$1(props2) {
  const { member, sortable: sortable2, readOnly } = props2, id2 = React.useId(), { onChange } = useFormCallbacks(), { t: t2 } = useTranslation(), handleRemove = React.useCallback(() => {
    onChange(PatchEvent.from([unset([{ _key: member.key }])]));
  }, [onChange, member.key]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    CellLayout,
    {
      dragHandle: sortable2,
      readOnly,
      tone: "caution",
      style: { height: "100%" },
      menu: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.MenuButton,
        {
          button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
          id: `${id2}-menuButton`,
          menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("inputs.array.action.remove-invalid-item"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: handleRemove
            }
          ) }),
          popover: MENU_POPOVER_PROPS$9
        }
      ),
      children: member.error.type === "INVALID_ITEM_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType$1, { value: member.error.value, vertical: !0 }) : /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("inputs.array.error.unexpected-error", { error: member.error.type }) })
    }
  );
}
function pathToString(path = []) {
  return path.reduce((target, segment, i) => {
    const segmentType = typeof segment;
    if (segmentType === "number")
      return `${target}[${segment}]`;
    if (segmentType === "string")
      return `${target}${i === 0 ? "" : "."}${segment}`;
    if (types.isKeyedObject(segment))
      return `${target}[_key=="${segment._key}"]`;
    throw new Error(`Unsupported path segment "${segment}"`);
  }, "");
}
function isNonNullable$2(t2) {
  return t2 !== null || t2 !== void 0;
}
function convertToValidationMarker(validatorResult, level, context) {
  if (!context)
    throw new Error("missing context");
  if (validatorResult === !0) return [];
  if (Array.isArray(validatorResult))
    return validatorResult.flatMap((child) => convertToValidationMarker(child, level, context)).filter(isNonNullable$2);
  if (typeof validatorResult == "string")
    return convertToValidationMarker({ message: validatorResult }, level, context);
  if (typeof validatorResult.message != "string")
    throw new Error(
      `${pathToString(
        context.path
      )}: Validator must return 'true' if valid or an error message as a string on errors`
    );
  const { message } = validatorResult, normalizedPaths = [];
  validatorResult.path && normalizedPaths.push(validatorResult.path);
  for (const path of validatorResult.paths || [])
    normalizedPaths.push(path);
  return normalizedPaths.length ? normalizedPaths.map((path) => ({
    path: (context.path || []).concat(path),
    level: level || "error",
    item: { message },
    message
  })) : [
    {
      level: level || "error",
      item: { message },
      message,
      path: context.path || []
    }
  ];
}
function escapeRegex(string) {
  return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
}
function localizeMessage(message, i18n) {
  const { currentLocale } = i18n, locale = currentLocale.id;
  if (message[locale])
    return message[locale];
  if (locale.includes("-")) {
    const language = locale.split("-", 1)[0];
    if (message[language])
      return message[language];
  }
  return message["en-US"] || message["en-GB"] || message.en || "Unknown validation error (not localized)";
}
function isLocalizedMessages(message) {
  return message !== !0 && typeof message < "u" && typeof message != "string" && isPlainObject__default.default(message) && !("message" in message);
}
function deepEquals(a, b) {
  if (a === b)
    return !0;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length != b.length) return !1;
    for (let i = 0; i < a.length; i++)
      if (!deepEquals(a[i], b[i]))
        return !1;
    return !0;
  }
  if (Array.isArray(a) != Array.isArray(b))
    return !1;
  if (a && b && typeof a == "object" && typeof b == "object") {
    const keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length)
      return !1;
    if (a instanceof Date && b instanceof Date)
      return a.getTime() === b.getTime();
    if (a instanceof Date != b instanceof Date)
      return !1;
    if (a instanceof RegExp && b instanceof RegExp)
      return a.toString() == b.toString();
    if (a instanceof RegExp != b instanceof RegExp)
      return !1;
    for (let i = 0; i < keys.length; i++)
      if (keys[i] !== "_key" && !Object.prototype.hasOwnProperty.call(b, keys[i]))
        return !1;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== "_key" && !deepEquals(a[key], b[key]))
        return !1;
    }
    return !0;
  }
  return !1;
}
const _toString = {}.toString, builtIns = [Object, Function, Array, String, Boolean, Number, Date, RegExp, Error];
function isBuiltIn(_constructor) {
  for (let i = 0; i < builtIns.length; i++)
    if (builtIns[i] === _constructor) return !0;
  return !1;
}
function typeString(obj) {
  const stringType = _toString.call(obj).slice(8, -1);
  if (obj == null) return stringType.toLowerCase();
  const constructorType = obj.constructor;
  return constructorType && !isBuiltIn(constructorType) ? constructorType.name : stringType;
}
const SLOW_VALIDATOR_TIMEOUT = 5e3, formatValidationErrors = (options) => {
  var _a2;
  return options.message ? options.message : options.results.length === 1 ? (_a2 = options.results[0]) == null ? void 0 : _a2.message : options.i18n.t("{{messages, list}}", {
    messages: options.results.map((err) => {
      var _a22;
      return err.message || ((_a22 = err.item) == null ? void 0 : _a22.message);
    }),
    formatParams: { messages: { style: "long", type: options.operation } }
  });
}, genericValidators = {
  type: (expectedType, value, message, { i18n }) => {
    const actualType = typeString(value);
    return actualType !== expectedType && actualType !== "undefined" ? message || i18n.t("validation:generic.incorrect-type", { actualType, expectedType }) : !0;
  },
  presence: (expected, value, message, { i18n }) => value === void 0 && expected === "required" ? message || i18n.t("validation:generic.required") : !0,
  all: async (children, value, message, context) => {
    const results = (await Promise.all(children.map((child) => child.validate(value, context)))).flat();
    return results.length === 0 ? !0 : formatValidationErrors({
      message,
      results,
      operation: "conjunction",
      i18n: context.i18n
    });
  },
  either: async (children, value, message, context) => {
    const resolved = await Promise.all(children.map((child) => child.validate(value, context))), results = resolved.flat();
    return resolved.find((result) => !result.length) ? !0 : formatValidationErrors({
      message,
      results,
      operation: "disjunction",
      i18n: context.i18n
    });
  },
  valid: (allowedValues, actual, message, { i18n }) => {
    const valueType = typeof actual;
    if (valueType === "undefined")
      return !0;
    const value = (valueType === "number" || valueType === "string") && `${actual}`, strValue = value && value.length > 30 ? `${value.slice(0, 30)}\u2026` : value;
    return allowedValues.some((expected) => deepEquals(expected, actual)) ? !0 : message || i18n.t(
      "validation:generic.not-allowed",
      value ? { context: "hint", replace: { hint: strValue } } : {}
    );
  },
  custom: async (fn, value, message, context) => {
    const slowTimer = setTimeout(() => {
      context.environment === "studio" && console.warn(
        `Custom validator at ${pathToString(
          context.path
        )} has taken more than ${SLOW_VALIDATOR_TIMEOUT}ms to respond`
      );
    }, SLOW_VALIDATOR_TIMEOUT);
    let result;
    try {
      result = await fn(value, context);
    } finally {
      clearTimeout(slowTimer);
    }
    return isLocalizedMessages(result) ? localizeMessage(result, context.i18n) : typeof result == "string" && message || result;
  }
}, arrayValidators = {
  ...genericValidators,
  min: (minLength, value, message, { i18n, type }) => {
    if (!value || value.length >= minLength)
      return !0;
    const context = types.isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
    return message || i18n.t("validation:array.minimum-length", { minLength, context });
  },
  max: (maxLength, value, message, { i18n, type }) => {
    if (!value || value.length <= maxLength)
      return !0;
    const context = types.isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
    return message || i18n.t("validation:array.maximum-length", { maxLength, context });
  },
  length: (wantedLength, value, message, { i18n, type }) => {
    if (!value || value.length === wantedLength)
      return !0;
    const context = types.isArrayOfBlocksSchemaType(type) ? "blocks" : void 0;
    return message || i18n.t("validation:array.exact-length", { wantedLength, context });
  },
  presence: (flag, value, message, { i18n }) => flag === "required" && !value ? message || i18n.t("validation:generic.required", { context: "array" }) : !0,
  valid: (allowedValues, values2, message, { i18n }) => {
    if (typeof values2 > "u")
      return !0;
    const paths = [];
    for (let i = 0; i < values2.length; i++) {
      const value = values2[i];
      if (allowedValues.some((expected) => deepEquals(expected, value)))
        continue;
      const pathSegment = value && value._key ? { _key: value._key } : i;
      paths.push([pathSegment]);
    }
    const sharedMessage = message || i18n.t("validation:generic.not-allowed");
    return paths.map((path) => ({ message: sharedMessage, path }));
  },
  unique: (_unused, value, message, { i18n }) => {
    const dupeIndices = [];
    if (!value)
      return !0;
    for (let x = 0; x < value.length; x++)
      for (let y = x + 1; y < value.length; y++) {
        const itemA = value[x], itemB = value[y];
        deepEquals(itemA, itemB) && (dupeIndices.indexOf(x) === -1 && dupeIndices.push(x), dupeIndices.indexOf(y) === -1 && dupeIndices.push(y));
      }
    const paths = dupeIndices.map((idx) => {
      const item = value[idx];
      return [item && item._key ? { _key: item._key } : idx];
    }), sharedMessage = message || i18n.t("validation:array.item-duplicate");
    return paths.map((path) => ({ message: sharedMessage, path }));
  }
}, booleanValidators = {
  ...genericValidators,
  presence: (flag, value, message, { i18n }) => flag === "required" && typeof value != "boolean" ? message || i18n.t("validation:generic.required", { context: "boolean" }) : !0
};
function isRecord$3(obj) {
  return typeof obj == "object" && obj !== null && !Array.isArray(obj);
}
const isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/, getFormattedDate = (type = "", value, options) => {
  const dateFormat = (options == null ? void 0 : options.dateFormat) || legacyDateFormat__namespace.DEFAULT_DATE_FORMAT, timeFormat = (options == null ? void 0 : options.timeFormat) || legacyDateFormat__namespace.DEFAULT_TIME_FORMAT;
  return legacyDateFormat__namespace.format(
    value,
    type === "date" ? dateFormat : `${dateFormat} ${timeFormat}`,
    type === "date"
  );
};
function parseDate$1(date, throwOnError = !1) {
  if (!date) return null;
  if (date === "now") return /* @__PURE__ */ new Date();
  const parsed = new Date(date), isInvalid = isNaN(parsed.getTime());
  if (isInvalid && throwOnError)
    throw new Error(`Unable to parse "${date}" to a date`);
  return isInvalid ? null : parsed;
}
const dateValidators = {
  ...genericValidators,
  type: (_unused, value, message, { i18n }) => typeof value > "u" || isoDate.test(`${value}`) ? !0 : message || i18n.t("validation:date.invalid-format"),
  min: (minDate, value, message, { type, i18n }) => {
    const dateVal = parseDate$1(value), minDateVal = parseDate$1(minDate, !0);
    if (!dateVal || !value || dateVal >= minDateVal)
      return !0;
    if (!type)
      throw new Error("`type` was not provided in validation context.");
    const dateTimeOptions = isRecord$3(type.options) ? type.options : {};
    return message || // Note that the `minDate` passed here is _formatted_, while the raw value provided to the
    // validator is available as `providedMinDate`. This because the formatted date is likely
    // what the developer wants to present to the user
    i18n.t("validation:date.minimum", {
      minDate: getFormattedDate(type.name, minDateVal, dateTimeOptions),
      providedMinDate: minDate
    });
  },
  max: (maxDate, value, message, { type, i18n }) => {
    const dateVal = parseDate$1(value), maxDateVal = parseDate$1(maxDate, !0);
    if (!dateVal || !value || dateVal <= maxDateVal)
      return !0;
    if (!type)
      throw new Error("`type` was not provided in validation context.");
    const dateTimeOptions = isRecord$3(type.options) ? type.options : {};
    return message || // Note that the `maxDate` passed here is _formatted_, while the raw value provided to the
    // validator is available as `providedMaxDate`. This because the formatted date is likely
    // what the developer wants to present to the user
    i18n.t("validation:date.maximum", {
      maxDate: getFormattedDate(type.name, maxDateVal, dateTimeOptions),
      providedMaxDate: maxDate
    });
  }
}, precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/, numberValidators = {
  ...genericValidators,
  integer: (_unused, value, message, { i18n }) => Number.isInteger(value) ? !0 : message || i18n.t("validation:number.non-integer"),
  precision: (limit, value, message, { i18n }) => {
    if (value === void 0) return !0;
    const places = value.toString().match(precisionRx);
    return Math.max(
      (places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0),
      0
    ) > limit ? message || i18n.t("validation:number.maximum-precision", { limit }) : !0;
  },
  min: (minNumber, value, message, { i18n }) => value >= minNumber ? !0 : message || i18n.t("validation:number.minimum", { minNumber }),
  max: (maxNumber, value, message, { i18n }) => value <= maxNumber ? !0 : message || i18n.t("validation:number.maximum", { maxNumber }),
  greaterThan: (threshold, value, message, { i18n }) => value > threshold ? !0 : message || i18n.t("validation:number.greater-than", { threshold }),
  lessThan: (threshold, value, message, { i18n }) => value < threshold ? !0 : message || i18n.t("validation:number.less-than", { threshold })
}, metaKeys = ["_key", "_type", "_weak"], objectValidators = {
  ...genericValidators,
  presence: (expected, value, message, { i18n }) => {
    if (expected !== "required")
      return !0;
    const keys = value && Object.keys(value).filter((key) => !metaKeys.includes(key));
    return value === void 0 || keys && keys.length === 0 ? message || i18n.t("validation:generic.required", { context: "object" }) : !0;
  },
  reference: async (_unused, value, message, context) => {
    if (!value)
      return !0;
    const { type, getDocumentExists, i18n } = context;
    if (!types.isReference(value))
      return message || i18n.t("validation:object.not-reference");
    if (!type)
      throw new Error("`type` was not provided in validation context");
    if ("weak" in type && type.weak)
      return !0;
    if (!getDocumentExists)
      throw new Error("`getDocumentExists` was not provided in validation context");
    return await getDocumentExists({ id: value._ref }) ? !0 : i18n.t("validation:object.reference-not-published", { documentId: value._ref });
  },
  assetRequired: (flag, value, message, { i18n }) => !value || !value.asset || !value.asset._ref ? message || i18n.t("validation:object.asset-required", { context: flag.assetType || "" }) : !0
}, DUMMY_ORIGIN = "http://sanity", isRelativeUrl = (url) => /^\.*\//.test(url), emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, stringValidators = {
  ...genericValidators,
  min: (minLength, value, message, { i18n }) => !value || value.length >= minLength ? !0 : message || i18n.t("validation:string.minimum-length", { minLength }),
  max: (maxLength, value, message, { i18n }) => !value || value.length <= maxLength ? !0 : message || i18n.t("validation:string.maximum-length", { maxLength }),
  length: (wantedLength, value, message, { i18n }) => (value || "").length === wantedLength ? !0 : message || i18n.t("validation:string.exact-length", { wantedLength }),
  uri: (constraints, value, message, { i18n }) => {
    const strValue = value || "";
    if (!strValue)
      return !0;
    const { options } = constraints, { allowCredentials, relativeOnly } = options, allowRelative = options.allowRelative || relativeOnly;
    let url;
    try {
      url = allowRelative ? new URL(strValue, DUMMY_ORIGIN) : new URL(strValue);
    } catch {
      return message || i18n.t("validation:string.url.invalid");
    }
    if (relativeOnly && url.origin !== DUMMY_ORIGIN)
      return message || i18n.t("validation:string.url.not-relative");
    if (!allowRelative && url.origin === DUMMY_ORIGIN && isRelativeUrl(strValue))
      return message || i18n.t("validation:string.url.not-absolute");
    if (!allowCredentials && (url.username || url.password))
      return message || i18n.t("validation:string.url.includes-credentials");
    const urlScheme = url.protocol.replace(/:$/, "");
    return options.scheme.some((scheme) => scheme.test(urlScheme)) ? !0 : message || i18n.t("validation:string.url.disallowed-scheme", { scheme: urlScheme });
  },
  stringCasing: (casing, value, message, { i18n }) => {
    const strValue = value || "";
    return casing === "uppercase" && strValue !== strValue.toLocaleUpperCase() ? message || i18n.t("validation:string.uppercase") : casing === "lowercase" && strValue !== strValue.toLocaleLowerCase() ? message || i18n.t("validation:string.lowercase") : !0;
  },
  presence: (flag, value, message, { i18n }) => flag === "required" && !value ? message || i18n.t("validation:generic.required", { context: "string" }) : !0,
  regex: (options, value, message, { i18n }) => {
    const { pattern, name, invert } = options, regName = name || `${pattern.toString()}`, strValue = value || "";
    pattern.lastIndex = 0;
    const matches = pattern.test(strValue);
    return !invert && !matches || invert && matches ? message || (invert ? i18n.t("validation:string.regex-match", { name: regName }) : i18n.t("validation:string.regex-does-not-match", { name: regName })) : !0;
  },
  email: (_unused, value, message, { i18n }) => {
    const strValue = `${value || ""}`.trim();
    return !strValue || emailRegex.test(strValue) ? !0 : message || i18n.t("validation:string.email");
  }
};
var __defProp$b = Object.defineProperty, __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$b = (obj, key, value) => __defNormalProp$b(obj, typeof key != "symbol" ? key + "" : key, value);
const typeValidators = {
  Boolean: booleanValidators,
  Number: numberValidators,
  String: stringValidators,
  Array: arrayValidators,
  Object: objectValidators,
  Date: dateValidators
}, getBaseType = (type) => type && type.type ? getBaseType(type.type) : type, isFieldRef = (constraint) => typeof constraint != "object" || !constraint ? !1 : constraint.type === Rule.FIELD_REF, EMPTY_ARRAY$k = [], FIELD_REF = Symbol("FIELD_REF"), ruleConstraintTypes$1 = [
  "Array",
  "Boolean",
  "Date",
  "Number",
  "Object",
  "String"
];
var _a;
const Rule = (_a = class {
  constructor(typeDef) {
    __publicField$b(this, "_type"), __publicField$b(this, "_level"), __publicField$b(this, "_required"), __publicField$b(this, "_typeDef"), __publicField$b(this, "_message"), __publicField$b(this, "_rules", []), __publicField$b(this, "_fieldRules"), __publicField$b(this, "valueOfField", _a.valueOfField.bind(_a)), this._typeDef = typeDef, this.reset();
  }
  _mergeRequired(next) {
    if (this._required === "required" || next._required === "required") return "required";
    if (this._required === "optional" || next._required === "optional") return "optional";
  }
  error(message) {
    const rule = this.clone();
    return rule._level = "error", rule._message = message || void 0, rule;
  }
  warning(message) {
    const rule = this.clone();
    return rule._level = "warning", rule._message = message || void 0, rule;
  }
  info(message) {
    const rule = this.clone();
    return rule._level = "info", rule._message = message || void 0, rule;
  }
  reset() {
    return this._type = this._type || void 0, this._rules = (this._rules || []).filter((rule) => rule.flag === "type"), this._message = void 0, this._required = void 0, this._level = "error", this._fieldRules = void 0, this;
  }
  isRequired() {
    return this._required === "required";
  }
  clone() {
    const rule = new _a();
    return rule._type = this._type, rule._message = this._message, rule._required = this._required, rule._rules = cloneDeep__default.default(this._rules), rule._level = this._level, rule._fieldRules = this._fieldRules, rule._typeDef = this._typeDef, rule;
  }
  cloneWithRules(rules) {
    const rule = this.clone(), newRules = /* @__PURE__ */ new Set();
    return rules.forEach((curr) => {
      curr.flag === "type" && (rule._type = curr.constraint), newRules.add(curr.flag);
    }), rule._rules = rule._rules.filter((curr) => {
      const disallowDuplicate = ["type", "uri", "email"].includes(curr.flag), isDuplicate = newRules.has(curr.flag);
      return !(disallowDuplicate && isDuplicate);
    }).concat(rules), rule;
  }
  merge(rule) {
    if (this._type && rule._type && this._type !== rule._type)
      throw new Error("merge() failed: conflicting types");
    const newRule = this.cloneWithRules(rule._rules);
    return newRule._type = this._type || rule._type, newRule._message = this._message || rule._message, newRule._required = this._mergeRequired(rule), newRule._level = this._level === "error" ? rule._level : this._level, newRule;
  }
  // Validation flag setters
  type(targetType) {
    const type = `${targetType.slice(0, 1).toUpperCase()}${targetType.slice(1)}`;
    if (!ruleConstraintTypes$1.includes(type))
      throw new Error(`Unknown type "${targetType}"`);
    const rule = this.cloneWithRules([{ flag: "type", constraint: type }]);
    return rule._type = type, rule;
  }
  all(children) {
    return this.cloneWithRules([{ flag: "all", constraint: children }]);
  }
  either(children) {
    return this.cloneWithRules([{ flag: "either", constraint: children }]);
  }
  // Shared rules
  optional() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "optional" }]);
    return rule._required = "optional", rule;
  }
  required() {
    const rule = this.cloneWithRules([{ flag: "presence", constraint: "required" }]);
    return rule._required = "required", rule;
  }
  custom(fn, options = {}) {
    return options.bypassConcurrencyLimit && Object.assign(fn, { bypassConcurrencyLimit: !0 }), this.cloneWithRules([{ flag: "custom", constraint: fn }]);
  }
  min(len) {
    return this.cloneWithRules([{ flag: "min", constraint: len }]);
  }
  max(len) {
    return this.cloneWithRules([{ flag: "max", constraint: len }]);
  }
  length(len) {
    return this.cloneWithRules([{ flag: "length", constraint: len }]);
  }
  valid(value) {
    const values2 = Array.isArray(value) ? value : [value];
    return this.cloneWithRules([{ flag: "valid", constraint: values2 }]);
  }
  // Numbers only
  integer() {
    return this.cloneWithRules([{ flag: "integer" }]);
  }
  precision(limit) {
    return this.cloneWithRules([{ flag: "precision", constraint: limit }]);
  }
  positive() {
    return this.cloneWithRules([{ flag: "min", constraint: 0 }]);
  }
  negative() {
    return this.cloneWithRules([{ flag: "lessThan", constraint: 0 }]);
  }
  greaterThan(num) {
    return this.cloneWithRules([{ flag: "greaterThan", constraint: num }]);
  }
  lessThan(num) {
    return this.cloneWithRules([{ flag: "lessThan", constraint: num }]);
  }
  // String only
  uppercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "uppercase" }]);
  }
  lowercase() {
    return this.cloneWithRules([{ flag: "stringCasing", constraint: "lowercase" }]);
  }
  regex(pattern, a, b) {
    var _a2, _b;
    const name = typeof a == "string" ? a : (_a2 = a == null ? void 0 : a.name) != null ? _a2 : b == null ? void 0 : b.name, invert = typeof a == "string" ? !1 : (_b = a == null ? void 0 : a.invert) != null ? _b : b == null ? void 0 : b.invert, constraint = {
      pattern,
      name,
      invert: invert || !1
    };
    return this.cloneWithRules([{ flag: "regex", constraint }]);
  }
  email() {
    return this.cloneWithRules([{ flag: "email" }]);
  }
  uri(opts) {
    const optsScheme = (opts == null ? void 0 : opts.scheme) || ["http", "https"], schemes = Array.isArray(optsScheme) ? optsScheme : [optsScheme];
    if (!schemes.length)
      throw new Error("scheme must have at least 1 scheme specified");
    const constraint = {
      options: {
        scheme: schemes.map((scheme) => {
          if (!(scheme instanceof RegExp) && typeof scheme != "string")
            throw new Error("scheme must be a RegExp or a String");
          return typeof scheme == "string" ? new RegExp(`^${escapeRegex(scheme)}$`) : scheme;
        }),
        allowRelative: (opts == null ? void 0 : opts.allowRelative) || !1,
        relativeOnly: (opts == null ? void 0 : opts.relativeOnly) || !1,
        allowCredentials: (opts == null ? void 0 : opts.allowCredentials) || !1
      }
    };
    return this.cloneWithRules([{ flag: "uri", constraint }]);
  }
  // Array only
  unique() {
    return this.cloneWithRules([{ flag: "unique" }]);
  }
  // Objects only
  reference() {
    return this.cloneWithRules([{ flag: "reference" }]);
  }
  fields(rules) {
    if (this._type !== "Object")
      throw new Error("fields() can only be called on an object type");
    const rule = this.cloneWithRules([]);
    return rule._fieldRules = rules, rule;
  }
  assetRequired() {
    const base = getBaseType(this._typeDef);
    let assetType;
    return base && ["image", "file"].includes(base.name) ? assetType = base.name === "image" ? "image" : "file" : assetType = "asset", this.cloneWithRules([{ flag: "assetRequired", constraint: { assetType } }]);
  }
  async validate(value, { __internal = {}, ...context }) {
    const { customValidationConcurrencyLimiter } = __internal, valueIsEmpty = value == null;
    if (valueIsEmpty && this._required === "optional")
      return EMPTY_ARRAY$k;
    const rules = (
      // Run only the _custom_ functions if the rule is not set to required or optional
      this._required === void 0 && valueIsEmpty ? this._rules.filter((curr) => curr.flag === "custom") : this._rules
    ), validators = this._type && typeValidators[this._type] || genericValidators;
    return (await Promise.all(
      rules.map(async (curr) => {
        if (curr.flag === void 0)
          throw new Error('Invalid rule, did not contain "flag"-property');
        const validator = validators[curr.flag];
        if (!validator) {
          const forType = this._type ? `type "${this._type}"` : "rule without declared type";
          throw new Error(`Validator for flag "${curr.flag}" not found for ${forType}`);
        }
        let specConstraint = "constraint" in curr ? curr.constraint : null;
        if (isFieldRef(specConstraint) && (specConstraint = get__default.default(context.parent, specConstraint.path)), curr.flag === "custom" && customValidationConcurrencyLimiter && !(specConstraint != null && specConstraint.bypassConcurrencyLimit)) {
          const customValidator = specConstraint;
          specConstraint = async (...args) => {
            await customValidationConcurrencyLimiter.ready();
            try {
              return await customValidator(...args);
            } finally {
              customValidationConcurrencyLimiter.release();
            }
          };
        }
        const message = isLocalizedMessages(this._message) ? localizeMessage(this._message, context.i18n) : this._message;
        try {
          const result = await validator(specConstraint, value, message, context);
          return convertToValidationMarker(result, this._level, context);
        } catch (err) {
          const errorMessage = `${pathToString(
            context.path
          )}: Exception occurred while validating value: ${err.message}`;
          return convertToValidationMarker({ message: errorMessage }, "error", context);
        }
      })
    )).flat();
  }
}, __publicField$b(_a, "FIELD_REF", FIELD_REF), __publicField$b(_a, "array", (def) => new _a(def).type("Array")), __publicField$b(_a, "object", (def) => new _a(def).type("Object")), __publicField$b(_a, "string", (def) => new _a(def).type("String")), __publicField$b(_a, "number", (def) => new _a(def).type("Number")), __publicField$b(_a, "boolean", (def) => new _a(def).type("Boolean")), __publicField$b(_a, "dateTime", (def) => new _a(def).type("Date")), __publicField$b(_a, "valueOfField", (path) => ({
  type: FIELD_REF,
  path
})), _a), memoizedWarnOnArraySlug = memoize__default.default(warnOnArraySlug);
function getDocumentIds(id2) {
  const isDraft2 = id2.indexOf("drafts.") === 0;
  return {
    published: isDraft2 ? id2.slice(7) : id2,
    draft: isDraft2 ? id2 : `drafts.${id2}`
  };
}
function serializePath(path) {
  return path.reduce((target, part, i) => {
    const isIndex = typeof part == "number", isKey = types.isKeyedObject(part), add = isIndex || isKey ? "[]" : `${i === 0 ? "" : "."}${part}`;
    return `${target}${add}`;
  }, "");
}
const defaultIsUnique = (slug2, context) => {
  const { getClient, document: document2, path, type } = context, schemaOptions = type == null ? void 0 : type.options;
  if (!document2)
    throw new Error("`document` was not provided in validation context.");
  if (!path)
    throw new Error("`path` was not provided in validation context.");
  const disableArrayWarning = (schemaOptions == null ? void 0 : schemaOptions.disableArrayWarning) || !1, { published, draft } = getDocumentIds(document2._id), docType = document2._type, atPath = serializePath(path.concat("current"));
  !disableArrayWarning && atPath.includes("[]") && context.environment === "studio" && memoizedWarnOnArraySlug(serializePath(path));
  const constraints = [
    "_type == $docType",
    "!(_id in [$draft, $published])",
    `${atPath} == $slug`
  ].join(" && ");
  return getClient({ apiVersion: "2023-11-13" }).fetch(
    `!defined(*[${constraints}][0]._id)`,
    {
      docType,
      draft,
      published,
      slug: slug2
    },
    { tag: "validation.slug-is-unique" }
  );
};
function warnOnArraySlug(serializedPath) {
  console.warn(
    [
      `Slug field at path ${serializedPath} is within an array and cannot be automatically checked for uniqueness`,
      'If you need to check for uniqueness, provide your own "isUnique" method',
      "To disable this message, set `disableArrayWarning: true` on the slug `options` field"
    ].join(`
`)
  );
}
const slugValidator = async (value, context) => {
  var _a2;
  if (!value)
    return !0;
  const { i18n } = context;
  if (typeof value != "object" || Array.isArray(value))
    return i18n.t("validation:slug.not-object");
  if (!types.isSlug(value) || value.current.trim().length === 0)
    return i18n.t("validation:slug.missing-current");
  const options = (_a2 = context == null ? void 0 : context.type) == null ? void 0 : _a2.options, isUnique = (options == null ? void 0 : options.isUnique) || defaultIsUnique, slugContext = {
    ...context,
    parent: context.parent,
    type: context.type,
    defaultIsUnique
  };
  return await isUnique(value.current, slugContext) ? !0 : i18n.t("validation:slug.not-unique", { slug: value.current });
}, ruleConstraintTypes = {
  array: !0,
  boolean: !0,
  date: !0,
  number: !0,
  object: !0,
  string: !0
}, isRuleConstraint = (typeString2) => typeString2 in ruleConstraintTypes;
function getTypeChain(type, visited = /* @__PURE__ */ new Set()) {
  return type ? visited.has(type) ? [] : (visited.add(type), [...type.type ? getTypeChain(type.type, visited) : [], type]) : [];
}
function baseRuleReducer(inputRule, type) {
  let baseRule = inputRule;
  isRuleConstraint(type.jsonType) && (baseRule = baseRule.type(type.jsonType));
  const typeOptionsList = (
    // if type.options is truthy
    (type == null ? void 0 : type.options) && // and type.options is an object (non-null from the previous)
    typeof type.options == "object" && // and if `list` is in options
    "list" in type.options && // then finally access the list
    type.options.list
  );
  return Array.isArray(typeOptionsList) && (baseRule = baseRule.valid(
    typeOptionsList.map((option) => extractValueFromListOption(option, type))
  )), type.name === "datetime" || type.name === "date" ? baseRule.type("Date") : type.name === "url" ? baseRule.uri() : type.name === "slug" ? baseRule.custom(slugValidator, { bypassConcurrencyLimit: !0 }) : type.name === "reference" ? baseRule.reference() : type.name === "email" ? baseRule.email() : baseRule;
}
function hasValueField(typeDef) {
  return typeDef ? !("fields" in typeDef) && typeDef.type ? hasValueField(typeDef.type) : !("fields" in typeDef) || !Array.isArray(typeDef.fields) ? !1 : typeDef.fields.some((field) => field.name === "value") : !1;
}
function extractValueFromListOption(option, typeDef) {
  return typeDef.jsonType === "object" && hasValueField(typeDef) || option.value === void 0 ? option : option.value;
}
function normalizeValidationRules(typeDef) {
  if (!typeDef)
    return [];
  const validation2 = typeDef.validation;
  if (Array.isArray(validation2))
    return validation2.flatMap(
      (i) => normalizeValidationRules({
        ...typeDef,
        validation: i
      })
    );
  if (validation2 && typeof validation2 == "object")
    return [validation2];
  const baseRule = (
    // using an object + Object.values to de-dupe the type chain by type name
    Object.values(
      getTypeChain(typeDef).reduce((acc, type) => (acc[type.name] = type, acc), {})
    ).reduce(baseRuleReducer, new Rule(typeDef))
  );
  return validation2 ? normalizeValidationRules({
    ...typeDef,
    validation: validation2(baseRule)
  }) : [baseRule];
}
function inferFromSchemaType(typeDef) {
  return traverse(typeDef, /* @__PURE__ */ new Set()), typeDef;
}
function traverse(typeDef, visited) {
  if (!visited.has(typeDef)) {
    if (visited.add(typeDef), typeDef.validation = normalizeValidationRules(typeDef), "fields" in typeDef)
      for (const field of typeDef.fields)
        traverse(field.type, visited);
    if ("of" in typeDef)
      for (const candidate of typeDef.of)
        traverse(candidate, visited);
    if (typeDef.annotations)
      for (const annotation of typeDef.annotations)
        traverse(annotation, visited);
  }
}
function inferFromSchema(schema2) {
  return schema2.getTypeNames().forEach((typeName) => {
    const schemaType = schema2.get(typeName);
    schemaType && inferFromSchemaType(schemaType);
  }), schema2;
}
const shouldEscape = typeof window > "u" || typeof document > "u", fallbackLocales = [defaultLocale], getFallbackLocaleSource = memoize__default.default(
  function() {
    const i18n = getFallbackI18nInstance();
    return i18n.init(), {
      currentLocale: defaultLocale,
      locales: fallbackLocales,
      loadNamespaces: i18n.loadNamespaces,
      t: i18n.t
    };
  }
);
function getFallbackI18nInstance() {
  var _a2;
  const staticResources = { [defaultLocale.id]: {} }, staticBundles = ((_a2 = usEnglishLocale.bundles) == null ? void 0 : _a2.filter(isStaticResourceBundle)) || [], namespaces = /* @__PURE__ */ new Set();
  for (const bundle of staticBundles)
    staticResources[defaultLocale.id][bundle.namespace] = bundle.resources, namespaces.add(bundle.namespace);
  return i18next.createInstance({
    ns: Array.from(namespaces),
    defaultNS: studioLocaleNamespace,
    initImmediate: !0,
    partialBundledLanguages: !0,
    fallbackLng: defaultLocale.id,
    lng: defaultLocale.id,
    supportedLngs: [defaultLocale.id],
    debug: !1,
    load: "currentOnly",
    resources: staticResources,
    interpolation: {
      // If we're in a browser, assume this is running inside of the studio, eg a React app,
      // and that values returned will be escaped by the framework (eg React) automatically.
      escapeValue: shouldEscape
    }
  });
}
const BUFFER_TIME = 250, MAX_BUFFER_SIZE = 100, MAX_REQUEST_CONCURRENCY = 1;
function createBatchedGetDocumentExists(client2) {
  const id$ = new rxjs.Subject(), limiter = new concurrencyLimiter.ConcurrencyLimiter(MAX_REQUEST_CONCURRENCY), existence$ = id$.pipe(
    rxjs.bufferTime(BUFFER_TIME, null, MAX_BUFFER_SIZE),
    rxjs.map((ids) => Array.from(new Set(ids))),
    rxjs.mergeMap(
      (ids) => rxjs.from(limiter.ready()).pipe(
        rxjs.switchMap(
          () => client2.observable.request({
            uri: client2.getDataUrl("doc", ids.join(",")),
            json: !0,
            query: { excludeContent: "true" },
            tag: "documents-availability"
          }).pipe(rxjs.map((availability) => ({ availability, ids })))
        ),
        rxjs.finalize(limiter.release)
      )
    ),
    rxjs.mergeMap(
      ({ availability, ids }) => ids.map((id2) => {
        const omittedIds = availability.omitted.reduce(
          (acc, next) => (acc[next.id] = next.reason, acc),
          {}
        );
        return omittedIds[id2] ? omittedIds[id2] === "existence" ? { id: id2, exists: !1 } : { id: id2, exists: !0 } : { id: id2, exists: !0 };
      })
    ),
    rxjs.share()
  );
  return async function(options) {
    const result = rxjs.firstValueFrom(existence$.pipe(rxjs.filter(({ id: id2 }) => id2 === options.id)));
    id$.next(options.id);
    const { exists } = await result;
    return exists;
  };
}
const requestIdleCallbackShim$1 = function(callback, options) {
  const start = Date.now();
  return window.setTimeout(() => {
    callback({
      didTimeout: !1,
      timeRemaining() {
        return Math.max(0, Date.now() - start);
      }
    });
  }, 0);
}, cancelIdleCallbackShim$1 = function(handle) {
  return window.clearTimeout(handle);
}, win = typeof window > "u" ? void 0 : window, requestIdleCallback$1 = (win == null ? void 0 : win.requestIdleCallback) || requestIdleCallbackShim$1, cancelIdleCallback$1 = (win == null ? void 0 : win.cancelIdleCallback) || cancelIdleCallbackShim$1, unknownFieldsValidator = (type) => (value) => {
  var _a2;
  if (typeof value != "object" || !value) return !0;
  const fieldNames = new Set((_a2 = type.fields) == null ? void 0 : _a2.map((field) => field.name));
  return Object.keys(value).filter((key) => !key.startsWith("_")).filter((key) => !fieldNames.has(key)).map((unknownField) => ({
    message: `Field '${unknownField}' does not exist on type '${type.name}'`,
    path: [unknownField]
  }));
}, MAX_FETCH_CONCURRENCY = 10, limitConcurrency = client$1.createClientConcurrencyLimiter(MAX_FETCH_CONCURRENCY), isRecord$2 = (maybeRecord) => typeof maybeRecord == "object" && maybeRecord !== null && !Array.isArray(maybeRecord), isNonNullable$1 = (value) => value != null;
function resolveTypeForArrayItem(item, candidates) {
  if (candidates.length === 1) return candidates[0];
  const itemType = types.isTypedObject(item) && item._type, primitive = item == null || !itemType && typeString(item).toLowerCase();
  return primitive && primitive !== "object" ? candidates.find((candidate) => candidate.jsonType === primitive) : candidates.find((candidate) => {
    var _a2;
    return ((_a2 = candidate.type) == null ? void 0 : _a2.name) === itemType;
  }) || candidates.find((candidate) => candidate.name === itemType) || candidates.find((candidate) => candidate.name === "object" && primitive === "object");
}
function validateDocument({
  document: document2,
  workspace,
  environment = "studio",
  ...options
}) {
  const getClient = options.getClient || workspace.getClient;
  return rxjs.lastValueFrom(
    validateDocumentObservable({
      document: document2,
      getClient: (clientOptions) => limitConcurrency(getClient(clientOptions)),
      i18n: workspace.i18n,
      schema: workspace.schema,
      getDocumentExists: options.getDocumentExists || createBatchedGetDocumentExists(getClient({ apiVersion: "v2021-03-25" })),
      environment
    })
  );
}
const customValidationConcurrencyLimiters = /* @__PURE__ */ new WeakMap();
function validateDocumentObservable({
  document: document2,
  getClient,
  i18n = getFallbackLocaleSource(),
  schema: schema2,
  getDocumentExists,
  environment,
  maxCustomValidationConcurrency
}) {
  if (typeof (document2 == null ? void 0 : document2._type) != "string")
    throw new Error("Tried to validated a value without a '_type'");
  const documentType = schema2.get(document2._type);
  if (!documentType)
    return environment === "studio" ? (console.warn(
      'Schema type for object type "%s" not found, skipping validation',
      document2._type
    ), rxjs.of([])) : rxjs.of([
      {
        level: "warning",
        message: `Could not find schema type for type '${document2._type}', skipping validation`,
        path: []
      }
    ]);
  let customValidationConcurrencyLimiter = customValidationConcurrencyLimiters.get(schema2);
  !customValidationConcurrencyLimiter && maxCustomValidationConcurrency && (customValidationConcurrencyLimiter = new concurrencyLimiter.ConcurrencyLimiter(maxCustomValidationConcurrency), customValidationConcurrencyLimiters.set(schema2, customValidationConcurrencyLimiter));
  const validationOptions = {
    getClient,
    schema: schema2,
    parent: void 0,
    value: document2,
    path: [],
    document: document2,
    type: documentType,
    i18n,
    getDocumentExists,
    environment,
    customValidationConcurrencyLimiter
  };
  return rxjs.from(i18n.loadNamespaces(["validation"])).pipe(
    operators.switchMap(() => validateItemObservable(validationOptions)),
    operators.catchError((err) => {
      console.error(err);
      const message = (err == null ? void 0 : err.message) || "Unknown error";
      return rxjs.of([{
        level: "error",
        message,
        item: { message },
        path: []
      }]);
    })
  );
}
function validateItemObservable({
  value,
  type,
  path = [],
  parent,
  customValidationConcurrencyLimiter,
  environment,
  ...restOfContext
}) {
  const addUnknownFieldsValidator = (rule) => (
    // if the schema type is an object type
    (type == null ? void 0 : type.jsonType) === "object" && // and if somewhere in it's type chain, it inherits from object or document
    getTypeChain(type).find((t2) => ["object", "document", "file", "image"].includes(t2.name)) && // and the environment is not the studio
    environment !== "studio" ? rule.custom(unknownFieldsValidator(type), { bypassConcurrencyLimit: !0 }).warning() : rule
  ), rules = normalizeValidationRules(type), selfChecks = rules.map(addUnknownFieldsValidator).map(
    (rule) => rxjs.defer(
      () => rule.validate(value, {
        ...restOfContext,
        environment,
        parent,
        path,
        type,
        __internal: { customValidationConcurrencyLimiter }
      })
    )
  );
  let nestedChecks = [];
  const selfIsRequired = rules.some((rule) => rule.isRequired());
  if (
    // run nested validation for objects
    (type == null ? void 0 : type.jsonType) === "object" && // if the value is truthy
    (value || // or
    // (the value is null or undefined) and the top-level value is required
    value == null && selfIsRequired)
  ) {
    const fieldTypes = type.fields.reduce((acc, field) => (acc[field.name] = field.type, acc), {});
    nestedChecks = nestedChecks.concat(
      rules.map((rule) => rule._fieldRules).filter(isNonNullable$1).flatMap((fieldResults) => Object.entries(fieldResults)).flatMap(([name, validation2]) => {
        const fieldType = fieldTypes[name];
        return normalizeValidationRules({ ...fieldType, validation: validation2 }).map(addUnknownFieldsValidator).map((subRule) => {
          const nestedValue = isRecord$2(value) ? value[name] : void 0;
          return rxjs.defer(
            () => subRule.validate(nestedValue, {
              ...restOfContext,
              parent: value,
              path: path.concat(name),
              type: fieldType,
              environment,
              __internal: { customValidationConcurrencyLimiter }
            })
          );
        });
      })
    ), nestedChecks = nestedChecks.concat(
      type.fields.map(
        (field) => validateItemObservable({
          ...restOfContext,
          parent: value,
          value: isRecord$2(value) ? value[field.name] : void 0,
          path: path.concat(field.name),
          type: field.type,
          environment,
          customValidationConcurrencyLimiter
        })
      )
    );
  }
  return (type == null ? void 0 : type.jsonType) === "array" && Array.isArray(value) && (nestedChecks = nestedChecks.concat(
    value.map(
      (item, index) => validateItemObservable({
        ...restOfContext,
        parent: value,
        value: item,
        path: path.concat(types.isKeyedObject(item) ? { _key: item._key } : index),
        type: resolveTypeForArrayItem(item, type.of),
        environment,
        customValidationConcurrencyLimiter
      })
    )
  )), rxjs.defer(() => rxjs.merge([...selfChecks, ...nestedChecks])).pipe(
    operators.mergeMap((validateNode) => rxjs.concat(idle(), validateNode), 40),
    operators.mergeAll(),
    operators.toArray(),
    operators.map(flatten__default.default),
    operators.map((results) => rules.some((rule) => rule._fieldRules) ? uniqBy__default.default(results, (rule) => JSON.stringify(rule)) : results)
  );
}
function idle(timeout) {
  return new rxjs.Observable((observer) => {
    const handle = requestIdleCallback$1(
      () => {
        observer.complete();
      },
      void 0
    );
    return () => cancelIdleCallback$1(handle);
  });
}
var assetSourceData = {
  name: "sanity.assetSourceData",
  title: "Asset Source Data",
  type: "object",
  fields: [
    {
      name: "name",
      title: "Source name",
      description: "A canonical name for the source this asset is originating from",
      type: "string"
    },
    {
      name: "id",
      title: "Asset Source ID",
      description: "The unique ID for the asset within the originating source so you can programatically find back to it",
      type: "string"
    },
    {
      name: "url",
      title: "Asset information URL",
      description: "A URL to find more information about this asset in the originating source",
      type: "string"
    }
  ]
}, fileAsset = {
  name: "sanity.fileAsset",
  title: "File",
  type: "document",
  fieldsets: [
    {
      name: "system",
      title: "System fields",
      description: "These fields are managed by the system and not editable"
    }
  ],
  fields: [
    {
      name: "originalFilename",
      type: "string",
      title: "Original file name",
      readOnly: !0
    },
    {
      name: "label",
      type: "string",
      title: "Label"
    },
    {
      name: "title",
      type: "string",
      title: "Title"
    },
    {
      name: "description",
      type: "string",
      title: "Description"
    },
    {
      name: "altText",
      type: "string",
      title: "Alternative text"
    },
    {
      name: "sha1hash",
      type: "string",
      title: "SHA1 hash",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "extension",
      type: "string",
      title: "File extension",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "mimeType",
      type: "string",
      title: "Mime type",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "size",
      type: "number",
      title: "File size in bytes",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "assetId",
      type: "string",
      title: "Asset ID",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "uploadId",
      type: "string",
      readOnly: !0,
      hidden: !0,
      fieldset: "system"
    },
    {
      name: "path",
      type: "string",
      title: "Path",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "url",
      type: "string",
      title: "Url",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "source",
      type: "sanity.assetSourceData",
      title: "Source",
      readOnly: !0,
      fieldset: "system"
    }
  ],
  preview: {
    select: {
      title: "originalFilename",
      path: "path",
      mimeType: "mimeType",
      size: "size"
    },
    prepare(doc) {
      return {
        title: doc.title || doc.path.split("/").slice(-1)[0],
        subtitle: `${doc.mimeType} (${(doc.size / 1024 / 1024).toFixed(2)} MB)`
      };
    }
  },
  orderings: [
    {
      title: "File size",
      name: "fileSizeDesc",
      by: [{ field: "size", direction: "desc" }]
    }
  ]
}, geopoint = {
  title: "Geographical Point",
  name: "geopoint",
  type: "object",
  fields: [
    {
      name: "lat",
      type: "number",
      title: "Latitude"
    },
    {
      name: "lng",
      type: "number",
      title: "Longitude"
    },
    {
      name: "alt",
      type: "number",
      title: "Altitude"
    }
  ]
}, imageAsset = {
  name: "sanity.imageAsset",
  title: "Image",
  type: "document",
  fieldsets: [
    {
      name: "system",
      title: "System fields",
      description: "These fields are managed by the system and not editable"
    }
  ],
  fields: [
    {
      name: "originalFilename",
      type: "string",
      title: "Original file name",
      readOnly: !0
    },
    {
      name: "label",
      type: "string",
      title: "Label"
    },
    {
      name: "title",
      type: "string",
      title: "Title"
    },
    {
      name: "description",
      type: "string",
      title: "Description"
    },
    {
      name: "altText",
      type: "string",
      title: "Alternative text"
    },
    {
      name: "sha1hash",
      type: "string",
      title: "SHA1 hash",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "extension",
      type: "string",
      readOnly: !0,
      title: "File extension",
      fieldset: "system"
    },
    {
      name: "mimeType",
      type: "string",
      readOnly: !0,
      title: "Mime type",
      fieldset: "system"
    },
    {
      name: "size",
      type: "number",
      title: "File size in bytes",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "assetId",
      type: "string",
      title: "Asset ID",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "uploadId",
      type: "string",
      readOnly: !0,
      hidden: !0,
      fieldset: "system"
    },
    {
      name: "path",
      type: "string",
      title: "Path",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "url",
      type: "string",
      title: "Url",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "metadata",
      type: "sanity.imageMetadata",
      title: "Metadata"
    },
    {
      name: "source",
      type: "sanity.assetSourceData",
      title: "Source",
      readOnly: !0,
      fieldset: "system"
    }
  ],
  preview: {
    select: {
      id: "_id",
      title: "originalFilename",
      mimeType: "mimeType",
      size: "size"
    },
    prepare(doc) {
      return {
        title: doc.title || typeof doc.path == "string" && doc.path.split("/").slice(-1)[0],
        media: { asset: { _ref: doc.id } },
        subtitle: `${doc.mimeType} (${(Number(doc.size) / 1024 / 1024).toFixed(2)} MB)`
      };
    }
  },
  orderings: [
    {
      title: "File size",
      name: "fileSizeDesc",
      by: [{ field: "size", direction: "desc" }]
    }
  ]
}, imageCrop = {
  name: "sanity.imageCrop",
  title: "Image crop",
  type: "object",
  fields: [
    {
      name: "top",
      type: "number"
    },
    {
      name: "bottom",
      type: "number"
    },
    {
      name: "left",
      type: "number"
    },
    {
      name: "right",
      type: "number"
    }
  ]
}, imageDimensions = {
  name: "sanity.imageDimensions",
  type: "object",
  title: "Image dimensions",
  fields: [
    { name: "height", type: "number", title: "Height", readOnly: !0 },
    { name: "width", type: "number", title: "Width", readOnly: !0 },
    { name: "aspectRatio", type: "number", title: "Aspect ratio", readOnly: !0 }
  ]
}, imageHotspot = {
  name: "sanity.imageHotspot",
  title: "Image hotspot",
  type: "object",
  fields: [
    {
      name: "x",
      type: "number"
    },
    {
      name: "y",
      type: "number"
    },
    {
      name: "height",
      type: "number"
    },
    {
      name: "width",
      type: "number"
    }
  ]
}, imageMetadata = {
  name: "sanity.imageMetadata",
  title: "Image metadata",
  type: "object",
  fieldsets: [
    {
      name: "extra",
      title: "Extra metadata\u2026",
      options: {
        collapsable: !0
      }
    }
  ],
  fields: [
    {
      name: "location",
      type: "geopoint"
    },
    {
      name: "dimensions",
      title: "Dimensions",
      type: "sanity.imageDimensions",
      fieldset: "extra"
    },
    {
      name: "palette",
      type: "sanity.imagePalette",
      title: "Palette",
      fieldset: "extra"
    },
    {
      name: "lqip",
      title: "LQIP (Low-Quality Image Placeholder)",
      type: "string",
      readOnly: !0
    },
    {
      name: "blurHash",
      title: "BlurHash",
      type: "string",
      readOnly: !0
    },
    {
      name: "hasAlpha",
      title: "Has alpha channel",
      type: "boolean",
      readOnly: !0
    },
    {
      name: "isOpaque",
      title: "Is opaque",
      type: "boolean",
      readOnly: !0
    }
  ]
}, imagePalette = {
  name: "sanity.imagePalette",
  title: "Image palette",
  type: "object",
  fields: [
    { name: "darkMuted", type: "sanity.imagePaletteSwatch", title: "Dark Muted" },
    { name: "lightVibrant", type: "sanity.imagePaletteSwatch", title: "Light Vibrant" },
    { name: "darkVibrant", type: "sanity.imagePaletteSwatch", title: "Dark Vibrant" },
    { name: "vibrant", type: "sanity.imagePaletteSwatch", title: "Vibrant" },
    { name: "dominant", type: "sanity.imagePaletteSwatch", title: "Dominant" },
    { name: "lightMuted", type: "sanity.imagePaletteSwatch", title: "Light Muted" },
    { name: "muted", type: "sanity.imagePaletteSwatch", title: "Muted" }
  ]
}, imagePaletteSwatch = {
  name: "sanity.imagePaletteSwatch",
  title: "Image palette swatch",
  type: "object",
  fields: [
    { name: "background", type: "string", title: "Background", readOnly: !0 },
    { name: "foreground", type: "string", title: "Foreground", readOnly: !0 },
    { name: "population", type: "number", title: "Population", readOnly: !0 },
    { name: "title", type: "string", title: "String", readOnly: !0 }
  ]
}, slug = {
  title: "Slug",
  name: "slug",
  type: "object",
  fields: [
    {
      name: "current",
      title: "Current slug",
      type: "string",
      validation: (Rule2) => Rule2.required()
    },
    {
      // The source field is deprecated/unused, but leaving it included and hidden
      // to prevent rendering "Unknown field" warnings on legacy data
      name: "source",
      title: "Source field",
      type: "string",
      hidden: !0
    }
  ]
};
const isError$1 = (problem) => problem.severity === "error", builtinTypes = [
  assetSourceData,
  slug,
  geopoint,
  // legacyRichDate,
  imageAsset,
  fileAsset,
  imageCrop,
  imageHotspot,
  imageMetadata,
  imageDimensions,
  imagePalette,
  imagePaletteSwatch
];
function createSchema(schemaDef) {
  const validated = _internal.validateSchema(schemaDef.types).getTypes(), validation2 = _internal.groupProblems(validated), hasErrors = validation2.some((group2) => group2.problems.some(isError$1)), compiled = schema$1.Schema.compile({
    name: schemaDef.name,
    types: hasErrors ? [] : [...schemaDef.types, ...builtinTypes].filter(Boolean)
  });
  return compiled._validation = validation2, inferFromSchema(compiled);
}
function getSchemaTypeTitle(type) {
  return typeof type.title == "string" ? type.title : type.type ? getSchemaTypeTitle(type.type) : type.name || type.jsonType;
}
const PRESENCE_MARGINS = [0, 0, 1, 0];
function onDragEnter(event) {
  return event.stopPropagation();
}
function onDrop(event) {
  return event.stopPropagation();
}
function EditPortal(props2) {
  const {
    children,
    header,
    id: id2,
    legacy_referenceElement: referenceElement,
    onClose,
    type,
    width,
    autofocus
  } = props2, [documentScrollElement, setDocumentScrollElement] = React.useState(null), containerElement = React.useRef(null), contents = /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { margins: PRESENCE_MARGINS, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ref: containerElement, children }) });
  return type === "dialog" ? /* @__PURE__ */ jsxRuntime.jsx(
    VirtualizerScrollInstanceProvider,
    {
      scrollElement: documentScrollElement,
      containerElement,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Dialog,
        {
          header,
          id: id2 || "",
          onClickOutside: onClose,
          onClose,
          onDragEnter,
          onDrop,
          width,
          contentRef: setDocumentScrollElement,
          __unstable_autoFocus: autofocus,
          children: contents
        }
      )
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    PopoverDialog,
    {
      header,
      onClose,
      referenceElement,
      width,
      containerRef: setDocumentScrollElement,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        VirtualizerScrollInstanceProvider,
        {
          scrollElement: documentScrollElement,
          containerElement,
          children: contents
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS$8 = {
  portal: !0,
  tone: "default",
  placement: "left",
  constrainSize: !0
}, InsertMenu$1 = React.memo(function(props2) {
  const { types: types2, onInsert } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      InsertMenuGroup,
      {
        pos: "before",
        types: types2,
        onInsert,
        text: t2("inputs.array.action.add-before"),
        icon: icons.InsertAboveIcon
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      InsertMenuGroup,
      {
        pos: "after",
        types: types2,
        onInsert,
        text: t2("inputs.array.action.add-after"),
        icon: icons.InsertBelowIcon
      }
    )
  ] });
});
function InsertMenuGroup(props2) {
  const { types: types2, onInsert, pos, text, icon } = props2;
  return (types2 == null ? void 0 : types2.length) === 1 ? /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.MenuItem, { text, icon, onClick: () => onInsert(pos, types2[0]) }, pos) : /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.MenuGroup, { text, popover: MENU_POPOVER_PROPS$8, children: types2 == null ? void 0 : types2.map((insertableType) => /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuItem,
    {
      icon: insertableType.icon,
      text: insertableType.title,
      onClick: () => onInsert(pos, insertableType)
    },
    insertableType.name
  )) }, pos);
}
const PreviewCard$1 = styledComponents.styled(ui.Card)`
  border-top-right-radius: inherit;
  border-top-left-radius: inherit;
  height: 100%;
  position: relative;

  @media (hover: hover) {
    &:hover {
      filter: brightness(95%);
    }
  }

  &:focus:focus-visible {
    box-shadow: 0 0 0 2px var(--card-focus-ring-color);
  }
`;
function getTone$2({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$7 = { portal: !0, tone: "default" };
function GridItem(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const {
    schemaType,
    parentSchemaType,
    path,
    readOnly,
    onRemove,
    value,
    open,
    onInsert,
    onFocus,
    onOpen,
    onClose,
    changed,
    focused,
    children,
    inputProps: { renderPreview }
  } = props2, { t: t2 } = useTranslation(), sortable2 = ((_a2 = parentSchemaType.options) == null ? void 0 : _a2.sortable) !== !1, insertableTypes = parentSchemaType.of, previewCardRef = React.useRef(null);
  useScrollIntoViewOnFocusWithin(previewCardRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    !hadFocus && hasFocus && previewCardRef.current && ((_a22 = previewCardRef.current) == null || _a22.focus());
  });
  const resolvingInitialValue = value._resolvingInitialValue, handleDuplicate = React.useCallback(() => {
    onInsert({
      items: [{ ...value, _key: randomKey() }],
      position: "after"
    });
  }, [onInsert, value]), handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({
        items: [createProtoArrayValue(insertType)],
        position: pos
      });
    },
    [onInsert]
  ), childPresence = useChildPresence(path, !0), presence = React.useMemo(() => childPresence.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence: childPresence, maxAvatars: 1 }), [childPresence]), childValidation = useChildValidation(path, !0), validation2 = React.useMemo(() => childValidation.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: childValidation, __unstable_showSummary: !0 }) }), [childValidation]), hasErrors = childValidation.some((v) => v.level === "error"), hasWarnings = childValidation.some((v) => v.level === "warning"), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
        id: `${props2.inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("inputs.array.action.remove"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: onRemove
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("inputs.array.action.duplicate"),
              icon: icons.CopyIcon,
              onClick: handleDuplicate
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })
        ] }),
        popover: MENU_POPOVER_PROPS$7
      }
    ),
    [handleDuplicate, handleInsert, onRemove, insertableTypes, props2.inputId, readOnly, t2]
  ), tone = getTone$2({ readOnly, hasErrors, hasWarnings }), item = /* @__PURE__ */ jsxRuntime.jsx(
    CellLayout,
    {
      menu,
      presence,
      validation: validation2,
      tone,
      radius: 2,
      border: !0,
      dragHandle: sortable2,
      selected: open,
      readOnly,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        PreviewCard$1,
        {
          tone: "inherit",
          overflow: "auto",
          forwardedAs: "button",
          "data-ui": "PreviewCard",
          "data-as": "button",
          type: "button",
          flex: 1,
          tabIndex: 0,
          disabled: resolvingInitialValue,
          onClick: onOpen,
          ref: previewCardRef,
          onFocus,
          __unstable_focusRing: !0,
          children: [
            renderPreview({
              schemaType,
              value,
              layout: "media",
              withBorder: !1,
              withShadow: !1
            }),
            resolvingInitialValue && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0 })
          ]
        }
      )
    }
  ), itemTypeTitle = getSchemaTypeTitle(schemaType);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: item }),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      EditPortal,
      {
        header: readOnly ? t2("inputs.array.action.view", { itemTypeTitle }) : t2("inputs.array.action.edit", { itemTypeTitle }),
        type: ((_c = (_b = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _b.modal) == null ? void 0 : _c.type) || "dialog",
        width: (_f = (_e = (_d = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _d.modal) == null ? void 0 : _e.width) != null ? _f : 1,
        id: value._key,
        onClose,
        autofocus: focused,
        legacy_referenceElement: previewCardRef.current,
        children
      }
    )
  ] });
}
const EMPTY$2 = [];
function GridArrayInput(props2) {
  var _a2;
  const {
    arrayFunctions: ArrayFunctions = ArrayOfObjectsFunctions,
    elementProps,
    members,
    onChange,
    onInsert,
    onItemMove,
    onUpload,
    readOnly,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderPreview,
    resolveUploader: resolveUploader2,
    schemaType,
    value = EMPTY$2
  } = props2, { t: t2 } = useTranslation(), handlePrepend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "before", referenceItem: 0 });
    },
    [onInsert]
  ), handleAppend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "after", referenceItem: -1 });
    },
    [onInsert]
  ), sortable2 = ((_a2 = schemaType.options) == null ? void 0 : _a2.sortable) !== !1, renderItem2 = React.useCallback((itemProps) => /* @__PURE__ */ jsxRuntime.jsx(GridItem, { ...itemProps }), []), memberKeys = React.useMemo(() => members.map((member) => member.key), [members]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      UploadTargetCard,
      {
        types: schemaType.of,
        resolveUploader: resolveUploader2,
        onUpload,
        ...elementProps,
        tabIndex: 0,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "data-ui": "ArrayInput__content", space: 2, children: [
          (members == null ? void 0 : members.length) === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: schemaType.placeholder || /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.array.no-items-label") }) }) }),
          (members == null ? void 0 : members.length) > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
            List,
            {
              columns: [2, 3, 4],
              gap: 3,
              padding: 1,
              margin: 1,
              items: memberKeys,
              onItemMove,
              sortable: sortable2,
              children: members.map((member) => /* @__PURE__ */ jsxRuntime.jsxs(Item, { sortable: sortable2, id: member.key, flex: 1, children: [
                member.kind === "item" && /* @__PURE__ */ jsxRuntime.jsx(
                  ArrayOfObjectsItem,
                  {
                    member,
                    renderAnnotation,
                    renderBlock: renderBlock2,
                    renderInlineBlock,
                    renderItem: renderItem2,
                    renderField,
                    renderInput,
                    renderPreview
                  }
                ),
                member.kind === "error" && /* @__PURE__ */ jsxRuntime.jsx(ErrorItem$1, { sortable: sortable2, member, readOnly })
              ] }, member.key))
            }
          ) })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      ArrayFunctions,
      {
        onChange,
        onItemAppend: handleAppend,
        onItemPrepend: handlePrepend,
        onValueCreate: createProtoArrayValue,
        readOnly,
        schemaType,
        value
      }
    )
  ] });
}
const Root$m = styledComponents.styled(ui.Card)`
  position: relative;
  border: 1px solid transparent;
  transition: border-color 250ms;

  .${MOVING_ITEM_CLASS_NAME} & {
    border-color: var(--card-shadow-umbra-color);
    box-shadow:
      0 0 0 0,
      0 8px 17px 2px var(--card-shadow-umbra-color),
      0 3px 14px 2px var(--card-shadow-penumbra-color),
      0 5px 5px -3px var(--card-shadow-ambient-color);
  }

  &:hover {
    border-color: var(--card-shadow-umbra-color);
  }

  &[aria-selected='true'] {
    border-color: var(--card-focus-ring-color);
  }
`;
function RowLayout(props2) {
  const {
    validation: validation2,
    selected,
    tone,
    presence,
    focused,
    children,
    dragHandle,
    menu,
    footer,
    readOnly
  } = props2, elementRef = React.useRef(null);
  return useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = elementRef.current) == null || _a2.focus());
  }), /* @__PURE__ */ jsxRuntime.jsx(
    Root$m,
    {
      ref: elementRef,
      selected,
      "aria-selected": selected,
      radius: 1,
      padding: 1,
      tone,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
          dragHandle && /* @__PURE__ */ jsxRuntime.jsx(DragHandle, { paddingY: 3, readOnly }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children }),
          (presence || validation2 || menu) && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: "none", gap: 2, style: { lineHeight: 0 }, children: [
            presence && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: presence }),
            validation2 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: validation2 }),
            menu
          ] })
        ] }),
        footer
      ] })
    }
  );
}
const PopoverCard = styledComponents.styled(ui.Card)`
  max-width: ${({ theme: theme2 }) => theme2.sanity.container[1]}px;
`;
function IncompatibleItemType(props2) {
  const { value, onFocus, vertical, ...rest } = props2, [showDetails, setShowDetails] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), { t: t2 } = useTranslation();
  ui.useClickOutside(() => setShowDetails(!1), [popoverRef]);
  const handleKeyDown = React.useCallback((e) => {
    (e.key === "Escape" || e.key === "Tab") && setShowDetails(!1);
  }, []), handleShowDetails = React.useCallback(() => {
    setShowDetails((v) => !v);
  }, []), typeName = content.resolveTypeName(value);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      open: showDetails,
      ref: setPopoverRef,
      onKeyDown: handleKeyDown,
      portal: !0,
      constrainSize: !0,
      tone: "default",
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverCard, { margin: 1, padding: 3, onKeyDown: handleKeyDown, tabIndex: 0, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: t2("inputs.array.error.type-is-incompatible-title") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.array.error.current-schema-not-declare-description",
            values: { typeName }
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(icons.BulbOutlineIcon, {}),
          " ",
          t2("inputs.array.error.can-delete-but-no-edit-description")
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.array.error.json-representation-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, overflow: "auto", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, as: "pre", language: "json", children: JSON.stringify(value, null, 2) }) })
        ] })
      ] }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: "button",
          type: "button",
          radius: 2,
          tone: "inherit",
          paddingX: 2,
          paddingY: 3,
          flex: 1,
          onFocus,
          onClick: handleShowDetails,
          onKeyDown: handleKeyDown,
          __unstable_focusRing: !0,
          ...rest,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(
              Translate,
              {
                t: t2,
                i18nKey: "inputs.array.error.type-is-incompatible-prompt",
                values: { typeName }
              }
            ) }) })
          ] })
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS$6 = { portal: !0, tone: "default" };
function ErrorItem(props2) {
  const { member, sortable: sortable2, onRemove, readOnly } = props2, id2 = React.useId(), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      dragHandle: sortable2,
      readOnly: !!readOnly,
      tone: "caution",
      menu: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.MenuButton,
        {
          button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
          id: `${id2}-menuButton`,
          menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("inputs.array.action.remove-invalid-item"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: onRemove
            }
          ) }),
          popover: MENU_POPOVER_PROPS$6
        }
      ),
      children: member.error.type === "INVALID_ITEM_TYPE" ? /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType, { value: member.error.value }) : /* @__PURE__ */ jsxRuntime.jsx("div", { children: t2("inputs.array.error.unexpected-error", { error: member.error.type }) })
    }
  ) });
}
function useMemoCompare(next, compare2) {
  const previousRef = React.useRef(next), previous = previousRef.current, isEqual2 = compare2(previous, next);
  return React.useEffect(() => {
    isEqual2 || (previousRef.current = next);
  }), isEqual2 ? previous : next;
}
function useVirtualizerScrollInstance() {
  const ref = React.useContext(_singletons.VirtualizerScrollInstanceContext);
  if (!ref)
    throw new Error("VirtualizerScrollInstance: missing context value");
  return ref;
}
const EMPTY$1 = [];
function ListArrayInput(props2) {
  var _a2;
  const {
    arrayFunctions: ArrayFunctions = ArrayOfObjectsFunctions,
    elementProps,
    members,
    onChange,
    onInsert,
    onItemMove,
    onUpload,
    focusPath,
    readOnly,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    resolveUploader: resolveUploader2,
    schemaType,
    value = EMPTY$1
  } = props2, { t: t2 } = useTranslation(), [activeDragItemIndex, setActiveDragItemIndex] = React.useState(null), { space } = ui.useTheme().sanity, handlePrepend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "before", referenceItem: 0 });
    },
    [onInsert]
  ), handleAppend = React.useCallback(
    (item) => {
      onInsert({ items: [item], position: "after", referenceItem: -1 });
    },
    [onInsert]
  ), memberKeys = useMemoCompare(
    React.useMemo(() => members.map((member) => member.key), [members]),
    shallowEquals__default.default
  ), { scrollElement, containerElement } = useVirtualizerScrollInstance(), parentRef = React.useRef(null), focusPathKey = React.useMemo(() => types.isKeySegment(focusPath[0]) ? focusPath[0]._key : focusPath[0], [focusPath]), rangeExtractor = React.useCallback(
    (range2) => {
      const newRange = { ...range2 };
      if (activeDragItemIndex !== null && (newRange.startIndex = Math.min(range2.startIndex, activeDragItemIndex), newRange.endIndex = Math.max(range2.endIndex, activeDragItemIndex)), focusPathKey) {
        const index = memberKeys.findIndex((key) => key === focusPathKey);
        index !== -1 && (newRange.startIndex = Math.min(newRange.startIndex, index), newRange.endIndex = Math.max(newRange.endIndex, index));
      }
      return reactVirtual.defaultRangeExtractor(newRange);
    },
    [activeDragItemIndex, focusPathKey, memberKeys]
  ), observeElementOffset = React.useCallback(
    (instance, callback) => {
      if (!instance.scrollElement)
        return;
      const scroll = instance.scrollElement, handleScroll = () => {
        var _a22, _b, _c, _d;
        const containerElementTop = (_b = (_a22 = containerElement.current) == null ? void 0 : _a22.getBoundingClientRect().top) != null ? _b : 0, parentElementTop = (_d = (_c = parentRef.current) == null ? void 0 : _c.getBoundingClientRect().top) != null ? _d : 0, itemOffset = Math.floor(parentElementTop - containerElementTop);
        callback(scroll.scrollTop - itemOffset);
      };
      return handleScroll(), instance.scrollElement.addEventListener("scroll", handleScroll, {
        capture: !1,
        passive: !0
      }), () => {
        scroll.removeEventListener("scroll", handleScroll);
      };
    },
    [containerElement]
  ), estimateSize = React.useCallback(() => 53, []), virtualizer = reactVirtual.useVirtualizer({
    count: members.length,
    estimateSize,
    getScrollElement: React.useCallback(() => scrollElement, [scrollElement]),
    observeElementOffset,
    rangeExtractor,
    getItemKey: React.useCallback((index) => memberKeys[index], [memberKeys]),
    scrollToFn: (offset, options, instance) => {
      offset !== instance.scrollOffset && reactVirtual.elementScroll(offset, options, instance);
    }
  }), items = virtualizer.getVirtualItems(), handleItemMoveStart = React.useCallback((event) => {
    var _a22, _b;
    const { active } = event;
    setActiveDragItemIndex((_b = (_a22 = active.data.current) == null ? void 0 : _a22.sortable) == null ? void 0 : _b.index);
  }, []), handleItemMoveEnd = React.useCallback(() => {
    setActiveDragItemIndex(null);
  }, []), sortable2 = ((_a2 = schemaType.options) == null ? void 0 : _a2.sortable) !== !1, listGridGap = 1, paddingY = 1, radius = 2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, ref: parentRef, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      UploadTargetCard,
      {
        $radius: radius,
        types: schemaType.of,
        resolveUploader: resolveUploader2,
        onUpload,
        ...elementProps,
        tabIndex: 0,
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { "data-ui": "ArrayInput__content", space: 2, children: members.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: schemaType.placeholder || /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.array.no-items-label") }) }) }) : /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            border: !0,
            radius,
            style: {
              // This is not memoized since it changes on scroll so it will change anyways making memo useless
              // Account for grid gap
              boxSizing: "border-box",
              height: `${virtualizer.getTotalSize() + items.length * space[listGridGap] + space[paddingY]}px`,
              width: "100%",
              position: "relative"
            },
            children: /* @__PURE__ */ jsxRuntime.jsx(
              List,
              {
                axis: "y",
                gap: listGridGap,
                paddingY,
                items: memberKeys,
                onItemMove,
                onItemMoveStart: handleItemMoveStart,
                onItemMoveEnd: handleItemMoveEnd,
                sortable: sortable2,
                style: {
                  // This is not memoized since it changes on scroll so it will change anyways making memo useless
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  transform: `translateY(${items[0].start}px)`
                },
                children: items.map((virtualRow) => {
                  const member = members[virtualRow.index];
                  return /* @__PURE__ */ jsxRuntime.jsxs(
                    Item,
                    {
                      ref: virtualizer.measureElement,
                      sortable: sortable2,
                      "data-index": virtualRow.index,
                      id: member.key,
                      children: [
                        member.kind === "item" && /* @__PURE__ */ jsxRuntime.jsx(
                          ArrayOfObjectsItem,
                          {
                            member,
                            renderAnnotation,
                            renderBlock: renderBlock2,
                            renderField,
                            renderInlineBlock,
                            renderInput,
                            renderItem: renderItem2,
                            renderPreview
                          }
                        ),
                        member.kind === "error" && /* @__PURE__ */ jsxRuntime.jsx(
                          ErrorItem,
                          {
                            readOnly,
                            sortable: sortable2,
                            member,
                            onRemove: () => props2.onItemRemove(member.key)
                          }
                        )
                      ]
                    },
                    virtualRow.key
                  );
                })
              }
            )
          }
        ) })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      ArrayFunctions,
      {
        onChange,
        onItemAppend: handleAppend,
        onItemPrepend: handlePrepend,
        onValueCreate: createProtoArrayValue,
        readOnly,
        schemaType,
        value
      }
    )
  ] });
}
function ArrayOfObjectsInput(props2) {
  var _a2;
  return ((_a2 = props2.schemaType.options) == null ? void 0 : _a2.layout) === "grid" ? /* @__PURE__ */ jsxRuntime.jsx(GridArrayInput, { ...props2 }) : /* @__PURE__ */ jsxRuntime.jsx(ListArrayInput, { ...props2 });
}
function isEqual(item, otherItem) {
  if (item === otherItem)
    return !0;
  if (typeof item != typeof otherItem)
    return !1;
  if (typeof item != "object" && !Array.isArray(item))
    return item === otherItem;
  if (item._key && item._key === otherItem._key)
    return !0;
  if (Array.isArray(item))
    return !item.length !== otherItem.length ? !1 : item.every((it, i) => isEqual(item[i], otherItem[i]));
  const keys = Object.keys(item), otherKeys = Object.keys(item);
  return keys.length !== otherKeys.length ? !1 : keys.every((keyName) => isEqual(item[keyName], otherItem[keyName]));
}
function inArray(array, candidate) {
  return array ? array.some((item) => isEqual(item, candidate)) : !1;
}
function getMemberTypeOfItem$1(schemaType, item) {
  return schemaType.of.find((memberType) => memberType.name === content.resolveTypeName(item));
}
const EMPTY_ARRAY$j = [];
function ArrayOfObjectOptionsInput(props2) {
  var _a2, _b;
  const {
    renderPreview,
    schemaType,
    onChange,
    onPathFocus,
    value = [],
    readOnly,
    elementProps,
    path,
    changed
  } = props2, options = React.useMemo(
    () => {
      var _a22;
      return (((_a22 = schemaType.options) == null ? void 0 : _a22.list) || EMPTY_ARRAY$j).map(
        (option, index) => types.isKeyedObject(option) ? option : { ...option, _key: `auto-generated-${index}` }
      );
    },
    [(_a2 = schemaType.options) == null ? void 0 : _a2.list]
  ), handleChange = React.useCallback(
    (isChecked, changedOption) => {
      if (!isChecked && types.isKeyedObject(changedOption)) {
        onChange(unset([{ _key: changedOption._key }]));
        return;
      }
      const nextValue = options.filter(
        (option) => isEqual(changedOption, option) ? isChecked : inArray(value, option)
      );
      onChange(nextValue.length > 0 ? set(nextValue) : unset());
    },
    [onChange, options, value]
  ), handleItemFocus = React.useCallback(
    (index) => {
      onPathFocus([index]);
    },
    [onPathFocus]
  ), isGrid = ((_b = schemaType.options) == null ? void 0 : _b.layout) === "grid";
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !1, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Grid,
    {
      gap: 2,
      columns: isGrid ? Math.min(options.length, 4) : 1,
      tabIndex: 0,
      ...elementProps,
      children: options.map((option, index) => {
        const optionType = getMemberTypeOfItem$1(schemaType, option), checked = inArray(value, option), disabled = !optionType;
        return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", as: "label", muted: disabled, children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            ui.Checkbox,
            {
              disabled,
              checked,
              onChange: (e) => handleChange(e.currentTarget.checked, option),
              onFocus: () => handleItemFocus(index),
              readOnly
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginLeft: 2, children: optionType ? renderPreview({
            layout: "default",
            schemaType: optionType,
            value: option
          }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "caution", radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType$2, { value: option, onFocus: () => handleItemFocus(index) }) }) })
        ] }, index);
      })
    }
  ) });
}
function isPrimitiveOption(option) {
  return !!(option && typeof option == "object" && "title" in option && "value" in option);
}
function normalizeOptions(options) {
  return options.map((option) => isPrimitiveOption(option) ? {
    title: option.title || startCase__default.default(String(option.value)),
    value: option.value
  } : {
    title: startCase__default.default(String(option)),
    value: option
  });
}
function getMemberTypeOfItem(schemaType, option) {
  return schemaType.of.find((memberType) => memberType.name === content.resolveTypeName(option.value));
}
function ArrayOfPrimitiveOptionsInput(props2) {
  var _a2, _b;
  const {
    schemaType,
    onChange,
    value = [],
    readOnly,
    path,
    changed,
    onIndexFocus,
    elementProps
  } = props2, options = React.useMemo(
    () => {
      var _a22;
      return normalizeOptions(((_a22 = schemaType.options) == null ? void 0 : _a22.list) || []);
    },
    [(_a2 = schemaType.options) == null ? void 0 : _a2.list]
  ), handleChange = (isChecked, changedValue) => {
    const nextValue = options.map((option) => option.value).filter(
      (optionValue) => (
        // note: sparse arrays are not supported here, so multiple options with same value will all be checked
        optionValue === changedValue ? isChecked : value.includes(optionValue)
      )
    );
    onChange(nextValue.length > 0 ? set(nextValue) : unset());
  }, isGrid = ((_b = schemaType.options) == null ? void 0 : _b.layout) === "grid";
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { gap: 2, columns: isGrid ? Math.min(options.length, 4) : 1, ...elementProps, children: options.map((option, index) => {
    const optionType = getMemberTypeOfItem(schemaType, option), checked = value.includes(option.value), disabled = !optionType;
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", as: "label", muted: disabled, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.Checkbox,
        {
          disabled,
          checked,
          onChange: (e) => handleChange(e.currentTarget.checked, option.value),
          onFocus: () => onIndexFocus(index),
          readOnly
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: option.title }) }),
      !optionType && /* @__PURE__ */ jsxRuntime.jsx(IncompatibleItemType, { value: option, onFocus: () => onIndexFocus(index) })
    ] }, index);
  }) }) });
}
function ArrayOfOptionsInput(props2) {
  return isArrayOfObjectsInputProps(props2) ? /* @__PURE__ */ jsxRuntime.jsx(ArrayOfObjectOptionsInput, { ...props2 }) : /* @__PURE__ */ jsxRuntime.jsx(ArrayOfPrimitiveOptionsInput, { ...props2 });
}
function ArrayOfPrimitivesFunctions(props2) {
  const { schemaType, readOnly, children, onValueCreate, onItemAppend } = props2, menuButtonId = React.useId(), { t: t2 } = useTranslation(), insertItem = React.useCallback(
    (itemType) => {
      onItemAppend(onValueCreate(itemType));
    },
    [onValueCreate, onItemAppend]
  ), handleAddBtnClick = React.useCallback(() => {
    insertItem(schemaType.of[0]);
  }, [schemaType, insertItem]), popoverProps = React.useMemo(() => ({ constrainSize: !0, portal: !0 }), []), addItemI18nKey = schemaType.of.length > 1 ? "inputs.array.action.add-item-select-type" : "inputs.array.action.add-item";
  return readOnly ? /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { portal: !0, content: t2("inputs.array.read-only-label"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { icon: icons.AddIcon, mode: "ghost", disabled: !0, size: "large", text: t2(addItemI18nKey) }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: { gridTemplateColumns: "repeat(auto-fit, minmax(100px, 1fr))" }, children: [
    schemaType.of.length === 1 ? /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.AddIcon,
        mode: "ghost",
        onClick: handleAddBtnClick,
        size: "large",
        text: t2(addItemI18nKey)
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { icon: icons.AddIcon, mode: "ghost", size: "large", text: t2(addItemI18nKey) }),
        id: menuButtonId || "",
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: schemaType.of.map((memberDef, i) => {
          var _a2, _b;
          const referenceIcon = types.isReferenceSchemaType(memberDef) && (memberDef.to || []).length === 1 && memberDef.to[0].icon, icon = memberDef.icon || ((_a2 = memberDef.type) == null ? void 0 : _a2.icon) || referenceIcon;
          return /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: memberDef.title || ((_b = memberDef.type) == null ? void 0 : _b.name),
              onClick: () => insertItem(memberDef),
              icon
            },
            i
          );
        }) }),
        popover: popoverProps
      }
    ),
    children
  ] });
}
const MENU_BUTTON_POPOVER_PROPS$2 = { portal: !0, tone: "default" }, ItemRow = React.forwardRef(function(props2, ref) {
  const {
    sortable: sortable2,
    value,
    insertableTypes,
    onInsert,
    onRemove,
    readOnly,
    inputId,
    validation: validation2,
    children,
    presence,
    schemaType
  } = props2, hasError = validation2.filter((item) => item.level === "error").length > 0, hasWarning = validation2.filter((item) => item.level === "warning").length > 0, handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({ position: pos, items: [getEmptyValue(insertType)] });
    },
    [onInsert]
  ), handleDuplicate = React.useCallback(() => {
    value && onInsert({ position: "after", items: [value] });
  }, [onInsert, value]), tone = React.useMemo(() => {
    if (hasError)
      return "critical";
    if (hasWarning)
      return "caution";
  }, [hasError, hasWarning]), { t: t2 } = useTranslation(), menu = /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
      id: `${inputId}-menuButton`,
      popover: MENU_BUTTON_POPOVER_PROPS$2,
      menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            text: t2("inputs.array.action.remove"),
            tone: "critical",
            icon: icons.TrashIcon,
            onClick: onRemove
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            text: t2("inputs.array.action.duplicate"),
            icon: icons.CopyIcon,
            onClick: handleDuplicate
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })
      ] })
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      tone,
      readOnly: !!readOnly,
      menu: !readOnly && menu,
      dragHandle: sortable2,
      presence: presence.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence, maxAvatars: 1 }),
      validation: validation2.length > 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: validation2 }) }) : null,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: schemaType ? "flex-end" : "center", ref, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "flex-end", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginRight: 2, children }) }) })
    }
  );
});
function NoItemsPlaceholder({ schemaType }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: schemaType.placeholder || t2("inputs.array.no-items-label") }) });
}
function nearestIndexOf(array, startIdx, searchElement) {
  return nearestIndex(array, startIdx, (element) => element === searchElement);
}
function nearestIndex(array, startIdx, predicate) {
  let lowerIdx = startIdx - 1, upperIdx = startIdx;
  const len = array.length;
  for (; lowerIdx > -1 || upperIdx < len; ) {
    const upper = array[upperIdx];
    if (upperIdx < len && predicate(upper, upperIdx))
      return upperIdx;
    const lower = array[lowerIdx];
    if (lowerIdx > -1 && predicate(lower, lowerIdx))
      return lowerIdx;
    lowerIdx--, upperIdx++;
  }
  return -1;
}
var __defProp$a = Object.defineProperty, __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$a = (obj, key, value) => __defNormalProp$a(obj, typeof key != "symbol" ? key + "" : key, value);
class ArrayOfPrimitivesInput extends React.PureComponent {
  constructor(props2) {
    super(props2), __publicField$a(this, "_element", null), __publicField$a(this, "handleAppend", (itemValue) => {
      const { value = [], onIndexFocus, onItemAppend } = this.props;
      onItemAppend(itemValue), onIndexFocus(value.length);
    }), __publicField$a(this, "handlePrepend", (itemValue) => {
      const { onIndexFocus, value = [], onItemPrepend } = this.props;
      onItemPrepend(itemValue), onIndexFocus(value.length);
    }), __publicField$a(this, "handleSortEnd", (event) => {
      const { onIndexFocus, onMoveItem, value } = this.props;
      value && onMoveItem(event), onIndexFocus(event.toIndex);
    }), __publicField$a(this, "handleItemMoveStart", () => {
      this.setState({ disableTransition: !1 });
    }), __publicField$a(this, "handleItemMoveEnd", () => {
      this.setState({ disableTransition: !0 });
    }), __publicField$a(this, "renderArrayItem", (props3) => {
      var _a2;
      const { schemaType } = this.props, sortable2 = ((_a2 = schemaType.options) == null ? void 0 : _a2.sortable) !== !1;
      return /* @__PURE__ */ jsxRuntime.jsx(ItemRow, { ...props3, sortable: sortable2, insertableTypes: schemaType.of });
    }), this.state = {
      disableTransition: !1
    };
  }
  focus() {
    this._element && this._element.focus();
  }
  getSnapshotBeforeUpdate(prevProps) {
    var _a2;
    const { focusPath: prevFocusPath = [], value: prevValue = [] } = prevProps, { focusPath = [], value = [] } = this.props;
    if (prevFocusPath[0] === focusPath[0] && prevValue.length !== value.length) {
      const focusIndex = focusPath[0], selection = window.getSelection();
      if (!((selection == null ? void 0 : selection.focusNode) instanceof HTMLElement))
        return null;
      const input = (_a2 = selection.focusNode) == null ? void 0 : _a2.querySelector("input,textarea");
      return input instanceof HTMLInputElement ? {
        prevFocusedIndex: focusIndex,
        restoreSelection: {
          text: selection.toString(),
          start: input.selectionStart,
          end: input.selectionEnd,
          value: input.value
        }
      } : {};
    }
    return null;
  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    var _a2;
    const { onIndexFocus } = this.props;
    if (snapshot != null && snapshot.restoreSelection && prevProps.value) {
      const prevFocusedValue = prevProps.value[snapshot.prevFocusedIndex], nearestIndex2 = nearestIndexOf(
        this.props.value || [],
        snapshot.prevFocusedIndex,
        prevFocusedValue
      );
      if (nearestIndex2 === -1)
        return;
      const newInput = (_a2 = this._element) == null ? void 0 : _a2.querySelector(
        `[data-item-index='${nearestIndex2}'] input,textarea`
      );
      if (newInput instanceof HTMLInputElement) {
        newInput.focus();
        try {
          newInput.setSelectionRange(snapshot.restoreSelection.start, snapshot.restoreSelection.end);
        } catch {
        }
      }
      onIndexFocus(nearestIndex2);
    }
  }
  render() {
    const {
      schemaType,
      members,
      readOnly,
      renderInput,
      onUpload,
      onItemRemove,
      resolveUploader: resolveUploader2,
      elementProps,
      arrayFunctions: ArrayFunctions = ArrayOfPrimitivesFunctions,
      changed
    } = this.props, isSortable = !readOnly && get__default.default(schemaType, "options.sortable") !== !1, membersWithSortIds = members.map((member) => ({
      id: `${member.key}-${member.kind === "item" ? member.item.value : "error"}`,
      member
    }));
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, "data-testid": "array-primitives-input", children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        UploadTargetCard,
        {
          types: schemaType.of,
          resolveUploader: resolveUploader2,
          onUpload,
          ...elementProps,
          tabIndex: 0,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: membersWithSortIds.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(NoItemsPlaceholder, { schemaType }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
            List,
            {
              onItemMove: this.handleSortEnd,
              onItemMoveStart: this.handleItemMoveStart,
              onItemMoveEnd: this.handleItemMoveEnd,
              items: membersWithSortIds.map((m) => m.id),
              sortable: isSortable,
              gap: 1,
              children: membersWithSortIds.map(({ member, id: id2 }, index) => /* @__PURE__ */ jsxRuntime.jsxs(
                Item,
                {
                  id: id2,
                  sortable: isSortable,
                  disableTransition: this.state.disableTransition,
                  children: [
                    member.kind === "item" && /* @__PURE__ */ jsxRuntime.jsx(
                      ChangeIndicator,
                      {
                        path: member.item.path,
                        isChanged: changed,
                        hasFocus: !1,
                        children: /* @__PURE__ */ jsxRuntime.jsx(
                          ArrayOfPrimitivesItem,
                          {
                            member,
                            renderItem: this.renderArrayItem,
                            renderInput
                          }
                        )
                      }
                    ),
                    member.kind === "error" && /* @__PURE__ */ jsxRuntime.jsx(
                      ErrorItem,
                      {
                        readOnly,
                        sortable: isSortable,
                        member,
                        onRemove: () => onItemRemove(index)
                      }
                    )
                  ]
                },
                member.key
              ))
            }
          ) }) })
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ArrayFunctions,
        {
          onChange: this.props.onChange,
          onItemAppend: this.handleAppend,
          onItemPrepend: this.handlePrepend,
          onValueCreate: getEmptyValue,
          readOnly: this.props.readOnly,
          schemaType: this.props.schemaType,
          value: this.props.value
        }
      )
    ] });
  }
}
function UniversalArrayInput(props2) {
  return React.useMemo(
    () => {
      var _a2;
      return Array.isArray((_a2 = props2.schemaType.options) == null ? void 0 : _a2.list);
    },
    [props2.schemaType]
  ) ? /* @__PURE__ */ jsxRuntime.jsx(ArrayOfOptionsInput, { ...props2 }) : isArrayOfPrimitivesInputProps(props2) ? /* @__PURE__ */ jsxRuntime.jsx(ArrayOfPrimitivesInput, { ...props2 }) : /* @__PURE__ */ jsxRuntime.jsx(ArrayOfObjectsInput, { ...props2 });
}
const Root$l = styledComponents.styled(ui.Card)`
  line-height: 1;
`, CenterAlignedBox = styledComponents.styled(ui.Box)`
  align-self: center;
`, ZeroLineHeightBox = styledComponents.styled(ui.Box)`
  line-height: 0;
`;
function BooleanInput(props2) {
  var _a2;
  const { t: t2 } = useTranslation(), { id: id2, value, schemaType, readOnly, elementProps, validation: validation2 } = props2, layout = ((_a2 = schemaType.options) == null ? void 0 : _a2.layout) || "switch", indeterminate = typeof value != "boolean", checked = value || !1, LayoutSpecificInput = layout === "checkbox" ? ui.Checkbox : ui.Switch, tone = readOnly ? "transparent" : void 0, input = /* @__PURE__ */ jsxRuntime.jsx(ZeroLineHeightBox, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
    LayoutSpecificInput,
    {
      label: schemaType.title,
      ...elementProps,
      checked,
      readOnly,
      indeterminate,
      style: { margin: -4 }
    }
  ) });
  return /* @__PURE__ */ jsxRuntime.jsx(Root$l, { border: !0, "data-testid": "boolean-input", radius: 2, tone, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    readOnly ? /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: t2("inputs.boolean.disabled"), children: input }) : input,
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
      FormFieldHeaderText,
      {
        deprecated: schemaType.deprecated,
        description: schemaType.description,
        inputId: id2,
        validation: validation2,
        title: schemaType.title
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(CenterAlignedBox, { paddingX: 3, paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldStatus, { maxAvatars: 1, position: "top" }) })
  ] }) });
}
function CalendarDay$3(props2) {
  const { date, focused, isCurrentMonth, isToday, onSelect, selected } = props2, handleClick = React.useCallback(() => {
    onSelect(date);
  }, [date, onSelect]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", { "aria-selected": selected, "data-ui": "CalendarDay", children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Card,
    {
      "aria-label": date.toDateString(),
      "aria-pressed": selected,
      as: "button",
      __unstable_focusRing: !0,
      "data-weekday": !0,
      "data-focused": focused ? "true" : "",
      role: "button",
      tabIndex: -1,
      onClick: handleClick,
      padding: 2,
      radius: 2,
      selected,
      tone: isToday || selected ? "primary" : "default",
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Text,
        {
          muted: !selected && !isCurrentMonth,
          size: 1,
          style: { textAlign: "center" },
          weight: isCurrentMonth ? "medium" : "regular",
          children: date.getDate()
        }
      )
    }
  ) });
}
const HOURS_24$1 = range__default.default(0, 24), ARROW_KEYS$3 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], TAIL_WEEKDAYS$3 = [1, 2, 3, 4, 5, 6], getWeekStartsOfMonth$3 = (date, weekStartsOn) => {
  const firstDay = dateFns.startOfMonth(date);
  return dateFns.eachWeekOfInterval(
    {
      start: firstDay,
      end: dateFns.lastDayOfMonth(firstDay)
    },
    {
      weekStartsOn: weekStartsOn === 7 ? 0 : weekStartsOn
    }
  );
}, getWeekDaysFromWeekStarts$3 = (weekStarts) => weekStarts.map((weekStart) => [
  weekStart,
  ...TAIL_WEEKDAYS$3.map((d) => dateFns.addDays(weekStart, d))
]), useWeeksOfMonth$1 = (date) => {
  const { weekInfo } = useCurrentLocale();
  return getWeekDaysFromWeekStarts$3(getWeekStartsOfMonth$3(date, weekInfo.firstDay)).map(
    (days) => ({
      number: dateFns.getWeek(days[0]),
      days
    })
  );
};
function CalendarMonth$3(props2) {
  const {
    weekInfo: { firstDay: weekStartDay }
  } = useCurrentLocale(), weekDayNames = weekStartDay === 1 ? props2.weekDayNames : [props2.weekDayNames[6], ...props2.weekDayNames.slice(0, 6)];
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "aria-hidden": props2.hidden || !1, "data-ui": "CalendarMonth", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: { gridTemplateColumns: "repeat(7, minmax(44px, 46px))" }, children: [
    weekDayNames.map((weekday) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", style: { textAlign: "center" }, children: weekday }) }, weekday)),
    useWeeksOfMonth$1(props2.date).map(
      (week, weekIdx) => week.days.map((date, dayIdx) => {
        const focused = props2.focused && dateFns.isSameDay(date, props2.focused), selected = props2.selected && dateFns.isSameDay(date, props2.selected), isToday = dateFns.isSameDay(date, /* @__PURE__ */ new Date()), isCurrentMonth = props2.focused && dateFns.isSameMonth(date, props2.focused);
        return /* @__PURE__ */ jsxRuntime.jsx(
          CalendarDay$3,
          {
            date,
            focused,
            isCurrentMonth,
            isToday,
            onSelect: props2.onSelect,
            selected
          },
          `${weekIdx}-${dayIdx}`
        );
      })
    )
  ] }) });
}
const features$1 = {
  dayPresets: !1,
  timePresets: !1
}, LazyTextInput = React.forwardRef(function({ onChange, onBlur, onKeyPress, value, ...rest }, forwardedRef) {
  const [inputValue, setInputValue] = React.useState(), handleChange = React.useCallback((event) => {
    setInputValue(event.currentTarget.value);
  }, []), checkEvent = React.useCallback(
    (event) => {
      event.currentTarget.value !== `${value}` && onChange && onChange(event), setInputValue(void 0);
    },
    [onChange, value]
  ), handleBlur = React.useCallback(
    (e) => {
      checkEvent(e), onBlur && onBlur(e);
    },
    [checkEvent, onBlur]
  ), handleKeyPress = React.useCallback(
    (e) => {
      e.key === "Enter" && checkEvent(e), onKeyPress && onKeyPress(e);
    },
    [checkEvent, onKeyPress]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      ...rest,
      "data-testid": "date-input",
      ref: forwardedRef,
      value: inputValue === void 0 ? value : inputValue,
      onChange: handleChange,
      onBlur: handleBlur,
      onKeyPress: handleKeyPress
    }
  );
}), YearInput$1 = (props2) => {
  const { onChange, ...restProps } = props2, handleChange = React.useCallback(
    (event) => {
      const numericValue = parseInt(event.currentTarget.value, 10);
      isNaN(numericValue) || onChange(numericValue);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    LazyTextInput,
    {
      ...restProps,
      fontSize: 1,
      onChange: handleChange,
      inputMode: "numeric",
      padding: 2,
      radius: 2
    }
  );
}, PRESERVE_FOCUS_ELEMENT$3 = /* @__PURE__ */ jsxRuntime.jsx(
  "span",
  {
    "data-preserve-focus": !0,
    style: { overflow: "hidden", position: "absolute", outline: "none" },
    tabIndex: -1
  }
), CALENDAR_ICON_BUTTON_PROPS = {
  padding: 2
}, Calendar$3 = React.forwardRef(function(props2, forwardedRef) {
  const {
    selectTime,
    onFocusedDateChange,
    selectedDate = /* @__PURE__ */ new Date(),
    focusedDate = selectedDate,
    timeStep = 1,
    onSelect,
    labels,
    ...restProps
  } = props2, setFocusedDate = React.useCallback(
    (date) => onFocusedDateChange(date),
    [onFocusedDateChange]
  ), setFocusedDateMonth = React.useCallback(
    (month) => setFocusedDate(dateFns.setDate(dateFns.setMonth(focusedDate, month), 1)),
    [focusedDate, setFocusedDate]
  ), handleFocusedMonthChange = React.useCallback(
    (e) => setFocusedDateMonth(Number(e.currentTarget.value)),
    [setFocusedDateMonth]
  ), moveFocusedDate = React.useCallback(
    (by) => setFocusedDate(dateFns.addMonths(focusedDate, by)),
    [focusedDate, setFocusedDate]
  ), setFocusedDateYear = React.useCallback(
    (year) => setFocusedDate(dateFns.setYear(focusedDate, year)),
    [focusedDate, setFocusedDate]
  ), handleDateChange = React.useCallback(
    (date) => {
      onSelect(dateFns.setMinutes(dateFns.setHours(date, selectedDate.getHours()), selectedDate.getMinutes()));
    },
    [onSelect, selectedDate]
  ), handleMinutesChange = React.useCallback(
    (event) => {
      const m = Number(event.currentTarget.value);
      onSelect(dateFns.setMinutes(selectedDate, m));
    },
    [onSelect, selectedDate]
  ), handleHoursChange = React.useCallback(
    (event) => {
      const m = Number(event.currentTarget.value);
      onSelect(dateFns.setHours(selectedDate, m));
    },
    [onSelect, selectedDate]
  );
  React.useCallback(
    (hours, mins) => {
      onSelect(dateFns.setHours(dateFns.setMinutes(selectedDate, mins), hours));
    },
    [onSelect, selectedDate]
  );
  const ref = ui.useForwardedRef(forwardedRef), focusCurrentWeekDay = React.useCallback(() => {
    var _a2, _b;
    (_b = (_a2 = ref.current) == null ? void 0 : _a2.querySelector('[data-focused="true"]')) == null || _b.focus();
  }, [ref]), handleKeyDown = React.useCallback(
    (event) => {
      var _a2, _b;
      if (!ARROW_KEYS$3.includes(event.key))
        return;
      const target = event.currentTarget;
      if (event.preventDefault(), target.hasAttribute("data-calendar-grid")) {
        focusCurrentWeekDay();
        return;
      }
      event.key === "ArrowUp" && onFocusedDateChange(dateFns.addDays(focusedDate, -7)), event.key === "ArrowDown" && onFocusedDateChange(dateFns.addDays(focusedDate, 7)), event.key === "ArrowLeft" && onFocusedDateChange(dateFns.addDays(focusedDate, -1)), event.key === "ArrowRight" && onFocusedDateChange(dateFns.addDays(focusedDate, 1)), (_b = (_a2 = ref.current) == null ? void 0 : _a2.querySelector("[data-preserve-focus]")) == null || _b.focus();
    },
    [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]
  );
  React.useEffect(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]), React.useEffect(() => {
    var _a2;
    (_a2 = document.activeElement) != null && _a2.matches(
      "[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]"
    ) && focusCurrentWeekDay();
  }, [ref, focusCurrentWeekDay, focusedDate]), React.useCallback(
    () => handleDateChange(dateFns.addDays(/* @__PURE__ */ new Date(), -1)),
    [handleDateChange]
  ), React.useCallback(() => handleDateChange(/* @__PURE__ */ new Date()), [handleDateChange]), React.useCallback(
    () => handleDateChange(dateFns.addDays(/* @__PURE__ */ new Date(), 1)),
    [handleDateChange]
  );
  const handleNowClick = React.useCallback(() => onSelect(/* @__PURE__ */ new Date()), [onSelect]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { "data-ui": "Calendar", ...restProps, ref, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 2, children: [
      features$1.dayPresets,
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          CalendarMonthSelect$1,
          {
            onChange: handleFocusedMonthChange,
            monthNames: labels.monthNames,
            value: focusedDate == null ? void 0 : focusedDate.getMonth()
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          CalendarYearSelect$1,
          {
            moveFocusedDate,
            labels: {
              goToNextYear: labels.goToNextYear,
              goToPreviousYear: labels.goToPreviousYear
            },
            onChange: setFocusedDateYear,
            value: focusedDate.getFullYear()
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(
        ui.Box,
        {
          "data-calendar-grid": !0,
          onKeyDown: handleKeyDown,
          marginTop: 2,
          overflow: "hidden",
          tabIndex: 0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              CalendarMonth$3,
              {
                weekDayNames: labels.weekDayNamesShort,
                date: focusedDate,
                focused: focusedDate,
                onSelect: handleDateChange,
                selected: selectedDate
              }
            ),
            PRESERVE_FOCUS_ELEMENT$3
          ]
        }
      )
    ] }),
    selectTime && /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 2, style: { borderTop: "1px solid var(--card-border-color)" }, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Select,
            {
              "aria-label": labels.selectHour,
              fontSize: 1,
              padding: 2,
              radius: 2,
              value: selectedDate == null ? void 0 : selectedDate.getHours(),
              onChange: handleHoursChange,
              children: HOURS_24$1.map((h) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: h, children: `${h}`.padStart(2, "0") }, h))
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: ":" }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Select,
            {
              "aria-label": labels.selectMinute,
              fontSize: 1,
              padding: 2,
              radius: 2,
              value: selectedDate == null ? void 0 : selectedDate.getMinutes(),
              onChange: handleMinutesChange,
              children: range__default.default(0, 60, timeStep).map((m) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: m, children: `${m}`.padStart(2, "0") }, m))
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { text: labels.setToCurrentTime, mode: "bleed", onClick: handleNowClick }) })
      ] }),
      features$1.timePresets
    ] })
  ] });
});
function CalendarMonthSelect$1(props2) {
  const { onChange, value, monthNames } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Select, { fontSize: 1, radius: 2, value, onChange, padding: 2, children: monthNames.map((monthName, i) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ jsxRuntime.jsx("option", { value: i, children: monthName }, i)
  )) }) }) });
}
function CalendarYearSelect$1(props2) {
  const { moveFocusedDate, onChange, value, labels } = props2, handlePrevYearClick = React.useCallback(() => moveFocusedDate(-12), [moveFocusedDate]), handleNextYearClick = React.useCallback(() => moveFocusedDate(12), [moveFocusedDate]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": labels.goToPreviousYear,
        onClick: handlePrevYearClick,
        mode: "bleed",
        icon: icons.ChevronLeftIcon,
        tooltipProps: { content: "Previous year" },
        ...CALENDAR_ICON_BUTTON_PROPS
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(YearInput$1, { value, onChange, radius: 0, style: { width: 48 } }),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": labels.goToNextYear,
        onClick: handleNextYearClick,
        mode: "bleed",
        icon: icons.ChevronRightIcon,
        tooltipProps: { content: "Next year" },
        ...CALENDAR_ICON_BUTTON_PROPS
      }
    )
  ] });
}
const DatePicker$2 = React.forwardRef(function(props2, ref) {
  const { value = /* @__PURE__ */ new Date(), onChange, calendarLabels, ...rest } = props2, [focusedDate, setFocusedDay] = React.useState(), handleSelect = React.useCallback(
    (nextDate) => {
      onChange(nextDate), setFocusedDay(void 0);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Calendar$3,
    {
      ...rest,
      labels: calendarLabels,
      ref,
      selectedDate: value,
      onSelect: handleSelect,
      focusedDate: focusedDate || value,
      onFocusedDateChange: setFocusedDay
    }
  );
}), DateTimeInput$3 = React.forwardRef(function(props2, ref) {
  const {
    value,
    inputValue,
    onInputChange,
    onChange,
    selectTime,
    timeStep,
    calendarLabels,
    ...rest
  } = props2, [popoverRef, setPopoverRef] = React.useState(null), forwardedRef = ui.useForwardedRef(ref), buttonRef = React.useRef(null), [isPickerOpen, setPickerOpen] = React.useState(!1);
  ui.useClickOutside(() => setPickerOpen(!1), [popoverRef]);
  const handleDeactivation = React.useCallback(() => {
    var _a2, _b;
    (_a2 = forwardedRef.current) == null || _a2.focus(), (_b = forwardedRef.current) == null || _b.select();
  }, [forwardedRef]), handleKeyUp = React.useCallback((e) => {
    e.key === "Escape" && setPickerOpen(!1);
  }, []), handleClick = React.useCallback(() => setPickerOpen(!0), []), suffix = /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { style: { padding: "5px" }, children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      ref: buttonRef,
      icon: icons.CalendarIcon,
      mode: "bleed",
      onClick: handleClick,
      style: { display: "block" },
      "data-testid": "select-date-button",
      tooltipProps: { content: "Select date" }
    }
  ) });
  return /* @__PURE__ */ jsxRuntime.jsx(
    LazyTextInput,
    {
      ref: forwardedRef,
      ...rest,
      value: inputValue,
      onChange: onInputChange,
      suffix: isPickerOpen ? (
        // Note: we're conditionally inserting the popover here due to an
        // issue with popovers rendering incorrectly on subsequent renders
        // see https://github.com/sanity-io/design/issues/519
        /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset: 1e3, children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Popover,
          {
            constrainSize: !0,
            "data-testid": "date-input-dialog",
            portal: !0,
            content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { onDeactivation: handleDeactivation, children: /* @__PURE__ */ jsxRuntime.jsx(
              DatePicker$2,
              {
                calendarLabels,
                selectTime,
                timeStep,
                onKeyUp: handleKeyUp,
                value,
                onChange
              }
            ) }) }),
            open: !0,
            placement: "bottom",
            ref: setPopoverRef,
            children: suffix
          }
        ) })
      ) : suffix
    }
  );
}), DEFAULT_PLACEHOLDER_TIME = /* @__PURE__ */ new Date(), CommonDateTimeInput$1 = React.forwardRef(function(props2, ref) {
  const {
    id: id2,
    deserialize: deserialize2,
    formatInputValue,
    onChange,
    parseInputValue,
    placeholder,
    readOnly,
    selectTime,
    serialize: serialize2,
    timeStep,
    value,
    ...restProps
  } = props2, [localValue, setLocalValue] = React.useState(null), { t: t2 } = useTranslation();
  React.useEffect(() => {
    setLocalValue(null);
  }, [value]);
  const handleDatePickerInputChange = React.useCallback(
    (event) => {
      const nextInputValue = event.currentTarget.value, result = nextInputValue === "" ? null : parseInputValue(nextInputValue);
      result === null ? (onChange(null), typeof value > "u" && localValue && setLocalValue(null)) : result.isValid ? onChange(serialize2(result.date)) : setLocalValue(nextInputValue);
    },
    [parseInputValue, onChange, value, localValue, serialize2]
  ), handleDatePickerChange = React.useCallback(
    (nextDate) => {
      onChange(nextDate ? serialize2(nextDate) : null);
    },
    [serialize2, onChange]
  ), forwardedRef = ui.useForwardedRef(ref), parseResult = localValue ? parseInputValue(localValue) : value ? deserialize2(value) : null, inputValue = localValue || (parseResult != null && parseResult.isValid ? formatInputValue(parseResult.date) : value);
  return readOnly ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { value: inputValue, readOnly: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(
    DateTimeInput$3,
    {
      ...restProps,
      calendarLabels: props2.calendarLabels,
      id: id2,
      selectTime,
      timeStep,
      placeholder: placeholder || t2("inputs.datetime.placeholder", {
        example: formatInputValue(DEFAULT_PLACEHOLDER_TIME)
      }),
      ref: forwardedRef,
      value: parseResult == null ? void 0 : parseResult.date,
      inputValue: inputValue || "",
      readOnly: !!readOnly,
      onInputChange: handleDatePickerInputChange,
      onChange: handleDatePickerChange,
      customValidity: parseResult == null ? void 0 : parseResult.error
    }
  );
});
function isValidDate$1(date) {
  return date instanceof Date && !isNaN(date.valueOf());
}
function getCalendarLabels(t2) {
  return {
    goToTomorrow: t2("calendar.action.go-to-tomorrow"),
    goToToday: t2("calendar.action.go-to-today"),
    goToYesterday: t2("calendar.action.go-to-yesterday"),
    goToNextMonth: t2("calendar.action.go-to-next-month"),
    goToPreviousMonth: t2("calendar.action.go-to-previous-month"),
    goToNextYear: t2("calendar.action.go-to-next-year"),
    goToPreviousYear: t2("calendar.action.go-to-previous-year"),
    setToCurrentTime: t2("calendar.action.set-to-current-time"),
    selectHour: t2("calendar.action.select-hour"),
    selectMinute: t2("calendar.action.select-minute"),
    monthNames: [
      t2("calendar.month-names.january"),
      t2("calendar.month-names.february"),
      t2("calendar.month-names.march"),
      t2("calendar.month-names.april"),
      t2("calendar.month-names.may"),
      t2("calendar.month-names.june"),
      t2("calendar.month-names.july"),
      t2("calendar.month-names.august"),
      t2("calendar.month-names.september"),
      t2("calendar.month-names.october"),
      t2("calendar.month-names.november"),
      t2("calendar.month-names.december")
    ],
    weekDayNamesShort: [
      t2("calendar.weekday-names.short.monday"),
      t2("calendar.weekday-names.short.tuesday"),
      t2("calendar.weekday-names.short.wednesday"),
      t2("calendar.weekday-names.short.thursday"),
      t2("calendar.weekday-names.short.friday"),
      t2("calendar.weekday-names.short.saturday"),
      t2("calendar.weekday-names.short.sunday")
    ],
    setToTimePreset: (time, date) => t2("calendar.action.set-to-time-preset", { time, date })
  };
}
const deserialize$3 = (value) => legacyDateFormat.parse(value, legacyDateFormat.DEFAULT_DATE_FORMAT), serialize$5 = (date) => legacyDateFormat.format(date, legacyDateFormat.DEFAULT_DATE_FORMAT);
function DateInput(props2) {
  var _a2;
  const { readOnly, onChange, schemaType, elementProps, value } = props2, dateFormat = ((_a2 = schemaType.options) == null ? void 0 : _a2.dateFormat) || legacyDateFormat.DEFAULT_DATE_FORMAT, { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (nextDate) => {
      onChange(nextDate === null ? unset() : set(nextDate));
    },
    [onChange]
  ), formatInputValue = React.useCallback((date) => legacyDateFormat.format(date, dateFormat), [dateFormat]), parseInputValue = React.useCallback(
    (inputValue) => legacyDateFormat.parse(inputValue, dateFormat),
    [dateFormat]
  ), calendarLabels = React.useMemo(() => getCalendarLabels(t2), [t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommonDateTimeInput$1,
    {
      ...elementProps,
      deserialize: deserialize$3,
      formatInputValue,
      onChange: handleChange,
      parseInputValue,
      placeholder: schemaType.placeholder,
      calendarLabels,
      readOnly,
      selectTime: !1,
      serialize: serialize$5,
      value
    }
  );
}
function parseOptions$1(options = {}) {
  return {
    dateFormat: options.dateFormat || legacyDateFormat.DEFAULT_DATE_FORMAT,
    timeFormat: options.timeFormat || legacyDateFormat.DEFAULT_TIME_FORMAT,
    timeStep: "timeStep" in options && Number(options.timeStep) || 1
  };
}
function serialize$4(date) {
  return date.toISOString();
}
function deserialize$2(isoString) {
  const deserialized = new Date(isoString);
  return isValidDate$1(deserialized) ? { isValid: !0, date: deserialized } : { isValid: !1, error: `Invalid date value: "${isoString}"` };
}
function enforceTimeStep$1(dateString, timeStep) {
  if (!timeStep || timeStep === 1)
    return dateString;
  const date = dateFns.parseISO(dateString), minutes = dateFns.getMinutes(date), leftOver = minutes % timeStep;
  return serialize$4(leftOver !== 0 ? dateFns.setMinutes(date, minutes - leftOver) : date);
}
function DateTimeInput$2(props2) {
  const { onChange, schemaType, value, elementProps } = props2, { dateFormat, timeFormat, timeStep } = parseOptions$1(schemaType.options), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (nextDate) => {
      let date = nextDate;
      date !== null && timeStep > 1 && (date = enforceTimeStep$1(date, timeStep)), onChange(date === null ? unset() : set(date));
    },
    [onChange, timeStep]
  ), formatInputValue = React.useCallback(
    (date) => legacyDateFormat.format(date, `${dateFormat} ${timeFormat}`),
    [dateFormat, timeFormat]
  ), parseInputValue = React.useCallback(
    (inputValue) => legacyDateFormat.parse(inputValue, `${dateFormat} ${timeFormat}`),
    [dateFormat, timeFormat]
  ), calendarLabels = React.useMemo(() => getCalendarLabels(t2), [t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommonDateTimeInput$1,
    {
      ...elementProps,
      calendarLabels,
      onChange: handleChange,
      deserialize: deserialize$2,
      formatInputValue,
      parseInputValue,
      placeholder: schemaType.placeholder,
      selectTime: !0,
      serialize: serialize$4,
      timeStep,
      value
    }
  );
}
function EmailInput(props2) {
  const { validationError, elementProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...elementProps, type: "email", inputMode: "email", customValidity: validationError });
}
const normalizeRules = (validation2, type) => {
  if (typeof validation2 == "function")
    throw new Error(
      `Schema type "${(type == null ? void 0 : type.name) || "<not-found>"}"'s \`validation\` was not run though \`inferFromSchema\``
    );
  return validation2 ? Array.isArray(validation2) ? validation2 : [validation2] : [];
};
function getValidationRule(type, ruleName) {
  for (const rule of normalizeRules(type == null ? void 0 : type.validation, type))
    for (const ruleSpec of rule._rules)
      if (ruleSpec.flag === ruleName)
        return ruleSpec;
  return null;
}
function NumberInput(props2) {
  const { schemaType, validationError, elementProps } = props2, minRule = getValidationRule(schemaType, "min"), integerRule = getValidationRule(schemaType, "integer"), precisionRule = getValidationRule(schemaType, "precision"), onlyPositiveNumber = typeof (minRule == null ? void 0 : minRule.constraint) == "number" && (minRule == null ? void 0 : minRule.constraint) >= 0, onlyIntegers = integerRule || (precisionRule == null ? void 0 : precisionRule.constraint) === 0;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      ...elementProps,
      type: "number",
      step: "any",
      inputMode: onlyPositiveNumber ? onlyIntegers ? "numeric" : "decimal" : "text",
      customValidity: validationError,
      placeholder: schemaType.placeholder,
      pattern: onlyPositiveNumber ? "[d]*" : void 0,
      max: Number.MAX_SAFE_INTEGER,
      min: Number.MIN_SAFE_INTEGER,
      "data-testid": "number-input"
    }
  );
}
const GroupTab = React.forwardRef(function(props2, ref) {
  const { onClick } = props2, handleClick = React.useCallback(() => {
    onClick == null || onClick(props2.name);
  }, [props2.name, onClick]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tab,
    {
      "data-testid": `group-tab-${props2.name}`,
      id: `${props2.name}-tab`,
      label: props2.title,
      ref,
      ...props2,
      onClick: handleClick
    }
  );
}), GroupOption = (props2) => {
  const { name, title, ...rest } = props2, { selected } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    "option",
    {
      title,
      value: name,
      id: `${name}-tab`,
      "aria-controls": rest["aria-controls"],
      "data-testid": `group-select-${name}`,
      "aria-selected": selected ? "true" : "false",
      children: title || name
    }
  );
}, Root$k = styledComponents.styled(ui.ElementQuery)`
  /* Hide on small screens */
  &[data-eq-max~='0'] [data-ui='TabList'] {
    display: none;
  }

  /* Hide on medium to large screens */
  [data-ui='Select'] {
    display: none;
  }

  /* Show on small screens */
  &[data-eq-max~='0'] [data-ui='Select'] {
    display: block;
  }
`, GroupTabs = ({
  inputId,
  groups,
  onClick,
  shouldAutoFocus = !0,
  disabled
}) => /* @__PURE__ */ jsxRuntime.jsx(ui.TabList, { space: 2, "data-testid": "field-group-tabs", children: groups.map((group2) => /* @__PURE__ */ jsxRuntime.jsx(
  GroupTab,
  {
    "aria-controls": `${inputId}-field-group-fields`,
    autoFocus: shouldAutoFocus && group2.selected,
    disabled: disabled || group2.disabled,
    icon: group2 == null ? void 0 : group2.icon,
    name: group2.name,
    onClick,
    selected: !!group2.selected,
    title: group2.title || group2.name
  },
  `${inputId}-${group2.name}-tab`
)) }), GroupSelect = ({
  disabled,
  groups,
  inputId,
  onSelect,
  shouldAutoFocus = !0
}) => {
  var _a2;
  const handleSelect = React.useCallback(
    (event) => {
      onSelect(event.currentTarget.value);
    },
    [onSelect]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Select,
    {
      "aria-label": t2("inputs.object.field-group-tabs.aria-label"),
      autoFocus: shouldAutoFocus,
      "data-testid": "field-group-select",
      disabled,
      fontSize: 2,
      muted: !0,
      onChange: handleSelect,
      value: (_a2 = groups.find((g) => g.selected)) == null ? void 0 : _a2.name,
      children: groups.map((group2) => /* @__PURE__ */ jsxRuntime.jsx(
        GroupOption,
        {
          "aria-controls": `${inputId}-field-group-fields`,
          disabled: group2.disabled,
          name: group2.name,
          selected: !!group2.selected,
          title: group2.title || group2.name
        },
        `${inputId}-${group2.name}-tab`
      ))
    }
  );
}, FieldGroupTabs = React.memo(function({
  disabled = !1,
  onClick,
  ...props2
}) {
  const handleClick = React.useCallback(
    (groupName) => {
      onClick == null || onClick(groupName);
    },
    [onClick]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$k, { "data-testid": "field-group-root", children: [
    /* @__PURE__ */ jsxRuntime.jsx(GroupTabs, { ...props2, disabled, onClick: handleClick }),
    /* @__PURE__ */ jsxRuntime.jsx(GroupSelect, { ...props2, disabled, onSelect: handleClick })
  ] });
}), FieldGroupTabsWrapper = styledComponents.styled(ui.Card)`
  margin-bottom: ${({ $level, theme: theme2 }) => $level === 0 ? 0 : theme2.sanity.space[5] * -1}px;
  padding-bottom: ${({ $level, theme: theme2 }) => theme2.sanity.space[4]}px;
`, AlignedBottomGrid = styledComponents.styled(ui.Grid)`
  align-items: flex-end;
`;
function UnknownFields(props2) {
  const { fieldNames, onChange, readOnly, value } = props2, fieldsLen = fieldNames.length, handleUnsetClick = React.useCallback(
    (fieldName) => {
      onChange(unset([fieldName]));
    },
    [onChange]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Alert,
    {
      status: "warning",
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.object.unknown-fields.warning.title", { count: fieldsLen }) }),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.object.unknown-fields.warning.description", { count: fieldsLen }) }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(
          Details,
          {
            marginTop: 4,
            open: isDev,
            title: t2("inputs.object.unknown-fields.warning.details.title"),
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.object.unknown-fields.warning.details.description", { count: fieldsLen }) }) }) }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 3, children: fieldNames.map((fieldName) => /* @__PURE__ */ jsxRuntime.jsx(
                UnknownField,
                {
                  fieldName,
                  onUnsetClick: handleUnsetClick,
                  readOnly,
                  value: value == null ? void 0 : value[fieldName]
                },
                fieldName
              )) })
            ]
          }
        )
      ]
    }
  );
}
function UnknownField({
  fieldName,
  onUnsetClick,
  readOnly,
  value
}) {
  const handleUnsetClick = React.useCallback(() => {
    onUnsetClick(fieldName);
  }, [fieldName, onUnsetClick]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { as: "li", overflow: "hidden", radius: 2, shadow: 1, tone: "caution", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: fieldName }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: 1, children: JSON.stringify(value, null, 2) }) }),
    readOnly && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "inputs.object.unknown-fields.read-only.description" }) }) }),
    !readOnly && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.TrashIcon,
        mode: "ghost",
        onClick: handleUnsetClick,
        size: "large",
        tone: "critical",
        text: t2("inputs.object.unknown-fields.remove-field-button.text")
      }
    ) })
  ] });
}
const ObjectInput = React.memo(function(props2) {
  const {
    schemaType,
    groups,
    members,
    onChange,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderInlineBlock,
    renderInput,
    renderField,
    renderItem: renderItem2,
    renderPreview,
    level,
    value,
    id: id2,
    onFieldGroupSelect
  } = props2, { columns } = schemaType.options || {}, renderedUnknownFields = React.useMemo(() => {
    if (!schemaType.fields)
      return null;
    const knownFieldNames = schemaType.fields.map((field) => field.name), unknownFields = Object.keys(value || {}).filter(
      (key) => !key.startsWith("_") && !knownFieldNames.includes(key)
    );
    return unknownFields.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(UnknownFields, { fieldNames: unknownFields, value, onChange });
  }, [onChange, schemaType.fields, value]), selectedGroup = React.useMemo(() => groups.find(({ selected }) => selected), [groups]), renderObjectMembers = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      ObjectInputMembers,
      {
        members,
        renderAnnotation,
        renderBlock: renderBlock2,
        renderField,
        renderInlineBlock,
        renderInput,
        renderItem: renderItem2,
        renderPreview
      }
    ),
    [
      members,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview
    ]
  );
  return members.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 6, children: [
    groups.length > 0 ? /* @__PURE__ */ jsxRuntime.jsx(FieldGroupTabsWrapper, { $level: level, "data-testid": "field-groups", children: /* @__PURE__ */ jsxRuntime.jsx(
      FieldGroupTabs,
      {
        groups,
        inputId: id2,
        onClick: onFieldGroupSelect,
        shouldAutoFocus: !1
      }
    ) }) : null,
    /* @__PURE__ */ jsxRuntime.jsx(
      React.Fragment,
      {
        children: columns ? /* @__PURE__ */ jsxRuntime.jsx(AlignedBottomGrid, { columns, gap: 4, marginTop: 1, children: renderObjectMembers() }) : renderObjectMembers()
      },
      selectedGroup == null ? void 0 : selectedGroup.name
    ),
    renderedUnknownFields
  ] });
});
function GetFormValueProvider(props2) {
  const valueRef = React.useRef(props2.value);
  valueRef.current = props2.value;
  const getValue2 = React.useCallback((path) => getValueAtPath(valueRef.current, path), [valueRef]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.GetFormValueContext.Provider, { value: getValue2, children: props2.children });
}
function useGetFormValue() {
  const ctx = React.useContext(_singletons.GetFormValueContext);
  if (!ctx)
    throw new Error("useFormValue must be used within a FormValueProvider");
  return ctx;
}
const defaultSlugify = (value, type) => {
  var _a2;
  const maxLength = (_a2 = type.options) == null ? void 0 : _a2.maxLength;
  return value ? speakingurl__default.default(value, { truncate: typeof maxLength == "number" ? maxLength : 200, symbols: !0 }) : "";
};
async function slugify(sourceValue, type, context) {
  var _a2;
  return sourceValue && (((_a2 = type.options) == null ? void 0 : _a2.slugify) || defaultSlugify)(sourceValue, type, context);
}
function useAsync(fn, dependencies) {
  const [state, setState] = React.useState(null), lastId = React.useRef(0), wrappedCallback = React.useCallback(
    (arg) => {
      const asyncId = ++lastId.current;
      setState({ status: "pending" }), Promise.resolve().then(() => fn(arg)).then(
        (res) => {
          asyncId === lastId.current && setState({ status: "complete", result: res });
        },
        (err) => {
          asyncId === lastId.current && setState({ status: "error", error: err });
        }
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- this is under control, and enforced by our linter setup
    [fn, ...dependencies]
  );
  return [state, wrappedCallback];
}
function useSlugContext() {
  const { getClient } = useSource(), schema2 = useSchema(), currentUser = useCurrentUser(), projectId = useProjectId(), dataset = useDataset();
  return React.useMemo(() => ({
    projectId,
    dataset,
    getClient,
    schema: schema2,
    currentUser
  }), [getClient, schema2, currentUser, projectId, dataset]);
}
function getSlugSourceContext(valuePath, document2, context) {
  const parentPath = valuePath.slice(0, -1), parent = PathUtils__namespace.get(document2, parentPath);
  return { parentPath, parent, ...context };
}
async function getNewFromSource(source, document2, context) {
  return typeof source == "function" ? source(document2, context) : PathUtils__namespace.get(document2, source);
}
function SlugInput(props2) {
  var _a2;
  const getFormValue = useGetFormValue(), { path, value, schemaType, validation: validation2, onChange, readOnly, elementProps } = props2, sourceField = (_a2 = schemaType.options) == null ? void 0 : _a2.source, errors = React.useMemo(() => validation2.filter((item) => item.level === "error"), [validation2]), slugContext = useSlugContext(), { t: t2 } = useTranslation(), updateSlug = React.useCallback(
    (nextSlug) => {
      if (!nextSlug) {
        onChange(PatchEvent.from(unset([])));
        return;
      }
      onChange(
        PatchEvent.from([setIfMissing({ _type: schemaType.name }), set(nextSlug, ["current"])])
      );
    },
    [onChange, schemaType.name]
  ), [generateState, handleGenerateSlug] = useAsync(() => {
    if (!sourceField)
      return Promise.reject(
        new Error(t2("inputs.slug.error.missing-source", { schemaType: schemaType.name }))
      );
    const doc = getFormValue([]) || { _type: schemaType.name }, sourceContext = getSlugSourceContext(path, doc, slugContext);
    return getNewFromSource(sourceField, doc, sourceContext).then((newFromSource) => slugify(newFromSource || "", schemaType, sourceContext)).then((newSlug) => updateSlug(newSlug));
  }, [sourceField, getFormValue, schemaType, path, slugContext, updateSlug, t2]), isUpdating = (generateState == null ? void 0 : generateState.status) === "pending", handleChange = React.useCallback(
    (event) => updateSlug(event.currentTarget.value),
    [updateSlug]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.TextInput,
        {
          customValidity: errors.length > 0 ? errors[0].message : "",
          disabled: isUpdating,
          onChange: handleChange,
          value: (value == null ? void 0 : value.current) || "",
          readOnly,
          ...elementProps
        }
      ),
      (generateState == null ? void 0 : generateState.status) === "error" && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, tone: "critical", children: generateState.error.message })
    ] }),
    sourceField && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        mode: "ghost",
        type: "button",
        disabled: readOnly || isUpdating,
        onClick: handleGenerateSlug,
        size: "large",
        text: (generateState == null ? void 0 : generateState.status) === "pending" ? t2("inputs.slug.action.generating") : t2("inputs.slug.action.generate")
      }
    )
  ] }) });
}
function StringInput(props2) {
  const { validationError, elementProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...elementProps, customValidity: validationError, "data-testid": "string-input" });
}
const StyledTextArea = styledComponents.styled(ui.TextArea)`
  &[data-as='textarea'] {
    resize: vertical;
  }
`;
function TextInput(props2) {
  const { schemaType, validationError, value, elementProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledTextArea,
    {
      customValidity: validationError,
      value: value || "",
      placeholder: schemaType.placeholder,
      rows: typeof schemaType.rows == "number" ? schemaType.rows : 10,
      ...elementProps
    }
  );
}
function UrlInput(props2) {
  var _a2, _b;
  const { schemaType, validationError, elementProps } = props2, uriRule = getValidationRule(schemaType, "uri"), inputType = (_b = (_a2 = uriRule == null ? void 0 : uriRule.constraint) == null ? void 0 : _a2.options) != null && _b.allowRelative ? "text" : "url";
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      type: inputType,
      inputMode: "url",
      customValidity: validationError,
      ...elementProps
    }
  );
}
function DisabledFeatureWarning({ value, onClearValue }) {
  const hasRef = React.useMemo(() => !!(value != null && value._ref), [value == null ? void 0 : value._ref]), { t: t2 } = useTranslation(), description = /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: "inputs.reference.cross-dataset.feature-disabled-description",
      components: {
        DocumentationLink: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(
          "a",
          {
            href: "https://www.sanity.io/docs/cross-dataset-references",
            target: "_blank",
            rel: "noreferrer",
            children
          }
        )
      }
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Card,
    {
      tone: "caution",
      padding: 4,
      border: !0,
      radius: 2,
      "data-testid": "alert-cross-dataset-reference-feature-disabled",
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: hasRef ? 4 : void 0, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h2", size: 1, weight: "medium", children: t2("inputs.reference.cross-dataset.feature-unavailable-title") }),
            hasRef && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: description }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: t2("inputs.reference.cross-dataset.feature-disabled-actions") })
            ] }),
            !hasRef && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: description })
          ] })
        ] }),
        onClearValue && hasRef && /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            icon: icons.ResetIcon,
            mode: "ghost",
            onClick: onClearValue,
            text: t2("inputs.reference.action.clear"),
            width: "fill"
          }
        )
      ]
    }
  );
}
const StyledPreviewFlex = styledComponents.styled(ui.Flex)`
  /* this is a hack to avoid layout jumps while previews are loading
  or the message is not tall enough to fill the card
  there's probably better ways of solving this */
  min-height: 36px;
`;
function CrossDatasetReferencePreview(props2) {
  var _a2, _b, _c;
  const {
    refType,
    showStudioUrlIcon,
    hasStudioUrl,
    showTypeLabel,
    availability,
    preview,
    id: id2,
    dataset,
    projectId
  } = props2, notFound = (availability == null ? void 0 : availability.reason) === "NOT_FOUND", insufficientPermissions = (availability == null ? void 0 : availability.reason) === "PERMISSION_DENIED", previewMedia = (_a2 = preview.published) == null ? void 0 : _a2.media, { t: t2 } = useTranslation(), media = React.useMemo(() => {
    if (previewMedia) {
      const isValidImageAsset = typeof (previewMedia == null ? void 0 : previewMedia.asset) < "u" && assetUtils.isImageSource(previewMedia), isValidElement = React.isValidElement(previewMedia);
      return !isValidImageAsset && !isValidElement ? null : function({ dimensions }) {
        return isValidElement ? previewMedia : /* @__PURE__ */ jsxRuntime.jsx(
          "img",
          {
            src: imageUrlBuilder__default.default({ dataset, projectId }).image(previewMedia).withOptions(dimensions).url(),
            alt: t2("inputs.reference.image-preview-alt-text"),
            referrerPolicy: "strict-origin-when-cross-origin"
          }
        );
      };
    }
    return refType != null && refType.icon ? React.createElement(refType.icon) : null;
  }, [previewMedia, dataset, projectId, refType == null ? void 0 : refType.icon, t2]);
  return /* @__PURE__ */ jsxRuntime.jsxs(StyledPreviewFlex, { align: "center", justify: "center", flex: 1, "data-testid": "preview", children: [
    availability != null && availability.available ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      DefaultPreview,
      {
        title: (_b = preview.published) == null ? void 0 : _b.title,
        subtitle: (_c = preview.published) == null ? void 0 : _c.subtitle,
        media: media || !1
      }
    ) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: t2("inputs.reference.error.document-unavailable-title") }) }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 4, children: [
      refType && showTypeLabel && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { mode: "outline", children: refType.title || refType.type }),
      (insufficientPermissions || notFound) && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Tooltip,
        {
          portal: !0,
          content: t2(
            notFound ? "inputs.reference.referenced-document-does-not-exist" : "inputs.reference.referenced-document-insufficient-permissions",
            { documentId: id2 }
          ),
          children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", children: insufficientPermissions ? /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.HelpCircleIcon, {}) })
        }
      ) }),
      !(notFound || insufficientPermissions) && showStudioUrlIcon && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Tooltip,
        {
          portal: !0,
          content: t2(
            hasStudioUrl ? "inputs.reference.document-opens-in-new-tab" : "input.reference.document-cannot-be-opened.failed-to-resolve-url"
          ),
          children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "default", muted: !hasStudioUrl, children: /* @__PURE__ */ jsxRuntime.jsx(icons.LaunchIcon, {}) })
        }
      ) })
    ] }) })
  ] });
}
const noop$1 = () => {
}, INITIAL_LOADING_STATE$1 = {
  isLoading: !0,
  result: void 0,
  error: void 0,
  retry: noop$1
}, EMPTY_STATE = {
  isLoading: !1,
  result: void 0,
  error: void 0,
  retry: noop$1
};
function useReferenceInfo(doc, getReferenceInfo2) {
  const [retryAttempt, setRetryAttempt] = React.useState(0), retry = React.useCallback(() => {
    setRetryAttempt((current) => current + 1);
  }, []), docInfo = React.useMemo(() => ({ _id: doc._id, _type: doc._type }), [doc._id, doc._type]), referenceInfo = reactRx.useMemoObservable(
    () => docInfo._id ? getReferenceInfo2(docInfo).pipe(
      operators.map(
        (result) => ({
          isLoading: !1,
          result,
          error: void 0,
          retry,
          retryAttempt
        })
      ),
      operators.startWith(INITIAL_LOADING_STATE$1),
      operators.catchError((err) => (console.error(err), rxjs.of({
        isLoading: !1,
        result: void 0,
        error: err,
        retry,
        retryAttempt
      })))
    ) : rxjs.of(EMPTY_STATE),
    [docInfo, getReferenceInfo2, retry, retryAttempt],
    INITIAL_LOADING_STATE$1
  ), previousId = usePrevious(doc._id, doc._id);
  return doc._id && previousId !== doc._id ? INITIAL_LOADING_STATE$1 : referenceInfo;
}
function useProjectId$1() {
  return useClient(DEFAULT_STUDIO_CLIENT_OPTIONS).config().projectId;
}
function OptionPreview(props2) {
  var _a2;
  const {
    isLoading,
    result: referenceInfo,
    error
  } = useReferenceInfo(props2.document, props2.getReferenceInfo), { t: t2 } = useTranslation(), projectId = useProjectId$1();
  if (isLoading)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, padding: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: !0 })
    ] });
  if (error)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Alert, { title: t2("inputs.reference.error.failed-to-load-document-title"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: error.message }) }) });
  if (!referenceInfo)
    return null;
  if (((_a2 = referenceInfo.availability) == null ? void 0 : _a2.reason) === "PERMISSION_DENIED")
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.missing-read-permissions-description") });
  const refType = props2.referenceType.to.find((toEntry) => toEntry.type === referenceInfo.type);
  return refType ? referenceInfo && refType && /* @__PURE__ */ jsxRuntime.jsx(
    CrossDatasetReferencePreview,
    {
      id: referenceInfo.id,
      availability: referenceInfo.availability,
      preview: referenceInfo.preview,
      refType,
      dataset: props2.referenceType.dataset,
      projectId,
      showTypeLabel: props2.referenceType.to.length > 1
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 1, children: t2("inputs.reference.error.invalid-search-result-type-title", {
    returnedType: referenceInfo.type
  }) });
}
function PreviewReferenceValue(props2) {
  var _a2, _b;
  const { value, type, showStudioUrlIcon, hasStudioUrl, referenceInfo } = props2, { t: t2 } = useTranslation(), projectId = useProjectId$1();
  if (referenceInfo.isLoading || referenceInfo.error)
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, padding: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 320 }, radius: 1, animated: !referenceInfo.error }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { maxWidth: 200 }, radius: 1, size: 1, animated: !referenceInfo.error })
    ] });
  const showTypeLabel = type.to.length > 1, refTypeName = (_a2 = referenceInfo.result) == null ? void 0 : _a2.type, refType = type.to.find((toType) => toType.type === refTypeName);
  return (_b = referenceInfo.result.availability) != null && _b.available && !refType ? /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: "inputs.reference.cross-dataset.invalid-type",
      values: { typeName: refTypeName || "unknown" },
      components: { JsonValue: () => /* @__PURE__ */ jsxRuntime.jsx("pre", { children: JSON.stringify(value, null, 2) }) }
    }
  ) }) }) : /* @__PURE__ */ jsxRuntime.jsx(
    CrossDatasetReferencePreview,
    {
      availability: referenceInfo.result.availability,
      hasStudioUrl,
      showStudioUrlIcon,
      preview: referenceInfo.result.preview,
      refType,
      projectId,
      dataset: type.dataset,
      id: value._ref,
      showTypeLabel
    }
  );
}
const StyledPopover$4 = styledComponents.styled(TooltipDelayGroupProvider.Popover)`
  & > div {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }
`, StyledText$4 = styledComponents.styled(ui.Text)`
  word-break: break-word;
`, FALLBACK_PLACEMENTS$1 = ["top-start", "bottom-start"], ReferenceAutocomplete$1 = React.forwardRef(function(props2, ref) {
  const { searchString, loading, portalRef, referenceElement, ...restProps } = props2, { t: t2 } = useTranslation(), hasResults = props2.options && props2.options.length > 0, renderPopover = React.useCallback(
    ({
      content: content2,
      hidden,
      inputElement,
      onMouseEnter,
      onMouseLeave
    }, contentRef) => /* @__PURE__ */ jsxRuntime.jsx(
      StyledPopover$4,
      {
        "data-testid": "autocomplete-popover",
        placement: "bottom-start",
        fallbackPlacements: FALLBACK_PLACEMENTS$1,
        arrow: !1,
        constrainSize: !0,
        onMouseEnter,
        onMouseLeave,
        content: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: contentRef, children: hasResults ? content2 : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(StyledText$4, { align: "center", muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
          Translate,
          {
            t: t2,
            i18nKey: "inputs.reference.no-results-for-query",
            values: { searchTerm: searchString || "" }
          }
        ) }) }) }) }),
        open: !loading && !hidden,
        ref: portalRef,
        portal: !0,
        referenceElement: referenceElement || inputElement,
        matchReferenceWidth: !0
      }
    ),
    [hasResults, t2, searchString, loading, portalRef, referenceElement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Autocomplete, { ...restProps, ref, renderPopover });
}), INITIAL_SEARCH_STATE$1 = {
  hits: [],
  isLoading: !1
}, NO_FILTER$1 = () => !0, REF_PATH = ["_ref"], CROSS_DATASET_FEATUREKEY = "crossDatasetReferences";
function CrossDatasetReferenceInput(props2) {
  var _a2, _b;
  const {
    changed,
    focused,
    focusPath,
    getReferenceInfo: getReferenceInfo2,
    onChange,
    onPathFocus,
    onSearch,
    path,
    readOnly,
    schemaType,
    validation: validation2,
    value,
    elementProps
  } = props2, { t: t2 } = useTranslation(), projectId = useProjectId$1(), [searchState, setSearchState] = React.useState(INITIAL_SEARCH_STATE$1), handleChange = React.useCallback(
    (id2) => {
      if (!id2) {
        onChange(unset()), onPathFocus([]);
        return;
      }
      if (!searchState.hits.find((h) => h.id === id2))
        throw new Error("Selected an item that wasnt part of the result set");
      onChange(
        set({
          _type: schemaType.name,
          _ref: getPublishedId(id2),
          _projectId: projectId,
          _dataset: schemaType.dataset,
          _weak: schemaType.weak,
          // persist _key between mutations if the value is in an array
          _key: value == null ? void 0 : value._key
        })
      ), onPathFocus([]);
    },
    [
      value == null ? void 0 : value._key,
      searchState.hits,
      schemaType.name,
      schemaType.dataset,
      schemaType.weak,
      projectId,
      onChange,
      onPathFocus
    ]
  ), handleClear = React.useCallback(() => {
    onChange(unset());
  }, [onChange]), handleAutocompleteKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && (onPathFocus == null || onPathFocus([]));
    },
    [onPathFocus]
  ), getReferenceInfoMemo = React.useCallback(
    (doc) => getReferenceInfo2(doc, schemaType),
    [getReferenceInfo2, schemaType]
  ), refDoc = React.useMemo(() => ({ _id: value == null ? void 0 : value._ref }), [value == null ? void 0 : value._ref]), loadableReferenceInfo = useReferenceInfo(refDoc, getReferenceInfoMemo), featureInfo = useFeatureEnabled(CROSS_DATASET_FEATUREKEY), autocompletePopoverReferenceElementRef = React.useRef(null), hasFocusAtRef = focusPath.length === 1 && focusPath[0] === "_ref", focusElementRef = elementProps.ref;
  useDidUpdate({ hasFocusAt: hasFocusAtRef, ref: value == null ? void 0 : value._ref }, (prev, current) => {
    var _a22;
    const refUpdated = (prev == null ? void 0 : prev.ref) !== current.ref;
    ((prev == null ? void 0 : prev.hasFocusAt) !== current.hasFocusAt || refUpdated) && current.hasFocusAt && ((_a22 = focusElementRef.current) == null || _a22.focus());
  });
  const actualStrength = value != null && value._weak ? "weak" : "strong", weakShouldBe = schemaType.weak === !0 ? "weak" : "strong", hasRef = !!(value != null && value._ref), handleFixStrengthMismatch = React.useCallback(() => {
    onChange(schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]));
  }, [onChange, schemaType]), { push } = ui.useToast(), errors = React.useMemo(() => validation2.filter((item) => item.level === "error"), [validation2]), handleFocus = React.useCallback(
    (event) => {
      event.currentTarget === elementProps.ref.current && (onPathFocus == null || onPathFocus([PathUtils.FOCUS_TERMINATOR]));
    },
    [elementProps.ref, onPathFocus]
  ), handleAutocompleteFocus = React.useCallback(
    (event) => {
      event.currentTarget === elementProps.ref.current && (onPathFocus == null || onPathFocus(REF_PATH));
    },
    [elementProps.ref, onPathFocus]
  ), handleReplace = React.useCallback(() => {
    onPathFocus == null || onPathFocus(REF_PATH);
  }, [onPathFocus]), inputId = React.useId(), handleQueryChange = reactRx.useObservableCallback(
    (inputValue$) => inputValue$.pipe(
      operators.filter(isNonNullable$3),
      operators.distinctUntilChanged(),
      operators.switchMap(
        (searchString) => rxjs.concat(
          rxjs.of({ isLoading: !0 }),
          onSearch(searchString).pipe(
            operators.map((hits) => ({ hits, searchString, isLoading: !1 })),
            operators.catchError((error) => (push({
              title: "Reference search failed",
              description: error.message,
              status: "error",
              id: `reference-search-fail-${inputId}`
            }), console.error(error), rxjs.of({ hits: [] })))
          )
        )
      ),
      operators.scan(
        (prevState, nextState) => ({ ...prevState, ...nextState }),
        INITIAL_SEARCH_STATE$1
      ),
      operators.tap(setSearchState)
    ),
    [inputId, onSearch, push]
  ), handleAutocompleteOpenButtonClick = React.useCallback(() => {
    handleQueryChange("");
  }, [handleQueryChange]), showWeakRefMismatch = !loadableReferenceInfo.isLoading && hasRef && actualStrength !== weakShouldBe, studioUrl = (value == null ? void 0 : value._ref) && ((_b = schemaType.studioUrl) == null ? void 0 : _b.call(schemaType, {
    id: value == null ? void 0 : value._ref,
    type: (_a2 = loadableReferenceInfo == null ? void 0 : loadableReferenceInfo.result) == null ? void 0 : _a2.type
  })) || null, renderOption = React.useCallback(
    (option) => /* @__PURE__ */ jsxRuntime.jsx(PreviewCard, { as: "button", type: "button", radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 3, paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      OptionPreview,
      {
        referenceType: schemaType,
        document: option.hit.published,
        getReferenceInfo: getReferenceInfoMemo
      }
    ) }) }),
    [schemaType, getReferenceInfoMemo]
  ), isEditing = hasFocusAtRef || !(value != null && value._ref), clickOutsideBoundaryRef = React.useRef(null), autocompletePortalRef = React.useRef(null), createButtonMenuPortalRef = React.useRef(null);
  return useOnClickOutside(
    [clickOutsideBoundaryRef, autocompletePortalRef, createButtonMenuPortalRef],
    () => {
      hasFocusAtRef && onPathFocus([]);
    }
  ), /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    !featureInfo.isLoading && !featureInfo.enabled && /* @__PURE__ */ jsxRuntime.jsx(DisabledFeatureWarning, { value, onClearValue: handleClear }),
    (featureInfo.isLoading || featureInfo.enabled) && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: isEditing ? /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, ref: clickOutsideBoundaryRef, children: /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: autocompletePopoverReferenceElementRef, children: /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceAutocomplete$1,
      {
        ...elementProps,
        "data-testid": "autocomplete",
        loading: searchState.isLoading,
        referenceElement: autocompletePopoverReferenceElementRef.current,
        portalRef: autocompletePortalRef,
        id: inputId || "",
        options: searchState.hits.map((hit) => ({
          value: hit.id,
          hit
        })),
        onFocus: handleAutocompleteFocus,
        radius: 2,
        placeholder: t2("inputs.reference.search-placeholder"),
        onKeyDown: handleAutocompleteKeyDown,
        readOnly,
        disabled: loadableReferenceInfo.isLoading,
        onQueryChange: handleQueryChange,
        searchString: searchState.searchString,
        onChange: handleChange,
        filterOption: NO_FILTER$1,
        renderOption,
        openButton: { onClick: handleAutocompleteOpenButtonClick }
      }
    ) }) }) }) : /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Card,
      {
        padding: 0,
        border: !0,
        flex: 1,
        radius: 1,
        tone: readOnly ? "transparent" : loadableReferenceInfo.error || errors.length > 0 ? "critical" : "default",
        children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", padding: 1, children: [
            studioUrl ? /* @__PURE__ */ jsxRuntime.jsx(
              PreviewCard,
              {
                as: "a",
                target: "_blank",
                rel: "noopener noreferrer",
                href: studioUrl,
                "data-as": "a",
                flex: 1,
                padding: 1,
                paddingRight: 3,
                radius: 2,
                tone: "inherit",
                __unstable_focusRing: !0,
                tabIndex: 0,
                onFocus: handleFocus,
                ref: elementProps.ref,
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  PreviewReferenceValue,
                  {
                    value,
                    referenceInfo: loadableReferenceInfo,
                    showStudioUrlIcon: !0,
                    hasStudioUrl: !!studioUrl,
                    type: schemaType
                  }
                )
              }
            ) : /* @__PURE__ */ jsxRuntime.jsx(
              PreviewCard,
              {
                flex: 1,
                padding: 1,
                paddingRight: 3,
                radius: 2,
                tone: "inherit",
                __unstable_focusRing: !0,
                tabIndex: 0,
                onFocus: handleFocus,
                ref: elementProps.ref,
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  PreviewReferenceValue,
                  {
                    value,
                    referenceInfo: loadableReferenceInfo,
                    showStudioUrlIcon: !0,
                    type: schemaType
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuButton,
              {
                button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, { "data-testid": "menu-button" }),
                id: `${inputId}-menuButton`,
                menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: !readOnly && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntime.jsx(
                    TooltipDelayGroupProvider.MenuItem,
                    {
                      text: t2("inputs.reference.action.clear"),
                      tone: "critical",
                      icon: icons.ResetIcon,
                      "data-testid": "menu-item-clear",
                      onClick: handleClear
                    }
                  ),
                  /* @__PURE__ */ jsxRuntime.jsx(
                    TooltipDelayGroupProvider.MenuItem,
                    {
                      text: t2("inputs.reference.action.replace"),
                      icon: icons.SyncIcon,
                      "data-testid": "menu-item-replace",
                      onClick: handleReplace
                    }
                  )
                ] }) }),
                placement: "right",
                popover: { portal: !0, tone: "default" }
              }
            ) })
          ] }),
          showWeakRefMismatch && /* @__PURE__ */ jsxRuntime.jsx(
            ReferenceStrengthMismatchAlertStrip,
            {
              actualStrength,
              handleFixStrengthMismatch
            }
          ),
          loadableReferenceInfo.error && /* @__PURE__ */ jsxRuntime.jsx(
            ReferenceMetadataLoadErrorAlertStrip,
            {
              errorMessage: loadableReferenceInfo.error.message,
              onHandleRetry: loadableReferenceInfo.retry
            }
          )
        ]
      }
    ) }) })
  ] });
}
const REQUEST_TAG_BASE = "cross-dataset-refs", AVAILABILITY_READABLE$1 = {
  available: !0,
  reason: "READABLE"
}, AVAILABILITY_PERMISSION_DENIED$1 = {
  available: !1,
  reason: "PERMISSION_DENIED"
}, AVAILABILITY_NOT_FOUND$1 = {
  available: !1,
  reason: "NOT_FOUND"
};
function createGetReferenceInfo(context) {
  const { client: client2, documentPreviewStore } = context, { dataset, projectId } = client2.config(), apiConfig = dataset && projectId ? { dataset, projectId } : void 0;
  return function(doc, referenceType) {
    return (doc._type ? rxjs.of(doc) : documentPreviewStore.observeDocumentTypeFromId(doc._id, apiConfig).pipe(operators.map((docType) => ({ _id: doc._id, _type: docType })))).pipe(
      operators.switchMap((resolvedDoc) => {
        if (!resolvedDoc._type)
          return fetchDocumentAvailability(client2, doc._id).pipe(
            operators.map((availability) => ({
              id: doc._id,
              type: void 0,
              availability,
              preview: { published: void 0 }
            }))
          );
        const refSchemaType = referenceType.to.find(
          (candidate) => candidate.type === resolvedDoc._type
        ), previewPaths = getPreviewPaths(refSchemaType == null ? void 0 : refSchemaType.preview) || [], publishedPreview$ = documentPreviewStore.observePaths(doc, previewPaths, apiConfig).pipe(
          operators.map((result) => result && prepareForPreview(result, refSchemaType))
        );
        return rxjs.combineLatest([publishedPreview$]).pipe(
          operators.map(([publishedPreview]) => ({
            type: resolvedDoc._type,
            id: doc._id,
            availability: AVAILABILITY_READABLE$1,
            preview: {
              published: isRecord$4(publishedPreview) ? publishedPreview : void 0
            }
          }))
        );
      })
    );
  };
}
function fetchDocumentAvailability(client2, id2) {
  const requestOptions = {
    uri: client2.getDataUrl("doc", id2),
    json: !0,
    query: { excludeContent: "true" },
    tag: `${REQUEST_TAG_BASE}.availability`
  };
  return client2.observable.request(requestOptions).pipe(
    operators.map((response) => {
      const omittedEntry = keyBy__default.default(response.omitted || [], (entry) => entry.id)[id2];
      return omittedEntry ? omittedEntry.reason === "existence" ? AVAILABILITY_NOT_FOUND$1 : omittedEntry.reason === "permission" ? AVAILABILITY_PERMISSION_DENIED$1 : null : AVAILABILITY_READABLE$1;
    })
  );
}
function search(client2, textTerm, type, options) {
  return createSearch(type.to, client2, {
    ...options,
    maxDepth: options.maxFieldDepth
  })(textTerm, {
    includeDrafts: !1,
    isCrossDataset: !0
  }).pipe(
    operators.map(({ hits }) => hits.map(({ hit }) => hit)),
    operators.map(collate),
    operators.map(
      (collated) => collated.map((entry) => ({
        id: entry.id,
        type: entry.type,
        published: entry.published
      }))
    )
  );
}
async function resolveUserDefinedFilter(options, document2, valuePath, getClient) {
  if (!options)
    return {};
  if (typeof options.filter == "function") {
    const parentPath = valuePath.slice(0, -1), parent = PathUtils.get(document2, parentPath);
    return await options.filter({ document: document2, parentPath, parent, getClient });
  }
  return {
    filter: options.filter,
    params: "filterParams" in options ? options.filterParams : void 0
  };
}
function useValueRef(value) {
  const ref = React.useRef(value);
  return ref.current = value, ref;
}
function StudioCrossDatasetReferenceInput(props2) {
  const { path, schemaType } = props2, source = useSource(), client2 = source.getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentPreviewStore = useDocumentPreviewStore(), getClient = source.getClient, { enableLegacySearch = !1 } = source.search, crossDatasetClient = React.useMemo(() => client2.withConfig({
    dataset: schemaType.dataset,
    apiVersion: "2023-11-13",
    ignoreBrowserTokenWarning: !0
  }).clone(), [client2, schemaType.dataset]), maxFieldDepth = useSearchMaxFieldDepth(crossDatasetClient), documentValue = useFormValue([]), documentRef = useValueRef(documentValue), handleSearch = React.useCallback(
    (searchString) => rxjs.from(resolveUserDefinedFilter(schemaType.options, documentRef.current, path, getClient)).pipe(
      operators.mergeMap(
        ({ filter, params }) => search(crossDatasetClient, searchString, schemaType, {
          ...schemaType.options,
          filter,
          params,
          tag: "search.cross-dataset-reference",
          maxFieldDepth,
          enableLegacySearch
        })
      ),
      operators.catchError((err) => {
        var _a2;
        const isQueryError = err.details && err.details.type === "queryParseError";
        return (_a2 = schemaType.options) != null && _a2.filter && isQueryError && (err.message = 'Invalid reference filter, please check the custom "filter" option'), rxjs.throwError(err);
      })
    ),
    [
      schemaType,
      documentRef,
      path,
      getClient,
      crossDatasetClient,
      maxFieldDepth,
      enableLegacySearch
    ]
  ), getReferenceInfo2 = React.useMemo(
    () => createGetReferenceInfo({ client: crossDatasetClient, documentPreviewStore }),
    [crossDatasetClient, documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CrossDatasetReferenceInput,
    {
      ...props2,
      getReferenceInfo: getReferenceInfo2,
      onSearch: handleSearch
    }
  );
}
function WithReferencedAsset(props2) {
  const { reference, children, observeAsset, waitPlaceholder } = props2, documentId = reference == null ? void 0 : reference._ref, asset = reactRx.useMemoObservable(() => observeAsset(documentId), [documentId, observeAsset]);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: documentId && asset ? children(asset) : waitPlaceholder });
}
const FileMenuItem = styledComponents.styled(TooltipDelayGroupProvider.MenuItem)`
  position: relative;

  & input {
    overflow: hidden;
    overflow: clip;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    position: absolute;
    min-width: 0;
    display: block;
    appearance: none;
    padding: 0;
    margin: 0;
    border: 0;
    opacity: 0;
  }
`, FileInputMenuItem = React.forwardRef(function(props2, forwardedRef) {
  const { icon, id: idProp, accept, capture, multiple, onSelect, text, disabled, ...rest } = props2, id2 = `${idProp || ""}-${React.useId()}`, handleChange = React.useCallback(
    (event) => {
      onSelect && event.target.files && onSelect(Array.from(event.target.files));
    },
    [onSelect]
  ), renderMenuItem = React.useCallback(
    (item) => /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
      item,
      /* @__PURE__ */ jsxRuntime.jsx(
        "input",
        {
          "data-testid": "file-menuitem-input",
          accept,
          capture,
          id: id2,
          multiple,
          onChange: handleChange,
          type: "file",
          value: "",
          disabled
        }
      )
    ] }),
    [accept, capture, disabled, handleChange, id2, multiple]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    FileMenuItem,
    {
      ...rest,
      htmlFor: id2,
      disabled,
      ref: forwardedRef,
      icon,
      text,
      renderMenuItem
    }
  );
});
function ActionsMenu(props2) {
  const { onUpload, onReset, readOnly, accept, directUploads, browse, downloadUrl, copyUrl } = props2, { push: pushToast } = ui.useToast(), { t: t2 } = useTranslation(), handleCopyURL = React.useCallback(() => {
    navigator.clipboard.writeText(copyUrl || ""), pushToast({
      closable: !0,
      status: "success",
      title: t2("inputs.files.common.actions-menu.notification.url-copied")
    });
  }, [copyUrl, pushToast, t2]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      FileInputMenuItem,
      {
        icon: icons.UploadIcon,
        onSelect: onUpload,
        accept,
        text: t2("inputs.files.common.actions-menu.upload.label"),
        "data-testid": "file-input-upload-button",
        disabled: readOnly || !directUploads
      }
    ),
    browse,
    (downloadUrl || copyUrl) && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    downloadUrl && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        as: "a",
        icon: icons.DownloadIcon,
        text: t2("inputs.files.common.actions-menu.download.label"),
        href: downloadUrl
      }
    ),
    copyUrl && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        icon: icons.CopyIcon,
        text: t2("inputs.files.common.actions-menu.copy-url.label"),
        onClick: handleCopyURL
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        tone: "critical",
        icon: icons.ResetIcon,
        text: t2("inputs.files.common.actions-menu.clear-field.label"),
        onClick: onReset,
        disabled: readOnly,
        "data-testid": "file-input-clear"
      }
    )
  ] });
}
function urlToFile(url, filename) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      const reader = new FileReader();
      reader.onloadend = () => {
        var _a2;
        const string = (_a2 = reader.result) == null ? void 0 : _a2.toString(), base64Index = string == null ? void 0 : string.indexOf(";base64");
        if (!string || base64Index === -1) {
          reject(new Error("Could not convert URL to file"));
          return;
        }
        const ext = string.slice(11, base64Index);
        if (!ext && !filename) {
          reject(new Error("Could not find mime type for image"));
          return;
        }
        resolve(dataURLtoFile(reader.result, filename || `${uuid.uuid()}.${ext}`));
      }, reader.readAsDataURL(xhr.response);
    }, xhr.onerror = (error) => {
      reject(error);
    }, xhr.open("GET", url), xhr.responseType = "blob", xhr.send();
  });
}
function base64ToFile(base64Data, filename) {
  return new Promise((resolve, reject) => {
    const string = base64Data.toString(), base64Index = string.indexOf(";base64");
    if (!string || base64Index === -1) {
      reject(new Error("Could not convert base64 to file"));
      return;
    }
    const ext = string.slice(11, base64Index);
    if (!ext && !filename) {
      reject(new Error("Could not find mime type for image"));
      return;
    }
    resolve(dataURLtoFile(base64Data, filename || `${uuid.uuid()}.${ext}`));
  });
}
function dataURLtoFile(dataurl, filename) {
  var _a2;
  const arr = dataurl.split(","), mime = (_a2 = arr[0].match(/:(.*?);/)) == null ? void 0 : _a2[1], bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  for (; n--; )
    u8arr[n] = bstr.charCodeAt(n);
  return new File([u8arr], filename, { type: mime });
}
function handleSelectAssetFromSource({
  assetFromSource,
  onChange,
  type,
  resolveUploader: resolveUploader2,
  uploadWith,
  isImage
}) {
  if (!assetFromSource)
    throw new Error("No asset given");
  if (!Array.isArray(assetFromSource) || assetFromSource.length === 0)
    throw new Error("Returned value must be an array with at least one item (asset)");
  const firstAsset = assetFromSource[0], assetProps = firstAsset.assetDocumentProps, originalFilename = assetProps == null ? void 0 : assetProps.originalFilename, label = assetProps == null ? void 0 : assetProps.label, title = assetProps == null ? void 0 : assetProps.title, description = assetProps == null ? void 0 : assetProps.description, creditLine = assetProps == null ? void 0 : assetProps.creditLine, source = assetProps == null ? void 0 : assetProps.source, imagePatches = isImage ? [unset(["hotspot"]), unset(["crop"])] : [];
  switch (firstAsset.kind) {
    case "assetDocumentId":
      onChange([
        setIfMissing({
          _type: type.name
        }),
        ...imagePatches,
        set(
          {
            _type: "reference",
            _ref: firstAsset.value
          },
          ["asset"]
        )
      ]);
      break;
    case "file": {
      const uploader = resolveUploader2(type, firstAsset.value);
      uploader && uploadWith(uploader, firstAsset.value, {
        label,
        title,
        description,
        creditLine,
        source
      });
      break;
    }
    case "base64":
      base64ToFile(firstAsset.value, originalFilename).then((file) => {
        const uploader = resolveUploader2(type, file);
        uploader && uploadWith(uploader, file, { label, title, description, creditLine, source });
      });
      break;
    case "url":
      urlToFile(firstAsset.value, originalFilename).then((file) => {
        const uploader = resolveUploader2(type, file);
        uploader && uploadWith(uploader, file, { label, title, description, creditLine, source });
      });
      break;
    default:
      throw new Error("Invalid value returned from asset source plugin");
  }
}
const RootFlex$5 = styledComponents.styled(ui.Flex)`
  pointer-events: none;
`;
function PlaceholderText(props2) {
  const { hoveringFiles, type, readOnly, acceptedFiles, rejectedFilesCount, directUploads } = props2, isFileType = type === "file", { t: t2 } = useTranslation(), messageIcon = React.useMemo(() => readOnly ? /* @__PURE__ */ jsxRuntime.jsx(icons.ReadOnlyIcon, {}) : hoveringFiles && rejectedFilesCount > 0 || !directUploads ? /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) : isFileType ? /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.ImageIcon, {}), [directUploads, hoveringFiles, isFileType, readOnly, rejectedFilesCount]), messageText = React.useMemo(() => {
    if (!directUploads)
      return t2("inputs.files.common.placeholder.upload-not-supported");
    if (readOnly)
      return t2("inputs.files.common.placeholder.read-only");
    if (hoveringFiles && directUploads && !readOnly) {
      if (acceptedFiles.length > 0)
        return t2("inputs.files.common.placeholder.drop-to-upload", { context: type });
      if (rejectedFilesCount > 0)
        return t2("inputs.files.common.placeholder.cannot-upload-some-files", {
          count: rejectedFilesCount
        });
    }
    return t2("inputs.files.common.placeholder.drag-or-paste-to-upload", { context: type });
  }, [acceptedFiles.length, directUploads, hoveringFiles, readOnly, rejectedFilesCount, t2, type]);
  return /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$5, { align: "center", gap: 3, justify: "center", paddingLeft: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: messageIcon }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: messageText })
  ] });
}
const FileTarget = withFocusRing(fileTarget(ui.Card)), FileButton = styledComponents.styled(TooltipDelayGroupProvider.Button).attrs({ forwardedAs: "label" })(
  ({ theme: theme2 }) => {
    const { focusRing } = theme2.sanity, base = theme2.sanity.color.base;
    return styledComponents.css`
      &:not([data-disabled='true']) {
        &:focus-within {
          box-shadow: ${focusRingStyle$1({ base, border: { width: 1, color: "var(--card-border-color)" }, focusRing })};
        }
      }

      // The underlying file input is rendered as children within a Sanity UI <Button> component.
      // The below visibly hides it by targeting the input's parent <span> element, which is
      // added by the <Button> component.
      // TODO: refactor, avoid nth-child selector usage
      & > span:nth-child(2) {
        overflow: hidden;
        overflow: clip;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        position: absolute;
        min-width: 0;
        display: block;
        appearance: none;
        padding: 0;
        margin: 0;
        border: 0;
        opacity: 0;
      }
    `;
  }
), FileInputButton = React.forwardRef(function(props2, forwardedRef) {
  const { icon, id: idProp, accept, capture, multiple, onSelect, text, disabled, ...rest } = props2, id2 = `${idProp || ""}-${React.useId()}`, handleChange = React.useCallback(
    (event) => {
      onSelect && event.target.files && onSelect(Array.from(event.target.files));
    },
    [onSelect]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(FileButton, { ...rest, icon, text, htmlFor: id2, disabled, children: /* @__PURE__ */ jsxRuntime.jsx(
    "input",
    {
      "data-testid": "file-button-input",
      accept,
      capture,
      id: id2,
      multiple,
      onChange: handleChange,
      ref: forwardedRef,
      type: "file",
      value: "",
      disabled
    }
  ) });
});
function UploadPlaceholderComponent(props2) {
  const {
    accept,
    acceptedFiles,
    browse,
    directUploads,
    hoveringFiles,
    onUpload,
    readOnly,
    rejectedFilesCount,
    type
  } = props2, [rootElement, setRootElement] = React.useState(null), rect = ui.useElementSize(rootElement), collapsed = (rect == null ? void 0 : rect.border) && rect.border.width < 440, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: collapsed ? void 0 : "center",
      direction: collapsed ? "column" : "row",
      gap: 4,
      justify: "space-between",
      paddingY: collapsed ? 1 : void 0,
      ref: setRootElement,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          PlaceholderText,
          {
            acceptedFiles,
            directUploads,
            hoveringFiles,
            readOnly,
            rejectedFilesCount,
            type
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, justify: "center", wrap: "wrap", children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            FileInputButton,
            {
              accept,
              "data-testid": "file-input-upload-button",
              disabled: readOnly || !directUploads,
              icon: icons.UploadIcon,
              mode: "bleed",
              onSelect: onUpload,
              text: t2("input.files.common.upload-placeholder.file-input-button.text")
            }
          ),
          browse
        ] })
      ]
    }
  );
}
const UploadPlaceholder = React.memo(UploadPlaceholderComponent), STALE_UPLOAD_MS = 12e4, CardWrapper = styledComponents.styled(ui.Card)`
  min-height: 82px;
  box-sizing: border-box;
`, FlexWrapper = styledComponents.styled(ui.Flex)`
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, LeftSection = styledComponents.styled(ui.Stack)`
  position: relative;
  width: 60%;
`, CodeWrapper = styledComponents.styled(ui.Code)`
  position: relative;
  width: 100%;

  code {
    overflow: hidden;
    overflow: clip;
    text-overflow: ellipsis;
    position: relative;
    max-width: 200px;
  }
`, elapsedMs = (date) => (/* @__PURE__ */ new Date()).getTime() - new Date(date).getTime();
function UploadProgress({ uploadState, onCancel, onStale, height }) {
  const filename = uploadState.file.name;
  React.useEffect(() => {
    elapsedMs(uploadState.updatedAt) > STALE_UPLOAD_MS && (onStale == null || onStale());
  }, [uploadState.updatedAt, onStale]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(CardWrapper, { tone: "primary", padding: 4, border: !0, style: { height: `${height}px` }, children: /* @__PURE__ */ jsxRuntime.jsxs(FlexWrapper, { align: "center", justify: "space-between", height: "fill", direction: "row", gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(LeftSection, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", gap: [3, 3, 2, 2], direction: ["column", "column", "row"], children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
        Translate,
        {
          t: t2,
          i18nKey: "input.files.common.upload-progress",
          components: {
            FileName: () => /* @__PURE__ */ jsxRuntime.jsx(CodeWrapper, { size: 1, children: filename || "\u2026" })
          }
        }
      ) }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, marginTop: 3, radius: 5, children: /* @__PURE__ */ jsxRuntime.jsx(LinearProgress, { value: uploadState.progress }) })
    ] }),
    onCancel ? /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        mode: "ghost",
        onClick: onCancel,
        text: t2("input.files.common.cancel-upload"),
        tone: "critical"
      }
    ) : null
  ] }) });
}
function UploadWarning({ onClearStale }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { tone: "caution", padding: 4, border: !0, radius: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.files.common.stale-upload-warning.title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("inputs.files.common.stale-upload-warning.description", {
          staleThresholdMinutes: Math.ceil(STALE_UPLOAD_MS / 1e3 / 60)
        }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.ResetIcon,
        mode: "ghost",
        onClick: onClearStale,
        text: t2("inputs.files.common.stale-upload-warning.clear"),
        width: "fill"
      }
    )
  ] });
}
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0) return "0 Bytes";
  const k = 1024, dm = decimals < 0 ? 0 : decimals, sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
function FileActionsMenu(props2) {
  const {
    originalFilename,
    size,
    children,
    muted,
    disabled,
    onClick,
    isMenuOpen,
    onMenuOpen,
    setMenuButtonElement
  } = props2, [menuElement, setMenuElement] = React.useState(null), [buttonElement, setButtonElement] = React.useState(null), handleClick = React.useCallback(() => onMenuOpen(!0), [onMenuOpen]);
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        isMenuOpen && (event.key === "Escape" || event.key === "Tab") && (onMenuOpen(!1), buttonElement == null || buttonElement.focus());
      },
      [isMenuOpen, onMenuOpen, buttonElement]
    )
  ), ui.useClickOutside(
    React.useCallback(
      (event) => {
        buttonElement != null && buttonElement.contains(event.target) || onMenuOpen(!1);
      },
      [buttonElement, onMenuOpen]
    ),
    [menuElement]
  );
  const setOptionsButtonRef = React.useCallback(
    (el) => {
      setMenuButtonElement(el), setButtonElement(el);
    },
    [setMenuButtonElement]
  );
  React.useEffect(() => {
    isMenuOpen && (menuElement == null || menuElement.focus());
  }, [isMenuOpen, menuElement]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { wrap: "nowrap", justify: "space-between", align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        as: muted || disabled ? void 0 : "button",
        radius: 2,
        padding: 2,
        tone: "inherit",
        onClick,
        flex: 1,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { wrap: "nowrap", align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, tone: "transparent", shadow: 1, radius: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted, children: /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              ui.Text,
              {
                size: 1,
                textOverflow: "ellipsis",
                muted,
                "data-testid": "file-name",
                weight: "medium",
                children: originalFilename
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, "data-testid": "file-size", children: formatBytes(size) })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Popover,
      {
        content: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { ref: setMenuElement, children }),
        id: "file-actions-menu",
        portal: !0,
        open: isMenuOpen,
        constrainSize: !0,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ContextMenuButton,
          {
            "aria-label": t2("inputs.file.actions-menu.file-options.aria-label"),
            "data-testid": "options-menu-button",
            onClick: handleClick,
            ref: setOptionsButtonRef
          }
        )
      }
    ) }) })
  ] });
}
function FileSkeleton$1() {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "flex-start", padding: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { padding: 3, radius: 1, animated: !0 }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "100%" }, radius: 1, animated: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "100%" }, radius: 1, animated: !0 })
    ] })
  ] });
}
function InvalidFileWarning({ onClearValue }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { tone: "caution", padding: 4, border: !0, radius: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.file.invalid-file-warning.title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("inputs.file.invalid-file-warning.description") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.ResetIcon,
        mode: "ghost",
        onClick: onClearValue,
        text: t2("inputs.file.invalid-file-warning.reset-button.text"),
        width: "fill"
      }
    )
  ] });
}
const CardOverlay = styledComponents.styled(ui.Card)`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
`, FlexContainer$1 = styledComponents.styled(ui.Flex)`
  height: 100%;
`;
var __defProp$9 = Object.defineProperty, __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$9 = (obj, key, value) => __defNormalProp$9(obj, typeof key != "symbol" ? key + "" : key, value);
function passThrough$1({ children }) {
  return children;
}
const ASSET_FIELD_PATH$1 = ["asset"];
class BaseFileInput extends React.PureComponent {
  constructor(props2) {
    super(props2), __publicField$9(this, "_assetFieldPath"), __publicField$9(this, "uploadSubscription", null), __publicField$9(this, "browseButtonElement", null), __publicField$9(this, "state", {
      isUploading: !1,
      selectedAssetSource: null,
      hoveringFiles: [],
      isStale: !1,
      isMenuOpen: !1
    }), __publicField$9(this, "toast", null), __publicField$9(this, "handleRemoveButtonClick", () => {
      const { path, value } = this.props, isArrayElement = typeof path.slice(-1)[0] != "string", allKeys = Object.keys(value || {}), isEmpty2 = allKeys.filter(
        (key) => !["_type", "_key", "_upload", "asset"].includes(key)
      ).length === 0, removeKeys = ["asset"].concat(allKeys.filter((key) => ["_upload"].includes(key))).map((key) => unset([key]));
      this.props.onChange(PatchEvent.from(isEmpty2 && !isArrayElement ? unset() : removeKeys));
    }), __publicField$9(this, "handleCancelUpload", () => {
      this.cancelUpload();
    }), __publicField$9(this, "handleClearUploadState", () => {
      this.setState({ isStale: !1 }), this.clearUploadStatus();
    }), __publicField$9(this, "handleStaleUpload", () => {
      this.setState({ isStale: !0 });
    }), __publicField$9(this, "handleClearField", () => {
      this.props.onChange(unset(["asset"]));
    }), __publicField$9(this, "handleSelectFiles", (files) => {
      const { directUploads, readOnly } = this.props, { hoveringFiles } = this.state;
      directUploads && !readOnly ? this.uploadFirstAccepted(files) : hoveringFiles.length > 0 && this.handleFilesOut();
    }), __publicField$9(this, "handleSelectFileFromAssetSource", (source) => {
      this.setState({ selectedAssetSource: source });
    }), __publicField$9(this, "handleAssetSourceClosed", () => {
      var _a2;
      this.setState({ selectedAssetSource: null }), (_a2 = this.browseButtonElement) == null || _a2.focus();
    }), __publicField$9(this, "setBrowseButtonElement", (el) => {
      this.browseButtonElement = el;
    }), __publicField$9(this, "uploadWith", (uploader, file, assetDocumentProps = {}) => {
      const { schemaType, onChange, client: client2, t: t2 } = this.props, { source } = assetDocumentProps, options = {
        metadata: get__default.default(schemaType, "options.metadata"),
        storeOriginalFilename: get__default.default(schemaType, "options.storeOriginalFilename"),
        source
      };
      this.cancelUpload(), this.setState({ isUploading: !0 }), onChange(PatchEvent.from([setIfMissing({ _type: schemaType.name })])), this.uploadSubscription = uploader.upload(client2, file, schemaType, options).subscribe({
        next: (uploadEvent) => {
          uploadEvent.patches && onChange(PatchEvent.from(uploadEvent.patches));
        },
        error: (err) => {
          var _a2;
          console.error(err), (_a2 = this.toast) == null || _a2.push({
            status: "error",
            description: t2("inputs.file.upload-failed.description"),
            title: t2("inputs.file.upload-failed.title")
          }), this.clearUploadStatus();
        },
        complete: () => {
          this.setState({ isUploading: !1 });
        }
      });
    }), __publicField$9(this, "handleSelectAssetFromSource", (assetFromSource) => {
      const { onChange, schemaType, resolveUploader: resolveUploader2 } = this.props;
      handleSelectAssetFromSource({
        assetFromSource,
        onChange,
        type: schemaType,
        resolveUploader: resolveUploader2,
        uploadWith: this.uploadWith
      }), this.setState({ selectedAssetSource: null });
    }), __publicField$9(this, "handleFileTargetFocus", (event) => {
      var _a2;
      event.currentTarget === event.target && event.currentTarget === ((_a2 = this.props.elementProps.ref) == null ? void 0 : _a2.current) && this.props.elementProps.onFocus(event);
    }), __publicField$9(this, "handleFilesOver", (fileInfo) => {
      this.setState({
        hoveringFiles: fileInfo
      });
    }), __publicField$9(this, "handleFilesOut", () => {
      this.setState({
        hoveringFiles: []
      });
    }), __publicField$9(this, "handleUpload", ({ file, uploader }) => {
      this.uploadWith(uploader, file);
    }), __publicField$9(this, "setToast", (toast) => {
      this.toast = toast;
    }), this._assetFieldPath = props2.path.concat(ASSET_FIELD_PATH$1);
  }
  clearUploadStatus() {
    var _a2;
    (_a2 = this.props.value) != null && _a2._upload && this.props.onChange(PatchEvent.from([unset(["_upload"])]));
  }
  cancelUpload() {
    this.uploadSubscription && (this.uploadSubscription.unsubscribe(), this.clearUploadStatus());
  }
  uploadFirstAccepted(files) {
    const { schemaType } = this.props, match = files.map((file) => {
      var _a2, _b;
      return { file, uploader: (_b = (_a2 = this.props).resolveUploader) == null ? void 0 : _b.call(_a2, schemaType, file) };
    }).find((result) => result.uploader);
    match && this.uploadWith(match.uploader, match.file), this.setState({ isMenuOpen: !1 });
  }
  renderUploadState(uploadState) {
    const { isUploading } = this.state;
    return /* @__PURE__ */ jsxRuntime.jsx(
      UploadProgress,
      {
        uploadState,
        onCancel: isUploading ? this.handleCancelUpload : void 0,
        onStale: this.handleStaleUpload
      }
    );
  }
  renderAssetSource() {
    const { selectedAssetSource } = this.state, { value, schemaType, observeAsset, t: t2 } = this.props;
    if (!selectedAssetSource)
      return null;
    const accept = get__default.default(schemaType, "options.accept", ""), Component = selectedAssetSource.component;
    return value && value.asset ? /* @__PURE__ */ jsxRuntime.jsx(
      WithReferencedAsset,
      {
        observeAsset,
        reference: value.asset,
        waitPlaceholder: /* @__PURE__ */ jsxRuntime.jsx(FileSkeleton$1, {}),
        children: (fileAsset2) => /* @__PURE__ */ jsxRuntime.jsx(
          Component,
          {
            selectedAssets: [fileAsset2],
            selectionType: "single",
            assetType: "file",
            accept,
            dialogHeaderTitle: t2("inputs.file.dialog.title"),
            onClose: this.handleAssetSourceClosed,
            onSelect: this.handleSelectAssetFromSource
          }
        )
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        selectedAssets: [],
        selectionType: "single",
        assetType: "file",
        accept,
        dialogHeaderTitle: t2("inputs.file.dialog.title"),
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }
    );
  }
  renderAsset() {
    const { value, changed, readOnly, elementProps } = this.props, { hoveringFiles, isStale } = this.state, hasValueOrUpload = !!(value != null && value._upload || value != null && value.asset);
    return value && typeof value.asset < "u" && !(value != null && value._upload) && !assetUtils.isFileSource(value) ? () => /* @__PURE__ */ jsxRuntime.jsx(InvalidFileWarning, { onClearValue: this.handleClearField }) : (inputProps) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      isStale && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(UploadWarning, { onClearStale: this.handleClearUploadState }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        ChangeIndicator,
        {
          path: this._assetFieldPath,
          hasFocus: !!inputProps.focused,
          isChanged: changed,
          children: value != null && value._upload ? this.renderUploadState(value._upload) : /* @__PURE__ */ jsxRuntime.jsx(
            FileTarget,
            {
              ...elementProps,
              onFocus: this.handleFileTargetFocus,
              tabIndex: 0,
              disabled: !!readOnly,
              onFiles: this.handleSelectFiles,
              onFilesOver: this.handleFilesOver,
              onFilesOut: this.handleFilesOut,
              tone: this.getFileTone(),
              $border: hasValueOrUpload || hoveringFiles.length > 0,
              style: { padding: 1 },
              sizing: "border",
              radius: 2,
              children: /* @__PURE__ */ jsxRuntime.jsxs("div", { style: { position: "relative" }, children: [
                !(value != null && value.asset) && this.renderUploadPlaceholder(),
                value != null && value.asset && hoveringFiles.length > 0 ? this.renderAssetMenu(this.getFileTone()) : null,
                !(value != null && value._upload) && (value == null ? void 0 : value.asset) && this.renderPreview()
              ] })
            }
          )
        }
      )
    ] });
  }
  renderPreview() {
    const { value, readOnly, assetSources, schemaType, directUploads, observeAsset, t: t2 } = this.props, { isMenuOpen } = this.state, asset = value == null ? void 0 : value.asset;
    if (!asset)
      return null;
    const accept = get__default.default(schemaType, "options.accept", "");
    let browseMenuItem = assetSources && (assetSources == null ? void 0 : assetSources.length) === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        icon: icons.SearchIcon,
        text: t2("inputs.file.browse-button.text"),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSources[0]);
        },
        disabled: readOnly,
        "data-testid": "file-input-browse-button"
      }
    );
    return assetSources.length > 1 && (browseMenuItem = assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        text: (assetSource.i18nKey ? t2(assetSource.i18nKey) : assetSource.title) || startCase__default.default(assetSource.name),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSource);
        },
        icon: assetSource.icon || icons.ImageIcon,
        disabled: readOnly,
        "data-testid": `file-input-browse-button-${assetSource.name}`
      },
      assetSource.name
    ))), /* @__PURE__ */ jsxRuntime.jsx(
      WithReferencedAsset,
      {
        reference: asset,
        observeAsset,
        waitPlaceholder: /* @__PURE__ */ jsxRuntime.jsx(FileSkeleton$1, {}),
        children: ({ originalFilename, extension, url, size }) => {
          const filename = originalFilename || `download.${extension}`;
          let copyUrl, downloadUrl;
          return assetUtils.isFileSource(value) && (downloadUrl = `${url}?dl`, copyUrl = url), /* @__PURE__ */ jsxRuntime.jsx(
            FileActionsMenu,
            {
              size,
              originalFilename: filename,
              muted: !readOnly,
              onMenuOpen: (isOpen) => this.setState({ isMenuOpen: isOpen }),
              isMenuOpen,
              setMenuButtonElement: this.setBrowseButtonElement,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                ActionsMenu,
                {
                  onUpload: this.handleSelectFiles,
                  browse: browseMenuItem,
                  onReset: this.handleRemoveButtonClick,
                  downloadUrl,
                  copyUrl,
                  readOnly,
                  accept,
                  directUploads
                }
              )
            }
          );
        }
      }
    );
  }
  renderAssetMenu(tone) {
    const { schemaType, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    return /* @__PURE__ */ jsxRuntime.jsx(CardOverlay, { radius: 2, tone, children: /* @__PURE__ */ jsxRuntime.jsx(FlexContainer$1, { align: "center", justify: "center", gap: 2, flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      PlaceholderText,
      {
        readOnly,
        hoveringFiles,
        acceptedFiles,
        rejectedFilesCount,
        directUploads,
        type: "file"
      }
    ) }) });
  }
  renderBrowser() {
    const { assetSources, readOnly, directUploads, id: id2, t: t2 } = this.props;
    return assetSources.length === 0 ? null : assetSources.length > 1 && !readOnly && directUploads ? /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        id: `${id2}_assetFileButton`,
        ref: this.setBrowseButtonElement,
        button: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "bleed",
            text: t2("inputs.file.multi-browse-button.text"),
            "data-testid": "file-input-multi-browse-button",
            icon: icons.SearchIcon
          }
        ),
        "data-testid": "input-select-button",
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            text: assetSource.title,
            onClick: () => {
              this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSource);
            },
            icon: assetSource.icon || icons.ImageIcon,
            disabled: readOnly,
            "data-testid": `file-input-browse-button-${assetSource.name}`
          },
          assetSource.name
        )) })
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        text: t2("inputs.file.browse-button.text"),
        icon: icons.SearchIcon,
        mode: "bleed",
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectFileFromAssetSource(assetSources[0]);
        },
        "data-testid": "file-input-browse-button",
        disabled: readOnly,
        ref: this.setBrowseButtonElement
      }
    );
  }
  renderUploadPlaceholder() {
    const { readOnly, schemaType, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, accept = get__default.default(schemaType, "options.accept", "");
    return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        tone: readOnly ? "transparent" : "inherit",
        border: !0,
        paddingX: 3,
        paddingY: 2,
        radius: 2,
        style: hoveringFiles.length === 0 ? { borderStyle: "dashed" } : { borderStyle: "dashed", borderColor: "transparent" },
        children: /* @__PURE__ */ jsxRuntime.jsx(
          UploadPlaceholder,
          {
            browse: this.renderBrowser(),
            onUpload: this.handleSelectFiles,
            readOnly,
            hoveringFiles,
            acceptedFiles,
            rejectedFilesCount,
            type: "file",
            accept,
            directUploads
          }
        )
      }
    ) });
  }
  getFileTone() {
    const { directUploads, schemaType, value, readOnly, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2 == null ? void 0 : resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    return hoveringFiles.length > 0 && (rejectedFilesCount > 0 || !directUploads) ? "critical" : !(value != null && value._upload) && !readOnly && hoveringFiles.length > 0 ? "primary" : value != null && value._upload && value != null && value.asset && readOnly ? "transparent" : "default";
  }
  render() {
    const {
      members,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderInlineBlock,
      renderItem: renderItem2,
      renderInput,
      renderField,
      renderPreview,
      t: t2
    } = this.props, { selectedAssetSource } = this.state;
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ImperativeToast, { ref: this.setToast }),
      members.map((member) => member.kind === "field" && (member.name === "crop" || member.name === "hotspot") ? null : member.kind === "field" ? /* @__PURE__ */ jsxRuntime.jsx(
        MemberField,
        {
          member,
          renderAnnotation,
          renderInlineBlock,
          renderBlock: renderBlock2,
          renderInput: member.name === "asset" ? this.renderAsset() : renderInput,
          renderField: member.name === "asset" ? passThrough$1 : renderField,
          renderItem: renderItem2,
          renderPreview
        },
        member.key
      ) : member.kind === "fieldSet" ? /* @__PURE__ */ jsxRuntime.jsx(
        MemberFieldSet,
        {
          member,
          renderAnnotation,
          renderBlock: renderBlock2,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem: renderItem2,
          renderPreview
        },
        member.key
      ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member }, member.key) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.file.error.unknown-member-kind", { kind: member.kind }) })),
      selectedAssetSource && this.renderAssetSource()
    ] });
  }
}
function StudioFileInput(props2) {
  var _a2;
  const sourcesFromSchema = (_a2 = props2.schemaType.options) == null ? void 0 : _a2.sources, documentPreviewStore = useDocumentPreviewStore(), { file: fileConfig } = useFormBuilder().__internal, client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), { t: t2 } = useTranslation(), resolveUploader$1 = React.useCallback(
    (type, file) => fileConfig.directUploads ? resolveUploader(type, file) : null,
    [fileConfig.directUploads]
  ), assetSources = React.useMemo(
    () => sourcesFromSchema || fileConfig.assetSources,
    [fileConfig, sourcesFromSchema]
  ), observeAsset = React.useCallback(
    (id2) => observeFileAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    BaseFileInput,
    {
      ...props2,
      t: t2,
      client: client2,
      assetSources,
      directUploads: fileConfig.directUploads,
      observeAsset,
      resolveUploader: resolveUploader$1
    }
  );
}
const RatioBox$1 = styledComponents.styled(ui.Box)`
  position: relative;
  padding-bottom: calc(${({ ratio = 3 / 2 }) => 1 / ratio} * 100%);

  & > div {
    position: absolute;
    top: ${({ padding = 0 }) => padding}px;
    left: ${({ padding = 0 }) => padding}px;
    right: ${({ padding = 0 }) => padding}px;
    bottom: ${({ padding = 0 }) => padding}px;
  }
`, DEFAULT_HOTSPOT = {
  x: 0.5,
  y: 0.5,
  height: 1,
  width: 1
}, DEFAULT_CROP = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
function calculateStyles(options = {}) {
  const imageAspect = readAspectRatio(options.image) || 1, hotspot = options.hotspot || DEFAULT_HOTSPOT, crop = options.crop || DEFAULT_CROP, containerAspect = readAspectRatio(options.container) || imageAspect * readCropAspect(crop), align2 = options.align || { x: "center", y: "center" }, result = calculateHotSpotCrop(
    imageAspect,
    { hotspot, crop },
    { aspect: containerAspect, align: align2 }
  ), containerHeight = styleFormat(round(100 / containerAspect));
  return {
    debug: {
      result
    },
    container: {
      //outline: '1px solid cyan',
      overflow: "hidden",
      position: "relative",
      width: "100%",
      height: containerHeight
    },
    padding: {
      marginTop: containerHeight
    },
    crop: {
      position: "absolute",
      overflow: "hidden",
      height: toStylePercentage(result.crop.height),
      width: toStylePercentage(result.crop.width),
      top: toStylePercentage(result.crop.top),
      left: toStylePercentage(result.crop.left)
    },
    image: {
      position: "absolute",
      height: toStylePercentage(result.image.height),
      width: toStylePercentage(result.image.width),
      top: toStylePercentage(result.image.top),
      left: toStylePercentage(result.image.left)
    }
  };
}
function readAspectRatio(opts) {
  if (!opts)
    return null;
  if ("aspectRatio" in opts)
    return opts.aspectRatio;
  if ("height" in opts || "width" in opts) {
    if (typeof opts.height != "number" && typeof opts.width != "number")
      throw new Error(`Height and width must be numbers, got ${JSON.stringify(opts)}`);
    return opts.width / opts.height;
  }
  return null;
}
function round(num, decimals = 2) {
  const multiplier = Math.pow(10, decimals);
  return Math.round(num * multiplier) / multiplier;
}
function calculateHotSpotCrop(sourceAspect, descriptor, spec) {
  const crop = descriptor.crop, viewportAspect = spec.aspect, alignment = spec.align, netWidth = 1 - crop.left - crop.right, netHeight = 1 - crop.top - crop.bottom, outImg = {
    top: -crop.top / netHeight,
    left: -crop.left / netWidth,
    width: 1 / netWidth,
    height: 1 / netHeight
  }, cropAspect = netWidth / netHeight * sourceAspect, hotspot = {
    x: (descriptor.hotspot.x - crop.left) / netWidth,
    y: (descriptor.hotspot.y - crop.top) / netHeight,
    height: descriptor.hotspot.height / netHeight,
    width: descriptor.hotspot.width / netWidth
  }, maxHotspotXScale = 1 / hotspot.width, maxHotspotYScale = 1 / hotspot.height * cropAspect / viewportAspect, maxScale = Math.min(maxHotspotXScale, maxHotspotYScale);
  let minFullBleedScale;
  const cropIsTaller = cropAspect <= viewportAspect;
  cropIsTaller ? minFullBleedScale = 1 : minFullBleedScale = cropAspect / viewportAspect;
  let method, outCrop;
  if (minFullBleedScale > maxScale) {
    method = "letterbox";
    let letterboxScale;
    const diff2 = minFullBleedScale - maxScale;
    cropIsTaller ? letterboxScale = 1 - diff2 : letterboxScale = maxScale, outCrop = {
      width: letterboxScale,
      height: letterboxScale / cropAspect * viewportAspect,
      // Gets overwritten further down
      left: 0,
      top: 0
    };
    const hotspotLeft = hotspot.x * outCrop.width - hotspot.width * outCrop.width / 2;
    switch (alignment.x) {
      case "left":
        outCrop.left = cropIsTaller ? 0 : -hotspotLeft;
        break;
      case "right":
        outCrop.left = cropIsTaller ? 1 - outCrop.width : hotspotLeft;
        break;
      case "center":
        outCrop.left = cropIsTaller ? (1 - outCrop.width) / 2 : -hotspotLeft;
        break;
      default:
        throw new Error(
          `Invalid x alignment: '${alignment.x}'. Must be either 'left', 'right' or 'center'`
        );
    }
    const hotspotTop = hotspot.y * outCrop.height - hotspot.height * outCrop.height / 2;
    switch (alignment.y) {
      case "top":
        outCrop.top = cropIsTaller ? -hotspotTop : 0;
        break;
      case "bottom":
        outCrop.top = hotspotTop;
        break;
      case "center":
        outCrop.top = cropIsTaller ? -hotspotTop : (1 - outCrop.height) / 2;
        break;
      default:
        throw new Error(
          `Invalid y alignment: '${alignment.y}'. Must be either 'top', 'bottom' or 'center'`
        );
    }
  } else if (cropIsTaller) {
    method = "full_width";
    let top = -hotspot.y / cropAspect * viewportAspect + 0.5;
    const height = minFullBleedScale / cropAspect * viewportAspect;
    top > 0 ? top = 0 : -top > height - 1 && (top = -(height - 1)), outCrop = {
      width: minFullBleedScale,
      height,
      left: 0,
      // Place the Y center of the hotspot near the center of the viewport
      top
    };
  } else {
    method = "full_height";
    const width = minFullBleedScale;
    let left = 0.5 - hotspot.x * minFullBleedScale;
    left > 0 ? left = 0 : -left > width - 1 && (left = -(width - 1)), outCrop = {
      width,
      height: minFullBleedScale / cropAspect * viewportAspect,
      top: 0,
      // Place the X center of the hotspot at the center of the viewport
      left
    };
  }
  return {
    method,
    crop: outCrop,
    image: outImg
  };
}
function readCropAspect(crop) {
  const height = 1 - crop.top - crop.bottom;
  return (1 - crop.left - crop.right) / height;
}
function styleFormat(num) {
  return num === 0 ? 0 : `${num}%`;
}
function toStylePercentage(num) {
  return styleFormat(round(num * 100));
}
const HotspotImageContainer = styledComponents.styled.div`
  position: relative;
  width: 100%;
`, debug$6 = debug__default.default("sanity-imagetool");
function getCropAspect(crop, srcAspect) {
  const origHeight = 1 / srcAspect, origWidth = srcAspect * origHeight, cropWidth = origWidth - (crop.left + crop.right) * origWidth, cropHeight = origHeight - (crop.top + crop.bottom) * origHeight;
  return cropWidth / cropHeight;
}
const HotspotImage = React.memo(function(props2) {
  const {
    alignX = "center",
    alignY = "center",
    alt,
    aspectRatio = "none",
    className = "",
    crop = DEFAULT_CROP,
    hotspot = DEFAULT_HOTSPOT,
    onError,
    onLoad,
    src,
    srcAspectRatio,
    srcSet,
    style
  } = props2, [containerAspect, setContainerAspect] = React.useState(null), containerElementRef = React.useRef(null), imageElementRef = React.useRef(null), updateContainerAspect = React.useCallback(() => {
    if (containerElementRef.current)
      if (aspectRatio === "auto") {
        const parentNode = containerElementRef.current.parentNode;
        React.startTransition(() => setContainerAspect(parentNode.offsetWidth / parentNode.offsetHeight));
      } else
        setContainerAspect(null);
  }, [aspectRatio]);
  React.useEffect(() => {
    const imageElement = imageElementRef.current;
    return imageElement && imageElement.src && imageElement.complete && imageElement.naturalWidth !== void 0 && (debug$6("Image '%s' already loaded, refreshing (from cache) to trigger onLoad / onError", src), imageElement.src = imageElement.src), updateContainerAspect(), window.addEventListener("resize", updateContainerAspect), () => {
      window.removeEventListener("resize", updateContainerAspect);
    };
  }, [src, updateContainerAspect]);
  const targetAspect = React.useMemo(() => aspectRatio === "none" ? crop ? getCropAspect(crop, srcAspectRatio) : srcAspectRatio : aspectRatio === "auto" ? containerAspect : aspectRatio || null, [aspectRatio, containerAspect, crop, srcAspectRatio]), targetStyles = React.useMemo(
    () => calculateStyles({
      container: { aspectRatio: targetAspect || srcAspectRatio },
      image: { aspectRatio: srcAspectRatio },
      hotspot,
      crop,
      align: {
        x: alignX,
        y: alignY
      }
    }),
    [alignX, alignY, crop, hotspot, srcAspectRatio, targetAspect]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(HotspotImageContainer, { className: `${className}`, style, ref: containerElementRef, children: /* @__PURE__ */ jsxRuntime.jsxs("div", { style: targetStyles.container, children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: targetStyles.padding }),
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: targetStyles.crop, children: /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        ref: imageElementRef,
        src,
        alt,
        srcSet,
        onLoad,
        onError,
        style: targetStyles.image
      }
    ) })
  ] }) });
});
function ImageLoader(props2) {
  const { src, children } = props2, [isLoading, setIsLoading] = React.useState(!0), [image, setImage] = React.useState(null), [error, setError] = React.useState(null);
  return React.useEffect(() => {
    setImage(null), setError(null), setIsLoading(!0);
    const image2 = new Image();
    image2.onload = () => {
      setImage(image2), setError(null), setIsLoading(!1);
    }, image2.onerror = () => {
      setError(new Error(`Could not load image from ${JSON.stringify(src)}`)), setIsLoading(!1);
    }, image2.referrerPolicy = "strict-origin-when-cross-origin", image2.src = src;
  }, [src]), children({ image, error, isLoading });
}
function Resize(props2) {
  const { image, maxHeight, maxWidth, children } = props2, [canvas] = React.useState(() => {
    const canvasElement = document.createElement("canvas");
    return canvasElement.style.display = "none", canvasElement;
  });
  React.useEffect(() => (document.body.appendChild(canvas), () => {
    document.body.removeChild(canvas);
  }), [canvas]);
  const resize = React.useCallback(
    (image2, maxHeight2, maxWidth2) => {
      const ratio = image2.width / image2.height, width = Math.min(image2.width, maxWidth2), height = Math.min(image2.height, maxHeight2), landscape = image2.width > image2.height, targetWidth = landscape ? width : height * ratio, targetHeight = landscape ? width / ratio : height;
      canvas.width = targetWidth, canvas.height = targetHeight;
      const ctx = canvas.getContext("2d");
      return ctx && ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, targetWidth, targetHeight), canvas;
    },
    [canvas]
  );
  return children(resize(image, maxHeight, maxWidth));
}
var __defProp$8 = Object.defineProperty, __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, typeof key != "symbol" ? key + "" : key, value);
class Point {
  constructor(x, y) {
    __publicField$8(this, "x"), __publicField$8(this, "y"), this.x = x, this.y = y;
  }
}
class HLine {
  constructor(y, left, right) {
    __publicField$8(this, "y"), __publicField$8(this, "_left"), __publicField$8(this, "_right"), this.y = y, this._left = left, this._right = right;
  }
  get right() {
    return new Point(this._right, this.y);
  }
  get left() {
    return new Point(this._left, this.y);
  }
  get length() {
    return this._right - this._left;
  }
}
class Corners {
  constructor(rect) {
    __publicField$8(this, "rect"), this.rect = rect;
  }
  get top() {
    return new HLine(this.rect.top, this.rect.left, this.rect.right);
  }
  get bottom() {
    return new HLine(this.rect.bottom, this.rect.left, this.rect.right);
  }
}
class Rect {
  constructor(left = 0, top = 0, width = 0, height = 0) {
    __publicField$8(this, "left"), __publicField$8(this, "top"), __publicField$8(this, "width"), __publicField$8(this, "height"), this.left = left, this.top = top, this.width = width, this.height = height;
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static fromEdges({ left, right, top, bottom: bottom2 }) {
    return new Rect(left, top, 1 - left - right, 1 - top - bottom2);
  }
  setTopLeft(left, top) {
    return new Rect(left, top, this.width || 0, this.height || 0);
  }
  setSize(width, height) {
    return new Rect(this.left || 0, this.top || 0, width, height);
  }
  setCenter(x, y) {
    const width = this.width || 0, height = this.height || 0;
    return new Rect(x - width / 2, y - height / 2, width || 0, height || 0);
  }
  get center() {
    return new Point(this.left + this.width / 2, this.top + this.height / 2);
  }
  get corners() {
    return new Corners(this);
  }
  get right() {
    return this.left + this.width;
  }
  get bottom() {
    return this.top + this.height;
  }
  multiply(rect) {
    return new Rect(
      (this.left || 0) + this.width * rect.left,
      (this.top || 0) + this.height * rect.top,
      this.width * rect.width,
      this.height * rect.height
    );
  }
  grow(delta) {
    return new Rect(
      this.left - delta,
      this.top - delta,
      this.width + delta * 2,
      this.height + delta * 2
    );
  }
  shrink(delta) {
    return this.grow(-delta);
  }
  cropRelative(crop) {
    const top = this.top + crop.top * this.height, left = this.left + crop.left * this.width, height = this.height * crop.height, width = this.width * crop.width;
    return new Rect(left, top, width, height);
  }
  clamp(bounds) {
    let { left, top, width, height } = this;
    return bounds.width < width && (width = bounds.width, left = bounds.left), bounds.height < height && (height = bounds.height, top = bounds.top), left + width > bounds.left + bounds.width && (left = bounds.right - width), top + height > bounds.top + bounds.height && (top = bounds.bottom - height), new Rect(Math.max(left, bounds.left), Math.max(top, bounds.top), width, height);
  }
}
function isPointInEllipse(point, ellipse) {
  const center = { x: ellipse.center.x, y: ellipse.center.y }, xradius = ellipse.width / 2, yradius = ellipse.height / 2;
  if (xradius <= 0 || yradius <= 0)
    return !1;
  const normalized = { x: point.x - center.x, y: point.y - center.y };
  return Math.pow(normalized.x, 2) / Math.pow(xradius, 2) + Math.pow(normalized.y, 2) / Math.pow(yradius, 2) <= 1;
}
function isPointInCircle({ x, y }, circle) {
  return Math.pow(x - circle.x, 2) + Math.pow(y - circle.y, 2) < Math.pow(circle.radius, 2);
}
function isPointInRect(point, rect) {
  return point.x >= rect.left && point.x <= rect.left + rect.width && point.y >= rect.top && point.y <= rect.top + rect.height;
}
function getPointAtCircumference(radians, ellipse) {
  return {
    x: ellipse.center.x - ellipse.width / 2 * Math.cos(radians),
    y: ellipse.center.y - ellipse.height / 2 * Math.sin(radians)
  };
}
const OPEN_HAND = "data:image/png;base64,AAACAAEAICACAAcABQAwAQAAFgAAACgAAAAgAAAAQAAAAAEAAQAAAAAAAAEAAAAAAAAAAAAAAgAAAAAAAAAAAAAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAfwAAAP+AAAH/gAAB/8AAA//AAAd/wAAGf+AAAH9gAADbYAAA2yAAAZsAAAGbAAAAGAAAAAAAAA//////////////////////////////////////////////////////////////////////////////////////gH///4B///8Af//+AD///AA///wAH//4AB//8AAf//AAD//5AA///gAP//4AD//8AF///AB///5A////5///8=", CLOSE_HAND = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAABdSURBVEjH7ZA7DsAwCEMN6v2vTCdESpLKQRl5gxfzMQDNRQyWlEK83QAIRh3cH/QbIhQwMDl8gORl7A16WD/xxAdq6N6SgycKUblf41+wbFBT44RiCi11NU3TLHgBxRUUD4ITqnIAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDEtMjFUMDA6MTM6NDMrMDE6MDC74T7AAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEyLTA0LTAyVDA0OjEzOjM3KzAyOjAwQJ35wQAAAABJRU5ErkJggg==", DragAwareCanvasComponent = React.forwardRef(
  function(props2, ref) {
    const { readOnly, onDragStart, onDragEnd, onDrag, ...rest } = props2, domNode = React.useRef(null), currentPos = React.useRef(null), isDragging = React.useRef(!1), handleDragStart = React.useCallback(
      (event) => {
        if (readOnly || !domNode.current)
          return;
        if (isDragging.current) {
          debug$5("Start cancelled, already a drag in progress");
          return;
        }
        isDragging.current = !0;
        const nextPos = getPos(event);
        debug$5("Drag started %o", nextPos), onDragStart(
          getPositionRelativeToRect(nextPos.x, nextPos.y, domNode.current.getBoundingClientRect())
        ), currentPos.current = nextPos;
      },
      [onDragStart, readOnly]
    ), handleDrag = React.useCallback(
      (event) => {
        if (!isDragging.current || readOnly || !currentPos.current)
          return;
        const nextPos = getPos(event), diff2 = diffPos(nextPos, currentPos.current);
        onDrag(diff2), debug$5("moving by %o", diff2), currentPos.current = nextPos;
      },
      [onDrag, readOnly]
    ), handleDragCancel = React.useCallback(() => {
      !isDragging.current || readOnly || !currentPos.current || !domNode.current || (isDragging.current = !1, onDragEnd(
        getPositionRelativeToRect(
          currentPos.current.x,
          currentPos.current.y,
          domNode.current.getBoundingClientRect()
        )
      ), currentPos.current = null);
    }, [onDragEnd, readOnly]), handleDragEnd = React.useCallback(
      (event) => {
        if (!isDragging.current || readOnly || !domNode.current)
          return;
        const nextPos = getPos(event);
        onDragEnd(
          getPositionRelativeToRect(nextPos.x, nextPos.y, domNode.current.getBoundingClientRect())
        ), isDragging.current = !1, currentPos.current = null, debug$5("Done moving %o", nextPos);
      },
      [onDragEnd, readOnly]
    );
    React.useEffect(() => (document.body.addEventListener("pointermove", handleDrag), document.body.addEventListener("pointerup", handleDragEnd), document.body.addEventListener("pointerleave", handleDragCancel), document.body.addEventListener("pointercancel", handleDragCancel), () => {
      document.body.removeEventListener("pointermove", handleDrag), document.body.removeEventListener("pointerup", handleDragEnd), document.body.removeEventListener("pointerleave", handleDragCancel), document.body.removeEventListener("pointercancel", handleDragCancel);
    }), [handleDrag, handleDragCancel, handleDragEnd]);
    const setRef = React.useCallback(
      (node) => {
        domNode.current = node, typeof ref == "function" ? ref(node) : ref && (ref.current = node);
      },
      [ref]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(StyledCanvas, { ref: setRef, onPointerDown: readOnly ? void 0 : handleDragStart, ...rest });
  }
), DragAwareCanvas = React.memo(
  DragAwareCanvasComponent
  /*
  function arePropsEqual(oldProps, newProps) {
    const keys = new Set([...Object.keys(oldProps), ...Object.keys(newProps)])
    for (const key of keys) {
      if (!Object.is(oldProps[key], newProps[key])) {
        console.count(`DragAwareCanvas ${key} changed`)
        return false
      }
    }
    return true
  },
  // */
), debug$5 = debug__default.default("sanity-imagetool"), StyledCanvas = styledComponents.styled.canvas`
  display: block;
  position: relative;
  max-width: calc(100% - 0.5em); /* to prevent overlap with change bar */
  max-height: calc(100% + 1em);
  user-select: none;
  // Enable only multi-finger panning and zooming within this element.
  // This prevents single finger panning when manipulating drag handles,
  // which can cause unwanted scrolling in the underlying document body.
  touch-action: pinch-zoom;
`;
function getPositionRelativeToRect(x, y, rect) {
  return {
    x: x - rect.left,
    y: y - rect.top
  };
}
function getPos(event) {
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function diffPos(pos, otherPos) {
  return {
    x: pos.x - otherPos.x,
    y: pos.y - otherPos.y
  };
}
function paintBackground({
  context,
  image,
  MARGIN_PX: MARGIN_PX2,
  scale
}) {
  const inner = new Rect().setSize(image.width, image.height).shrink(MARGIN_PX2 * scale);
  context.save(), context.fillStyle = "white", context.clearRect(0, 0, image.width, image.height), context.globalAlpha = 0.3, context.drawImage(image, inner.left, inner.top, inner.width, inner.height), context.restore();
}
function paintHotspot({
  clampedValue,
  context,
  HOTSPOT_HANDLE_SIZE: HOTSPOT_HANDLE_SIZE2,
  image,
  MARGIN_PX: MARGIN_PX2,
  opacity,
  readOnly,
  scale
}) {
  const imageRect = new Rect().setSize(image.width, image.height), { hotspot, crop } = clampedValue, margin = MARGIN_PX2 * scale;
  context.save(), drawBackdrop(), drawEllipse(), context.clip(), drawHole(), context.restore(), readOnly || drawDragHandle(Math.PI * 1.25);
  function drawEllipse() {
    context.save();
    const dest = imageRect.shrink(margin).multiply(hotspot), scaleY = dest.height / dest.width;
    context.scale(1, scaleY), context.beginPath(), context.globalAlpha = opacity, context.arc(
      dest.center.x,
      dest.center.y / scaleY,
      Math.abs(dest.width / 2),
      0,
      2 * Math.PI,
      !1
    ), context.strokeStyle = "white", context.lineWidth = 1.5 * scale, context.stroke(), context.closePath(), context.restore();
  }
  function drawImage(srcLeft, srcTop, srcWidth, srcHeight, destLeft, destTop, destWidth, destHeight) {
    context.save(), context.drawImage(
      image,
      srcLeft,
      srcTop,
      srcWidth,
      srcHeight,
      destLeft,
      destTop,
      destWidth,
      destHeight
    ), context.restore();
  }
  function drawHole() {
    const src = imageRect.multiply(hotspot), dest = imageRect.shrink(margin).multiply(hotspot);
    drawImage(
      src.left,
      src.top,
      src.width,
      src.height,
      dest.left,
      dest.top,
      dest.width,
      dest.height
    );
  }
  function drawBackdrop() {
    const src = imageRect.cropRelative(crop), dest = imageRect.shrink(margin).cropRelative(crop);
    context.save(), drawImage(
      src.left,
      src.top,
      src.width,
      src.height,
      dest.left,
      dest.top,
      dest.width,
      dest.height
    ), context.globalAlpha = 0.5, context.fillStyle = "black", context.fillRect(dest.left, dest.top, dest.width, dest.height), context.restore();
  }
  function drawDragHandle(radians) {
    context.save();
    const radius = HOTSPOT_HANDLE_SIZE2 * scale, dest = imageRect.shrink(margin).multiply(hotspot), point = getPointAtCircumference(radians, dest);
    context.beginPath(), context.arc(point.x, point.y, radius, 0, 2 * Math.PI, !1), context.fillStyle = "rgb(255,255,255)", context.fill(), context.closePath(), context.restore(), context.beginPath(), context.arc(point.x, point.y, radius, 0, 2 * Math.PI, !1), context.strokeStyle = "rgb(0, 0, 0)", context.lineWidth = 0.5 * scale, context.stroke(), context.closePath();
  }
}
function printGuidelines({
  context,
  hotspotRect,
  image,
  MARGIN_PX: MARGIN_PX2,
  scale
}) {
  context.save();
  const margin = MARGIN_PX2 * scale;
  context.setLineDash && context.setLineDash([2 * scale, 2 * scale]), context.lineWidth = 0.5 * scale, context.strokeStyle = "rgba(200, 200, 200, 0.5)", vline(hotspotRect.center.x), hline(hotspotRect.center.y), context.strokeStyle = "rgba(150, 150, 150, 0.5)", hline(hotspotRect.top), hline(hotspotRect.bottom), vline(hotspotRect.left), vline(hotspotRect.right), context.restore();
  function vline(x) {
    line(x, margin, x, image.height - margin);
  }
  function hline(y) {
    line(margin, y, image.width - margin, y);
  }
  function line(x1, y1, x2, y2) {
    context.beginPath(), context.moveTo(x1, y1), context.lineTo(x2, y2), context.stroke(), context.closePath();
  }
}
function paintCropBorder({
  context,
  cropRect
}) {
  context.save(), context.beginPath(), context.fillStyle = "rgba(66, 66, 66, 0.9)", context.lineWidth = 1, context.rect(cropRect.left, cropRect.top, cropRect.width, cropRect.height), context.stroke(), context.closePath(), context.restore();
}
function highlightCropHandles({
  context,
  cropHandles,
  cropping,
  opacity
}) {
  context.save(), cropHandleKeys.forEach((handle) => {
    context.fillStyle = cropping === handle ? `rgba(202, 54, 53, ${opacity})` : `rgba(230, 230, 230, ${opacity + 0.4})`;
    const { left, top, height, width } = cropHandles[handle];
    context.fillRect(left, top, width, height), context.beginPath(), context.fillStyle = `rgba(66, 66, 66, ${opacity})`, context.rect(left, top, width, height), context.closePath(), context.stroke();
  }), context.restore();
}
const cropHandleKeys = [
  "left",
  "right",
  "top",
  "topLeft",
  "topRight",
  "bottom",
  "bottomLeft",
  "bottomRight"
];
function paint({
  clampedValue,
  context,
  cropHandles,
  cropping,
  cropRect,
  HOTSPOT_HANDLE_SIZE: HOTSPOT_HANDLE_SIZE2,
  hotspotRect,
  image,
  MARGIN_PX: MARGIN_PX2,
  pointerPosition,
  ratio,
  readOnly,
  scale
}) {
  context.save(), context.scale(ratio, ratio);
  const opacity = !readOnly && pointerPosition ? 0.8 : 0.2;
  paintBackground({ context, image, MARGIN_PX: MARGIN_PX2, scale }), paintHotspot({
    clampedValue,
    context,
    HOTSPOT_HANDLE_SIZE: HOTSPOT_HANDLE_SIZE2,
    image,
    MARGIN_PX: MARGIN_PX2,
    opacity,
    readOnly,
    scale
  }), printGuidelines({ context, hotspotRect, image, MARGIN_PX: MARGIN_PX2, scale }), paintCropBorder({ context, cropRect }), readOnly || highlightCropHandles({ context, cropHandles, cropping, opacity }), context.restore();
}
const RootContainer = styledComponents.styled.div`
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
`;
function useActualCanvasSizeObserver() {
  const [canvas, setCanvas] = React.useState(null), [height, setHeight] = React.useState(0), [width, setWidth] = React.useState(0), size = React.useMemo(() => ({ height, width }), [height, width]);
  return React.useEffect(() => {
    if (canvas)
      return setHeight(canvas.clientHeight), setWidth(canvas.clientWidth), resizeObserver.observe(canvas, (entry) => {
        setHeight(Math.round(entry.contentRect.height)), setWidth(Math.round(entry.contentRect.width));
      }), () => {
        resizeObserver.unobserve(canvas);
      };
  }, [canvas]), [size, setCanvas];
}
var __defProp$7 = Object.defineProperty, __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, typeof key != "symbol" ? key + "" : key, value);
const MARGIN_PX = 8, CROP_HANDLE_SIZE = 12, HOTSPOT_HANDLE_SIZE = 10;
function normalizeRect(rect) {
  const flippedY = rect.top > rect.bottom, flippedX = rect.left > rect.right;
  return {
    top: flippedY ? rect.bottom : rect.top,
    bottom: flippedY ? rect.top : rect.bottom,
    left: flippedX ? rect.right : rect.left,
    right: flippedX ? rect.left : rect.right
  };
}
function checkCropBoundaries(value, delta) {
  return !(!value || !value.crop || value.crop.top + delta.top < 0 || value.crop.left + delta.left < 0 || value.crop.right + delta.right < 0 || value.crop.bottom + delta.bottom < 0);
}
function limitToBoundaries(value, delta) {
  const { top, right, bottom: bottom2, left } = value.crop || DEFAULT_CROP, newValue = {
    hotspot: value.hotspot,
    crop: {
      top: top + (delta.top || 0) > 0 ? top : 0,
      right: right + (delta.right || 0) > 0 ? right : 0,
      bottom: bottom2 + (delta.bottom || 0) > 0 ? bottom2 : 0,
      left: left + (delta.left || 0) > 0 ? left : 0
    }
  }, newDelta = {
    top: top + (delta.top || 0) > 0 && delta.top || 0,
    right: right + (delta.right || 0) > 0 && delta.right || 0,
    bottom: bottom2 + (delta.bottom || 0) > 0 && delta.bottom || 0,
    left: left + (delta.left || 0) > 0 && delta.left || 0
  };
  return { value: newValue, delta: newDelta };
}
function getCropCursorForHandle(handle) {
  switch (handle) {
    case "left":
    case "right":
      return "col-resize";
    case "top":
    case "bottom":
      return "row-resize";
    case "topRight":
    case "bottomLeft":
      return "nesw-resize";
    case "topLeft":
    case "bottomRight":
      return "nwse-resize";
    default:
      return null;
  }
}
function ToolCanvasComponent(props2) {
  const { image, readOnly, onChange, onChangeEnd, value } = props2, ratio = useDevicePixelRatio.useDevicePixelRatio(), [actualSize, setCanvasObserver] = useActualCanvasSizeObserver(), scale = React.useMemo(() => image.width / actualSize.width, [actualSize.width, image.width]), hotspotRect = React.useMemo(() => {
    const hotspot = value.hotspot || DEFAULT_HOTSPOT, rect = new Rect().setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y);
    return new Rect().setSize(image.width, image.height).shrink(MARGIN_PX * scale).multiply(rect);
  }, [image.height, image.width, scale, value.hotspot]), cropRect = React.useMemo(() => new Rect().setSize(image.width, image.height).shrink(MARGIN_PX * scale).cropRelative(Rect.fromEdges(value.crop || DEFAULT_CROP).clamp(new Rect(0, 0, 1, 1))), [image.height, image.width, scale, value.crop]), cropHandles = React.useMemo(() => {
    const inner = cropRect, handleSize = CROP_HANDLE_SIZE * scale, halfCropHandleSize = handleSize / 2, cropHandle = new Rect(0, 0, handleSize, handleSize);
    return {
      left: cropHandle.setTopLeft(
        inner.left - halfCropHandleSize,
        inner.center.y - halfCropHandleSize
      ),
      right: cropHandle.setTopLeft(
        inner.right - halfCropHandleSize,
        inner.center.y - halfCropHandleSize
      ),
      top: cropHandle.setTopLeft(
        inner.center.x - halfCropHandleSize,
        inner.top - halfCropHandleSize
      ),
      topLeft: cropHandle.setTopLeft(
        inner.left - halfCropHandleSize,
        inner.top - halfCropHandleSize
      ),
      topRight: cropHandle.setTopLeft(
        inner.right - halfCropHandleSize,
        inner.top - halfCropHandleSize
      ),
      bottom: cropHandle.setTopLeft(
        inner.center.x - halfCropHandleSize,
        inner.bottom - halfCropHandleSize
      ),
      bottomLeft: cropHandle.setTopLeft(
        inner.left - halfCropHandleSize,
        inner.bottom - halfCropHandleSize
      ),
      bottomRight: cropHandle.setTopLeft(
        inner.right - halfCropHandleSize,
        inner.bottom - halfCropHandleSize
      )
    };
  }, [cropRect, scale]), clampedValue = React.useMemo(() => {
    const crop = Rect.fromEdges(value.crop || DEFAULT_CROP).clamp(new Rect(0, 0, 1, 1)), hotspot = value.hotspot || DEFAULT_HOTSPOT, hotspotRect2 = new Rect(0, 0, 1, 1).setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y).clamp(crop);
    return { crop, hotspot: hotspotRect2 };
  }, [value.crop, value.hotspot]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ToolCanvasLegacy,
    {
      actualSize,
      hotspotRect,
      cropRect,
      cropHandles,
      clampedValue,
      image,
      onChange,
      onChangeEnd,
      ratio,
      readOnly,
      scale,
      setCanvasObserver,
      value
    }
  );
}
const ToolCanvas = React.memo(ToolCanvasComponent);
class ToolCanvasLegacy extends React.PureComponent {
  constructor() {
    super(...arguments), __publicField$7(this, "state", {
      cropping: !1,
      cropMoving: !1,
      moving: !1,
      resizing: !1,
      pointerPosition: null
    }), __publicField$7(this, "canvas"), __publicField$7(this, "handleDragStart", ({ x, y }) => {
      const pointerPosition = { x: x * this.props.scale, y: y * this.props.scale }, inHotspot = isPointInEllipse(pointerPosition, this.props.hotspotRect), inDragHandle = isPointInCircle(pointerPosition, this.getDragHandleCoords()), activeCropHandle = this.getActiveCropHandleFor(pointerPosition), inCropRect = isPointInRect(pointerPosition, this.props.cropRect);
      activeCropHandle ? this.setState({ cropping: activeCropHandle }) : inDragHandle ? this.setState({ resizing: !0 }) : inHotspot ? this.setState({ moving: !0 }) : inCropRect && this.setState({ cropMoving: !0 });
    }), __publicField$7(this, "handleDrag", (pos) => {
      this.state.cropping ? this.emitCrop(this.state.cropping, pos) : this.state.cropMoving ? this.emitCropMove(pos) : this.state.moving ? this.emitMove(pos) : this.state.resizing && this.emitResize(pos);
    }), __publicField$7(this, "handleDragEnd", () => {
      const { onChange, onChangeEnd } = this.props;
      this.setState({ moving: !1, resizing: !1, cropping: !1, cropMoving: !1 });
      const { hotspot, crop: rawCrop } = this.props.clampedValue, crop = normalizeRect(rawCrop), finalValue = {
        crop: {
          top: crop.top,
          bottom: 1 - crop.bottom,
          left: crop.left,
          right: 1 - crop.right
        },
        hotspot: {
          x: hotspot.center.x,
          y: hotspot.center.y,
          height: Math.abs(hotspot.height),
          width: Math.abs(hotspot.width)
        }
      };
      onChange(finalValue), onChangeEnd && onChangeEnd(finalValue);
    }), __publicField$7(this, "handlePointerOut", () => {
      this.setState({ pointerPosition: null });
    }), __publicField$7(this, "handlePointerMove", (event) => {
      const clientRect = event.currentTarget.getBoundingClientRect();
      this.setState({
        pointerPosition: {
          x: (event.clientX - clientRect.left) * this.props.scale,
          y: (event.clientY - clientRect.top) * this.props.scale
        }
      });
    }), __publicField$7(this, "setCanvas", (node) => {
      node && (this.canvas = node), this.props.setCanvasObserver(node);
    });
  }
  getActiveCropHandleFor({ x, y }) {
    const cropHandles = this.props.cropHandles;
    for (const position of cropHandleKeys)
      if (isPointInRect({ x, y }, cropHandles[position]))
        return position;
    return !1;
  }
  emitMove(pos) {
    const { image, value, onChange } = this.props, scale = this.props.scale, delta = {
      x: pos.x * scale / image.width,
      y: pos.y * scale / image.height
    };
    onChange(applyHotspotMoveBy(value, delta));
  }
  emitCropMove(pos) {
    const { image, onChange, value } = this.props, scale = this.props.scale, left = pos.x * scale / image.width, right = -pos.x * scale / image.width, top = pos.y * scale / image.height, bottom2 = -pos.y * scale / image.height, delta = { left, right, top, bottom: bottom2 };
    checkCropBoundaries(value, delta) && onChange(applyCropMoveBy(value, delta));
  }
  emitCrop(side, pos) {
    const { image, onChange, value } = this.props, scale = this.props.scale;
    let left = 0, right = 0, top = 0, bottom2 = 0;
    side == "left" || side === "topLeft" || side === "bottomLeft" ? left = pos.x * scale / image.width : (side == "right" || side === "topRight" || side === "bottomRight") && (right = -pos.x * scale / image.width), side == "top" || side === "topLeft" || side === "topRight" ? top = pos.y * scale / image.height : (side == "bottom" || side === "bottomLeft" || side === "bottomRight") && (bottom2 = -pos.y * scale / image.height);
    const delta = { left, right, top, bottom: bottom2 }, newValue = limitToBoundaries(value, delta).value, newDelta = limitToBoundaries(value, delta).delta;
    onChange(applyCropMoveBy(newValue, newDelta));
  }
  emitResize(pos) {
    const { image, onChange, value } = this.props, scale = this.props.scale, delta = {
      x: pos.x * scale * 2 / image.width,
      y: pos.y * scale * 2 / image.height
    };
    onChange(applyHotspotResizeBy(value, { height: delta.y, width: delta.x }));
  }
  getDragHandleCoords() {
    const bbox = this.props.hotspotRect, point = getPointAtCircumference(Math.PI * 1.25, bbox);
    return {
      x: point.x,
      y: point.y,
      radius: 8 * this.props.scale
    };
  }
  getCursor() {
    const { pointerPosition } = this.state, { readOnly } = this.props;
    if (!pointerPosition || readOnly)
      return "auto";
    const activeCropArea = this.state.cropping || this.getActiveCropHandleFor(pointerPosition);
    if (activeCropArea)
      return getCropCursorForHandle(activeCropArea) || "auto";
    const pointerOverDragHandle = isPointInCircle(
      pointerPosition,
      this.getDragHandleCoords()
    );
    if (this.state.resizing || pointerOverDragHandle)
      return "move";
    if (this.state.moving || this.state.cropMoving)
      return `url(${CLOSE_HAND}), move`;
    const pointerOverHotspot = isPointInEllipse(pointerPosition, this.props.hotspotRect), pointerOverCropRect = isPointInRect(pointerPosition, this.props.cropRect);
    return pointerOverHotspot || pointerOverCropRect ? `url(${OPEN_HAND}), move` : "auto";
  }
  componentDidMount() {
    const { canvas } = this;
    canvas && this.draw({ canvas });
  }
  componentDidUpdate() {
    const { canvas } = this;
    canvas && this.draw({ canvas });
  }
  draw({ canvas }) {
    const context = canvas.getContext("2d");
    if (!context)
      return;
    const { clampedValue, cropHandles, cropRect, hotspotRect, image, ratio, readOnly, scale } = this.props, { cropping, pointerPosition } = this.state;
    paint({
      clampedValue,
      context,
      cropHandles,
      cropping,
      cropRect,
      HOTSPOT_HANDLE_SIZE,
      hotspotRect,
      image,
      MARGIN_PX,
      pointerPosition,
      ratio,
      readOnly,
      scale
    });
    const currentCursor = canvas.style.cursor, newCursor = this.getCursor();
    currentCursor !== newCursor && (canvas.style.cursor = newCursor);
  }
  render() {
    const { image, readOnly, ratio } = this.props;
    return /* @__PURE__ */ jsxRuntime.jsx(RootContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(
      DragAwareCanvas,
      {
        readOnly,
        ref: this.setCanvas,
        onDrag: this.handleDrag,
        onDragStart: this.handleDragStart,
        onDragEnd: this.handleDragEnd,
        onPointerMove: this.handlePointerMove,
        onPointerOut: this.handlePointerOut,
        height: image.height * ratio,
        width: image.width * ratio
      }
    ) });
  }
}
function applyHotspotMoveBy(value, delta) {
  const currentHotspot = value && value.hotspot || DEFAULT_HOTSPOT;
  return {
    ...value,
    hotspot: {
      ...currentHotspot,
      x: currentHotspot.x + delta.x,
      y: currentHotspot.y + delta.y
    }
  };
}
function applyHotspotResizeBy(value, delta) {
  const currentHotspot = value && value.hotspot || DEFAULT_HOTSPOT;
  return {
    ...value,
    hotspot: {
      ...currentHotspot,
      height: currentHotspot.height + delta.height,
      width: currentHotspot.width + delta.width
    }
  };
}
function applyCropMoveBy(value, delta) {
  const currentCrop = value && value.crop || DEFAULT_CROP;
  return {
    ...value,
    crop: {
      left: currentCrop.left + (delta.left || 0),
      right: currentCrop.right + (delta.right || 0),
      top: currentCrop.top + (delta.top || 0),
      bottom: currentCrop.bottom + (delta.bottom || 0)
    }
  };
}
function ImageTool(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ImageLoader, { src: props2.src, children: ({ isLoading, image, error }) => isLoading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : error ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: error.message }) : image ? /* @__PURE__ */ jsxRuntime.jsx(Resize, { image, maxHeight: ImageTool.maxHeight, maxWidth: ImageTool.maxWidth, children: (canvas) => /* @__PURE__ */ jsxRuntime.jsx(ToolCanvas, { image: canvas, ...props2 }) }) : null });
}
ImageTool.maxHeight = 500;
ImageTool.maxWidth = 1e3;
const PROBABLY_THE_TINIEST_GIF_EVER = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
function isBlob(src) {
  return src.startsWith("blob:");
}
function loadImage(src) {
  return new rxjs.Observable((subscriber) => {
    const image = document.createElement("img");
    let completed = !1;
    const onload = () => {
      completed = !0, subscriber.next(image), subscriber.complete();
    }, onerror = () => {
      completed = !0, subscriber.error(new Error(`Could not load image from ${isBlob(src) ? "blob" : src}`));
    };
    return image.onload = onload, image.onerror = onerror, image.src = src, () => {
      image.onload = null, image.onerror = null, completed || (image.src = PROBABLY_THE_TINIEST_GIF_EVER);
    };
  });
}
const INITIAL_STATE$5 = { isLoading: !0 };
function useLoadImage(url) {
  const [state, setState] = React.useState(INITIAL_STATE$5);
  return React.useEffect(() => {
    setState(INITIAL_STATE$5);
    const subscription = loadImage(url).subscribe({
      error: (err) => {
        setState({ isLoading: !1, error: err });
      },
      next: (image) => {
        setState({ image, isLoading: !1 });
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [url]), state;
}
const HOTSPOT_PATH = ["hotspot"], PREVIEW_ASPECT_RATIOS = [
  ["3:4", 3 / 4],
  ["Square", 1 / 1],
  ["16:9", 16 / 9],
  ["Panorama", 4 / 1]
], DEFAULT_VALUE = {
  crop: DEFAULT_CROP,
  hotspot: DEFAULT_HOTSPOT
}, Placeholder$2 = styledComponents.styled.div`
  min-height: 6em;
`;
function LoadStatus(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", padding: 4, style: { overflowWrap: "break-word" }, children: props2.children });
}
function ImageToolInput(props2) {
  const {
    imageUrl,
    value,
    changed,
    level,
    path,
    focusPath = EMPTY_ARRAY$t,
    presence,
    onChange,
    schemaType,
    onPathFocus,
    readOnly,
    elementProps
  } = props2, [localValue, setLocalValue] = React.useState(value || DEFAULT_VALUE), { image, isLoading: isImageLoading, error: imageLoadError } = useLoadImage(imageUrl), handleFocus = React.useCallback(() => {
    onPathFocus(HOTSPOT_PATH);
  }, [onPathFocus]);
  React.useEffect(() => {
    setLocalValue(value || DEFAULT_VALUE);
  }, [value]);
  const hasFocus = focusPath[0] === "hotspot";
  useDidUpdate(hasFocus, (hadFocus) => {
    var _a2;
    !hadFocus && hasFocus && ((_a2 = elementProps.ref.current) == null || _a2.focus());
  });
  const handleChangeEnd = React.useCallback(
    (finalValue) => {
      if (readOnly)
        return;
      const cropField = schemaType.fields.find(
        (field) => field.name === "crop" && field.type.name !== "object"
      ), hotspotField = schemaType.fields.find(
        (field) => field.type.name !== "object" && field.name === "hotspot"
      ), crop = cropField ? { _type: cropField.type.name, ...finalValue.crop || DEFAULT_CROP } : finalValue.crop, hotspot = hotspotField ? { _type: hotspotField.type.name, ...finalValue.hotspot || DEFAULT_HOTSPOT } : finalValue.hotspot;
      onChange([set(crop, ["crop"]), set(hotspot, ["hotspot"])]);
    },
    [onChange, readOnly, schemaType.fields]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormField,
    {
      title: t2("inputs.imagetool.title"),
      level,
      description: t2("inputs.imagetool.description"),
      deprecated: schemaType.deprecated,
      __unstable_presence: presence,
      children: /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            __unstable_checkered: !0,
            __unstable_focusRing: !0,
            tabIndex: 0,
            ref: elementProps.ref,
            onFocus: handleFocus,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ChangeIndicator,
              {
                path: path.concat(HOTSPOT_PATH),
                hasFocus: focusPath[0] === "hotspot",
                isChanged: changed,
                children: /* @__PURE__ */ jsxRuntime.jsxs(RatioBox$1, { ratio: 3 / 2, children: [
                  (isImageLoading || imageLoadError) && /* @__PURE__ */ jsxRuntime.jsx(LoadStatus, { children: imageLoadError ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, tone: "critical", border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: t2("inputs.imagetool.load-error", {
                    errorMessage: imageLoadError.message
                  }) }) }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) }),
                  !isImageLoading && image && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
                    ImageTool,
                    {
                      value: localValue,
                      src: image.src,
                      readOnly: !!readOnly,
                      onChangeEnd: handleChangeEnd,
                      onChange: setLocalValue
                    }
                  ) })
                ] })
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { columns: PREVIEW_ASPECT_RATIOS.length, gap: 1, children: PREVIEW_ASPECT_RATIOS.map(([title, ratio]) => /* @__PURE__ */ jsxRuntime.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h4", size: 0, children: title }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(RatioBox$1, { ratio, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { __unstable_checkered: !0, children: !isImageLoading && image ? /* @__PURE__ */ jsxRuntime.jsx(
            HotspotImage,
            {
              aspectRatio: ratio,
              src: image.src,
              srcAspectRatio: image.width / image.height,
              hotspot: localValue.hotspot || DEFAULT_HOTSPOT,
              crop: localValue.crop || DEFAULT_CROP
            }
          ) : /* @__PURE__ */ jsxRuntime.jsx(Placeholder$2, {}) }) }) })
        ] }, ratio)) }) })
      ] })
    }
  );
}
const MenuActionsWrapper = styledComponents.styled(ui.Inline)`
  position: absolute;
  top: 0;
  right: 0;
`;
function ImageActionsMenu(props2) {
  const {
    onEdit,
    children,
    showEdit,
    setHotspotButtonElement,
    setMenuButtonElement,
    onMenuOpen,
    isMenuOpen
  } = props2, [menuElement, setMenuElement] = React.useState(null), [buttonElement, setButtonElement] = React.useState(null), handleClick = React.useCallback(() => onMenuOpen(!isMenuOpen), [onMenuOpen, isMenuOpen]);
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        isMenuOpen && (event.key === "Escape" || event.key === "Tab") && (onMenuOpen(!1), buttonElement == null || buttonElement.focus());
      },
      [isMenuOpen, onMenuOpen, buttonElement]
    )
  ), ui.useClickOutside(
    React.useCallback(
      (event) => {
        buttonElement != null && buttonElement.contains(event.target) || onMenuOpen(!1);
      },
      [buttonElement, onMenuOpen]
    ),
    [menuElement]
  );
  const setOptionsButtonRef = React.useCallback(
    (el) => {
      setMenuButtonElement(el), setButtonElement(el);
    },
    [setMenuButtonElement]
  );
  React.useEffect(() => {
    isMenuOpen && (menuElement == null || menuElement.focus());
  }, [isMenuOpen, menuElement]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(MenuActionsWrapper, { "data-buttons": !0, space: 1, padding: 2, children: [
    showEdit && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": t2("inputs.image.actions-menu.edit-details.aria-label"),
        "data-testid": "options-menu-edit-details",
        icon: icons.CropIcon,
        mode: "ghost",
        onClick: onEdit,
        ref: setHotspotButtonElement,
        tooltipProps: { content: t2("inputs.image.actions-menu.crop-image-tooltip") }
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Popover,
      {
        id: "image-actions-menu",
        content: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { ref: setMenuElement, children }),
        portal: !0,
        open: isMenuOpen,
        constrainSize: !0,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ContextMenuButton,
          {
            "aria-label": t2("inputs.image.actions-menu.options.aria-label"),
            "data-testid": "options-menu-button",
            mode: "ghost",
            onClick: handleClick,
            ref: setOptionsButtonRef
          }
        )
      }
    )
  ] }) });
}
const MAX_DEFAULT_HEIGHT = 30, RatioBox = styledComponents.styled(ui.Card)`
  position: relative;
  width: 100%;
  overflow: hidden;
  overflow: clip;
  min-height: 3.75rem;
  max-height: 20rem;

  & > div[data-container] {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex !important;
    align-items: center;
    justify-content: center;
  }

  & img {
    max-width: 100%;
    max-height: 100%;
  }
`, Overlay = styledComponents.styled(ui.Flex)(({ $drag, $tone }) => {
  const textColor = ui.studioTheme.color.light[$tone].card.enabled.fg, backgroundColor = ui.rgba(ui.studioTheme.color.light[$tone].card.enabled.bg, 0.8);
  return styledComponents.css`
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    backdrop-filter: ${$drag ? "blur(10px)" : ""};
    color: ${$tone ? textColor : ""};
    background-color: ${$drag ? backgroundColor : "transparent"};
  `;
}), FlexOverlay = styledComponents.styled(ui.Flex)`
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
`, getImageSize = (src) => {
  const rect = new URLSearchParams(src.split("?")[1]).get("rect");
  return rect ? [rect.split(",")[2], rect.split(",")[3]].map(Number) : src.split("-")[1].split(".")[0].split("x").map(Number);
};
function ImagePreview$1(props2) {
  const { drag, readOnly, isRejected, src, ...rest } = props2, [isLoaded, setLoaded] = React.useState(!1), [rootElement, setRootElement] = React.useState(null), rootRect = ui.useElementRect(rootElement), rootWidth = (rootRect == null ? void 0 : rootRect.width) || 0, tone = drag ? isRejected || readOnly ? "critical" : "primary" : "default", maxHeightToPx = MAX_DEFAULT_HEIGHT * document.documentElement.clientHeight / 100, [imageWidth, imageHeight] = getImageSize(src), imageRatio = imageWidth / imageHeight, rootHeight = (imageWidth > rootWidth ? rootWidth / imageRatio : imageHeight) < maxHeightToPx ? null : `${MAX_DEFAULT_HEIGHT}vh`;
  React.useEffect(() => {
    setLoaded(!1);
  }, [src]);
  const onLoadChange = React.useCallback(() => {
    setLoaded(!0);
  }, []), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(RatioBox, { ...rest, ref: setRootElement, style: { height: rootHeight }, tone: "transparent", children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { "data-container": !0, tone: "inherit", children: [
      !isLoaded && /* @__PURE__ */ jsxRuntime.jsx(OverlayComponent, { cardTone: "transparent", drag: !0, content: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        "img",
        {
          src,
          "data-testid": "hotspot-image-input",
          alt: props2.alt,
          onLoad: onLoadChange,
          referrerPolicy: "strict-origin-when-cross-origin"
        }
      )
    ] }),
    drag && /* @__PURE__ */ jsxRuntime.jsx(
      OverlayComponent,
      {
        cardTone: tone,
        drag,
        content: /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { children: /* @__PURE__ */ jsxRuntime.jsx(HoverIcon, { isRejected, readOnly }) }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2(getHoverTextTranslationKey({ isRejected, readOnly })) })
        ] })
      }
    )
  ] });
}
function HoverIcon({ isRejected, readOnly }) {
  return isRejected ? /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) : readOnly ? /* @__PURE__ */ jsxRuntime.jsx(icons.ReadOnlyIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(icons.ImageIcon, {});
}
function getHoverTextTranslationKey({
  isRejected,
  readOnly
}) {
  return isRejected ? "inputs.image.drag-overlay.this-field-is-read-only" : readOnly ? "inputs.image.drag-overlay.cannot-upload-here" : "inputs.image.drag-overlay.drop-to-upload-image";
}
function OverlayComponent({
  cardTone,
  drag,
  content: content2
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(Overlay, { justify: "flex-end", padding: 3, $drag: drag, $tone: cardTone, children: /* @__PURE__ */ jsxRuntime.jsx(FlexOverlay, { direction: "column", align: "center", justify: "center", children: content2 }) });
}
function InvalidImageWarning({ onClearValue }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { tone: "caution", padding: 4, border: !0, radius: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 4, marginBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("inputs.image.invalid-image-warning.title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("inputs.image.invalid-image-warning.description") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.ResetIcon,
        mode: "ghost",
        onClick: onClearValue,
        text: t2("inputs.image.invalid-image-warning.reset-button.text"),
        width: "fill"
      }
    )
  ] });
}
var __defProp$6 = Object.defineProperty, __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key != "symbol" ? key + "" : key, value);
const getDevicePixelRatio = () => typeof window > "u" || !window.devicePixelRatio ? 1 : Math.round(Math.max(1, window.devicePixelRatio));
function passThrough({ children }) {
  return children;
}
const ASSET_FIELD_PATH = ["asset"], ASSET_IMAGE_MENU_POPOVER = { portal: !0 };
class BaseImageInput extends React.PureComponent {
  constructor(props2) {
    super(props2), __publicField$6(this, "_previewElement", null), __publicField$6(this, "_assetPath"), __publicField$6(this, "uploadSubscription", null), __publicField$6(this, "state", {
      isUploading: !1,
      selectedAssetSource: null,
      hoveringFiles: [],
      isStale: !1,
      hotspotButtonElement: null,
      menuButtonElement: null,
      isMenuOpen: !1
    }), __publicField$6(this, "toast", null), __publicField$6(this, "setPreviewElement", (el) => {
      this._previewElement = el;
    }), __publicField$6(this, "setHotspotButtonElement", (el) => {
      this.setState({ hotspotButtonElement: el });
    }), __publicField$6(this, "setMenuButtonElement", (el) => {
      this.setState({ menuButtonElement: el });
    }), __publicField$6(this, "getUploadOptions", (file) => {
      const { schemaType, resolveUploader: resolveUploader2 } = this.props, uploader = resolveUploader2 && resolveUploader2(schemaType, file);
      return uploader ? [{ type: schemaType, uploader }] : [];
    }), __publicField$6(this, "uploadWith", (uploader, file, assetDocumentProps = {}) => {
      const { schemaType, onChange, client: client2, t: t2 } = this.props, { label, title, description, creditLine, source } = assetDocumentProps, options = {
        metadata: get__default.default(schemaType, "options.metadata"),
        storeOriginalFilename: get__default.default(schemaType, "options.storeOriginalFilename"),
        label,
        title,
        description,
        creditLine,
        source
      };
      this.cancelUpload(), this.setState({ isUploading: !0 }), onChange(setIfMissing({ _type: schemaType.name })), this.uploadSubscription = uploader.upload(client2, file, schemaType, options).subscribe({
        next: (uploadEvent) => {
          uploadEvent.patches && onChange(uploadEvent.patches);
        },
        error: (err) => {
          var _a2;
          console.error(err), (_a2 = this.toast) == null || _a2.push({
            status: "error",
            description: t2("inputs.image.upload-error.description"),
            title: t2("inputs.image.upload-error.title")
          }), this.clearUploadStatus();
        },
        complete: () => {
          onChange([unset(["hotspot"]), unset(["crop"])]), this.setState({ isUploading: !1 });
        }
      });
    }), __publicField$6(this, "handleRemoveButtonClick", () => {
      const { value } = this.props, allKeys = Object.keys(value || {}), isEmpty2 = allKeys.filter(
        (key) => !["_type", "_key", "_upload", "asset", "crop", "hotspot"].includes(key)
      ).length === 0, removeKeys = ["asset"].concat(allKeys.filter((key) => ["crop", "hotspot", "_upload"].includes(key))).map((key) => unset([key]));
      this.props.onChange(isEmpty2 && !this.valueIsArrayElement() ? unset() : removeKeys);
    }), __publicField$6(this, "handleFieldChange", (event) => {
      const { onChange, schemaType } = this.props;
      if (!this.valueIsArrayElement() && this.eventIsUnsettingLastFilledField(event)) {
        onChange(unset());
        return;
      }
      onChange(
        event.prepend(
          setIfMissing({
            _type: schemaType.name
          })
        ).patches
      );
    }), __publicField$6(this, "eventIsUnsettingLastFilledField", (event) => {
      const patch2 = event.patches[0];
      if (event.patches.length !== 1 || patch2.type !== "unset")
        return !1;
      const remainingKeys = Object.keys(this.props.value || {}).filter(
        (key) => !["_type", "_key", "crop", "hotspot"].includes(key)
      );
      return event.patches[0].path.length === 1 && remainingKeys.length === 1 && remainingKeys[0] === event.patches[0].path[0];
    }), __publicField$6(this, "valueIsArrayElement", () => {
      const { path } = this.props;
      return typeof path.slice(-1)[0] != "string";
    }), __publicField$6(this, "handleOpenDialog", () => {
      this.props.onPathFocus(["hotspot"]);
    }), __publicField$6(this, "handleCloseDialog", () => {
      var _a2;
      this.props.onPathFocus([]), (_a2 = this.state.hotspotButtonElement) == null || _a2.focus();
    }), __publicField$6(this, "handleSelectAssetFromSource", (assetFromSource) => {
      const { onChange, schemaType, resolveUploader: resolveUploader2 } = this.props;
      handleSelectAssetFromSource({
        assetFromSource,
        onChange,
        type: schemaType,
        resolveUploader: resolveUploader2,
        uploadWith: this.uploadWith,
        isImage: !0
      }), this.setState({ selectedAssetSource: null });
    }), __publicField$6(this, "handleFileTargetFocus", (event) => {
      var _a2;
      event.currentTarget === event.target && event.currentTarget === ((_a2 = this.props.elementProps.ref) == null ? void 0 : _a2.current) && this.props.elementProps.onFocus(event);
    }), __publicField$6(this, "handleFilesOver", (hoveringFiles) => {
      this.setState({
        hoveringFiles: hoveringFiles.filter((file) => file.kind !== "string")
      });
    }), __publicField$6(this, "handleFilesOut", () => {
      this.setState({
        hoveringFiles: []
      });
    }), __publicField$6(this, "handleCancelUpload", () => {
      this.cancelUpload();
    }), __publicField$6(this, "handleClearUploadState", () => {
      this.setState({ isStale: !1 }), this.clearUploadStatus();
    }), __publicField$6(this, "handleStaleUpload", () => {
      this.setState({ isStale: !0 });
    }), __publicField$6(this, "handleClearField", () => {
      this.props.onChange([unset(["asset"]), unset(["crop"]), unset(["hotspot"])]);
    }), __publicField$6(this, "handleSelectFiles", (files) => {
      const { directUploads, readOnly } = this.props, { hoveringFiles } = this.state;
      directUploads && !readOnly ? this.uploadFirstAccepted(files) : hoveringFiles.length > 0 && this.handleFilesOut();
    }), __publicField$6(this, "handleSelectImageFromAssetSource", (source) => {
      this.setState({ selectedAssetSource: source });
    }), __publicField$6(this, "handleAssetSourceClosed", () => {
      var _a2;
      this.setState({ selectedAssetSource: null }), (_a2 = this.state.menuButtonElement) == null || _a2.focus();
    }), __publicField$6(this, "renderHotspotInput", (hotspotInputProps) => {
      const { value, changed, id: id2, imageUrlBuilder: imageUrlBuilder2, t: t2 } = this.props, withImageTool = this.isImageToolEnabled() && value && value.asset;
      return /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Dialog,
        {
          __unstable_autoFocus: !1,
          header: t2("inputs.image.hotspot-dialog.title"),
          id: `${id2}_dialog`,
          onClickOutside: this.handleCloseDialog,
          onClose: this.handleCloseDialog,
          width: 1,
          children: /* @__PURE__ */ jsxRuntime.jsx(PresenceOverlay, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 5, children: withImageTool && (value == null ? void 0 : value.asset) && /* @__PURE__ */ jsxRuntime.jsx(
            ImageToolInput,
            {
              ...this.props,
              imageUrl: imageUrlBuilder2.image(value.asset).url(),
              value,
              presence: hotspotInputProps.presence,
              changed
            }
          ) }) })
        }
      );
    }), __publicField$6(this, "renderPreview", () => {
      const { value, schemaType, readOnly, directUploads, imageUrlBuilder: imageUrlBuilder2, t: t2, resolveUploader: resolveUploader2 } = this.props;
      if (!value || !assetUtils.isImageSource(value))
        return null;
      const { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, imageUrl = imageUrlBuilder2.width(2e3).fit("max").image(value).dpr(getDevicePixelRatio()).auto("format").url();
      return /* @__PURE__ */ jsxRuntime.jsx(
        ImagePreview$1,
        {
          onDoubleClick: this.handleOpenDialog,
          drag: !(value != null && value._upload) && hoveringFiles.length > 0,
          isRejected: rejectedFilesCount > 0 || !directUploads,
          readOnly,
          src: imageUrl,
          alt: t2("inputs.image.preview-uploaded-image")
        }
      );
    }), __publicField$6(this, "setToast", (toast) => {
      this.toast = toast;
    }), this._assetPath = props2.path.concat(ASSET_FIELD_PATH);
  }
  isImageToolEnabled() {
    return get__default.default(this.props.schemaType, "options.hotspot") === !0;
  }
  clearUploadStatus() {
    var _a2;
    (_a2 = this.props.value) != null && _a2._upload && this.props.onChange(unset(["_upload"]));
  }
  cancelUpload() {
    this.uploadSubscription && (this.uploadSubscription.unsubscribe(), this.clearUploadStatus());
  }
  uploadFirstAccepted(files) {
    const { schemaType, resolveUploader: resolveUploader2 } = this.props, match = files.map((file) => ({ file, uploader: resolveUploader2(schemaType, file) })).find((result) => result.uploader);
    match && this.uploadWith(match.uploader, match.file), this.setState({ isMenuOpen: !1 });
  }
  renderAssetMenu() {
    const {
      value,
      assetSources,
      schemaType,
      readOnly,
      directUploads,
      imageUrlBuilder: imageUrlBuilder2,
      observeAsset,
      t: t2
    } = this.props, asset = value == null ? void 0 : value.asset;
    if (!asset)
      return null;
    const accept = get__default.default(schemaType, "options.accept", "image/*"), showAdvancedEditButton = value && asset && this.isImageToolEnabled();
    let browseMenuItem = assetSources && assetSources.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        icon: icons.SearchIcon,
        text: t2("inputs.image.browse-menu.text"),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSources[0]);
        },
        disabled: readOnly,
        "data-testid": "file-input-browse-button"
      }
    );
    return assetSources && assetSources.length > 1 && (browseMenuItem = assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        text: (assetSource.i18nKey ? t2(assetSource.i18nKey) : assetSource.title) || startCase__default.default(assetSource.name),
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSource);
        },
        icon: assetSource.icon || icons.ImageIcon,
        "data-testid": `file-input-browse-button-${assetSource.name}`,
        disabled: readOnly
      },
      assetSource.name
    ))), /* @__PURE__ */ jsxRuntime.jsx(WithReferencedAsset, { observeAsset, reference: asset, children: ({ _id, originalFilename, extension }) => {
      let copyUrl, downloadUrl;
      if (assetUtils.isImageSource(value)) {
        const filename = originalFilename || `download.${extension}`;
        downloadUrl = imageUrlBuilder2.image(_id).forceDownload(filename).url(), copyUrl = imageUrlBuilder2.image(_id).url();
      }
      return /* @__PURE__ */ jsxRuntime.jsx(
        ImageActionsMenu,
        {
          isMenuOpen: this.state.isMenuOpen,
          onEdit: this.handleOpenDialog,
          onMenuOpen: (isOpen) => this.setState({ isMenuOpen: isOpen }),
          setHotspotButtonElement: this.setHotspotButtonElement,
          setMenuButtonElement: this.setMenuButtonElement,
          showEdit: showAdvancedEditButton,
          children: /* @__PURE__ */ jsxRuntime.jsx(
            ActionsMenu,
            {
              onUpload: this.handleSelectFiles,
              browse: browseMenuItem,
              onReset: this.handleRemoveButtonClick,
              downloadUrl,
              copyUrl,
              readOnly,
              directUploads,
              accept
            }
          )
        }
      );
    } });
  }
  renderBrowser() {
    const { assetSources, readOnly, directUploads, id: id2, t: t2 } = this.props;
    return assetSources && assetSources.length === 0 ? null : assetSources && assetSources.length > 1 && !readOnly && directUploads ? /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        id: `${id2}_assetImageButton`,
        ref: this.setMenuButtonElement,
        button: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            "data-testid": "file-input-multi-browse-button",
            icon: icons.SearchIcon,
            iconRight: icons.ChevronDownIcon,
            mode: "bleed",
            text: t2("inputs.image.browse-menu.text")
          }
        ),
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: assetSources.map((assetSource) => /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            text: (assetSource.i18nKey ? t2(assetSource.i18nKey) : assetSource.title) || startCase__default.default(assetSource.name),
            onClick: () => {
              this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSource);
            },
            icon: assetSource.icon || icons.ImageIcon,
            disabled: readOnly,
            "data-testid": `file-input-browse-button-${assetSource.name}`
          },
          assetSource.name
        )) }),
        popover: ASSET_IMAGE_MENU_POPOVER
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        text: t2("inputs.image.browse-menu.text"),
        icon: icons.SearchIcon,
        mode: "bleed",
        onClick: () => {
          this.setState({ isMenuOpen: !1 }), this.handleSelectImageFromAssetSource(assetSources[0]);
        },
        "data-testid": "file-input-browse-button",
        disabled: readOnly
      }
    );
  }
  renderUploadPlaceholder() {
    const { schemaType, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length, accept = get__default.default(schemaType, "options.accept", "image/*");
    return /* @__PURE__ */ jsxRuntime.jsx("div", { style: { padding: 1 }, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        tone: readOnly ? "transparent" : "inherit",
        border: !0,
        paddingX: 3,
        paddingY: 2,
        radius: 2,
        style: hoveringFiles.length === 0 ? {} : { borderColor: "transparent" },
        children: /* @__PURE__ */ jsxRuntime.jsx(
          UploadPlaceholder,
          {
            browse: this.renderBrowser(),
            onUpload: this.handleSelectFiles,
            readOnly,
            hoveringFiles,
            acceptedFiles,
            rejectedFilesCount,
            type: "image",
            accept,
            directUploads
          }
        )
      }
    ) });
  }
  renderUploadState(uploadState) {
    var _a2;
    const { isUploading } = this.state, height = (_a2 = this._previewElement) == null ? void 0 : _a2.offsetHeight;
    return /* @__PURE__ */ jsxRuntime.jsx(
      UploadProgress,
      {
        uploadState,
        onCancel: isUploading ? this.handleCancelUpload : void 0,
        onStale: this.handleStaleUpload,
        height
      }
    );
  }
  renderAssetSource() {
    const { selectedAssetSource } = this.state, { value, schemaType, observeAsset } = this.props, accept = get__default.default(schemaType, "options.accept", "image/*");
    if (!selectedAssetSource)
      return null;
    const Component = selectedAssetSource.component;
    return value && value.asset ? /* @__PURE__ */ jsxRuntime.jsx(WithReferencedAsset, { observeAsset, reference: value.asset, children: (imageAsset2) => /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        selectedAssets: [imageAsset2],
        assetType: "image",
        accept,
        selectionType: "single",
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }
    ) }) : /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        selectedAssets: [],
        selectionType: "single",
        assetType: "image",
        accept,
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }
    );
  }
  getFileTone() {
    const { schemaType, value, readOnly, directUploads, resolveUploader: resolveUploader2 } = this.props, { hoveringFiles } = this.state, acceptedFiles = hoveringFiles.filter((file) => resolveUploader2(schemaType, file)), rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
    return hoveringFiles.length > 0 && (rejectedFilesCount > 0 || !directUploads) ? "critical" : !(value != null && value._upload) && !readOnly && hoveringFiles.length > 0 ? "primary" : readOnly || value != null && value._upload && value != null && value.asset ? "transparent" : "default";
  }
  renderAsset() {
    const { value, readOnly, elementProps } = this.props, { hoveringFiles, isStale } = this.state, hasValueOrUpload = !!(value != null && value._upload || value != null && value.asset);
    return value && typeof value.asset < "u" && !(value != null && value._upload) && !assetUtils.isImageSource(value) ? () => /* @__PURE__ */ jsxRuntime.jsx(InvalidImageWarning, { onClearValue: this.handleClearField }) : (inputProps) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      isStale && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(UploadWarning, { onClearStale: this.handleClearUploadState }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        ChangeIndicator,
        {
          path: inputProps.path.concat(ASSET_FIELD_PATH),
          hasFocus: !!inputProps.focused,
          isChanged: inputProps.changed,
          children: value != null && value._upload ? this.renderUploadState(value._upload) : /* @__PURE__ */ jsxRuntime.jsxs(
            FileTarget,
            {
              ...elementProps,
              onFocus: this.handleFileTargetFocus,
              tabIndex: 0,
              disabled: !!readOnly,
              onFiles: this.handleSelectFiles,
              onFilesOver: this.handleFilesOver,
              onFilesOut: this.handleFilesOut,
              tone: this.getFileTone(),
              $border: hasValueOrUpload || hoveringFiles.length > 0,
              sizing: "border",
              radius: 2,
              children: [
                !(value != null && value.asset) && this.renderUploadPlaceholder(),
                !(value != null && value._upload) && (value == null ? void 0 : value.asset) && /* @__PURE__ */ jsxRuntime.jsxs("div", { style: { position: "relative" }, ref: this.setPreviewElement, children: [
                  this.renderPreview(),
                  this.renderAssetMenu()
                ] })
              ]
            }
          )
        }
      )
    ] });
  }
  render() {
    const {
      focusPath,
      members,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview
    } = this.props, { selectedAssetSource } = this.state, hotspotField = members.find(
      (member) => member.kind === "field" && member.name === "hotspot"
    );
    return (
      // The Stack space should match the space in ObjectInput
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, "data-testid": "image-input", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ImperativeToast, { ref: this.setToast }),
        members.map((member) => member.kind === "field" && (member.name === "crop" || member.name === "hotspot") ? null : member.kind === "field" ? /* @__PURE__ */ jsxRuntime.jsx(
          MemberField,
          {
            member,
            renderAnnotation,
            renderBlock: renderBlock2,
            renderInlineBlock,
            renderInput: member.name === "asset" ? this.renderAsset() : renderInput,
            renderField: member.name === "asset" ? passThrough : renderField,
            renderItem: renderItem2,
            renderPreview
          },
          member.key
        ) : member.kind === "fieldSet" ? /* @__PURE__ */ jsxRuntime.jsx(
          MemberFieldSet,
          {
            member,
            renderAnnotation,
            renderBlock: renderBlock2,
            renderField,
            renderInlineBlock,
            renderInput,
            renderItem: renderItem2,
            renderPreview
          },
          member.key
        ) : member.kind === "error" ? /* @__PURE__ */ jsxRuntime.jsx(MemberFieldError, { member }, member.key) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t("inputs.image.error.unknown-member-kind", { kind: member.kind }) })),
        hotspotField && focusPath[0] === "hotspot" && /* @__PURE__ */ jsxRuntime.jsx(
          FormInput,
          {
            ...this.props,
            absolutePath: hotspotField.field.path,
            renderInput: this.renderHotspotInput
          }
        ),
        selectedAssetSource && this.renderAssetSource()
      ] })
    );
  }
}
function StudioImageInput(props2) {
  var _a2;
  const sourcesFromSchema = (_a2 = props2.schemaType.options) == null ? void 0 : _a2.sources, { image } = useFormBuilder().__internal, documentPreviewStore = useDocumentPreviewStore(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), supportsImageUploads = image.directUploads, resolveUploader$1 = React.useCallback(
    (type, file) => supportsImageUploads ? resolveUploader(type, file) : null,
    [supportsImageUploads]
  ), assetSources = React.useMemo(
    () => sourcesFromSchema || image.assetSources,
    [image, sourcesFromSchema]
  ), builder = React.useMemo(() => imageUrlBuilder__default.default(client2), [client2]), observeAsset = React.useCallback(
    (id2) => observeImageAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  ), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    BaseImageInput,
    {
      ...props2,
      t: t2,
      client: client2,
      assetSources,
      directUploads: supportsImageUploads,
      imageUrlBuilder: builder,
      observeAsset,
      resolveUploader: resolveUploader$1
    }
  );
}
const defaultInputs = {
  document: ObjectInput,
  object: ObjectInput,
  array: UniversalArrayInput,
  boolean: BooleanInput,
  number: NumberInput,
  text: TextInput,
  email: EmailInput,
  datetime: DateTimeInput$2,
  date: DateInput,
  url: UrlInput,
  image: StudioImageInput,
  file: StudioFileInput,
  string: StringInput,
  slug: SlugInput,
  crossDatasetReference: StudioCrossDatasetReferenceInput
}, PortableTextInputExpanded = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Expanded",
  description: "The portable text editor was expanded"
}), PortableTextInputCollapsed = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Collapsed",
  description: "The portable text editor was collapsed"
}), PortableTextInvalidValueIgnore = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Invalid Value Ignored",
  description: "The portable text got an invalid value from the form and pressed button to ignore it"
}), PortableTextInvalidValueResolve = telemetry.defineEvent({
  version: 1,
  name: "Portable Text Editor Invalid Value Resolved",
  description: "The portable text got an invalid value from the form and pressed button to resolve it."
}), OverlayContainer = styledComponents.styled.div`
  position: relative;
`, ContentContainer = styledComponents.styled.div`
  z-index: 13;
  opacity: 0;
  transition: opacity 300ms linear;
`, CardContainer = styledComponents.styled(ui.Card)`
  border: 1px solid var(--card-border-color);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 12;
  transition: opacity 150ms ease-in-out;
  opacity: 0;
  box-sizing: border-box;
`, FlexContainer = styledComponents.styled(ui.Flex)`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;

  &:hover,
  &:focus {
    & ${CardContainer} {
      opacity: 0.9;
    }

    & ${ContentContainer} {
      opacity: 1;
    }
  }
`, isTouchDevice = () => typeof window < "u" && "ontouchstart" in window || typeof navigator < "u" && navigator.maxTouchPoints > 0;
function ActivateOnFocus(props2) {
  const { children, message, onActivate, isOverlayActive } = props2, [focused, setFocused] = React.useState(!1), { t: t2 } = useTranslation(), handleClick = React.useCallback(() => {
    onActivate && onActivate();
  }, [onActivate]), handleKeyDown = React.useCallback(
    (event) => {
      isOverlayActive && event.code === "Space" && onActivate && (event.preventDefault(), onActivate());
    },
    [isOverlayActive, onActivate]
  ), handleOnFocus = React.useCallback(() => {
    setFocused(!0);
  }, []), handleBlur = React.useCallback(() => {
    setFocused(!1);
  }, []), msg = React.useMemo(() => {
    const isTouch = isTouchDevice();
    let messageContext;
    isTouch ? messageContext = "tap" : focused ? messageContext = "click-focused" : messageContext = "click";
    const text = message || t2("inputs.portable-text.activate-on-focus-message", {
      context: messageContext
    });
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: text });
  }, [focused, message, t2]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    OverlayContainer,
    {
      onBlur: handleBlur,
      onClick: handleClick,
      onFocus: handleOnFocus,
      onKeyDown: handleKeyDown,
      children: [
        isOverlayActive && /* @__PURE__ */ jsxRuntime.jsxs(FlexContainer, { "data-testid": "activate-overlay", tabIndex: 0, align: "center", justify: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            CardContainer,
            {
              radius: 2
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ContentContainer, { children: msg })
        ] }),
        children
      ]
    }
  );
}
const Root$j = styledComponents.styled.div((props2) => {
  const { color: color2, input, radius } = theme.getTheme_v2(props2.theme), border = {
    color: color2.input.default.enabled.border,
    width: input.border.width
  };
  return styledComponents.css`
    --input-box-shadow: ${focusRingBorderStyle$2(border)};

    position: relative;

    & [data-wrapper] {
      overflow: hidden;
      overflow: clip;
      position: relative;
      z-index: 1;
      padding: ${input.border.width}px;
    }

    & [data-border] {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      box-shadow: var(--input-box-shadow);
      z-index: 2;
      border-radius: ${radius[2]}px;
      pointer-events: none;
    }

    &:not([data-read-only])[data-focused] [data-border] {
      --input-box-shadow: ${focusRingStyle$1({
    base: color2,
    border,
    focusRing: input.text.focusRing
  })};
    }
  `;
}), ExpandedLayer = styledComponents.styled(ui.Layer)`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
`, TEXT_LEVELS = [1, 2, 3, 4, 5, 6, 7, 8, 9], TEXT_BULLET_MARKERS = ["\u25CF", "\u25CB", "\u25A0"], TEXT_NUMBER_FORMATS = ["number", "lower-alpha", "lower-roman"], TEXT_DECORATOR_TAGS = {
  em: "em",
  "strike-through": "s",
  underline: "u",
  strong: "strong",
  code: "code"
}, TEXT_STYLE_PADDING = {
  h1: {
    paddingTop: 5,
    paddingBottom: 4
  },
  h2: {
    paddingTop: 4,
    paddingBottom: 4
  },
  h3: {
    paddingTop: 4,
    paddingBottom: 3
  },
  h4: {
    paddingTop: 4,
    paddingBottom: 3
  },
  h5: {
    paddingTop: 4,
    paddingBottom: 3
  },
  h6: {
    paddingTop: 4,
    paddingBottom: 2
  },
  normal: {
    paddingTop: 2,
    paddingBottom: 3
  },
  blockquote: {
    paddingTop: 2,
    paddingBottom: 3
  }
}, Root$i = styledComponents.styled.span(({ theme: theme2 }) => {
  const isDark = theme2.sanity.color.dark;
  return styledComponents.css`
    /* Make sure the annotation styling is visible */
    &[data-mark='code'] {
      color: inherit;
      mix-blend-mode: ${isDark ? "screen" : "multiply"};
    }
  `;
});
function Decorator(props2) {
  const { value, focused, selected, children, schemaType } = props2, tag = TEXT_DECORATOR_TAGS[value], CustomComponent = schemaType.component, DefaultComponent2 = React.useCallback(
    (defaultComponentProps) => /* @__PURE__ */ jsxRuntime.jsx(Root$i, { as: tag, "data-mark": value, children: defaultComponentProps.children }),
    [tag, value]
  );
  return React.useMemo(() => {
    const componentProps = {
      focused,
      renderDefault: DefaultComponent2,
      schemaType,
      selected,
      title: schemaType.title,
      value
    };
    return CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps, children }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultComponent2, { ...componentProps, children });
  }, [CustomComponent, DefaultComponent2, children, focused, schemaType, selected, value]);
}
function createListName(level) {
  return `list-level-${level}`;
}
const ReviewChangesHighlightBlock = styledComponents.styled.div(({ theme: theme2 }) => {
  const { radius, space, color: color2 } = theme2.sanity, bg = ui.rgba(color2.spot.yellow, 0.2);
  return styledComponents.css`
    position: absolute;
    border-radius: ${radius[3]}px;
    top: -${space[2]}px;
    bottom: -${space[1] + space[1]}px;
    left: ${space[4] + space[1]}px;
    right: 0;
    background-color: ${bg};
    pointer-events: none;
  `;
}), StyledChangeIndicatorWithProvidedFullPath = styledComponents.styled(ChangeIndicator)(() => styledComponents.css`
    width: 1px;
    height: 100%;

    & > div {
      height: 100%;
    }
  `);
function createInsertCallback(options) {
  const { allowedDecorators, block, onChange } = options;
  let toInsert;
  return (givenBlock) => {
    toInsert = Array.isArray(givenBlock) ? givenBlock : [givenBlock], toInsert = toInsert.map(
      (blk) => blockTools.normalizeBlock(blk, {
        allowedDecorators
      })
    );
    const patches = [insert(toInsert, "after", [{ _key: block._key }])];
    return onChange(PatchEvent.from(patches));
  };
}
function createSetCallback(options) {
  const { allowedDecorators, block, onChange } = options;
  return (givenBlock) => {
    const patches = [
      set(
        blockTools.normalizeBlock(givenBlock, {
          allowedDecorators
        }),
        [{ _key: block._key }]
      )
    ];
    return onChange(PatchEvent.from(patches));
  };
}
function createUnsetCallback(options) {
  const { block, onChange } = options;
  return () => {
    const patches = [unset([{ _key: block._key }])];
    return onChange(PatchEvent.from(patches));
  };
}
const Root$h = styledComponents.styled.div`
  display: flex;
  pointer-events: all;
`;
function BlockActions(props2) {
  const editor2 = portableTextEditor.usePortableTextEditor(), { block, onChange, renderBlockActions } = props2, decoratorValues = React.useMemo(() => editor2.schemaTypes.decorators.map((d) => d.value), [editor2]), blockActions = React.useMemo(() => {
    if (renderBlockActions) {
      const blockActionProps = {
        block,
        value: portableTextEditor.PortableTextEditor.getValue(editor2),
        set: createSetCallback({ allowedDecorators: decoratorValues, block, onChange }),
        unset: createUnsetCallback({ block, onChange }),
        insert: createInsertCallback({ allowedDecorators: decoratorValues, block, onChange })
      };
      return renderBlockActions(blockActionProps);
    }
  }, [renderBlockActions, block, editor2, onChange, decoratorValues]);
  return blockActions ? /* @__PURE__ */ jsxRuntime.jsx(Root$h, { contentEditable: !1, children: blockActions }) : null;
}
function textBlockStyle(props2) {
  const { $level } = props2, { color: color$1, font, radius, space } = theme.getTheme_v2(props2.theme), numberMarker = TEXT_NUMBER_FORMATS[($level - 1) % TEXT_NUMBER_FORMATS.length], bulletMarker = TEXT_BULLET_MARKERS[($level - 1) % TEXT_BULLET_MARKERS.length];
  return styledComponents.css`
    --marker-bg-color: transparent;

    mix-blend-mode: ${color$1._dark ? "screen" : "multiply"};
    position: relative;

    & > [data-ui='TextBlock_inner'] {
      position: relative;
      flex: 1;
    }

    & > div:before {
      content: '';
      position: absolute;
      top: -${space[1]}px;
      bottom: -${space[1]}px;
      left: -${space[1]}px;
      right: -${space[1]}px;
      border-radius: ${radius[2]}px;
      background-color: var(--marker-bg-color);
      // This is to make sure the marker is always behind the text
      z-index: -1;
      pointer-events: none;
    }

    &[data-markers] {
      --marker-bg-color: ${color$1._dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
    }

    &[data-warning] {
      --card-border-color: ${color$1.button.ghost.caution.enabled.border};
      --marker-bg-color: ${color$1.button.ghost.caution.hovered.bg};
    }

    &[data-error] {
      --card-border-color: ${color$1.button.ghost.critical.enabled.border};
      --marker-bg-color: ${color$1.button.ghost.critical.hovered.bg};
    }

    & [data-list-prefix] {
      position: absolute;
      margin-left: -4.5rem;
      width: 3.75rem;
      text-align: right;
      box-sizing: border-box;
    }

    &[data-list-item='number'] [data-list-prefix] {
      font-variant-numeric: tabular-nums;

      & > span:before {
        content: counter(${createListName($level)}) '.';
        content: counter(${createListName($level)}, ${numberMarker}) '.';
      }
    }

    &[data-list-item='bullet'] [data-list-prefix] {
      & > span {
        position: relative;
        top: -0.1875em;

        &:before {
          content: '${bulletMarker}';
          font-size: 0.46666em;
        }
      }
    }

    & [data-text] {
      overflow-wrap: anywhere;
      text-transform: none;
      white-space: pre-wrap;
      font-family: ${font.text.family};
      flex: 1;

      *::selection {
        background-color: ${theme.rgba(color$1.focusRing, 0.3)};
      }
    }
  `;
}
const TextRoot = styledComponents.styled.div(textBlockStyle), TextBlockFlexWrapper = styledComponents.styled(ui.Box)`
  position: relative;
  display: flex;
`, ListPrefixWrapper = styledComponents.styled.div`
  user-select: none;
  white-space: nowrap;
`, BlockExtrasContainer = styledComponents.styled(ui.Box)`
  user-select: none;
`, BlockActionsOuter$1 = styledComponents.styled(ui.Box)`
  line-height: 0;
  width: 25px;
  position: relative;
`, BlockActionsInner$1 = styledComponents.styled(ui.Flex)(({ theme: theme2 }) => {
  const { fonts, space } = theme2.sanity, textSize1 = fonts.text.sizes[1], textSize2 = fonts.text.sizes[2], capHeight1 = textSize1.lineHeight - textSize1.ascenderHeight - textSize1.descenderHeight, capHeight2 = textSize2.lineHeight - textSize2.ascenderHeight - textSize2.descenderHeight, negativeTop = 0 - (capHeight1 + space[2] + space[2] - capHeight2) / 2;
  return styledComponents.css`
    user-select: none;
    position: absolute;
    right: 0;
    top: ${negativeTop}px;
  `;
}), TooltipBox$2 = styledComponents.styled(ui.Box)`
  max-width: 250px;
`, TextFlex = styledComponents.styled(ui.Flex)`
  position: relative;
  padding-left: ${({ $level }) => $level ? $level * 32 : 0}px;
`, ChangeIndicatorWrapper$1 = styledComponents.styled.div(
  ({ theme: theme2, $hasChanges }) => {
    const { space } = theme2.sanity;
    return styledComponents.css`
      position: absolute;
      width: ${space[2]}px;
      right: 0;
      top: 0;
      bottom: 0;
      padding-left: ${space[1]}px;
      user-select: none;

      ${!$hasChanges && styledComponents.css`
        display: none;
      `}
    `;
  }
), TextContainer = styledComponents.styled.div`
  display: block;
`, Normal = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { "data-testid": "text-style--normal", ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading1 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h1", "data-testid": "text-style--h1", size: 5, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading2 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h2", "data-testid": "text-style--h2", size: 4, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading3 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h3", "data-testid": "text-style--h3", size: 3, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading4 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h4", "data-testid": "text-style--h4", size: 2, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading5 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h5", "data-testid": "text-style--h5", size: 1, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), Heading6 = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h6", "data-testid": "text-style--h6", size: 0, ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { children }) }), BlockQuoteRoot = styledComponents.styled.blockquote`
  position: relative;
  display: block;
  margin: 0;
  padding-left: ${({ theme: theme2 }) => theme2.sanity.space[3]}px;

  &::before {
    content: '';
    position: absolute;
    left: 0;
    top: -4px;
    bottom: -4px;
    width: 3px;
    background: var(--card-border-color);
  }
`, BlockQuote = ({ children, ...rest }) => /* @__PURE__ */ jsxRuntime.jsx(BlockQuoteRoot, { "data-testid": "text-style--blockquote", ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children }) }), TEXT_STYLES = {
  normal: Normal,
  h1: Heading1,
  h2: Heading2,
  h3: Heading3,
  h4: Heading4,
  h5: Heading5,
  h6: Heading6,
  blockquote: BlockQuote
};
function TextBlock(props2) {
  const {
    children,
    floatingBoundary,
    focused,
    isFullscreen,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    renderBlock: renderBlock2,
    renderAnnotation,
    renderBlockActions,
    renderCustomMarkers,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    schemaType,
    selected,
    spellCheck,
    value
  } = props2, { Markers } = useFormBuilder().__internal.components, [reviewChangesHovered, setReviewChangesHovered] = React.useState(!1), markers = usePortableTextMarkers(path), memberItem = usePortableTextMemberItem(pathToString$1(path)), editor2 = portableTextEditor.usePortableTextEditor(), { onChange } = useFormCallbacks(), presence = useChildPresence(path, !0), textPresence = React.useMemo(() => presence.filter(
    (p) => PathUtils.isEqual(p.path, path) || p.path.slice(-3)[1] === "children" && p.path.length - path.length === 2
  ), [path, presence]), handleChangeIndicatorMouseEnter = React.useCallback(() => setReviewChangesHovered(!0), []), handleChangeIndicatorMouseLeave = React.useCallback(() => setReviewChangesHovered(!1), []), { validation: validation2, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), hasMarkers = !!renderCustomMarkers && markers.length > 0, tooltipEnabled = hasError || hasWarning || hasMarkers || hasInfo, onOpen = React.useCallback(() => {
    memberItem && onItemOpen(memberItem.node.path);
  }, [onItemOpen, memberItem]), onRemove = React.useCallback(() => {
    const point = { path: path.slice(-1), offset: 0 }, sel = {
      focus: point,
      anchor: point
    };
    portableTextEditor.PortableTextEditor.delete(editor2, sel, { mode: "blocks" }), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [path, editor2]), text = React.useMemo(() => /* @__PURE__ */ jsxRuntime.jsxs(TextFlex, { align: "flex-start", $level: value == null ? void 0 : value.level, children: [
    value.listItem && /* @__PURE__ */ jsxRuntime.jsx(ListPrefixWrapper, { contentEditable: !1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { "data-list-prefix": "", children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx("div", { "data-text": "", style: void 0, children })
  ] }), [value.listItem, value.level, children]), innerPaddingProps = React.useMemo(() => isFullscreen && !renderBlockActions ? { paddingX: 5 } : isFullscreen && renderBlockActions ? { paddingLeft: 5, paddingRight: 2 } : renderBlockActions ? {
    paddingLeft: 3,
    paddingRight: 2
  } : { paddingX: 3 }, [isFullscreen, renderBlockActions]), outerPaddingProps = React.useMemo(() => value.listItem ? { paddingY: 2 } : TEXT_STYLE_PADDING[value.style || "normal"] || { paddingY: 2 }, [value]), isOpen = !!(memberItem != null && memberItem.member.open), parentSchemaType = editor2.schemaTypes.portableText, componentProps = React.useMemo(
    () => {
      var _a2;
      return {
        __unstable_floatingBoundary: floatingBoundary,
        __unstable_referenceBoundary: referenceBoundary,
        __unstable_referenceElement: ((_a2 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a2.current) || null,
        children: text,
        focused,
        markers,
        onClose: onItemClose,
        onOpen,
        onPathFocus,
        onRemove,
        open: isOpen,
        parentSchemaType,
        path: (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$t,
        presence: textPresence,
        readOnly: !!readOnly,
        renderAnnotation,
        renderBlock: renderBlock2,
        renderDefault: DefaultComponent$1,
        renderField,
        renderInput,
        renderInlineBlock,
        renderItem: renderItem2,
        renderPreview,
        schemaType,
        selected,
        validation: validation2,
        value
      };
    },
    [
      floatingBoundary,
      focused,
      isOpen,
      markers,
      memberItem == null ? void 0 : memberItem.elementRef,
      memberItem == null ? void 0 : memberItem.node.path,
      onItemClose,
      onOpen,
      onPathFocus,
      onRemove,
      parentSchemaType,
      readOnly,
      referenceBoundary,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview,
      schemaType,
      selected,
      text,
      textPresence,
      validation2,
      value
    ]
  ), toolTipContent = React.useMemo(
    () => tooltipEnabled && /* @__PURE__ */ jsxRuntime.jsx(TooltipBox$2, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Markers,
      {
        markers,
        renderCustomMarkers,
        validation: validation2
      }
    ) }) || null,
    [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]
  ), blockActionsVisible = renderBlockActions && focused && !readOnly, changeIndicatorVisible = isFullscreen && memberItem;
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      ui.Box,
      {
        ...outerPaddingProps,
        "data-testid": "text-block",
        "data-text-block": "",
        ref: memberItem == null ? void 0 : memberItem.elementRef,
        style: void 0,
        children: /* @__PURE__ */ jsxRuntime.jsx(TextBlockFlexWrapper, { "data-testid": "text-block__wrapper", children: /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Flex,
          {
            "data-text-block-inner": "",
            flex: 1,
            ...innerPaddingProps,
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
                TooltipDelayGroupProvider.Tooltip,
                {
                  content: toolTipContent,
                  disabled: !tooltipEnabled,
                  placement: "top",
                  portal: "editor",
                  children: /* @__PURE__ */ jsxRuntime.jsx(
                    TextRoot,
                    {
                      $level: value.level || 1,
                      "data-error": hasError ? "" : void 0,
                      "data-list-item": value.listItem,
                      "data-markers": hasMarkers ? "" : void 0,
                      "data-read-only": readOnly,
                      "data-testid": "text-block__text",
                      "data-warning": hasWarning ? "" : void 0,
                      spellCheck,
                      children: renderBlock2 && renderBlock2(componentProps)
                    }
                  )
                }
              ) }),
              (blockActionsVisible || changeIndicatorVisible) && /* @__PURE__ */ jsxRuntime.jsxs(BlockExtrasContainer, { contentEditable: !1, children: [
                blockActionsVisible && /* @__PURE__ */ jsxRuntime.jsx(BlockActionsOuter$1, { marginRight: 1, children: /* @__PURE__ */ jsxRuntime.jsx(BlockActionsInner$1, { children: /* @__PURE__ */ jsxRuntime.jsx(
                  BlockActions,
                  {
                    onChange,
                    block: value,
                    renderBlockActions
                  }
                ) }) }),
                changeIndicatorVisible && /* @__PURE__ */ jsxRuntime.jsx(
                  ChangeIndicatorWrapper$1,
                  {
                    $hasChanges: memberItem.member.item.changed,
                    onMouseEnter: handleChangeIndicatorMouseEnter,
                    onMouseLeave: handleChangeIndicatorMouseLeave,
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      StyledChangeIndicatorWithProvidedFullPath,
                      {
                        hasFocus: focused,
                        isChanged: memberItem.member.item.changed,
                        path: memberItem.member.item.path,
                        withHoverEffect: !1
                      }
                    )
                  }
                )
              ] }),
              reviewChangesHovered && /* @__PURE__ */ jsxRuntime.jsx(ReviewChangesHighlightBlock, {})
            ]
          }
        ) })
      }
    ),
    [
      blockActionsVisible,
      changeIndicatorVisible,
      componentProps,
      focused,
      handleChangeIndicatorMouseEnter,
      handleChangeIndicatorMouseLeave,
      hasError,
      hasMarkers,
      hasWarning,
      innerPaddingProps,
      memberItem,
      onChange,
      outerPaddingProps,
      readOnly,
      renderBlock2,
      renderBlockActions,
      reviewChangesHovered,
      spellCheck,
      toolTipContent,
      tooltipEnabled,
      value
    ]
  );
}
const DefaultComponent$1 = (props2) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: props2.children }), Root$g = styledComponents.styled(ui.Card)`
  &[data-fullscreen='true'] {
    height: 100%;
  }

  &[data-fullscreen='false'] {
    min-height: 5em;
    resize: vertical;
    overflow: auto;
    height: 19em;
  }

  &:not([hidden]) {
    display: flex;
  }

  flex-direction: column;
`, ToolbarCard = styledComponents.styled(ui.Card)`
  z-index: 10;
  line-height: 0;
`, EditableCard = styledComponents.styled(ui.Card)`
  position: relative;
  overflow: hidden;
  overflow: clip;

  & > [data-portal] {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;

    & > * {
      pointer-events: initial;
    }
  }

  &::selection,
  *::selection {
    background-color: transparent;
  }
`, Scroller = styledComponents.styled(ScrollContainer)`
  position: relative;
  overflow: auto;
  height: 100%;
  display: flex;
  flex-direction: column;

  & > * {
    flex: 1;
    min-height: auto;
  }
`, EditableContainer = styledComponents.styled(ui.Container)`
  /* @todo: calculate from theme */
  /* max-width: 728px; */
`, EditableWrapper = styledComponents.styled(ui.Card)`
  height: 100%;
  width: 100%;
  counter-reset: ${TEXT_LEVELS.map((l) => createListName(l)).join(" ")};
  overflow: hidden;
  overflow: clip;

  & > div {
    height: 100%;
  }

  & .pt-editable {
    display: block;
    width: 100%;
    height: 100%;

    ${TEXT_LEVELS.map((l) => styledComponents.css`
        & > .pt-list-item-number[class~='pt-list-item-level-${l}'] {
          counter-increment: ${createListName(l)};
        }
      `)}

    & > .pt-list-item-bullet + .pt-list-item-number,
    & > .pt-list-item-number + .pt-list-item-bullet {
      margin-top: ${({ theme: theme2 }) => theme2.sanity.space[3]}px;
      counter-reset: ${TEXT_LEVELS.map((l) => createListName(l)).join(" ")};
    }

    & > :not(.pt-list-item) + .pt-list-item {
      margin-top: ${({ theme: theme2 }) => theme2.sanity.space[2]}px;
    }

    /* Reset the list count if the element is not a numbered list item */
    & > :not(.pt-list-item-number) {
      counter-reset: ${TEXT_LEVELS.map((l) => createListName(l)).join(" ")};
    }

    ${TEXT_LEVELS.slice(1).map((l) => styledComponents.css`
        & > .pt-list-item-level-${l} + .pt-list-item-level-${l - 1} {
          counter-reset: ${createListName(l)};
        }
      `)}

    & > .pt-list-item + :not(.pt-list-item) {
      margin-top: ${({ theme: theme2 }) => theme2.sanity.space[3]}px;
    }

    & > :first-child {
      padding-top: ${({ $isFullscreen, theme: theme2 }) => theme2.sanity.space[$isFullscreen ? 5 : 3]}px;
    }

    padding-bottom: ${({ $isFullscreen, theme: theme2 }) => theme2.sanity.space[$isFullscreen ? 9 : 5]}px;

    /* & > .pt-block {
      & .pt-inline-object {
      }
    } */

    & .pt-drop-indicator {
      pointer-events: none;
      border: 1px solid var(--card-focus-ring-color) !important;
      height: 0px !important;
      border-radius: ${(props2) => theme.getTheme_v2(props2.theme).radius[2]}px;
      margin-top: -3px;
      left: calc(
        ${({ $isFullscreen, theme: theme2 }) => $isFullscreen ? ui.rem(theme2.sanity.space[5]) : ui.rem(theme2.sanity.space[3])} - 1px
      );
      right: calc(
        ${({ $isFullscreen, theme: theme2 }) => $isFullscreen ? ui.rem(theme2.sanity.space[5]) : ui.rem(theme2.sanity.space[3])} - 1px
      );
      width: calc(
        100% -
          ${({ $isFullscreen, theme: theme2 }) => $isFullscreen ? ui.rem(theme2.sanity.space[5] * 2) : ui.rem(theme2.sanity.space[3] * 2)} + 2px
      ) !important;
    }
  }
`;
function useScrollSelectionIntoView(scrollElement) {
  return React.useMemo(
    () => (editor2, domRange) => {
      if (portableTextEditor.PortableTextEditor.getSelection(editor2)) {
        const leafEl = domRange.startContainer.parentElement;
        if (!leafEl)
          return;
        scrollIntoView__default.default(leafEl, {
          scrollMode: "if-needed",
          boundary: scrollElement,
          block: "nearest",
          inline: "nearest"
        });
      }
    },
    [scrollElement]
  );
}
function useSpellCheck() {
  const editor2 = portableTextEditor.usePortableTextEditor();
  return React.useMemo(() => {
    var _a2;
    const spellCheckOption = (_a2 = editor2.schemaTypes.block.options) == null ? void 0 : _a2.spellCheck, isChrome96 = typeof navigator > "u" ? !1 : /Chrome\/96/.test(navigator.userAgent);
    return spellCheckOption === void 0 && isChrome96 === !0 ? !1 : spellCheckOption;
  }, [editor2]);
}
const DefaultComponent = (dProps) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: dProps.children }), ListItem$1 = (props2) => {
  const { block, children, schemaType, selected, focused, level, value } = props2, { title, component: CustomComponent } = schemaType;
  return React.useMemo(() => {
    const componentProps = {
      block,
      focused,
      level,
      renderDefault: DefaultComponent,
      schemaType,
      selected,
      title,
      value
    };
    return CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps, children }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultComponent, { ...componentProps, children });
  }, [CustomComponent, block, children, focused, level, schemaType, selected, title, value]);
}, Style = (props2) => {
  const { block, focused, children, selected, schemaType } = props2, DefaultComponentWithFallback = React.useMemo(
    () => (block.style && TEXT_STYLES[block.style] ? TEXT_STYLES[block.style] : TEXT_STYLES[0]) || Normal,
    [block.style]
  ), DefaultComponent2 = React.useCallback(
    (defaultComponentProps) => /* @__PURE__ */ jsxRuntime.jsx(DefaultComponentWithFallback, { children: /* @__PURE__ */ jsxRuntime.jsx(TextContainer, { "data-testid": `text-style--${block.style}`, children: defaultComponentProps.children }) }),
    [DefaultComponentWithFallback, block.style]
  );
  return React.useMemo(() => {
    const CustomComponent = schemaType.component, { title, value } = schemaType, componentProps = {
      block,
      focused,
      renderDefault: DefaultComponent2,
      schemaType,
      selected,
      title,
      value
    };
    return CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { ...componentProps, children }) : /* @__PURE__ */ jsxRuntime.jsx(DefaultComponent2, { ...componentProps, children });
  }, [DefaultComponent2, block, children, focused, schemaType, selected]);
}, DividerDiv = styledComponents.styled.div`
  border-right: 1px solid var(--card-border-color);
  height: auto;

  &[data-hidden] {
    opacity: 0;
  }
`;
function CollapseMenuDivider(props2) {
  const { hidden, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(DividerDiv, { "data-ui": "CollapseMenuDivider", "data-hidden": hidden ? "" : void 0, ...rest });
}
const MENU_BUTTON_POPOVER_PROPS$1 = {
  portal: !0,
  constrainSize: !0
}, CollapseOverflowMenu = React.forwardRef(function(props2, forwardedRef) {
  const { disableRestoreFocusOnClose, menuButton, menuButtonProps, menuOptions, onMenuClose } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose,
      id: "menu-button",
      ref: forwardedRef,
      onClose: onMenuClose,
      popover: MENU_BUTTON_POPOVER_PROPS$1,
      ...menuButtonProps,
      button: menuButton,
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: menuOptions.map((c, index) => {
        const {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          collapsedProps = {},
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          expandedProps = {},
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          tooltipProps = {},
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          tooltipText,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          dividerBefore,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          fontSize,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          padding,
          text,
          icon,
          selected,
          ...rest
        } = c.props;
        return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
          dividerBefore && index !== 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.MenuItem, { text, icon, pressed: selected, ...rest })
        ] }, c.key);
      }) })
    }
  );
});
function ObserveElement(props2) {
  const { onIntersectionChange, children, options, ...rest } = props2, [el, setEl] = React.useState(null);
  return React.useEffect(() => {
    const target = el == null ? void 0 : el.closest('[data-ui="Flex"]');
    if (!target) return;
    const io = new IntersectionObserver(onIntersectionChange, options);
    return io.observe(target), () => {
      io.unobserve(target), io.disconnect();
    };
  }, [el, onIntersectionChange, options]), /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { ...rest, children: [
    children,
    /* @__PURE__ */ jsxRuntime.jsx("span", { hidden: !0, ref: setEl })
  ] });
}
const FOCUS_RING_PADDING = 3, OPTION_STYLE = styledComponents.css`
  list-style: none;
  display: flex;
  white-space: nowrap;

  &[data-hidden='true'] {
    opacity: 0;
    visibility: hidden;
  }
`, OuterFlex = styledComponents.styled(ui.Flex)`
  padding: ${FOCUS_RING_PADDING}px;
  margin: -${FOCUS_RING_PADDING}px;
  box-sizing: border-box;
`, RootFlex$4 = styledComponents.styled(ui.Flex)`
  border-radius: inherit;
  position: relative;
`, RowFlex = styledComponents.styled(ui.Flex)`
  width: max-content;
  &[data-hidden='true'] {
    visibility: hidden;
    position: relative;
    margin-top: -1px;
    height: 1px;
  }
`, OptionObserveElement$1 = styledComponents.styled(ObserveElement)`
  ${OPTION_STYLE}
`;
function _isReactElement$1(node) {
  return !!node;
}
const CollapseMenu = React.forwardRef(function(props2, ref) {
  const { children, collapsed, disableRestoreFocusOnClose, onMenuClose, menuButtonProps, ...rest } = props2, menuOptions = React.useMemo(() => React.Children.toArray(children).filter(_isReactElement$1), [children]), menuButton = React.useMemo(
    () => (menuButtonProps == null ? void 0 : menuButtonProps.button) || /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
    [menuButtonProps]
  );
  return collapsed ? /* @__PURE__ */ jsxRuntime.jsx(
    CollapseOverflowMenu,
    {
      ref,
      disableRestoreFocusOnClose,
      menuButton,
      menuButtonProps,
      menuOptions,
      onMenuClose
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    AutoCollapseMenu,
    {
      ...rest,
      ref,
      disableRestoreFocusOnClose,
      menuButtonProps,
      menuOptions,
      onMenuClose
    }
  );
}), AutoCollapseMenu = React.forwardRef(function(props2, ref) {
  const {
    collapseText = !0,
    disableRestoreFocusOnClose,
    gap,
    menuOptions,
    menuButtonProps,
    onMenuClose,
    ...rest
  } = props2, [rootEl, setRootEl] = React.useState(null), [expandedIntersections, setExpandedIntersections] = React.useState({}), [collapsedIntersections, setCollapsedIntersections] = React.useState({}), intersectionOptions = React.useMemo(
    () => ({
      root: rootEl,
      // safari needs threshold to be < 1
      threshold: 0.99,
      rootMargin: "2px"
    }),
    [rootEl]
  ), menuOptionKeys = React.useMemo(() => menuOptions.map((child) => child.key), [menuOptions]), pendingIntersections = React.useMemo(
    () => [
      ...difference__default.default(menuOptionKeys, Object.keys(expandedIntersections)),
      ...difference__default.default(menuOptionKeys, Object.keys(collapsedIntersections))
    ],
    [menuOptionKeys, expandedIntersections, collapsedIntersections]
  ), overflowingExpandedElements = React.useMemo(
    () => menuOptions.filter((optionElement) => {
      const entry = expandedIntersections[optionElement.key];
      return entry && !entry.intersects;
    }),
    [expandedIntersections, menuOptions]
  ), handleExpandedIntersection = React.useCallback(
    (e, element) => {
      setExpandedIntersections((current) => {
        const key = element.key;
        if (key === null)
          throw new Error("Expected element to have a non-null key");
        const nextState = {
          intersects: e.isIntersecting,
          element
        }, currentState = current[key];
        return !currentState || currentState.intersects !== nextState.intersects ? {
          ...current,
          [key]: nextState
        } : current;
      });
    },
    []
  ), handleCollapsedIntersection = React.useCallback(
    (e, element) => {
      setCollapsedIntersections((current) => {
        const key = element.key;
        if (key === null)
          throw new Error("Expected child element to have a non-null key");
        const currentElementIntersection = current[key], nextElementIntersection = {
          intersects: e.isIntersecting,
          element
        };
        return (currentElementIntersection == null ? void 0 : currentElementIntersection.intersects) === nextElementIntersection.intersects ? current : {
          ...current,
          [key]: nextElementIntersection
        };
      });
    },
    []
  ), collapsedElements = React.useMemo(
    () => menuOptions.map((optionElement) => {
      const { collapsedProps } = optionElement.props, modeProps = collapsedProps, text = collapseText ? void 0 : optionElement.props.text;
      return React.cloneElement(optionElement, {
        ...modeProps,
        text
      });
    }),
    [menuOptions, collapseText]
  ), overflowingCollapsedOptionElements = React.useMemo(
    () => menuOptions.filter((optionElement) => {
      const intersection2 = collapsedIntersections[optionElement.key];
      return (intersection2 == null ? void 0 : intersection2.intersects) === !1;
    }),
    [menuOptions, collapsedIntersections]
  ), visibleMenuOptions = overflowingExpandedElements.length > 0 ? collapsedElements.filter((optionElement) => {
    const intersection2 = collapsedIntersections[optionElement.key];
    return (intersection2 == null ? void 0 : intersection2.intersects) === !0;
  }) : menuOptions, menuButton = React.useMemo(
    () => (menuButtonProps == null ? void 0 : menuButtonProps.button) || /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
    [menuButtonProps]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    OuterFlex,
    {
      align: "center",
      "data-ui": "CollapseMenu",
      overflow: "hidden",
      sizing: "border",
      ref,
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$4, { direction: "column", flex: 1, justify: "center", ref: setRootEl, children: [
          /* @__PURE__ */ jsxRuntime.jsx(RowFlex, { gap, children: pendingIntersections.length === 0 && visibleMenuOptions.map((optionElement, index) => {
            const { dividerBefore, tooltipText = "", tooltipProps = {} } = optionElement.props, hidden = !optionElement.key || !(optionElement.key in expandedIntersections) || overflowingCollapsedOptionElements.includes(optionElement);
            return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
              dividerBefore && index !== 0 && /* @__PURE__ */ jsxRuntime.jsx(CollapseMenuDivider, { hidden }),
              /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { portal: !0, disabled: !tooltipText, content: tooltipText, ...tooltipProps, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: React.cloneElement(optionElement, {
                disabled: optionElement.props.disabled || hidden,
                "aria-hidden": hidden
              }) }) })
            ] }, optionElement.key);
          }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            RenderHidden,
            {
              gap,
              elements: menuOptions,
              intersectionOptions,
              onIntersectionChange: handleExpandedIntersection
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            RenderHidden,
            {
              gap,
              elements: collapsedElements,
              intersectionOptions,
              onIntersectionChange: handleCollapsedIntersection
            }
          )
        ] }),
        overflowingCollapsedOptionElements.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { marginLeft: gap, children: /* @__PURE__ */ jsxRuntime.jsx(
          CollapseOverflowMenu,
          {
            disableRestoreFocusOnClose,
            menuButton,
            menuButtonProps,
            menuOptions: overflowingCollapsedOptionElements,
            onMenuClose
          }
        ) })
      ]
    }
  );
}), RenderHidden = React.memo(function(props2) {
  const { elements, gap, intersectionOptions, onIntersectionChange } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(RowFlex, { "data-hidden": !0, "aria-hidden": "true", gap, overflow: "hidden", children: elements.map((element, index) => {
    const { dividerBefore } = element.props;
    return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
      dividerBefore && index !== 0 && /* @__PURE__ */ jsxRuntime.jsx(CollapseMenuDivider, { hidden: !0 }),
      /* @__PURE__ */ jsxRuntime.jsx(
        OptionObserveElement$1,
        {
          options: intersectionOptions,
          onIntersectionChange: (e) => onIntersectionChange(e[0], element),
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: React.cloneElement(element, {
            disabled: !0,
            "aria-hidden": !0
          }) })
        }
      )
    ] }, element.key);
  }) });
}), CollapseMenuButton = React.forwardRef(function(props2, ref) {
  const {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    collapsedProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    expandedProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tooltipProps = {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    tooltipText,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    dividerBefore,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ...rest
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { "data-ui": "CollapseMenuButton", ...rest, ref });
}), CustomIconDiv = styledComponents.styled.div`
  width: 1em;
  height: 1em;
  border-radius: inherit;
  background-origin: content-box;
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  transform: scale(0.7);
`;
function CustomIcon(props2) {
  const { icon, active } = props2, inlineStyle = React.useMemo(
    () => ({
      backgroundImage: `url(${icon})`,
      filter: active ? "invert(100%)" : "invert(0%)"
    }),
    [active, icon]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(CustomIconDiv, { style: inlineStyle });
}
function getPTEFormatActions(editor2, disabled, hotkeyOpts, t2) {
  return editor2.schemaTypes.decorators.map((decorator) => {
    const shortCutKey = Object.keys(hotkeyOpts.marks || {}).find(
      (key) => {
        var _a2;
        return ((_a2 = hotkeyOpts.marks) == null ? void 0 : _a2[key]) === decorator.value;
      }
    );
    let hotkeys = [];
    return shortCutKey && (hotkeys = [shortCutKey]), {
      type: "format",
      disabled,
      icon: decorator == null ? void 0 : decorator.icon,
      key: decorator.value,
      handle: () => {
        portableTextEditor.PortableTextEditor.toggleMark(editor2, decorator.value), portableTextEditor.PortableTextEditor.focus(editor2);
      },
      hotkeys,
      title: decorator.i18nTitleKey && t2 ? t2(decorator.i18nTitleKey) : decorator.title
    };
  });
}
function getPTEListActions(editor2, disabled, t2) {
  return editor2.schemaTypes.lists.map((listItem) => ({
    type: "listStyle",
    key: listItem.value,
    disabled,
    icon: listItem == null ? void 0 : listItem.icon,
    handle: () => {
      portableTextEditor.PortableTextEditor.toggleList(editor2, listItem.value);
    },
    title: listItem.i18nTitleKey && t2 ? t2(listItem.i18nTitleKey) : listItem.title
  }));
}
function getAnnotationIcon(type) {
  return get__default.default(type, "icon") || get__default.default(type, "type.icon") || get__default.default(type, "type.to.icon") || get__default.default(type, "type.to[0].icon");
}
function getPTEAnnotationActions(editor2, disabled, onInsert, t2) {
  const types2 = editor2.schemaTypes, focusChild = portableTextEditor.PortableTextEditor.focusChild(editor2), hasText = focusChild && focusChild.text;
  return types2.annotations.map((aType) => ({
    type: "annotation",
    disabled: !hasText || disabled,
    icon: getAnnotationIcon(aType),
    key: aType.name,
    handle: (active) => {
      active ? (portableTextEditor.PortableTextEditor.removeAnnotation(editor2, aType), portableTextEditor.PortableTextEditor.focus(editor2)) : onInsert(aType);
    },
    title: aType.i18nTitleKey && t2 ? t2(aType.i18nTitleKey) : aType.title || capitalize__default.default(aType.name)
  }));
}
function getPTEToolbarActionGroups(editor2, disabled, onInsertAnnotation, hotkeyOpts, t2) {
  return [
    { name: "format", actions: getPTEFormatActions(editor2, disabled, hotkeyOpts, t2) },
    { name: "list", actions: getPTEListActions(editor2, disabled, t2) },
    { name: "annotation", actions: getPTEAnnotationActions(editor2, disabled, onInsertAnnotation, t2) }
  ];
}
function getBlockStyles(types2) {
  return types2.styles.map((style) => ({
    key: `style-${style.value}`,
    style: style.value,
    styleComponent: style && style.component,
    title: style.title,
    i18nTitleKey: style.i18nTitleKey
  }));
}
function getInsertMenuIcon(type, fallbackIcon) {
  const referenceIcon = get__default.default(type, "to[0].icon");
  return type.icon || type.type && type.type.icon || referenceIcon || fallbackIcon;
}
function getInsertMenuItems(types2, disabled, onInsertBlock, onInsertInline) {
  const blockItems = types2.blockObjects.map(
    (type, index) => ({
      handle: () => onInsertBlock(type),
      icon: getInsertMenuIcon(type, icons.BlockElementIcon),
      inline: !1,
      key: `block-${index}`,
      type
    })
  ), inlineItems = types2.inlineObjects.map(
    (type, index) => ({
      handle: () => onInsertInline(type),
      icon: getInsertMenuIcon(type, icons.InlineElementIcon),
      inline: !0,
      key: `inline-${index}`,
      type
    })
  );
  return blockItems.concat(inlineItems).filter((item) => {
    var _a2;
    return !((_a2 = item.type) != null && _a2.hidden);
  });
}
const annotationIcons = {
  link: icons.LinkIcon
}, formatIcons = {
  strong: icons.BoldIcon,
  em: icons.ItalicIcon,
  "strike-through": icons.StrikethroughIcon,
  underline: icons.UnderlineIcon,
  code: icons.CodeIcon
}, listStyleIcons = {
  number: icons.OlistIcon,
  bullet: icons.UlistIcon
};
function getActionIcon(action, active) {
  return action.icon ? typeof action.icon == "string" ? /* @__PURE__ */ jsxRuntime.jsx(CustomIcon, { active, icon: action.icon }) : action.icon : action.type === "annotation" ? annotationIcons[action.key] || icons.UnknownIcon : action.type === "listStyle" ? listStyleIcons[action.key] || icons.UnknownIcon : formatIcons[action.key] || icons.UnknownIcon;
}
function useFocusBlock() {
  const editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection();
  return React.useMemo(() => portableTextEditor.PortableTextEditor.focusBlock(editor2), [editor2, selection]);
}
function useActionGroups({
  hotkeys,
  onMemberOpen,
  resolveInitialValue: resolveInitialValue2,
  disabled
}) {
  const editor2 = portableTextEditor.usePortableTextEditor(), { t: t2 } = useTranslation(), handleInsertAnnotation = React.useCallback(
    async (schemaType) => {
      const initialValue = await resolveInitialValue2(schemaType), paths = portableTextEditor.PortableTextEditor.addAnnotation(editor2, schemaType, initialValue);
      paths && paths.markDefPath && onMemberOpen(paths.markDefPath);
    },
    [editor2, onMemberOpen, resolveInitialValue2]
  );
  return React.useMemo(
    () => editor2 ? getPTEToolbarActionGroups(editor2, disabled, handleInsertAnnotation, hotkeys, t2) : [],
    [disabled, editor2, handleInsertAnnotation, hotkeys, t2]
  );
}
function useActiveActionKeys({
  actions
}) {
  const editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection();
  return useUnique(
    React.useMemo(
      () => actions.filter((a) => a.type === "annotation" ? portableTextEditor.PortableTextEditor.isAnnotationActive(editor2, a.key) : a.type === "listStyle" ? portableTextEditor.PortableTextEditor.hasListStyle(editor2, a.key) : portableTextEditor.PortableTextEditor.isMarkActive(editor2, a.key)).map((a) => a.key),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        editor2,
        // This is needed so that active actions update as `selection` changes
        selection
      ]
    )
  );
}
function useActiveStyleKeys({ items }) {
  const editor2 = portableTextEditor.usePortableTextEditor(), focusBlock = useFocusBlock(), selection = portableTextEditor.usePortableTextEditorSelection();
  return useUnique(
    React.useMemo(
      () => items.filter((i) => portableTextEditor.PortableTextEditor.hasBlockStyle(editor2, i.style)).map((i) => i.style),
      //  eslint-disable-next-line react-hooks/exhaustive-deps
      [
        focusBlock,
        // This is needed so that active styles update as `selection` changes
        selection
      ]
    )
  );
}
const CollapseMenuMemo$1 = React.memo(CollapseMenu), MENU_POPOVER_PROPS$5 = { constrainSize: !0, portal: !0 }, ActionMenu = React.memo(function(props2) {
  const { disabled: disabledProp, groups, isFullscreen, collapsed } = props2, focusBlock = useFocusBlock(), editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection(), { t: t2 } = useTranslation(), isSelectingMultipleBlocks = (
    // Path at 0 is the block level, by comparing those we can detect if the user is selecting multiple blocks
    selection && types.isKeySegment(selection.anchor.path[0]) && types.isKeySegment(selection.focus.path[0]) ? (
      // In case of keyed segments
      selection.anchor.path[0]._key !== (selection == null ? void 0 : selection.focus.path[0]._key)
    ) : (
      // In case of non-keyed segments
      (selection == null ? void 0 : selection.anchor.path[0]) !== (selection == null ? void 0 : selection.focus.path[0])
    )
  ), isVoidBlock = (focusBlock == null ? void 0 : focusBlock._type) !== editor2.schemaTypes.block.name, isEmptyTextBlock = !isVoidBlock && Array.isArray(focusBlock.children) && focusBlock.children.length === 1 && (focusBlock == null ? void 0 : focusBlock.children[0].text) === "", disabled = disabledProp || isVoidBlock, actions = React.useMemo(
    () => groups.reduce((acc, group2) => acc.concat(
      group2.actions.map(
        // eslint-disable-next-line max-nested-callbacks
        (action, actionIndex) => actionIndex === 0 ? { ...action, firstInGroup: !0 } : action
      )
    ), []),
    [groups]
  ), activeKeys = useActiveActionKeys({ actions }), handleMenuClose = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2]), tooltipPlacement = isFullscreen ? "bottom" : "top", children = React.useMemo(
    () => actions.map((action) => {
      const annotationDisabled = action.type === "annotation" && (isEmptyTextBlock || isSelectingMultipleBlocks), annotationDisabledText = isEmptyTextBlock ? t2("user-menu.action.portable-text.annotation-disabled_empty-block", {
        name: action.title || action.key
      }) : t2("user-menu.action.portable-text.annotation-disabled_multiple-blocks", {
        name: action.title || action.key
      }), active = activeKeys.includes(action.key);
      return /* @__PURE__ */ jsxRuntime.jsx(
        CollapseMenuButton,
        {
          "aria-label": t2("toolbar.portable-text.action-button-aria-label", {
            action: action.title || action.key
          }),
          "data-testid": `action-button-${action.key}`,
          disabled: disabled || annotationDisabled,
          mode: "bleed",
          dividerBefore: action.firstInGroup,
          icon: getActionIcon(action, active),
          onClick: () => action.handle(active),
          selected: active,
          text: action.title || action.key,
          tooltipText: annotationDisabled ? annotationDisabledText : action.title || action.key,
          tooltipProps: {
            disabled,
            placement: tooltipPlacement,
            portal: "default"
          }
        },
        action.key
      );
    }),
    [
      actions,
      activeKeys,
      disabled,
      isEmptyTextBlock,
      isSelectingMultipleBlocks,
      t2,
      tooltipPlacement
    ]
  ), menuButtonProps = React.useMemo(
    () => ({
      button: /* @__PURE__ */ jsxRuntime.jsx(
        ContextMenuButton,
        {
          "data-testid": "action-menu-button",
          disabled,
          tooltipProps: { placement: tooltipPlacement }
        }
      ),
      popover: MENU_POPOVER_PROPS$5
    }),
    [disabled, tooltipPlacement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CollapseMenuMemo$1,
    {
      "data-testid": "action-menu-auto-collapse-menu",
      collapsed,
      disableRestoreFocusOnClose: !0,
      gap: 1,
      menuButtonProps,
      onMenuClose: handleMenuClose,
      children
    }
  );
}), MenuButtonMemo = React.memo(TooltipDelayGroupProvider.MenuButton), StyledMenuItem = styledComponents.styled(ui.MenuItem)`
  // Change the border color variable used by BlockQuote
  // to make the border visible when the MenuItem is selected
  &[data-selected] {
    [data-option='blockquote'] {
      --card-border-color: var(--card-muted-fg-color);
    }
  }
`, MENU_POPOVER_PROPS$4 = {
  constrainSize: !0,
  placement: "bottom-start",
  portal: "default"
}, TEXT_STYLE_OPTIONS = {
  h1: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading1, { children: title }),
  h2: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading2, { children: title }),
  h3: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading3, { children: title }),
  h4: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading4, { children: title }),
  h5: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading5, { children: title }),
  h6: (title) => /* @__PURE__ */ jsxRuntime.jsx(Heading6, { children: title }),
  normal: (title) => /* @__PURE__ */ jsxRuntime.jsx(Normal, { children: title }),
  blockquote: (title) => /* @__PURE__ */ jsxRuntime.jsx(BlockQuote, { "data-option": "blockquote", children: title })
}, preventDefault = (event) => event.preventDefault(), emptyStyle = {
  key: "style-none",
  style: "",
  title: "No style",
  i18nTitleKey: "inputs.portable-text.style.none"
}, BlockStyleSelect = React.memo(function(props2) {
  const { disabled, items: itemsProp } = props2, editor2 = portableTextEditor.usePortableTextEditor(), focusBlock = useFocusBlock(), { t: t2 } = useTranslation(), _disabled = disabled || (focusBlock ? editor2.schemaTypes.block.name !== focusBlock._type : !1), activeKeys = useActiveStyleKeys({ items: itemsProp }), { activeItems, items } = React.useMemo(() => {
    const _activeItems = itemsProp.filter((item) => activeKeys.includes(item.style));
    let _items = itemsProp;
    return _activeItems.length === 0 && _items.length > 1 && (_items = _items.concat([emptyStyle]), _activeItems.push(emptyStyle)), { activeItems: _activeItems, items: _items };
  }, [activeKeys, itemsProp]), menuButtonText = React.useMemo(() => activeItems.length > 1 ? t2("inputs.portable-text.style.multiple") : activeItems.length !== 1 ? emptyStyle.i18nTitleKey ? t2(emptyStyle.i18nTitleKey) : emptyStyle.title : activeItems[0].i18nTitleKey ? t2(activeItems[0].i18nTitleKey) : activeItems[0].title, [activeItems, t2]), handleChange = React.useCallback(
    (item) => {
      focusBlock && item.style !== focusBlock.style && (portableTextEditor.PortableTextEditor.toggleBlockStyle(editor2, item.style), portableTextEditor.PortableTextEditor.focus(editor2));
    },
    [editor2, focusBlock]
  ), renderOption = React.useCallback(
    (item) => {
      const { style, styleComponent } = item, renderStyle2 = TEXT_STYLE_OPTIONS[style], title = item.i18nTitleKey ? t2(item.i18nTitleKey) : (item == null ? void 0 : item.title) || item.style, CustomComponent = typeof styleComponent == "function" ? styleComponent : void 0;
      return renderStyle2 && !CustomComponent ? renderStyle2(title) : CustomComponent ? /* @__PURE__ */ jsxRuntime.jsx(CustomComponent, { children: title }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: title });
    },
    [t2]
  ), button = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        disabled: _disabled,
        iconRight: icons.ChevronDownIcon,
        justify: "space-between",
        mode: "bleed",
        onClick: preventDefault,
        text: menuButtonText,
        width: "fill"
      }
    ),
    [_disabled, menuButtonText]
  ), menu = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { disabled: _disabled, children: items.map((item) => /* @__PURE__ */ jsxRuntime.jsx(
      StyledMenuItem,
      {
        pressed: activeItems.includes(item),
        onClick: _disabled ? void 0 : () => handleChange(item),
        children: renderOption(item)
      },
      item.key
    )) }),
    [_disabled, activeItems, handleChange, items, renderOption]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    MenuButtonMemo,
    {
      popover: MENU_POPOVER_PROPS$4,
      id: "block-style-select",
      button,
      menu
    }
  );
}), CollapseMenuMemo = React.memo(CollapseMenu), MENU_POPOVER_PROPS$3 = { constrainSize: !0, portal: !0 }, InsertMenu = React.memo(function(props2) {
  const { disabled, items, isFullscreen, collapsed } = props2, { t: t2 } = useTranslation(), focusBlock = useFocusBlock(), editor2 = portableTextEditor.usePortableTextEditor(), isVoidFocus = focusBlock && focusBlock._type !== editor2.schemaTypes.block.name, handleMenuClose = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2]), tooltipPlacement = isFullscreen ? "bottom" : "top", children = React.useMemo(() => items.map((item) => {
    const title = item.type.title || upperFirst__default.default(item.type.name);
    return /* @__PURE__ */ jsxRuntime.jsx(
      CollapseMenuButton,
      {
        "aria-label": t2(
          item.inline ? "inputs.portable-text.action.insert-inline-object-aria-label" : "inputs.portable-text.action.insert-block-aria-label",
          { typeName: title }
        ),
        mode: "bleed",
        disabled: disabled || isVoidFocus && item.inline === !0,
        icon: item.icon,
        onClick: item.handle,
        text: title,
        tooltipText: t2(
          item.inline ? "inputs.portable-text.action.insert-inline-object" : "inputs.portable-text.action.insert-block",
          { typeName: title }
        ),
        tooltipProps: {
          disabled,
          placement: tooltipPlacement,
          portal: "default"
        }
      },
      item.key
    );
  }), [disabled, isVoidFocus, items, t2, tooltipPlacement]), menuButtonProps = React.useMemo(
    () => ({
      button: /* @__PURE__ */ jsxRuntime.jsx(
        ContextMenuButton,
        {
          "data-testid": "insert-menu-button",
          disabled,
          tooltipProps: { placement: tooltipPlacement }
        }
      ),
      popover: MENU_POPOVER_PROPS$3
    }),
    [disabled, tooltipPlacement]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CollapseMenuMemo,
    {
      "data-testid": "insert-menu-auto-collapse-menu",
      collapsed,
      collapseText: !1,
      disableRestoreFocusOnClose: !0,
      gap: 1,
      menuButtonProps,
      onMenuClose: handleMenuClose,
      children
    }
  );
}), RootFlex$3 = styledComponents.styled(ui.Flex)`
  width: 100%;
`, StyleSelectBox = styledComponents.styled(ui.Box)`
  width: 8em;
`, StyleSelectFlex = styledComponents.styled(ui.Flex)`
  border-right: 1px solid var(--card-border-color);
`, ActionMenuBox = styledComponents.styled(ui.Box)`
  ${({ $withInsertMenu }) => $withInsertMenu && styledComponents.css`
      max-width: max-content;
      border-right: 1px solid var(--card-border-color);
    `}
`, FullscreenButtonBox = styledComponents.styled(ui.Box)`
  border-left: 1px solid var(--card-border-color);
`, SLOW_INITIAL_VALUE_LIMIT = 300, IS_MAC$1 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), InnerToolbar = React.memo(function({
  actionGroups,
  blockStyles,
  collapsible,
  disabled,
  insertMenuItems,
  isFullscreen,
  onToggleFullscreen
}) {
  const { t: t2 } = useTranslation(), showActionMenu = actionGroups.reduce((acc, x) => acc + x.actions.length, 0) > 0, showInsertMenu = insertMenuItems.length > 0, [rootElement, setRootElement] = React.useState(null), rootElementRect = ui.useElementRect(rootElement), collapsed = collapsible && rootElementRect ? (rootElementRect == null ? void 0 : rootElementRect.width) < 400 : !1, showBlockStyleSelect = blockStyles.length > 1;
  useRovingFocus({
    rootElement
  });
  const preventEditorBlurOnToolbarMouseDown = React.useCallback((e) => {
    e.preventDefault();
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$3, { align: "center", ref: setRootElement, onMouseDown: preventEditorBlurOnToolbarMouseDown, children: [
    showBlockStyleSelect && /* @__PURE__ */ jsxRuntime.jsx(StyleSelectFlex, { flex: collapsed ? 1 : void 0, children: /* @__PURE__ */ jsxRuntime.jsx(StyleSelectBox, { padding: isFullscreen ? 2 : 1, children: /* @__PURE__ */ jsxRuntime.jsx(BlockStyleSelect, { disabled, items: blockStyles }) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, children: [
      showActionMenu && /* @__PURE__ */ jsxRuntime.jsx(
        ActionMenuBox,
        {
          flex: collapsed ? void 0 : 1,
          padding: isFullscreen ? 2 : 1,
          $withInsertMenu: showInsertMenu,
          children: /* @__PURE__ */ jsxRuntime.jsx(
            ActionMenu,
            {
              disabled,
              collapsed,
              groups: actionGroups,
              isFullscreen
            }
          )
        }
      ),
      showInsertMenu && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: collapsed ? void 0 : 1, padding: isFullscreen ? 2 : 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        InsertMenu,
        {
          disabled,
          collapsed,
          items: insertMenuItems,
          isFullscreen
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(FullscreenButtonBox, { padding: isFullscreen ? 2 : 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": t2("inputs.portable-text.action.expand-editor"),
        icon: isFullscreen ? icons.CollapseIcon : icons.ExpandIcon,
        mode: "bleed",
        onClick: onToggleFullscreen,
        tooltipProps: {
          content: t2(
            isFullscreen ? "inputs.portable-text.action.collapse-editor" : "inputs.portable-text.action.expand-editor"
          ),
          hotkeys: [`${IS_MAC$1 ? "Cmd" : "Ctrl"}`, "Enter"],
          placement: isFullscreen ? "bottom" : "top",
          portal: "default"
        }
      }
    ) })
  ] });
});
function Toolbar(props2) {
  const { collapsible, hotkeys, isFullscreen, readOnly, onMemberOpen, onToggleFullscreen } = props2, editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection(), resolveInitialValueForType2 = useResolveInitialValueForType(), disabled = readOnly || !selection, { push } = ui.useToast(), resolveInitialValue2 = React.useCallback(
    (type) => {
      let isSlow = !1;
      const slowTimer = setTimeout(() => {
        isSlow = !0, push({
          id: "resolving-initial-value",
          status: "info",
          title: "Resolving initial value\u2026"
        });
      }, SLOW_INITIAL_VALUE_LIMIT);
      return resolveInitialValueForType2(type, {}).then((value) => (isSlow && push({
        id: "resolving-initial-value",
        status: "info",
        duration: 500,
        title: "Initial value resolved"
      }), value)).catch((error) => {
        push({
          title: "Could not resolve initial value",
          id: "resolving-initial-value",
          description: `Unable to resolve initial value for type: ${type.name}: ${error.message}.`,
          status: "error"
        });
      }).finally(() => clearTimeout(slowTimer));
    },
    [push, resolveInitialValueForType2]
  ), handleInsertBlock = React.useCallback(
    async (type) => {
      const initialValue = await resolveInitialValue2(type), path = portableTextEditor.PortableTextEditor.insertBlock(editor2, type, initialValue);
      path && onMemberOpen(path);
    },
    [editor2, onMemberOpen, resolveInitialValue2]
  ), handleInsertInline = React.useCallback(
    async (type) => {
      const initialValue = await resolveInitialValue2(type), path = portableTextEditor.PortableTextEditor.insertChild(editor2, type, initialValue);
      path && onMemberOpen(path);
    },
    [editor2, onMemberOpen, resolveInitialValue2]
  ), actionGroups = useActionGroups({
    hotkeys,
    onMemberOpen,
    resolveInitialValue: resolveInitialValue2,
    disabled: !0
  }), blockStyles = React.useMemo(() => getBlockStyles(editor2.schemaTypes), [editor2]), insertMenuItems = React.useMemo(
    () => getInsertMenuItems(editor2.schemaTypes, disabled, handleInsertBlock, handleInsertInline),
    [disabled, editor2, handleInsertBlock, handleInsertInline]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    InnerToolbar,
    {
      actionGroups,
      blockStyles,
      collapsible,
      disabled,
      insertMenuItems,
      isFullscreen,
      onToggleFullscreen
    }
  );
}
const noOutlineStyle = { outline: "none" }, FORM_BUILDER_DEFAULT_ID = "root", PlaceholderWrapper$1 = styledComponents.styled.span((props2) => {
  const { color: color2 } = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    color: ${color2.input.default.enabled.placeholder};
  `;
}), renderDecorator = (props2) => /* @__PURE__ */ jsxRuntime.jsx(Decorator, { ...props2 }), renderStyle = (props2) => /* @__PURE__ */ jsxRuntime.jsx(Style, { ...props2 }), renderListItem = (props2) => /* @__PURE__ */ jsxRuntime.jsx(ListItem$1, { ...props2 });
function Editor(props2) {
  const {
    elementRef,
    hideToolbar,
    hotkeys,
    initialSelection,
    isActive,
    isFullscreen,
    onCopy,
    onItemOpen,
    onPaste,
    onToggleFullscreen,
    path,
    readOnly,
    rangeDecorations,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderChild: renderChild2,
    renderEditable,
    scrollElement,
    setPortalElement,
    setScrollElement,
    ariaDescribedBy
  } = props2, { id: id2 } = useFormBuilder(), { t: t2 } = useTranslation(), { isTopLayer } = ui.useLayer(), { element: boundaryElement } = ui.useBoundaryElement();
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        !isTopLayer || !isFullscreen || event.key === "Escape" && onToggleFullscreen();
      },
      [onToggleFullscreen, isFullscreen, isTopLayer]
    )
  );
  const renderPlaceholder = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(PlaceholderWrapper$1, { "data-testid": "pt-input-placeholder", children: t2("inputs.portable-text.empty-placeholder") }),
    [t2]
  ), spellCheck = useSpellCheck(), scrollSelectionIntoView = useScrollSelectionIntoView(scrollElement), editable = React.useMemo(() => {
    const editableProps = {
      "aria-describedby": ariaDescribedBy,
      hotkeys,
      onCopy,
      onPaste,
      rangeDecorations,
      ref: elementRef,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderChild: renderChild2,
      renderDecorator,
      renderListItem,
      renderPlaceholder,
      renderStyle,
      scrollSelectionIntoView,
      selection: initialSelection,
      spellCheck,
      style: noOutlineStyle
    }, defaultRender = (defaultRenderProps) => /* @__PURE__ */ jsxRuntime.jsx(portableTextEditor.PortableTextEditable, { ...editableProps, ...omit__default.default(defaultRenderProps, ["renderDefault"]) });
    return renderEditable ? renderEditable({ ...editableProps, renderDefault: defaultRender }) : defaultRender(editableProps);
  }, [
    ariaDescribedBy,
    elementRef,
    hotkeys,
    initialSelection,
    onCopy,
    onPaste,
    rangeDecorations,
    renderAnnotation,
    renderBlock2,
    renderChild2,
    renderEditable,
    renderPlaceholder,
    scrollSelectionIntoView,
    spellCheck
  ]), handleToolBarOnMemberOpen = React.useCallback(
    (relativePath) => {
      onItemOpen(path.concat(relativePath));
    },
    [onItemOpen, path]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$g, { "data-fullscreen": isFullscreen, "data-testid": "pt-editor", children: [
    isActive && !hideToolbar && /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ToolbarCard, { "data-testid": "pt-editor__toolbar-card", shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      Toolbar,
      {
        collapsible: id2 === FORM_BUILDER_DEFAULT_ID,
        hotkeys,
        isFullscreen,
        onMemberOpen: handleToolBarOnMemberOpen,
        onToggleFullscreen,
        readOnly
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(EditableCard, { flex: 1, tone: readOnly ? "transparent" : "default", children: [
      /* @__PURE__ */ jsxRuntime.jsx(Scroller, { ref: setScrollElement, children: /* @__PURE__ */ jsxRuntime.jsx(EditableContainer, { padding: isFullscreen ? 2 : 0, sizing: "border", width: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        EditableWrapper,
        {
          $isFullscreen: isFullscreen,
          tone: readOnly ? "transparent" : "default",
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: isFullscreen ? scrollElement : boundaryElement, children: editable })
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntime.jsx("div", { "data-portal": "", ref: setPortalElement })
    ] })
  ] });
}
function useHotkeys(hotkeys) {
  const editor2 = portableTextEditor.usePortableTextEditor(), [initialHotkeys] = React.useState(() => hotkeys);
  return initialHotkeys !== hotkeys && console.warn(
    "Make sure that hotkeys are a stable object across renders, or there will be issues with key handling in the Portable Text Editor."
  ), React.useMemo(() => {
    const defaultHotkeys = { marks: {} };
    return editor2.schemaTypes.decorators.forEach((dec2) => {
      switch (dec2.value) {
        case "strong":
          defaultHotkeys.marks["mod+b"] = dec2.value;
          break;
        case "em":
          defaultHotkeys.marks["mod+i"] = dec2.value;
          break;
        case "underline":
          defaultHotkeys.marks["mod+u"] = dec2.value;
          break;
        case "code":
          defaultHotkeys.marks["mod+'"] = dec2.value;
          break;
      }
    }), {
      marks: { ...defaultHotkeys.marks, ...(initialHotkeys || {}).marks },
      custom: initialHotkeys.custom
    };
  }, [editor2, initialHotkeys]);
}
function useTrackFocusPath(props2) {
  const { focusPath, boundaryElement, onItemClose } = props2, portableTextMemberItems = usePortableTextMemberItems(), editor2 = portableTextEditor.usePortableTextEditor(), selection = portableTextEditor.usePortableTextEditorSelection();
  React.useLayoutEffect(() => {
    var _a2, _b, _c, _d, _e;
    if (focusPath.length === 0 || selection != null && selection.focus.path && PathUtils.isEqual(selection.focus.path, focusPath.slice(0, selection.focus.path.length)))
      return;
    const focusedItem = portableTextMemberItems.find((m) => m.member.item.focused), openItem = portableTextMemberItems.find((m) => m.member.open), relatedEditorItem = focusedItem || openItem;
    if (relatedEditorItem && (_a2 = relatedEditorItem.elementRef) != null && _a2.current) {
      boundaryElement && (scrollIntoView__default.default(boundaryElement, {
        scrollMode: "if-needed",
        block: "start",
        inline: "start"
      }), scrollIntoView__default.default(relatedEditorItem.elementRef.current, {
        scrollMode: "if-needed",
        boundary: boundaryElement,
        block: "nearest",
        inline: "start"
      }));
      const isTextBlock = relatedEditorItem.kind === "textBlock", isBlockFocusPath = focusPath.length === 1;
      if (isTextBlock || isBlockFocusPath) {
        const textBlockChildKey = isTextBlock && types.isKeyedObject(focusPath[2]) ? focusPath[2]._key : void 0, child = textBlockChildKey && Array.isArray((_b = relatedEditorItem.node.value) == null ? void 0 : _b.children) ? (_c = relatedEditorItem.node.value) == null ? void 0 : _c.children.find((c) => c._key === textBlockChildKey) : void 0, isSpanTextFocusPath = child && child._type === "span" && focusPath.length === 4 && focusPath[1] === "children" && focusPath[3] === "text" || !1, isTextChildFocusPath = isTextBlock && (focusPath.length === 3 && focusPath[1] === "children" || isSpanTextFocusPath);
        let path = [];
        isTextChildFocusPath ? path = focusPath.slice(0, 3) : (
          /* Known text block, but unknown child. Select first child in that block. */
          isTextBlock && isBlockFocusPath && Array.isArray((_d = relatedEditorItem.node.value) == null ? void 0 : _d.children) ? path = [focusPath[0], "children", { _key: (_e = relatedEditorItem.node.value) == null ? void 0 : _e.children[0]._key }] : isBlockFocusPath && (path = [{ _key: relatedEditorItem.key }])
        ), path.length && (portableTextEditor.PortableTextEditor.select(editor2, {
          anchor: { path, offset: 0 },
          focus: { path, offset: 0 }
        }), isTextBlock && portableTextEditor.PortableTextEditor.focus(editor2));
      }
    }
  }, [
    boundaryElement,
    editor2,
    focusPath,
    onItemClose,
    portableTextMemberItems,
    selection == null ? void 0 : selection.focus.path
  ]);
}
const Root$f = styledComponents.styled(ui.Card)(rootStyle), PreviewSpan = styledComponents.styled.span`
  display: block;
  max-width: calc(5em + 80px);
  position: relative;
`, TooltipBox$1 = styledComponents.styled(ui.Box)`
  max-width: 250px;
`;
function rootStyle({ theme: theme2 }) {
  var _a2, _b, _c;
  const { color: color$1, radius } = theme2.sanity;
  return styledComponents.css`
    line-height: 0;
    border-radius: ${radius[2]}px;
    padding: 2px;
    box-shadow: inset 0 0 0 1px var(--card-border-color);
    height: calc(1em - 1px);
    margin-top: 0.0625em;
    cursor: default;

    &:not([hidden]) {
      display: inline-flex;
      align-items: center;
      vertical-align: top;
    }

    &[data-ready-only] {
      cursor: default;
    }

    &[data-focused] {
      box-shadow: inset 0 0 0 1px ${(_a2 = color$1.selectable) == null ? void 0 : _a2.primary.selected.border};
      color: ${(_b = color$1.selectable) == null ? void 0 : _b.primary.pressed.fg};
    }

    &[data-selected] {
      background-color: ${(_c = color$1.selectable) == null ? void 0 : _c.primary.pressed.bg};
    }

    &:not([data-focused]):not([data-selected]) {
      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.default.hovered.border};
        }
      }
    }

    &[data-markers] {
      --card-bg-color: ${color$1.dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
    }

    &[data-warning] {
      --card-bg-color: ${color$1.muted.caution.hovered.bg};

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.muted.caution.hovered.border};
        }
      }
    }

    &[data-invalid] {
      --card-bg-color: ${color$1.input.invalid.enabled.bg};
      --card-border-color: ${color$1.input.invalid.enabled.border};

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.invalid.hovered.border};
        }
      }
    }
  `;
}
const POPOVER_FALLBACK_PLACEMENTS$4 = ["top", "bottom"];
function InlineObjectToolbarPopover(props2) {
  const {
    floatingBoundary,
    onClosePopover,
    onEdit,
    onDelete,
    referenceBoundary,
    referenceElement,
    title,
    open
  } = props2, { sanity: sanity2 } = ui.useTheme(), { t: t2 } = useTranslation(), editButtonRef = React.useRef(null), deleteButtonRef = React.useRef(null), popoverScheme = sanity2.color.dark ? "light" : "dark";
  ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClosePopover());
      },
      [onClosePopover]
    )
  );
  const handleDelete = React.useCallback(
    (event) => {
      var _a2;
      if (!((_a2 = deleteButtonRef.current) != null && _a2.disabled)) {
        event.preventDefault(), event.stopPropagation();
        try {
          onDelete(event);
        } catch (err) {
          console.error(err);
        } finally {
          deleteButtonRef.current && (deleteButtonRef.current.disabled = !0);
        }
      }
    },
    [onDelete]
  ), popoverContent = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: title }) }),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          "aria-label": t2("inputs.portable-text.inline-object.edit-aria-label"),
          icon: icons.EditIcon,
          mode: "bleed",
          onClick: onEdit,
          ref: editButtonRef,
          tooltipProps: { content: t2("inputs.portable-text.inline-object.edit") }
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          "aria-label": t2("inputs.portable-text.inline-object.remove-aria-label"),
          ref: deleteButtonRef,
          icon: icons.TrashIcon,
          mode: "bleed",
          onClick: handleDelete,
          tone: "critical",
          tooltipProps: { content: t2("inputs.portable-text.inline-object.remove") }
        }
      )
    ] }) }),
    [handleDelete, onEdit, title, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      constrainSize: !0,
      content: popoverContent,
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$4,
      floatingBoundary,
      open,
      placement: "top",
      portal: !0,
      referenceBoundary,
      referenceElement,
      scheme: popoverScheme
    }
  );
}
const InlineObject = (props2) => {
  var _a2;
  const {
    floatingBoundary,
    focused,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    relativePath,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderCustomMarkers,
    renderField,
    renderItem: renderItem2,
    renderInlineBlock,
    renderInput,
    renderPreview,
    schemaType,
    selected,
    value
  } = props2, { Markers } = useFormBuilder().__internal.components, editor2 = portableTextEditor.usePortableTextEditor(), markers = usePortableTextMarkers(path), memberItem = usePortableTextMemberItem(pathToString$1(path)), { validation: validation2, hasError, hasInfo, hasWarning } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), parentSchemaType = editor2.schemaTypes.block, hasMarkers = markers.length > 0, selfSelection = React.useMemo(
    () => ({
      anchor: { path: relativePath, offset: 0 },
      focus: { path: relativePath, offset: 0 }
    }),
    [relativePath]
  ), onRemove = React.useCallback(() => {
    portableTextEditor.PortableTextEditor.delete(editor2, selfSelection, { mode: "children" }), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [selfSelection, editor2]), onOpen = React.useCallback(() => {
    memberItem && (portableTextEditor.PortableTextEditor.blur(editor2), onItemOpen(memberItem.node.path));
  }, [editor2, onItemOpen, memberItem]), onClose = React.useCallback(() => {
    onItemClose(), portableTextEditor.PortableTextEditor.select(editor2, selfSelection), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [onItemClose, editor2, selfSelection]), isOpen = !!(memberItem != null && memberItem.member.open), input = memberItem == null ? void 0 : memberItem.input, nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$t, referenceElement = (_a2 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a2.current, presence = useChildPresence(path, !0), rootPresence = React.useMemo(
    () => presence.filter((p) => PathUtils.isEqual(p.path, path)),
    [path, presence]
  ), componentProps = React.useMemo(
    () => ({
      __unstable_floatingBoundary: floatingBoundary,
      __unstable_referenceBoundary: referenceBoundary,
      __unstable_referenceElement: referenceElement,
      children: input,
      focused,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      open: isOpen,
      markers,
      member: memberItem == null ? void 0 : memberItem.member,
      parentSchemaType,
      path: nodePath,
      presence: rootPresence,
      readOnly: !!readOnly,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderDefault: DefaultInlineObjectComponent,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview,
      schemaType,
      selected,
      value,
      validation: validation2
    }),
    [
      floatingBoundary,
      focused,
      input,
      isOpen,
      markers,
      memberItem == null ? void 0 : memberItem.member,
      nodePath,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      parentSchemaType,
      readOnly,
      referenceBoundary,
      referenceElement,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview,
      rootPresence,
      schemaType,
      selected,
      validation2,
      value
    ]
  ), tooltipEnabled = hasError || hasWarning || hasInfo || hasMarkers, toolTipContent = React.useMemo(
    () => tooltipEnabled && /* @__PURE__ */ jsxRuntime.jsx(TooltipBox$1, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Markers,
      {
        markers,
        validation: validation2,
        renderCustomMarkers
      }
    ) }) || null,
    [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]
  );
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx("span", { ref: memberItem == null ? void 0 : memberItem.elementRef, contentEditable: !1, children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Tooltip,
      {
        placement: "bottom",
        portal: "editor",
        disabled: isOpen ? !0 : !tooltipEnabled,
        content: toolTipContent,
        children: renderInlineBlock && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { position: "relative" }, children: renderInlineBlock(componentProps) })
      }
    ) }),
    [
      componentProps,
      memberItem == null ? void 0 : memberItem.elementRef,
      renderInlineBlock,
      toolTipContent,
      tooltipEnabled,
      isOpen
    ]
  );
}, DefaultInlineObjectComponent = (props2) => {
  const {
    __unstable_floatingBoundary: floatingBoundary,
    __unstable_referenceBoundary: referenceBoundary,
    __unstable_referenceElement: referenceElement,
    children,
    focused,
    markers,
    onClose,
    onOpen,
    onRemove,
    open,
    readOnly,
    renderPreview,
    schemaType,
    selected,
    validation: validation2,
    value
  } = props2, { t: t2 } = useTranslation(), hasMarkers = markers.length > 0, [popoverOpen, setPopoverOpen] = React.useState(!1), popoverTitle = (schemaType == null ? void 0 : schemaType.title) || schemaType.name, hasError = validation2.filter((v) => v.level === "error").length > 0, hasWarning = validation2.filter((v) => v.level === "warning").length > 0, openItem = React.useCallback(() => {
    setPopoverOpen(!1), onOpen();
  }, [onOpen]);
  React.useEffect(() => {
    setPopoverOpen(open ? !1 : !!focused);
  }, [focused, open]);
  const tone = React.useMemo(() => {
    if (hasError)
      return "critical";
    if (hasWarning)
      return "caution";
    if (selected || focused)
      return "primary";
  }, [focused, hasError, hasWarning, selected]), onClosePopover = React.useCallback(() => {
    setPopoverOpen(!1);
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Root$f,
      {
        "aria-label": t2("inputs.portable-text.inline-block.aria-label"),
        "data-focused": focused || void 0,
        "data-invalid": hasError || void 0,
        "data-markers": hasMarkers || void 0,
        "data-read-only": readOnly || void 0,
        "data-selected": selected || void 0,
        "data-warning": hasWarning || void 0,
        forwardedAs: "span",
        onClick: readOnly ? openItem : void 0,
        onDoubleClick: openItem,
        tone,
        children: /* @__PURE__ */ jsxRuntime.jsx(PreviewSpan, { children: renderPreview({
          layout: "inline",
          schemaType,
          skipVisibilityCheck: !0,
          value,
          fallbackTitle: "Click to edit"
        }) })
      }
    ),
    referenceElement && /* @__PURE__ */ jsxRuntime.jsx(
      InlineObjectToolbarPopover,
      {
        floatingBoundary,
        onClosePopover,
        onDelete: onRemove,
        onEdit: openItem,
        open: popoverOpen,
        referenceBoundary,
        referenceElement,
        title: popoverTitle
      }
    ),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      ObjectEditModal,
      {
        defaultType: "popover",
        onClose,
        autoFocus: focused,
        floatingBoundary,
        referenceBoundary,
        referenceElement,
        schemaType,
        children
      }
    )
  ] });
};
function Compositor(props2) {
  const {
    changed,
    elementRef,
    focused,
    focusPath = EMPTY_ARRAY$t,
    hasFocusWithin,
    hideToolbar,
    hotkeys,
    isActive,
    isFullscreen,
    onActivate,
    onCopy,
    onItemClose,
    onItemOpen,
    onItemRemove,
    onPaste,
    onPathFocus,
    onToggleFullscreen,
    path,
    rangeDecorations,
    readOnly,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderBlockActions,
    renderCustomMarkers,
    renderEditable,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    value
  } = props2, editor2 = portableTextEditor.usePortableTextEditor(), boundaryElement = ui.useBoundaryElement().element, [wrapperElement, setWrapperElement] = React.useState(null), [scrollElement, setScrollElement] = React.useState(null), handleToggleFullscreen = React.useCallback(() => {
    onToggleFullscreen();
  }, [onToggleFullscreen]), hotkeysWithFullscreenToggle = React.useMemo(
    () => ({
      ...hotkeys,
      custom: {
        "mod+enter": onToggleFullscreen,
        ...(hotkeys == null ? void 0 : hotkeys.custom) || {}
      }
    }),
    [hotkeys, onToggleFullscreen]
  ), editorHotkeys = useHotkeys(hotkeysWithFullscreenToggle), _renderBlockActions = value && renderBlockActions ? renderBlockActions : void 0, _renderCustomMarkers = value && renderCustomMarkers ? renderCustomMarkers : void 0, [portalElement, setPortalElement] = React.useState(null), renderTextBlock = React.useCallback(
    (blockProps) => {
      const {
        children,
        focused: blockFocused,
        path: blockPath,
        selected,
        schemaType: blockSchemaType,
        value: block
      } = blockProps;
      return /* @__PURE__ */ jsxRuntime.jsx(
        TextBlock,
        {
          floatingBoundary: boundaryElement,
          focused: blockFocused,
          isFullscreen,
          onItemClose,
          onItemOpen,
          onItemRemove,
          onPathFocus,
          path: path.concat(blockPath),
          readOnly,
          referenceBoundary: scrollElement,
          renderAnnotation,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem: renderItem2,
          renderBlockActions: _renderBlockActions,
          renderCustomMarkers: _renderCustomMarkers,
          renderPreview,
          renderBlock: renderBlock2,
          schemaType: blockSchemaType,
          selected,
          value: block,
          children
        }
      );
    },
    [
      _renderBlockActions,
      _renderCustomMarkers,
      boundaryElement,
      isFullscreen,
      onItemClose,
      onItemOpen,
      onItemRemove,
      onPathFocus,
      path,
      readOnly,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview,
      scrollElement
    ]
  ), renderObjectBlock = React.useCallback(
    (blockProps) => {
      const {
        focused: blockFocused,
        path: blockPath,
        selected: blockSelected,
        schemaType: blockSchemaType,
        value: blockValue
      } = blockProps;
      return /* @__PURE__ */ jsxRuntime.jsx(
        BlockObject,
        {
          floatingBoundary: boundaryElement,
          focused: blockFocused,
          isFullscreen,
          onItemClose,
          onItemOpen,
          onItemRemove,
          onPathFocus,
          path: path.concat(blockPath),
          readOnly,
          referenceBoundary: scrollElement,
          relativePath: blockPath,
          renderAnnotation,
          renderBlock: renderBlock2,
          renderBlockActions: _renderBlockActions,
          renderCustomMarkers: _renderCustomMarkers,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem: renderItem2,
          renderPreview,
          schemaType: blockSchemaType,
          selected: blockSelected,
          value: blockValue
        }
      );
    },
    [
      boundaryElement,
      scrollElement,
      isFullscreen,
      onItemClose,
      onItemOpen,
      onItemRemove,
      onPathFocus,
      path,
      readOnly,
      renderAnnotation,
      renderBlock2,
      _renderBlockActions,
      _renderCustomMarkers,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview
    ]
  ), editorRenderBlock = React.useCallback(
    (blockProps) => {
      const { value: block } = blockProps;
      return block._type === editor2.schemaTypes.block.name ? renderTextBlock(blockProps) : renderObjectBlock(blockProps);
    },
    [editor2.schemaTypes.block.name, renderObjectBlock, renderTextBlock]
  ), editorRenderChild = React.useCallback(
    (childProps) => {
      const {
        children,
        focused: childFocused,
        path: childPath,
        selected,
        schemaType: childSchemaType,
        value: child
      } = childProps;
      return child._type === editor2.schemaTypes.span.name ? children : /* @__PURE__ */ jsxRuntime.jsx(
        InlineObject,
        {
          floatingBoundary: boundaryElement,
          focused: childFocused,
          onItemClose,
          onItemOpen,
          onPathFocus,
          path: path.concat(childPath),
          readOnly,
          referenceBoundary: scrollElement,
          relativePath: childPath,
          renderAnnotation,
          renderBlock: renderBlock2,
          renderCustomMarkers,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem: renderItem2,
          renderPreview,
          schemaType: childSchemaType,
          selected,
          value: child
        }
      );
    },
    [
      editor2.schemaTypes.span.name,
      boundaryElement,
      onItemClose,
      onItemOpen,
      onPathFocus,
      path,
      readOnly,
      scrollElement,
      renderAnnotation,
      renderBlock2,
      renderCustomMarkers,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview
    ]
  ), editorRenderAnnotation = React.useCallback(
    (annotationProps) => {
      const {
        children,
        focused: editorNodeFocused,
        path: aPath,
        selected,
        schemaType: aSchemaType,
        value: aValue
      } = annotationProps;
      return /* @__PURE__ */ jsxRuntime.jsx(
        Annotation,
        {
          editorNodeFocused,
          floatingBoundary: boundaryElement,
          focused: !!focused,
          onItemClose,
          onItemOpen,
          onPathFocus,
          path: path.concat(aPath),
          readOnly,
          referenceBoundary: scrollElement,
          renderAnnotation,
          renderBlock: renderBlock2,
          renderCustomMarkers,
          renderField,
          renderInlineBlock,
          renderInput,
          renderItem: renderItem2,
          renderPreview,
          schemaType: aSchemaType,
          selected,
          value: aValue,
          children
        }
      );
    },
    [
      boundaryElement,
      scrollElement,
      focused,
      onItemClose,
      onItemOpen,
      onPathFocus,
      path,
      readOnly,
      renderAnnotation,
      renderBlock2,
      renderCustomMarkers,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview
    ]
  ), ariaDescribedBy = props2.elementProps["aria-describedby"], initialSelection = React.useMemo(() => {
    if (hasFocusWithin)
      return {
        anchor: {
          path: focusPath,
          offset: 0
        },
        focus: {
          path: focusPath,
          offset: 0
        }
      };
  }, []), editorNode = React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      Editor,
      {
        ariaDescribedBy,
        elementRef,
        initialSelection,
        hideToolbar,
        hotkeys: editorHotkeys,
        isActive,
        isFullscreen,
        onItemOpen,
        onCopy,
        onPaste,
        onToggleFullscreen: handleToggleFullscreen,
        path,
        rangeDecorations,
        readOnly,
        renderAnnotation: editorRenderAnnotation,
        renderBlock: editorRenderBlock,
        renderChild: editorRenderChild,
        renderEditable,
        setPortalElement,
        scrollElement,
        setScrollElement
      }
    ),
    // Keep only stable ones here!
    [
      ariaDescribedBy,
      editorHotkeys,
      editorRenderAnnotation,
      editorRenderBlock,
      editorRenderChild,
      elementRef,
      handleToggleFullscreen,
      hideToolbar,
      initialSelection,
      isActive,
      isFullscreen,
      onCopy,
      onItemOpen,
      onPaste,
      path,
      rangeDecorations,
      readOnly,
      renderEditable,
      scrollElement
    ]
  ), portal = ui.usePortal(), portalElements = React.useMemo(
    () => ({
      collapsed: wrapperElement,
      default: portal.element,
      editor: portalElement,
      expanded: portal.element
    }),
    [portal.element, portalElement, wrapperElement]
  );
  useTrackFocusPath({
    focusPath,
    boundaryElement: scrollElement,
    onItemClose
  });
  const editorFocused = focused || hasFocusWithin;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.PortalProvider, { __unstable_elements: portalElements, element: portal.element, children: /* @__PURE__ */ jsxRuntime.jsx(ActivateOnFocus, { onActivate, isOverlayActive: !isActive, children: /* @__PURE__ */ jsxRuntime.jsx(
    ChangeIndicator,
    {
      disabled: isFullscreen,
      hasFocus: !!focused,
      isChanged: changed,
      path,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        Root$j,
        {
          "data-focused": editorFocused ? "" : void 0,
          "data-read-only": readOnly ? "" : void 0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-wrapper": "", ref: setWrapperElement, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { __unstable_name: isFullscreen ? "expanded" : "collapsed", children: isFullscreen ? /* @__PURE__ */ jsxRuntime.jsx(ExpandedLayer, { children: editorNode }) : editorNode }) }),
            /* @__PURE__ */ jsxRuntime.jsx("div", { "data-border": "" })
          ]
        }
      )
    }
  ) }) });
}
function PortableTextMarkersProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.PortableTextMarkersContext.Provider, { value: props2.markers, children: props2.children });
}
function PortableTextMemberItemsProvider(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.PortableTextMemberItemsContext.Provider, { value: props2.memberItems, children: props2.children });
}
function InvalidValue(props2) {
  const { onChange, onIgnore, resolution, readOnly } = props2, telemetry2 = react.useTelemetry(), { t: t2 } = useTranslation(), handleAction = React.useCallback(() => {
    resolution && (onChange({ type: "mutation", patches: resolution.patches }), telemetry2.log(PortableTextInvalidValueResolve, {
      PTEInvalidValueId: resolution.i18n.description,
      PTEInvalidValueDescription: resolution.description
    }));
  }, [onChange, resolution, telemetry2]), handleOnIgnore = React.useCallback(() => {
    telemetry2.log(PortableTextInvalidValueIgnore), onIgnore();
  }, [onIgnore, telemetry2]);
  return resolution ? /* @__PURE__ */ jsxRuntime.jsx(
    Alert,
    {
      title: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("inputs.portable-text.invalid-value.title") }),
      suffix: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { padding: 2, children: [
        resolution.action && /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: [1, 2], gap: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              mode: "ghost",
              onClick: handleOnIgnore,
              text: t2("inputs.portable-text.invalid-value.ignore-button.text")
            }
          ),
          !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              onClick: handleAction,
              text: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  t: t2,
                  i18nKey: resolution.i18n.action,
                  values: resolution.i18n.values
                }
              ),
              tone: "caution"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: resolution.action && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: t2("inputs.portable-text.invalid-value.action-disclaimer") }) })
      ] }),
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: resolution.i18n.description, values: resolution.i18n.values }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, overflow: "auto", padding: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", children: JSON.stringify(resolution.item, null, 2) }) })
      ] })
    }
  ) : null;
}
const DOT_SIZE = 6, CONTENT_BOX_VARIANTS = {
  animate: { opacity: 1, scaleX: 1, scaleY: 1 },
  exit: { opacity: 0, scaleX: 0, scaleY: 0.5 },
  initial: { opacity: 0, scaleX: 0, scaleY: 0.5 }
}, CONTENT_BOX_TRANSITION = {
  duration: 0.3,
  ease: "easeInOut",
  type: "spring",
  bounce: 0
}, CONTENT_TEXT_VARIANTS = {
  animate: { opacity: 1 },
  exit: { opacity: 0 },
  initial: { opacity: 0 }
}, CONTENT_TEXT_TRANSITION = {
  duration: 0.2,
  delay: 0.15
}, CursorLine = styledComponents.styled.span(({ theme: theme$1, $tints }) => {
  var _a2;
  const isDark = (_a2 = theme.getTheme_v2(theme$1)) == null ? void 0 : _a2.color._dark, bg = $tints[isDark ? 400 : 500].hex, fg = $tints[isDark ? 900 : 50].hex;
  return styledComponents.css`
    --presence-cursor-bg: ${bg};
    --presence-cursor-fg: ${fg};

    border-left: 1px solid transparent;
    border-color: var(--presence-cursor-bg);
    margin-left: -1px;
    position: relative;
    word-break: normal;
    white-space: normal;
    mix-blend-mode: unset;
    pointer-events: none;
  `;
}), CursorDot = styledComponents.styled.div`
  background-color: var(--presence-cursor-bg);
  border-radius: 50%;
  width: ${DOT_SIZE}px;
  height: ${DOT_SIZE}px;
  position: absolute;
  top: -${DOT_SIZE - 1}px;
  left: -0.5px;
  transform: translateX(-50%);
  mix-blend-mode: unset;
  z-index: 0;
  pointer-events: all;

  // Increase the hit area of the cursor dot
  &:before {
    content: '';
    position: absolute;
    top: -${DOT_SIZE / 2}px;
    left: 50%;
    transform: translateX(-50%);
    width: ${DOT_SIZE * 2}px;
    height: ${DOT_SIZE * 3}px;
    opacity: 0.5;
  }
`, UserBox = styledComponents.styled(framerMotion.motion(ui.Box))(({ theme: theme$1 }) => {
  var _a2;
  const radius = (_a2 = theme.getTheme_v2(theme$1)) == null ? void 0 : _a2.radius[4];
  return styledComponents.css`
    position: absolute;
    top: -${DOT_SIZE * 1.5}px;
    left: -${DOT_SIZE * 0.75}px;
    transform-origin: left;
    white-space: nowrap;
    padding: 3px 6px;
    box-sizing: border-box;
    border-radius: ${radius}px;
    background-color: var(--presence-cursor-bg);
    z-index: 1;
    mix-blend-mode: unset;
    user-select: none;
  `;
}), UserText = styledComponents.styled(framerMotion.motion(ui.Text))`
  color: var(--presence-cursor-fg);
  mix-blend-mode: unset;
`;
function UserPresenceCursor(props2) {
  const { children, user } = props2, { tints } = useUserColor(user.id), [hovered, setHovered] = React.useState(!1), handleMouseEnter = React.useCallback(() => setHovered(!0), []), handleMouseLeave = React.useCallback(() => setHovered(!1), []), testId = React.useMemo(
    () => {
      var _a2;
      return `presence-cursor-${(_a2 = user.displayName) == null ? void 0 : _a2.split(" ").join("-")}`;
    },
    [user.displayName]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      CursorLine,
      {
        $tints: tints,
        contentEditable: !1,
        "data-testid": testId,
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: hovered && /* @__PURE__ */ jsxRuntime.jsx(
            UserBox,
            {
              animate: "animate",
              exit: "exit",
              flex: 1,
              initial: "initial",
              transition: CONTENT_BOX_TRANSITION,
              variants: CONTENT_BOX_VARIANTS,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                UserText,
                {
                  animate: "animate",
                  exit: "exit",
                  initial: "initial",
                  size: 0,
                  transition: CONTENT_TEXT_TRANSITION,
                  variants: CONTENT_TEXT_VARIANTS,
                  weight: "medium",
                  children: user.displayName
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(CursorDot, {})
        ]
      }
    ),
    children
  ] });
}
function usePresenceCursorDecorations(props2) {
  const { path } = props2, fieldPresence = useFormFieldPresence(), [currentPresence, setCurrentPresence] = React.useState([]), [presenceCursorDecorations, setPresenceCursorDecorations] = React.useState([]), previousPresence = React.useRef(currentPresence), handleRangeDecorationMoved = React.useCallback((details) => {
    const { rangeDecoration, newSelection } = details;
    setPresenceCursorDecorations((prev) => prev.map((p) => {
      var _a2, _b;
      return ((_a2 = p.payload) == null ? void 0 : _a2.sessionId) === ((_b = rangeDecoration.payload) == null ? void 0 : _b.sessionId) ? {
        ...rangeDecoration,
        selection: newSelection
      } : p;
    }));
  }, []);
  return React.useEffect(() => {
    const nextPresence = fieldPresence.filter(
      (p) => PathUtils.startsWith(path, p.path) && !isEqual__default.default(path, p.path)
    ), filteredNext = nextPresence.map((d) => ({ ...d.selection, sessionId: d.sessionId })), filteredPrevious = previousPresence.current.map((d) => ({
      ...d.selection,
      sessionId: d.sessionId
    }));
    if (!isEqual__default.default(filteredNext, filteredPrevious)) {
      const value = nextPresence.length > 0 ? nextPresence : sanity.EMPTY_ARRAY;
      setCurrentPresence(value), previousPresence.current = value;
    }
  }, [fieldPresence, path]), React.useEffect(() => {
    const decorations = currentPresence.map((presence) => {
      if (!presence.selection) return null;
      const cursorPoint = { focus: presence.selection.focus, anchor: presence.selection.focus };
      return {
        component: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(UserPresenceCursor, { user: presence.user, children }),
        selection: cursorPoint,
        onMoved: handleRangeDecorationMoved,
        payload: { sessionId: presence.sessionId }
      };
    });
    setPresenceCursorDecorations(decorations.filter(Boolean));
  }, [currentPresence, handleRangeDecorationMoved]), presenceCursorDecorations;
}
function getUploadCandidates(types2, resolveUploader2, file) {
  return types2.map((memberType) => ({
    type: memberType,
    uploader: resolveUploader2(memberType, file),
    parentType: memberType
  })).filter((member) => member.uploader);
}
function usePatches(props2) {
  const { path } = props2, { patchChannel } = useFormBuilder().__internal;
  return { subscribe: React.useCallback(
    (subscriber) => patchChannel.subscribe(({ snapshot, patches }) => {
      const filteredPatches = patches.filter((patch2) => _startsWith(patch2.path, path)).map((patch2) => ({
        ...patch2,
        path: patch2.path.slice(path.length)
      }));
      filteredPatches.length && subscriber({
        shouldReset: _shouldReset(path, patches),
        snapshot: isRecord$4(snapshot) ? _getValueAtPath(snapshot, path) : {},
        patches: filteredPatches
      });
    }),
    [path, patchChannel]
  ) };
}
function _isSegmentEqual(segment1, segment2) {
  const segment1Type = typeof segment1;
  return segment1Type !== typeof segment2 ? !1 : segment1Type === "object" ? shallowEquals__default.default(segment1, segment2) : segment1 === segment2;
}
function _startsWith(subjectPath, checkPath) {
  if (subjectPath === checkPath)
    return !0;
  if (!Array.isArray(subjectPath) || !Array.isArray(checkPath) || subjectPath.length < checkPath.length)
    return !1;
  for (let i = 0, len = checkPath.length; i < len; i++)
    if (!_isSegmentEqual(checkPath[i], subjectPath[i]))
      return !1;
  return !0;
}
function _isAncestor(path1, path2) {
  return path1.length === 0 || _startsWith(path2, path1) && !_startsWith(path1, path2);
}
function _shouldReset(path, patches) {
  return patches.some(
    (patch2) => _isAncestor(patch2.path, path) && (patch2.type === "set" || patch2.type === "unset")
  );
}
function _getValueAtPath(value, path) {
  return path.reduce((result, segment) => typeof segment == "object" ? find__default.default(result, segment) : get__default.default(result, segment), value);
}
function PortableTextInput(props2) {
  const {
    editorRef: editorRefProp,
    elementProps,
    hotkeys,
    initialActive,
    initialFullscreen,
    markers = EMPTY_ARRAY$t,
    onChange,
    onCopy,
    onEditorChange,
    onFullScreenChange,
    onInsert,
    onItemRemove,
    onPaste,
    onPathFocus,
    path,
    readOnly,
    rangeDecorations: rangeDecorationsProp,
    renderBlockActions,
    renderCustomMarkers,
    renderEditable,
    schemaType,
    value,
    resolveUploader: resolveUploader2,
    onUpload
  } = props2, { onBlur, ref: elementRef } = elementProps, defaultEditorRef = React.useRef(null), editorRef = editorRefProp || defaultEditorRef, presenceCursorDecorations = usePresenceCursorDecorations(
    React.useMemo(
      () => ({
        path: props2.path
      }),
      [props2.path]
    )
  ), { subscribe } = usePatches({ path }), { t: t2 } = useTranslation(), [ignoreValidationError, setIgnoreValidationError] = React.useState(!1), [invalidValue, setInvalidValue] = React.useState(null), [isFullscreen, setIsFullscreen] = React.useState(initialFullscreen != null ? initialFullscreen : !1), [isActive, setIsActive] = React.useState(initialActive != null ? initialActive : !1), [isOffline, setIsOffline] = React.useState(!1), [hasFocusWithin, setHasFocusWithin] = React.useState(!1), telemetry2 = react.useTelemetry(), toast = ui.useToast(), patchSubject = React.useMemo(() => new rxjs.Subject(), []), patches$ = React.useMemo(() => patchSubject.asObservable(), [patchSubject]), handleToggleFullscreen = React.useCallback(() => {
    setIsFullscreen((v) => {
      const next = !v;
      return next ? telemetry2.log(PortableTextInputExpanded) : telemetry2.log(PortableTextInputCollapsed), onFullScreenChange == null || onFullScreenChange(next), next;
    });
  }, [onFullScreenChange, telemetry2]);
  React.useEffect(() => {
    invalidValue && value !== invalidValue.value && setInvalidValue(null);
  }, [invalidValue, value]), React.useEffect(() => subscribe(({ patches, snapshot }) => {
    patchSubject.next({ patches, snapshot });
  }), [patchSubject, subscribe]);
  const portableTextMemberItems = usePortableTextMemberItemsFromProps(props2);
  React.useEffect(() => {
    hasFocusWithin && setIsActive(!0);
  }, [hasFocusWithin]);
  const setFocusPathFromEditorSelection = React.useCallback(() => {
    const selection = nextSelectionRef.current, focusPath = selection == null ? void 0 : selection.focus.path;
    if (!focusPath) return;
    const nextFocusPath = focusPath.length === 3 && // A span path is always 3 segments long
    focusPath[1] === "children" && // Is a child of a block
    types.isKeySegment(focusPath[2]) && // Contains the key of the child
    !portableTextMemberItems.some(
      (item) => types.isKeySegment(focusPath[2]) && item.member.key === focusPath[2]._key
    ) ? focusPath.concat(["text"]) : focusPath;
    React.startTransition(() => {
      onPathFocus(nextFocusPath, {
        selection
      });
    });
  }, [onPathFocus, portableTextMemberItems]), nextSelectionRef = React.useRef(null), handleEditorChange = React.useCallback(
    (change) => {
      switch (change.type) {
        case "mutation":
          onChange(toFormPatches(change.patches));
          break;
        case "connection":
          change.value === "offline" ? setIsOffline(!0) : change.value === "online" && setIsOffline(!1);
          break;
        case "selection":
          nextSelectionRef.current = change.selection, setFocusPathFromEditorSelection();
          break;
        case "focus":
          setIsActive(!0), setHasFocusWithin(!0);
          break;
        case "blur":
          onBlur(change.event), setHasFocusWithin(!1);
          break;
        case "undo":
        case "redo":
          onChange(toFormPatches(change.patches));
          break;
        case "invalidValue":
          setInvalidValue(change);
          break;
        case "error":
          toast.push({
            status: change.level,
            description: change.description
          });
          break;
      }
      editorRef.current && onEditorChange && onEditorChange(change, editorRef.current);
    },
    [editorRef, onEditorChange, onChange, setFocusPathFromEditorSelection, onBlur, toast]
  );
  React.useEffect(() => {
    setIgnoreValidationError(!1);
  }, [value]);
  const handleIgnoreInvalidValue = React.useCallback(() => {
    setIgnoreValidationError(!0);
  }, []), respondToInvalidContent = React.useMemo(() => invalidValue && invalidValue.resolution ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    InvalidValue,
    {
      onChange: handleEditorChange,
      onIgnore: handleIgnoreInvalidValue,
      resolution: invalidValue.resolution,
      readOnly: isOffline || readOnly
    }
  ) }) : null, [handleEditorChange, handleIgnoreInvalidValue, invalidValue, isOffline, readOnly]), handleActivate = React.useCallback(() => {
    isActive || (setIsActive(!0), editorRef.current && portableTextEditor.PortableTextEditor.focus(editorRef.current));
  }, [editorRef, isActive]), previousRangeDecorations = React.useRef([]), rangeDecorations = React.useMemo(() => {
    const result = [...rangeDecorationsProp || [], ...presenceCursorDecorations], reconciled = immutableReconcile(previousRangeDecorations.current, result);
    return previousRangeDecorations.current = reconciled, reconciled;
  }, [presenceCursorDecorations, rangeDecorationsProp]), uploadFile2 = React.useCallback(
    (file, resolvedUploader) => {
      const { type, uploader } = resolvedUploader;
      onUpload == null || onUpload({ file, schemaType: type, uploader });
    },
    [onUpload]
  ), handleFiles = React.useCallback(
    (files) => {
      if (!resolveUploader2)
        return;
      const tasks2 = files.map((file) => ({
        file,
        uploaderCandidates: getUploadCandidates(schemaType.of, resolveUploader2, file)
      })), ready = tasks2.filter((task) => task.uploaderCandidates.length > 0), rejected = tasks2.filter((task) => task.uploaderCandidates.length === 0);
      rejected.length > 0 && toast.push({
        closable: !0,
        status: "warning",
        title: t2("inputs.array.error.cannot-upload-unable-to-convert", {
          count: rejected.length
        }),
        description: rejected.map((task, i) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, padding: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: task.file.name }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
            "(",
            task.file.type,
            ")"
          ] }) })
        ] }, i))
      }), ready.forEach((task) => {
        uploadFile2(
          task.file,
          // eslint-disable-next-line max-nested-callbacks
          sortBy__default.default(task.uploaderCandidates, (candidate) => candidate.uploader.priority)[0]
        );
      });
    },
    [toast, resolveUploader2, schemaType, uploadFile2, t2]
  ), handlePaste = React.useCallback(
    (input) => {
      const { event } = input;
      return extractPastedFiles(event.clipboardData).then((files) => files.length > 0 ? files : []).then((files) => {
        handleFiles(files);
      }), onPaste == null ? void 0 : onPaste(input);
    },
    [handleFiles, onPaste]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(
    UploadTargetCard,
    {
      types: schemaType.of,
      resolveUploader: props2.resolveUploader,
      onUpload: props2.onUpload,
      ...elementProps,
      tabIndex: -1,
      children: [
        !ignoreValidationError && respondToInvalidContent,
        (!invalidValue || ignoreValidationError) && /* @__PURE__ */ jsxRuntime.jsx(PortableTextMarkersProvider, { markers, children: /* @__PURE__ */ jsxRuntime.jsx(PortableTextMemberItemsProvider, { memberItems: portableTextMemberItems, children: /* @__PURE__ */ jsxRuntime.jsx(
          portableTextEditor.PortableTextEditor,
          {
            patches$,
            onChange: handleEditorChange,
            maxBlocks: void 0,
            ref: editorRef,
            readOnly: isOffline || readOnly,
            schemaType,
            value,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              Compositor,
              {
                ...props2,
                elementRef,
                hasFocusWithin,
                hotkeys,
                isActive,
                isFullscreen,
                onActivate: handleActivate,
                onItemRemove,
                onCopy,
                onInsert,
                onPaste: handlePaste,
                onToggleFullscreen: handleToggleFullscreen,
                rangeDecorations,
                renderBlockActions,
                renderCustomMarkers,
                renderEditable
              }
            )
          }
        ) }) })
      ]
    }
  ) });
}
function toFormPatches(patches) {
  return patches.map((p) => ({ ...p, patchType: SANITY_PATCH_TYPE }));
}
function focusRingBorderStyle$1(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
function focusRingStyle(opts) {
  const { base, border, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border && focusRingBorderStyle$1(border),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
const Root$e = styledComponents.styled(ui.Card)((props2) => {
  const { theme: theme2 } = props2, { focusRing, input, radius } = theme2.sanity, color2 = theme2.sanity.color.input, space = ui.rem(theme2.sanity.space[1]);
  return {
    position: "relative",
    borderRadius: `${radius[1]}px`,
    color: color2.default.enabled.fg,
    boxShadow: focusRingBorderStyle$1({
      color: color2.default.enabled.border,
      width: input.border.width
    }),
    "& > .content": {
      position: "relative",
      lineHeight: 0,
      margin: `-${space} 0 0 -${space}`
    },
    "& > .content > div": {
      display: "inline-block",
      verticalAlign: "top",
      padding: `${space} 0 0 ${space}`
    },
    // enabled
    "&:not([data-read-only])": {
      cursor: "text"
    },
    // hovered
    "@media(hover:hover):not([data-disabled]):not([data-read-only]):hover": {
      borderColor: color2.default.hovered.border
    },
    // focused
    "&:not([data-disabled]):not([data-read-only])[data-focused]": {
      boxShadow: focusRingStyle({
        border: {
          color: color2.default.enabled.border,
          width: input.border.width
        },
        focusRing
      })
    },
    // disabled
    "*:disabled + &": {
      color: color2.default.disabled.fg,
      backgroundColor: color2.default.disabled.bg,
      boxShadow: focusRingBorderStyle$1({
        color: color2.default.disabled.border,
        width: input.border.width
      })
    }
  };
}), Input = styledComponents.styled.input((props2) => {
  const { theme: theme2 } = props2, font = theme2.sanity.fonts.text, color2 = theme2.sanity.color.input, p = theme2.sanity.space[2], size = theme2.sanity.fonts.text.sizes[2];
  return {
    appearance: "none",
    background: "none",
    border: 0,
    borderRadius: 0,
    outline: "none",
    fontSize: ui.rem(size.fontSize),
    lineHeight: size.lineHeight / size.fontSize,
    fontFamily: font.family,
    fontWeight: font.weights.regular,
    margin: 0,
    display: "block",
    minWidth: "1px",
    maxWidth: "100%",
    boxSizing: "border-box",
    paddingTop: ui.rem(p - size.ascenderHeight),
    paddingRight: ui.rem(p),
    paddingBottom: ui.rem(p - size.descenderHeight),
    paddingLeft: ui.rem(p),
    // enabled
    "&:not(:invalid):not(:disabled)": {
      color: color2.default.enabled.fg
    },
    // disabled
    "&:not(:invalid):disabled": {
      color: color2.default.disabled.fg
    }
  };
}), Placeholder$1 = styledComponents.styled(ui.Box)((props2) => {
  const { theme: theme2 } = props2, color2 = theme2.sanity.color.input;
  return styledComponents.css`
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    pointer-events: none;
    --card-fg-color: ${color2.default.enabled.placeholder};
  `;
}), TagBox = styledComponents.styled(ui.Box)`
  // This is needed to make textOverflow="ellipsis" work properly for the Text primitive
  max-width: 100%;
`, TagInput = React.forwardRef(
  (props2, ref) => {
    const {
      disabled,
      onChange,
      onFocus,
      placeholder: placeholderProp,
      readOnly,
      value = [],
      ...restProps
    } = props2, { t: t2 } = useTranslation(studioLocaleNamespace), [inputValue, setInputValue] = React.useState(""), enabled = !disabled && !readOnly, [focused, setFocused] = React.useState(!1), forwardedRef = ui.useForwardedRef(ref), rootRef = React.useRef(null), handleRootPointerDown = React.useCallback(
      (event) => {
        if (ui.isHTMLElement(event.target) && event.target.closest('[data-ui="Tag"]')) return;
        const inputElement = forwardedRef.current;
        inputElement && setTimeout(() => inputElement.focus(), 0);
      },
      [forwardedRef]
    ), handleInputBlur = React.useCallback(() => {
      setFocused(!1);
    }, []), handleInputChange = React.useCallback((event) => {
      setInputValue(event.currentTarget.value);
    }, []), handleInputFocus = React.useCallback(
      (event) => {
        setFocused(!0), onFocus && onFocus(event);
      },
      [onFocus]
    ), handleInputKeyDown = React.useCallback(
      (event) => {
        if (event.key === "Enter" && (event.preventDefault(), event.stopPropagation(), onChange && inputValue)) {
          const newValue = value.concat([{ value: inputValue }]);
          setInputValue(""), onChange && onChange(newValue);
        }
      },
      [inputValue, onChange, value]
    ), handleTagRemove = React.useCallback(
      (index) => {
        if (!onChange) return;
        const newValue = value.slice(0);
        newValue.splice(index, 1), onChange(newValue);
      },
      [onChange, value]
    );
    return React.useEffect(() => {
      const inputElement = forwardedRef.current;
      inputElement && (inputElement.style.width = "0", inputElement.style.width = `${inputElement.scrollWidth}px`);
    }, [forwardedRef, inputValue]), /* @__PURE__ */ jsxRuntime.jsxs(
      Root$e,
      {
        "data-disabled": disabled ? "" : void 0,
        "data-focused": focused ? "" : void 0,
        "data-read-only": readOnly ? "" : void 0,
        "data-ui": "TagInput",
        onPointerDown: handleRootPointerDown,
        overflow: "auto",
        padding: 1,
        ref: rootRef,
        children: [
          enabled && /* @__PURE__ */ jsxRuntime.jsx(Placeholder$1, { hidden: !!(inputValue || value.length), padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", children: placeholderProp || t2("inputs.tags.placeholder", {
            context: typeof window < "u" && "ontouchstart" in window ? "touch" : void 0
          }) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs("div", { className: "content", children: [
            value.map((tag, tagIndex) => (
              // eslint-disable-next-line react/no-array-index-key
              /* @__PURE__ */ jsxRuntime.jsx(TagBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
                Tag,
                {
                  enabled,
                  index: tagIndex,
                  muted: !enabled,
                  onRemove: handleTagRemove,
                  tag
                }
              ) }, `tag-${tagIndex}`)
            )),
            /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
              Input,
              {
                ...restProps,
                disabled: !enabled,
                onBlur: handleInputBlur,
                onChange: handleInputChange,
                onFocus: handleInputFocus,
                onKeyDown: handleInputKeyDown,
                ref: forwardedRef,
                type: "text",
                value: inputValue
              }
            ) }, "tag-input")
          ] })
        ]
      }
    );
  }
);
TagInput.displayName = "TagInput";
function Tag(props2) {
  const { enabled, index, muted, onRemove, tag } = props2, handleRemoveClick = React.useCallback(() => {
    onRemove(index);
  }, [index, onRemove]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { "data-ui": "Tag", radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, paddingY: 2, paddingLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted, textOverflow: "ellipsis", children: tag.value }) }),
    enabled && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.CloseIcon,
        mode: "bleed",
        onClick: handleRemoveClick,
        tooltipProps: { content: "Remove" }
      }
    )
  ] }) });
}
function TagsArrayInput(props2) {
  const { onChange, readOnly, value = [], elementProps, path, changed } = props2, tagInputValue = React.useMemo(() => value == null ? void 0 : value.map((v) => ({ value: v })), [value]), handleChange = React.useCallback(
    (nextValue) => {
      onChange(nextValue.length === 0 ? unset() : set(nextValue.map((v) => v.value)));
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !1, children: /* @__PURE__ */ jsxRuntime.jsx(
    TagInput,
    {
      onChange: handleChange,
      readOnly,
      value: tagInputValue,
      ...elementProps
    }
  ) });
}
const PRIMITIVES = ["string", "number", "boolean"];
function isArrayOfPrimitives$1(type) {
  return type.of.every((ofType) => PRIMITIVES.includes(ofType.jsonType));
}
function isStringArray(type) {
  return type.of.length === 1 && is$1("string", type.of[0]);
}
function isTagsArray(type) {
  var _a2;
  return ((_a2 = type.options) == null ? void 0 : _a2.layout) === "tags";
}
function isPortableText(type) {
  return type.of.some((memberType) => is$1("block", memberType));
}
function hasListOptions(type) {
  var _a2;
  return !!((_a2 = type.options) != null && _a2.list);
}
function resolveArrayInput(type) {
  return isStringArray(type) && isTagsArray(type) ? TagsArrayInput : hasListOptions(type) ? ArrayOfOptionsInput : isArrayOfPrimitives$1(type) ? ArrayOfPrimitivesInput : isPortableText(type) ? PortableTextInput : ArrayOfObjectsInput;
}
function toSelectItem$1(option) {
  return types.isTitledListValue(option) ? option : { title: capitalize__default.default(`${option}`), value: option };
}
const EMPTY_ITEM = { title: "", value: void 0 };
function SelectInput(props2) {
  var _a2, _b;
  const {
    value,
    readOnly,
    validationError,
    schemaType,
    onChange,
    path,
    changed,
    focused,
    elementProps
  } = props2, items = React.useMemo(
    () => {
      var _a22;
      return (((_a22 = schemaType.options) == null ? void 0 : _a22.list) || []).map(toSelectItem$1);
    },
    [(_a2 = schemaType.options) == null ? void 0 : _a2.list]
  ), currentItem = items.find((item) => item.value === value), isRadio = schemaType.options && schemaType.options.layout === "radio", itemFromOptionValue = React.useCallback(
    (optionValue) => {
      const index = Number(optionValue);
      return items[index];
    },
    [items]
  ), optionValueFromItem = React.useCallback(
    (item) => String(items.indexOf(item)),
    [items]
  ), inputId = React.useId(), handleChange = React.useCallback(
    (nextItem) => {
      onChange(
        PatchEvent.from(typeof (nextItem == null ? void 0 : nextItem.value) > "u" ? unset() : set(nextItem.value))
      );
    },
    [onChange]
  ), handleSelectChange = React.useCallback(
    (event) => {
      const nextItem = itemFromOptionValue(event.currentTarget.value);
      if (!nextItem) {
        handleChange(EMPTY_ITEM);
        return;
      }
      handleChange(nextItem);
    },
    [handleChange, itemFromOptionValue]
  ), content2 = isRadio ? /* @__PURE__ */ jsxRuntime.jsx(
    RadioSelect,
    {
      ...elementProps,
      value: currentItem,
      inputId,
      items,
      direction: ((_b = schemaType.options) == null ? void 0 : _b.direction) || "vertical",
      customValidity: validationError,
      onChange: handleChange,
      readOnly
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    ui.Select,
    {
      ...elementProps,
      customValidity: validationError,
      value: optionValueFromItem(currentItem),
      readOnly,
      onChange: handleSelectChange,
      children: [EMPTY_ITEM, ...items].map((item, i) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: i - 1, children: item.title }, `${i - 1}`))
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: content2 });
}
const RadioSelect = React.forwardRef(function(props2, ref) {
  const { items, value, onChange, onFocus, readOnly, customValidity, direction, inputId } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 3, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(direction === "horizontal" ? ui.Inline : ui.Stack, { space: 3, role: "group", children: items.map((item, index) => /* @__PURE__ */ jsxRuntime.jsx(
    RadioSelectItem,
    {
      customValidity,
      inputId,
      item,
      onChange,
      onFocus,
      readOnly,
      ref: index === 0 ? ref : null,
      value
    },
    index
  )) }) });
}), RadioSelectItem = React.forwardRef(function(props2, ref) {
  const { customValidity, inputId, item, onChange, onFocus, readOnly, value } = props2, handleChange = React.useCallback(() => {
    onChange(item);
  }, [item, onChange]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { as: "label", align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Radio,
      {
        ref,
        checked: value === item,
        onChange: handleChange,
        onFocus,
        readOnly,
        customValidity,
        name: inputId
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: item.title }) })
  ] });
});
function resolveNumberInput(type) {
  return getOption(type, "list") ? SelectInput : NumberInput;
}
function resolveStringInput(type) {
  return getOption(type, "list") ? SelectInput : StringInput;
}
function resolveComponentFromTypeVariants(type) {
  if (is$1("array", type))
    return resolveArrayInput(type);
  if (is$1("reference", type))
    return StudioReferenceInput;
  if (is$1("string", type))
    return resolveStringInput(type);
  if (is$1("number", type))
    return resolveNumberInput(type);
}
function defaultResolveInputComponent(schemaType) {
  var _a2;
  if ((_a2 = schemaType.components) != null && _a2.input) return schemaType.components.input;
  const componentFromTypeVariants = resolveComponentFromTypeVariants(schemaType);
  if (componentFromTypeVariants)
    return componentFromTypeVariants;
  const deduped = getTypeChain$1(schemaType, /* @__PURE__ */ new Set()).reduce(
    (acc, type) => (acc[type.name] = type, acc),
    {}
  ), subType = Object.values(deduped).find((t2) => defaultInputs[t2.name]);
  if (subType)
    return defaultInputs[subType.name];
  throw new Error(`Could not find input component for schema type \`${schemaType.name}\``);
}
function defaultResolvePreviewComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.preview ? schemaType.components.preview : SanityDefaultPreview;
}
function getTone$1({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$2 = { portal: !0, tone: "default" }, BUTTON_CARD_STYLE = { position: "relative" };
function PreviewItem(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const {
    schemaType,
    parentSchemaType,
    path,
    readOnly,
    onRemove,
    value,
    open,
    onInsert,
    onFocus,
    onOpen,
    onClose,
    changed,
    focused,
    children,
    inputProps: { renderPreview }
  } = props2, { t: t2 } = useTranslation(), sortable2 = ((_a2 = parentSchemaType.options) == null ? void 0 : _a2.sortable) !== !1, insertableTypes = parentSchemaType.of, previewCardRef = React.useRef(null);
  useScrollIntoViewOnFocusWithin(previewCardRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    !hadFocus && hasFocus && previewCardRef.current && ((_a22 = previewCardRef.current) == null || _a22.focus());
  });
  const resolvingInitialValue = value._resolvingInitialValue, handleDuplicate = React.useCallback(() => {
    onInsert({
      items: [{ ...value, _key: randomKey() }],
      position: "after"
    });
  }, [onInsert, value]), handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({
        items: [createProtoArrayValue(insertType)],
        position: pos
      });
    },
    [onInsert]
  ), childPresence = useChildPresence(path, !0), presence = React.useMemo(() => childPresence.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence: childPresence, maxAvatars: 1 }), [childPresence]), childValidation = useChildValidation(path, !0), validation2 = React.useMemo(() => childValidation.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: childValidation, __unstable_showSummary: !0 }) }), [childValidation]), hasErrors = childValidation.some((v) => v.level === "error"), hasWarnings = childValidation.some((v) => v.level === "warning"), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
        id: `${props2.inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("inputs.array.action.remove"),
              tone: "critical",
              icon: icons.TrashIcon,
              onClick: onRemove
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("inputs.array.action.duplicate"),
              icon: icons.CopyIcon,
              onClick: handleDuplicate
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { types: insertableTypes, onInsert: handleInsert })
        ] }),
        popover: MENU_POPOVER_PROPS$2
      }
    ),
    [handleDuplicate, handleInsert, onRemove, insertableTypes, props2.inputId, readOnly, t2]
  ), tone = getTone$1({ readOnly, hasErrors, hasWarnings }), item = /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      menu,
      presence,
      validation: validation2,
      tone,
      focused,
      dragHandle: sortable2,
      selected: open,
      readOnly: !!readOnly,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        ui.Card,
        {
          as: "button",
          type: "button",
          tone: "inherit",
          radius: 1,
          disabled: resolvingInitialValue,
          onClick: onOpen,
          ref: previewCardRef,
          onFocus,
          __unstable_focusRing: !0,
          style: BUTTON_CARD_STYLE,
          children: [
            renderPreview({
              schemaType: props2.schemaType,
              value: props2.value,
              layout: "default",
              // Don't do visibility check for virtualized items as the calculation will be incorrect causing it to scroll
              skipVisibilityCheck: !0
            }),
            resolvingInitialValue && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0 })
          ]
        }
      )
    }
  ), itemTypeTitle = getSchemaTypeTitle(schemaType);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: item }) }),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      EditPortal,
      {
        header: readOnly ? t2("inputs.array.action.view", { itemTypeTitle }) : t2("inputs.array.action.edit", { itemTypeTitle }),
        type: ((_c = (_b = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _b.modal) == null ? void 0 : _c.type) || "dialog",
        width: (_f = (_e = (_d = parentSchemaType == null ? void 0 : parentSchemaType.options) == null ? void 0 : _d.modal) == null ? void 0 : _e.width) != null ? _f : 1,
        id: value._key,
        onClose,
        autofocus: focused,
        legacy_referenceElement: previewCardRef.current,
        children
      }
    )
  ] });
}
function ReferenceItemRefProvider(props2) {
  const { menuRef, containerRef } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ReferenceItemRefContext.Provider, { value: { menuRef, containerRef }, children: props2.children });
}
function getTone({
  readOnly,
  hasErrors,
  hasWarnings
}) {
  return readOnly ? "transparent" : hasErrors ? "critical" : hasWarnings ? "caution" : "default";
}
const MENU_POPOVER_PROPS$1 = { portal: !0, tone: "default" };
function ReferenceItem(props2) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const {
    schemaType,
    parentSchemaType,
    path,
    readOnly,
    onRemove,
    value,
    open,
    onInsert,
    presence,
    validation: validation2,
    inputId,
    changed,
    focused,
    children,
    inputProps: { onChange, focusPath, onPathFocus, renderPreview, elementProps }
  } = props2, sortable2 = ((_a2 = parentSchemaType.options) == null ? void 0 : _a2.sortable) !== !1, insertableTypes = parentSchemaType.of, elementRef = React.useRef(null), menuRef = React.useRef(null), containerRef = React.useRef(null), { EditReferenceLink, getReferenceInfo: getReferenceInfo2, selectedState, isCurrentDocumentLiveEdit } = useReferenceInput({
    path,
    schemaType,
    value
  });
  useScrollIntoViewOnFocusWithin(elementRef, open), useDidUpdate(focused, (hadFocus, hasFocus) => {
    var _a22;
    !hadFocus && hasFocus && elementRef.current && ((_a22 = elementRef.current) == null || _a22.focus());
  });
  const hasErrors = props2.validation.some((v) => v.level === "error"), hasWarnings = props2.validation.some((v) => v.level === "warning"), resolvingInitialValue = value._resolvingInitialValue, handleDuplicate = React.useCallback(() => {
    onInsert({
      items: [{ ...value, _key: randomKey() }],
      position: "after"
    });
  }, [onInsert, value]), handleInsert = React.useCallback(
    (pos, insertType) => {
      onInsert({
        items: [{ ...createProtoArrayValue(insertType), _key: randomKey() }],
        position: pos
      });
    },
    [onInsert]
  ), loadableReferenceInfo = useReferenceInfo$1(value == null ? void 0 : value._ref, getReferenceInfo2), hasRef = value._ref, refTypeName = ((_b = loadableReferenceInfo.result) == null ? void 0 : _b.type) || ((_c = value == null ? void 0 : value._strengthenOnPublish) == null ? void 0 : _c.type), publishedReferenceExists = hasRef && ((_f = (_e = (_d = loadableReferenceInfo.result) == null ? void 0 : _d.preview) == null ? void 0 : _e.published) == null ? void 0 : _f._id), handleRemoveStrengthenOnPublish = React.useCallback(() => {
    onChange([
      schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]),
      unset(["_strengthenOnPublish"])
    ]);
  }, [onChange, schemaType.weak]), refType = refTypeName ? schemaType.to.find((toType) => toType.name === refTypeName) : void 0, pressed = selectedState === "pressed", selected = selectedState === "selected", tone = getTone({ readOnly, hasErrors, hasWarnings }), isEditing = !hasRef || focusPath[0] === "_ref", { t: t2 } = useTranslation(), OpenLink = React.useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      React.forwardRef(function(restProps, _ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(
          router.IntentLink,
          {
            ...restProps,
            intent: "edit",
            params: { id: value == null ? void 0 : value._ref, type: refType == null ? void 0 : refType.name },
            target: "_blank",
            rel: "noopener noreferrer",
            ref: _ref
          }
        );
      })
    ),
    [refType == null ? void 0 : refType.name, value == null ? void 0 : value._ref]
  ), handleReplace = React.useCallback(() => {
    onPathFocus(hasRef && isEditing ? [] : ["_ref"]);
  }, [hasRef, isEditing, onPathFocus]), menu = React.useMemo(
    () => readOnly ? null : /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
        id: `${inputId}-menuButton`,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { ref: menuRef, children: [
          !readOnly && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                text: t2("inputs.reference.action.remove"),
                tone: "critical",
                icon: icons.TrashIcon,
                onClick: onRemove
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                text: t2(
                  hasRef && isEditing ? "inputs.reference.action.replace-cancel" : "inputs.reference.action.replace"
                ),
                icon: hasRef && isEditing ? icons.CloseIcon : icons.SyncIcon,
                onClick: handleReplace
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                text: t2("inputs.reference.action.duplicate"),
                icon: icons.CopyIcon,
                onClick: handleDuplicate
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(InsertMenu$1, { onInsert: handleInsert, types: insertableTypes })
          ] }),
          !readOnly && !isEditing && hasRef && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          !isEditing && hasRef && /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              as: OpenLink,
              "data-as": "a",
              text: t2("inputs.reference.action.open-in-new-tab"),
              icon: icons.LaunchIcon
            }
          )
        ] }),
        popover: MENU_POPOVER_PROPS$1
      }
    ),
    [
      handleDuplicate,
      handleInsert,
      handleReplace,
      hasRef,
      inputId,
      insertableTypes,
      isEditing,
      onRemove,
      OpenLink,
      readOnly,
      t2
    ]
  ), handleFixStrengthMismatch = React.useCallback(() => {
    onChange(schemaType.weak === !0 ? set(!0, ["_weak"]) : unset(["_weak"]));
  }, [onChange, schemaType]), actualStrength = value != null && value._weak ? "weak" : "strong", weakShouldBe = schemaType.weak === !0 ? "weak" : "strong", weakWarningOverride = hasRef && !loadableReferenceInfo.isLoading && (value == null ? void 0 : value._strengthenOnPublish), showWeakRefMismatch = !loadableReferenceInfo.isLoading && ((_g = loadableReferenceInfo.result) == null ? void 0 : _g.availability.available) && hasRef && actualStrength !== weakShouldBe && !weakWarningOverride, issues = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    isCurrentDocumentLiveEdit && publishedReferenceExists && value._strengthenOnPublish && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceFinalizeAlertStrip,
      {
        schemaType,
        handleRemoveStrengthenOnPublish
      }
    ),
    showWeakRefMismatch && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceStrengthMismatchAlertStrip,
      {
        actualStrength,
        handleFixStrengthMismatch
      }
    ),
    loadableReferenceInfo.error && /* @__PURE__ */ jsxRuntime.jsx(
      ReferenceMetadataLoadErrorAlertStrip,
      {
        errorMessage: loadableReferenceInfo.error.message,
        onHandleRetry: loadableReferenceInfo.retry
      }
    )
  ] }), item = /* @__PURE__ */ jsxRuntime.jsx(ReferenceItemRefProvider, { menuRef, containerRef, children: /* @__PURE__ */ jsxRuntime.jsx(
    RowLayout,
    {
      dragHandle: sortable2,
      readOnly: !!readOnly,
      presence: !isEditing && presence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(FieldPresence, { presence, maxAvatars: 1 }),
      validation: !isEditing && validation2.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(FormFieldValidationStatus, { validation: validation2 }),
      menu,
      footer: isEditing ? void 0 : issues,
      tone: isEditing ? void 0 : tone,
      focused,
      children: isEditing ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, ref: containerRef, children: /* @__PURE__ */ jsxRuntime.jsx(
        FormFieldSet,
        {
          title: schemaType.title,
          description: schemaType.description,
          __unstable_presence: presence,
          validation: validation2,
          inputId,
          deprecated: schemaType.deprecated,
          children
        }
      ) }) : /* @__PURE__ */ jsxRuntime.jsxs(
        ReferenceLinkCard,
        {
          as: EditReferenceLink,
          tone: "inherit",
          radius: 2,
          documentId: value == null ? void 0 : value._ref,
          documentType: refType == null ? void 0 : refType.name,
          disabled: resolvingInitialValue,
          __unstable_focusRing: !0,
          selected,
          pressed,
          "data-selected": selected ? !0 : void 0,
          "data-pressed": pressed ? !0 : void 0,
          ...elementProps,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              PreviewReferenceValue$1,
              {
                value,
                referenceInfo: loadableReferenceInfo,
                renderPreview,
                type: schemaType
              }
            ),
            resolvingInitialValue && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0 })
          ]
        }
      )
    }
  ) });
  return /* @__PURE__ */ jsxRuntime.jsx(ChangeIndicator, { path, isChanged: changed, hasFocus: !!focused, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: item }) });
}
function defaultResolveItemComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.item ? schemaType.components.item : types.isReferenceSchemaType(schemaType) ? ReferenceItem : PreviewItem;
}
const defaultRenderAnnotation = (props2) => React.createElement(defaultResolveAnnotationComponent(props2.schemaType), props2), defaultRenderBlock = (props2) => React.createElement(defaultResolveBlockComponent(props2.schemaType), props2), defaultRenderInlineBlock = (props2) => React.createElement(defaultResolveInlineBlockComponent(props2.schemaType), props2), defaultRenderField = (props2) => React.createElement(defaultResolveFieldComponent(props2.schemaType), props2), defaultRenderInput = (props2) => React.createElement(defaultResolveInputComponent(props2.schemaType), props2), defaultRenderItem = (props2) => React.createElement(defaultResolveItemComponent(props2.schemaType), props2), defaultRenderPreview = (props2) => React.createElement(Preview$1, props2), INITIAL_STATE$4 = {
  isLoading: !0
}, PENDING_STATE = {
  isLoading: !1
};
function useDocumentPreview(props2) {
  const { enabled = !0, ordering, schemaType, value: previewValue } = props2 || {}, { observeForPreview } = useDocumentPreviewStore();
  return reactRx.useMemoObservable(
    () => !enabled || !previewValue || !schemaType ? rxjs.of(PENDING_STATE) : observeForPreview(previewValue, schemaType, { ordering }).pipe(
      operators.map((event) => ({ isLoading: !1, value: event.snapshot || void 0 })),
      operators.catchError((error) => rxjs.of({ isLoading: !1, error }))
    ),
    [enabled, observeForPreview, ordering, schemaType, previewValue],
    INITIAL_STATE$4
  );
}
const orientationChange$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(window, "orientationchange").pipe(operators.shareReplay(1)), resize$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(window, "resize").pipe(operators.shareReplay(1)), scroll$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(window, "scroll", { passive: !0, capture: !0 }).pipe(operators.shareReplay(1)), ROOT_MARGIN_PX = 150;
function isIntersectionObserverSupported() {
  return typeof window < "u" && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in IntersectionObserverEntry.prototype ? ("isIntersecting" in IntersectionObserverEntry.prototype || Object.defineProperty(IntersectionObserverEntry.prototype, "isIntersecting", {
    get() {
      return this.intersectionRatio > 0;
    }
  }), !0) : !1;
}
const intersectionObservableFor = isIntersectionObserverSupported() ? createIntersectionObserverBased() : createLegacyBased();
function createIntersectionObserverBased() {
  const intersectionObserverEntriesSubject = new rxjs.Subject(), intersectionObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        intersectionObserverEntriesSubject.next(entry);
      });
    },
    {
      threshold: 0,
      rootMargin: `${ROOT_MARGIN_PX}px`
    }
  );
  return function(element) {
    return new rxjs.Observable((observer) => (intersectionObserver.observe(element), observer.next(), () => intersectionObserver.unobserve(element))).pipe(
      operators.mergeMap(() => intersectionObserverEntriesSubject.asObservable()),
      operators.filter((entry) => entry.target === element),
      operators.map((ev) => ({
        isIntersecting: ev.isIntersecting
      }))
    );
  };
}
function createLegacyBased() {
  function getViewport() {
    return {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: window.innerHeight
    };
  }
  function intersects(rect, viewport, margin) {
    return rect.left <= viewport.right + margin && rect.right >= viewport.left - margin && rect.top <= viewport.bottom + margin && rect.bottom >= viewport.top - margin;
  }
  function inViewport(element) {
    return () => intersects(element.getBoundingClientRect(), getViewport(), ROOT_MARGIN_PX);
  }
  return function(element) {
    const isElementInViewport = inViewport(element);
    return rxjs.merge(rxjs.of(isElementInViewport()), resize$, scroll$, orientationChange$).pipe(
      // @todo: consider "faking" more of the IntersectionObserverEntry api if possible
      operators.map(isElementInViewport),
      operators.map((isIntersecting) => ({ isIntersecting }))
    );
  };
}
const visibilityChange$ = typeof window > "u" ? rxjs.EMPTY : rxjs.fromEvent(document, "visibilitychange").pipe(operators.shareReplay(1));
function useVisibility(props2) {
  const { element, hideDelay = 0 } = props2, [visible, setVisible] = React.useState(!1);
  return React.useEffect(() => {
    if (!element)
      return;
    const isDocumentVisible$ = rxjs.concat(
      rxjs.of(!document.hidden),
      visibilityChange$.pipe(
        operators.map((event) => {
          var _a2;
          return event.target instanceof Document ? !((_a2 = event == null ? void 0 : event.target) != null && _a2.hidden) : !1;
        })
      )
    ).pipe(operators.distinctUntilChanged()), inViewport$ = intersectionObservableFor(element).pipe(
      operators.map((event) => event.isIntersecting)
    ), sub = isDocumentVisible$.pipe(
      operators.switchMap((isDocumentVisible) => isDocumentVisible ? inViewport$ : rxjs.of(!1)),
      operators.switchMap((isVisible2) => isVisible2 ? rxjs.of(!0) : rxjs.of(!1).pipe(operators.delay(hideDelay))),
      operators.distinctUntilChanged()
    ).subscribe(setVisible);
    return () => sub.unsubscribe();
  }, [element, hideDelay]), visible;
}
const _HIDE_DELAY = 2e3;
function _extractUploadState(value) {
  return _resolveUploadValue(value == null ? void 0 : value._upload);
}
function getStringOrUndefined(value) {
  return isString(value) ? value : void 0;
}
function _resolveUploadValue(value) {
  var _a2, _b;
  if (!isRecord$4(value)) return;
  const progress = typeof value.progress == "number" ? value.progress : 0, createdAt = getStringOrUndefined(value.initiated || value.createdAt), updatedAt = getStringOrUndefined(value.updated || value.updatedAt), fileName = getStringOrUndefined((_a2 = value == null ? void 0 : value.file) == null ? void 0 : _a2.name), fileType = getStringOrUndefined((_b = value == null ? void 0 : value.file) == null ? void 0 : _b.type), previewImage = getStringOrUndefined(value.previewImage);
  if (createdAt && updatedAt && fileName && fileType)
    return {
      progress,
      createdAt,
      updatedAt,
      file: { name: fileName, type: fileType },
      previewImage
    };
}
function PreviewLoader(props2) {
  const {
    layout,
    value,
    component,
    style: styleProp,
    schemaType,
    skipVisibilityCheck,
    ...restProps
  } = props2, { t: t2 } = useTranslation(), [element, setElement] = React.useState(null), isVisible2 = useVisibility({
    element: skipVisibilityCheck ? null : element,
    hideDelay: _HIDE_DELAY
  }), preview = useDocumentPreview({
    enabled: skipVisibilityCheck || isVisible2,
    schemaType,
    value
  }), style = React.useMemo(
    () => ({
      ...styleProp,
      minWidth: (styleProp == null ? void 0 : styleProp.minWidth) || 1,
      minHeight: (styleProp == null ? void 0 : styleProp.minHeight) || 1
    }),
    [styleProp]
  ), uploadState = React.useMemo(() => _extractUploadState(value), [value]), media = React.useMemo(() => {
    var _a2, _b;
    return uploadState != null && uploadState.previewImage ? /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        alt: t2("preview.image.file-is-being-uploaded.alt-text"),
        src: uploadState.previewImage
      }
    ) : (_a2 = preview == null ? void 0 : preview.value) != null && _a2.media ? (_b = preview == null ? void 0 : preview.value) == null ? void 0 : _b.media : schemaType.icon;
  }, [preview, schemaType, uploadState, t2]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", { ref: setElement, style, children: React.createElement(component, {
    ...restProps,
    ...(preview == null ? void 0 : preview.value) || {},
    media,
    error: preview == null ? void 0 : preview.error,
    isPlaceholder: preview == null ? void 0 : preview.isLoading,
    layout,
    schemaType
  }) });
}
function DefaultCustomMarkers() {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
    "This is a example custom marker, please implement ",
    /* @__PURE__ */ jsxRuntime.jsx("code", { children: "renderCustomMarkers" }),
    " function."
  ] });
}
const missingPatchChannel = {
  publish: () => {
  },
  subscribe: () => (console.warn(
    "No patch channel provided to form-builder. If you need input based patch updates, please provide one"
  ), () => {
  })
};
function FormBuilderProvider(props2) {
  const {
    __internal_fieldActions: fieldActions = EMPTY_ARRAY$t,
    __internal_patchChannel: patchChannel = missingPatchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    file,
    filterField,
    focusPath,
    focused,
    groups,
    id: id2,
    image,
    onChange,
    onFieldGroupSelect,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    schemaType,
    unstable,
    validation: validation2
  } = props2, __internal = React.useMemo(
    () => ({
      patchChannel,
      // eslint-disable-line camelcase
      components: {
        ArrayFunctions: ArrayOfObjectsFunctions,
        CustomMarkers: (unstable == null ? void 0 : unstable.CustomMarkers) || DefaultCustomMarkers,
        Markers: (unstable == null ? void 0 : unstable.Markers) || DefaultMarkers
      },
      field: {
        actions: fieldActions
      },
      file: {
        assetSources: file.assetSources,
        directUploads: (file == null ? void 0 : file.directUploads) !== !1
      },
      filterField: filterField || (() => !0),
      image: {
        assetSources: image.assetSources,
        directUploads: (image == null ? void 0 : image.directUploads) !== !1
      },
      onChange
    }),
    [
      fieldActions,
      file.assetSources,
      file == null ? void 0 : file.directUploads,
      filterField,
      image.assetSources,
      image == null ? void 0 : image.directUploads,
      onChange,
      patchChannel,
      unstable == null ? void 0 : unstable.CustomMarkers,
      unstable == null ? void 0 : unstable.Markers
    ]
  ), formBuilder = React.useMemo(
    () => ({
      __internal,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id: id2,
      readOnly,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview,
      schemaType
    }),
    [
      __internal,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id2,
      readOnly,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview,
      schemaType
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.FormBuilderContext.Provider, { value: formBuilder, children: /* @__PURE__ */ jsxRuntime.jsx(
    FormCallbacksProvider,
    {
      onChange,
      onFieldGroupSelect,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      children: /* @__PURE__ */ jsxRuntime.jsx(DocumentIdProvider, { id: id2, children: /* @__PURE__ */ jsxRuntime.jsx(PresenceProvider, { presence, children: /* @__PURE__ */ jsxRuntime.jsx(ValidationProvider, { validation: validation2, children: /* @__PURE__ */ jsxRuntime.jsx(HoveredFieldProvider, { children }) }) }) })
    }
  ) });
}
function FormProvider(props2) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    children,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id: id2,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    presence,
    readOnly,
    schemaType,
    validation: validation2
  } = props2, { file, image } = useSource().form, Input2 = useInputComponent(), Field = useFieldComponent(), Preview2 = usePreviewComponent(), Item2 = useItemComponent(), Block2 = useBlockComponent(), InlineBlock = useInlineBlockComponent(), Annotation2 = useAnnotationComponent(), renderInput = React.useCallback(
    (inputProps) => /* @__PURE__ */ jsxRuntime.jsx(Input2, { ...inputProps }),
    [Input2]
  ), renderField = React.useCallback(
    (fieldProps) => /* @__PURE__ */ jsxRuntime.jsx(Field, { ...fieldProps }),
    [Field]
  ), renderItem2 = React.useCallback(
    (itemProps) => /* @__PURE__ */ jsxRuntime.jsx(Item2, { ...itemProps }),
    [Item2]
  ), renderPreview = React.useCallback(
    (previewProps) => /* @__PURE__ */ jsxRuntime.jsx(PreviewLoader, { component: Preview2, ...previewProps }),
    [Preview2]
  ), renderBlock2 = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(Block2, { ...blockProps }),
    [Block2]
  ), renderInlineBlock = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(InlineBlock, { ...blockProps }),
    [InlineBlock]
  ), renderAnnotation = React.useCallback(
    (annotationProps) => /* @__PURE__ */ jsxRuntime.jsx(Annotation2, { ...annotationProps }),
    [Annotation2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormBuilderProvider,
    {
      __internal_fieldActions: fieldActions,
      __internal_patchChannel: patchChannel,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      file,
      focusPath,
      focused,
      groups,
      id: id2,
      image,
      onChange,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onFieldGroupSelect,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      presence,
      readOnly,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview,
      schemaType,
      validation: validation2,
      children
    }
  );
}
function FormBuilder(props2) {
  const {
    __internal_fieldActions: fieldActions,
    __internal_patchChannel: patchChannel,
    autoFocus,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    focused,
    groups,
    id: id2,
    members,
    onChange,
    onPathBlur,
    onPathFocus,
    onPathOpen,
    onFieldGroupSelect,
    onSetFieldSetCollapsed,
    onSetPathCollapsed,
    presence,
    readOnly,
    schemaType,
    validation: validation2,
    value
  } = props2, handleCollapseField = React.useCallback(
    (fieldName) => onSetPathCollapsed([fieldName], !0),
    [onSetPathCollapsed]
  ), handleExpandField = React.useCallback(
    (fieldName) => onSetPathCollapsed([fieldName], !1),
    [onSetPathCollapsed]
  ), handleBlur = React.useCallback(() => onPathBlur(EMPTY_ARRAY$t), [onPathBlur]), handleFocus = React.useCallback(() => onPathFocus(EMPTY_ARRAY$t), [onPathFocus]), handleChange = React.useCallback(
    (patch2) => onChange(PatchEvent.from(patch2)),
    [onChange]
  ), focusRef = React.useRef(null), handleSelectFieldGroup = React.useCallback(
    (groupName) => onFieldGroupSelect(EMPTY_ARRAY$t, groupName),
    [onFieldGroupSelect]
  ), handleOpenField = React.useCallback((fieldName) => onPathOpen([fieldName]), [onPathOpen]), handleCloseField = React.useCallback(() => onPathOpen([]), [onPathOpen]), handleCollapseFieldSet = React.useCallback(
    (fieldSetName) => onSetFieldSetCollapsed([fieldSetName], !0),
    [onSetFieldSetCollapsed]
  ), handleExpandFieldSet = React.useCallback(
    (fieldSetName) => onSetFieldSetCollapsed([fieldSetName], !1),
    [onSetFieldSetCollapsed]
  ), Input2 = useInputComponent(), Field = useFieldComponent(), Preview2 = usePreviewComponent(), Item2 = useItemComponent(), Block2 = useBlockComponent(), InlineBlock = useInlineBlockComponent(), Annotation2 = useAnnotationComponent(), renderInput = React.useCallback(
    (inputProps) => /* @__PURE__ */ jsxRuntime.jsx(Input2, { ...inputProps }),
    [Input2]
  ), renderField = React.useCallback(
    (fieldProps) => /* @__PURE__ */ jsxRuntime.jsx(Field, { ...fieldProps }),
    [Field]
  ), renderItem2 = React.useCallback(
    (itemProps) => /* @__PURE__ */ jsxRuntime.jsx(Item2, { ...itemProps }),
    [Item2]
  ), renderPreview = React.useCallback(
    (previewProps) => /* @__PURE__ */ jsxRuntime.jsx(PreviewLoader, { component: Preview2, ...previewProps }),
    [Preview2]
  ), renderBlock2 = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(Block2, { ...blockProps }),
    [Block2]
  ), renderInlineBlock = React.useCallback(
    (blockProps) => /* @__PURE__ */ jsxRuntime.jsx(InlineBlock, { ...blockProps }),
    [InlineBlock]
  ), renderAnnotation = React.useCallback(
    (annotationProps) => /* @__PURE__ */ jsxRuntime.jsx(Annotation2, { ...annotationProps }),
    [Annotation2]
  ), rootInputProps = {
    focusPath,
    elementProps: {
      ref: focusRef,
      id: id2,
      onBlur: handleBlur,
      onFocus: handleFocus,
      "aria-describedby": void 0
      // Root input should not have any aria-describedby
    },
    changed: members.some((m) => m.kind === "field" && m.field.changed),
    focused,
    groups,
    id: id2,
    level: 0,
    members,
    onChange: handleChange,
    onFieldClose: handleCloseField,
    onFieldCollapse: handleCollapseField,
    onFieldSetCollapse: handleCollapseFieldSet,
    onFieldExpand: handleExpandField,
    onFieldSetExpand: handleExpandFieldSet,
    onPathFocus,
    onFieldOpen: handleOpenField,
    onFieldGroupSelect: handleSelectFieldGroup,
    path: EMPTY_ARRAY$t,
    presence: EMPTY_ARRAY$t,
    readOnly,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    schemaType,
    validation: EMPTY_ARRAY$t,
    value
  };
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormProvider,
    {
      __internal_fieldActions: fieldActions,
      __internal_patchChannel: patchChannel,
      autoFocus,
      changesOpen,
      collapsedFieldSets,
      collapsedPaths,
      focusPath,
      focused,
      groups,
      id: id2,
      onChange,
      onPathBlur,
      onPathFocus,
      onPathOpen,
      onFieldGroupSelect,
      onSetPathCollapsed,
      onSetFieldSetCollapsed,
      presence,
      validation: validation2,
      readOnly,
      schemaType,
      children: /* @__PURE__ */ jsxRuntime.jsx(GetFormValueProvider, { value, children: /* @__PURE__ */ jsxRuntime.jsx(FormValueProvider, { value, children: /* @__PURE__ */ jsxRuntime.jsx(DocumentFieldActionsProvider, { actions: fieldActions, children: renderInput(rootInputProps) }) }) })
    }
  );
}
const Root$d = styledComponents.styled(ui.Card)((props2) => {
  const { color: color$1, radius, space } = props2.theme.sanity, overlay = styledComponents.css`
    pointer-events: none;
    content: '';
    position: absolute;
    top: -${space[1]}px;
    bottom: -${space[1]}px;
    left: -${space[1]}px;
    right: -${space[1]}px;
    border-radius: ${radius[2]}px;
    mix-blend-mode: ${color$1.dark ? "screen" : "multiply"};
  `;
  return styledComponents.css`
    box-shadow: 0 0 0 1px var(--card-border-color);
    border-radius: ${radius[1]}px;
    pointer-events: all;
    position: relative;

    &[data-focused] {
      --card-border-color: var(--card-focus-ring-color);
    }

    &:not([data-focused]):not([data-selected]) {
      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.default.hovered.border};
        }
      }
    }

    &[data-markers] {
      &:after {
        ${overlay}
        background-color: ${color$1.dark ? color.hues.purple[950].hex : color.hues.purple[50].hex};
      }
    }

    &[data-warning] {
      &:after {
        ${overlay}
        background-color: ${color$1.muted.caution.hovered.bg};
      }

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.muted.caution.hovered.border};
        }
      }
    }

    &[data-invalid] {
      &:after {
        ${overlay}
        background-color: ${color$1.input.invalid.enabled.bg};
      }

      @media (hover: hover) {
        &:hover {
          --card-border-color: ${color$1.input.invalid.hovered.border};
        }
      }
    }
  `;
}), PreviewContainer = styledComponents.styled(ui.Box)`
  display: block;
  width: 100%;
  user-select: none;
  pointer-events: all;
`, ChangeIndicatorWrapper = styledComponents.styled.div(
  ({ theme: theme2, $hasChanges }) => {
    const { space } = theme2.sanity;
    return styledComponents.css`
      position: absolute;
      width: ${space[2]}px;
      right: 0;
      top: 0;
      bottom: 0;
      padding-left: ${space[1]}px;
      user-select: none;

      ${!$hasChanges && styledComponents.css`
        display: none;
      `}

      [data-dragged] & {
        visibility: hidden;
      }
    `;
  }
), InnerFlex$1 = styledComponents.styled(ui.Flex)`
  position: relative;

  [data-dragged] > & {
    opacity: 0.5;
  }
`, BlockActionsOuter = styledComponents.styled(ui.Box)`
  width: 25px;
  position: relative;

  [data-dragged] & {
    visibility: hidden;
  }
`, BlockActionsInner = styledComponents.styled(ui.Flex)`
  position: absolute;
  right: 0;
  [data-dragged] & {
    visibility: hidden;
  }
`, TooltipBox = styledComponents.styled(ui.Box)`
  max-width: 250px;
`, POPOVER_PROPS$4 = {
  constrainSize: !0,
  placement: "bottom",
  portal: "default",
  tone: "default"
};
function BlockObjectActionsMenu(props2) {
  const { children, focused, isOpen, onOpen, onRemove, readOnly, value } = props2, { t: t2 } = useTranslation(), menuButtonId = React.useId(), menuButton = React.useRef(null), isTabbing = React.useRef(!1), referenceLink = React.useMemo(
    () => types.isReference(value) ? React.forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsxRuntime.jsx(router.IntentLink, { ...linkProps, intent: "edit", params: { id: value._ref }, ref });
    }) : void 0,
    [value]
  );
  React.useEffect(() => {
    isOpen && (isTabbing.current = !1);
  }, [isOpen]), ui.useGlobalKeyDown(
    React.useCallback(
      (event) => {
        focused && event.key === "Tab" && menuButton.current && !isTabbing.current && !isOpen && (event.preventDefault(), event.stopPropagation(), menuButton.current.focus(), isTabbing.current = !0);
      },
      [focused, isOpen]
    )
  );
  const handleDelete = React.useCallback(
    (event) => {
      event.preventDefault(), event.stopPropagation(), onRemove();
    },
    [onRemove]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        button: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            "aria-label": t2("inputs.portable-text.block.open-menu-aria-label"),
            icon: icons.EllipsisHorizontalIcon,
            mode: "bleed",
            paddingY: 3,
            tabIndex: focused ? 0 : 1,
            tooltipProps: { content: "Open menu" }
          }
        ),
        ref: menuButton,
        id: menuButtonId,
        menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          "_ref" in value && value._ref && /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              as: referenceLink,
              "data-as": "a",
              icon: icons.LinkIcon,
              text: t2("inputs.portable-text.block.open-reference")
            }
          ),
          readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              icon: icons.EyeOpenIcon,
              onClick: onOpen,
              text: t2("inputs.portable-text.block.view")
            }
          ),
          !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              icon: icons.EditIcon,
              onClick: onOpen,
              text: t2("inputs.portable-text.block.edit")
            }
          ),
          !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              icon: icons.TrashIcon,
              onClick: handleDelete,
              text: t2("inputs.portable-text.block.remove"),
              tone: "critical"
            }
          )
        ] }) }),
        popover: POPOVER_PROPS$4
      }
    ) })
  ] });
}
function BlockObject(props2) {
  var _a2;
  const {
    floatingBoundary,
    focused,
    isFullscreen,
    onItemClose,
    onItemOpen,
    onPathFocus,
    path,
    readOnly,
    referenceBoundary,
    relativePath,
    renderAnnotation,
    renderBlock: renderBlock2,
    renderBlockActions,
    renderCustomMarkers,
    renderField,
    renderInlineBlock,
    renderInput,
    renderItem: renderItem2,
    renderPreview,
    schemaType,
    selected,
    value
  } = props2, { onChange } = useFormCallbacks(), { Markers } = useFormBuilder().__internal.components, [reviewChangesHovered, setReviewChangesHovered] = React.useState(!1), markers = usePortableTextMarkers(path), editor2 = portableTextEditor.usePortableTextEditor(), memberItem = usePortableTextMemberItem(pathToString$1(path)), isDeleting = React.useRef(!1), selfSelection = React.useMemo(
    () => ({
      anchor: { path: relativePath, offset: 0 },
      focus: { path: relativePath, offset: 0 }
    }),
    [relativePath]
  ), handleMouseOver = React.useCallback(() => setReviewChangesHovered(!0), []), handleMouseOut = React.useCallback(() => setReviewChangesHovered(!1), []), onOpen = React.useCallback(() => {
    memberItem && (portableTextEditor.PortableTextEditor.blur(editor2), onItemOpen(memberItem.node.path));
  }, [editor2, memberItem, onItemOpen]), onClose = React.useCallback(() => {
    onItemClose(), portableTextEditor.PortableTextEditor.select(editor2, selfSelection), portableTextEditor.PortableTextEditor.focus(editor2);
  }, [onItemClose, editor2, selfSelection]), onRemove = React.useCallback(() => {
    if (!isDeleting.current)
      try {
        portableTextEditor.PortableTextEditor.delete(editor2, selfSelection, { mode: "blocks" });
      } catch (err) {
        console.error(err);
      } finally {
        isDeleting.current = !0;
      }
  }, [editor2, selfSelection]);
  React.useEffect(
    () => () => {
      isDeleting.current && portableTextEditor.PortableTextEditor.focus(editor2);
    },
    [editor2]
  );
  const innerPaddingProps = React.useMemo(() => isFullscreen && !renderBlockActions ? { paddingX: 5 } : isFullscreen && renderBlockActions ? { paddingLeft: 5, paddingRight: 2 } : renderBlockActions ? {
    paddingLeft: 3,
    paddingRight: 2
  } : { paddingX: 3 }, [isFullscreen, renderBlockActions]), { validation: validation2, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem == null ? void 0 : memberItem.node), parentSchemaType = editor2.schemaTypes.portableText, hasMarkers = markers.length > 0, presence = useChildPresence(path, !0), rootPresence = React.useMemo(
    () => presence.filter((p) => PathUtils.isEqual(p.path, path)),
    [path, presence]
  ), tooltipEnabled = hasError || hasWarning || hasInfo || hasMarkers, toolTipContent = React.useMemo(
    () => tooltipEnabled && /* @__PURE__ */ jsxRuntime.jsx(TooltipBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Markers,
      {
        markers,
        validation: validation2,
        renderCustomMarkers
      }
    ) }) || null,
    [Markers, markers, renderCustomMarkers, tooltipEnabled, validation2]
  ), isOpen = !!(memberItem != null && memberItem.member.open), input = memberItem == null ? void 0 : memberItem.input, nodePath = (memberItem == null ? void 0 : memberItem.node.path) || EMPTY_ARRAY$t, referenceElement = (_a2 = memberItem == null ? void 0 : memberItem.elementRef) == null ? void 0 : _a2.current, componentProps = React.useMemo(
    () => ({
      __unstable_floatingBoundary: floatingBoundary,
      __unstable_referenceBoundary: referenceBoundary,
      __unstable_referenceElement: referenceElement || null,
      children: input,
      focused,
      markers,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      open: isOpen,
      parentSchemaType,
      path: nodePath,
      presence: rootPresence,
      readOnly: !!readOnly,
      renderAnnotation,
      renderBlock: renderBlock2,
      renderDefault: DefaultBlockObjectComponent,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem: renderItem2,
      renderPreview,
      schemaType,
      selected,
      validation: validation2,
      value
    }),
    [
      floatingBoundary,
      referenceElement,
      input,
      focused,
      markers,
      onClose,
      onOpen,
      onPathFocus,
      onRemove,
      isOpen,
      parentSchemaType,
      nodePath,
      rootPresence,
      readOnly,
      referenceBoundary,
      renderAnnotation,
      renderBlock2,
      renderField,
      renderInlineBlock,
      renderInput,
      renderItem2,
      renderPreview,
      schemaType,
      selected,
      validation2,
      value
    ]
  );
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(
      ui.Box,
      {
        ref: memberItem == null ? void 0 : memberItem.elementRef,
        contentEditable: !1,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          ui.Flex,
          {
            "data-object-block": "",
            paddingBottom: 1,
            marginY: 3,
            style: void 0,
            children: /* @__PURE__ */ jsxRuntime.jsxs(InnerFlex$1, { flex: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(
                TooltipDelayGroupProvider.Tooltip,
                {
                  placement: "top",
                  portal: "editor",
                  disabled: isOpen ? !0 : !tooltipEnabled,
                  content: toolTipContent,
                  children: /* @__PURE__ */ jsxRuntime.jsx(
                    PreviewContainer,
                    {
                      "data-object-block-inner": "",
                      ...innerPaddingProps,
                      children: renderBlock2 && renderBlock2(componentProps)
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsx(BlockActionsOuter, { marginRight: 1, children: /* @__PURE__ */ jsxRuntime.jsx(BlockActionsInner, { children: renderBlockActions && value && focused && !readOnly && /* @__PURE__ */ jsxRuntime.jsx(
                BlockActions,
                {
                  block: value,
                  onChange,
                  renderBlockActions
                }
              ) }) }),
              isFullscreen && memberItem && /* @__PURE__ */ jsxRuntime.jsx(
                ChangeIndicatorWrapper,
                {
                  $hasChanges: memberItem.member.item.changed,
                  onMouseOut: handleMouseOut,
                  onMouseOver: handleMouseOver,
                  children: /* @__PURE__ */ jsxRuntime.jsx(
                    StyledChangeIndicatorWithProvidedFullPath,
                    {
                      hasFocus: focused,
                      isChanged: memberItem.member.item.changed,
                      path: memberItem.member.item.path,
                      withHoverEffect: !1
                    }
                  )
                }
              ),
              reviewChangesHovered && /* @__PURE__ */ jsxRuntime.jsx(ReviewChangesHighlightBlock, {})
            ] })
          }
        )
      }
    ),
    [
      componentProps,
      focused,
      handleMouseOut,
      handleMouseOver,
      innerPaddingProps,
      isFullscreen,
      memberItem,
      onChange,
      readOnly,
      renderBlock2,
      renderBlockActions,
      reviewChangesHovered,
      toolTipContent,
      tooltipEnabled,
      value,
      isOpen
    ]
  );
}
const DefaultBlockObjectComponent = (props2) => {
  const {
    __unstable_floatingBoundary,
    __unstable_referenceBoundary,
    __unstable_referenceElement,
    children,
    focused,
    markers,
    onClose,
    onOpen,
    onRemove,
    open,
    readOnly,
    renderPreview,
    schemaType,
    selected,
    value,
    validation: validation2
  } = props2, { t: t2 } = useTranslation(), isImagePreview = types.isImage(value), hasError = validation2.filter((v) => v.level === "error").length > 0, hasWarning = validation2.filter((v) => v.level === "warning").length > 0, hasMarkers = markers.length > 0, tone = selected || focused ? "primary" : "default", handleDoubleClickToOpen = React.useCallback(
    (e) => {
      e.preventDefault(), e.stopPropagation(), onOpen();
    },
    [onOpen]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Root$d,
      {
        "aria-label": t2("inputs.portable-text.block.aria-label"),
        "data-focused": focused ? "" : void 0,
        "data-image-preview": isImagePreview ? "" : void 0,
        "data-invalid": hasError ? "" : void 0,
        "data-markers": hasMarkers ? "" : void 0,
        "data-read-only": readOnly ? "" : void 0,
        "data-selected": selected ? "" : void 0,
        "data-testid": "pte-block-object",
        "data-warning": hasWarning ? "" : void 0,
        flex: 1,
        onDoubleClick: handleDoubleClickToOpen,
        padding: isImagePreview ? 0 : 1,
        tone,
        children: renderPreview({
          actions: /* @__PURE__ */ jsxRuntime.jsx(
            BlockObjectActionsMenu,
            {
              isOpen: open,
              focused,
              onOpen,
              onRemove,
              readOnly,
              value
            }
          ),
          layout: isImagePreview ? "blockImage" : "block",
          schemaType,
          skipVisibilityCheck: !0,
          value
        })
      }
    ),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      ObjectEditModal,
      {
        floatingBoundary: __unstable_floatingBoundary,
        defaultType: "dialog",
        onClose,
        autoFocus: focused,
        schemaType,
        referenceBoundary: __unstable_referenceBoundary,
        referenceElement: __unstable_referenceElement,
        children
      }
    )
  ] });
};
function defaultResolveBlockComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.block ? schemaType.components.block : isBlockType(schemaType) ? DefaultComponent$1 : DefaultBlockObjectComponent;
}
function defaultResolveInlineBlockComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.inlineBlock ? schemaType.components.inlineBlock : DefaultInlineObjectComponent;
}
function defaultResolveAnnotationComponent(schemaType) {
  var _a2;
  return (_a2 = schemaType.components) != null && _a2.annotation ? schemaType.components.annotation : DefaultAnnotationComponent;
}
function useResolveDefaultComponent(props2) {
  const { componentResolver, componentProps } = props2;
  if (!componentProps.schemaType)
    throw new Error("the `schemaType` property must be defined");
  const defaultResolvedComponent = componentResolver(componentProps.schemaType), renderDefault = React.useCallback(
    (parentTypeProps) => {
      var _a2;
      if (!((_a2 = parentTypeProps.schemaType) != null && _a2.type))
        throw new Error("Attempted to render form component of non-existent parent type");
      const { components: components2, ...restSchemaType } = parentTypeProps.schemaType, parentTypeResolvedComponent = componentResolver(restSchemaType);
      return React.createElement(parentTypeResolvedComponent, parentTypeProps);
    },
    [componentResolver]
  );
  return React.createElement(defaultResolvedComponent, {
    ...componentProps,
    renderDefault
  });
}
function DefaultInput(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveInputComponent
  });
}
function DefaultField(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveFieldComponent
  });
}
function DefaultItem(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveItemComponent
  });
}
function DefaultPreview$1(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolvePreviewComponent
  });
}
function DefaultBlock(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveBlockComponent
  });
}
function DefaultInlineBlock(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveInlineBlockComponent
  });
}
function DefaultAnnotation(props2) {
  return useResolveDefaultComponent({
    componentProps: props2,
    componentResolver: defaultResolveAnnotationComponent
  });
}
function pickInputComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.input;
}
function pickFieldComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.field;
}
function pickPreviewComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.preview;
}
function pickItemComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.item;
}
function pickBlockComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.block;
}
function pickInlineBlockComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.inlineBlock;
}
function pickAnnotationComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.form) == null ? void 0 : _a2.components) == null ? void 0 : _b.annotation;
}
function useInputComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultInput,
    pick: pickInputComponent
  });
}
function useFieldComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultField,
    pick: pickFieldComponent
  });
}
function usePreviewComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultPreview$1,
    pick: pickPreviewComponent
  });
}
function useItemComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultItem,
    pick: pickItemComponent
  });
}
function useBlockComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultBlock,
    pick: pickBlockComponent
  });
}
function useInlineBlockComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultInlineBlock,
    pick: pickInlineBlockComponent
  });
}
function useAnnotationComponent() {
  return useMiddlewareComponents({
    defaultComponent: DefaultAnnotation,
    pick: pickAnnotationComponent
  });
}
function Preview$1(props2) {
  const PreviewComponent = usePreviewComponent();
  return /* @__PURE__ */ jsxRuntime.jsx(PreviewLoader, { ...props2, component: PreviewComponent });
}
const _previewComponents = {
  block: BlockPreview,
  blockImage: BlockImagePreview,
  compact: CompactPreview,
  default: DefaultPreview,
  detail: DetailPreview,
  inline: InlinePreview,
  media: MediaPreview
};
function FallbackIcon() {
  return /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, { className: "sanity-studio__preview-fallback-icon" });
}
function SanityDefaultPreview(props2) {
  const { icon, layout, media: mediaProp, imageUrl, title, tooltip, ...restProps } = props2, client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), imageBuilder = React.useMemo(() => imageUrlBuilder__default.default(client2), [client2]), renderMedia2 = React.useCallback(
    (options) => {
      const { dimensions } = options;
      return /* @__PURE__ */ jsxRuntime.jsx(
        "img",
        {
          alt: isString(title) ? title : void 0,
          referrerPolicy: "strict-origin-when-cross-origin",
          src: imageBuilder.image(
            mediaProp
          ).width(dimensions.width || 100).height(dimensions.height || 100).fit(dimensions.fit).dpr(dimensions.dpr || 1).url() || ""
        }
      );
    },
    [imageBuilder, mediaProp, title]
  ), renderIcon = React.useCallback(() => React.createElement(icon || FallbackIcon), [icon]), media = React.useMemo(() => icon === !1 ? !1 : reactIs.isValidElementType(mediaProp) || React.isValidElement(mediaProp) ? mediaProp : assetUtils.isImageSource(mediaProp) ? renderMedia2 : isString(imageUrl) ? /* @__PURE__ */ jsxRuntime.jsx(
    "img",
    {
      src: imageUrl,
      alt: isString(title) ? title : void 0,
      referrerPolicy: "strict-origin-when-cross-origin"
    }
  ) : renderIcon, [icon, imageUrl, mediaProp, renderIcon, renderMedia2, title]), previewProps = React.useMemo(
    () => ({
      ...restProps,
      // @todo: fix `TS2769: No overload matches this call.`
      media,
      title
    }),
    [media, restProps, title]
  ), layoutComponent = _previewComponents[layout || "default"], children = React.createElement(
    layoutComponent,
    previewProps
  );
  return tooltip ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: tooltip,
      disabled: !tooltip,
      fallbackPlacements: ["top-end"],
      placement: "bottom-end",
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children })
    }
  ) : children;
}
const INCLUDE_FIELDS_QUERY = ["_id", "_rev", "_type"], INCLUDE_FIELDS = [...INCLUDE_FIELDS_QUERY, "_key"], AVAILABILITY_READABLE = {
  available: !0,
  reason: "READABLE"
}, AVAILABILITY_PERMISSION_DENIED = {
  available: !1,
  reason: "PERMISSION_DENIED"
}, AVAILABILITY_NOT_FOUND = {
  available: !1,
  reason: "NOT_FOUND"
}, INVALID_PREVIEW_FALLBACK = {
  title: "Invalid preview config",
  subtitle: "Check the error log in the console",
  media: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {})
};
function debounceCollect(fn, wait) {
  let timer, queue = {}, idx = 0;
  return function(...args) {
    return new rxjs.Observable((obs) => {
      clearTimeout(timer), timer = setTimeout(flush, wait);
      const queueItem = {
        args,
        observer: obs,
        completed: !1
      }, id2 = idx++;
      return queue[id2] = queueItem, () => {
        queueItem.completed = !0;
      };
    });
  };
  function flush() {
    const currentlyFlushingQueue = queue;
    queue = {};
    const queueItemIds = Object.keys(currentlyFlushingQueue).filter((id2) => {
      const queueItem = currentlyFlushingQueue[id2];
      return queueItem && !queueItem.completed;
    });
    if (queueItemIds.length === 0)
      return;
    const collectedArgs = queueItemIds.map((id2) => {
      const queueItem = currentlyFlushingQueue[id2];
      return queueItem && queueItem.args;
    }).filter(isNonNullable$3);
    fn(collectedArgs).subscribe({
      next(results) {
        results.forEach((result, i) => {
          const queueItem = currentlyFlushingQueue[queueItemIds[i]];
          queueItem && !queueItem.completed && queueItem.observer.next(results[i]);
        });
      },
      complete() {
        queueItemIds.forEach((id2) => {
          const entry = currentlyFlushingQueue[id2];
          entry && !entry.completed && entry.observer.complete();
        });
      },
      error(err) {
        queueItemIds.forEach((id2) => {
          const entry = currentlyFlushingQueue[id2];
          entry && !entry.completed && entry.observer.error(err);
        });
      }
    });
  }
}
const MAX_DOCUMENT_ID_CHUNK_SIZE = 11164;
function chunkDocumentIds(documentIds) {
  let chunk = [], chunkSize = 0;
  const chunks = [];
  for (const documentId of documentIds)
    chunkSize + documentId.length + 1 >= MAX_DOCUMENT_ID_CHUNK_SIZE && (chunks.push(chunk), chunk = [], chunkSize = 0), chunkSize += documentId.length + 1, chunk.push(documentId);
  return chunks.includes(chunk) || chunks.push(chunk), chunks;
}
function mutConcat(array, chunks) {
  return array.push(...chunks), array;
}
function create_preview_availability(versionedClient, observePaths2) {
  function observeDocumentPairAvailability(id2) {
    const draftId = getDraftId(id2), publishedId = getPublishedId(id2);
    return rxjs.combineLatest([
      observeDocumentAvailability(draftId),
      observeDocumentAvailability(publishedId)
    ]).pipe(
      operators.distinctUntilChanged(shallowEquals__default.default),
      operators.map(([draftReadability, publishedReadability]) => ({
        draft: draftReadability,
        published: publishedReadability
      }))
    );
  }
  function observeDocumentAvailability(id2) {
    return observePaths2({ _ref: id2 }, [["_rev"]]).pipe(
      operators.map((res) => isRecord$4(res) && !!("_rev" in res && res != null && res._rev)),
      operators.distinctUntilChanged(),
      operators.switchMap((hasRev) => hasRev ? (
        // short circuit: if we can read the _rev field we know it both exists and is readable
        rxjs.of(AVAILABILITY_READABLE)
      ) : (
        // we can't read the _rev field for two possible reasons: 1) the document isn't readable or 2) the document doesn't exist
        fetchDocumentReadability(id2)
      ))
    );
  }
  const fetchDocumentReadability = debounceCollect(function(args) {
    const uniqueIds = [...new Set(flatten__default.default(args))];
    return rxjs.from(chunkDocumentIds(uniqueIds)).pipe(
      operators.mergeMap(fetchDocumentReadabilityChunked, 10),
      operators.reduce(mutConcat, []),
      operators.map((res) => args.map(([id2]) => res[uniqueIds.indexOf(id2)]))
    );
  }, 1);
  function fetchDocumentReadabilityChunked(ids) {
    return rxjs.defer(() => {
      const requestOptions = {
        uri: versionedClient.getDataUrl("doc", ids.join(",")),
        json: !0,
        query: { excludeContent: "true" },
        tag: "preview.documents-availability"
      };
      return versionedClient.observable.request(requestOptions).pipe(
        operators.map((response) => {
          const omitted = keyBy__default.default(response.omitted || [], (entry) => entry.id);
          return ids.map((id2) => {
            const omittedEntry = omitted[id2];
            if (!omittedEntry)
              return AVAILABILITY_READABLE;
            if (omittedEntry.reason === "existence")
              return AVAILABILITY_NOT_FOUND;
            if (omittedEntry.reason === "permission")
              return AVAILABILITY_PERMISSION_DENIED;
            throw new Error(`Unexpected reason for omission: "${omittedEntry.reason}"`);
          });
        })
      );
    });
  }
  return { observeDocumentPairAvailability };
}
function keysOf(value) {
  return Object.keys(value);
}
function setKey(source, key, value) {
  return {
    ...source,
    [key]: value
  };
}
function props(options = {}) {
  return (source) => new rxjs.Observable((observer) => source.subscribe(observer)).pipe(
    operators.switchMap((object) => {
      const keyObservables = keysOf(object).map((key) => {
        const value = object[key];
        return rxjs.isObservable(value) ? rxjs.from(value).pipe(operators.map((val) => [key, val])) : rxjs.of([key, value]);
      });
      return options.wait ? rxjs.combineLatest(keyObservables).pipe(
        operators.map((pairs) => pairs.reduce((acc, [key, value]) => setKey(acc, key, value), {}))
      ) : rxjs.from(keyObservables).pipe(
        operators.mergeAll(),
        operators.scan((acc, [key, value]) => setKey(acc, key, value), {})
      );
    })
  );
}
function createEmpty(fields) {
  return fields.reduce((result, field) => (result[field] = void 0, result), {});
}
function resolveMissingHeads(value, paths) {
  return paths.filter((path) => !(path[0] in value));
}
function getDocumentId(value) {
  return types.isReference(value) ? value._ref : "_id" in value ? value._id : void 0;
}
function observePaths(value, paths, observeFields, apiConfig) {
  if (!value || typeof value != "object")
    return rxjs.of(value);
  const id2 = getDocumentId(value), currentValue = id2 ? { ...value, _id: id2 } : { ...value };
  currentValue._type === "reference" && (delete currentValue._type, delete currentValue._ref, delete currentValue._weak, delete currentValue._dataset, delete currentValue._projectId, delete currentValue._strengthenOnPublish);
  const pathsWithMissingHeads = resolveMissingHeads(currentValue, paths);
  if (id2 && pathsWithMissingHeads.length > 0) {
    const nextHeads = uniq__default.default(pathsWithMissingHeads.map((path) => path[0])), refApiConfig = types.isCrossDatasetReference(value) ? { projectId: value._projectId, dataset: value._dataset } : apiConfig;
    return observeFields(id2, nextHeads, refApiConfig).pipe(
      operators.switchMap((snapshot) => snapshot === null ? rxjs.of(null) : observePaths(
        {
          ...createEmpty(nextHeads),
          ...types.isReference(value) ? { ...value, ...refApiConfig } : value,
          ...snapshot
        },
        paths,
        observeFields,
        refApiConfig
      ))
    );
  }
  const leads = {};
  paths.forEach((path) => {
    const [head, ...tail] = path;
    leads[head] || (leads[head] = []), leads[head].push(tail);
  });
  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head].filter((tail) => tail.length > 0);
    return tails.length === 0 ? res[head] = isRecord$4(value) ? value[head] : void 0 : res[head] = observePaths(value[head], tails, observeFields, apiConfig), res;
  }, currentValue);
  return rxjs.of(next).pipe(props({ wait: !0 }));
}
function normalizePaths(path) {
  return path.map(
    (segment) => typeof segment == "string" ? segment.split(".") : segment
  );
}
function createPathObserver(context) {
  const { observeFields } = context;
  return {
    observePaths(value, paths, apiConfig) {
      return observePaths(value, normalizePaths(paths), observeFields, apiConfig);
    }
  };
}
const DEFAULT_PREVIEW_PATHS = [["_createdAt"], ["_updatedAt"]];
function getPreviewPaths(preview) {
  const selection = preview == null ? void 0 : preview.select;
  return selection ? (Object.values(selection).map((value) => String(value).split(".")) || []).concat(DEFAULT_PREVIEW_PATHS) : void 0;
}
function isPortableTextPreviewValue(value) {
  return Array.isArray(value) && (value.length === 0 || value.some(types.isPortableTextTextBlock));
}
function extractTextFromBlocks(blocks) {
  const firstBlock = Array.isArray(blocks) && blocks.find(types.isPortableTextTextBlock);
  return !firstBlock || !firstBlock.children ? "" : firstBlock.children.filter(types.isPortableTextSpan).map((span) => span.text).join("");
}
const PRESERVE_KEYS = ["_id", "_type", "_upload", "_createdAt", "_updatedAt"], EMPTY = [], errorCollector = /* @__PURE__ */ (() => {
  let errorsByType = {};
  return {
    add: (type, value, error) => {
      errorsByType[type.name] || (errorsByType[type.name] = []), errorsByType[type.name].push({ error, type, value });
    },
    getAll() {
      return errorsByType;
    },
    clear() {
      errorsByType = {};
    }
  };
})(), reportErrors = debounce__default.default(() => {
  const errorsByType = errorCollector.getAll(), errorCount = flatten__default.default(
    Object.keys(errorsByType).map((typeName) => {
      const entries = errorsByType[typeName];
      return uniqBy__default.default(entries, (entry) => entry.error.message);
    })
  ).length;
  errorCount !== 0 && (console.groupCollapsed(
    `%cHeads up! Got ${errorCount === 1 ? "error" : `${errorCount} errors`} while preparing data for preview. Click for details.`,
    "color: #ff7e7c"
  ), Object.keys(errorsByType).forEach((typeName) => {
    const entries = errorsByType[typeName], first = entries[0];
    console.group(`Check the preview config for schema type "${typeName}": %o`, first.type.preview), uniqBy__default.default(entries, (entry) => entry.error.message).forEach((entry) => {
      var _a2;
      if (entry.error.type === "returnValueError") {
        const hasPrepare = typeof ((_a2 = entry.type.preview) == null ? void 0 : _a2.prepare) == "function", { value, error } = entry;
        console.log(
          `Encountered an invalid ${hasPrepare ? "return value when calling prepare(%o)" : "value targeted by preview.select"}:`,
          value
        ), console.error(error);
      }
      if (entry.error.type === "prepareError") {
        const { value, error } = entry;
        console.log("Encountered an error when calling prepare(%o):", value), console.error(error);
      }
    }), console.groupEnd();
  }), console.groupEnd(), errorCollector.clear());
}, 1e3), isRenderable = (fieldName) => (value) => {
  const type = typeof value;
  return value === null || type === "undefined" || type === "string" || type === "number" || type === "boolean" ? EMPTY : [
    assignType(
      "returnValueError",
      new Error(
        `The "${fieldName}" field should be a string, number, boolean, undefined or null, instead saw ${inspect(
          value
        )}`
      )
    )
  ];
}, FIELD_NAME_VALIDATORS = {
  media: () => EMPTY,
  title: isRenderable("title"),
  subtitle: isRenderable("subtitle"),
  description: isRenderable("description"),
  imageUrl: isRenderable("imageUrl"),
  date: isRenderable("date")
};
function inspect(val, prefixType = !0) {
  if (isRecord$4(val)) {
    const keys = Object.keys(val), ellipse = keys.length > 3 ? "..." : "";
    return `${prefixType ? "object with keys " : ""}{${keys.slice(0, 3).join(", ")}${ellipse}}`;
  }
  if (Array.isArray(val)) {
    const ellipse = val.length > 3 ? "..." : "";
    return `${prefixType ? "array with " : ""}[${val.map((v) => inspect(v, !1))}${ellipse}]`;
  }
  return `the ${typeof val} ${val}`;
}
function validateFieldValue(fieldName, fieldValue) {
  if (typeof fieldValue > "u")
    return EMPTY;
  const validator = FIELD_NAME_VALIDATORS[fieldName];
  return validator && validator(fieldValue) || EMPTY;
}
function assignType(type, error) {
  return Object.assign(error, { type });
}
function validatePreparedValue(preparedValue) {
  return !isPlainObject__default.default(preparedValue) || preparedValue === null ? [
    assignType(
      "returnValueError",
      new Error(
        `Invalid return value. Expected a plain object with at least a 'title' field, instead saw ${inspect(
          preparedValue
        )}`
      )
    )
  ] : Object.entries(preparedValue).reduce((acc, [fieldName, fieldValue]) => [...acc, ...validateFieldValue(fieldName, fieldValue)], EMPTY);
}
function validateReturnedPreview(result) {
  return {
    ...result,
    errors: [...result.errors || [], ...validatePreparedValue(result.returnValue)]
  };
}
function defaultPrepare(value) {
  return keysOf(value).reduce((acc, fieldName) => {
    const val = value[fieldName];
    return {
      ...acc,
      [fieldName]: isPortableTextPreviewValue(val) ? extractTextFromBlocks(val) : val
    };
  }, {});
}
function invokePrepare(type, value, viewOptions = {}) {
  var _a2;
  const prepare2 = (_a2 = type.preview) == null ? void 0 : _a2.prepare;
  try {
    return {
      returnValue: prepare2 ? prepare2(value, viewOptions) : defaultPrepare(value),
      errors: EMPTY
    };
  } catch (error) {
    return {
      returnValue: null,
      errors: [assignType("prepareError", error)]
    };
  }
}
function withErrors(result, type, selectedValue) {
  return result.errors.forEach((error) => errorCollector.add(type, selectedValue, error)), reportErrors(), INVALID_PREVIEW_FALLBACK;
}
function hasEnumListOptions(type) {
  const options = type.options && typeof type.options == "object" ? type.options : !1;
  if (!options || !("list" in options))
    return !1;
  const listOptions = options.list;
  return Array.isArray(listOptions);
}
function getListOptions(type) {
  return hasEnumListOptions(type) ? type.options.list.map(
    (option) => types.isTitledListValue(option) ? option : { title: option, value: option }
  ) : void 0;
}
function prepareForPreview(rawValue, type, viewOptions = {}) {
  var _a2, _b;
  const hasCustomPrepare = typeof ((_a2 = type.preview) == null ? void 0 : _a2.prepare) == "function", selection = ((_b = type.preview) == null ? void 0 : _b.select) || {}, selectedValue = Object.keys(selection).reduce((acc, key) => {
    var _a22;
    const typeWithFields = "fields" in type ? type : null, targetFieldName = selection[key], valueField = (_a22 = typeWithFields == null ? void 0 : typeWithFields.fields) == null ? void 0 : _a22.find((f) => f.name === targetFieldName), listOptions = valueField && getListOptions(valueField.type);
    if (!hasCustomPrepare && listOptions) {
      const selectedOption = listOptions && listOptions.find((opt) => opt.value === get__default.default(rawValue, selection[key]));
      acc[key] = selectedOption ? selectedOption.value : get__default.default(rawValue, selection[key]);
    } else
      acc[key] = get__default.default(rawValue, selection[key]);
    return acc;
  }, {}), prepareResult = invokePrepare(type, selectedValue, viewOptions);
  if (prepareResult.errors.length > 0)
    return withErrors(prepareResult, type, selectedValue);
  const returnValueResult = validateReturnedPreview(prepareResult);
  return returnValueResult.errors.length > 0 ? withErrors(returnValueResult, type, selectedValue) : { ...pick__default.default(rawValue, PRESERVE_KEYS), ...prepareResult.returnValue };
}
function isRecord$1(value) {
  return isPlainObject__default.default(value);
}
function isReference(value) {
  return isPlainObject__default.default(value);
}
function createPreviewObserver(context) {
  const { observeDocumentTypeFromId, observePaths: observePaths2 } = context;
  return function observeForPreview(value, type, viewOptions, apiConfig) {
    if (types.isCrossDatasetReferenceSchemaType(type)) {
      if (!types.isCrossDatasetReference(value))
        return rxjs.of({ snapshot: void 0 });
      const refApiConfig = { projectId: value._projectId, dataset: value._dataset };
      return observeDocumentTypeFromId(value._ref, refApiConfig).pipe(
        operators.switchMap((typeName) => {
          if (typeName) {
            const refType = type.to.find((toType) => toType.type === typeName);
            return observeForPreview(value, refType, {}, refApiConfig);
          }
          return rxjs.of({ snapshot: void 0 });
        })
      );
    }
    if (types.isReferenceSchemaType(type))
      return isReference(value) ? observeDocumentTypeFromId(value._ref).pipe(
        operators.switchMap((typeName) => {
          if (typeName) {
            const refType = type.to.find((toType) => toType.name === typeName);
            return observeForPreview(value, refType);
          }
          return rxjs.of({ snapshot: void 0 });
        })
      ) : rxjs.of({ snapshot: void 0 });
    const paths = getPreviewPaths(type.preview);
    return paths ? observePaths2(value, paths, apiConfig).pipe(
      operators.map((snapshot) => ({
        type,
        snapshot: snapshot && prepareForPreview(snapshot, type, viewOptions)
      }))
    ) : rxjs.of({
      type,
      snapshot: value && isRecord$1(value) ? invokePrepare(type, value, viewOptions).returnValue : null
    });
  };
}
function create_preview_documentPair(versionedClient, observePaths2) {
  const { observeDocumentPairAvailability } = create_preview_availability(
    versionedClient,
    observePaths2
  ), ALWAYS_INCLUDED_SNAPSHOT_PATHS = [["_updatedAt"], ["_createdAt"], ["_type"]];
  return { observePathsDocumentPair };
  function observePathsDocumentPair(id2, paths) {
    const { draftId, publishedId } = getIdPair(id2);
    return observeDocumentPairAvailability(draftId).pipe(
      operators.switchMap((availability) => {
        if (!availability.draft.available && !availability.published.available)
          return rxjs.of({
            id: publishedId,
            type: null,
            draft: {
              availability: availability.draft,
              snapshot: void 0
            },
            published: {
              availability: availability.published,
              snapshot: void 0
            }
          });
        const snapshotPaths = [...paths, ...ALWAYS_INCLUDED_SNAPSHOT_PATHS];
        return rxjs.combineLatest([
          observePaths2({ _type: "reference", _ref: draftId }, snapshotPaths),
          observePaths2({ _type: "reference", _ref: publishedId }, snapshotPaths)
        ]).pipe(
          operators.map(([draftSnapshot, publishedSnapshot]) => {
            const type = isRecord$4(draftSnapshot) && "_type" in draftSnapshot && draftSnapshot._type || isRecord$4(publishedSnapshot) && "_type" in publishedSnapshot && publishedSnapshot._type || null;
            return {
              id: publishedId,
              type: typeof type == "string" ? type : null,
              draft: {
                availability: availability.draft,
                snapshot: draftSnapshot
              },
              published: {
                availability: availability.published,
                snapshot: publishedSnapshot
              }
            };
          })
        );
      })
    );
  }
}
function hasEqualFields(fields) {
  return (object, otherObject) => object === otherObject ? !0 : !object || !otherObject || typeof object != "object" || typeof otherObject != "object" ? !1 : fields.every((field) => object[field] === otherObject[field]);
}
const id = (value) => value;
function isUniqueBy(array, itemSelector = id) {
  let prevItem, currItem;
  for (let i = 0; i < array.length; i++) {
    if (i === 0) {
      prevItem = itemSelector(array[i]);
      continue;
    }
    if (currItem = itemSelector(array[i]), prevItem !== currItem)
      return !1;
    prevItem = currItem;
  }
  return !0;
}
function combineSelections(selections) {
  return values__default.default(
    selections.reduce((output, [id2, fields], index) => {
      const key = sortBy__default.default(fields.join(","), identity__default.default).join(".");
      output[key] || (output[key] = { fields, ids: [], map: [] });
      const idx = output[key].ids.length;
      return output[key].ids[idx] = id2, output[key].map[idx] = index, output;
    }, {})
  );
}
function stringifyId(id2) {
  return JSON.stringify(id2);
}
const maybeEscape = (fieldName) => fieldNeedsEscape(fieldName) ? `"${fieldName}": @${escapeField(fieldName)}` : fieldName;
function toSubQuery({ ids, fields }) {
  const allFields = [...INCLUDE_FIELDS_QUERY, ...fields];
  return `*[_id in [${ids.map(stringifyId).join(",")}]][0...${ids.length}]{${allFields.map(maybeEscape).join(",")}}`;
}
function toQuery(combinedSelections) {
  return `[${combinedSelections.map(toSubQuery).join(",")}][0...${combinedSelections.length}]`;
}
function reassemble(queryResult, combinedSelections) {
  return queryResult.reduce((reprojected, subResult, index) => (combinedSelections[index].map.forEach((resultIdx, i) => {
    const id2 = combinedSelections[index].ids[i], found = subResult.find((doc) => doc._id === id2);
    reprojected[resultIdx] = found || null;
  }), reprojected), []);
}
function create_preview_observeFields(context) {
  const { observePaths: observePaths2, versionedClient } = context;
  let _globalListener;
  const getGlobalEvents = () => {
    if (!_globalListener) {
      const allEvents$ = rxjs.from(
        versionedClient.listen(
          '*[!(_id in path("_.**"))]',
          {},
          {
            events: ["welcome", "mutation"],
            includeResult: !1,
            visibility: "query",
            tag: "preview.global"
          }
        )
      ).pipe(operators.share()), welcome$ = allEvents$.pipe(
        operators.filter((event) => event.type === "welcome"),
        operators.shareReplay({ refCount: !0, bufferSize: 1 })
      );
      welcome$.subscribe();
      const mutations$ = allEvents$.pipe(operators.filter((event) => event.type === "mutation"));
      _globalListener = {
        welcome$,
        mutations$
      };
    }
    return _globalListener;
  };
  function listen2(id2) {
    const globalEvents = getGlobalEvents();
    return rxjs.merge(
      globalEvents.welcome$,
      globalEvents.mutations$.pipe(operators.filter((event) => event.documentId === id2))
    );
  }
  function fetchAllDocumentPathsWith(client2) {
    return function(selections) {
      const combinedSelections = combineSelections(selections);
      return client2.observable.fetch(toQuery(combinedSelections), {}, { tag: "preview.document-paths" }).pipe(operators.map((result) => reassemble(result, combinedSelections)));
    };
  }
  const fetchDocumentPathsFast = debounceCollect(fetchAllDocumentPathsWith(versionedClient), 100), fetchDocumentPathsSlow = debounceCollect(fetchAllDocumentPathsWith(versionedClient), 1e3);
  function currentDatasetListenFields(id2, fields) {
    return listen2(id2).pipe(
      operators.switchMap((event) => event.type === "welcome" || event.visibility === "query" ? fetchDocumentPathsFast(id2, fields).pipe(
        operators.mergeMap((result) => rxjs.concat(
          rxjs.of(result),
          result === void 0 ? (
            // just been created and is not yet indexed. We therefore need to wait a bit
            // and then re-fetch.
            fetchDocumentPathsSlow(id2, fields)
          ) : []
        ))
      ) : fetchDocumentPathsSlow(id2, fields))
    );
  }
  const CACHE2 = {}, getBatchFetcherForDataset = memoize__default.default(
    function(apiConfig) {
      const client2 = versionedClient.withConfig(apiConfig), fetchAll = fetchAllDocumentPathsWith(client2);
      return debounceCollect(fetchAll, 10);
    },
    (apiConfig) => apiConfig.dataset + apiConfig.projectId
  ), CROSS_DATASET_PREVIEW_POLL_INTERVAL = 1e4, visiblePoll$ = rxjs.fromEvent(document, "visibilitychange").pipe(
    operators.startWith(0),
    operators.map(() => document.visibilityState === "visible"),
    operators.switchMap((visible) => visible ? rxjs.timer(0, CROSS_DATASET_PREVIEW_POLL_INTERVAL) : rxjs.EMPTY),
    operators.share()
  );
  function crossDatasetListenFields(id2, fields, apiConfig) {
    return visiblePoll$.pipe(operators.startWith(0)).pipe(
      operators.switchMap(() => getBatchFetcherForDataset(apiConfig)(id2, fields))
    );
  }
  function createCachedFieldObserver(id2, fields, apiConfig) {
    let latest = null;
    const changes$ = rxjs.merge(
      rxjs.defer(() => latest === null ? rxjs.EMPTY : rxjs.of(latest)),
      apiConfig ? crossDatasetListenFields(id2, fields, apiConfig) : currentDatasetListenFields(id2, fields)
    ).pipe(
      operators.tap((v) => latest = v),
      operators.shareReplay({ refCount: !0, bufferSize: 1 })
    );
    return { id: id2, fields, changes$ };
  }
  function cachedObserveFields(id2, fields, apiConfig) {
    const cacheKey = apiConfig ? `${apiConfig.projectId}:${apiConfig.dataset}:${id2}` : `$current$-${id2}`;
    cacheKey in CACHE2 || (CACHE2[cacheKey] = []);
    const existingObservers = CACHE2[cacheKey];
    difference__default.default(
      fields,
      flatten__default.default(existingObservers.map((cachedFieldObserver) => cachedFieldObserver.fields))
    ).length > 0 && existingObservers.push(createCachedFieldObserver(id2, fields, apiConfig));
    const cachedFieldObservers = existingObservers.filter((observer) => observer.fields.some((fieldName) => fields.includes(fieldName))).map((cached) => cached.changes$);
    return rxjs.combineLatest(cachedFieldObservers).pipe(
      // in the event that a document gets deleted, the cached values will be updated to store `undefined`
      // if this happens, we should not pick any fields from it, but rather just return null
      operators.map((snapshots) => snapshots.filter(Boolean)),
      // make sure all snapshots agree on same revision
      operators.filter((snapshots) => isUniqueBy(snapshots, (snapshot) => snapshot._rev)),
      // pass on value with the requested fields (or null if value is deleted)
      operators.map((snapshots) => snapshots.length === 0 ? null : pickFrom(snapshots, fields)),
      // emit values only if changed
      operators.distinctUntilChanged(hasEqualFields(fields))
    );
  }
  return { observeFields: cachedObserveFields };
  function pickFrom(objects, fields) {
    return [...INCLUDE_FIELDS, ...fields].reduce((result, fieldName) => {
      const value = getFirstFieldValue(objects, fieldName);
      return value !== void 0 && (result[fieldName] = value), result;
    }, {});
  }
  function getFirstFieldValue(objects, fieldName) {
    let value;
    return objects.some((object) => fieldName in object ? (value = object[fieldName], !0) : !1), value;
  }
}
function createDocumentPreviewStore({
  client: client2
}) {
  const versionedClient = client2.withConfig({ apiVersion: "1" }), __proxy_observePaths = (value, paths, apiConfig) => observePaths2(value, paths, apiConfig), { observeFields } = create_preview_observeFields({
    observePaths: __proxy_observePaths,
    versionedClient
  }), { observePaths: observePaths2 } = createPathObserver({ observeFields });
  function observeDocumentTypeFromId(id2, apiConfig) {
    return observePaths2({ _type: "reference", _ref: id2 }, ["_type"], apiConfig).pipe(
      operators.map((res) => isRecord$4(res) && typeof res._type == "string" ? res._type : void 0),
      operators.distinctUntilChanged()
    );
  }
  const observeForPreview = createPreviewObserver({ observeDocumentTypeFromId, observePaths: observePaths2 }), { observeDocumentPairAvailability } = create_preview_availability(
    versionedClient,
    observePaths2
  ), { observePathsDocumentPair } = create_preview_documentPair(versionedClient, observePaths2);
  return {
    observePaths: observePaths2,
    observeForPreview,
    observeDocumentTypeFromId,
    // eslint-disable-next-line camelcase
    unstable_observeDocumentPairAvailability: observeDocumentPairAvailability,
    unstable_observePathsDocumentPair: observePathsDocumentPair
  };
}
const isLiveEditEnabled$2 = (schemaType) => schemaType.liveEdit === !0;
function getPreviewStateObservable$1(documentPreviewStore, schemaType, documentId, title) {
  const draft$ = isLiveEditEnabled$2(schemaType) ? rxjs.of({ snapshot: null }) : documentPreviewStore.observeForPreview(
    { _type: "reference", _ref: getDraftId(documentId) },
    schemaType
  ), published$ = documentPreviewStore.observeForPreview(
    { _type: "reference", _ref: getPublishedId(documentId) },
    schemaType
  );
  return rxjs.combineLatest([draft$, published$]).pipe(
    operators.map(([draft, published]) => ({
      draft: draft.snapshot ? { title, ...draft.snapshot || {} } : null,
      isLoading: !1,
      published: published.snapshot ? { title, ...published.snapshot || {} } : null
    })),
    operators.startWith({ draft: null, isLoading: !0, published: null })
  );
}
const getMissingDocumentFallback = (item) => ({
  title: /* @__PURE__ */ jsxRuntime.jsx("em", { children: item.title ? String(item.title) : "Missing document" }),
  subtitle: /* @__PURE__ */ jsxRuntime.jsx("em", { children: item.title ? `Missing document ID: ${item._id}` : `Document ID: ${item._id}` }),
  media: () => /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {})
}), getPreviewValueWithFallback = ({
  value,
  draft,
  published
}) => {
  const snapshot = draft || published;
  return snapshot ? assignWith__default.default({}, snapshot, value, (objValue, srcValue) => typeof srcValue > "u" ? objValue : srcValue) : getMissingDocumentFallback(value);
}, useUserViaUserStore = createHookFromObservableFactory(
  ([userStore, userId]) => rxjs.from(
    userStore.getUser(userId).catch((err) => (console.error(err), null))
  )
);
function useUser(userId) {
  const userStore = useUserStore();
  return useUserViaUserStore(React.useMemo(() => [userStore, userId], [userId, userStore]));
}
function useCurrentUser() {
  const { currentUser } = useSource();
  return currentUser;
}
const getUpdatedSnapshot = (bufferedDocument) => {
  const LOCAL = bufferedDocument.LOCAL, HEAD = bufferedDocument.document.HEAD;
  return LOCAL && {
    ...LOCAL,
    _type: (HEAD || LOCAL)._type,
    _rev: (HEAD || LOCAL)._rev,
    _updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
}, toSnapshotEvent = (document2) => ({ type: "snapshot", document: document2 }), getDocument = (event) => event.document, createObservableBufferedDocument = (listenerEvent$) => {
  const actions$ = new rxjs.Subject(), consistency$ = new rxjs.BehaviorSubject(!0), mutations$ = new rxjs.Subject(), rebase$ = new rxjs.Subject(), remoteMutations = new rxjs.Subject(), commitRequests = new rxjs.Subject(), createInitialBufferedDocument = (initialSnapshot) => {
    const bufferedDocument = new mutator.BufferedDocument(initialSnapshot);
    return bufferedDocument.onMutation = ({ mutation, remote }) => {
      mutations$.next({
        type: "mutation",
        document: getUpdatedSnapshot(bufferedDocument),
        mutations: mutation.mutations,
        origin: remote ? "remote" : "local"
      });
    }, bufferedDocument.onRemoteMutation = (mutation) => {
      remoteMutations.next({
        type: "remoteMutation",
        head: bufferedDocument.document.HEAD,
        transactionId: mutation.transactionId,
        timestamp: mutation.timestamp,
        author: mutation.identity,
        effects: mutation.effects
      });
    }, bufferedDocument.onRebase = (edge, nextRemoteMutations, localMutations) => {
      rebase$.next({
        type: "rebase",
        document: edge,
        remoteMutations: nextRemoteMutations,
        localMutations
      });
    }, bufferedDocument.onConsistencyChanged = (isConsistent) => {
      consistency$.next(isConsistent);
    }, bufferedDocument.commitHandler = (commitArg) => commitRequests.next(commitArg), bufferedDocument;
  }, currentBufferedDocument$ = listenerEvent$.pipe(
    operators.scan((bufferedDocument, listenerEvent) => listenerEvent.type === "snapshot" ? (bufferedDocument && bufferedDocument.commit(), createInitialBufferedDocument(listenerEvent.document || null)) : bufferedDocument === null ? (console.warn(
      'Ignoring event of type "%s" since buffered document has not yet been set up with snapshot',
      listenerEvent.type
    ), null) : bufferedDocument, null),
    operators.filter(
      (bufferedDocument) => bufferedDocument !== null
    ),
    operators.distinctUntilChanged(),
    operators.publishReplay(1),
    operators.refCount()
  ), snapshotAfterSync$ = listenerEvent$.pipe(
    operators.filter((ev) => ev.type === "mutation"),
    operators.withLatestFrom(currentBufferedDocument$),
    operators.map(([mutationEvent, bufferedDocument]) => (bufferedDocument.arrive(new mutator.Mutation(mutationEvent)), getUpdatedSnapshot(bufferedDocument)))
  ), actionHandler$ = actions$.pipe(
    operators.withLatestFrom(currentBufferedDocument$),
    operators.tap(([action, bufferedDocument]) => {
      action.type === "mutation" && bufferedDocument.add(new mutator.Mutation({ mutations: action.mutations })), action.type === "commit" && bufferedDocument.commit();
    }),
    // We subscribe to this only for the side effects
    operators.mergeMapTo(rxjs.EMPTY),
    operators.share()
  ), emitAction = (action) => actions$.next(action), addMutations = (mutations) => emitAction({ type: "mutation", mutations }), addMutation = (mutation) => addMutations([mutation]), commit2 = () => {
    currentBufferedDocument$.pipe(
      operators.take(1),
      operators.tap((bufferedDocument) => bufferedDocument.commit())
    ).subscribe();
  }, snapshot$ = rxjs.merge(
    currentBufferedDocument$.pipe(operators.map((bufferedDocument) => bufferedDocument.LOCAL)),
    mutations$.pipe(operators.map(getDocument)),
    rebase$.pipe(operators.map(getDocument)),
    snapshotAfterSync$
  ).pipe(operators.map(toSnapshotEvent), operators.publishReplay(1), operators.refCount()), remoteSnapshot$ = rxjs.merge(
    currentBufferedDocument$.pipe(
      operators.map((bufferedDocument) => bufferedDocument.document.HEAD),
      operators.map(toSnapshotEvent)
    ),
    remoteMutations
  ).pipe(operators.publishReplay(1), operators.refCount());
  return {
    updates$: rxjs.merge(snapshot$, actionHandler$, mutations$, rebase$),
    consistency$: consistency$.pipe(operators.distinctUntilChanged(), operators.publishReplay(1), operators.refCount()),
    remoteSnapshot$,
    commitRequest$: commitRequests,
    addMutation,
    addMutations,
    commit: commit2
  };
}, prepare = (id2) => (document2) => {
  const { _id, _rev, _updatedAt, ...rest } = document2;
  return { _id: id2, ...rest };
}, createBufferedDocument = (documentId, listenerEvent$) => {
  const bufferedDocument = createObservableBufferedDocument(listenerEvent$), prepareDoc = prepare(documentId), DELETE = { delete: { id: documentId } };
  return {
    events: bufferedDocument.updates$,
    consistency$: bufferedDocument.consistency$,
    remoteSnapshot$: bufferedDocument.remoteSnapshot$,
    commitRequest$: bufferedDocument.commitRequest$,
    patch: (patches) => patches.map((patch2) => ({ patch: { ...patch2, id: documentId } })),
    create: (document2) => ({ create: prepareDoc(document2) }),
    createIfNotExists: (document2) => ({ createIfNotExists: prepareDoc(document2) }),
    createOrReplace: (document2) => ({ createOrReplace: prepareDoc(document2) }),
    delete: () => DELETE,
    mutate: (mutations) => bufferedDocument.addMutations(mutations),
    commit: () => bufferedDocument.commit()
  };
}, PENDING_START = { type: "pending", phase: "begin" }, PENDING_END = { type: "pending", phase: "end" };
function isMutationEvent(msg) {
  return msg.type === "mutation";
}
function isMultiTransactionEvent(msg) {
  return msg.transactionTotalEvents > 1;
}
function allPendingTransactionEventsReceived(listenerEvents) {
  const groupedMutations = groupBy__default.default(
    listenerEvents.filter((ev) => ev.type === "mutation"),
    (e) => e.transactionId
  );
  return Object.values(groupedMutations).every(
    (mutations) => mutations.length === mutations[0].transactionTotalEvents
  );
}
function getPairListener(client2, idPair, options = {}) {
  const { publishedId, draftId } = idPair;
  return rxjs.defer(
    () => client2.observable.listen(
      "*[_id == $publishedId || _id == $draftId]",
      {
        publishedId,
        draftId
      },
      {
        includeResult: !1,
        events: ["welcome", "mutation", "reconnect"],
        effectFormat: "mendoza",
        tag: options.tag || "document.pair-listener"
      }
    )
  ).pipe(
    operators.concatMap(
      (event) => event.type === "welcome" ? fetchInitialDocumentSnapshots().pipe(
        operators.concatMap((snapshots) => [
          createSnapshotEvent(draftId, snapshots.draft),
          createSnapshotEvent(publishedId, snapshots.published)
        ])
      ) : rxjs.of(event)
    ),
    operators.scan(
      (acc, msg) => {
        if (!isMutationEvent(msg))
          return { next: [msg], buffer: [] };
        const isBuffering = acc.buffer.length > 0, isMulti = isMultiTransactionEvent(msg);
        if (!isMulti && !isBuffering)
          return { next: [msg], buffer: [] };
        if (!isMulti)
          return { next: [], buffer: acc.buffer.concat(msg) };
        const nextBuffer = acc.buffer.concat(msg);
        return allPendingTransactionEventsReceived(nextBuffer) ? { next: nextBuffer.concat(PENDING_END), buffer: [] } : { next: nextBuffer.length === 1 ? [PENDING_START] : [], buffer: nextBuffer };
      },
      { next: [], buffer: [] }
    ),
    // note: this flattens the array, and in the case of an empty array, no event will be pushed downstream
    operators.mergeMap((v) => v.next),
    operators.concatMap(
      (result) => window.SLOW ? rxjs.timer(1e4).pipe(operators.map(() => result)) : rxjs.of(result)
    )
  );
  function fetchInitialDocumentSnapshots() {
    return client2.observable.getDocuments([draftId, publishedId], { tag: "document.snapshots" }).pipe(
      operators.map(([draft, published]) => ({
        draft,
        published
      }))
    );
  }
}
function createSnapshotEvent(documentId, document2) {
  return {
    type: "snapshot",
    documentId,
    document: document2
  };
}
const isMutationEventForDocId = (id2) => (event) => event.type !== "reconnect" && event.type !== "pending" && event.documentId === id2;
function setVersion(version) {
  return (ev) => ({ ...ev, version });
}
function requireId(value) {
  if (!value._id)
    throw new Error("Expected document to have an _id");
}
function isLiveEditMutation(mutationParams, publishedId) {
  const { resultRev, ...mutation } = mutationParams;
  return mutation.mutations.flatMap((mut) => {
    const mutationPayloads = Object.values(mut);
    if (mutationPayloads.length > 1)
      throw new Error("Did not expect multiple mutations in the same payload");
    return mutationPayloads[0].id || mutationPayloads[0]._id;
  }).every((target) => target === publishedId);
}
function toActions(idPair, mutationParams) {
  return mutationParams.mutations.flatMap((mutations) => {
    if (Object.keys(mutations).length > 1)
      throw new Error("Did not expect multiple mutations in the same payload");
    if (mutations.createIfNotExists)
      return [];
    if (mutations.create)
      return requireId(mutations.create), {
        actionType: "sanity.action.document.create",
        publishedId: idPair.publishedId,
        attributes: mutations.create,
        ifExists: "fail"
      };
    if (mutations.patch)
      return {
        actionType: "sanity.action.document.edit",
        draftId: idPair.draftId,
        publishedId: idPair.publishedId,
        patch: mutations.patch
      };
    throw new Error("Todo: implement");
  });
}
function commitActions(defaultClient, idPair, mutationParams) {
  if (isLiveEditMutation(mutationParams, idPair.publishedId))
    return commitMutations(defaultClient, mutationParams);
  const vXClient = defaultClient.withConfig({ apiVersion: "X" }), { dataset } = defaultClient.config();
  return vXClient.observable.request({
    url: `/data/actions/${dataset}`,
    method: "post",
    tag: "document.commit",
    body: {
      transactionId: mutationParams.transactionId,
      actions: toActions(idPair, mutationParams)
    }
  });
}
function commitMutations(client2, mutationParams) {
  const { resultRev, ...mutation } = mutationParams;
  return client2.dataRequest("mutate", mutation, {
    visibility: "async",
    returnDocuments: !1,
    tag: "document.commit",
    // This makes sure the studio doesn't crash when a draft is crated
    // because someone deleted a referenced document in the target dataset
    skipCrossDatasetReferenceValidation: !0
  });
}
function submitCommitRequest(client2, idPair, request, serverActionsEnabled) {
  return rxjs.from(
    serverActionsEnabled ? commitActions(client2, idPair, request.mutation.params) : commitMutations(client2, request.mutation.params)
  ).pipe(
    operators.tap({
      error: (error) => {
        "statusCode" in error && typeof error.statusCode == "number" && error.statusCode >= 400 && error.statusCode <= 500 ? request.cancel(error) : request.failure(error);
      },
      next: () => request.success()
    })
  );
}
function checkoutPair(client2, idPair, serverActionsEnabled) {
  const { publishedId, draftId } = idPair, listenerEventsConnector = new rxjs.Subject(), listenerEvents$ = getPairListener(client2, idPair).pipe(
    operators.share({ connector: () => listenerEventsConnector })
  ), reconnect$ = listenerEvents$.pipe(
    operators.filter((ev) => ev.type === "reconnect")
  ), draft = createBufferedDocument(
    draftId,
    listenerEvents$.pipe(operators.filter(isMutationEventForDocId(draftId)))
  ), published = createBufferedDocument(
    publishedId,
    listenerEvents$.pipe(operators.filter(isMutationEventForDocId(publishedId)))
  ), transactionsPendingEvents$ = listenerEvents$.pipe(
    operators.filter((ev) => ev.type === "pending")
  ), commits$ = rxjs.merge(draft.commitRequest$, published.commitRequest$).pipe(
    operators.mergeMap(
      (commitRequest) => serverActionsEnabled.pipe(
        operators.take(1),
        operators.mergeMap(
          (canUseServerActions) => submitCommitRequest(client2, idPair, commitRequest, canUseServerActions)
        )
      )
    ),
    operators.mergeMap(() => rxjs.EMPTY),
    operators.share()
  );
  return {
    transactionsPendingEvents$,
    draft: {
      ...draft,
      events: rxjs.merge(commits$, reconnect$, draft.events).pipe(operators.map(setVersion("draft"))),
      consistency$: draft.consistency$,
      remoteSnapshot$: draft.remoteSnapshot$.pipe(operators.map(setVersion("draft")))
    },
    published: {
      ...published,
      events: rxjs.merge(commits$, reconnect$, published.events).pipe(operators.map(setVersion("published"))),
      consistency$: published.consistency$,
      remoteSnapshot$: published.remoteSnapshot$.pipe(operators.map(setVersion("published")))
    },
    complete: () => listenerEventsConnector.complete()
  };
}
function memoize(fn, keyGen) {
  const MEMO = /* @__PURE__ */ Object.create(null);
  return (...args) => {
    const key = keyGen(...args);
    return key in MEMO || (MEMO[key] = fn(...args)), MEMO[key];
  };
}
function memoizeKeyGen(client2, idPair, typeName) {
  var _a2, _b;
  const config = client2.config();
  return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}-${idPair.publishedId}-${typeName}`;
}
const memoizedPair = memoize(
  (client2, idPair, _typeName, serverActionsEnabled) => new rxjs.Observable((subscriber) => {
    const pair = checkoutPair(client2, idPair, serverActionsEnabled);
    return subscriber.next(pair), pair.complete;
  }).pipe(operators.publishReplay(1), operators.refCount()),
  memoizeKeyGen
);
function isSnapshotEvent(event) {
  return event.type === "snapshot";
}
function withSnapshots(pair) {
  return {
    snapshots$: pair.events.pipe(
      operators.filter(isSnapshotEvent),
      operators.map((event) => event.document),
      operators.publishReplay(1),
      operators.refCount()
    ),
    patch: pair.patch,
    create: pair.create,
    createIfNotExists: pair.createIfNotExists,
    createOrReplace: pair.createOrReplace,
    delete: pair.delete,
    mutate: pair.mutate,
    commit: pair.commit
  };
}
const snapshotPair = memoize(
  (client2, idPair, typeName, serverActionsEnabled) => memoizedPair(client2, idPair, typeName, serverActionsEnabled).pipe(
    operators.map(({ published, draft, transactionsPendingEvents$ }) => ({
      transactionsPendingEvents$,
      published: withSnapshots(published),
      draft: withSnapshots(draft)
    })),
    operators.publishReplay(1),
    operators.refCount()
  ),
  memoizeKeyGen
), isLiveEditEnabled$1 = (schema2, typeName) => {
  var _a2;
  return ((_a2 = schema2.get(typeName)) == null ? void 0 : _a2.liveEdit) === !0;
}, LOCKED = { enabled: !0 }, NOT_LOCKED = { enabled: !1 }, editState = memoize(
  (ctx, idPair, typeName) => {
    const liveEdit = isLiveEditEnabled$1(ctx.schema, typeName);
    return snapshotPair(ctx.client, idPair, typeName, ctx.serverActionsEnabled).pipe(
      operators.switchMap(
        (versions) => rxjs.combineLatest([
          versions.draft.snapshots$,
          versions.published.snapshots$,
          versions.transactionsPendingEvents$.pipe(
            operators.map((ev) => ev.phase === "begin" ? LOCKED : NOT_LOCKED),
            operators.startWith(NOT_LOCKED)
          )
        ])
      ),
      operators.map(([draftSnapshot, publishedSnapshot, transactionSyncLock]) => ({
        id: idPair.publishedId,
        type: typeName,
        draft: draftSnapshot,
        published: publishedSnapshot,
        liveEdit,
        ready: !0,
        transactionSyncLock
      })),
      operators.startWith({
        id: idPair.publishedId,
        type: typeName,
        draft: null,
        published: null,
        liveEdit,
        ready: !1,
        transactionSyncLock: null
      }),
      operators.publishReplay(1),
      operators.refCount()
    );
  },
  (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName)
), consistencyStatus = memoize(
  (client2, idPair, typeName, serverActionsEnabled) => memoizedPair(client2, idPair, typeName, serverActionsEnabled).pipe(
    operators.switchMap(
      ({ draft, published }) => rxjs.combineLatest([draft.consistency$, published.consistency$])
    ),
    operators.map(
      ([draftIsConsistent, publishedIsConsistent]) => draftIsConsistent && publishedIsConsistent
    ),
    operators.distinctUntilChanged(),
    operators.publishReplay(1),
    operators.refCount()
  ),
  memoizeKeyGen
), operationArgs = memoize(
  (ctx, idPair, typeName) => snapshotPair(ctx.client, idPair, typeName, ctx.serverActionsEnabled).pipe(
    operators.switchMap(
      (versions) => rxjs.combineLatest([
        versions.draft.snapshots$,
        versions.published.snapshots$,
        ctx.serverActionsEnabled
      ]).pipe(
        operators.map(
          ([draft, published, canUseServerActions]) => ({
            ...ctx,
            serverActionsEnabled: canUseServerActions,
            idPair,
            typeName,
            snapshots: { draft, published },
            draft: versions.draft,
            published: versions.published
          })
        )
      )
    ),
    operators.publishReplay(1),
    operators.refCount()
  ),
  (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName)
), commit = {
  disabled: () => !1,
  execute: ({ draft, published }) => (draft.commit(), published.commit(), rxjs.EMPTY)
}, del$1 = {
  disabled: ({ snapshots }) => snapshots.draft || snapshots.published ? !1 : "NOTHING_TO_DELETE",
  execute: ({ client: client2, schema: schema2, idPair, typeName }) => {
    const tx = client2.observable.transaction().delete(idPair.publishedId);
    return isLiveEditEnabled$1(schema2, typeName) ? tx.commit({ tag: "document.delete" }) : tx.delete(idPair.draftId).commit({
      tag: "document.delete",
      // this disables referential integrity for cross-dataset references. we
      // have this set because we warn against deletes in the `ConfirmDeleteDialog`
      // UI. This operation is run when "delete anyway" is clicked
      skipCrossDatasetReferenceValidation: !0
    });
  }
}, discardChanges$1 = {
  disabled: ({ snapshots }) => snapshots.draft ? snapshots.published ? !1 : "NOT_PUBLISHED" : "NO_CHANGES",
  execute: ({ client: client2, idPair }) => client2.observable.transaction().delete(idPair.draftId).commit({ tag: "document.discard-changes" })
}, omitProps = ["_createdAt", "_updatedAt"], duplicate = {
  disabled: ({ snapshots }) => snapshots.published || snapshots.draft ? !1 : "NOTHING_TO_DUPLICATE",
  execute: ({ schema: schema2, client: client2, snapshots, typeName }, dupeId) => {
    const source = snapshots.draft || snapshots.published;
    if (!source)
      throw new Error("cannot execute on empty document");
    return client2.observable.create(
      {
        ...omit__default.default(source, omitProps),
        _id: isLiveEditEnabled$1(schema2, typeName) ? dupeId : getDraftId(dupeId),
        _type: source._type
      },
      {
        tag: "document.duplicate"
      }
    );
  }
}, patch$1 = {
  disabled: () => !1,
  execute: ({ schema: schema2, snapshots, idPair, draft, published, typeName }, patches = [], initialDocument) => {
    isLiveEditEnabled$1(schema2, typeName) ? published.mutate([
      published.createIfNotExists({
        _type: typeName,
        ...initialDocument
      }),
      ...published.patch(patches)
    ]) : draft.mutate([
      draft.createIfNotExists({
        ...initialDocument,
        ...snapshots.published,
        _id: idPair.draftId,
        _type: typeName
      }),
      ...draft.patch(patches)
    ]);
  }
};
function strengthenOnPublish(obj) {
  return types.isReference(obj) ? obj._strengthenOnPublish ? omit__default.default(
    obj,
    ["_strengthenOnPublish"].concat(obj._strengthenOnPublish.weak ? [] : ["_weak"])
  ) : obj : typeof obj != "object" || !obj ? obj : Array.isArray(obj) ? obj.map(strengthenOnPublish) : Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [key, strengthenOnPublish(value)])
  );
}
const publish$1 = {
  disabled: ({ schema: schema2, typeName, snapshots }) => isLiveEditEnabled$1(schema2, typeName) ? "LIVE_EDIT_ENABLED" : snapshots.draft ? !1 : snapshots.published ? "ALREADY_PUBLISHED" : "NO_CHANGES",
  execute: ({ client: client2, idPair, snapshots }) => {
    if (!snapshots.draft)
      throw new Error('cannot execute "publish" when draft is missing');
    const value = strengthenOnPublish(omit__default.default(snapshots.draft, "_updatedAt")), tx = client2.observable.transaction();
    if (!snapshots.draft)
      throw new Error('cannot execute "publish" when draft is missing');
    return snapshots.published ? (tx.patch(idPair.publishedId, {
      // Hack until other mutations support revision locking
      unset: ["_revision_lock_pseudo_field_"],
      ifRevisionID: snapshots.published._rev
    }), tx.createOrReplace({
      ...value,
      _id: idPair.publishedId,
      _type: snapshots.draft._type
    })) : tx.create({
      ...value,
      _id: idPair.publishedId,
      _type: snapshots.draft._type
    }), tx.delete(idPair.draftId), tx.commit({ tag: "document.publish", visibility: "async" });
  }
}, restore$1 = {
  disabled: () => !1,
  execute: ({ historyStore, schema: schema2, idPair, typeName }, fromRevision) => {
    const targetId = isLiveEditEnabled$1(schema2, typeName) ? idPair.publishedId : idPair.draftId;
    return historyStore.restore(idPair.publishedId, targetId, fromRevision);
  }
}, unpublish$1 = {
  disabled: ({ schema: schema2, snapshots, typeName }) => isLiveEditEnabled$1(schema2, typeName) ? "LIVE_EDIT_ENABLED" : snapshots.published ? !1 : "NOT_PUBLISHED",
  execute: ({ client: client2, idPair, snapshots }) => {
    let tx = client2.observable.transaction().delete(idPair.publishedId);
    return snapshots.published && (tx = tx.createIfNotExists({
      ...omit__default.default(snapshots.published, "_updatedAt"),
      _id: idPair.draftId,
      _type: snapshots.published._type
    })), tx.commit({
      tag: "document.unpublish",
      visibility: "async",
      // this disables referential integrity for cross-dataset references. we
      // have this set because we warn against unpublishes in the `ConfirmDeleteDialog`
      // UI. This operation is run when "unpublish anyway" is clicked
      skipCrossDatasetReferenceValidation: !0
    });
  }
}, del = {
  disabled: ({ snapshots }) => snapshots.draft || snapshots.published ? !1 : "NOTHING_TO_DELETE",
  execute: ({ client: globalClient, schema: schema2, idPair, typeName, snapshots }) => {
    if (isLiveEditEnabled$1(schema2, typeName))
      return globalClient.observable.transaction().delete(idPair.publishedId).commit({ tag: "document.delete" });
    const vXClient = globalClient.withConfig({ apiVersion: "X" }), { dataset } = globalClient.config();
    return snapshots.published ? vXClient.observable.request({
      url: `/data/actions/${dataset}`,
      method: "post",
      tag: "document.delete",
      // this disables referential integrity for cross-dataset references. we
      // have this set because we warn against deletes in the `ConfirmDeleteDialog`
      // UI. This operation is run when "delete anyway" is clicked
      query: { skipCrossDatasetReferenceValidation: "true" },
      body: {
        actions: [
          {
            actionType: "sanity.action.document.delete",
            draftId: idPair.draftId,
            publishedId: idPair.publishedId
          }
        ]
      }
    }) : vXClient.observable.request({
      url: `/data/actions/${dataset}`,
      method: "post",
      tag: "document.discard",
      body: {
        actions: [
          {
            actionType: "sanity.action.document.discard",
            draftId: idPair.draftId,
            publishedId: idPair.publishedId
          }
        ]
      }
    });
  }
}, discardChanges = {
  disabled: ({ snapshots }) => snapshots.draft ? snapshots.published ? !1 : "NOT_PUBLISHED" : "NO_CHANGES",
  execute: ({ client: globalClient, idPair }) => {
    const vXClient = globalClient.withConfig({ apiVersion: "X" }), { dataset } = globalClient.config();
    return vXClient.observable.request({
      url: `/data/actions/${dataset}`,
      method: "post",
      tag: "document.discard-changes",
      body: {
        actions: [
          {
            actionType: "sanity.action.document.discard",
            draftId: idPair.draftId,
            publishedId: idPair.publishedId
          }
        ]
      }
    });
  }
}, patch = {
  disabled: () => !1,
  execute: ({ schema: schema2, snapshots, idPair, draft, published, typeName }, patches = [], initialDocument) => {
    if (isLiveEditEnabled$1(schema2, typeName)) {
      const patchMutation2 = published.patch(patches), mutations = snapshots.published ? patchMutation2 : [
        published.createIfNotExists({
          _type: typeName,
          ...initialDocument
        })
      ];
      published.mutate(mutations);
      return;
    }
    const patchMutation = draft.patch(patches);
    if (snapshots.published) {
      draft.mutate([
        // If there's no draft, the user's edits will be based on the published document in the form in front of them
        // so before patching it we need to make sure it's created based on the current published version first.
        draft.createIfNotExists({
          ...initialDocument,
          ...snapshots.published,
          _id: idPair.draftId,
          _type: typeName
        }),
        ...patchMutation
      ]);
      return;
    }
    const ensureDraft = snapshots.draft ? [] : [
      draft.create({
        ...initialDocument,
        _id: idPair.draftId,
        _type: typeName
      })
    ];
    draft.mutate([...ensureDraft, ...patchMutation]);
  }
}, publish = {
  disabled: ({ schema: schema2, typeName, snapshots }) => isLiveEditEnabled$1(schema2, typeName) ? "LIVE_EDIT_ENABLED" : snapshots.draft ? !1 : snapshots.published ? "ALREADY_PUBLISHED" : "NO_CHANGES",
  execute: ({ client: globalClient, idPair }) => {
    const vXClient = globalClient.withConfig({ apiVersion: "X" }), { dataset } = globalClient.config();
    return vXClient.observable.request({
      url: `/data/actions/${dataset}`,
      method: "post",
      tag: "document.publish",
      body: {
        actions: [
          {
            actionType: "sanity.action.document.publish",
            draftId: idPair.draftId,
            publishedId: idPair.publishedId
          }
        ]
      }
    });
  }
}, unpublish = {
  disabled: ({ schema: schema2, snapshots, typeName }) => isLiveEditEnabled$1(schema2, typeName) ? "LIVE_EDIT_ENABLED" : snapshots.published ? !1 : "NOT_PUBLISHED",
  execute: ({ client: globalClient, idPair }) => {
    const vXClient = globalClient.withConfig({ apiVersion: "X" }), { dataset } = globalClient.config();
    return vXClient.observable.request({
      url: `/data/actions/${dataset}`,
      method: "post",
      // this disables referential integrity for cross-dataset references. we
      // have this set because we warn against unpublishes in the `ConfirmDeleteDialog`
      // UI. This operation is run when "unpublish anyway" is clicked
      query: { skipCrossDatasetReferenceValidation: "true" },
      tag: "document.unpublish",
      body: {
        actions: [
          {
            actionType: "sanity.action.document.unpublish",
            draftId: idPair.draftId,
            publishedId: idPair.publishedId
          }
        ]
      }
    });
  }
};
function maybeObservable(v) {
  return typeof v > "u" ? rxjs.of(null) : v;
}
const operationImpls = {
  del: del$1,
  delete: del$1,
  publish: publish$1,
  patch: patch$1,
  commit,
  discardChanges: discardChanges$1,
  unpublish: unpublish$1,
  duplicate,
  restore: restore$1
}, serverOperationImpls = {
  ...operationImpls,
  del,
  delete: del,
  discardChanges,
  patch,
  publish,
  unpublish
}, execute = (operationName, operationArguments, extraArgs, serverActionsEnabled) => {
  const operation = serverActionsEnabled ? serverOperationImpls[operationName] : operationImpls[operationName];
  return rxjs.defer(
    () => rxjs.merge(rxjs.of(null), maybeObservable(operation.execute(operationArguments, ...extraArgs)))
  ).pipe(operators.last());
}, operationCalls$ = new rxjs.Subject();
function emitOperation(operationName, idPair, typeName, extraArgs) {
  operationCalls$.next({ operationName, idPair, typeName, extraArgs });
}
const REQUIRES_CONSISTENCY = ["publish", "unpublish", "discardChanges", "delete"], operationEvents = memoize(
  (ctx) => {
    const result$ = operationCalls$.pipe(
      operators.groupBy((op) => op.idPair.publishedId),
      operators.mergeMap(
        (groups$) => groups$.pipe(
          // although it might look like a bug, dropping pending async operations here is actually a feature
          // E.g. if the user types `publish` which is async and then starts patching (sync) then the publish
          // should be cancelled
          operators.switchMap(
            (args) => operationArgs(ctx, args.idPair, args.typeName).pipe(
              operators.take(1),
              operators.switchMap((operationArguments) => {
                const requiresConsistency = REQUIRES_CONSISTENCY.includes(args.operationName);
                requiresConsistency && (operationArguments.published.commit(), operationArguments.draft.commit());
                const isConsistent$ = consistencyStatus(
                  ctx.client,
                  args.idPair,
                  args.typeName,
                  ctx.serverActionsEnabled
                ).pipe(operators.filter(Boolean));
                return (requiresConsistency ? isConsistent$.pipe(operators.take(1)) : rxjs.of(!0)).pipe(
                  operators.switchMap(
                    () => execute(
                      args.operationName,
                      operationArguments,
                      args.extraArgs,
                      operationArguments.serverActionsEnabled
                    )
                  )
                );
              }),
              operators.map(() => ({ type: "success", args })),
              operators.catchError(
                (err) => rxjs.of({ type: "error", args, error: err })
              )
            )
          )
        )
      ),
      operators.share()
    ), autoCommit$ = result$.pipe(
      operators.filter((result) => result.type === "success" && result.args.operationName === "patch"),
      operators.throttleTime(1e3, rxjs.asyncScheduler, { leading: !0, trailing: !0 }),
      operators.concatMap(
        (result) => window.SLOW ? rxjs.timer(1e4).pipe(operators.map(() => result)) : rxjs.of(result)
      ),
      operators.tap((result) => {
        emitOperation("commit", result.args.idPair, result.args.typeName, []);
      })
    );
    return rxjs.merge(result$, autoCommit$.pipe(operators.mergeMapTo(rxjs.EMPTY)));
  },
  (ctx) => {
    var _a2, _b;
    const config = ctx.client.config();
    return `${(_a2 = config.dataset) != null ? _a2 : ""}-${(_b = config.projectId) != null ? _b : ""}${ctx.serverActionsEnabled ? "-serverActionsEnabled" : ""}`;
  }
), remoteSnapshots = memoize(
  (client2, idPair, typeName, serverActionsEnabled) => memoizedPair(client2, idPair, typeName, serverActionsEnabled).pipe(
    operators.switchMap(({ published, draft }) => rxjs.merge(published.remoteSnapshot$, draft.remoteSnapshot$))
  ),
  memoizeKeyGen
), INITIAL_VALIDATION_STATUS = {
  isValidating: !0,
  validation: []
};
function findReferenceIds(obj) {
  return jsonReduce.reduce(
    obj,
    (acc, node) => (types.isReference(node) && acc.add(node._ref), acc),
    /* @__PURE__ */ new Set()
  );
}
const EMPTY_VALIDATION = [], listenDocumentExists = (observeDocumentAvailability, id2) => observeDocumentAvailability(id2).pipe(operators.map(({ published }) => published.available)), DOC_UPDATE_DELAY = 200, REF_UPDATE_DELAY = 1e3;
function shareLatestWithRefCount() {
  return operators.shareReplay({ bufferSize: 1, refCount: !0 });
}
const validation = memoize(
  (ctx, { draftId, publishedId }, typeName) => {
    const document$ = editState(ctx, { draftId, publishedId }, typeName).pipe(
      operators.map(({ draft, published }) => draft || published),
      operators.throttleTime(DOC_UPDATE_DELAY, rxjs.asyncScheduler, { trailing: !0 }),
      operators.distinctUntilChanged((prev, next) => (prev == null ? void 0 : prev._rev) === (next == null ? void 0 : next._rev) ? !0 : shallowEquals__default.default(omit__default.default(prev, "_rev", "_updatedAt"), omit__default.default(next, "_rev", "_updatedAt"))),
      shareLatestWithRefCount()
    ), referenceExistence$ = document$.pipe(
      operators.map((document2) => findReferenceIds(document2)),
      operators.mergeMap((ids) => rxjs.from(ids))
    ).pipe(
      operators.groupBy((id2) => id2, { duration: () => rxjs.timer(1e3 * 60 * 30) }),
      operators.mergeMap(
        (id$) => id$.pipe(
          operators.distinct(),
          operators.mergeMap(
            (id2) => listenDocumentExists(ctx.observeDocumentPairAvailability, id2).pipe(
              operators.map(
                // eslint-disable-next-line max-nested-callbacks
                (result) => [id2, result]
              )
            )
          )
        )
      ),
      operators.scan((acc, [id2, result]) => acc[id2] === result ? acc : { ...acc, [id2]: result }, {}),
      operators.distinctUntilChanged(shallowEquals__default.default),
      shareLatestWithRefCount()
    ), getDocumentExists = ({ id: id2 }) => rxjs.lastValueFrom(
      referenceExistence$.pipe(
        // If the id is not present as key in the `referenceExistence` map it means it's existence status
        // isn't yet loaded, so we want to wait until it is
        operators.first((referenceExistence) => id2 in referenceExistence),
        operators.map((referenceExistence) => referenceExistence[id2])
      )
    ), referenceDocumentUpdates$ = referenceExistence$.pipe(
      // we'll skip the first emission since the document already gets an initial validation pass
      // we're only interested in updates in referenced documents after that
      operators.skip(1),
      operators.throttleTime(REF_UPDATE_DELAY, rxjs.asyncScheduler, { leading: !0, trailing: !0 })
    );
    return rxjs.combineLatest([document$, rxjs.concat(rxjs.of(null), referenceDocumentUpdates$)]).pipe(
      operators.map(([document2]) => document2),
      rxjsExhaustmapWithTrailing.exhaustMapWithTrailing((document2) => rxjs.defer(() => document2 != null && document2._type ? rxjs.concat(
        rxjs.of({ isValidating: !0, revision: document2._rev }),
        validateDocumentObservable({
          document: document2,
          getClient: ctx.getClient,
          getDocumentExists,
          i18n: ctx.i18n,
          schema: ctx.schema,
          environment: "studio"
        }).pipe(
          operators.map((validationMarkers) => ({ validation: validationMarkers, isValidating: !1 }))
        )
      ) : rxjs.of({ validation: EMPTY_VALIDATION, isValidating: !1 }))),
      operators.scan((acc, next) => ({ ...acc, ...next }), INITIAL_VALIDATION_STATUS),
      shareLatestWithRefCount()
    );
  },
  (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName)
), documentEvents = memoize(
  (client2, idPair, typeName, serverActionsEnabled) => memoizedPair(client2, idPair, typeName, serverActionsEnabled).pipe(
    operators.switchMap(({ draft, published }) => rxjs.merge(draft.events, published.events))
  ),
  memoizeKeyGen
);
function createOperationGuard(opName) {
  return {
    disabled: "NOT_READY",
    execute: () => {
      throw new Error(`Called ${opName} before it was ready.`);
    }
  };
}
const GUARDED = {
  commit: createOperationGuard("commit"),
  delete: createOperationGuard("delete"),
  del: createOperationGuard("del"),
  publish: createOperationGuard("publish"),
  patch: createOperationGuard("patch"),
  discardChanges: createOperationGuard("discardChanges"),
  unpublish: createOperationGuard("unpublish"),
  duplicate: createOperationGuard("duplicate"),
  restore: createOperationGuard("restore")
}, createEmitter = (operationName, idPair, typeName) => (...executeArgs) => emitOperation(operationName, idPair, typeName, executeArgs);
function wrap(opName, op, operationArgs2) {
  return {
    disabled: op.disabled(operationArgs2),
    execute: createEmitter(opName, operationArgs2.idPair, operationArgs2.typeName)
  };
}
function createOperationsAPI(args) {
  const operationsAPI = {
    commit: wrap("commit", commit, args),
    delete: wrap("delete", del$1, args),
    del: wrap("delete", del$1, args),
    publish: wrap("publish", publish$1, args),
    patch: wrap("patch", patch$1, args),
    discardChanges: wrap("discardChanges", discardChanges$1, args),
    unpublish: wrap("unpublish", unpublish$1, args),
    duplicate: wrap("duplicate", duplicate, args),
    restore: wrap("restore", restore$1, args)
  };
  return args.serverActionsEnabled ? {
    ...operationsAPI,
    delete: wrap("delete", del, args),
    del: wrap("delete", del, args),
    discardChanges: wrap("discardChanges", discardChanges, args),
    patch: wrap("patch", patch, args),
    publish: wrap("publish", publish, args),
    unpublish: wrap("unpublish", unpublish, args)
  } : operationsAPI;
}
const editOperations = memoize(
  (ctx, idPair, typeName) => {
    const operationEvents$ = operationEvents(ctx), operations$ = operationArgs(ctx, idPair, typeName).pipe(operators.map(createOperationsAPI));
    return rxjs.concat(
      rxjs.of(GUARDED),
      rxjs.merge(operationEvents$.pipe(operators.mergeMap(() => rxjs.EMPTY)), operations$)
    ).pipe(operators.shareReplay({ refCount: !0, bufferSize: 1 }));
  },
  (ctx, idPair, typeName) => memoizeKeyGen(ctx.client, idPair, typeName)
);
function isRecord(value) {
  return isPlainObject__default.default(value);
}
function deepAssign(target, source) {
  const result = { ...target, ...source };
  return Object.keys(result).forEach((key) => {
    const sourceVal = source[key], targetVal = target[key];
    isRecord(sourceVal) && isRecord(targetVal) && (result[key] = deepAssign(targetVal, sourceVal));
  }), result;
}
const ALLOWED_REF_PROPS = [
  "_dataset",
  "_projectId",
  "_strengthenOnPublish",
  "_key",
  "_ref",
  "_type",
  "_weak"
], REQUIRED_TEMPLATE_PROPS = ["id", "title", "schemaType", "value"];
function templateId(template2, i) {
  return quote(template2.id || template2.title) || typeof i == "number" && `at index ${i}` || "";
}
function quote(str) {
  return str && str.length > 0 ? `"${str}"` : str;
}
function validateTemplates(schema2, templates) {
  const idMap = /* @__PURE__ */ new Map();
  return templates.forEach((template2, i) => {
    const id2 = templateId(template2, i);
    if (typeof template2.values < "u" && !template2.value)
      throw new Error(`Template ${id2} is missing "value" property, but contained "values". Typo?`);
    const missing = REQUIRED_TEMPLATE_PROPS.filter((prop) => !template2[prop]);
    if (missing.length > 0)
      throw new Error(`Template ${id2} is missing required properties: ${missing.join(", ")}`);
    if (typeof template2.value != "function" && !isRecord(template2.value))
      throw new Error(
        `Template ${id2} has an invalid "value" property; should be a function or an object`
      );
    if (typeof template2.parameters < "u")
      if (Array.isArray(template2.parameters))
        template2.parameters.forEach((param, j) => validateParameter(schema2, param, template2, j));
      else
        throw new Error(`Template ${id2} has an invalid "parameters" property; must be an array`);
    if (idMap.has(template2.id)) {
      const dupeIndex = idMap.get(template2.id), dupe = `${quote(templates[dupeIndex].title)} at index ${dupeIndex}`;
      throw new Error(
        `Template "${template2.title}" at index ${i} has the same ID ("${template2.id}") as template ${dupe}`
      );
    }
    idMap.set(template2.id, i);
  }), templates;
}
function validateInitialObjectValue(value, template2) {
  const contextError = (msg) => `Template "${template2.id}" initial value: ${msg}`;
  if (!isRecord(value))
    throw new Error(contextError("resolved to a non-object"));
  if (value._type && template2.schemaType !== value._type)
    throw new Error(
      contextError(
        `includes "_type"-property (${value._type}) that does not match template (${template2.schemaType})`
      )
    );
  try {
    return validateValue(value);
  } catch (err) {
    throw err.message = contextError(err.message), err;
  }
}
function validateValue(value, path = [], parentIsArray = !1) {
  if (Array.isArray(value))
    return value.map((item, i) => {
      if (Array.isArray(item))
        throw new Error(
          `multidimensional arrays are not supported (at path "${PathUtils.toString(path)}")`
        );
      return validateValue(item, path.concat(i), !0);
    });
  if (!isRecord(value))
    return value;
  const initial = parentIsArray && !value._key ? { _key: content.randomKey() } : {};
  return path.length > 0 && !value._type && value._ref && (initial._type = "reference"), value._ref && validateReference(value, path), Object.keys(value).reduce((acc, key) => (acc[key] = validateValue(value[key], path.concat([key])), acc), initial);
}
function validateParameter(schema2, parameter, template2, index) {
  if (!parameter.name)
    throw new Error(
      `Template ${template2.id} has a parameter at index ${index} that is missing its "name"-property`
    );
  if (parameter.name === "template")
    throw new Error(
      `Template parameters cannot be named "template", see parameter #${index} for template ${template2.id}`
    );
  if (!schema2.get(parameter.type))
    throw new Error(
      `Template parameter "${parameter.name}" has an invalid/unknown type: "${parameter.type}"`
    );
}
function validateReference(value, path = []) {
  if (!value._type && value.type)
    throw new Error(
      `Reference is missing "_type", but has a "type" property at path "${PathUtils.toString(path)}"`
    );
  const disallowed = Object.keys(value).filter((key) => !ALLOWED_REF_PROPS.includes(key));
  if (disallowed.length > 0) {
    const plural = disallowed.length > 1 ? "properties" : "property";
    throw new Error(
      `Disallowed ${plural} found in reference: ${disallowed.map(quote).join(", ")} at path "${PathUtils.toString(path)}"`
    );
  }
}
function isBuilder(template2) {
  return isRecord(template2) && typeof template2.serialize == "function";
}
const cache$1 = /* @__PURE__ */ new WeakMap();
async function resolveValue(initialValueOpt, params, context, options) {
  var _a2;
  const useCache = options == null ? void 0 : options.useCache;
  if (typeof initialValueOpt == "function") {
    const cached = cache$1.get(initialValueOpt), key = JSON.stringify([
      params,
      context.projectId,
      context.dataset,
      (_a2 = context.currentUser) == null ? void 0 : _a2.id
    ]);
    if (useCache && cached != null && cached[key])
      return cached[key];
    const value = initialValueOpt(params, context);
    return useCache && cache$1.set(initialValueOpt, {
      ...cached,
      [key]: value
    }), value;
  }
  return initialValueOpt;
}
async function resolveInitialValue(schema2, template2, params = {}, context, options) {
  if (isBuilder(template2))
    return resolveInitialValue(schema2, template2.serialize(), params, context, options);
  const { id: id2, schemaType: schemaTypeName, value } = template2;
  if (!value)
    throw new Error(`Template "${id2}" has invalid "value" property`);
  let resolvedValue = await resolveValue(value, params, context, options);
  if (!isRecord(resolvedValue))
    throw new Error(
      `Template "${id2}" has invalid "value" property - must be a plain object or a resolver function returning a plain object`
    );
  isRecord(resolvedValue) && !Object.keys(resolvedValue).length && (resolvedValue = { _type: schemaTypeName }), resolvedValue = validateInitialObjectValue(resolvedValue, template2);
  const schemaType = schema2.get(schemaTypeName);
  if (!schemaType)
    throw new Error(`Could not find schema type with name "${schemaTypeName}".`);
  const newValue = deepAssign(
    await resolveInitialValueForType(
      schemaType,
      params,
      DEFAULT_MAX_RECURSION_DEPTH,
      context,
      options
    ) || {},
    resolvedValue
  );
  return validateInitialObjectValue(newValue, template2);
}
function getItemType$1(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
const DEFAULT_MAX_RECURSION_DEPTH = 10;
function resolveInitialValueForType(type, params, maxDepth = DEFAULT_MAX_RECURSION_DEPTH, context, options) {
  return maxDepth <= 0 ? Promise.resolve(void 0) : types.isObjectSchemaType(type) ? resolveInitialObjectValue(type, params, maxDepth, context, options) : types.isArraySchemaType(type) ? resolveInitialArrayValue(type, params, maxDepth, context, options) : resolveValue(type.initialValue, params, context, options);
}
async function resolveInitialArrayValue(type, params, maxDepth, context, options) {
  const initialArray = await resolveValue(type.initialValue, void 0, context, options);
  if (Array.isArray(initialArray))
    return Promise.all(
      initialArray.map(async (initialItem) => {
        const itemType = getItemType$1(type, initialItem);
        return types.isObjectSchemaType(itemType) ? {
          ...initialItem,
          ...await resolveInitialValueForType(itemType, params, maxDepth - 1, context, options),
          _key: content.randomKey()
        } : initialItem;
      })
    );
}
async function resolveInitialObjectValue(type, params, maxDepth, context, options) {
  const initialObject = {
    ...await resolveValue(type.initialValue, params, context, options) || {}
  }, fieldValues = {};
  await Promise.all(
    type.fields.map(async (field) => {
      const initialFieldValue = await resolveInitialValueForType(
        field.type,
        params,
        maxDepth - 1,
        context,
        options
      );
      initialFieldValue != null && (fieldValues[field.name] = initialFieldValue);
    })
  );
  const merged = deepAssign(fieldValues, initialObject);
  if (!content.isDeepEmpty(merged))
    return type.name !== "object" && (merged._type = type.name), merged;
}
function maybeSerialize(template2) {
  return isBuilder(template2) ? template2.serialize() : template2;
}
function isNonNullable(t2) {
  return !!t2;
}
function prepareTemplates(schema2, initialValueTemplates) {
  const serialized = initialValueTemplates.map(maybeSerialize);
  return validateTemplates(schema2, serialized);
}
function defaultTemplateForType(schemaType) {
  return {
    id: schemaType.name,
    schemaType: schemaType.name,
    title: schemaType.title || schemaType.name,
    icon: schemaType.icon,
    value: schemaType.initialValue || { _type: schemaType.name }
  };
}
function defaultTemplatesForSchema(schema2) {
  const schemaTypes = schema2.getTypeNames().filter((typeName) => !/^sanity\./.test(typeName)).map((typeName) => schema2.get(typeName)).filter(isNonNullable).filter((schemaType) => {
    var _a2;
    return ((_a2 = schemaType.type) == null ? void 0 : _a2.name) === "document";
  });
  return prepareTemplates(
    schema2,
    schemaTypes.map((schemaType) => defaultTemplateForType(schemaType))
  );
}
const LOADING_MSG = { type: "loading" };
function getInitialValueStream(schema2, initialValueTemplates, documentPreviewStore, opts, context) {
  const draft$ = documentPreviewStore.observePaths(
    { _type: "reference", _ref: getDraftId(opts.documentId) },
    ["_type"]
  ), published$ = documentPreviewStore.observePaths(
    { _type: "reference", _ref: getPublishedId(opts.documentId) },
    ["_type"]
  );
  return rxjs.merge(
    draft$.pipe(operators.map((draft) => ({ draft }))),
    published$.pipe(operators.map((published) => ({ published })))
  ).pipe(
    operators.scan((prev, res) => ({ ...prev, ...res }), {}),
    // Wait until we know the state of both draft and published
    operators.filter((res) => "draft" in res && "published" in res),
    operators.map((res) => res.draft || res.published),
    // Only update if we didn't previously have a document but we now do
    operators.distinctUntilChanged((prev, next) => !!prev != !!next),
    // Prevent rapid re-resolving when transitioning between different templates
    operators.debounceTime(25)
  ).pipe(
    operators.switchMap((document2) => {
      if (document2)
        return rxjs.of({ type: "success", value: null });
      if (!opts.templateName)
        return rxjs.of({ isResolving: !1, initialValue: void 0 });
      const template2 = initialValueTemplates.find((t2) => t2.id === opts.templateName);
      if (!template2)
        return console.warn('Template "%s" not defined, using empty initial value', opts.templateName), rxjs.of({ isResolving: !1, initialValue: void 0 });
      const initialValueWithParams$ = rxjs.from(
        resolveInitialValue(schema2, template2, opts.templateParams, context)
      ).pipe(operators.map((initialValue) => ({ isResolving: !1, initialValue }))).pipe(
        operators.catchError((resolveError) => (console.group("Failed to resolve initial value"), console.error(resolveError), console.error("Template ID: %s", opts.templateName), console.error("Parameters: %o", opts.templateParams), console.groupEnd(), rxjs.of({ type: "error", error: resolveError })))
      );
      return rxjs.merge(rxjs.of({ isResolving: !0 }), initialValueWithParams$).pipe(
        operators.switchMap(({ isResolving, initialValue, resolveError }) => resolveError ? rxjs.of({ type: "error", message: "Failed to resolve initial value" }) : isResolving ? rxjs.of(LOADING_MSG) : rxjs.of({ type: "success", value: initialValue }))
      );
    }),
    operators.startWith(LOADING_MSG),
    operators.distinctUntilChanged()
  );
}
const fetch$1 = (client2, query, params, options) => rxjs.defer(
  () => client2.observable.fetch(query, params, {
    tag: options.tag,
    filterResponse: !0,
    perspective: options.perspective
  })
), listen = (client2, query, params, options) => rxjs.defer(
  () => client2.listen(query, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeResult: !1,
    visibility: "query",
    tag: options.tag
  })
);
function isWelcomeEvent(event) {
  return event.type === "welcome";
}
function listenQuery(client2, query, params = {}, options = {}) {
  const fetchQuery = typeof query == "string" ? query : query.fetch, listenerQuery = typeof query == "string" ? query : query.listen, events$ = listen(client2, listenerQuery, params, options).pipe(
    operators.mergeMap((ev, i) => i === 0 && !isWelcomeEvent(ev) ? rxjs.throwError(
      () => new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : rxjs.of(ev)),
    operators.share()
  ), [welcome$, mutationAndReconnect$] = rxjs.partition(events$, isWelcomeEvent), isRelevantEvent = (event) => !options.transitions || event.type !== "mutation" ? !0 : options.transitions.includes(event.transition), doFetch = () => fetch$1(client2, fetchQuery, params, options);
  return rxjs.merge(
    welcome$.pipe(operators.take(1)),
    mutationAndReconnect$.pipe(
      operators.filter(isRelevantEvent),
      operators.throttleTime(options.throttleTime || 1e3, rxjs.asyncScheduler, { leading: !0, trailing: !0 })
    )
  ).pipe(
    rxjsExhaustmapWithTrailing.exhaustMapWithTrailing((event) => event.type === "mutation" && event.visibility !== "query" ? rxjs.timer(1200).pipe(operators.mergeMap(doFetch)) : doFetch())
  );
}
function resolveTypeForDocument(client2, id2, specifiedType = "*") {
  if (specifiedType && specifiedType !== "*")
    return rxjs.of(specifiedType);
  const query = "*[_id in [$documentId, $draftId]]._type", documentId = getPublishedId(id2), draftId = getDraftId(documentId);
  return client2.observable.fetch(query, { documentId, draftId }).pipe(operators.map((types2) => types2[0]));
}
function getIdPairFromPublished(publishedId) {
  if (isDraftId(publishedId))
    throw new Error("editOpsOf does not expect a draft id.");
  return { publishedId, draftId: getDraftId(publishedId) };
}
function createDocumentStore({
  getClient,
  documentPreviewStore,
  historyStore,
  initialValueTemplates,
  schema: schema2,
  i18n,
  serverActionsEnabled
}) {
  const observeDocumentPairAvailability = documentPreviewStore.unstable_observeDocumentPairAvailability, client2 = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), ctx = {
    client: client2,
    getClient,
    observeDocumentPairAvailability,
    historyStore,
    schema: schema2,
    i18n,
    serverActionsEnabled
  };
  return {
    // Public API
    checkoutPair(idPair) {
      return checkoutPair(client2, idPair, serverActionsEnabled);
    },
    initialValue(opts, context) {
      return getInitialValueStream(
        schema2,
        initialValueTemplates,
        documentPreviewStore,
        opts,
        context
      );
    },
    listenQuery(query, params, options) {
      return listenQuery(client2, query, params, options);
    },
    resolveTypeForDocument(id2, specifiedType) {
      return resolveTypeForDocument(client2, id2, specifiedType);
    },
    pair: {
      consistencyStatus(publishedId, type) {
        return consistencyStatus(
          ctx.client,
          getIdPairFromPublished(publishedId),
          type,
          serverActionsEnabled
        );
      },
      documentEvents(publishedId, type) {
        return documentEvents(
          ctx.client,
          getIdPairFromPublished(publishedId),
          type,
          serverActionsEnabled
        );
      },
      editOperations(publishedId, type) {
        return editOperations(ctx, getIdPairFromPublished(publishedId), type);
      },
      editState(publishedId, type) {
        return editState(ctx, getIdPairFromPublished(publishedId), type);
      },
      operationEvents(publishedId, type) {
        return operationEvents({
          client: client2,
          historyStore,
          schema: schema2,
          serverActionsEnabled
        }).pipe(
          operators.filter(
            (result) => result.args.idPair.publishedId === publishedId && result.args.typeName === type
          ),
          operators.map((result) => {
            const { operationName, idPair: documentIds } = result.args;
            return result.type === "success" ? { type: "success", op: operationName, id: documentIds.publishedId } : { type: "error", op: operationName, id: documentIds.publishedId, error: result.error };
          })
        );
      },
      validation(publishedId, type) {
        return validation(ctx, getIdPairFromPublished(publishedId), type);
      }
    }
  };
}
const LOADING_STATE = {
  isLoaded: !1,
  documentType: void 0
};
function useDocumentType(documentId, specifiedType = "*") {
  const documentStore = useDocumentStore(), publishedId = getPublishedId(documentId), isResolved = !!(specifiedType && specifiedType !== "*"), SYNC_RESOLVED_STATE = React.useMemo(
    () => ({ documentType: specifiedType, isLoaded: !0 }),
    [specifiedType]
  ), [resolvedState, setDocumentType] = React.useState(
    isResolved ? SYNC_RESOLVED_STATE : LOADING_STATE
  );
  return React.useEffect(() => setDocumentType(LOADING_STATE), [publishedId, specifiedType]), React.useEffect(() => {
    if (isResolved)
      return;
    const sub = documentStore.resolveTypeForDocument(publishedId, specifiedType).subscribe((documentType) => setDocumentType({ documentType, isLoaded: !0 }));
    return () => sub.unsubscribe();
  }, [documentStore, publishedId, specifiedType, isResolved]), isResolved ? (
    // `isResolved` is only true when we're _synchronously_ resolved
    SYNC_RESOLVED_STATE
  ) : (
    // Using the document type resolved from the API
    resolvedState
  );
}
function useDocumentValues(documentId, paths) {
  const documentPreviewStore = useDocumentPreviewStore(), documentValues$ = React.useMemo(
    () => documentId ? documentPreviewStore.observePaths(
      { _type: "reference", _ref: documentId },
      paths
    ) : rxjs.of(void 0),
    [documentId, documentPreviewStore, paths]
  );
  return useLoadable(documentValues$);
}
function useInitialValue(props2) {
  const { documentId, documentType, templateName, templateParams: templateParamsRaw } = props2, templateParams = useUnique(templateParamsRaw), documentStore = useDocumentStore(), context = useInitialValueResolverContext(), defaultValue2 = React.useMemo(
    () => ({ _id: documentId, _type: documentType }),
    [documentId, documentType]
  ), [state, setState] = React.useState({
    loading: !1,
    error: null,
    value: defaultValue2
  });
  return React.useEffect(() => {
    const initialValueOptions = { documentId, documentType, templateName, templateParams };
    if (!templateName) {
      setState({ loading: !0, error: null, value: defaultValue2 });
      return;
    }
    const sub = documentStore.initialValue(initialValueOptions, context).subscribe((msg) => {
      msg.type === "loading" && setState({ loading: !0, error: null, value: defaultValue2 }), msg.type === "success" && setState({
        loading: !1,
        error: null,
        value: msg.value ? { ...defaultValue2, ...msg.value } : defaultValue2
      }), msg.type === "error" && setState({ loading: !1, error: msg.error, value: defaultValue2 });
    });
    return setState({ loading: !0, error: null, value: defaultValue2 }), () => sub.unsubscribe();
  }, [defaultValue2, documentId, documentStore, documentType, templateName, templateParams, context]), state;
}
function useInitialValueResolverContext() {
  const source = useSource(), schema2 = useSchema(), currentUser = useCurrentUser(), projectId = useProjectId(), dataset = useDataset(), getClient = source.getClient;
  return React.useMemo(() => ({
    projectId,
    dataset,
    getClient,
    schema: schema2,
    currentUser
  }), [getClient, schema2, currentUser, projectId, dataset]);
}
function useResolveInitialValueForType() {
  const initialValueContext = useInitialValueResolverContext();
  return React.useCallback(
    (type, params) => resolveInitialValueForType(
      type,
      params,
      DEFAULT_MAX_RECURSION_DEPTH,
      initialValueContext
    ),
    [initialValueContext]
  );
}
const fetchFeatureToggle = (defaultClient) => {
  const client2 = defaultClient.withConfig({ apiVersion: "X" }), { dataset } = defaultClient.config();
  return client2.observable.request({
    uri: `/data/actions/${dataset}`,
    withCredentials: !0
  }).pipe(
    rxjs.map((res) => res.actions),
    rxjs.timeout({ first: 2e3, with: () => rxjs.of(!1) }),
    operators.catchError(
      () => (
        // If we fail to fetch the feature toggle, we'll just assume it's disabled and fallback to legacy mutations
        rxjs.of(!1)
      )
    ),
    operators.share({
      // replay latest known state to new subscribers
      connector: () => new rxjs.ReplaySubject(1),
      // this will typically be completed and unsubscribed from right after the answer is received, so we don't want to reset
      resetOnRefCountZero: !1,
      // once the fetch has completed, we'll wait for 2 minutes before resetting the state.
      // we'll then check again once a new subscriber comes in
      resetOnComplete: () => rxjs.timer(1e3 * 120)
    })
  );
};
function getSchemaType(schema2, typeName) {
  const type = schema2.get(typeName);
  if (!type)
    throw new Error(`No such schema type: ${typeName}`);
  return type;
}
function getPairPermissions({
  grantsStore,
  permission,
  draft,
  published,
  liveEdit
}) {
  const effectiveVersion = draft || published, effectiveVersionType = effectiveVersion === draft ? "draft" : "published", { checkDocumentPermission } = grantsStore;
  switch (permission) {
    case "delete":
      return liveEdit ? [
        ["delete published document (live-edit)", checkDocumentPermission("update", published)]
      ] : [
        ["delete draft document", checkDocumentPermission("update", draft)],
        ["delete published document", checkDocumentPermission("update", published)]
      ];
    case "discardDraft":
      return liveEdit ? [] : [["delete draft document", checkDocumentPermission("update", draft)]];
    case "publish":
      return liveEdit ? [] : [
        // precondition
        [
          "update published document at its current state",
          checkDocumentPermission("update", published)
        ],
        // post condition
        ["delete draft document", checkDocumentPermission("update", draft)],
        [
          "create published document from draft",
          checkDocumentPermission("create", draft && { ...draft, _id: getPublishedId(draft._id) })
        ]
      ];
    case "unpublish":
      return liveEdit ? [] : [
        // precondition
        ["update draft document at its current state", checkDocumentPermission("create", draft)],
        // post condition
        ["delete published document", checkDocumentPermission("update", published)],
        [
          "create draft document from published version",
          checkDocumentPermission(
            "create",
            published && { ...published, _id: getDraftId(published._id) }
          )
        ]
      ];
    case "update":
      return liveEdit ? [
        ["update published document (live-edit)", checkDocumentPermission("update", published)]
      ] : [
        [
          `update ${effectiveVersionType} document`,
          checkDocumentPermission("update", effectiveVersion)
        ]
      ];
    case "duplicate":
      return liveEdit ? [
        [
          "create new published document from existing document (live-edit)",
          checkDocumentPermission("create", { ...published, _id: "dummy-id" })
        ]
      ] : [
        [
          `create new draft document from existing ${effectiveVersionType} document`,
          checkDocumentPermission("create", { ...effectiveVersion, _id: getDraftId("dummy-id") })
        ]
      ];
    default:
      throw new Error(`Could not match permission: ${permission}`);
  }
}
function getDocumentPairPermissions({
  client: client2,
  grantsStore,
  schema: schema2,
  id: id2,
  permission,
  type,
  serverActionsEnabled
}) {
  if (type === "*")
    return rxjs.of({ granted: !1, reason: "Type specified was `*`" });
  const liveEdit = !!getSchemaType(schema2, type).liveEdit;
  return snapshotPair(
    client2,
    { draftId: getDraftId(id2), publishedId: getPublishedId(id2) },
    type,
    serverActionsEnabled
  ).pipe(
    operators.switchMap(
      (pair) => rxjs.combineLatest([pair.draft.snapshots$, pair.published.snapshots$]).pipe(
        operators.map(([draft, published]) => ({ draft, published }))
      )
    ),
    operators.switchMap(({ draft, published }) => {
      const pairPermissions = getPairPermissions({
        grantsStore,
        permission,
        draft,
        published,
        liveEdit
      }).map(
        ([label, observable]) => observable.pipe(
          operators.map(({ granted, reason }) => ({
            granted,
            reason: granted ? "" : `not allowed to ${label}: ${reason}`,
            label,
            permission
          }))
        )
      );
      return pairPermissions.length ? rxjs.combineLatest(pairPermissions).pipe(
        operators.map((permissionResults) => {
          const granted = permissionResults.every((permissionResult) => permissionResult.granted), reason = granted ? "" : `Unable to ${permission}:
	${permissionResults.filter((permissionResult) => !permissionResult.granted).map((permissionResult) => permissionResult.reason).join(`
	`)}`;
          return { granted, reason };
        })
      ) : rxjs.of({ granted: !0, reason: "" });
    })
  );
}
const useDocumentPairPermissionsFromHookFactory = createHookFromObservableFactory(
  getDocumentPairPermissions
);
function useDocumentPairPermissions({
  id: id2,
  type,
  permission,
  client: overrideClient,
  schema: overrideSchema,
  grantsStore: overrideGrantsStore
}) {
  var _a2;
  const defaultClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), defaultSchema = useSchema(), defaultGrantsStore = useGrantsStore(), workspace = useWorkspace(), client2 = React.useMemo(() => overrideClient || defaultClient, [defaultClient, overrideClient]), schema2 = React.useMemo(() => overrideSchema || defaultSchema, [defaultSchema, overrideSchema]), grantsStore = React.useMemo(
    () => overrideGrantsStore || defaultGrantsStore,
    [defaultGrantsStore, overrideGrantsStore]
  ), serverActionsEnabled = React.useMemo(() => {
    var _a22;
    const configFlag = (_a22 = workspace.__internal_serverDocumentActions) == null ? void 0 : _a22.enabled;
    return typeof configFlag == "boolean" ? rxjs.of(configFlag) : fetchFeatureToggle(client2);
  }, [client2, (_a2 = workspace.__internal_serverDocumentActions) == null ? void 0 : _a2.enabled]);
  return useDocumentPairPermissionsFromHookFactory(
    React.useMemo(
      () => ({ client: client2, schema: schema2, grantsStore, id: id2, permission, type, serverActionsEnabled }),
      [client2, grantsStore, id2, permission, schema2, type, serverActionsEnabled]
    )
  );
}
function getDocumentValuePermissions({
  grantsStore,
  document: document2,
  permission
}) {
  const { checkDocumentPermission } = grantsStore;
  return checkDocumentPermission(permission, document2);
}
const useDocumentValuePermissionsFromHookFactory = createHookFromObservableFactory(
  getDocumentValuePermissions
);
function useDocumentValuePermissions({
  document: document2,
  permission,
  ...rest
}) {
  const grantsStore = useGrantsStore();
  return useDocumentValuePermissionsFromHookFactory({
    grantsStore: rest.grantsStore || grantsStore,
    document: document2,
    permission
  });
}
function refCountDelay(duration, scheduler = rxjs.asapScheduler) {
  return (source) => {
    const connectable = source;
    let connectableSubscription = null, connectorSubscription = null;
    const notifier = new rxjs.Subject(), connector = notifier.pipe(operators.scan((count, step) => count + step, 0), operators.switchMap((count) => count === 0 ? rxjs.timer(duration, scheduler).pipe(operators.tap(() => {
      connectableSubscription && (connectableSubscription.unsubscribe(), connectableSubscription = null), connectorSubscription && (connectorSubscription.unsubscribe(), connectorSubscription = null);
    })) : !connectableSubscription && count > 0 ? rxjs.timer(0, scheduler).pipe(operators.tap(() => {
      connectableSubscription || (connectableSubscription = connectable.connect());
    })) : rxjs.NEVER));
    return rxjs.using(() => (connectorSubscription || (connectorSubscription = connector.subscribe()), notifier.next(1), { unsubscribe: () => notifier.next(-1) }), () => source);
  };
}
const DEBUG_PREFIX = "_debug_", hashchange$ = typeof window > "u" ? rxjs.of({}) : rxjs.fromEvent(window, "hashchange"), debugParams$ = rxjs.concat(rxjs.of(0), hashchange$).pipe(
  operators.map(() => typeof document > "u" ? "#" : document.location.hash),
  operators.distinctUntilChanged(),
  operators.map(
    (hash2) => hash2.slice(1).split(";").filter((p) => p.toLowerCase().startsWith(DEBUG_PREFIX)).map((param) => param.slice(DEBUG_PREFIX.length))
  )
), debugRolesParam$ = debugParams$.pipe(
  operators.map((args) => args.find((arg) => arg.startsWith("roles="))),
  operators.map(
    (arg) => (arg == null ? void 0 : arg.split("roles=")[1].split(",").map((r) => r.trim())) || []
  )
), administrator = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "create", "history", "update"]
  }
], editor = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "create", "history", "update"]
  }
], developer = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "create", "history", "update"]
  }
], contributor = [
  {
    filter: '_id in path("**")',
    permissions: ["read"]
  },
  {
    filter: '_id in path("drafts.**")',
    permissions: ["create", "history", "update"]
  }
], viewer = [
  {
    filter: '_id in path("**")',
    permissions: ["read", "history"]
  }
], requiresApproval = [
  {
    filter: "!locked",
    permissions: ["read", "create", "update"]
  }
], restricted = [
  {
    filter: '_id in path("drafts.**") && _type in ["stringsTest", "book", "author", "referenceTest"]',
    permissions: ["read", "create", "history", "update"]
  },
  {
    filter: '_id in path("**")',
    permissions: ["read"]
  }
], DEBUG_ROLE_GRANTS_MAP = {
  // basic
  administrator,
  editor,
  developer,
  contributor,
  viewer,
  // custom
  restricted,
  requiresApproval,
  // legacy
  read: viewer,
  write: editor
}, debugGrants$ = debugRolesParam$.pipe(
  operators.map((roles) => roles.length ? roles.filter((value) => !!value && value in DEBUG_ROLE_GRANTS_MAP).flatMap((roleName) => DEBUG_ROLE_GRANTS_MAP[roleName] || []) : null)
);
async function getDatasetGrants(client2, projectId, dataset) {
  return await client2.request({
    uri: `/projects/${projectId}/datasets/${dataset}/acl`,
    tag: "acl.get",
    withCredentials: !0
  });
}
function getParams(userId) {
  const params = {};
  return userId !== null && (params.identity = userId), params;
}
const PARSED_FILTERS_MEMO = /* @__PURE__ */ new Map();
async function matchesFilter(userId, filter, document2) {
  PARSED_FILTERS_MEMO.has(filter) || PARSED_FILTERS_MEMO.set(filter, groqJs.parse(`*[${filter}]`));
  const parsed = PARSED_FILTERS_MEMO.get(filter), evalParams = getParams(userId), { identity: identity2 } = evalParams, params = { ...evalParams }, data = await (await groqJs.evaluate(parsed, { dataset: [document2], identity: identity2, params })).get();
  return (data == null ? void 0 : data.length) === 1;
}
function createGrantsStore(opts) {
  var _a2;
  const { client: client2 } = opts, versionedClient = client2.withConfig({ apiVersion: "2021-06-07" }), userId = "userId" in opts ? opts.userId : ((_a2 = opts == null ? void 0 : opts.currentUser) == null ? void 0 : _a2.id) || null, datasetGrants$ = rxjs.defer(() => rxjs.of(versionedClient.config())).pipe(
    operators.switchMap(({ projectId, dataset }) => {
      if (!projectId || !dataset)
        throw new Error("Missing projectId or dataset");
      return getDatasetGrants(versionedClient, projectId, dataset);
    })
  ), currentUserDatasetGrants = debugGrants$.pipe(
    operators.switchMap((debugGrants) => debugGrants ? rxjs.of(debugGrants) : datasetGrants$),
    operators.publishReplay(1),
    refCountDelay(1e3)
  );
  return {
    checkDocumentPermission(permission, document2) {
      return currentUserDatasetGrants.pipe(
        operators.switchMap((grants) => grantsPermissionOn(userId, grants, permission, document2)),
        operators.distinctUntilChanged(shallowEquals__default.default)
      );
    }
  };
}
async function grantsPermissionOn(userId, grants, permission, document2) {
  if (!document2)
    return { granted: !0, reason: "Null document, nothing to check" };
  if (!grants.length)
    return { granted: !1, reason: "No document grants" };
  const matchingGrants = [];
  for (const grant of grants)
    await matchesFilter(userId, grant.filter, document2) && matchingGrants.push(grant);
  const foundMatch = matchingGrants.some((grant) => grant.permissions.some((p) => p === permission));
  return {
    granted: foundMatch,
    reason: foundMatch ? "Matching grant" : "No matching grants found"
  };
}
function serialize$3(item) {
  return typeof item == "object" && item !== null && "serialize" in item ? serialize$3(item.serialize()) : item;
}
function getTemplatePermissions({
  grantsStore,
  templateItems,
  templates,
  schema: schema2,
  context
}) {
  return templateItems != null && templateItems.length ? rxjs.combineLatest(
    templateItems.map(serialize$3).map(async (item) => {
      const template2 = templates.find((t2) => t2.id === item.templateId);
      if (!template2)
        throw new Error(`template not found: "${item.templateId}"`);
      const resolvedInitialValue = await resolveInitialValue(
        schema2,
        template2,
        item.parameters,
        context,
        {
          useCache: !0
        }
      );
      return { template: template2, item, resolvedInitialValue };
    }).map(
      (promise) => rxjs.from(promise).pipe(
        operators.switchMap(({ item, resolvedInitialValue, template: template2 }) => {
          const schemaType = schema2.get(template2.schemaType);
          if (!schemaType)
            throw new Error(`schema type not found: "${template2.schemaType}"`);
          const liveEdit = schemaType == null ? void 0 : schemaType.liveEdit, { initialDocumentId = "dummy-id" } = item;
          return getDocumentValuePermissions({
            grantsStore,
            permission: "create",
            document: {
              _id: liveEdit ? getPublishedId(initialDocumentId) : getDraftId(initialDocumentId),
              ...resolvedInitialValue
            }
          }).pipe(
            operators.map(({ granted, reason }) => {
              const title = item.title || template2.title;
              return {
                ...item,
                i18n: item.i18n || template2.i18n,
                granted,
                reason,
                resolvedInitialValue,
                template: template2,
                title,
                subtitle: schemaType.title === title ? void 0 : schemaType.title,
                description: item.description || template2.description,
                icon: item.icon || template2.icon
              };
            })
          );
        })
      )
    )
  ) : rxjs.of([]);
}
const useTemplatePermissionsFromHookFactory = createHookFromObservableFactory(getTemplatePermissions);
function useTemplatePermissions({
  templateItems,
  ...rest
}) {
  const schema2 = useSchema(), templates = useTemplates(), grantsStore = useGrantsStore(), initialValueContext = useInitialValueResolverContext();
  return useTemplatePermissionsFromHookFactory({
    templateItems,
    grantsStore: rest.grantsStore || grantsStore,
    schema: rest.schema || schema2,
    templates: rest.templates || templates,
    context: initialValueContext
  });
}
function canMergeEdit(type) {
  return type === "create" || type === "editDraft";
}
const CHUNK_WINDOW = 5 * 60 * 1e3;
function isWithinMergeWindow(a, b) {
  return Date.parse(b) - Date.parse(a) < CHUNK_WINDOW;
}
function mergeChunk(left, right) {
  if (left.end !== right.start) throw new Error("chunks are not next to each other");
  const draftState = combineState(left.draftState, right.draftState), publishedState = combineState(left.publishedState, right.publishedState);
  if (left.type === "delete" && right.type === "editDraft")
    return [left, { ...right, type: "create", draftState, publishedState }];
  if (right.type === "delete") {
    if (draftState === "missing" && publishedState === "present")
      return [left, { ...right, type: "discardDraft", draftState, publishedState }];
    if (draftState === "present" && publishedState === "missing")
      return [left, { ...right, type: "unpublish", draftState, publishedState }];
  }
  if (canMergeEdit(left.type) && right.type === "editDraft" && isWithinMergeWindow(left.endTimestamp, right.startTimestamp)) {
    const authors = /* @__PURE__ */ new Set();
    for (const author of left.authors) authors.add(author);
    for (const author of right.authors) authors.add(author);
    return {
      index: 0,
      id: right.id,
      type: left.type,
      start: left.start,
      end: right.end,
      startTimestamp: left.startTimestamp,
      endTimestamp: right.endTimestamp,
      authors,
      draftState,
      publishedState
    };
  }
  return [left, { ...right, draftState, publishedState }];
}
function getChunkState(effect) {
  const modified = !!effect;
  return effect && isDeletePatch(effect == null ? void 0 : effect.apply) ? "deleted" : modified ? "upsert" : "unedited";
}
function getChunkType(transaction) {
  const draftState = getChunkState(transaction.draftEffect), publishedState = getChunkState(transaction.publishedEffect);
  if (publishedState === "unedited") {
    if (draftState === "deleted")
      return "delete";
    if (draftState === "upsert")
      return "editDraft";
  }
  if (publishedState === "deleted")
    return "delete";
  if (publishedState === "upsert") {
    if (draftState === "unedited")
      return "editLive";
    if (draftState === "deleted")
      return "publish";
    if (draftState === "upsert")
      return "editLive";
  }
  return "editLive";
}
function chunkFromTransaction(transaction) {
  const modifiedDraft = !!transaction.draftEffect, modifiedPublished = !!transaction.publishedEffect, draftDeleted = transaction.draftEffect && isDeletePatch(transaction.draftEffect.apply), publishedDeleted = transaction.publishedEffect && isDeletePatch(transaction.publishedEffect.apply), type = getChunkType(transaction);
  return {
    index: 0,
    id: transaction.id,
    type,
    start: transaction.index,
    end: transaction.index + 1,
    startTimestamp: transaction.timestamp,
    endTimestamp: transaction.timestamp,
    authors: /* @__PURE__ */ new Set([transaction.author]),
    draftState: modifiedDraft ? draftDeleted ? "missing" : "present" : "unknown",
    publishedState: modifiedPublished ? publishedDeleted ? "missing" : "present" : "unknown"
  };
}
function combineState(left, right) {
  return right === "unknown" ? left : right;
}
function isDeletePatch(patch2) {
  return patch2[0] === 0 && patch2[1] === null;
}
function isSameAnnotation(a, b) {
  return a && b ? a.author === b.author && a.chunk === b.chunk : !a && !b;
}
function getAttrs$1(doc) {
  return doc.draft || doc.published;
}
var __defProp$5 = Object.defineProperty, __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key != "symbol" ? key + "" : key, value);
class ArrayContentWrapper {
  constructor(content2, value, annotation, extractor) {
    __publicField$5(this, "type", "array"), __publicField$5(this, "value"), __publicField$5(this, "length"), __publicField$5(this, "annotation"), __publicField$5(this, "extractor"), __publicField$5(this, "content"), __publicField$5(this, "elements", []), this.content = content2, this.value = value, this.annotation = annotation, this.extractor = extractor, this.length = content2.elements.length;
  }
  at(idx) {
    if (idx >= this.length) throw new Error("out of bounds");
    return this.elements[idx] || (this.elements[idx] = wrapValue(
      this.content.elements[idx],
      this.value[idx],
      this.extractor
    ));
  }
  annotationAt(idx) {
    const meta = this.content.metas[idx];
    return this.extractor.fromMeta(meta);
  }
}
class ObjectContentWrapper {
  constructor(content2, value, annotation, extractor) {
    __publicField$5(this, "type", "object"), __publicField$5(this, "value"), __publicField$5(this, "keys"), __publicField$5(this, "annotation"), __publicField$5(this, "extractor"), __publicField$5(this, "content"), __publicField$5(this, "fields", {}), this.content = content2, this.value = value, this.annotation = annotation, this.extractor = extractor, this.keys = Object.keys(content2.fields);
  }
  get(key) {
    const input = this.fields[key];
    if (input)
      return input;
    const value = this.content.fields[key];
    if (value)
      return this.fields[key] = wrapValue(value, this.value[key], this.extractor);
  }
}
class StringContentWrapper {
  constructor(content2, value, annotation, extractor) {
    __publicField$5(this, "type", "string"), __publicField$5(this, "value"), __publicField$5(this, "annotation"), __publicField$5(this, "extractor"), __publicField$5(this, "content"), this.content = content2, this.value = value, this.annotation = annotation, this.extractor = extractor;
  }
  sliceAnnotation(start, end) {
    const result = [];
    let idx = 0;
    function push(text, annotation) {
      if (result.length > 0) {
        const lst = result[result.length - 1];
        if (isSameAnnotation(lst.annotation, annotation)) {
          lst.text += text;
          return;
        }
      }
      result.push({ text, annotation });
    }
    for (const part of this.content.parts) {
      const length = part.value.length, subStart = Math.max(0, start - idx);
      if (subStart < length) {
        const subEnd = Math.min(length, end - idx);
        if (subEnd <= 0) break;
        push(part.value.slice(subStart, subEnd), this.extractor.fromValue(part));
      }
      idx += length;
    }
    return result;
  }
}
function wrapValue(value, raw, extractor) {
  const annotation = extractor.fromValue(value);
  if (value.content)
    switch (value.content.type) {
      case "array":
        return new ArrayContentWrapper(value.content, raw, annotation, extractor);
      case "object":
        return new ObjectContentWrapper(
          value.content,
          raw,
          annotation,
          extractor
        );
      case "string":
        return new StringContentWrapper(value.content, raw, annotation, extractor);
    }
  return diff.wrap(raw, annotation);
}
function extractAnnotationForFromInput(timeline, firstChunk, meta) {
  return meta ? annotationForTransactionIndex(timeline, meta.transactionIndex + 1, meta.chunk.index) : firstChunk ? annotationForTransactionIndex(timeline, firstChunk.start, firstChunk.index) : null;
}
function extractAnnotationForToInput(timeline, meta) {
  return meta ? annotationForTransactionIndex(timeline, meta.transactionIndex, meta.chunk.index) : null;
}
function annotationForTransactionIndex(timeline, idx, chunkIdx) {
  const tx = timeline.transactionByIndex(idx);
  if (!tx) return null;
  const chunk = timeline.chunkByTransactionIndex(idx, chunkIdx);
  return chunk ? {
    chunk,
    timestamp: tx.timestamp,
    author: tx.author
  } : null;
}
function diffValue(timeline, firstChunk, from, fromRaw, to, toRaw) {
  const fromInput = wrapValue(from, fromRaw, {
    fromValue(value) {
      return extractAnnotationForFromInput(timeline, firstChunk, value.endMeta);
    },
    fromMeta(meta) {
      return extractAnnotationForFromInput(timeline, firstChunk, meta);
    }
  }), toInput = wrapValue(to, toRaw, {
    fromValue(value) {
      return extractAnnotationForToInput(timeline, value.startMeta);
    },
    fromMeta(meta) {
      return extractAnnotationForToInput(timeline, meta);
    }
  });
  return diff.diffInput(fromInput, toInput);
}
var __defProp$4 = Object.defineProperty, __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key != "symbol" ? key + "" : key, value);
class TwoEndedArray {
  constructor() {
    __publicField$4(this, "_postive", []), __publicField$4(this, "_negative", []);
  }
  addToEnd(elem) {
    elem.index = this._postive.length, this._postive.push(elem);
  }
  addToBeginning(elem) {
    if (this.length == 0) {
      this.addToEnd(elem);
      return;
    }
    elem.index = -(this._negative.length + 1), this._negative.push(elem);
  }
  mergeAtEnd(value, merger) {
    if (this.length === 0) {
      this.addToEnd(value);
      return;
    }
    const idx = this.lastIdx, result = merger(this.get(idx), value);
    Array.isArray(result) ? (this.set(idx, result[0]), this.addToEnd(result[1])) : this.set(idx, result);
  }
  mergeAtBeginning(value, merger) {
    if (this.length === 0) {
      this.addToEnd(value);
      return;
    }
    const idx = this.firstIdx, result = merger(value, this.get(idx));
    Array.isArray(result) ? (this.set(idx, result[1]), this.addToBeginning(result[0])) : this.set(idx, result);
  }
  removeFromEnd() {
    this._postive.length === 0 ? this._negative.shift() : this._postive.pop();
  }
  has(idx) {
    return idx >= 0 ? idx < this._postive.length : -(idx + 1) < this._negative.length;
  }
  get(idx) {
    return idx >= 0 ? this._postive[idx] : this._negative[-(idx + 1)];
  }
  set(idx, value) {
    idx >= 0 ? (value.index = idx, this._postive[idx] = value) : (value.index = idx, this._negative[-(idx + 1)] = value);
  }
  get lastIdx() {
    return this._postive.length - 1;
  }
  get last() {
    return this.get(this.lastIdx);
  }
  get firstIdx() {
    return -this._negative.length;
  }
  get first() {
    return this.get(this.firstIdx);
  }
  get length() {
    return this._postive.length + this._negative.length;
  }
}
var __defProp$3 = Object.defineProperty, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key != "symbol" ? key + "" : key, value);
class Timeline {
  constructor(opts) {
    __publicField$3(this, "reachedEarliestEntry", !1), __publicField$3(this, "publishedId"), __publicField$3(this, "draftId"), __publicField$3(this, "_transactions", new TwoEndedArray()), __publicField$3(this, "_chunks", new TwoEndedArray()), __publicField$3(this, "_possiblePendingTransactions", /* @__PURE__ */ new Map()), __publicField$3(this, "_recreateTransactionsFrom"), __publicField$3(this, "_trace"), this.publishedId = opts.publishedId, this.draftId = `drafts.${opts.publishedId}`, opts.enableTrace && (this._trace = [], this._trace.push({
      type: "initial",
      publishedId: opts.publishedId
    }), window.__sanityTimelineTrace = this._trace);
  }
  get chunkCount() {
    return this._chunks.length;
  }
  /** Maps over the chunk from newest to oldest. */
  mapChunks(mapper) {
    const result = [], firstIdx = this._chunks.firstIdx, lastIdx = this._chunks.lastIdx;
    for (let idx = lastIdx; idx >= firstIdx; idx--)
      result.push(mapper(this._chunks.get(idx), idx));
    return result;
  }
  reset() {
    this._transactions = new TwoEndedArray(), this._chunks = new TwoEndedArray(), this._possiblePendingTransactions = /* @__PURE__ */ new Map(), this._recreateTransactionsFrom = void 0, this.reachedEarliestEntry = !1;
  }
  /**
   * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
   * come in correct order for their respective version, but has no ordering requirements
   * across draft/published.
   *
   * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
   * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
   * the mutation for the draft is out of order.
   */
  addRemoteMutation(entry) {
    this._trace && this._trace.push({ type: "addRemoteMutation", event: entry });
    const pending = this._possiblePendingTransactions.get(entry.transactionId), transaction = pending ? pending.transaction : {
      index: 0,
      id: entry.transactionId,
      timestamp: entry.timestamp.toISOString(),
      author: entry.author
    };
    entry.version === "draft" ? transaction.draftEffect = entry.effects : transaction.publishedEffect = entry.effects, pending ? (this._possiblePendingTransactions.delete(entry.transactionId), this._invalidateTransactionFrom(pending.idx)) : (this._transactions.addToEnd(transaction), this._possiblePendingTransactions.set(entry.transactionId, {
      transaction,
      idx: this._transactions.lastIdx
    }));
  }
  addTranslogEntry(event) {
    this._trace && this._trace.push({ type: "addTranslogEntry", event }), this._transactions.addToBeginning({
      index: 0,
      id: event.id,
      author: event.author,
      timestamp: event.timestamp,
      draftEffect: event.effects[this.draftId],
      publishedEffect: event.effects[this.publishedId]
    });
  }
  /** Mark that we've reached the earliest entry. */
  didReachEarliestEntry() {
    this._trace && this._trace.push({ type: "didReachEarliestEntry" }), this.reachedEarliestEntry = !0;
  }
  /**
   * updateChunks synchronizes the chunks to match the current state
   * of the transactions array. After calling this method you need
   * to invalidate all Chunks.
   */
  updateChunks() {
    this._trace && this._trace.push({ type: "updateChunks" }), this._removeInvalidatedChunks(), this._addChunksFromTransactions(), this._createInitialChunk();
  }
  _removeInvalidatedChunks() {
    if (this._recreateTransactionsFrom) {
      for (; this._chunks.length > 0; ) {
        const chunk = this._chunks.last;
        if (this._recreateTransactionsFrom < chunk.end)
          this._chunks.removeFromEnd();
        else
          break;
      }
      this._recreateTransactionsFrom = void 0;
    }
  }
  _addChunksFromTransactions() {
    const firstIdx = this._transactions.firstIdx, lastIdx = this._transactions.lastIdx, nextTransactionToChunk = this._chunks.length > 0 ? this._chunks.last.end : firstIdx;
    for (let idx = nextTransactionToChunk; idx <= lastIdx; idx++) {
      const transaction = this._transactions.get(idx);
      this._chunks.mergeAtEnd(chunkFromTransaction(transaction), mergeChunk);
    }
    if (this._chunks.length == 0) return;
    const firstTransactionChunked = this._chunks.first.start;
    for (let idx = firstTransactionChunked - 1; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx);
      this._chunks.mergeAtBeginning(chunkFromTransaction(transaction), mergeChunk);
    }
  }
  _invalidateTransactionFrom(idx) {
    (this._recreateTransactionsFrom === void 0 || idx < this._recreateTransactionsFrom) && (this._recreateTransactionsFrom = idx);
  }
  _createInitialChunk() {
    var _a2;
    if (this.reachedEarliestEntry) {
      if (((_a2 = this._chunks.first) == null ? void 0 : _a2.type) === "initial") return;
      const firstTx = this._transactions.first;
      if (!firstTx) return;
      const initialChunk = chunkFromTransaction(firstTx);
      initialChunk.type = "initial", initialChunk.id = "@initial", initialChunk.end = initialChunk.start, this._chunks.addToBeginning(initialChunk);
    }
  }
  /**
   * Resolves a time reference.
   *
   * Note that the chunk returned is only valid if the timeline stays constant.
   * Once the timeline is updated, you must re-parse all references.
   */
  parseTimeId(id2) {
    if (this._chunks.length === 0)
      return this.reachedEarliestEntry ? "invalid" : "loading";
    const idSegments = id2.split("/", 3), timestampStr = idSegments.shift(), chunkId = idSegments.shift(), timestamp = Number(timestampStr);
    for (let idx = this._chunks.lastIdx; idx >= this._chunks.firstIdx; idx--) {
      const chunk = this._chunks.get(idx);
      if (chunk.id === chunkId)
        return chunk;
      if (Date.parse(chunk.endTimestamp) + 60 * 60 * 1e3 < timestamp)
        return "invalid";
    }
    return this.reachedEarliestEntry ? "invalid" : "loading";
  }
  findLastPublishedBefore(chunk) {
    for (let chunkIdx = chunk ? chunk.index - 1 : this._chunks.lastIdx; chunkIdx >= this._chunks.firstIdx; chunkIdx--) {
      const currentChunk = this._chunks.get(chunkIdx);
      if (currentChunk.type === "publish" || currentChunk.type === "initial")
        return currentChunk;
    }
    return this.reachedEarliestEntry ? this._chunks.first : "loading";
  }
  isLatestChunk(chunk) {
    return chunk === this._chunks.last;
  }
  // eslint-disable-next-line class-methods-use-this
  createTimeId(chunk) {
    return `${chunk.endTimestamp.valueOf()}/${chunk.id}`;
  }
  lastChunk() {
    return this._chunks.last;
  }
  transactionByIndex(idx) {
    return this._transactions.has(idx) ? this._transactions.get(idx) : null;
  }
  chunkByTransactionIndex(idx, startChunkIdx = 0) {
    let chunkIdx = startChunkIdx;
    for (; ; ) {
      const chunk = this._chunks.get(chunkIdx);
      if (!chunk) throw new Error("transaction does not belong in any chunk");
      if (idx >= chunk.end)
        chunkIdx++;
      else if (idx < chunk.start)
        chunkIdx--;
      else
        return chunk;
    }
  }
  replayBackwardsBetween(firstIdx, lastIdx, doc) {
    let draft = doc.draft, published = doc.published;
    for (let idx = lastIdx; idx >= firstIdx; idx--) {
      const transaction = this._transactions.get(idx);
      transaction.draftEffect && (draft = mendoza.applyPatch(draft, transaction.draftEffect.revert)), transaction.publishedEffect && (published = mendoza.applyPatch(published, transaction.publishedEffect.revert));
    }
    return { draft, published };
  }
  replayBackwardsUntil(firstIdx, doc) {
    return this.replayBackwardsBetween(firstIdx, this._transactions.lastIdx, doc);
  }
  calculateDiff(initialDoc, finalDoc, firstIdx, lastIdx) {
    let draftValue = mendoza.incremental.wrap(initialDoc.draft, null), publishedValue = mendoza.incremental.wrap(initialDoc.published, null);
    const initialValue = getValue(draftValue, publishedValue), initialAttributes = getAttrs$1(initialDoc);
    let firstChunk = null;
    for (let chunkIdx = firstIdx; chunkIdx <= lastIdx; chunkIdx++) {
      const chunk = this._chunks.get(chunkIdx);
      firstChunk || (firstChunk = chunk);
      for (let idx = chunk.start; idx < chunk.end; idx++) {
        const transaction = this._transactions.get(idx), meta = {
          chunk,
          transactionIndex: idx
        }, preDraftValue = draftValue, prePublishedValue = publishedValue;
        transaction.draftEffect && (draftValue = mendoza.incremental.applyPatch(draftValue, transaction.draftEffect.apply, meta)), transaction.publishedEffect && (publishedValue = mendoza.incremental.applyPatch(
          publishedValue,
          transaction.publishedEffect.apply,
          meta
        ));
        const didHaveDriaft = mendoza.incremental.getType(preDraftValue) !== "null", haveDraft = mendoza.incremental.getType(draftValue) !== "null";
        mendoza.incremental.getType(publishedValue) !== "null" && !haveDraft && (publishedValue = mendoza.incremental.rebaseValue(preDraftValue, publishedValue)), haveDraft && !didHaveDriaft && (draftValue = mendoza.incremental.rebaseValue(prePublishedValue, draftValue));
      }
    }
    const finalValue = mendoza.incremental.getType(draftValue) === "null" ? publishedValue : draftValue, finalAttributes = getAttrs$1(finalDoc);
    return diffValue(this, firstChunk, initialValue, initialAttributes, finalValue, finalAttributes);
  }
}
function getValue(draftValue, publishedValue) {
  return mendoza.incremental.getType(draftValue) === "null" ? publishedValue : draftValue;
}
var __defProp$2 = Object.defineProperty, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key != "symbol" ? key + "" : key, value);
function emptyVersionState(id2) {
  return {
    id: id2,
    hasAttrs: !1,
    attrs: null,
    rev: null,
    events: [],
    aligned: !1
  };
}
function align(history2, state) {
  const idx = state.events.findIndex((evt) => history2.id === evt.transactionId);
  return idx >= 0 ? idx + 1 : state.rev ? state.rev === history2.id ? 0 : -1 : 0;
}
function startFromSnapshot(state, doc) {
  if (state.hasAttrs = !0, doc) {
    if (state.attrs = { ...doc }, typeof state.attrs._rev != "string") throw new Error("snapshot has no _rev");
    state.rev = state.attrs._rev, delete state.attrs._rev;
  } else
    state.attrs = null, state.rev = null;
  state.events = [];
}
class Aligner {
  constructor(timeline) {
    __publicField$2(this, "timeline"), __publicField$2(this, "earliestTransactionId", null), __publicField$2(this, "_states"), this.timeline = timeline, this._states = {
      draft: emptyVersionState(timeline.draftId),
      published: emptyVersionState(timeline.publishedId)
    };
  }
  appendRemoteSnapshotEvent(evt) {
    const state = this._states[evt.version];
    if (evt.type === "snapshot") {
      this._maybeInvalidateHistory(), startFromSnapshot(state, evt.document);
      return;
    }
    evt.type === "remoteMutation" && (state.aligned ? (this._apply(state, evt), this.timeline.addRemoteMutation(evt)) : state.hasAttrs ? state.events.push(evt) : startFromSnapshot(state, evt.head));
  }
  prependHistoryEvent(evt) {
    if (!this.acceptsHistory) throw new Error("cannot prepend history at this point");
    for (const state of Object.values(this._states))
      if (!state.aligned) {
        const idx = align(evt, state);
        idx >= 0 && this._alignAtIndex(state, idx);
      }
    this.timeline.addTranslogEntry(evt), this.earliestTransactionId = evt.id;
  }
  didReachEarliestEntry() {
    for (const state of Object.values(this._states))
      if (!state.aligned) {
        if (state.attrs !== null) throw new Error("unable to find translog entry to align to");
        this._alignAtIndex(state, 0);
      }
    this.timeline.didReachEarliestEntry();
  }
  get isAligned() {
    return Object.values(this._states).every((state) => state.aligned);
  }
  get acceptsHistory() {
    return this._isComplete;
  }
  get currentDocument() {
    return { draft: this._states.draft.attrs, published: this._states.published.attrs };
  }
  _alignAtIndex(state, idx) {
    for (const mutEvt of state.events.slice(0, idx))
      this._apply(state, mutEvt);
    for (const mutEvt of state.events.slice(idx))
      this._apply(state, mutEvt), this.timeline.addRemoteMutation(mutEvt);
    state.events = [], state.aligned = !0;
  }
  get _isComplete() {
    return Object.values(this._states).every((state) => state.hasAttrs);
  }
  // eslint-disable-next-line class-methods-use-this
  _apply(state, evt) {
    state.attrs = mendoza.applyPatch(state.attrs, evt.effects.apply), state.rev = evt.transactionId;
  }
  _maybeInvalidateHistory() {
    if (this._isComplete) {
      for (const state of Object.values(this._states))
        state.aligned = !1;
      this.earliestTransactionId = null, this.timeline.reset();
    }
  }
}
async function getJsonStream(url, token) {
  const options = token ? { headers: { Authorization: `Bearer ${token}` } } : { credentials: "include" }, response = await fetch(url, options);
  return getStream(response);
}
function getStream(response) {
  const body = response.body;
  if (!body)
    throw new Error("Failed to read body from response");
  let reader, cancelled = !1;
  return new ReadableStream({
    start(controller) {
      reader = body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      reader.read().then(function processResult(result) {
        if (result.done) {
          if (cancelled)
            return;
          if (buffer = buffer.trim(), buffer.length === 0) {
            controller.close();
            return;
          }
          controller.enqueue(JSON.parse(buffer)), controller.close();
          return;
        }
        buffer += decoder.decode(result.value, { stream: !0 });
        const lines = buffer.split(`
`);
        for (let i = 0; i < lines.length - 1; ++i) {
          const line = lines[i].trim();
          if (line.length !== 0)
            try {
              controller.enqueue(JSON.parse(line));
            } catch (err) {
              controller.error(err), cancelled = !0, reader.cancel();
              return;
            }
        }
        return buffer = lines[lines.length - 1], reader.read().then(processResult).catch((err) => controller.error(err));
      }).catch((err) => controller.error(err));
    },
    cancel() {
      cancelled = !0, reader.cancel();
    }
  });
}
var __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key != "symbol" ? key + "" : key, value);
class Reconstruction {
  constructor(timeline, doc, start, end) {
    __publicField$1(this, "timeline"), __publicField$1(this, "start"), __publicField$1(this, "end"), __publicField$1(this, "doc"), __publicField$1(this, "_startDocument"), __publicField$1(this, "_endDocument"), __publicField$1(this, "_diff"), this.timeline = timeline, this.start = start, this.end = end, this.doc = doc;
  }
  same(start, end) {
    return this.start === start && this.end === end;
  }
  /** Returns the attributes as seen at the end of the range. */
  endAttributes() {
    return getAttrs(this.endDocument());
  }
  endDocument() {
    return this._endDocument || (this._endDocument = this.timeline.replayBackwardsUntil(this.end.end, this.doc)), this._endDocument;
  }
  /** Returns the attributes as seen at the end of the range. */
  startAttributes() {
    return getAttrs(this.startDocument());
  }
  startDocument() {
    if (!this.start) throw new Error("start required");
    return this._startDocument || (this._startDocument = this.timeline.replayBackwardsBetween(
      this.start.end,
      this.end.end - 1,
      this.endDocument()
    )), this._startDocument;
  }
  diff() {
    if (!this._diff) {
      if (!this.start) throw new Error("start required");
      this._diff = this.timeline.calculateDiff(
        this.startDocument(),
        this.endDocument(),
        this.start.index + 1,
        this.end.index
      );
    }
    return this._diff;
  }
}
function getAttrs(doc) {
  return doc.draft || doc.published;
}
var __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value);
const TRANSLOG_ENTRY_LIMIT = 50;
class TimelineController {
  constructor(options) {
    __publicField(this, "timeline"), __publicField(this, "client"), __publicField(this, "handler"), __publicField(this, "version", 0), __publicField(this, "selectionState", "inactive"), __publicField(this, "_aligner"), __publicField(this, "_fetchMore", !1), __publicField(this, "_fetchAtLeast", 0), __publicField(this, "_isRunning", !1), __publicField(this, "_isSuspended", !1), __publicField(this, "_didErr", !1), __publicField(this, "_since", null), __publicField(this, "_sinceTime", null), __publicField(this, "_rev", null), __publicField(this, "_revTime", null), __publicField(this, "_reconstruction"), this.timeline = options.timeline, this.client = options.client, this.handler = options.handler, this._aligner = new Aligner(this.timeline), this.markChange();
  }
  clearRange() {
    this.setRange(null, null);
  }
  setRange(since, rev) {
    rev !== this._rev && this.setRevTime(rev), since !== this._since && this.setSinceTime(since);
    let _fetchAtLeast = 10;
    if (this._sinceTime === "loading" || this._revTime === "loading" || !this._aligner.isAligned)
      this.selectionState = "loading";
    else if (this._sinceTime === "invalid" || this._revTime === "invalid")
      this.selectionState = "invalid";
    else if (this._sinceTime) {
      this.selectionState = "range";
      const targetRev = this._revTime || this.timeline.lastChunk();
      this._sinceTime.index > targetRev.index ? (this._revTime = "invalid", this.selectionState = "invalid") : this.setReconstruction(this._sinceTime, targetRev);
    } else this._revTime ? (this.selectionState = "rev", this.setReconstruction(null, this._revTime)) : (this.selectionState = "inactive", _fetchAtLeast = 0);
    this._fetchAtLeast = _fetchAtLeast, this.start();
  }
  setLoadMore(flag) {
    this._fetchMore = flag, this.start();
  }
  get sinceTime() {
    return this._sinceTime && typeof this._sinceTime == "object" ? this._sinceTime : null;
  }
  get revTime() {
    return this._revTime && typeof this._revTime == "object" ? this._revTime : null;
  }
  get realRevChunk() {
    return this.revTime || this.timeline.lastChunk();
  }
  /** Returns true when there's an older revision we want to render. */
  onOlderRevision() {
    return !!this._rev && (this.selectionState === "range" || this.selectionState === "rev");
  }
  findRangeForNewRev(rev) {
    const revTimeId = this.timeline.isLatestChunk(rev) ? null : this.timeline.createTimeId(rev);
    if (!this._since)
      return [null, revTimeId];
    const sinceChunk = this.sinceTime;
    return sinceChunk && sinceChunk.index < rev.index ? [this._since, revTimeId] : ["@lastPublished", revTimeId];
  }
  findRangeForNewSince(since) {
    const revChunk = this.revTime;
    return revChunk && since.index < revChunk.index ? [this.timeline.createTimeId(since), this._rev] : [this.timeline.createTimeId(since), null];
  }
  setRevTime(rev) {
    this._rev = rev, this._revTime = rev ? this.timeline.parseTimeId(rev) : null, this._since === "@lastPublished" && (this._since = null, this._sinceTime = null);
  }
  setSinceTime(since) {
    since === "@lastPublished" ? typeof this._revTime == "string" ? this._sinceTime = this._revTime : this._sinceTime = this.timeline.findLastPublishedBefore(this._revTime) : this._sinceTime = since ? this.timeline.parseTimeId(since) : null, this._since = since;
  }
  sinceAttributes() {
    return this._sinceTime && this._reconstruction ? this._reconstruction.startAttributes() : null;
  }
  displayed() {
    return this._revTime && this._reconstruction ? this._reconstruction.endAttributes() : null;
  }
  setReconstruction(since, rev) {
    this._reconstruction && this._reconstruction.same(since, rev) || (this._reconstruction = new Reconstruction(
      this.timeline,
      this._aligner.currentDocument,
      since,
      rev
    ));
  }
  currentDiff() {
    return this._reconstruction ? this._reconstruction.diff() : null;
  }
  currentObjectDiff() {
    const diff2 = this.currentDiff();
    if (diff2) {
      if (diff2.type === "null") return null;
      if (diff2.type !== "object") throw new Error(`ObjectDiff expected, got ${diff2.type}`);
    }
    return diff2;
  }
  handleRemoteMutation(ev) {
    this._aligner.appendRemoteSnapshotEvent(ev), this.markChange(), this._aligner.acceptsHistory && this.start();
  }
  start() {
    this._didErr || this._isRunning || (this._isRunning = !0, this.tick().then(() => {
      this._isRunning = !1;
    }));
  }
  resume() {
    this._isSuspended = !1;
  }
  suspend() {
    this._isSuspended = !0;
  }
  async tick() {
    var _a2;
    if (this._aligner.acceptsHistory && !this.timeline.reachedEarliestEntry && (this.selectionState === "loading" || this._fetchMore || this.timeline.chunkCount <= this._fetchAtLeast) && !this._isSuspended) {
      try {
        await this.fetchMoreTransactions();
      } catch (err) {
        this._didErr = !0, (_a2 = this.handler) == null || _a2.call(this, err, this);
        return;
      }
      await this.tick();
    }
  }
  async fetchMoreTransactions() {
    const publishedId = this.timeline.publishedId, draftId = this.timeline.draftId, clientConfig = this.client.config(), limit = TRANSLOG_ENTRY_LIMIT;
    let queryParams = `tag=sanity.studio.structure.history&effectFormat=mendoza&excludeContent=true&excludeMutations=true&includeIdentifiedDocumentsOnly=true&reverse=true&limit=${limit}`, tid = this._aligner.earliestTransactionId;
    tid && (queryParams += `&toTransaction=${tid}`);
    const transactionsUrl = this.client.getUrl(
      `/data/history/${clientConfig.dataset}/transactions/${publishedId},${draftId}?${queryParams}`
    ), reader = (await getJsonStream(transactionsUrl, clientConfig.token)).getReader();
    let count = 0;
    for (; ; ) {
      const result = await reader.read();
      if (result.done) break;
      if ("error" in result.value)
        throw new Error(result.value.error.description || result.value.error.type);
      if (count++, result.value.id !== tid) {
        if (this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory)
          return;
        this._aligner.prependHistoryEvent(result.value), tid = this._aligner.earliestTransactionId;
      }
    }
    this._aligner.earliestTransactionId !== tid || !this._aligner.acceptsHistory || (count < limit && this._aligner.didReachEarliestEntry(), this.markChange());
  }
  markChange() {
    var _a2;
    this.timeline.updateChunks(), this.setRevTime(this._rev), this.setSinceTime(this._rev), this.version++, (_a2 = this.handler) == null || _a2.call(this, null, this);
  }
}
const documentRevisionCache = /* @__PURE__ */ Object.create(null), getHistory = (client2, documentIds, options = {}) => {
  const ids = Array.isArray(documentIds) ? documentIds : [documentIds], { time, revision } = options;
  if (time && revision)
    throw new Error("getHistory can't handle both time and revision parameters");
  let url = `/data/history/${client2.config().dataset}/documents/${ids.join(",")}`;
  if (revision)
    url = `${url}?revision=${revision}`;
  else {
    const timestamp = time || (/* @__PURE__ */ new Date()).toISOString();
    url = `${url}?time=${timestamp}`;
  }
  return client2.request({ url });
}, getDocumentAtRevision = (client2, documentId, revision) => {
  const publishedId = getPublishedId(documentId), draftId = getDraftId(documentId), cacheKey = `${publishedId}@${revision}`, cached = documentRevisionCache[cacheKey];
  if (cached)
    return cached;
  const url = `/data/history/${client2.config().dataset}/documents/${publishedId},${draftId}?revision=${revision}`, entry = client2.request({ url }).then((result) => {
    const documents = result.documents || [], published = documents.find((res) => res._id === publishedId);
    return documents.find((res) => res._id === draftId) || published;
  });
  return documentRevisionCache[cacheKey] = entry, entry;
}, getTimelineController = ({
  client: client2,
  documentId,
  documentType
}) => {
  const timeline = new Timeline({
    enableTrace: isDev,
    publishedId: documentId
  });
  return new TimelineController({
    client: client2,
    documentId,
    documentType,
    timeline
  });
}, getTransactions = async (client2, documentIds) => {
  const ids = Array.isArray(documentIds) ? documentIds : [documentIds], dataset = client2.config().dataset, query = { excludeContent: "true", includeIdentifiedDocumentsOnly: "true" }, url = `/data/history/${dataset}/transactions/${ids.join(",")}`;
  return (await client2.request({ url, query })).toString("utf8").split(`
`).filter(Boolean).map((line) => JSON.parse(line));
}, getAllRefIds = (doc) => jsonReduce.reduce(
  doc,
  (acc, node) => types.isReference(node) && !acc.includes(node._ref) ? [...acc, node._ref] : acc,
  []
);
function jsonMap(value, mapFn) {
  return Array.isArray(value) ? mapFn(
    value.map((item) => jsonMap(item, mapFn)).filter((item) => typeof item < "u")
  ) : isRecord$4(value) ? mapFn(
    Object.keys(value).reduce((res, key) => {
      const mappedValue = jsonMap(value[key], mapFn);
      return typeof mappedValue < "u" && (res[key] = mappedValue), res;
    }, {})
  ) : mapFn(value);
}
const mapRefNodes = (doc, mapFn) => jsonMap(doc, (node) => types.isReference(node) ? mapFn(node) : node), removeMissingReferences = (doc, existingIds) => mapRefNodes(doc, (refNode) => existingIds[refNode._ref] ? refNode : void 0);
function restore(client2, documentId, targetDocumentId, rev) {
  return rxjs.from(getDocumentAtRevision(client2, documentId, rev)).pipe(
    operators.mergeMap((documentAtRevision) => {
      if (!documentAtRevision)
        throw new Error(`Unable to find document with ID ${documentId} at revision ${rev}`);
      const existingIdsQuery = getAllRefIds(documentAtRevision).map((refId) => `"${refId}": defined(*[_id=="${refId}"]._id)`).join(",");
      return client2.observable.fetch(`{${existingIdsQuery}}`).pipe(operators.map((existingIds) => removeMissingReferences(documentAtRevision, existingIds)));
    }),
    operators.map((documentAtRevision) => {
      const { _updatedAt, ...document2 } = documentAtRevision;
      return { ...document2, _id: targetDocumentId };
    }),
    operators.mergeMap(
      (restoredDraft) => client2.observable.createOrReplace(restoredDraft, { visibility: "async" })
    )
  );
}
function createHistoryStore({ client: client2 }) {
  return {
    getDocumentAtRevision: (documentId, revision) => getDocumentAtRevision(client2, documentId, revision),
    getHistory: (documentIds, options) => getHistory(client2, documentIds, options),
    getTransactions: (documentIds) => getTransactions(client2, documentIds),
    restore: (id2, targetId, rev) => restore(client2, id2, targetId, rev),
    getTimelineController
  };
}
function useTimelineSelector(timelineStore, selector) {
  return withSelector_js.useSyncExternalStoreWithSelector(
    timelineStore.subscribe,
    timelineStore.getSnapshot,
    null,
    selector
  );
}
const INITIAL_TIMELINE_STATE = {
  chunks: [],
  diff: null,
  hasMoreChunks: null,
  isLoading: !1,
  isPristine: null,
  lastNonDeletedRevId: null,
  onOlderRevision: !1,
  realRevChunk: null,
  revTime: null,
  selectionState: "inactive",
  sinceAttributes: null,
  sinceTime: null,
  timelineDisplayed: null,
  timelineReady: !1
};
function useTimelineStore({
  documentId,
  documentType,
  onError,
  rev,
  since
}) {
  var _a2;
  const historyStore = useHistoryStore(), snapshotsSubscriptionRef = React.useRef(null), timelineStateRef = React.useRef(INITIAL_TIMELINE_STATE), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), workspace = useWorkspace(), controller = React.useMemo(
    () => historyStore.getTimelineController({
      client: client2,
      documentId,
      documentType
    }),
    [client2, documentId, documentType, historyStore]
  ), timelineController$ = React.useMemo(
    () => new rxjs.BehaviorSubject(controller),
    [controller]
  );
  React.useEffect(() => (controller.setRange(since || null, rev || null), timelineController$.next(controller), controller.handler = (err, innerController) => {
    err ? timelineController$.error(err) : setTimeout(() => {
      innerController.setRange(since || null, rev || null), timelineController$.next(innerController);
    }, 0);
  }, controller.resume(), () => controller.suspend()), [rev, since, controller, timelineController$]);
  const serverActionsEnabled = React.useMemo(() => {
    var _a22;
    const configFlag = (_a22 = workspace.__internal_serverDocumentActions) == null ? void 0 : _a22.enabled;
    return typeof configFlag == "boolean" ? rxjs.of(configFlag) : fetchFeatureToggle(client2);
  }, [client2, (_a2 = workspace.__internal_serverDocumentActions) == null ? void 0 : _a2.enabled]);
  return React.useEffect(() => (snapshotsSubscriptionRef.current || (snapshotsSubscriptionRef.current = remoteSnapshots(
    client2,
    { draftId: `drafts.${documentId}`, publishedId: documentId },
    documentType,
    serverActionsEnabled
  ).subscribe((ev) => {
    controller.handleRemoteMutation(ev);
  })), () => {
    snapshotsSubscriptionRef.current && (snapshotsSubscriptionRef.current.unsubscribe(), snapshotsSubscriptionRef.current = null);
  }), [client2, controller, documentId, documentType, serverActionsEnabled]), React.useMemo(() => ({
    findRangeForRev: (chunk) => controller.findRangeForNewRev(chunk),
    findRangeForSince: (chunk) => controller.findRangeForNewSince(chunk),
    loadMore: () => {
      controller.setLoadMore(!0), timelineStateRef.current.isLoading = !0;
    },
    getSnapshot: () => timelineStateRef.current,
    subscribe: (callback) => {
      const subscription = timelineController$.pipe(
        rxjs.map((innerController) => {
          var _a22;
          const chunks = innerController.timeline.mapChunks((c) => c), lastNonDeletedChunk = chunks.filter(
            (chunk) => !["delete", "initial"].includes(chunk.type)
          ), hasMoreChunks = !innerController.timeline.reachedEarliestEntry;
          hasMoreChunks && chunks.length > 16 && innerController.setLoadMore(!1);
          const timelineReady = !["invalid", "loading"].includes(innerController.selectionState);
          return {
            chunks,
            diff: innerController.sinceTime ? innerController.currentObjectDiff() : null,
            isLoading: !1,
            isPristine: timelineReady ? chunks.length === 0 && hasMoreChunks === !1 : null,
            hasMoreChunks: !innerController.timeline.reachedEarliestEntry,
            lastNonDeletedRevId: (_a22 = lastNonDeletedChunk == null ? void 0 : lastNonDeletedChunk[0]) == null ? void 0 : _a22.id,
            onOlderRevision: innerController.onOlderRevision(),
            realRevChunk: innerController.realRevChunk,
            revTime: innerController.revTime,
            selectionState: innerController.selectionState,
            sinceAttributes: innerController.sinceAttributes(),
            sinceTime: innerController.sinceTime,
            timelineDisplayed: innerController.displayed(),
            timelineReady
          };
        }),
        // Only emit (and in turn, re-render) when values have changed
        rxjs.distinctUntilChanged(deepEquals__default.default),
        // Emit initial timeline state whenever we encounter an error in TimelineController's `handler` callback.
        // A little ham-fisted, but also reflects how we handle timeline errors in the UI
        // (i.e. no timeline state or diffs are rendered and we revert to the current editable document)
        rxjs.catchError((err) => (onError == null || onError(err), rxjs.of(INITIAL_TIMELINE_STATE))),
        rxjs.tap((timelineState) => {
          timelineStateRef.current = timelineState;
        }),
        // Trigger callback function required by `useSyncExternalStore` to denote when to re-render
        rxjs.tap(callback)
      ).subscribe();
      return () => subscription.unsubscribe();
    }
  }), [controller, onError, timelineController$]);
}
const handleIncomingMessage = (event) => {
  if (event.type === "rollCall")
    return {
      type: "rollCall",
      userId: event.i,
      sessionId: event.session
    };
  if (event.type === "state") {
    const { sessionId: sessionId2, locations } = event.m;
    return {
      type: "state",
      userId: event.i,
      sessionId: sessionId2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      locations
    };
  }
  if (event.type === "disconnect")
    return {
      type: "disconnect",
      userId: event.i,
      sessionId: event.m.session,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  throw new Error(`Got unknown presence event: ${JSON.stringify(event)}`);
}, createBifurTransport = (bifur, sessionId2) => {
  const incomingEvents$ = bifur.request("presence").pipe(operators.map(handleIncomingMessage)), dispatchMessage = (message) => message.type === "rollCall" ? bifur.request("presence_rollcall", { session: sessionId2 }) : message.type === "state" ? bifur.request("presence_announce", {
    data: { locations: message.locations, sessionId: sessionId2 }
  }) : message.type === "disconnect" ? bifur.request("presence_disconnect", { session: sessionId2 }) : rxjs.EMPTY;
  return [incomingEvents$.pipe(operators.share()), dispatchMessage];
}, USERIDS = [
  "pqSMwf6hH",
  "pnLYqNfv5",
  "priDVVmy8",
  "p0NFOU0j8",
  "pTDl2jw8d",
  "pHMeQnTse",
  "pDQYzJbyS",
  "pZyoPHKUs",
  "p4Tyi2Be5",
  "pb9vii060",
  "pE8yhOisw",
  "p7Fd2C6Cj",
  "p3exSgYCx",
  "pbIQRYViC",
  "p8GJaTEhN",
  "p27ewL8aM",
  "pYg97z75S",
  "pdLr4quHv",
  "pkJXiDgg6",
  "pkl4UAKcA",
  // Included to ensure we handle the case when a user profile cannot
  // be fetched due to insufficient privileges or similar
  "pNoExists"
], PATHS = [
  ["nested", "first"],
  ["nested", "second"],
  [
    "nestedArray",
    { _key: "565c867c8dac" },
    "arrayNo1",
    { _key: "a645548a8f01" },
    "arrayNo1",
    { _key: "1685e372c40f" },
    "fieldNo0"
  ],
  ["nestedArray", { _key: "565c867c8dac" }, "fieldNo0"],
  ["nestedArray", { _key: "565c867c8dac" }, "arrayNo19", { _key: "a02e7a93e2a2" }, "fieldNo0"],
  ["nestedArray", { _key: "565c867c8dac" }, "arrayNo19", { _key: "a02e7a93e2a2" }, "fieldNo19"],
  ["address", "country"],
  ["address", "street"],
  ["customInputWithDefaultPresence", "row3", "cell3"]
], mock$ = rxjs.defer(() => rxjs.timer(0, 1e4)).pipe(
  operators.mergeMapTo(USERIDS),
  operators.map(
    (id2, n) => ({
      type: "state",
      userId: id2,
      sessionId: id2 + n,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      locations: [
        {
          type: "document",
          documentId: "presence-debug",
          lastActiveAt: (/* @__PURE__ */ new Date()).toISOString(),
          path: sample__default.default(PATHS)
        }
      ]
    })
  ),
  operators.shareReplay()
), KEY = "presence_session_id", generate = () => nanoid.nanoid(16);
function getSessionId() {
  try {
    return window.sessionStorage.getItem(KEY);
  } catch {
  }
  return null;
}
function setSessionId(id2) {
  try {
    window.sessionStorage.setItem(KEY, id2);
  } catch {
  }
  return id2;
}
const SESSION_ID = getSessionId() || setSessionId(generate());
function __tmp_wrap_presenceStore(context) {
  const { bifur, connectionStatusStore, userStore } = context, [presenceEvents$, sendMessage] = createBifurTransport(bifur, SESSION_ID), currentLocation$ = new rxjs.BehaviorSubject([]), locationChange$ = currentLocation$.pipe(operators.distinctUntilChanged()), setLocation = (nextLocation) => {
    currentLocation$.next(nextLocation);
  }, reportLocations = (locations) => sendMessage({ type: "state", locations }), requestRollCall = () => sendMessage({ type: "rollCall" }), rollCallRequests$ = presenceEvents$.pipe(
    operators.filter((event) => event.type === "rollCall"),
    // do not respond to my own rollcall requests
    operators.filter((event) => event.sessionId !== SESSION_ID)
  ), reportLocationInterval$ = rxjs.timer(0, 3e4), reportLocation$ = rxjs.defer(() => rxjs.merge(locationChange$, rollCallRequests$)).pipe(
    operators.switchMap(() => reportLocationInterval$),
    operators.withLatestFrom(currentLocation$),
    operators.map(([, locations]) => locations),
    operators.auditTime(200),
    operators.switchMap((locations) => reportLocations(locations)),
    operators.mergeMapTo(rxjs.EMPTY),
    operators.share()
  ), myRollCall$ = rxjs.defer(() => requestRollCall()).pipe(operators.mergeMapTo(rxjs.EMPTY)), connectionChange$ = connectionStatusStore.connectionStatus$.pipe(
    operators.map((status) => status.type),
    operators.filter((statusType) => statusType === "connected" || statusType === "error"),
    operators.distinctUntilChanged()
  ), debugPresenceParam$ = debugParams$.pipe(
    operators.map((args) => args.find((arg) => arg.startsWith("presence="))),
    operators.map(
      (arg) => (arg == null ? void 0 : arg.split("presence=")[1].split(",").map((r) => r.trim())) || []
    )
  ), useMock$ = debugPresenceParam$.pipe(
    operators.filter((args) => args.includes("fake_others")),
    operators.tap(() => {
      console.log(
        'Faking other users present in the studio. They will hang out in the document with _type: "presence" and _id: "presence-debug"'
      );
    }),
    operators.switchMapTo(mock$)
  ), debugIntrospect$ = debugPresenceParam$.pipe(operators.map((args) => args.includes("show_own"))), syncEvent$ = rxjs.merge(myRollCall$, presenceEvents$).pipe(
    operators.filter(
      (event) => event.type === "state" || event.type === "disconnect"
    )
  ), stateEventToSession = (stateEvent) => ({
    lastActiveAt: stateEvent.timestamp,
    locations: stateEvent.locations,
    sessionId: stateEvent.sessionId,
    userId: stateEvent.userId
  }), states$ = rxjs.merge(syncEvent$, useMock$).pipe(
    operators.scan(
      (keyed, event) => event.type === "disconnect" ? omit__default.default(keyed, event.sessionId) : { ...keyed, [event.sessionId]: stateEventToSession(event) },
      {}
    )
  ), allSessions$ = connectionChange$.pipe(
    operators.switchMap((status) => status === "connected" ? rxjs.merge(states$, reportLocation$) : rxjs.NEVER),
    operators.map((keyedSessions) => Object.values(keyedSessions)),
    operators.switchMap((sessions) => {
      const userIds = uniq__default.default(sessions.map((sess) => sess.userId));
      return rxjs.from(userStore.getUsers(userIds)).pipe(
        operators.map(
          (users) => sessions.map((session) => ({
            // eslint-disable-next-line max-nested-callbacks
            user: users.find((res) => res.id === session.userId),
            session
          })).filter(userSessionPairHasUser)
        )
      );
    }),
    operators.takeUntil(
      rxjs.fromEvent(window, "beforeunload").pipe(operators.switchMap(() => sendMessage({ type: "disconnect" })))
    ),
    operators.shareReplay({ refCount: !0, bufferSize: 1 })
  );
  function userSessionPairHasUser(pair) {
    return !!(pair.user && pair.session);
  }
  const globalPresence$ = allSessions$.pipe(
    operators.map((sessions) => {
      const grouped = groupBy__default.default(
        sessions.map((s) => s.session),
        (e) => e.userId
      );
      return Object.keys(grouped).map((userId) => {
        var _a2;
        return {
          user: (_a2 = sessions.find((s) => s.user.id === userId)) == null ? void 0 : _a2.user,
          sessions: grouped[userId]
        };
      });
    }),
    operators.withLatestFrom(debugIntrospect$),
    operators.map(
      ([userAndSessions, debugIntrospect]) => userAndSessions.filter((userAndSession) => debugIntrospect ? !0 : !userAndSession.sessions.some((sess) => sess.sessionId === SESSION_ID))
    ),
    operators.map(
      (userAndSessions) => userAndSessions.map((userAndSession) => {
        var _a2;
        return {
          user: userAndSession.user,
          status: "online",
          lastActiveAt: (_a2 = userAndSession.sessions.sort()[0]) == null ? void 0 : _a2.lastActiveAt,
          locations: flatten__default.default(
            (userAndSession.sessions || []).map((session) => session.locations || [])
          ).map((location) => ({
            type: location.type,
            documentId: location.documentId,
            path: location.path,
            lastActiveAt: location.lastActiveAt
          })).reduce((prev, curr) => prev.concat(curr), [])
        };
      })
    )
  );
  return { setLocation, reportLocations, debugPresenceParam$, globalPresence$, documentPresence: (documentId) => allSessions$.pipe(
    operators.withLatestFrom(debugIntrospect$),
    operators.switchMap(
      ([userAndSessions, debugIntrospect]) => rxjs.from(userAndSessions).pipe(
        operators.filter(
          (userAndSession) => debugIntrospect || userAndSession.session.sessionId !== SESSION_ID
        ),
        operators.flatMap(
          (userAndSession) => (userAndSession.session.locations || []).filter((item) => item.documentId === documentId).map((location) => ({
            user: userAndSession.user,
            lastActiveAt: userAndSession.session.lastActiveAt,
            path: location.path || [],
            sessionId: userAndSession.session.sessionId,
            selection: location == null ? void 0 : location.selection
          }))
        ),
        operators.toArray()
      )
    )
  ) };
}
function createProjectStore(context) {
  const { client: client2 } = context, projectId = client2.config().projectId, versionedClient = client2.withConfig({ apiVersion: "2021-12-15" });
  function get2() {
    return versionedClient.observable.request({
      url: `/projects/${projectId}`
    });
  }
  function getDatasets() {
    return versionedClient.observable.request({
      url: `/projects/${projectId}/datasets`
    });
  }
  return { get: get2, getDatasets };
}
function useProject() {
  const projectStore = useProjectStore(), [value, setValue] = React.useState(null);
  return React.useEffect(() => {
    const sub = projectStore.get().subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]), { value };
}
function useProjectDatasets() {
  const projectStore = useProjectStore(), [value, setValue] = React.useState(null);
  return React.useEffect(() => {
    const sub = projectStore.getDatasets().subscribe(setValue);
    return () => sub.unsubscribe();
  }, [projectStore]), { value };
}
function createMultiKeyWeakMap() {
  const rootMap = /* @__PURE__ */ new WeakMap(), idCache = /* @__PURE__ */ new WeakMap();
  function randomId() {
    return Array.from({ length: 10 }).map(
      () => Math.floor(Math.random() * 255).toString(16).padStart(2, "0")
    ).join("");
  }
  function assignId(key) {
    const cachedId = idCache.get(key);
    if (cachedId) return cachedId;
    const id2 = randomId();
    return idCache.set(key, id2), id2;
  }
  function arrangeKeys(keys) {
    return Array.from(new Set(keys)).map((key) => [assignId(key), key]).sort(([a], [b]) => a.localeCompare(b, "en")).map(([, key]) => key);
  }
  function getDeep(keys, map) {
    if (!keys.length) return;
    const [firstKey, ...restOfKeys] = keys, node = map.get(firstKey);
    if (node)
      return restOfKeys.length ? getDeep(restOfKeys, node.next) : node.value;
  }
  function setDeep(keys, map, value) {
    if (!keys.length) return;
    const [firstKey, ...restOfKeys] = keys, node = map.get(firstKey) || {
      type: "multi-key-weak-map-node",
      value: void 0,
      next: /* @__PURE__ */ new WeakMap()
    };
    if (map.set(firstKey, node), !restOfKeys.length) {
      node.value = value;
      return;
    }
    setDeep(restOfKeys, node.next, value);
  }
  function get2(keys) {
    return getDeep(arrangeKeys(keys), rootMap);
  }
  function set2(keys, value) {
    setDeep(arrangeKeys(keys), rootMap, value);
  }
  return { get: get2, set: set2 };
}
function ResourceCacheProvider({ children }) {
  const resourceCache = React.useMemo(() => {
    const namespaces = /* @__PURE__ */ new Map(), nullReplacer = {};
    return {
      get: ({ namespace, dependencies }) => {
        const dependenciesWithoutNull = dependencies.map(
          (dep) => dep === null ? nullReplacer : dep
        ), namespaceMap = namespaces.get(namespace);
        return namespaceMap == null ? void 0 : namespaceMap.get(dependenciesWithoutNull);
      },
      set: ({ namespace, dependencies, value }) => {
        const namespaceMap = namespaces.get(namespace) || createMultiKeyWeakMap(), dependenciesWithoutNull = dependencies.map(
          (dep) => dep === null ? nullReplacer : dep
        );
        namespaces.set(namespace, namespaceMap), namespaceMap.set(dependenciesWithoutNull, value);
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ResourceCacheContext.Provider, { value: resourceCache, children });
}
function useResourceCache() {
  const cache2 = React.useContext(_singletons.ResourceCacheContext);
  if (!cache2) throw new Error("Could not find `cache` context");
  return cache2;
}
const INTERNAL_USER_IDS = [
  {
    id: "<system>",
    displayName: "Sanity",
    imageUrl: "https://public.sanity.io/logos/favicon-192.png"
  }
];
function createUserStore({ client: _client, currentUser }) {
  const client2 = _client.withConfig({ apiVersion: "2021-06-07" }), userLoader = new DataLoader__default.default(
    async (userIds) => {
      const value = await client2.request({
        uri: `/users/${userIds.join(",")}`,
        withCredentials: !0,
        tag: "users.get"
      }), users = (Array.isArray(value) ? value : [value]).reduce(
        (acc, next) => (next != null && next.id && (acc[next.id] = next), acc),
        {}
      );
      return userIds.map((id2) => users[id2] || null);
    },
    { batchScheduleFn: (cb) => raf__default.default(cb) }
  ), userFromCurrentUser = currentUser && {
    id: currentUser.id,
    displayName: currentUser.name,
    imageUrl: currentUser.profileImage
  };
  return userLoader.prime("me", userFromCurrentUser), userFromCurrentUser != null && userFromCurrentUser.id && userLoader.prime(userFromCurrentUser.id, userFromCurrentUser), INTERNAL_USER_IDS.forEach((user) => userLoader.prime(user.id, user)), {
    getUser: async (userId) => {
      if (!userId) return Promise.resolve(null);
      try {
        return await userLoader.load(userId);
      } catch (err) {
        if (err.statusCode === 403)
          return Promise.resolve(null);
        throw err;
      }
    },
    getUsers: async (userIds) => (await userLoader.loadMany(userIds)).filter(
      (result) => isRecord$4(result) && typeof result.id == "string"
    )
  };
}
function useUserStore() {
  const { getClient, currentUser } = useSource(), resourceCache = useResourceCache(), client2 = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return React.useMemo(() => {
    const userStore = resourceCache.get({
      namespace: "userStore",
      dependencies: [client2, currentUser]
    }) || createUserStore({ client: client2, currentUser });
    return resourceCache.set({
      namespace: "userStore",
      dependencies: [client2, currentUser],
      value: userStore
    }), userStore;
  }, [client2, currentUser, resourceCache]);
}
function useGrantsStore() {
  const { getClient } = useSource(), client2 = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS), currentUser = useCurrentUser(), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const grantsStore = resourceCache.get({
      namespace: "grantsStore",
      dependencies: [client2, currentUser]
    }) || createGrantsStore({ client: client2, userId: (currentUser == null ? void 0 : currentUser.id) || null });
    return resourceCache.set({
      namespace: "grantsStore",
      dependencies: [client2, currentUser],
      value: grantsStore
    }), grantsStore;
  }, [client2, currentUser, resourceCache]);
}
function useHistoryStore() {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const historyStore = resourceCache.get({
      namespace: "historyStore",
      dependencies: [client2]
    }) || createHistoryStore({ client: client2 });
    return resourceCache.set({
      namespace: "historyStore",
      dependencies: [client2],
      value: historyStore
    }), historyStore;
  }, [client2, resourceCache]);
}
function useDocumentPreviewStore() {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const documentPreviewStore = resourceCache.get({
      namespace: "documentPreviewStore",
      dependencies: [client2]
    }) || createDocumentPreviewStore({ client: client2 });
    return resourceCache.set({
      namespace: "documentPreviewStore",
      dependencies: [client2],
      value: documentPreviewStore
    }), documentPreviewStore;
  }, [client2, resourceCache]);
}
function useDocumentStore() {
  var _a2;
  const { getClient, i18n } = useSource(), schema2 = useSchema(), templates = useTemplates(), resourceCache = useResourceCache(), historyStore = useHistoryStore(), documentPreviewStore = useDocumentPreviewStore(), workspace = useWorkspace(), serverActionsEnabled = React.useMemo(() => {
    var _a22;
    const configFlag = (_a22 = workspace.__internal_serverDocumentActions) == null ? void 0 : _a22.enabled;
    return typeof configFlag == "boolean" ? rxjs.of(configFlag) : fetchFeatureToggle(getClient(DEFAULT_STUDIO_CLIENT_OPTIONS));
  }, [getClient, (_a2 = workspace.__internal_serverDocumentActions) == null ? void 0 : _a2.enabled]);
  return React.useMemo(() => {
    const documentStore = resourceCache.get({
      namespace: "documentStore",
      dependencies: [getClient, documentPreviewStore, historyStore, schema2, i18n, workspace]
    }) || createDocumentStore({
      getClient,
      documentPreviewStore,
      historyStore,
      initialValueTemplates: templates,
      schema: schema2,
      i18n,
      serverActionsEnabled
    });
    return resourceCache.set({
      namespace: "documentStore",
      dependencies: [getClient, documentPreviewStore, historyStore, schema2, i18n],
      value: documentStore
    }), documentStore;
  }, [
    resourceCache,
    getClient,
    documentPreviewStore,
    historyStore,
    schema2,
    i18n,
    workspace,
    templates,
    serverActionsEnabled
  ]);
}
function useConnectionStatusStore() {
  const { bifur } = useSource().__internal, resourceCache = useResourceCache();
  return React.useMemo(() => {
    const connectionStatusStore = resourceCache.get({
      namespace: "connectionStatusStore",
      dependencies: [bifur]
    }) || createConnectionStatusStore({ bifur });
    return resourceCache.set({
      namespace: "connectionStatusStore",
      dependencies: [bifur],
      value: connectionStatusStore
    }), connectionStatusStore;
  }, [bifur, resourceCache]);
}
function usePresenceStore() {
  const {
    __internal: { bifur }
  } = useSource(), resourceCache = useResourceCache(), userStore = useUserStore(), connectionStatusStore = useConnectionStatusStore();
  return React.useMemo(() => {
    const presenceStore = resourceCache.get({
      namespace: "presenceStore",
      dependencies: [bifur, connectionStatusStore, userStore]
    }) || __tmp_wrap_presenceStore({ bifur, connectionStatusStore, userStore });
    return resourceCache.set({
      namespace: "presenceStore",
      dependencies: [bifur, connectionStatusStore, userStore],
      value: presenceStore
    }), presenceStore;
  }, [bifur, connectionStatusStore, resourceCache, userStore]);
}
function useProjectStore() {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), resourceCache = useResourceCache();
  return React.useMemo(() => {
    const projectStore = resourceCache.get({
      namespace: "projectStore",
      dependencies: [client2]
    }) || createProjectStore({ client: client2 });
    return resourceCache.set({
      namespace: "projectStore",
      dependencies: [client2],
      value: projectStore
    }), projectStore;
  }, [client2, resourceCache]);
}
function useKeyValueStore() {
  const resourceCache = useResourceCache(), workspace = useWorkspace(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  return React.useMemo(() => {
    const keyValueStore = resourceCache.get({
      dependencies: [workspace],
      namespace: "KeyValueStore"
    }) || createKeyValueStore({ client: client2 });
    return resourceCache.set({
      dependencies: [workspace],
      namespace: "KeyValueStore",
      value: keyValueStore
    }), keyValueStore;
  }, [client2, resourceCache, workspace]);
}
function useDocumentPresence(documentId) {
  const presenceStore = usePresenceStore(), [presence, setPresence] = React.useState([]);
  return React.useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(setPresence);
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]), presence;
}
function useGlobalPresence() {
  const [presence, setPresence] = React.useState([]), presenceStore = usePresenceStore();
  return React.useEffect(() => {
    const subscription = presenceStore.globalPresence$.subscribe(setPresence);
    return () => {
      subscription.unsubscribe();
    };
  }, [presenceStore]), presence;
}
const INITIAL_STATE$3 = { referringDocuments: [], isLoading: !0 };
function useReferringDocuments(id2) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.listenQuery(
      "*[references($docId)] [0...101]",
      { docId: id2 },
      { tag: "use-referring-documents" }
    ).pipe(
      operators.map(
        (docs) => ({
          referringDocuments: docs,
          isLoading: !1
        })
      ),
      operators.startWith(INITIAL_STATE$3)
    ),
    [documentStore, id2],
    INITIAL_STATE$3
  );
}
const AssetUsageList = ({
  asset,
  assetType,
  referringDocuments
}) => {
  const { t: t2 } = useTranslation(), count = referringDocuments.length;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: count > 0, marginTop: 2, paddingBottom: 2, marginBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, as: "h2", weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(
      Translate,
      {
        t: t2,
        i18nKey: `asset-source.usage-list.documents-using-${assetType}`,
        context: asset.originalFilename ? "named" : "unnamed",
        values: { filename: asset.originalFilename, count }
      }
    ) }) }),
    referringDocuments.map((document2) => /* @__PURE__ */ jsxRuntime.jsx(DocumentLink, { document: document2 }, document2._id))
  ] });
}, DocumentLink = ({ document: document2 }) => {
  const schema2 = useSchema(), LinkComponent2 = React.useCallback(
    (linkProps) => /* @__PURE__ */ jsxRuntime.jsx(router.IntentLink, { ...linkProps, params: { id: document2._id, type: document2._type }, intent: "edit" }),
    [document2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: LinkComponent2, radius: 2, "data-as": "a", tabIndex: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    Preview$1,
    {
      layout: "default",
      value: { _type: "reference", _ref: document2._id },
      schemaType: schema2.get(document2._type)
    }
  ) }) }, document2._id);
}, STYLE_ASSET_IMAGE = {
  maxWidth: "100%",
  height: "120px",
  objectFit: "contain",
  objectPosition: "center"
}, STYLE_CONFIRM_CARD = {
  gridColumn: "span 1",
  overflow: "hidden",
  display: "flex",
  alignSelf: "center",
  justifyContent: "center"
}, STYLE_IMAGE_WRAPPER = { height: "100%" }, ConfirmMessage = ({ asset, assetType, hasResults = !1 }) => {
  const isImage = assetType === "image", { t: t2 } = useTranslation();
  return hasResults ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "caution", padding: [3, 3, 4], border: !0, radius: 2, marginBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: 3, gap: [2, 3, 4], children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: [3, 4], align: "center", style: { gridColumn: isImage ? "span 2" : "span 3" }, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2(`asset-source.delete-dialog.usage-list.warning-${assetType}-is-in-use`, {
        context: asset.originalFilename ? "named" : "unnamed",
        filename: asset.originalFilename
      }) })
    ] }),
    isImage && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { __unstable_checkered: !0, border: !0, radius: 1, style: STYLE_CONFIRM_CARD, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", style: STYLE_IMAGE_WRAPPER, children: /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        src: `${asset.url}?w=200`,
        style: STYLE_ASSET_IMAGE,
        alt: t2("asset-source.usage-list.image-alt"),
        referrerPolicy: "strict-origin-when-cross-origin"
      }
    ) }) })
  ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingX: [2, 3, 4], paddingY: [3, 3, 3, 4], children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: 3, gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { style: { gridColumn: isImage ? "span 2" : "span 3" }, align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Translate,
      {
        t: t2,
        i18nKey: `asset-source.delete-dialog.usage-list.confirm-delete-${assetType}`,
        context: asset.originalFilename ? "named" : "unnamed",
        values: { filename: asset.originalFilename }
      }
    ) }) }),
    isImage && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { __unstable_checkered: !0, border: !0, radius: 1, style: STYLE_CONFIRM_CARD, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", style: STYLE_IMAGE_WRAPPER, children: /* @__PURE__ */ jsxRuntime.jsx(
      "img",
      {
        src: `${asset.url}?w=200`,
        style: STYLE_ASSET_IMAGE,
        alt: t2("asset-source.asset-list.table.preview-alt"),
        referrerPolicy: "strict-origin-when-cross-origin"
      }
    ) }) })
  ] }) });
};
function AssetDeleteDialog({
  asset,
  assetType,
  isDeleting = !1,
  onClose,
  onDelete
}) {
  const { isLoading, referringDocuments } = useReferringDocuments(asset._id), publishedDocuments = React.useMemo(() => {
    const drafts = referringDocuments.reduce(
      (acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc,
      []
    );
    return referringDocuments.filter((doc) => !drafts.includes(doc._id));
  }, [referringDocuments]), hasResults = publishedDocuments.length > 0, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      __unstable_autoFocus: isLoading,
      footer: {
        cancelButton: {
          onClick: onClose,
          text: t2("asset-source.delete-dialog.action.cancel")
        },
        confirmButton: {
          disabled: hasResults,
          icon: icons.TrashIcon,
          loading: isDeleting,
          onClick: onDelete,
          text: t2("asset-source.delete-dialog.action.delete")
        }
      },
      header: t2("asset-source.delete-dialog.header", { context: assetType }),
      id: "asset-dialog",
      onClickOutside: onClose,
      onClose,
      width: 1,
      children: isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) }) : /* @__PURE__ */ jsxRuntime.jsxs(
        ui.Stack,
        {
          paddingX: hasResults ? [2, 3, 4] : 0,
          paddingY: hasResults ? [3, 3, 3, 4] : 0,
          space: 1,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(ConfirmMessage, { asset, assetType, hasResults }),
            hasResults && /* @__PURE__ */ jsxRuntime.jsx(
              AssetUsageList,
              {
                asset,
                referringDocuments: publishedDocuments,
                assetType
              }
            )
          ]
        }
      )
    }
  );
}
const MENU_POPOVER_PROPS = { portal: !0, placement: "right" };
function AssetMenu({
  isSelected,
  border = !0,
  onAction
}) {
  const triggerButtonMode = isSelected ? "default" : "bleed", triggerButtonTone = isSelected ? "primary" : "default", { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        ContextMenuButton,
        {
          mode: border ? "ghost" : triggerButtonMode,
          tone: border ? "default" : triggerButtonTone
        }
      ),
      id: "asset-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            text: t2("asset-source.asset-list.menu.show-usage"),
            icon: icons.LinkIcon,
            onClick: () => {
              onAction({ type: "showUsage" });
            }
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            text: t2("asset-source.asset-list.menu.delete"),
            icon: icons.TrashIcon,
            tone: "critical",
            onClick: () => {
              onAction({ type: "delete" });
            }
          }
        )
      ] }),
      popover: MENU_POPOVER_PROPS
    }
  );
}
function AssetUsageDialog({ asset, assetType, onClose }) {
  const { isLoading, referringDocuments } = useReferringDocuments(asset._id), publishedDocuments = React.useMemo(() => {
    const drafts = referringDocuments.reduce(
      (acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc,
      []
    );
    return referringDocuments.filter((doc) => !drafts.includes(doc._id));
  }, [referringDocuments]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      __unstable_autoFocus: !0,
      header: t2("asset-source.asset-usage-dialog.header", { context: assetType }),
      id: "asset-dialog",
      onClickOutside: onClose,
      onClose,
      width: 1,
      children: isLoading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(
        AssetUsageList,
        {
          asset,
          referringDocuments: publishedDocuments,
          assetType
        }
      )
    }
  );
}
const MIME_TYPES = {
  // Images
  "image/bmp": {
    title: "Bitmap Image"
  },
  "image/jpeg": {
    title: "JPEG Image"
  },
  "image/gif": {
    title: "GIF Image"
  },
  "image/vnd.microsoft.icon": {
    title: "Icon"
  },
  "image/png": {
    title: "PNG Image"
  },
  "image/svg+xml": {
    title: "SVG Image"
  },
  "image/webp": {
    title: "WebP Image"
  },
  "image/tiff": {
    title: "TIFF Image"
  },
  "image/heic": {
    title: "HEIC Image"
  },
  // Audio
  "audio/midi": {
    title: "MIDI Audio"
  },
  "audio/midi-x": {
    title: "MIDI Audio"
  },
  "audio/mpeg": {
    title: "MP3 Audio"
  },
  "audio/ogg": {
    title: "OGG Audio"
  },
  "audio/wav": {
    title: "WAV Audio"
  },
  "audio/webm": {
    title: "WebM Audio"
  },
  "audio/aac": {
    title: "AAC Audio"
  },
  // Video
  "video/x-msvideo": {
    title: "AVI Video"
  },
  "video/mp4": {
    title: "MP4 Video"
  },
  "video/mpeg": {
    title: "MPEG Video"
  },
  "video/ogg": {
    title: "OGG Video"
  },
  "video/webm": {
    title: "WebM Video"
  },
  "video/quicktime": {
    title: "QuickTime Video"
  },
  // Documents
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    title: "Excel Spreadsheet"
  },
  "application/vnd.ms-excel": {
    title: "Excel Spreadsheet"
  },
  "text/plain": {
    title: "Text"
  },
  "text/javascript": {
    title: "JavaScript"
  },
  "text/markdown": {
    title: "Markdown"
  },
  "text/csv": {
    title: "CSV"
  },
  "text/css": {
    title: "CSS"
  },
  "application/pdf": {
    title: "PDF Document"
  },
  "application/xml": {
    title: "XML Document"
  },
  "text/xml": {
    title: "XML Document"
  },
  "application/zip": {
    title: "ZIP Archive"
  },
  "application/vnd.rar": {
    title: "RAR Archive"
  },
  "application/x-7z-compressed": {
    title: "7-zip Archive"
  },
  "application/octet-stream": {
    title: "Binary"
  }
};
function convertMimeTypeToSomethingNice(mimeType) {
  const part = mimeType.replace("x-", "").split("/")[1];
  return part.charAt(0).toUpperCase() + part.slice(1);
}
function formatMimeType(mimeType) {
  return MIME_TYPES != null && MIME_TYPES[mimeType] ? MIME_TYPES[mimeType].title : convertMimeTypeToSomethingNice(mimeType);
}
const CardIconWrapper = styledComponents.styled.span`
  background-color: transparent;
  flex-shrink: 0;
`, CustomFlex = styledComponents.styled(ui.Flex)``, CustomCard$1 = styledComponents.styled(ui.Card)`
  ${(props2) => props2.isSelected && styledComponents.css`
      --card-muted-fg-color: var(--card-bg-color);
      --card-fg-color: var(--card-bg-color);
    `}
`, RowButton = styledComponents.styled(ui.Button)`
  box-shadow: none;
  min-width: 0;
  cursor: pointer;
  position: initial;

  &:before,
  &:after {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
  }

  &:before {
    z-index: 0;
    pointer-events: none;
    border-radius: inherit;
  }

  ${(props2) => props2.isSelected && styledComponents.css`
      --card-muted-fg-color: var(--card-bg-color);
      --card-fg-color: var(--card-bg-color);

      &:before {
        background-color: var(--card-focus-ring-color);
      }

      ${CardIconWrapper} {
        --card-muted-fg-color: var(--card-bg-color);
      }

      ${CustomFlex} {
        --card-muted-fg-color: var(--card-bg-color);
        --card-fg-color: var(--card-bg-color);
      }
    `}

  ${(props2) => !props2.isSelected && styledComponents.css`
      &:hover:before {
        background-color: var(--card-bg-color);
      }

      &:focus:before {
        background-color: var(--card-code-bg-color);
      }

      &:focus-within:before {
        background-color: var(--card-bg-color);
      }
    `}
`, TypeText = styledComponents.styled(ui.Text)`
  overflow-wrap: anywhere;
`, STYLES_ROW_CARD = {
  position: "relative"
}, STYLES_ICON_CARD = { flexShrink: 0 }, STYLES_BUTTON_TEXT = { minWidth: 0 }, STYLES_ASSETMENU_WRAPPER = {
  zIndex: 3,
  marginTop: "-0.5rem",
  marginBottom: "-0.5rem"
}, AssetRow = (props2) => {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), toast = ui.useToast(), deleteRef$ = React.useRef(), [showUsageDialog, setShowUsageDialog] = React.useState(!1), [showDeleteDialog, setShowDeleteDialog] = React.useState(!1), [isDeleting, setIsDeleting] = React.useState(!1), [isOpen, setIsOpen] = React.useState(!1), { asset, onClick, onKeyPress, onDeleteFinished, isSelected, isMobile } = props2, { originalFilename, _id, mimeType, size, _createdAt } = asset, formattedTime = useRelativeTime(_createdAt, { useTemporalPhrase: !0 }), formattedMimeType = formatMimeType(mimeType), formatUnit = useUnitFormatter({ unitDisplay: "short", maximumFractionDigits: 2 }), formattedSize = getHumanFriendlyBytes(size, formatUnit), showTooltip = (originalFilename || "").length > 37, { t: t2 } = useTranslation(), handleConfirmDelete = React.useCallback(() => {
    setShowDeleteDialog(!0);
  }, []), handleDeleteError = React.useCallback(
    (error) => {
      toast.push({
        closable: !0,
        status: "error",
        title: t2("asset-source.file.asset-list.delete-failed"),
        description: error.message
      });
    },
    [t2, toast]
  ), handleDeleteSuccess = React.useCallback(() => {
    toast.push({
      status: "success",
      title: t2("asset-source.file.asset-list.delete-successful")
    });
  }, [t2, toast]), handleDeleteAsset = React.useCallback(() => {
    setIsDeleting(!0), deleteRef$.current = versionedClient.observable.delete(asset._id).subscribe({
      next: () => {
        setIsDeleting(!1), onDeleteFinished == null || onDeleteFinished(asset._id), setShowDeleteDialog(!1), handleDeleteSuccess();
      },
      error: (err) => {
        setIsDeleting(!1), handleDeleteError(err), console.error("Could not delete asset", err);
      }
    });
  }, [
    asset._id,
    handleDeleteError,
    handleDeleteSuccess,
    onDeleteFinished,
    versionedClient.observable
  ]), handleDialogClose = () => {
    setShowUsageDialog(!1), setShowDeleteDialog(!1);
  }, handleToggleUsageDialog = () => {
    setShowUsageDialog(!0);
  }, handleToggleOpen = () => {
    setIsOpen(!isOpen);
  }, handleMenuAction = (action) => {
    action.type === "delete" && handleConfirmDelete(), action.type === "showUsage" && handleToggleUsageDialog();
  }, usageDialog = React.useMemo(() => showUsageDialog && /* @__PURE__ */ jsxRuntime.jsx(AssetUsageDialog, { assetType: "file", asset, onClose: handleDialogClose }), [asset, showUsageDialog]), deleteDialog = React.useMemo(() => showDeleteDialog && /* @__PURE__ */ jsxRuntime.jsx(
    AssetDeleteDialog,
    {
      assetType: "file",
      asset,
      onClose: handleDialogClose,
      onDelete: handleDeleteAsset,
      isDeleting
    }
  ), [asset, handleDeleteAsset, isDeleting, showDeleteDialog]);
  return isMobile ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { paddingBottom: 2, style: STYLES_ROW_CARD, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Grid,
      {
        columns: 4,
        gap: 1,
        style: {
          position: "relative",
          gridTemplateColumns: "1fr 30px",
          opacity: isDeleting ? 0.5 : 1
        },
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            RowButton,
            {
              asset,
              mode: "bleed",
              padding: 0,
              "data-id": _id,
              onClick,
              paddingY: 1,
              radius: 2,
              children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, flex: 2, align: "center", children: [
                /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: CardIconWrapper, padding: 2, tone: "transparent", radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 2, style: STYLES_ICON_CARD, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) }) }),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "flex-end", align: "center", paddingRight: 1, style: STYLES_ASSETMENU_WRAPPER, children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              mode: "bleed",
              fontSize: 1,
              padding: 2,
              onClick: handleToggleOpen,
              icon: isOpen ? icons.ChevronUpIcon : icons.ChevronDownIcon
            }
          ) })
        ]
      }
    ),
    isOpen && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { marginTop: 3, columns: 3, gap: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", children: t2("asset-source.file.asset-list.header.size") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedSize })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", children: t2("asset-source.file.asset-list.header.type") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedMimeType })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", children: t2("asset-source.file.asset-list.header.date-added") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedTime })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, marginTop: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Button,
          {
            fontSize: 1,
            tone: "default",
            mode: "ghost",
            text: t2("asset-source.file.asset-list.action.show-usage.title"),
            onClick: handleToggleUsageDialog,
            icon: icons.LinkIcon
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Button,
          {
            fontSize: 1,
            tone: "critical",
            mode: "ghost",
            text: t2("asset-source.file.asset-list.action.delete.title"),
            icon: icons.TrashIcon,
            disabled: isSelected,
            title: t2(
              isSelected ? "asset-source.file.asset-list.action.delete.disabled-cannot-delete-current-file" : "asset-source.file.asset-list.action.delete.title"
            ),
            onClick: handleConfirmDelete
          }
        )
      ] })
    ] }),
    usageDialog || deleteDialog
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(
    CustomCard$1,
    {
      asset,
      paddingBottom: 1,
      style: STYLES_ROW_CARD,
      radius: 0,
      overflow: "hidden",
      isSelected,
      "aria-selected": "true",
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Grid,
          {
            columns: 4,
            gap: 1,
            "data-id": _id,
            paddingY: 1,
            style: {
              position: "relative",
              gridTemplateColumns: "3fr 1fr 1fr 2fr 30px",
              opacity: isDeleting ? 0.5 : 1
            },
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(
                RowButton,
                {
                  asset,
                  mode: "bleed",
                  "data-id": _id,
                  onClick,
                  padding: 0,
                  onKeyPress,
                  title: t2("asset-source.file.asset-list.item.select-file-tooltip", {
                    filename: originalFilename
                  }),
                  isSelected,
                  radius: 2,
                  children: /* @__PURE__ */ jsxRuntime.jsxs(
                    CustomFlex,
                    {
                      gap: 2,
                      flex: 2,
                      paddingRight: 1,
                      align: "center",
                      onClick,
                      onKeyPress,
                      "data-id": _id,
                      children: [
                        /* @__PURE__ */ jsxRuntime.jsx(
                          ui.Card,
                          {
                            as: CardIconWrapper,
                            padding: 2,
                            tone: "transparent",
                            radius: 2,
                            style: STYLES_ICON_CARD,
                            children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 2, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) })
                          }
                        ),
                        showTooltip && /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: originalFilename, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename }) }),
                        !showTooltip && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, align: "left", textOverflow: "ellipsis", style: STYLES_BUTTON_TEXT, children: originalFilename })
                      ]
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsx(CustomFlex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formattedSize }) }),
              /* @__PURE__ */ jsxRuntime.jsx(CustomFlex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(TypeText, { size: 1, muted: !0, textOverflow: "ellipsis", children: formattedMimeType }) }) }),
              /* @__PURE__ */ jsxRuntime.jsx(CustomFlex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "time", size: 1, muted: !0, dateTime: _createdAt, children: formattedTime }) }),
              /* @__PURE__ */ jsxRuntime.jsx(
                CustomFlex,
                {
                  justify: "flex-end",
                  align: "center",
                  paddingX: 1,
                  paddingY: 1,
                  style: STYLES_ASSETMENU_WRAPPER,
                  children: /* @__PURE__ */ jsxRuntime.jsx(AssetMenu, { border: !1, isSelected: !1, onAction: handleMenuAction })
                }
              )
            ]
          }
        ),
        usageDialog || deleteDialog
      ]
    }
  );
}, STYLES_FILENAME = { paddingLeft: "2.2rem" }, STYLES_GRID = { gridTemplateColumns: "3fr 1fr 1fr 2fr 30px" };
function FileListView(props2) {
  const isMobile = ui.useMediaIndex() < 2, { assets, onClick, onKeyPress, onDeleteFinished, selectedAssets, isLoading } = props2, { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, paddingBottom: 2, marginBottom: 1, children: isMobile ? /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { style: STYLES_GRID, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 2, paddingLeft: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.filename") }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: STYLES_GRID, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 2, style: STYLES_FILENAME, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.filename") }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.size") }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.type") }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("asset-source.file.asset-list.header.date-added") }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
      isLoading && assets.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 4, paddingBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }) }) }),
      assets.map((asset) => /* @__PURE__ */ jsxRuntime.jsx(
        AssetRow,
        {
          asset,
          isMobile,
          isSelected: selectedAssets.some((selected) => selected._id === asset._id),
          onClick,
          onKeyPress,
          onDeleteFinished
        },
        asset._id
      ))
    ] })
  ] });
}
const DPI = typeof window > "u" || !window.devicePixelRatio ? 1 : Math.round(window.devicePixelRatio), Image$6 = styledComponents.styled.img`
  position: absolute;
  z-index: 1;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
`, Container$1 = styledComponents.styled(ui.Card)`
  position: relative;
  z-index: 1;
  padding-bottom: 100%;
`, Root$c = styledComponents.styled.div`
  position: relative;
  display: inherit;
`, MenuContainer = styledComponents.styled.div`
  box-sizing: border-box;
  position: absolute;
  z-index: 2;
  top: 3px;
  right: 3px;

  & button[data-selected] {
    display: block;
  }

  @media (hover: hover) {
    // If hover is supported, hide the buttons until the user hovers or focuses the asset
    // Use opacity to enable the buttons to still be focusable
    & button {
      opacity: 0;
    }

    ${Root$c}:hover & {
      button {
        opacity: 1;
      }
    }

    ${Root$c}:focus-within & {
      button {
        opacity: 1;
      }
    }
  }
`, AssetThumb = React.memo(function(props2) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), toast = ui.useToast(), deleteRef$ = React.useRef(), { asset, onClick, onKeyPress, onDeleteFinished, isSelected } = props2, [showUsageDialog, setShowUsageDialog] = React.useState(!1), [showDeleteDialog, setShowDeleteDialog] = React.useState(!1), [isDeleting, setIsDeleting] = React.useState(!1), { t: t2 } = useTranslation();
  React.useEffect(() => () => {
    deleteRef$.current && deleteRef$.current.unsubscribe();
  }, []);
  const handleConfirmDelete = React.useCallback(() => {
    setShowDeleteDialog(!0);
  }, [setShowDeleteDialog]), handleDialogClose = React.useCallback(() => {
    setShowUsageDialog(!1), setShowDeleteDialog(!1);
  }, [setShowUsageDialog, setShowDeleteDialog]), handleToggleUsageDialog = React.useCallback(() => {
    setShowUsageDialog(!0);
  }, [setShowUsageDialog]), handleDeleteError = React.useCallback(
    (error) => {
      toast.push({
        closable: !0,
        status: "error",
        title: t2("asset-source.image.asset-list.delete-failed"),
        description: error.message
      });
    },
    [t2, toast]
  ), handleDeleteSuccess = React.useCallback(() => {
    toast.push({
      status: "success",
      title: t2("asset-source.image.asset-list.delete-successful")
    });
  }, [t2, toast]), handleDeleteAsset = React.useCallback(() => {
    setIsDeleting(!0), deleteRef$.current = versionedClient.observable.delete(asset._id).subscribe({
      next: () => {
        setIsDeleting(!1), onDeleteFinished(asset._id), setShowDeleteDialog(!1), handleDeleteSuccess();
      },
      error: (err) => {
        setIsDeleting(!1), handleDeleteError(err), console.error("Could not delete asset", err);
      }
    });
  }, [
    asset._id,
    handleDeleteError,
    handleDeleteSuccess,
    onDeleteFinished,
    versionedClient.observable
  ]), handleMenuAction = React.useCallback(
    (action) => {
      action.type === "delete" && handleConfirmDelete(), action.type === "showUsage" && handleToggleUsageDialog();
    },
    [handleConfirmDelete, handleToggleUsageDialog]
  ), usageDialog = React.useMemo(() => showUsageDialog && /* @__PURE__ */ jsxRuntime.jsx(AssetUsageDialog, { assetType: "file", asset, onClose: handleDialogClose }), [asset, handleDialogClose, showUsageDialog]), deleteDialog = React.useMemo(() => showDeleteDialog && /* @__PURE__ */ jsxRuntime.jsx(
    AssetDeleteDialog,
    {
      assetType: "file",
      asset,
      onClose: handleDialogClose,
      onDelete: handleDeleteAsset,
      isDeleting
    }
  ), [asset, handleDeleteAsset, handleDialogClose, isDeleting, showDeleteDialog]), { originalFilename, _id, url } = asset, imgH = 200 * Math.max(1, DPI), imageUrl = url.includes(".gif") ? `${url}?h=${imgH}&fit=max&fm=jpg` : `${url}?h=${imgH}&fit=max`;
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$c, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        selected: isSelected,
        tabIndex: 0,
        "data-id": _id,
        mode: "ghost",
        onKeyPress,
        padding: 0,
        style: { padding: 2 },
        children: /* @__PURE__ */ jsxRuntime.jsxs(Container$1, { __unstable_checkered: !0, children: [
          /* @__PURE__ */ jsxRuntime.jsx(Image$6, { alt: originalFilename, src: imageUrl, onClick, "data-id": _id }),
          isDeleting && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(MenuContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(AssetMenu, { isSelected, onAction: handleMenuAction }) }),
    usageDialog || deleteDialog
  ] });
}), ThumbGrid = styledComponents.styled(ui.Grid)`
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
`;
function ImageListView(props2) {
  const { isLoading, assets, selectedAssets, onItemClick, onItemKeyPress, onDeleteFinished } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ThumbGrid, { gap: 2, children: assets.map((asset) => /* @__PURE__ */ jsxRuntime.jsx(
      AssetThumb,
      {
        asset,
        isSelected: selectedAssets.some((selected) => selected._id === asset._id),
        onClick: onItemClick,
        onKeyPress: onItemKeyPress,
        onDeleteFinished
      },
      asset._id
    )) }),
    isLoading && assets.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }) }),
    !isLoading && assets.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0 })
  ] });
}
const PER_PAGE = 200, ASSET_TYPE_IMAGE = "sanity.imageAsset", ASSET_TYPE_FILE = "sanity.fileAsset", buildFilterQuery = (acceptParam) => {
  const WILDCARD_ACCEPT = ["image/*", "audio/*", "video/*"], typesForFilter = acceptParam.split(",").map((accept) => accept.trim()).reduce(
    (acceptTypes, acceptValue) => WILDCARD_ACCEPT.includes(acceptValue) ? {
      ...acceptTypes,
      wildcards: `mimeType match '${acceptValue}' || ${acceptTypes.wildcards}`
    } : acceptValue.indexOf(".") === 0 ? {
      ...acceptTypes,
      extensions: `'${acceptValue.replace(".", "")}', ${acceptTypes.extensions}`
    } : { ...acceptTypes, mimes: `'${acceptValue}', ${acceptTypes.mimes}` },
    { mimes: "", extensions: "", wildcards: "" }
  );
  return `&&
  (
    ${typesForFilter.wildcards}
    extension in [${typesForFilter.extensions}] ||
    mimeType in [${typesForFilter.mimes}]
  )`;
}, buildQuery = (start = 0, end = PER_PAGE, assetType = ASSET_TYPE_IMAGE, acceptParam) => {
  const filterCondition = acceptParam.length > 0 ? buildFilterQuery(acceptParam) : "";
  return `
  *[_type == "${assetType}" ${filterCondition}] | order(_updatedAt desc) [${start}...${end}] {
    _id,
    _updatedAt,
    _createdAt,
    url,
    originalFilename,
    mimeType,
    extension,
    size,
    metadata {dimensions}
  }
`;
}, CardLoadMore = styledComponents.styled(ui.Card)`
  border-top: 1px solid var(--card-border-color);
  position: sticky;
  bottom: 0;
  z-index: 200;
`, DefaultAssetSource = function(props2, ref) {
  const client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), versionedClient = React.useMemo(() => client2.withConfig({ apiVersion: "2023-02-14" }), [client2]), _elementId = React.useRef(`default-asset-source-${uniqueId__default.default()}`), currentPageNumber = React.useRef(0), { t: t2 } = useTranslation(), fetch$ = React.useRef(), [assets, setAssets] = React.useState([]), [isLastPage, setIsLastPage] = React.useState(!1), [hasResetAutoFocus, setHasResetFocus] = React.useState(!1), [isLoading, setIsLoading] = React.useState(!0), { selectedAssets, assetType = "image", dialogHeaderTitle, onClose, onSelect, accept } = props2, isImageOnlyWildCard = accept && accept === "image/*" && assetType === "image", fetchPage = React.useCallback(
    (pageNumber) => {
      const start = pageNumber * PER_PAGE, end = start + PER_PAGE, isImageAssetType = assetType === "image", tag = isImageAssetType ? "asset.image-list" : "asset.file-list", assetTypeParam = isImageAssetType ? ASSET_TYPE_IMAGE : ASSET_TYPE_FILE;
      setIsLoading(!0), typeof accept < "u" && (fetch$.current = versionedClient.observable.fetch(buildQuery(start, end, assetTypeParam, accept), {}, { tag }).subscribe((result) => {
        setIsLastPage(result.length < PER_PAGE), setAssets((prevState) => prevState.concat(result)), setIsLoading(!1);
      }));
    },
    [assetType, accept, versionedClient]
  ), handleDeleteFinished = React.useCallback(
    (id2) => {
      setAssets((prevState) => prevState.filter((asset) => asset._id !== id2));
    },
    [setAssets]
  ), select2 = React.useCallback(
    (id2) => {
      assets.find((doc) => doc._id === id2) && onSelect([{ kind: "assetDocumentId", value: id2 }]);
    },
    [assets, onSelect]
  ), handleItemClick = React.useCallback(
    (event) => {
      event.preventDefault();
      const id2 = event.currentTarget.getAttribute("data-id");
      if (!id2)
        throw new Error("Missing data-id attribute on item");
      select2(id2);
    },
    [select2]
  ), handleItemKeyPress = React.useCallback(
    (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        const id2 = event.currentTarget.getAttribute("data-id");
        if (!id2)
          throw new Error("Missing data-id attribute on item");
        select2(id2);
      }
    },
    [select2]
  ), handleClose = React.useCallback(() => {
    onClose && onClose();
  }, [onClose]), handleFetchNextPage = React.useCallback(
    (event) => {
      event.preventDefault(), fetchPage(++currentPageNumber.current);
    },
    [fetchPage]
  );
  React.useEffect(() => (fetchPage(currentPageNumber.current), () => {
    fetch$.current && fetch$.current.unsubscribe();
  }), [fetchPage]), React.useEffect(() => {
    !isLoading && (!currentPageNumber.current || currentPageNumber.current === 0) && setHasResetFocus(!0);
  }, [isLoading]);
  const listFormat = useListFormat({ style: "narrow" });
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      __unstable_autoFocus: hasResetAutoFocus,
      header: dialogHeaderTitle || t2("asset-source.dialog.default-title", {
        context: assetType
      }),
      id: _elementId.current,
      onClickOutside: handleClose,
      onClose: handleClose,
      ref,
      width: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
        !isImageOnlyWildCard && !isLoading && (accept == null ? void 0 : accept.length) > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "primary", padding: 3, border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {}) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
            Translate,
            {
              t: t2,
              i18nKey: "asset-source.dialog.accept-message",
              values: {
                acceptTypes: listFormat.format(accept.split(",").map((type) => type.trim()))
              }
            }
          ) })
        ] }) }),
        assetType === "file" && /* @__PURE__ */ jsxRuntime.jsx(
          FileListView,
          {
            assets,
            onDeleteFinished: handleDeleteFinished,
            onClick: handleItemClick,
            onKeyPress: handleItemKeyPress,
            isLoading,
            selectedAssets
          }
        ),
        assetType === "image" && /* @__PURE__ */ jsxRuntime.jsx(
          ImageListView,
          {
            assets,
            onDeleteFinished: handleDeleteFinished,
            onItemClick: handleItemClick,
            onItemKeyPress: handleItemKeyPress,
            isLoading,
            selectedAssets
          }
        ),
        assets.length > 0 && !isLastPage && /* @__PURE__ */ jsxRuntime.jsx(CardLoadMore, { tone: "default", padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            type: "button",
            icon: icons.DownloadIcon,
            loading: isLoading,
            onClick: handleFetchNextPage,
            size: "large",
            text: t2("asset-source.dialog.load-more"),
            tone: "primary"
          }
        ) }) })
      ] })
    }
  );
}, DefaultSource = React.memo(React.forwardRef(DefaultAssetSource)), FileSource = {
  name: "sanity-default",
  title: "Uploaded files",
  i18nKey: "asset-source.file.title",
  component: DefaultSource,
  icon: icons.DocumentsIcon
}, ImageSource = {
  name: "sanity-default",
  title: "Uploaded images",
  i18nKey: "asset-source.image.title",
  component: DefaultSource,
  icon: icons.ImageIcon
}, initialDocumentBadges = [], initialDocumentActions = [], initialLanguageFilter = [], schemaTypesReducer = (prev, { schema: schema2 }, context) => {
  const schemaTypes = schema2 == null ? void 0 : schema2.types;
  if (!schemaTypes) return prev;
  if (typeof schemaTypes == "function") return schemaTypes(prev, context);
  if (Array.isArray(schemaTypes)) return [...prev, ...schemaTypes];
  throw new Error(
    `Expected \`schema.types\` to be an array or a function, but received ${getPrintableType(
      schemaTypes
    )}`
  );
}, resolveProductionUrlReducer = async (prev, { document: document2 }, context) => {
  const resolveProductionUrl = document2 == null ? void 0 : document2.productionUrl;
  return resolveProductionUrl ? await resolveProductionUrl(prev, context) : prev;
}, toolsReducer = (prev, { tools }, context) => {
  if (!tools) return prev;
  if (typeof tools == "function") return tools(prev, context);
  if (Array.isArray(tools)) return [...prev, ...tools];
  throw new Error(
    `Expected \`tools\` to be an array or a function, but received ${getPrintableType(tools)}`
  );
}, schemaTemplatesReducer = (prev, { schema: schema2 }, context) => {
  const schemaTemplates = schema2 == null ? void 0 : schema2.templates;
  if (!schemaTemplates) return prev;
  if (typeof schemaTemplates == "function") return schemaTemplates(prev, context);
  if (Array.isArray(schemaTemplates)) return [...prev, ...schemaTemplates];
  throw new Error(
    `Expected \`schema.templates\` to be an array or a function, but received ${getPrintableType(
      schemaTemplates
    )}`
  );
}, localeDefReducer = (prev, { i18n }, context) => {
  const locales = i18n == null ? void 0 : i18n.locales;
  if (!locales) return prev;
  if (typeof locales == "function") return locales(prev, context);
  if (Array.isArray(locales)) return [...prev, ...locales];
  throw new Error(
    `Expected \`i18n.locales\` to be an array or a function, but received ${getPrintableType(
      locales
    )}`
  );
}, localeBundlesReducer = (prev, { i18n }, context) => {
  const bundles = i18n == null ? void 0 : i18n.bundles;
  if (!bundles) return prev;
  if (Array.isArray(bundles)) return [...prev, ...bundles];
  if (typeof bundles == "function") return bundles(prev, context);
  throw new Error(
    `Expected \`i18n.bundles\` to be an array or a function, but received ${typeof bundles}`
  );
}, documentBadgesReducer = (prev, { document: document2 }, context) => {
  const documentBadges = document2 == null ? void 0 : document2.badges;
  if (!documentBadges) return prev;
  if (typeof documentBadges == "function") return documentBadges(prev, context);
  if (Array.isArray(documentBadges)) return [...prev, ...documentBadges];
  throw new Error(
    `Expected \`document.badges\` to be an array or a function, but received ${getPrintableType(
      documentBadges
    )}`
  );
}, documentActionsReducer = (prev, { document: document2 }, context) => {
  const documentActions = document2 == null ? void 0 : document2.actions;
  if (!documentActions) return prev;
  if (typeof documentActions == "function") return documentActions(prev, context);
  if (Array.isArray(documentActions)) return [...prev, ...documentActions];
  throw new Error(
    `Expected \`document.actions\` to be an array or a function, but received ${getPrintableType(
      documentActions
    )}`
  );
}, newDocumentOptionsResolver = (prev, { document: document2 }, context) => {
  const resolveNewDocumentOptions = document2 == null ? void 0 : document2.newDocumentOptions;
  if (!resolveNewDocumentOptions) return prev;
  if (typeof resolveNewDocumentOptions != "function")
    throw new Error(
      `Expected \`document.resolveNewDocumentOptions\` to be a function, but received ${getPrintableType(
        resolveNewDocumentOptions
      )}`
    );
  return resolveNewDocumentOptions(prev, context);
}, fileAssetSourceResolver = (prev, { form }, context) => {
  var _a2;
  const assetSources = (_a2 = form == null ? void 0 : form.file) == null ? void 0 : _a2.assetSources;
  if (!assetSources) return prev;
  if (typeof assetSources == "function") return assetSources(prev, context);
  if (Array.isArray(assetSources)) return [...prev, ...assetSources];
  throw new Error(
    `Expected \`form.file.assetSources\` to be an array or a function, but received ${getPrintableType(
      assetSources
    )}`
  );
}, imageAssetSourceResolver = (prev, { form }, context) => {
  var _a2;
  const assetSources = (_a2 = form == null ? void 0 : form.image) == null ? void 0 : _a2.assetSources;
  if (!assetSources) return prev;
  if (typeof assetSources == "function") return assetSources(prev, context);
  if (Array.isArray(assetSources)) return [...prev, ...assetSources];
  throw new Error(
    `Expected \`form.image.assetSources\` to be an array or a function, but received ${getPrintableType(
      assetSources
    )}`
  );
}, documentLanguageFilterReducer = (prev, { document: document2 }, context) => {
  const resolveDocumentLanguageFilter = document2 == null ? void 0 : document2.unstable_languageFilter;
  if (!resolveDocumentLanguageFilter) return prev;
  if (typeof resolveDocumentLanguageFilter == "function")
    return resolveDocumentLanguageFilter(prev, context);
  if (Array.isArray(resolveDocumentLanguageFilter))
    return [...prev, ...resolveDocumentLanguageFilter];
  throw new Error(
    `Expected \`document.unstable_languageFilter\` to be an array or a function, but received ${getPrintableType(
      resolveDocumentLanguageFilter
    )}`
  );
}, documentInspectorsReducer = (prev, { document: document2 }, context) => {
  const resolveInspectorsFilter = document2 == null ? void 0 : document2.inspectors;
  if (!resolveInspectorsFilter) return prev;
  if (typeof resolveInspectorsFilter == "function") return resolveInspectorsFilter(prev, context);
  if (Array.isArray(resolveInspectorsFilter)) return [...prev, ...resolveInspectorsFilter];
  throw new Error(
    `Expected \`document.inspectors\` to be an array or a function, but received ${getPrintableType(
      resolveInspectorsFilter
    )}`
  );
}, documentCommentsEnabledReducer = (opts) => {
  const { config, context, initialValue } = opts;
  return flattenConfig(config, []).reduce((acc, { config: innerConfig }) => {
    var _a2, _b, _c, _d, _e;
    const resolver = (_e = (_b = (_a2 = innerConfig.document) == null ? void 0 : _a2.comments) == null ? void 0 : _b.enabled) != null ? _e : (_d = (_c = innerConfig.document) == null ? void 0 : _c.unstable_comments) == null ? void 0 : _d.enabled;
    if (!resolver && typeof resolver != "boolean") return acc;
    if (typeof resolver == "function") return resolver(context);
    if (typeof resolver == "boolean") return resolver;
    throw new Error(
      `Expected \`document.comments.enabled\` to be a boolean or a function, but received ${getPrintableType(
        resolver
      )}`
    );
  }, initialValue);
}, internalTasksReducer = (opts) => {
  const { config } = opts;
  return flattenConfig(config, []).reduce(
    (acc, { config: innerConfig }) => {
      const resolver = innerConfig.__internal_tasks;
      if (!resolver) return acc;
      if (typeof resolver == "object" && resolver.footerAction) return resolver;
      throw new Error(
        `Expected \`__internal__tasks\` to be an object with footerAction, but received ${getPrintableType(
          resolver
        )}`
      );
    },
    void 0
  );
}, partialIndexingEnabledReducer = (opts) => {
  const { config, initialValue } = opts;
  return flattenConfig(config, []).reduce((acc, { config: innerConfig }) => {
    var _a2, _b;
    const resolver = (_b = (_a2 = innerConfig.search) == null ? void 0 : _a2.unstable_partialIndexing) == null ? void 0 : _b.enabled;
    if (!resolver && typeof resolver != "boolean") return acc;
    if (typeof resolver == "boolean") return resolver;
    throw new Error(
      `Expected \`search.unstable_partialIndexing.enabled\` to be a boolean, but received ${getPrintableType(
        resolver
      )}`
    );
  }, initialValue);
}, legacySearchEnabledReducer = (prev, { search: search2 }) => typeof (search2 == null ? void 0 : search2.enableLegacySearch) < "u" ? search2.enableLegacySearch : prev;
function resolveConfigProperty({
  config: inputConfig,
  context,
  initialValue,
  propertyName,
  ...reducers
}) {
  const configs = flattenConfig(inputConfig, []);
  if ("reducer" in reducers)
    return configs.reduce((acc, { config, path }) => {
      try {
        return reducers.reducer(acc, config, context);
      } catch (e) {
        throw new ConfigPropertyError({
          propertyName,
          path,
          cause: e
        });
      }
    }, initialValue);
  const reducer2 = reducers.asyncReducer;
  return (async () => {
    let current = initialValue;
    for (const { config, path } of configs)
      try {
        current = await reducer2(current, config, context);
      } catch (e) {
        throw new ConfigPropertyError({
          propertyName,
          path,
          cause: e
        });
      }
    return current;
  })();
}
function createSanityI18nBackend(options) {
  const { bundles } = options;
  function init() {
  }
  function read2(locale, namespace, callback) {
    const loadable = bundles.filter(
      (bundle) => bundle.locale === locale && bundle.namespace === namespace
    );
    if (loadable.length === 0) {
      callback(
        `No translations found for namespace "${namespace}", language "${locale}"`,
        void 0
        // Returning undefined here will i18next _not_ retry
      );
      return;
    }
    loadBundles(loadable).then((resources) => callback(null, resources)).catch((err) => callback(err, !0));
  }
  return {
    type: "backend",
    init,
    read: read2
  };
}
async function loadBundles(bundles) {
  var _a2, _b;
  const resolved = await Promise.all(
    bundles.map(async (bundle) => ({
      ...bundle,
      resources: await loadBundleResources(bundle)
    }))
  ), base = {};
  for (const item of resolved) {
    const deep = (_a2 = item.deep) != null ? _a2 : !0, overwrite = (_b = item.overwrite) != null ? _b : !0;
    deep ? deepExtend(base, item.resources, overwrite) : overwrite ? Object.assign(base, item.resources) : Object.assign({}, item.resources, base);
  }
  return base;
}
async function loadBundleResources(bundle) {
  if (typeof bundle.resources != "function")
    return bundle.resources;
  const resources = await bundle.resources();
  return maybeUnwrapModule(resources);
}
function deepExtend(target, source, overwrite = !1) {
  for (const prop in source) {
    if (prop === "__proto__" || prop === "constructor")
      continue;
    if (!(prop in target)) {
      target[prop] = source[prop];
      continue;
    }
    const targetLeaf = target[prop], sourceLeaf = source[prop], targetIsString = isStringLeaf(targetLeaf), sourceIsString = isStringLeaf(sourceLeaf);
    if ((targetIsString || sourceIsString) && overwrite) {
      target[prop] = source[prop];
      continue;
    }
    if (targetIsString || sourceIsString)
      continue;
    const sourceIsArray = Array.isArray(sourceLeaf), targetIsArray = Array.isArray(targetLeaf);
    if (sourceIsArray || targetIsArray) {
      overwrite && (target[prop] = sourceLeaf);
      continue;
    }
    deepExtend(targetLeaf, sourceLeaf, overwrite);
  }
  return target;
}
function isStringLeaf(target) {
  return typeof target == "string" || target instanceof String;
}
function maybeUnwrapModule(maybeModule) {
  return isWrappedModule(maybeModule) ? maybeModule.default : maybeModule;
}
function isWrappedModule(mod) {
  return "default" in mod && typeof mod.default == "object" && isPlainObject__default.default(mod.default);
}
function prepareI18n(source) {
  const { projectId, dataset, name: sourceName } = source, context = { projectId, dataset }, locales = resolveConfigProperty({
    config: source,
    context,
    propertyName: "i18n.locales",
    reducer: localeDefReducer,
    initialValue: [defaultLocale]
  }), bundles = resolveConfigProperty({
    config: source,
    context,
    propertyName: "i18n.bundles",
    reducer: localeBundlesReducer,
    initialValue: normalizeResourceBundles(locales)
  });
  return createI18nApi({
    locales,
    bundles,
    projectId,
    sourceName
  });
}
function createI18nApi({
  locales,
  bundles,
  projectId,
  sourceName
}) {
  const namespaceNames = new Set(bundles.map((bundle) => bundle.namespace)), options = getI18NextOptions(projectId, sourceName, locales, namespaceNames), i18nInstance = i18next.createInstance().use(createSanityI18nBackend({ bundles })).use(reactI18next.initReactI18next);
  i18nInstance.init(options).catch((err) => {
    console.error("Failed to initialize i18n backend: %s", err);
  });
  const reducedLocales = locales.map(reduceLocaleDefinition);
  return {
    /** @public */
    source: {
      get currentLocale() {
        var _a2;
        return (_a2 = reducedLocales.find((locale) => locale.id === i18nInstance.language)) != null ? _a2 : defaultLocale;
      },
      loadNamespaces(namespaces) {
        const missing = namespaces.filter((ns) => !i18nInstance.hasLoadedNamespace(ns));
        return missing.length === 0 ? Promise.resolve() : i18nInstance.loadNamespaces(missing);
      },
      locales: reducedLocales,
      t: maybeWrapT(i18nInstance.t)
    },
    /** @internal */
    // @ts-expect-error types are missing
    i18next: i18nInstance
  };
}
function normalizeResourceBundles(locales) {
  const normalized = [];
  for (const lang of locales) {
    if (lang.bundles && !Array.isArray(lang.bundles))
      throw new Error(`Resource bundle for locale ${lang.id} is not an array`);
    if (lang.bundles)
      for (const bundle of lang.bundles) {
        if ("locale" in bundle && bundle.locale !== lang.id)
          throw new Error(`Resource bundle inside locale ${lang.id} has mismatching locale id`);
        if (!bundle.namespace)
          throw new Error(`Resource bundle for locale ${lang.id} is missing namespace`);
        normalized.push("locale" in bundle ? bundle : { ...bundle, locale: lang.id });
      }
  }
  return normalized;
}
const defaultOptions = {
  /**
   * Even though we're only defining the studio namespace, i18next will still load requested
   * namespaces through the backend. The reason why we're defining the namespace at all is to
   * prevent i18next from (trying) to load the i18next default `translation` namespace.
   */
  ns: [studioLocaleNamespace],
  defaultNS: studioLocaleNamespace,
  partialBundledLanguages: !0,
  // Fall back to English (US) locale
  fallbackLng: defaultLocale.id,
  // This will be overriden with the users detected/preferred locale before initing,
  // but to satisfy the init options and prevent mistakes, we include a default here.
  lng: defaultLocale.id,
  // In rare cases we'll want to be able to debug i18next - there is a `debug` option
  // in the studio i18n configuration for that, which will override this value.
  debug: DEBUG_I18N,
  // When specifying language 'en-US', do not load 'en-US', 'en', 'dev' - only `en-US`.
  load: "currentOnly",
  // We always use our "backend" for loading translations, allowing us to handle i18n resources
  // in a single place with a single approach. This means we shouldn't need to wait for the init,
  // as any missing translations will be loaded async (through react suspense).
  initImmediate: !0,
  // Because we use i18next-react, we do not need to escale values
  interpolation: {
    escapeValue: !1
  },
  // Theoretically, if the framework somehow gets new translations added, re-render.
  // Note that this shouldn't actually happen, as we only use the Sanity backend
  react: {
    bindI18nStore: "added"
  }
};
function getI18NextOptions(projectId, sourceName, locales, namespaces) {
  var _a2, _b;
  const preferredLocaleId = getPreferredLocale(projectId, sourceName), preferredLocale = locales.find((l) => l.id === preferredLocaleId), lastLocale = locales[locales.length - 1], locale = (_b = (_a2 = preferredLocale == null ? void 0 : preferredLocale.id) != null ? _a2 : lastLocale.id) != null ? _b : defaultOptions.lng;
  return {
    ...defaultOptions,
    ns: Array.from(namespaces),
    // For now, let us load all namespaces. We can optimize later.
    lng: locale,
    supportedLngs: locales.map((def) => def.id)
  };
}
function reduceLocaleDefinition(definition) {
  const { bundles, ...locale } = definition;
  return locale;
}
function createFilterDefinitionDictionary(filterDefinitions2) {
  return filterDefinitions2.reduce((acc, val) => (acc[val.name] = val, acc), {});
}
function defineSearchFilter(filterDef) {
  return filterDef;
}
function defineSearchFilterOperators(operators2) {
  return operators2;
}
function getFilterDefinition(definitions, filterName) {
  return definitions[filterName];
}
function getSupportedFieldTypes(filterDefs) {
  return filterDefs.reduce((acc, val) => (val.type === "field" && acc.push(val.fieldType), acc), []);
}
const filterDefinitions = [
  // 'Pinned' filters
  {
    fieldPath: "_updatedAt",
    icon: icons.CalendarIcon,
    operators: [
      { name: "dateTimeLast", type: "item" },
      { type: "divider" },
      { name: "dateTimeRange", type: "item" },
      { name: "dateTimeAfter", type: "item" },
      { name: "dateTimeBefore", type: "item" },
      { type: "divider" },
      { name: "dateTimeEqual", type: "item" },
      { name: "dateTimeNotEqual", type: "item" }
    ],
    title: "Edited at",
    name: "updatedAt",
    type: "pinned"
  },
  {
    fieldPath: "_createdAt",
    icon: icons.CalendarIcon,
    operators: [
      { name: "dateTimeLast", type: "item" },
      { type: "divider" },
      { name: "dateTimeRange", type: "item" },
      { name: "dateTimeAfter", type: "item" },
      { name: "dateTimeBefore", type: "item" },
      { type: "divider" },
      { name: "dateTimeEqual", type: "item" },
      { name: "dateTimeNotEqual", type: "item" }
    ],
    title: "Created at",
    name: "createdAt",
    type: "pinned"
  },
  {
    icon: icons.LinkIcon,
    operators: [
      { name: "referencesDocument", type: "item" },
      { name: "referencesAssetImage", type: "item" },
      { name: "referencesAssetFile", type: "item" }
    ],
    title: "Contains document, image or file",
    name: "references",
    type: "pinned"
  },
  // 'Field' filters
  {
    fieldType: "array",
    icon: icons.UlistIcon,
    name: "array",
    operators: [
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" },
      { type: "divider" },
      { name: "arrayCountEqual", type: "item" },
      { name: "arrayCountNotEqual", type: "item" },
      { type: "divider" },
      { name: "arrayCountGt", type: "item" },
      { name: "arrayCountGte", type: "item" },
      { name: "arrayCountLt", type: "item" },
      { name: "arrayCountLte", type: "item" },
      { type: "divider" },
      { name: "arrayCountRange", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "array",
    icon: icons.UlistIcon,
    name: "arrayList",
    operators: [
      { name: "arrayListIncludes", type: "item" },
      { name: "arrayListNotIncludes", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" },
      { type: "divider" },
      { name: "arrayCountEqual", type: "item" },
      { name: "arrayCountNotEqual", type: "item" },
      { type: "divider" },
      { name: "arrayCountGt", type: "item" },
      { name: "arrayCountGte", type: "item" },
      { name: "arrayCountLt", type: "item" },
      { name: "arrayCountLte", type: "item" },
      { type: "divider" },
      { name: "arrayCountRange", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "array",
    icon: icons.UlistIcon,
    name: "arrayReferences",
    operators: [
      { name: "arrayReferenceIncludes", type: "item" },
      { name: "arrayReferenceNotIncludes", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" },
      { type: "divider" },
      { name: "arrayCountEqual", type: "item" },
      { name: "arrayCountNotEqual", type: "item" },
      { type: "divider" },
      { name: "arrayCountGt", type: "item" },
      { name: "arrayCountGte", type: "item" },
      { name: "arrayCountLt", type: "item" },
      { name: "arrayCountLte", type: "item" },
      { type: "divider" },
      { name: "arrayCountRange", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "boolean",
    icon: icons.CheckmarkCircleIcon,
    name: "boolean",
    operators: [
      { name: "booleanEqual", type: "item" },
      { type: "divider" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "date",
    icon: icons.CalendarIcon,
    name: "date",
    operators: [
      { name: "dateLast", type: "item" },
      { type: "divider" },
      { name: "dateRange", type: "item" },
      { name: "dateAfter", type: "item" },
      { name: "dateBefore", type: "item" },
      { type: "divider" },
      { name: "dateEqual", type: "item" },
      { name: "dateNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "datetime",
    icon: icons.CalendarIcon,
    name: "datetime",
    operators: [
      { name: "dateTimeLast", type: "item" },
      { type: "divider" },
      { name: "dateTimeRange", type: "item" },
      { name: "dateTimeAfter", type: "item" },
      { name: "dateTimeBefore", type: "item" },
      { type: "divider" },
      { name: "dateTimeEqual", type: "item" },
      { name: "dateTimeNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "email",
    icon: icons.StringIcon,
    name: "email",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "file",
    icon: icons.DocumentIcon,
    name: "file",
    operators: [
      { name: "assetFileEqual", type: "item" },
      { name: "assetFileNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "image",
    icon: icons.ImageIcon,
    name: "image",
    operators: [
      { name: "assetImageEqual", type: "item" },
      { name: "assetImageNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "number",
    icon: icons.NumberIcon,
    name: "number",
    operators: [
      { name: "numberEqual", type: "item" },
      { name: "numberNotEqual", type: "item" },
      { type: "divider" },
      { name: "numberGt", type: "item" },
      { name: "numberGte", type: "item" },
      { name: "numberLt", type: "item" },
      { name: "numberLte", type: "item" },
      { type: "divider" },
      { name: "numberRange", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "array",
    icon: icons.BlockContentIcon,
    name: "portableText",
    operators: [
      { name: "portableTextMatches", type: "item" },
      { name: "portableTextNotMatches", type: "item" },
      { type: "divider" },
      { name: "portableTextEqual", type: "item" },
      { name: "portableTextNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "reference",
    icon: icons.LinkIcon,
    name: "reference",
    operators: [
      { name: "referenceEqual", type: "item" },
      { name: "referenceNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "slug",
    icon: icons.StringIcon,
    name: "slug",
    operators: [
      { name: "slugMatches", type: "item" },
      { name: "slugNotMatches", type: "item" },
      { type: "divider" },
      { name: "slugEqual", type: "item" },
      { name: "slugNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "string",
    icon: icons.StringIcon,
    name: "string",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "string",
    icon: icons.ChevronDownIcon,
    name: "stringList",
    operators: [
      { name: "stringListEqual", type: "item" },
      { name: "stringListNotEqual", type: "item" },
      { type: "divider" },
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "text",
    icon: icons.StringIcon,
    name: "text",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  },
  {
    fieldType: "url",
    icon: icons.StringIcon,
    name: "url",
    operators: [
      { name: "stringMatches", type: "item" },
      { name: "stringNotMatches", type: "item" },
      { type: "divider" },
      { name: "stringEqual", type: "item" },
      { name: "stringNotEqual", type: "item" },
      { type: "divider" },
      { name: "defined", type: "item" },
      { name: "notDefined", type: "item" }
    ],
    type: "field"
  }
];
function useDateTimeFormat(options = {}) {
  const currentLocale = useCurrentLocale().id;
  return intlCache.dateTimeFormat(currentLocale, options);
}
function useUnitFormatter(options = {}) {
  const currentLocale = useCurrentLocale().id, defaultOptions2 = {
    unitDisplay: "long",
    ...options,
    style: "unit"
  };
  return function(value, unit) {
    return intlCache.numberFormat(currentLocale, { ...defaultOptions2, unit }).format(value);
  };
}
function ReferencePreviewTitle({
  documentId,
  schemaType
}) {
  const documentPreviewStore = useDocumentPreviewStore(), { draft, published, isLoading } = reactRx.useMemoObservable(
    () => getPreviewStateObservable$1(documentPreviewStore, schemaType, documentId, ""),
    [documentId, documentPreviewStore, schemaType]
  ), sanityDocument = React.useMemo(() => ({
    _id: documentId,
    _type: schemaType.name
  }), [documentId, schemaType.name]), previewValue = getPreviewValueWithFallback({
    draft,
    published,
    value: sanityDocument
  });
  return isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { animated: !0, marginLeft: 1, radius: 2, style: { width: "10ch", height: "1em" } }) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: previewValue.title || documentId.slice(0, 8) });
}
function SearchButtonValueDate({
  value
}) {
  const dateFormat = useDateTimeFormat({
    dateStyle: "medium",
    timeStyle: value.includeTime ? "short" : void 0
  }), date = value != null && value.date ? new Date(value.date) : null;
  return !date || !dateFns.isValid(date) ? null : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: dateFormat.format(date) });
}
function SearchButtonValueDateLast({
  value
}) {
  var _a2;
  const formatUnit = useUnitFormatter();
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: formatUnit(Math.floor((_a2 = value == null ? void 0 : value.unitValue) != null ? _a2 : 0), value.unit) });
}
function SearchButtonValueDateRange({
  value
}) {
  const dateFormat = useDateTimeFormat({
    dateStyle: "medium",
    timeStyle: value.includeTime ? "short" : void 0
  }), startDate = value != null && value.from ? new Date(value.from) : null, endDate = value != null && value.to ? new Date(value.to) : null;
  if (!endDate || !startDate || !dateFns.isValid(endDate) || !dateFns.isValid(startDate))
    return null;
  const from = dateFormat.format(startDate), to = dateFormat.format(endDate);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: `${from} \u2192 ${to}` });
}
function SearchButtonValueReference({ value }) {
  const schema2 = useSchema(), documentId = value._ref, schemaType = schema2.get(value._type);
  return schemaType ? /* @__PURE__ */ jsxRuntime.jsx(ReferencePreviewTitle, { documentId, schemaType }) : null;
}
function useSearchState() {
  const context = React.useContext(_singletons.SearchContext);
  if (context === void 0)
    throw new Error("useSearchState must be used within an SearchProvider");
  return context;
}
function SearchFilterNumberInput({ value, onChange }) {
  const [uncontrolledValue, setUncontrolledValue] = React.useState(value != null ? value : ""), {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (event) => {
      setUncontrolledValue(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      onChange(Number.isFinite(numValue) ? numValue : null);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      fontSize: fullscreen ? 2 : 1,
      onChange: handleChange,
      placeholder: t2("search.filter-number-value-placeholder"),
      radius: 2,
      step: "any",
      type: "number",
      value: uncontrolledValue
    }
  );
}
function SearchFilterNumberRangeInput({
  onChange,
  value
}) {
  var _a2, _b;
  const [to, setTo] = React.useState((_a2 = value == null ? void 0 : value.to) != null ? _a2 : ""), [from, setFrom] = React.useState((_b = value == null ? void 0 : value.from) != null ? _b : ""), {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleToChange = React.useCallback(
    (event) => {
      var _a22;
      setTo(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      onChange({
        to: Number.isFinite(numValue) ? numValue : null,
        from: (_a22 = value == null ? void 0 : value.from) != null ? _a22 : null
      });
    },
    [value == null ? void 0 : value.from, onChange]
  ), handleFromChange = React.useCallback(
    (event) => {
      var _a22;
      setFrom(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      onChange({
        to: (_a22 = value == null ? void 0 : value.to) != null ? _a22 : null,
        from: Number.isFinite(numValue) ? numValue : null
      });
    },
    [value == null ? void 0 : value.to, onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        fontSize: fullscreen ? 2 : 1,
        onChange: handleFromChange,
        placeholder: t2("search.filter-number-min-value-placeholder"),
        radius: 2,
        step: "any",
        type: "number",
        value: from
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        fontSize: fullscreen ? 2 : 1,
        onChange: handleToChange,
        placeholder: t2("search.filter-number-max-value-placeholder"),
        radius: 2,
        step: "any",
        type: "number",
        value: to
      }
    ) })
  ] });
}
function getSchemaField$1(schemaType, fieldPath) {
  const paths = fieldPath.split("."), firstPath = paths[0];
  if (firstPath && types.isObjectSchemaType(schemaType)) {
    const field = schemaType.fields.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = paths.slice(1).join(".");
      return nextPath ? getSchemaField$1(field.type, nextPath) : field;
    }
  }
}
const SearchResultItemPreviewBox = styledComponents.styled(ui.Box)`
  @supports (-webkit-overflow-scrolling: touch) {
    * [data-ui='Box'] {
      background-attachment: scroll;
    }
  }
`;
function SearchResultItemPreview({
  documentId,
  layout,
  presence,
  schemaType,
  showBadge = !0
}) {
  const documentPreviewStore = useDocumentPreviewStore(), { draft, published, isLoading } = reactRx.useMemoObservable(
    () => getPreviewStateObservable$1(documentPreviewStore, schemaType, documentId, ""),
    [documentId, documentPreviewStore, schemaType]
  ), sanityDocument = React.useMemo(() => ({
    _id: documentId,
    _type: schemaType.name
  }), [documentId, schemaType.name]), status = React.useMemo(() => isLoading ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(DocumentPreviewPresence, { presence }),
    showBadge && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { children: schemaType.title }),
    /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusIndicator, { draft, published })
  ] }), [draft, isLoading, presence, published, schemaType.title, showBadge]), tooltip = /* @__PURE__ */ jsxRuntime.jsx(DocumentStatus, { draft, published });
  return /* @__PURE__ */ jsxRuntime.jsx(SearchResultItemPreviewBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
    SanityDefaultPreview,
    {
      ...getPreviewValueWithFallback({
        draft,
        published,
        value: sanityDocument
      }),
      isPlaceholder: isLoading != null ? isLoading : !0,
      layout: layout || "default",
      icon: schemaType.icon,
      status,
      tooltip
    }
  ) });
}
function SearchResultItem({
  disableIntentLink,
  documentId,
  documentType,
  layout,
  onClick,
  onItemSelect,
  ...rest
}) {
  const type = useSchema().get(documentType), documentPresence = useDocumentPresence(documentId), params = React.useMemo(() => ({ id: documentId, type: type == null ? void 0 : type.name }), [documentId, type == null ? void 0 : type.name]), { onClick: onIntentClick, href } = router.useIntentLink({
    intent: "edit",
    params
  }), handleClick = React.useCallback(
    (e) => {
      onItemSelect == null || onItemSelect({ _id: documentId, _type: documentType }), disableIntentLink || onIntentClick(e), onClick == null || onClick();
    },
    [onItemSelect, documentId, documentType, disableIntentLink, onClick, onIntentClick]
  );
  return type ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    PreviewCard,
    {
      as: "a",
      "data-as": "a",
      flex: 1,
      href: disableIntentLink ? void 0 : href,
      onClick: handleClick,
      radius: 2,
      tabIndex: -1,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        SearchResultItemPreview,
        {
          documentId,
          layout,
          presence: documentPresence,
          schemaType: type
        }
      )
    }
  ) }) : null;
}
const IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), DEBUG_FRAGMENT = "_debug_search_score", DEBUG_MODE = !1, SEARCH_LIMIT = 1e3, GLOBAL_SEARCH_KEY = "k", GLOBAL_SEARCH_KEY_MODIFIER = IS_MAC ? "Cmd" : "Ctrl", POPOVER_INPUT_PADDING = ui.studioTheme.space[4], POPOVER_MAX_HEIGHT = 735, POPOVER_MAX_WIDTH = 800, POPOVER_VERTICAL_MARGIN = 5, POPOVER_RADIUS = 3;
function hasSearchableTerms({
  allowEmptyQueries,
  terms
}) {
  const hasQuery = allowEmptyQueries ? !0 : terms.query.length > 0, hasFilter = !!terms.filter, hasSelectedTypes = terms.types.length > 0;
  return hasQuery || hasFilter || hasSelectedTypes;
}
function getSelectableOmnisearchTypes(schema2, typeFilter) {
  return getSearchableOmnisearchTypes(schema2).filter((type) => inTypeFilter(type, typeFilter)).sort(sortTypes);
}
function getSearchableOmnisearchTypes(schema2) {
  return getSearchableTypes(schema2).filter(
    (type) => type.__experimental_omnisearch_visibility !== !1
  );
}
function sortTypes(a, b) {
  var _a2, _b;
  return ((_a2 = a.title) != null ? _a2 : a.name).localeCompare((_b = b.title) != null ? _b : b.name);
}
function inTypeFilter(type, typeFilter) {
  var _a2;
  return !typeFilter || ((_a2 = type.title) != null ? _a2 : type.name).toLowerCase().includes(typeFilter == null ? void 0 : typeFilter.toLowerCase());
}
const DEFAULT_DEBOUNCE_TIME = 300, INITIAL_SEARCH_STATE = {
  error: null,
  hits: [],
  loading: !1,
  terms: {
    query: "",
    types: []
  }
};
function nonNullable(v) {
  return v !== null;
}
function sanitizeRequest(request) {
  var _a2;
  return {
    ...request,
    terms: {
      ...request.terms,
      filter: (_a2 = request.terms.filter) == null ? void 0 : _a2.trim(),
      query: request.terms.query.trim()
    }
  };
}
function useSearch({
  allowEmptyQueries,
  initialState: initialState2,
  onComplete,
  onError,
  onStart,
  schema: schema2
}) {
  const [searchState, setSearchState] = React.useState(initialState2), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), maxFieldDepth = useSearchMaxFieldDepth(), { enableLegacySearch = !1 } = useWorkspace().search, search2 = React.useMemo(
    () => createSearch(getSearchableOmnisearchTypes(schema2), client2, {
      tag: "search.global",
      unique: !0,
      enableLegacySearch,
      maxDepth: maxFieldDepth
    }),
    [client2, maxFieldDepth, schema2, enableLegacySearch]
  ), handleQueryChange = reactRx.useObservableCallback(
    (inputValue$) => inputValue$.pipe(
      // Ignore null values
      operators.filter(nonNullable),
      // Sanitize request (trim query and filter)
      operators.map(sanitizeRequest),
      // Only emit when values have changed
      operators.distinctUntilChanged(isEqual__default.default),
      // Debounce requests
      operators.debounce((request) => rxjs.timer((request == null ? void 0 : request.debounceTime) || DEFAULT_DEBOUNCE_TIME)),
      // Trigger `onStart` callback
      operators.tap(onStart),
      operators.switchMap((request) => rxjs.concat(
        // Emit loading start
        rxjs.of({
          ...INITIAL_SEARCH_STATE,
          loading: !0,
          options: request.options,
          terms: request.terms
        }),
        // Conditionally trigger search ONLY if we have valid searchable terms.
        // Typically, search terms are valid if either query, filter or selected types is non-empty.
        // There are exceptions (e.g. searching within <AutoComplete> components) where empty queries are permitted,
        // which is what `allowEmptyQueries` is used for.
        rxjs.iif(
          () => hasSearchableTerms({ allowEmptyQueries, terms: request.terms }),
          // If we have a valid search, run async fetch, map results and trigger `onComplete` / `onError` callbacks
          search2(request.terms, request.options).pipe(
            operators.tap(({ hits, nextCursor }) => onComplete == null ? void 0 : onComplete({ hits, nextCursor })),
            operators.catchError((error) => (onError == null || onError(error), rxjs.of({
              ...INITIAL_SEARCH_STATE,
              error,
              loading: !1,
              options: request.options,
              terms: request.terms
            })))
          ),
          // If there is no valid search, emit an empty observable and trigger `onComplete` event
          rxjs.of(rxjs.EMPTY).pipe(operators.tap(() => onComplete == null ? void 0 : onComplete({ hits: [], nextCursor: void 0 })))
        ),
        // Emit loading completed
        rxjs.of({ loading: !1 })
      )),
      operators.scan((prevState, nextState) => ({ ...prevState, ...nextState }), INITIAL_SEARCH_STATE),
      // Update local search state
      operators.tap(setSearchState)
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps -- @todo: add onComplete, onError and onStart to the deps list when it's verified that it's safe to do so
    [allowEmptyQueries, search2]
  );
  return { handleSearch: React.useCallback(
    (searchRequest) => handleQueryChange(searchRequest),
    [handleQueryChange]
  ), searchState };
}
const DEFAULT_AVAILABLE_CHARS = 40;
function getDocumentTypesTruncated({
  availableCharacters = DEFAULT_AVAILABLE_CHARS,
  types: types2
}) {
  if (types2.length === 0)
    return { remainingCount: 0, types: [] };
  const visibleTypes = types2.reduce(
    /* @__PURE__ */ function() {
      let remaining = availableCharacters;
      return function(acc, val, index) {
        const title = typeTitle(val);
        return remaining -= title.length, (index === 0 || availableCharacters > title.length && remaining > title.length) && acc.push(val), acc;
      };
    }(),
    []
  );
  return {
    remainingCount: types2.length - visibleTypes.length,
    types: visibleTypes.map(typeTitle)
  };
}
function documentTypesTruncated({
  t: t2,
  availableCharacters,
  types: types2
}) {
  if (types2.length === 0)
    return t2("search.document-type-list-all-types");
  const { remainingCount, types: visibleTypes } = getDocumentTypesTruncated({
    availableCharacters,
    types: types2
  }), key = remainingCount > 0 ? "search.document-type-list-truncated" : "search.document-type-list";
  return t2(key, {
    count: remainingCount,
    types: visibleTypes,
    formatParams: { types: { style: "short", type: "unit" } }
  });
}
function typeTitle(schemaType) {
  var _a2;
  return (_a2 = schemaType.title) != null ? _a2 : schemaType.name;
}
const NO_FILTER = () => !0, StyledText$3 = styledComponents.styled(ui.Text)`
  word-break: break-word;
`, ReferenceAutocomplete = React.forwardRef(function({ onSelect, types: types2 = [], value }, ref) {
  const autocompletePopoverReferenceElementRef = React.useRef(null), schema2 = useSchema(), {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), autocompleteId = React.useId(), [hits, setHits] = React.useState([]), { handleSearch, searchState } = useSearch({
    allowEmptyQueries: !0,
    initialState: {
      hits: [],
      loading: !1,
      error: null,
      terms: { query: "", types: types2 }
    },
    onComplete: (result) => {
      setHits(result.hits.map(({ hit }) => ({ value: hit._id, hit })));
    },
    schema: schema2
  }), handleAutocompleteOpenButtonClick = React.useCallback(() => {
    handleSearch({
      debounceTime: 0,
      options: { limit: 100 },
      terms: { query: "", types: types2 }
    });
  }, [handleSearch, types2]), handleQueryChange = React.useCallback(
    (query) => {
      handleSearch(query ? {
        options: { limit: 100 },
        terms: { query: query || "", types: types2 }
      } : {
        debounceTime: 0,
        options: { limit: 0 },
        terms: { query: "", types: types2 }
      });
    },
    [handleSearch, types2]
  ), handleSelect = React.useCallback(
    (val) => {
      var _a2;
      const hit = (_a2 = hits.find((h) => h.value === val)) == null ? void 0 : _a2.hit;
      hit && (onSelect == null || onSelect({
        _ref: getPublishedId(hit._id),
        _type: hit._type
      }));
    },
    [hits, onSelect]
  ), placeholderText = React.useMemo(() => {
    if (types2.length === 0)
      return t2("search.action.search-all-types");
    const { remainingCount, types: visibleTypes } = getDocumentTypesTruncated({ types: types2 }), key = remainingCount > 0 ? "search.action.search-specific-types-truncated" : "search.action.search-specific-types";
    return t2(key, {
      count: remainingCount,
      types: visibleTypes,
      formatParams: { types: { style: "short", type: "unit" } }
    });
  }, [types2, t2]), renderOption = React.useCallback((option) => /* @__PURE__ */ jsxRuntime.jsx(
    SearchResultItem,
    {
      disableIntentLink: !0,
      documentId: option.value,
      documentType: option.hit._type,
      layout: "compact"
    }
  ), []), renderPopover = React.useCallback(
    (props2, contentRef) => {
      const { content: content2, hidden, onMouseEnter, onMouseLeave } = props2, hasResults = hits && hits.length > 0;
      return /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Popover,
        {
          constrainSize: !0,
          content: /* @__PURE__ */ jsxRuntime.jsx("div", { ref: contentRef, children: hasResults ? content2 : searchState.terms.query && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(StyledText$3, { align: "center", muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
            Translate,
            {
              t: t2,
              i18nKey: "new-document.no-results",
              values: { searchQuery: searchState.terms.query }
            }
          ) }) }) }) }),
          fallbackPlacements: ["bottom", "bottom-end"],
          matchReferenceWidth: !0,
          onMouseEnter,
          onMouseLeave,
          open: !searchState.loading && !hidden,
          overflow: "auto",
          placement: "bottom-start",
          radius: POPOVER_RADIUS,
          referenceElement: autocompletePopoverReferenceElementRef.current
        }
      );
    },
    [hits, searchState.loading, searchState.terms.query, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { ref: autocompletePopoverReferenceElementRef, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Autocomplete,
    {
      "aria-label": placeholderText,
      filterOption: NO_FILTER,
      fontSize: fullscreen ? 2 : 1,
      id: autocompleteId,
      loading: searchState.loading,
      openButton: { onClick: handleAutocompleteOpenButtonClick },
      options: hits,
      onQueryChange: handleQueryChange,
      onSelect: handleSelect,
      placeholder: placeholderText,
      radius: 2,
      ref,
      renderOption,
      renderPopover,
      value: value == null ? void 0 : value._ref
    }
  ) });
});
function SearchFilterReferenceInput({
  fieldDefinition,
  onChange,
  value
}) {
  const {
    onClose,
    state: { documentTypesNarrowed }
  } = useSearchState(), schema2 = useSchema(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (referenceValue) => onChange(referenceValue),
    [onChange]
  ), searchableTypes = React.useMemo(() => fieldDefinition ? fieldDefinition.documentTypes.filter((d) => documentTypesNarrowed.includes(d)).flatMap((type) => {
    const schemaType = schema2.get(type);
    if (schemaType) {
      const field = getSchemaField$1(schemaType, fieldDefinition.fieldPath);
      if (types.isArraySchemaType(field == null ? void 0 : field.type))
        return field == null ? void 0 : field.type.of.filter(types.isReferenceSchemaType).flatMap((i) => i.to);
      if (types.isReferenceSchemaType(field == null ? void 0 : field.type))
        return field == null ? void 0 : field.type.to;
    }
    return [];
  }).reduce((acc, val) => (acc.findIndex((v) => v.name === (val == null ? void 0 : val.name)) < 0 && acc.push(val), acc), []) : [], [documentTypesNarrowed, fieldDefinition, schema2]), handleClear = React.useCallback(() => handleChange(null), [handleChange]), handleClick = React.useCallback(() => {
    onClose == null || onClose();
  }, [onClose]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { width: "min(calc(100vw - 40px), 420px)" }, children: value != null && value._ref && value != null && value._type ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, radius: 1, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      SearchResultItem,
      {
        documentId: value._ref,
        documentType: value._type,
        layout: "compact",
        onClick: handleClick
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        mode: "ghost",
        onClick: handleClear,
        text: t2("search.filter-reference-clear"),
        tone: "critical"
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(ReferenceAutocomplete, { onSelect: handleChange, types: searchableTypes, value }) });
}
function CustomMenuItem$2({
  onClick,
  selected,
  title,
  value
}) {
  const handleClick = React.useCallback(() => onClick(value), [onClick, value]);
  let menuItemText = `${title}`;
  return typeof value < "u" && title !== value && (menuItemText += ` (${value})`), /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.MenuItem, { onClick: handleClick, pressed: selected, tone: "default", text: menuItemText });
}
function SearchFilterStringListInput({
  fieldDefinition,
  onChange,
  value
}) {
  const menuButtonId = React.useId(), {
    state: { documentTypesNarrowed }
  } = useSearchState(), { t: t2 } = useTranslation(), schema2 = useSchema(), items = React.useMemo(() => fieldDefinition ? fieldDefinition.documentTypes.filter((d) => documentTypesNarrowed.includes(d)).map((type) => {
    const schemaType = schema2.get(type);
    if (schemaType) {
      const field = getSchemaField$1(schemaType, fieldDefinition.fieldPath);
      return field == null ? void 0 : field.type.options;
    }
    return null;
  }).filter(isNonNullable$3).map((o) => o.list).flatMap((list) => list == null ? void 0 : list.map((l) => toSelectItem(l))).filter(isNonNullable$3).reduce((acc, val) => {
    const prevIndex = acc.findIndex((v) => v.value === (val == null ? void 0 : val.value));
    if (prevIndex > -1) {
      const prevValue = acc[prevIndex];
      acc[prevIndex] = {
        ...acc[prevIndex],
        title: uniq__default.default([...prevValue.title, val.title]).sort()
      };
    } else
      acc.push({
        ...val,
        title: [val.title]
      });
    return acc;
  }, []) : [], [documentTypesNarrowed, fieldDefinition, schema2]), handleClick = React.useCallback(
    (v) => {
      onChange(v);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          mode: "ghost",
          iconRight: icons.ChevronDownIcon,
          text: value ? String(value) : t2("search.filter-string-value-select-predefined-value")
        }
      ),
      id: menuButtonId || "",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: items.map((item, index) => /* @__PURE__ */ jsxRuntime.jsx(
        CustomMenuItem$2,
        {
          onClick: handleClick,
          selected: item.value === value,
          title: item.title.join(", "),
          value: item.value || ""
        },
        index
      )) }),
      popover: {
        constrainSize: !0,
        placement: "bottom-start",
        portal: !1,
        radius: 2
      }
    }
  );
}
function toSelectItem(option) {
  return types.isTitledListValue(option) ? option : { title: capitalize__default.default(`${option}`), value: option };
}
const GteIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M7.04 19V17.512H17.36V19H7.04ZM7.04 15.328V13.624L12.08 11.872L15.32 10.816V10.72L12.08 9.664L7.04 7.912V6.208L17.36 9.88V11.656L7.04 15.328Z",
    fill: "currentColor"
  }
) }), GtIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M7.568 18.848V16.952L14.792 12.08V11.984L7.568 7.112V5.216L16.52 11.288V12.776L7.568 18.848Z",
    fill: "currentColor"
  }
) }), LteIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M7.04 19V17.512H17.36V19H7.04ZM17.36 15.328L7.04 11.656V9.88L17.36 6.208V7.912L12.32 9.664L9.08 10.72V10.816L12.32 11.872L17.36 13.624V15.328Z",
    fill: "currentColor"
  }
) }), LtIcon = () => /* @__PURE__ */ jsxRuntime.jsx("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntime.jsx(
  "path",
  {
    d: "M16.952 19.632L8 13.56V12.072L16.952 6V7.896L9.728 12.768V12.864L16.952 17.736V19.632Z",
    fill: "currentColor"
  }
) });
function defineSearchOperator(definition) {
  return definition;
}
function toJSON(val) {
  return JSON.stringify(val);
}
const arrayOperators = {
  arrayCountEqual: {
    nameKey: "search.operator.array-count-equal.name",
    descriptionKey: "search.operator.array-count-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountEqual"
  },
  arrayCountGt: {
    nameKey: "search.operator.array-count-gt.name",
    descriptionKey: "search.operator.array-count-gt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) > ${toJSON(value)}` : null,
    icon: GtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountGt"
  },
  arrayCountGte: {
    nameKey: "search.operator.array-count-gte.name",
    descriptionKey: "search.operator.array-count-gte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) >= ${toJSON(value)}` : null,
    icon: GteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountGte"
  },
  arrayCountLt: {
    nameKey: "search.operator.array-count-lt.name",
    descriptionKey: "search.operator.array-count-lt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) < ${toJSON(value)}` : null,
    icon: LtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountLt"
  },
  arrayCountLte: {
    nameKey: "search.operator.array-count-lte.name",
    descriptionKey: "search.operator.array-count-lte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) <= ${toJSON(value)}` : null,
    icon: LteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountLte"
  },
  arrayCountNotEqual: {
    nameKey: "search.operator.array-count-not-equal.name",
    descriptionKey: "search.operator.array-count-not-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `count(${fieldPath}) != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "arrayCountNotEqual"
  },
  arrayCountRange: {
    nameKey: "search.operator.array-count-range.name",
    descriptionKey: "search.operator.array-count-range.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value == null ? void 0 : value.to) && Number.isFinite(value == null ? void 0 : value.from) && fieldPath ? `count(${fieldPath}) > ${toJSON(value == null ? void 0 : value.from)} && count(${fieldPath}) < ${toJSON(
      value == null ? void 0 : value.to
    )}` : "",
    initialValue: null,
    inputComponent: SearchFilterNumberRangeInput,
    type: "arrayCountRange"
  },
  arrayListIncludes: {
    nameKey: "search.operator.array-list-includes.name",
    descriptionKey: "search.operator.array-list-includes.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${toJSON(value)} in ${fieldPath}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "arrayListIncludes"
  },
  arrayListNotIncludes: {
    nameKey: "search.operator.array-list-not-includes.name",
    descriptionKey: "search.operator.array-list-not-includes.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(${toJSON(value)} in ${fieldPath})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "arrayListNotIncludes"
  },
  arrayReferenceIncludes: {
    nameKey: "search.operator.array-reference-includes.name",
    descriptionKey: "search.operator.array-reference-includes.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${toJSON(value._ref)} in ${fieldPath}[]._ref` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "arrayReferenceIncludes"
  },
  arrayReferenceNotIncludes: {
    nameKey: "search.operator.array-reference-not-includes.name",
    descriptionKey: "search.operator.array-reference-not-includes.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `!(${toJSON(value._ref)} in ${fieldPath}[]._ref)` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "arrayReferenceNotIncludes"
  }
};
function SourceProvider({ children, ...props2 }) {
  const parentSource = React.useContext(_singletons.SourceContext), { unstable_sources: sources } = useWorkspace();
  if ("source" in props2) {
    const { source } = props2;
    return /* @__PURE__ */ jsxRuntime.jsx(_singletons.SourceContext.Provider, { value: source, children });
  }
  if ("name" in props2) {
    const { name } = props2, source = sources.find((s) => s.name === name);
    if (!source)
      throw new Error(`Could not find source with name \`${name}\` in current workspace`);
    return parentSource === source ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }) : /* @__PURE__ */ jsxRuntime.jsx(_singletons.SourceContext.Provider, { value: source, children });
  }
  throw new Error(
    "Invalid props passed into SourceProvider. A `name` or a `source` object is required."
  );
}
function useSource() {
  const source = React.useContext(_singletons.SourceContext);
  if (!source) throw new Error("Could not find `source` context");
  return source;
}
function AssetSourceError(props2) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...props2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "caution", children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "caution", weight: "medium", children: t2("search.error.no-valid-asset-source-title") }),
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "caution", children: t2("search.error.no-valid-asset-source-only-default-description") }),
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "caution", children: t2("search.error.no-valid-asset-source-check-config-description") })
    ] })
  ] }) });
}
function FileReferencePreview({ reference }) {
  const documentPreviewStore = useDocumentPreviewStore(), observeAsset = React.useCallback(
    (id2) => observeFileAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    WithReferencedAsset,
    {
      observeAsset,
      reference,
      waitPlaceholder: /* @__PURE__ */ jsxRuntime.jsx(FileSkeleton, {}),
      children: (asset) => /* @__PURE__ */ jsxRuntime.jsx(FilePreview, { asset })
    }
  );
}
function FilePreview({ asset }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "space-between", wrap: "nowrap", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 1, shadow: 1, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", weight: "medium", children: (asset == null ? void 0 : asset.originalFilename) || asset._id }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: formatBytes(asset.size) })
    ] })
  ] }) });
}
function FileSkeleton() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 1, shadow: 1, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.BinaryDocumentIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, marginLeft: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "100%" }, radius: 1 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "100%" }, radius: 1 })
    ] })
  ] }) });
}
const Container = styledComponents.styled(ui.Card)`
  position: relative;
  padding-bottom: 100%;
`, Image$5 = styledComponents.styled.img`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
`;
function ImageReferencePreview({ reference }) {
  const documentPreviewStore = useDocumentPreviewStore(), observeAsset = React.useCallback(
    (id2) => observeImageAsset(documentPreviewStore, id2),
    [documentPreviewStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(WithReferencedAsset, { observeAsset, reference, children: (asset) => /* @__PURE__ */ jsxRuntime.jsx(ImagePreview, { asset }) });
}
function ImagePreview({ asset }) {
  const [loaded, setLoaded] = React.useState(!1), imageUrl = `${asset.url}?h=800&fit=max`, handleLoad = React.useCallback(() => setLoaded(!0), []);
  return /* @__PURE__ */ jsxRuntime.jsxs(Container, { __unstable_checkered: !0, border: !0, children: [
    !loaded && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { fill: !0, showText: !0 }),
    /* @__PURE__ */ jsxRuntime.jsx(Image$5, { onLoad: handleLoad, src: imageUrl })
  ] });
}
function AssetPreview({ reference }) {
  return reference ? reference._type.startsWith("sanity.fileAsset") ? /* @__PURE__ */ jsxRuntime.jsx(FileReferencePreview, { reference }) : reference._type.startsWith("sanity.imageAsset") ? /* @__PURE__ */ jsxRuntime.jsx(ImageReferencePreview, { reference }) : null : null;
}
const ASSET_TYPE = {
  file: "sanity.fileAsset",
  image: "sanity.imageAsset"
}, ContainerBox = styledComponents.styled(ui.Box)`
  width: min(calc(100vw - 40px), 320px);
`;
function SearchFilterAssetInput(type) {
  return function({
    onChange,
    value
  }) {
    const [selectedAssetSource, setSelectedAssetSource] = React.useState(null), [selectedAssetFromSource, setSelectedAssetFromSource] = React.useState(
      null
    );
    useSearchState();
    const { file, image } = useSource().form, { t: t2 } = useTranslation(), assetSources = React.useMemo(() => {
      switch (type) {
        case "file":
          return file.assetSources.filter((a) => a.name === FileSource.name);
        case "image":
          return image.assetSources.filter((a) => a.name === ImageSource.name);
        default:
          throw Error("Unknown asset source found");
      }
    }, [file.assetSources, image.assetSources]), menuButtonId = React.useId(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), handleClear = React.useCallback(() => {
      setSelectedAssetFromSource(null), onChange(null);
    }, [onChange]), handleCloseAssetSource = React.useCallback(() => {
      setSelectedAssetSource(null);
    }, []), handleSelectAssetFromSource2 = React.useCallback(
      (assetFromSource) => {
        const firstAsset = assetFromSource[0];
        setSelectedAssetFromSource(firstAsset), handleCloseAssetSource();
      },
      [handleCloseAssetSource]
    ), handleSelectAssetSource = React.useCallback(
      (source) => setSelectedAssetSource(source),
      []
    );
    React.useEffect(() => {
      (selectedAssetFromSource == null ? void 0 : selectedAssetFromSource.kind) === "assetDocumentId" && typeof (selectedAssetFromSource == null ? void 0 : selectedAssetFromSource.value) == "string" && type && onChange({
        _ref: selectedAssetFromSource.value,
        _type: ASSET_TYPE[type]
      });
    }, [client2, onChange, selectedAssetFromSource]);
    const AssetSourceComponent = selectedAssetSource == null ? void 0 : selectedAssetSource.component, buttonText = t2(value ? "search.filter-asset-change" : "search.filter-asset-select", {
      context: type
    }), accept = get__default.default(type, "options.accept", type === "image" ? "image/*" : "");
    return /* @__PURE__ */ jsxRuntime.jsx(ContainerBox, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
      selectedAssetSource && AssetSourceComponent && /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { children: /* @__PURE__ */ jsxRuntime.jsx(
        AssetSourceComponent,
        {
          assetType: type,
          dialogHeaderTitle: t2("search.action.select-asset", { context: type }),
          onClose: handleCloseAssetSource,
          onSelect: handleSelectAssetFromSource2,
          selectedAssets: [],
          selectionType: "single",
          accept
        }
      ) }),
      value && /* @__PURE__ */ jsxRuntime.jsx(AssetPreview, { reference: value }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, children: [
        assetSources.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(AssetSourceError, { padding: 2 }),
        assetSources.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: assetSources.length > 1 ? /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuButton,
          {
            button: /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.Button,
              {
                icon: value ? icons.UndoIcon : icons.SearchIcon,
                iconRight: icons.ChevronDownIcon,
                mode: "ghost",
                width: value ? "fill" : void 0,
                text: buttonText
              }
            ),
            id: menuButtonId,
            menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: assetSources.map((source) => /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                icon: source.icon || icons.ImageIcon,
                onClick: () => handleSelectAssetSource(source),
                text: (source.i18nKey ? t2(source.i18nKey) : source.title) || startCase__default.default(source.name)
              },
              source.name
            )) }),
            popover: {
              constrainSize: !0,
              portal: !1,
              radius: 2
            }
          }
        ) : /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            icon: value ? icons.UndoIcon : icons.SearchIcon,
            mode: "ghost",
            onClick: () => handleSelectAssetSource(assetSources[0]),
            width: value ? "fill" : void 0,
            text: buttonText
          }
        ) }),
        value && /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "ghost",
            onClick: handleClear,
            width: "fill",
            text: t2("search.filter-asset-clear"),
            tone: "critical"
          }
        )
      ] })
    ] }) });
  };
}
const assetOperators = {
  assetFileEqual: {
    nameKey: "search.operator.asset-file-equal.name",
    descriptionKey: "search.operator.asset-file-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref == ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("file"),
    label: "is",
    type: "assetFileEqual"
  },
  assetFileNotEqual: {
    nameKey: "search.operator.asset-file-not-equal.name",
    descriptionKey: "search.operator.asset-file-not-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref != ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("file"),
    label: "is not",
    type: "assetFileNotEqual"
  },
  assetImageEqual: {
    nameKey: "search.operator.asset-image-equal.name",
    descriptionKey: "search.operator.asset-image-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref == ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("image"),
    label: "is",
    type: "assetImageEqual"
  },
  assetImageNotEqual: {
    nameKey: "search.operator.asset-image-not-equal.name",
    descriptionKey: "search.operator.asset-image-not-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}.asset._ref != ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("image"),
    label: "is not",
    type: "assetImageNotEqual"
  }
};
function SearchFilterBooleanInput({ onChange, value }) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (event) => {
      onChange(event.currentTarget.value === "true");
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Select,
    {
      fontSize: fullscreen ? 2 : 1,
      onChange: handleChange,
      radius: 2,
      value: String(value != null ? value : !0),
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("option", { value: "true", children: t2("search.filter-boolean-true") }),
        /* @__PURE__ */ jsxRuntime.jsx("option", { value: "false", children: t2("search.filter-boolean-false") })
      ]
    }
  );
}
const booleanOperators = {
  booleanEqual: {
    nameKey: "search.operator.boolean-equal.name",
    descriptionKey: "search.operator.boolean-equal.description",
    groqFilter: ({ fieldPath, value }) => typeof value < "u" && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: !0,
    inputComponent: SearchFilterBooleanInput,
    type: "booleanEqual"
  }
}, TimeLabelText = styledComponents.styled(ui.Text)`
  cursor: default;
`;
function DateIncludeTimeFooter({ onChange, value }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, justify: "flex-end", marginTop: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(TimeLabelText, { muted: !0, onClick: onChange, size: 1, weight: "medium", children: t2("calendar.action.include-time-label") }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Switch, { checked: value, label: t2("calendar.action.include-time-label"), onChange })
  ] });
}
function useCalendar() {
  const context = React.useContext(_singletons.CalendarContext);
  if (context === void 0)
    throw new Error("useCalendar must be used within an CalendarContext.Provider");
  return context;
}
function CalendarHeader(props2) {
  const { t: t2 } = useTranslation(), monthFormatter = useDateTimeFormat({ month: "long", year: "numeric" }), { focusedDate } = useCalendar(), { moveFocusedDate, onNowClick } = props2, handlePrevMonthClick = React.useCallback(() => moveFocusedDate(-1), [moveFocusedDate]), handleNextMonthClick = React.useCallback(() => moveFocusedDate(1), [moveFocusedDate]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, justify: "space-between", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { paddingLeft: 2, space: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: upperFirst__default.default(monthFormatter.format(focusedDate)) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          "aria-label": t2("calendar.action.go-to-today-aria-label"),
          mode: "bleed",
          onClick: onNowClick,
          text: t2("calendar.action.go-to-today")
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          icon: icons.ChevronLeftIcon,
          mode: "bleed",
          onClick: handlePrevMonthClick,
          tooltipProps: { content: t2("calendar.action.go-to-previous-month") }
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          icon: icons.ChevronRightIcon,
          mode: "bleed",
          onClick: handleNextMonthClick,
          tooltipProps: { content: t2("calendar.action.go-to-next-month") }
        }
      )
    ] })
  ] });
}
const CircleSvg = styledComponents.styled.svg(({ theme: theme2 }) => styledComponents.css`
    bottom: 0;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;

    circle {
      stroke: ${theme2.sanity.color.card.enabled.border};
      stroke-width: 3;
      fill: none;
    }
  `), CustomCard = styledComponents.styled(ui.Card)`
  position: relative;

  &[data-focused='true'] {
    z-index: 1;
  }

  &[data-start-date='true'] {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }

  &[data-end-date='true'] {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }

  &[data-within-range='true'] {
    border-radius: 0;
  }
`;
function CalendarDay$2({ date, onSelect }) {
  const handleClick = React.useCallback(() => {
    onSelect(date);
  }, [date, onSelect]), { date: selectedDate, endDate: selectedEndDate, focusedDate, selectRange } = useCalendar(), isSelected = selectedDate && dateFns.isSameDay(date, selectedDate), isStartDate = selectRange && selectedDate && dateFns.isSameDay(date, selectedDate), isEndDate = selectRange && selectedEndDate && dateFns.isSameDay(date, selectedEndDate), isCurrentMonth = dateFns.isSameMonth(date, focusedDate), isFocused = focusedDate && dateFns.isSameDay(date, focusedDate), isToday = dateFns.isSameDay(date, /* @__PURE__ */ new Date()), isWithinRange = selectedDate && selectedEndDate && !isStartDate && !isEndDate && dateFns.isAfter(date, selectedDate) && dateFns.isBefore(date, selectedEndDate);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    CustomCard,
    {
      __unstable_focusRing: !0,
      "aria-label": date.toDateString(),
      "aria-pressed": isSelected,
      "data-end-date": isEndDate ? !0 : void 0,
      "data-focused": isFocused ? "true" : "",
      "data-ui": "CalendarDay",
      "aria-selected": isSelected,
      "data-start-date": isStartDate ? !0 : void 0,
      "data-within-range": isWithinRange ? !0 : void 0,
      forwardedAs: "button",
      onClick: handleClick,
      paddingX: 3,
      paddingY: 2,
      radius: 2,
      role: "button",
      selected: isSelected || isStartDate || isEndDate,
      tabIndex: -1,
      tone: isWithinRange ? "primary" : "default",
      children: [
        isToday && /* @__PURE__ */ jsxRuntime.jsx(
          CircleSvg,
          {
            height: "100%",
            preserveAspectRatio: "xMidYMid meet",
            vectorEffect: "non-scaling-stroke",
            viewBox: "0 0 100 100",
            width: "100%",
            children: /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: "50", cy: "50", r: "40%" })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Text,
          {
            align: "center",
            muted: !isSelected && !isCurrentMonth,
            size: 1,
            weight: isCurrentMonth ? "medium" : "regular",
            children: date.getDate()
          }
        )
      ]
    }
  );
}
const SHORT_WEEK_DAY_KEYS = [
  "calendar.weekday-names.short.monday",
  "calendar.weekday-names.short.tuesday",
  "calendar.weekday-names.short.wednesday",
  "calendar.weekday-names.short.thursday",
  "calendar.weekday-names.short.friday",
  "calendar.weekday-names.short.saturday",
  "calendar.weekday-names.short.sunday"
];
range__default.default(0, 24);
const ARROW_KEYS$2 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], TAIL_WEEKDAYS$2 = [1, 2, 3, 4, 5, 6], getWeekStartsOfMonth$2 = (date, weekStartsOn) => {
  const firstDay = dateFns.startOfMonth(date);
  return dateFns.eachWeekOfInterval(
    {
      start: firstDay,
      end: dateFns.lastDayOfMonth(firstDay)
    },
    {
      weekStartsOn: weekStartsOn === 7 ? 0 : weekStartsOn
    }
  );
}, getWeekDaysFromWeekStarts$2 = (weekStarts) => weekStarts.map((weekStart) => [
  weekStart,
  ...TAIL_WEEKDAYS$2.map((d) => dateFns.addDays(weekStart, d))
]), useWeeksOfMonth = (date) => {
  const { weekInfo } = useCurrentLocale();
  return getWeekDaysFromWeekStarts$2(getWeekStartsOfMonth$2(date, weekInfo.firstDay)).map(
    (days) => ({
      number: dateFns.getWeek(days[0]),
      days
    })
  );
}, WEEK_DAY_NAME_KEYS = {
  // Monday is start of the week
  1: SHORT_WEEK_DAY_KEYS,
  // Sunday is start of the week
  7: [SHORT_WEEK_DAY_KEYS[6], ...SHORT_WEEK_DAY_KEYS.slice(0, 6)]
}, CustomGrid = styledComponents.styled(ui.Grid)`
  grid-template-columns: repeat(7, minmax(44px, auto));
`;
function CalendarMonth$2({ hidden, onSelect }) {
  const { focusedDate, firstWeekDay } = useCalendar(), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "aria-hidden": hidden || !1, "data-ui": "CalendarMonth", children: /* @__PURE__ */ jsxRuntime.jsxs(CustomGrid, { gapY: 1, children: [
    WEEK_DAY_NAME_KEYS[firstWeekDay].map((weekdayDay) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 3, paddingTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, weight: "medium", children: t2(weekdayDay) }) }, weekdayDay)),
    useWeeksOfMonth(focusedDate).map(
      (week, weekIdx) => week.days.map((weekDayDate, dayIdx) => /* @__PURE__ */ jsxRuntime.jsx(
        CalendarDay$2,
        {
          date: weekDayDate,
          onSelect
        },
        `${weekIdx}-${dayIdx}`
      ))
    )
  ] }) });
}
const PRESERVE_FOCUS_ELEMENT$2 = /* @__PURE__ */ jsxRuntime.jsx(
  "span",
  {
    "data-preserve-focus": !0,
    style: { overflow: "hidden", position: "absolute", outline: "none" },
    tabIndex: -1
  }
);
function Calendar$2(props2) {
  const { date, endDate, onSelect, selectRange, selectTime } = props2, [calendarElement, setCalendarElement] = React.useState(null), [selectEndValue, setSelectEndValue] = React.useState(!1), [focusedDate, setFocusedDate] = React.useState(date || /* @__PURE__ */ new Date()), previousDate = React.useRef(date || null), previousEndDate = React.useRef(endDate || null), {
    weekInfo: { firstDay: firstWeekDay }
  } = useCurrentLocale(), focusCurrentWeekDay = React.useCallback(() => {
    var _a2;
    (_a2 = calendarElement == null ? void 0 : calendarElement.querySelector('[data-focused="true"]')) == null || _a2.focus();
  }, [calendarElement]), handleDateChange = React.useCallback(
    (d) => {
      const selectedDate = dateFns.set(d, {
        hours: d.getHours(),
        minutes: d.getMinutes(),
        seconds: 0,
        milliseconds: 0
      }), dateIsBeforeStartDate = date && dateFns.isBefore(selectedDate, date), dateIsAfterEndDate = endDate && dateFns.isAfter(selectedDate, endDate);
      if (selectRange) {
        if (dateIsBeforeStartDate || dateIsAfterEndDate) {
          onSelect({ date: selectedDate, endDate: null });
          return;
        }
        onSelect(selectEndValue ? { date: date || null, endDate: selectedDate } : { date: selectedDate, endDate: date ? null : endDate || null });
      } else
        onSelect({ date: selectedDate });
    },
    [date, endDate, onSelect, selectEndValue, selectRange]
  ), handleNowClick = React.useCallback(() => {
    const now = /* @__PURE__ */ new Date();
    selectRange ? setFocusedDate(now) : onSelect({ date: now });
  }, [onSelect, selectRange, setFocusedDate]), handleKeyDown = React.useCallback(
    (event) => {
      var _a2;
      if (ARROW_KEYS$2.includes(event.key)) {
        if (event.preventDefault(), event.target.hasAttribute("data-calendar-grid")) {
          focusCurrentWeekDay();
          return;
        }
        event.key === "ArrowUp" && setFocusedDate(dateFns.addDays(focusedDate, -7)), event.key === "ArrowDown" && setFocusedDate(dateFns.addDays(focusedDate, 7)), event.key === "ArrowLeft" && setFocusedDate(dateFns.addDays(focusedDate, -1)), event.key === "ArrowRight" && setFocusedDate(dateFns.addDays(focusedDate, 1)), (_a2 = calendarElement == null ? void 0 : calendarElement.querySelector("[data-preserve-focus]")) == null || _a2.focus();
      }
    },
    [calendarElement, focusCurrentWeekDay, focusedDate, setFocusedDate]
  ), moveFocusedDate = React.useCallback(
    (by) => setFocusedDate(dateFns.addMonths(focusedDate, by)),
    [focusedDate, setFocusedDate]
  );
  return React.useEffect(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]), React.useEffect(() => {
    var _a2;
    (_a2 = document.activeElement) != null && _a2.matches(
      "[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]"
    ) && focusCurrentWeekDay();
  }, [focusCurrentWeekDay, focusedDate]), React.useEffect(() => {
    var _a2, _b;
    const dateChanged = (date == null ? void 0 : date.getTime()) !== ((_a2 = previousDate.current) == null ? void 0 : _a2.getTime()), endDateChanged = (endDate == null ? void 0 : endDate.getTime()) !== ((_b = previousEndDate.current) == null ? void 0 : _b.getTime()), onlyDateChanged = dateChanged && !endDateChanged, onlyEndDateChanged = !dateChanged && endDateChanged, dateIsAfterEndDate = date && endDate && dateFns.isAfter(date, endDate);
    onlyDateChanged && (dateIsAfterEndDate && (setSelectEndValue(!0), onSelect({ date, endDate: null })), setSelectEndValue(!!date), date && setFocusedDate(date)), onlyEndDateChanged && (dateIsAfterEndDate && (setSelectEndValue(!0), onSelect({ date: endDate, endDate: null })), setSelectEndValue(!!date && !endDate), endDate && setFocusedDate(endDate)), dateChanged && endDateChanged && (setSelectEndValue(!0), date && setFocusedDate(date)), previousDate.current = date || null, previousEndDate.current = endDate || null;
  }, [date, endDate, onSelect]), /* @__PURE__ */ jsxRuntime.jsx(
    _singletons.CalendarContext.Provider,
    {
      value: {
        date,
        endDate,
        focusedDate,
        selectRange,
        selectTime,
        firstWeekDay
      },
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { "data-ui": "Calendar", ref: setCalendarElement, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(CalendarHeader, { moveFocusedDate, onNowClick: handleNowClick }) }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Box,
          {
            "data-calendar-grid": !0,
            onKeyDown: handleKeyDown,
            marginTop: 2,
            overflow: "hidden",
            tabIndex: 0,
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(CalendarMonth$2, { onSelect: handleDateChange }),
              PRESERVE_FOCUS_ELEMENT$2
            ]
          }
        )
      ] })
    }
  );
}
function DatePicker$1({ date, endDate, onChange, selectRange, selectTime }) {
  const handleSelect = React.useCallback(
    (dates) => {
      onChange(dates);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Calendar$2,
    {
      date,
      endDate,
      onSelect: handleSelect,
      selectRange,
      selectTime
    }
  );
}
const CustomTextInputBox = styledComponents.styled(ui.Box)(({ $background, $smallClearButton }) => styledComponents.css`
    width: 100%;

    input + span {
      background: ${({ theme: theme2 }) => $background ? theme2.sanity.color.card.disabled.bg2 : "transparent"};
    }

    [data-qa='clear-button'] {
      background: none;
      box-shadow: none;
      display: flex; /* TODO: hack, currently used to vertically center <TextInput>'s clearButton */
      transform: ${$smallClearButton ? "scale(0.8)" : "scale(1)"};
      &:hover {
        opacity: 0.5;
      }
    }
  `), CustomTextInput = React.forwardRef(
  function(props2, ref) {
    const { $background, $smallClearButton, ...rest } = props2;
    return /* @__PURE__ */ jsxRuntime.jsx(CustomTextInputBox, { $background, $smallClearButton, children: /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...rest, ref }) });
  }
);
function getDateISOString({
  date,
  dateOnly,
  roundDay
}) {
  let adjustedDate;
  switch (roundDay) {
    case "end":
      adjustedDate = dateFns.endOfDay(date);
      break;
    case "start":
      adjustedDate = dateFns.startOfDay(date);
      break;
    default:
      adjustedDate = date;
      break;
  }
  return dateOnly ? adjustedDate.toISOString().split("T")[0] : adjustedDate.toISOString();
}
const FORMAT = {
  date: {
    exampleDate: "Jan 1, 2000",
    pattern: "MMM d, yyyy"
  },
  datetime: {
    exampleDate: "Jan 1, 2000 12:00 AM",
    pattern: "MMM d, yyyy p"
  }
};
function ParsedDateTextInput({
  isDateTime,
  onChange,
  placeholderDate,
  isDateTimeFormat,
  value,
  ...rest
}) {
  const { t: t2 } = useTranslation(), dateFormat = isDateTimeFormat ? FORMAT.datetime.pattern : FORMAT.date.pattern, [customValidity, setCustomValidity] = React.useState(void 0), [inputValue, setInputValue] = React.useState(() => {
    if (!value)
      return "";
    const inputValueDate = new Date(value);
    return dateFns.format(inputValueDate, dateFormat);
  }), formattedPlaceholder = React.useMemo(() => dateFns.format(placeholderDate || /* @__PURE__ */ new Date(), dateFormat), [dateFormat, placeholderDate]), processInputString = React.useCallback(
    ({ dateString, triggerOnChange }) => {
      if (!dateString)
        return;
      const dateParsed = dateFns.parse(dateString, dateFormat, /* @__PURE__ */ new Date()), validDate = dateFns.isValid(dateParsed);
      validDate && (triggerOnChange && onChange(getDateISOString({ date: dateParsed, dateOnly: !isDateTime })), setInputValue(dateFns.format(dateParsed, dateFormat))), setCustomValidity(validDate ? void 0 : `Invalid ${isDateTime ? "datetime" : "date"}`);
    },
    [dateFormat, isDateTime, onChange]
  ), handleTextInputBlur = React.useCallback(() => {
    processInputString({ dateString: inputValue, triggerOnChange: !0 });
  }, [inputValue, processInputString]), handleTextInputChange = React.useCallback((event) => {
    setInputValue(event.currentTarget.value);
  }, []), handleTextInputClear = React.useCallback(() => {
    onChange(null), setCustomValidity(void 0), setInputValue("");
  }, [onChange]), handleTextInputKeyDown = React.useCallback(
    (event) => {
      event.key === "Enter" && processInputString({ dateString: inputValue, triggerOnChange: !0 });
    },
    [inputValue, processInputString]
  );
  return React.useEffect(() => {
    const updatedDate = value && new Date(value);
    updatedDate && processInputString({
      dateString: dateFns.format(updatedDate, dateFormat),
      triggerOnChange: !1
    });
  }, [dateFormat, processInputString, isDateTimeFormat, value]), /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: t2("calendar.error.must-be-in-format", {
        exampleDate: isDateTimeFormat ? FORMAT.datetime.exampleDate : FORMAT.date.exampleDate
      }),
      disabled: !customValidity,
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        CustomTextInput,
        {
          ...rest,
          clearButton: !!inputValue,
          customValidity,
          onBlur: handleTextInputBlur,
          onChange: handleTextInputChange,
          onClear: handleTextInputClear,
          onKeyDown: handleTextInputKeyDown,
          placeholder: formattedPlaceholder,
          value: inputValue
        }
      )
    }
  );
}
function CommonDateDirectionInput({
  direction,
  isDateTime,
  onChange,
  value
}) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), roundDay = React.useMemo(() => {
    switch (direction) {
      case "after":
        return "end";
      case "before":
        return "start";
      default:
        return;
    }
  }, [direction]), handleDatePickerChange = React.useCallback(
    ({ date }) => {
      let dateISOString = null;
      date && (dateISOString = getDateISOString({
        date,
        dateOnly: !isDateTime,
        roundDay: value != null && value.includeTime ? void 0 : roundDay
      })), onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        date: dateISOString
      });
    },
    [isDateTime, onChange, roundDay, value == null ? void 0 : value.includeTime]
  ), handleIncludeTimeChange = React.useCallback(() => {
    const includeTime = !(value != null && value.includeTime), date = value != null && value.date ? new Date(value.date) : null;
    let dateISOString = null;
    date && (dateISOString = getDateISOString({
      date,
      dateOnly: !isDateTime,
      roundDay: includeTime ? "start" : roundDay
    })), onChange({ includeTime, date: dateISOString });
  }, [isDateTime, onChange, roundDay, value]), handleTextDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        date: date || null
      });
    },
    [onChange, value == null ? void 0 : value.includeTime]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ParsedDateTextInput,
      {
        "aria-label": t2("search.filter-date-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        isDateTime,
        isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
        onChange: handleTextDateChange,
        radius: 2,
        value: value == null ? void 0 : value.date
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      DatePicker$1,
      {
        date: value != null && value.date ? new Date(value.date) : void 0,
        onChange: handleDatePickerChange,
        selectTime: isDateTime
      }
    ),
    isDateTime && /* @__PURE__ */ jsxRuntime.jsx(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value != null && value.includeTime) })
  ] });
}
function SearchFilterDateAfterInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "after", isDateTime: !1 });
}
function SearchFilterDateBeforeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "before", isDateTime: !1 });
}
function CommonDateEqualInput({
  isDateTime,
  onChange,
  value
}) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleDatePickerChange = React.useCallback(
    ({ date }) => {
      if (date) {
        const dateISOString = getDateISOString({ date, dateOnly: !isDateTime });
        onChange({
          includeTime: value == null ? void 0 : value.includeTime,
          date: dateISOString
        });
      } else
        onChange(null);
    },
    [isDateTime, onChange, value == null ? void 0 : value.includeTime]
  ), handleIncludeTimeChange = React.useCallback(() => {
    const includeTime = !(value != null && value.includeTime), date = value != null && value.date ? new Date(value.date) : null;
    let dateISOString = null;
    date && (dateISOString = getDateISOString({
      date,
      dateOnly: !isDateTime
    })), onChange({ includeTime, date: dateISOString });
  }, [isDateTime, onChange, value]), handleTextDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        date: date || null
      });
    },
    [onChange, value == null ? void 0 : value.includeTime]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ParsedDateTextInput,
      {
        "aria-label": t2("search.filter-date-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        isDateTime,
        isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
        onChange: handleTextDateChange,
        radius: 2,
        value: value == null ? void 0 : value.date
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      DatePicker$1,
      {
        date: value != null && value.date ? new Date(value.date) : void 0,
        onChange: handleDatePickerChange,
        selectTime: isDateTime
      }
    ),
    isDateTime && /* @__PURE__ */ jsxRuntime.jsx(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value != null && value.includeTime) })
  ] });
}
function SearchFilterDateEqualInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateEqualInput, { ...props2, isDateTime: !1 });
}
const UNIT_CHOICES = [
  { unit: "day", key: "search.filter-date-unit_days" },
  { unit: "month", key: "search.filter-date-unit_months" },
  { unit: "year", key: "search.filter-date-unit_years" }
];
function SearchFilterDateLastInput({
  onChange,
  value
}) {
  const [uncontrolledValue, setUncontrolledValue] = React.useState((value == null ? void 0 : value.unitValue) || ""), dateUnit = React.useRef("day"), dateValue = React.useRef((value == null ? void 0 : value.unitValue) || null), { t: t2 } = useTranslation(), {
    state: { fullscreen }
  } = useSearchState(), handleChange = React.useCallback(() => {
    onChange({
      unit: dateUnit == null ? void 0 : dateUnit.current,
      unitValue: dateValue == null ? void 0 : dateValue.current
    });
  }, [onChange]), handleUnitChange = React.useCallback(
    (event) => {
      dateUnit.current = event.currentTarget.value, handleChange();
    },
    [handleChange]
  ), handleValueChange = React.useCallback(
    (event) => {
      setUncontrolledValue(event.currentTarget.value);
      const numValue = parseFloat(event.currentTarget.value);
      dateValue.current = Number.isFinite(numValue) ? numValue : null, handleChange();
    },
    [handleChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        "aria-label": t2("search.filter-date-value-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        onChange: handleValueChange,
        pattern: "\\d*",
        radius: 2,
        step: "1",
        type: "number",
        value: uncontrolledValue
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Select,
      {
        "aria-label": t2("search.filter-date-unit-aria-label"),
        fontSize: fullscreen ? 2 : 1,
        onChange: handleUnitChange,
        radius: 2,
        value: value == null ? void 0 : value.unit,
        children: UNIT_CHOICES.map((choice) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: choice.unit, children: t2(choice.key) }, choice.key))
      }
    ) })
  ] });
}
const PLACEHOLDER_START_DATE_OFFSET = -7;
function CommonDateRangeInput({
  isDateTime,
  onChange,
  value
}) {
  const { t: t2 } = useTranslation(), {
    state: { fullscreen }
  } = useSearchState(), placeholderStartDate = React.useMemo(() => dateFns.addDays(/* @__PURE__ */ new Date(), PLACEHOLDER_START_DATE_OFFSET), []), placeholderEndDate = React.useMemo(() => /* @__PURE__ */ new Date(), []), handleDatePickerChange = React.useCallback(
    ({ date, endDate }) => {
      onChange(
        getStartAndEndDate({
          date,
          endDate,
          includeTime: value == null ? void 0 : value.includeTime,
          isDateTime
        })
      );
    },
    [isDateTime, onChange, value == null ? void 0 : value.includeTime]
  ), handleIncludeTimeChange = React.useCallback(() => {
    const includeTime = !(value != null && value.includeTime);
    onChange(
      getStartAndEndDate({
        date: value != null && value.from ? new Date(value.from) : null,
        endDate: value != null && value.to ? new Date(value.to) : null,
        includeTime,
        isDateTime
      })
    );
  }, [isDateTime, onChange, value]), handleTextEndDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        to: date || null,
        from: (value == null ? void 0 : value.from) || null
      });
    },
    [onChange, value]
  ), handleTextStartDateChange = React.useCallback(
    (date) => {
      onChange({
        includeTime: value == null ? void 0 : value.includeTime,
        to: (value == null ? void 0 : value.to) || null,
        from: date || null
      });
    },
    [onChange, value]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ParsedDateTextInput,
        {
          "aria-label": t2("search.filter-date-range-start-date-aria-label"),
          fontSize: fullscreen ? 2 : 1,
          isDateTime,
          isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
          onChange: handleTextStartDateChange,
          placeholderDate: placeholderStartDate,
          radius: 2,
          value: value == null ? void 0 : value.from
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ParsedDateTextInput,
        {
          "aria-label": t2("search.filter-date-range-end-date-aria-label"),
          fontSize: fullscreen ? 2 : 1,
          isDateTime,
          isDateTimeFormat: isDateTime && (value == null ? void 0 : value.includeTime),
          onChange: handleTextEndDateChange,
          placeholderDate: placeholderEndDate,
          radius: 2,
          value: value == null ? void 0 : value.to
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      DatePicker$1,
      {
        date: value != null && value.from ? new Date(value.from) : void 0,
        endDate: value != null && value.to ? new Date(value.to) : void 0,
        onChange: handleDatePickerChange,
        selectRange: !0,
        selectTime: isDateTime
      }
    ),
    isDateTime && /* @__PURE__ */ jsxRuntime.jsx(DateIncludeTimeFooter, { onChange: handleIncludeTimeChange, value: !!(value != null && value.includeTime) })
  ] }) });
}
function getStartAndEndDate({
  date,
  endDate,
  includeTime,
  isDateTime
}) {
  return includeTime ? {
    includeTime,
    to: endDate ? getDateISOString({ date: endDate, dateOnly: !isDateTime, roundDay: "start" }) : null,
    from: date ? getDateISOString({ date, dateOnly: !isDateTime, roundDay: "start" }) : null
  } : {
    includeTime,
    to: endDate ? getDateISOString({ date: endDate, dateOnly: !isDateTime, roundDay: "end" }) : null,
    from: date ? getDateISOString({ date, dateOnly: !isDateTime, roundDay: "start" }) : null
  };
}
function SearchFilterDateRangeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateRangeInput, { ...props2, isDateTime: !1 });
}
function SearchFilterDateTimeAfterInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "after", isDateTime: !0 });
}
function SearchFilterDateTimeBeforeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateDirectionInput, { ...props2, direction: "before", isDateTime: !0 });
}
function SearchFilterDateTimeEqualInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateEqualInput, { ...props2, isDateTime: !0 });
}
function SearchFilterDateTimeRangeInput(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CommonDateRangeInput, { ...props2, isDateTime: !0 });
}
const COMMON = {
  dateAfter: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: null
  },
  dateBefore: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: null
  },
  dateEqual: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: {
      date: null,
      includeTime: !1
    }
  },
  dateLast: {
    buttonValueComponent: SearchButtonValueDateLast
  },
  dateNotEqual: {
    buttonValueComponent: SearchButtonValueDate,
    initialValue: {
      date: null,
      includeTime: !1
    }
  },
  dateRange: {
    initialValue: null
  }
}, dateOperators = {
  dateAfter: {
    ...COMMON.dateAfter,
    nameKey: "search.operator.date-after.name",
    descriptionKey: "search.operator.date-after.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} > ${toJSON(value == null ? void 0 : value.date)}` : null,
    inputComponent: SearchFilterDateAfterInput,
    type: "dateAfter"
  },
  dateBefore: {
    ...COMMON.dateBefore,
    nameKey: "search.operator.date-before.name",
    descriptionKey: "search.operator.date-before.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} < ${toJSON(value == null ? void 0 : value.date)}` : null,
    inputComponent: SearchFilterDateBeforeInput,
    type: "dateBefore"
  },
  dateEqual: {
    ...COMMON.dateEqual,
    nameKey: "search.operator.date-equal.name",
    descriptionKey: "search.operator.date-equal.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} == ${toJSON(value.date)}` : null,
    inputComponent: SearchFilterDateEqualInput,
    type: "dateEqual"
  },
  dateLast: {
    ...COMMON.dateLast,
    nameKey: "search.operator.date-last.name",
    descriptionKey: "search.operator.date-last.description",
    groqFilter: ({ fieldPath, value }) => {
      const flooredValue = typeof (value == null ? void 0 : value.unitValue) == "number" ? Math.floor(value.unitValue) : void 0, timestampAgo = Number.isFinite(flooredValue) ? dateFns.sub(/* @__PURE__ */ new Date(), {
        days: (value == null ? void 0 : value.unit) === "day" ? flooredValue : 0,
        months: (value == null ? void 0 : value.unit) === "month" ? flooredValue : 0,
        years: (value == null ? void 0 : value.unit) === "year" ? flooredValue : 0
      }).toISOString().split("T")[0] : null;
      return timestampAgo && fieldPath ? `${fieldPath} > ${toJSON(timestampAgo)}` : null;
    },
    inputComponent: SearchFilterDateLastInput,
    initialValue: {
      unit: "day",
      unitValue: 7
    },
    type: "dateLast"
  },
  dateNotEqual: {
    ...COMMON.dateNotEqual,
    nameKey: "search.operator.date-not-equal.name",
    descriptionKey: "search.operator.date-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `${fieldPath} != ${toJSON(value.date)}` : null,
    inputComponent: SearchFilterDateEqualInput,
    type: "dateNotEqual"
  },
  dateRange: {
    ...COMMON.dateRange,
    nameKey: "search.operator.date-range.name",
    descriptionKey: "search.operator.date-range.description",
    buttonValueComponent: SearchButtonValueDateRange,
    groqFilter: ({ fieldPath, value }) => value != null && value.to && value != null && value.from && fieldPath ? `${fieldPath} >= ${toJSON(value.from)} && ${fieldPath} <= ${toJSON(value.to)}` : null,
    initialValue: {
      includeTime: !1,
      to: dateFns.startOfToday().toISOString(),
      from: null
    },
    inputComponent: SearchFilterDateRangeInput,
    type: "dateRange"
  },
  dateTimeAfter: {
    ...COMMON.dateAfter,
    nameKey: "search.operator.date-time-after.name",
    descriptionKey: "search.operator.date-time-after.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `dateTime(${fieldPath}) > dateTime(${toJSON(value.date)})` : null,
    inputComponent: SearchFilterDateTimeAfterInput,
    type: "dateTimeAfter"
  },
  dateTimeBefore: {
    ...COMMON.dateBefore,
    nameKey: "search.operator.date-time-before.name",
    descriptionKey: "search.operator.date-time-before.description",
    groqFilter: ({ fieldPath, value }) => value != null && value.date && fieldPath ? `dateTime(${fieldPath}) < dateTime(${toJSON(value.date)})` : null,
    inputComponent: SearchFilterDateTimeBeforeInput,
    type: "dateTimeBefore"
  },
  dateTimeEqual: {
    ...COMMON.dateEqual,
    nameKey: "search.operator.date-time-equal.name",
    descriptionKey: "search.operator.date-time-equal.description",
    groqFilter: ({ fieldPath, value }) => {
      const date = (value == null ? void 0 : value.date) && new Date(value.date);
      if (!date || !dateFns.isValid(date) || !fieldPath)
        return null;
      const dateStart = (value != null && value.includeTime ? dateFns.startOfMinute(date) : dateFns.startOfDay(date)).toISOString(), dateEnd = (value != null && value.includeTime ? dateFns.endOfMinute(date) : dateFns.endOfDay(date)).toISOString();
      return `dateTime(${fieldPath}) > dateTime(${toJSON(
        dateStart
      )}) && dateTime(${fieldPath}) < dateTime(${toJSON(dateEnd)})`;
    },
    inputComponent: SearchFilterDateTimeEqualInput,
    type: "dateTimeEqual"
  },
  dateTimeLast: {
    ...COMMON.dateLast,
    nameKey: "search.operator.date-time-last.name",
    descriptionKey: "search.operator.date-time-last.description",
    groqFilter: ({ fieldPath, value }) => {
      const flooredValue = typeof (value == null ? void 0 : value.unitValue) == "number" ? Math.floor(value.unitValue) : void 0, timestampAgo = Number.isFinite(flooredValue) ? dateFns.sub(/* @__PURE__ */ new Date(), {
        days: (value == null ? void 0 : value.unit) === "day" ? flooredValue : 0,
        months: (value == null ? void 0 : value.unit) === "month" ? flooredValue : 0,
        years: (value == null ? void 0 : value.unit) === "year" ? flooredValue : 0
      }).toISOString() : null;
      return timestampAgo && fieldPath ? `dateTime(${fieldPath}) > dateTime(${toJSON(timestampAgo)})` : null;
    },
    initialValue: {
      unit: "day",
      unitValue: 7
    },
    inputComponent: SearchFilterDateLastInput,
    type: "dateTimeLast"
  },
  dateTimeNotEqual: {
    ...COMMON.dateNotEqual,
    nameKey: "search.operator.date-time-not-equal.name",
    descriptionKey: "search.operator.date-time-not-equal.description",
    groqFilter: ({ fieldPath, value }) => {
      const date = (value == null ? void 0 : value.date) && new Date(value.date);
      if (!date || !dateFns.isValid(date) || !fieldPath)
        return null;
      const dateStart = (value != null && value.includeTime ? dateFns.startOfMinute(date) : dateFns.startOfDay(date)).toISOString(), dateEnd = (value != null && value.includeTime ? dateFns.endOfMinute(date) : dateFns.endOfDay(date)).toISOString();
      return `dateTime(${fieldPath}) < dateTime(${toJSON(
        dateStart
      )}) || dateTime(${fieldPath}) > dateTime(${toJSON(dateEnd)})`;
    },
    inputComponent: SearchFilterDateTimeEqualInput,
    type: "dateTimeNotEqual"
  },
  dateTimeRange: {
    ...COMMON.dateRange,
    nameKey: "search.operator.date-time-range.name",
    descriptionKey: "search.operator.date-time-range.description",
    buttonValueComponent: SearchButtonValueDateRange,
    groqFilter: ({ fieldPath, value }) => value != null && value.to && value != null && value.from && fieldPath ? `dateTime(${fieldPath}) >= dateTime(${toJSON(
      value.from
    )}) && dateTime(${fieldPath}) <= dateTime(${toJSON(value.to)})` : null,
    initialValue: {
      includeTime: !1,
      to: dateFns.startOfToday().toISOString(),
      from: null
    },
    inputComponent: SearchFilterDateTimeRangeInput,
    type: "dateTimeRange"
  }
}, definedOperators = {
  defined: {
    nameKey: "search.operator.defined.name",
    descriptionKey: "search.operator.defined.description",
    groqFilter: ({ fieldPath }) => fieldPath ? `defined(${fieldPath})` : null,
    type: "defined"
  },
  notDefined: {
    nameKey: "search.operator.not-defined.name",
    descriptionKey: "search.operator.not-defined.description",
    i18nKey: "search.operator.not-defined",
    groqFilter: ({ fieldPath }) => fieldPath ? `!defined(${fieldPath})` : null,
    type: "notDefined"
  }
}, numberOperators = {
  numberEqual: {
    nameKey: "search.operator.number-equal.name",
    descriptionKey: "search.operator.number-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberEqual"
  },
  numberGt: {
    nameKey: "search.operator.number-gt.name",
    descriptionKey: "search.operator.number-gt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} > ${toJSON(value)}` : null,
    icon: GtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberGt"
  },
  numberGte: {
    nameKey: "search.operator.number-gte.name",
    descriptionKey: "search.operator.number-gte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} >= ${toJSON(value)}` : null,
    icon: GteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberGte"
  },
  numberLt: {
    nameKey: "search.operator.number-lt.name",
    descriptionKey: "search.operator.number-lt.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} < ${toJSON(value)}` : null,
    icon: LtIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberLt"
  },
  numberLte: {
    nameKey: "search.operator.number-lte.name",
    descriptionKey: "search.operator.number-lte.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} <= ${toJSON(value)}` : null,
    icon: LteIcon,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberLte"
  },
  numberNotEqual: {
    nameKey: "search.operator.number-not-equal.name",
    descriptionKey: "search.operator.number-not-equal.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value) && fieldPath ? `${fieldPath} != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterNumberInput,
    type: "numberNotEqual"
  },
  numberRange: {
    nameKey: "search.operator.number-range.name",
    descriptionKey: "search.operator.number-range.description",
    groqFilter: ({ fieldPath, value }) => Number.isFinite(value == null ? void 0 : value.to) && Number.isFinite(value == null ? void 0 : value.from) && fieldPath ? `${fieldPath} > ${toJSON(value == null ? void 0 : value.from)} && ${fieldPath} < ${toJSON(value == null ? void 0 : value.to)}` : "",
    initialValue: null,
    inputComponent: SearchFilterNumberRangeInput,
    type: "numberRange"
  }
};
function SearchFilterStringInput({
  onChange,
  value
}) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleChange = React.useCallback(
    (event) => onChange(event.currentTarget.value || null),
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      fontSize: fullscreen ? 2 : 1,
      onChange: handleChange,
      placeholder: t2("search.filter-string-value-placeholder"),
      radius: 2,
      value: value || ""
    }
  );
}
const portableTextOperators = {
  portableTextEqual: {
    nameKey: "search.operator.portable-text-equal.name",
    descriptionKey: "search.operator.portable-text-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `pt::text(${fieldPath}) == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextEqual"
  },
  portableTextMatches: {
    nameKey: "search.operator.portable-text-contains.name",
    descriptionKey: "search.operator.portable-text-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `pt::text(${fieldPath}) match ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextMatches"
  },
  portableTextNotEqual: {
    nameKey: "search.operator.portable-text-not-equal.name",
    descriptionKey: "search.operator.portable-text-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `pt::text(${fieldPath}) != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextNotEqual"
  },
  portableTextNotMatches: {
    nameKey: "search.operator.portable-text-not-contains.name",
    descriptionKey: "search.operator.portable-text-not-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(pt::text(${fieldPath}) match ${toJSON(value)})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "portableTextNotMatches"
  }
}, referenceOperators = {
  referenceEqual: {
    nameKey: "search.operator.reference-equal.name",
    descriptionKey: "search.operator.reference-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}._ref == ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "referenceEqual"
  },
  referenceNotEqual: {
    nameKey: "search.operator.reference-not-equal.name",
    descriptionKey: "search.operator.reference-not-equal.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ fieldPath, value }) => value != null && value._ref && fieldPath ? `${fieldPath}._ref != ${toJSON(value._ref)}` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "referenceNotEqual"
  },
  referencesAssetFile: {
    nameKey: "search.operator.reference-asset-file.name",
    descriptionKey: "search.operator.reference-asset-file.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ value }) => value != null && value._ref ? `references(${toJSON(value._ref)})` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("file"),
    type: "referencesAssetFile"
  },
  referencesAssetImage: {
    nameKey: "search.operator.reference-asset-image.name",
    descriptionKey: "search.operator.reference-asset-image.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ value }) => value != null && value._ref ? `references(${toJSON(value._ref)})` : null,
    initialValue: null,
    inputComponent: SearchFilterAssetInput("image"),
    type: "referencesAssetImage"
  },
  referencesDocument: {
    nameKey: "search.operator.reference-document.name",
    descriptionKey: "search.operator.reference-document.description",
    buttonValueComponent: SearchButtonValueReference,
    groqFilter: ({ value }) => value != null && value._ref ? `references(${toJSON(value._ref)})` : null,
    initialValue: null,
    inputComponent: SearchFilterReferenceInput,
    type: "referencesDocument"
  }
}, slugOperators = {
  slugEqual: {
    nameKey: "search.operator.slug-equal.name",
    descriptionKey: "search.operator.slug-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath}.current == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "slugEqual"
  },
  slugMatches: {
    nameKey: "search.operator.slug-contains.name",
    descriptionKey: "search.operator.slug-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath}.current match ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    label: "contains",
    type: "slugMatches"
  },
  slugNotEqual: {
    nameKey: "search.operator.slug-not-equal.name",
    descriptionKey: "search.operator.slug-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath}.current != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "slugNotEqual"
  },
  slugNotMatches: {
    nameKey: "search.operator.slug-not-contains.name",
    descriptionKey: "search.operator.slug-not-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(${fieldPath}.current match ${toJSON(value)})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "slugNotMatches"
  }
}, stringOperators = {
  stringEqual: {
    nameKey: "search.operator.string-equal.name",
    descriptionKey: "search.operator.string-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringEqual"
  },
  stringListEqual: {
    nameKey: "search.operator.string-list-equal.name",
    descriptionKey: "search.operator.string-list-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} == ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "stringListEqual"
  },
  stringListNotEqual: {
    nameKey: "search.operator.string-list-not-equal.name",
    descriptionKey: "search.operator.string-list-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringListInput,
    type: "stringListNotEqual"
  },
  stringMatches: {
    nameKey: "search.operator.string-contains.name",
    descriptionKey: "search.operator.string-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} match ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringMatches"
  },
  stringNotEqual: {
    nameKey: "search.operator.string-not-equal.name",
    descriptionKey: "search.operator.string-not-equal.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `${fieldPath} != ${toJSON(value)}` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringNotEqual"
  },
  stringNotMatches: {
    nameKey: "search.operator.string-not-contains.name",
    descriptionKey: "search.operator.string-not-contains.description",
    groqFilter: ({ fieldPath, value }) => value && fieldPath ? `!(${fieldPath} match ${toJSON(value)})` : null,
    initialValue: null,
    inputComponent: SearchFilterStringInput,
    type: "stringNotMatches"
  }
}, searchOperators = {
  ...arrayOperators,
  ...assetOperators,
  ...booleanOperators,
  ...dateOperators,
  ...definedOperators,
  ...numberOperators,
  ...portableTextOperators,
  ...referenceOperators,
  ...slugOperators,
  ...stringOperators
}, operatorDefinitions = Object.values(searchOperators);
function pseudoRandomNumber(seed) {
  const hashCode = seed.split("").reduce((prevHash, currVal) => (prevHash << 5) - prevHash + currVal.charCodeAt(0) | 0, 0);
  return Math.abs(hashCode * 16807 % 2147483647) / 2147483647;
}
const SvgText = styledComponents.styled.text`
  font-family: ${({ theme: theme2 }) => theme2.sanity.fonts.text.family};
  font-weight: ${({ theme: theme2 }) => theme2.sanity.fonts.text.weights.medium};
  font-size: ${({ theme: theme2 }) => theme2.sanity.fonts.text.sizes[1].fontSize}px;
  transform: translateY(1px);
`;
function createDefaultIcon(title, subtitle) {
  const rng1 = pseudoRandomNumber(`${title} ${subtitle}`), huesWithoutGray = color.COLOR_HUES.filter((hue) => hue !== "gray"), colorHue = huesWithoutGray[Math.floor(rng1 * huesWithoutGray.length)], possibleTints = ["300", "400", "500", "600", "700"], rng2 = pseudoRandomNumber(rng1.toString()), tint = possibleTints[Math.floor(rng2 * possibleTints.length)], color$1 = color.hues[colorHue][tint].hex, letters = title.split(/\s/g).map((word) => word.replace(/\\W/g, "")).filter(Boolean).slice(0, 2).map((i) => i.charAt(0).toUpperCase()), darkened = color2k.darken(color$1, 0.4), lightened = color2k.lighten(color$1, 0.4), textColor = color2k.hasBadContrast(color$1, "readable", darkened) ? color2k.hasBadContrast(color$1, "readable", lightened) ? color2k.readableColor(color$1) : lightened : darkened;
  return /* @__PURE__ */ jsxRuntime.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: [
    /* @__PURE__ */ jsxRuntime.jsx("rect", { width: 32, height: 32, rx: 2, fill: color$1 }),
    /* @__PURE__ */ jsxRuntime.jsx(
      SvgText,
      {
        x: "50%",
        y: "50%",
        textAnchor: "middle",
        alignmentBaseline: "middle",
        dominantBaseline: "middle",
        fill: textColor,
        children: letters
      }
    )
  ] });
}
const commentsLocaleNamespace = "comments", commentsUsEnglishLocaleBundle = {
  locale: "en-US",
  namespace: commentsLocaleNamespace,
  resources: () => Promise.resolve().then(function() {
    return require("./_chunks-cjs/resources.js");
  })
};
function CommentsAuthoringPathProvider(props2) {
  const { children } = props2, [authoringPath, setAuthoringPath] = React.useState(null), handleSetAuthoringPath = React.useCallback((nextAuthoringPath) => {
    setAuthoringPath(nextAuthoringPath);
  }, []), value = React.useMemo(
    () => ({
      authoringPath,
      setAuthoringPath: handleSetAuthoringPath
    }),
    [authoringPath, handleSetAuthoringPath]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.CommentsAuthoringPathContext.Provider, { value, children });
}
function useCommentsIntent() {
  return React.useContext(_singletons.CommentsIntentContext);
}
function useNotificationTarget(opts) {
  const { documentId, documentType, getCommentLink } = opts || {}, schemaType = useSchema().get(documentType), { title: workspaceTitle } = useWorkspace(), documentPreviewStore = useDocumentPreviewStore(), previewState = reactRx.useMemoObservable(() => !documentId || !schemaType ? rxjs.of(null) : getPreviewStateObservable$1(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title) || "Sanity document";
  return {
    getNotificationValue: React.useCallback(
      ({ commentId }) => ({
        documentTitle,
        url: getCommentLink == null ? void 0 : getCommentLink(commentId),
        workspaceTitle
      }),
      [documentTitle, getCommentLink, workspaceTitle]
    )
  };
}
function TelephoneInput(props2) {
  const { schemaType, validationError, value, elementProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      type: "tel",
      inputMode: "tel",
      customValidity: validationError,
      value: value || "",
      placeholder: schemaType.placeholder,
      ...elementProps
    }
  );
}
function resolveConditionalProperty(property, context) {
  const { currentUser, document: document2, parent, value } = context;
  return typeof property == "boolean" || property === void 0 ? !!property : property({
    document: document2,
    parent,
    value,
    currentUser
  }) === !0;
}
function setAtPath(currentTree, path, value) {
  var _a2;
  if (path.length === 0)
    return { ...currentTree || {}, value };
  const [head, ...tail] = path, key = types.isKeySegment(head) ? head._key : String(head), children = (_a2 = currentTree == null ? void 0 : currentTree.children) != null ? _a2 : {};
  return {
    value: currentTree == null ? void 0 : currentTree.value,
    children: { ...children, [key]: setAtPath(children[key] || {}, tail, value) }
  };
}
const MAX_FIELD_DEPTH = 20, AUTO_COLLAPSE_DEPTH = 3, ALL_FIELDS_GROUP = {
  name: "all-fields",
  title: "All fields",
  hidden: !1
};
function getCollapsedWithDefaults(options = {}, level) {
  if ((options == null ? void 0 : options.collapsible) === !1 || (options == null ? void 0 : options.collapsable) === !1)
    return { collapsible: !1, collapsed: !1 };
  const collapsed = (
    // eslint-disable-next-line no-nested-ternary
    typeof (options == null ? void 0 : options.collapsed) == "boolean" ? options.collapsed : level >= AUTO_COLLAPSE_DEPTH ? !0 : void 0
  );
  return {
    collapsible: (options == null ? void 0 : options.collapsible) === !0 || (options == null ? void 0 : options.collapsable) === !0 || collapsed === !0 ? !0 : void 0,
    collapsed
  };
}
function getItemType(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return itemTypeName === "object" && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
function getPrimitiveItemType(arrayType, item) {
  const itemTypeName = content.resolveTypeName(item);
  return arrayType == null ? void 0 : arrayType.of.find(
    (memberType) => memberType.name === itemTypeName || memberType.jsonType === itemTypeName
  );
}
function isFieldEnabledByGroupFilter(groupsConfig, fieldGroup, selectedGroup) {
  return selectedGroup.name === ALL_FIELDS_GROUP.name ? !0 : fieldGroup === void 0 ? !1 : groupsConfig.length === 0 && selectedGroup.name === ALL_FIELDS_GROUP.name ? !0 : castArray__default.default(fieldGroup).includes(selectedGroup.name);
}
function isAcceptedObjectValue(value) {
  return typeof value > "u" || isRecord$4(value);
}
function isValidArrayOfObjectsValue(value) {
  return typeof value > "u" || Array.isArray(value);
}
function isValidArrayOfPrimitivesValue(value) {
  return typeof value > "u" || Array.isArray(value);
}
function everyItemIsObject(value) {
  return value.length === 0 || value.every((item) => isRecord$4(item));
}
function findDuplicateKeyEntries(array) {
  const seenKeys = /* @__PURE__ */ new Set();
  return array.reduce((acc, item, index) => (seenKeys.has(item._key) && acc.push([index, item._key]), seenKeys.add(item._key), acc), []);
}
function hasKey(value) {
  return "_key" in value;
}
function everyItemHasKey(array) {
  return array == null ? void 0 : array.every((item) => isRecord$4(item) && hasKey(item));
}
function isChangedValue(value, comparisonValue) {
  return Array.isArray(value) && typeof comparisonValue > "u" || Array.isArray(comparisonValue) && typeof value > "u" ? !1 : value && !comparisonValue ? !0 : !isEqual__default.default(value, comparisonValue);
}
function prepareFieldMember(props2) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const { parent, field, index } = props2, fieldPath = PathUtils.pathFor([...parent.path, field.name]), fieldLevel = getFieldLevel(field.type, parent.level + 1), parentValue = parent.value, parentComparisonValue = parent.comparisonValue;
  if (!isAcceptedObjectValue(parentValue))
    throw new Error("Unexpected non-object value");
  const normalizedFieldGroupNames = field.group ? castArray__default.default(field.group) : [], inSelectedGroup = isFieldEnabledByGroupFilter(
    parent.groups,
    field.group,
    parent.selectedGroup
  );
  if (types.isObjectSchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = isRecord$4(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (!isAcceptedObjectValue(fieldValue))
      return {
        kind: "error",
        key: field.name,
        fieldName: field.name,
        error: {
          type: "INCOMPATIBLE_TYPE",
          expectedSchemaType: field.type,
          resolvedValueType: content.resolveTypeName(fieldValue),
          value: fieldValue
        }
      };
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    if (resolveConditionalProperty(field.type.hidden, conditionalPropertyContext))
      return {
        kind: "hidden",
        key: `field-${field.name}`,
        name: field.name,
        index
      };
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext), fieldGroupState = (_b = (_a2 = parent.fieldGroupState) == null ? void 0 : _a2.children) == null ? void 0 : _b[field.name], scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[field.name], scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[field.name], inputState = prepareObjectInputState({
      schemaType: field.type,
      currentUser: parent.currentUser,
      parent: parent.value,
      document: parent.document,
      value: fieldValue,
      changed: isChangedValue(fieldValue, fieldComparisonValue),
      comparisonValue: fieldComparisonValue,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      path: fieldPath,
      level: fieldLevel,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      readOnly,
      changesOpen: parent.changesOpen
    });
    if (inputState === null)
      return null;
    const defaultCollapsedState = getCollapsedWithDefaults(field.type.options, fieldLevel), collapsed = scopedCollapsedPaths ? scopedCollapsedPaths.value : defaultCollapsedState.collapsed;
    return {
      kind: "field",
      key: `field-${field.name}`,
      name: field.name,
      index,
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      open: PathUtils.startsWith(fieldPath, parent.openPath),
      field: inputState,
      collapsed,
      collapsible: defaultCollapsedState.collapsible
    };
  } else if (types.isArraySchemaType(field.type)) {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = isRecord$4(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0;
    if (types.isArrayOfObjectsSchemaType(field.type)) {
      const hasValue2 = typeof fieldValue < "u";
      if (hasValue2 && !isValidArrayOfObjectsValue(fieldValue)) {
        const resolvedValueType = content.resolveTypeName(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      if (hasValue2 && !everyItemIsObject(fieldValue))
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MIXED_ARRAY",
            schemaType: field.type,
            value: fieldValue
          }
        };
      if (hasValue2 && !everyItemHasKey(fieldValue))
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "MISSING_KEYS",
            value: fieldValue,
            schemaType: field.type
          }
        };
      const duplicateKeyEntries = hasValue2 ? findDuplicateKeyEntries(fieldValue) : [];
      if (duplicateKeyEntries.length > 0)
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "DUPLICATE_KEYS",
            duplicates: duplicateKeyEntries,
            schemaType: field.type
          }
        };
      const fieldGroupState = (_h = (_g = parent.fieldGroupState) == null ? void 0 : _g.children) == null ? void 0 : _h[field.name], scopedCollapsedPaths = (_j = (_i = parent.collapsedPaths) == null ? void 0 : _i.children) == null ? void 0 : _j[field.name], scopedCollapsedFieldSets = (_l = (_k = parent.collapsedFieldSets) == null ? void 0 : _k.children) == null ? void 0 : _l[field.name], readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      }), fieldState = prepareArrayOfObjectsInputState({
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      return fieldState === null ? null : {
        kind: "field",
        key: `field-${field.name}`,
        name: field.name,
        index,
        open: PathUtils.startsWith(fieldPath, parent.openPath),
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        collapsible: !1,
        collapsed: !1,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    } else {
      if (!isValidArrayOfPrimitivesValue(fieldValue)) {
        const resolvedValueType = content.resolveTypeName(fieldValue);
        return {
          kind: "error",
          key: field.name,
          fieldName: field.name,
          error: {
            type: "INCOMPATIBLE_TYPE",
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }
      const fieldGroupState = (_n = (_m = parent.fieldGroupState) == null ? void 0 : _m.children) == null ? void 0 : _n[field.name], scopedCollapsedPaths = (_p = (_o = parent.collapsedPaths) == null ? void 0 : _o.children) == null ? void 0 : _p[field.name], scopedCollapsedFieldSets = (_r = (_q = parent.collapsedFieldSets) == null ? void 0 : _q.children) == null ? void 0 : _r[field.name], readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      }), fieldState = prepareArrayOfPrimitivesInputState({
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });
      return fieldState === null ? null : {
        kind: "field",
        key: `field-${field.name}`,
        name: field.name,
        index,
        inSelectedGroup,
        groups: normalizedFieldGroupNames,
        open: PathUtils.startsWith(fieldPath, parent.openPath),
        // todo: consider support for collapsible arrays
        collapsible: !1,
        collapsed: !1,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    }
  } else {
    const fieldValue = parentValue == null ? void 0 : parentValue[field.name], fieldComparisonValue = isRecord$4(parentComparisonValue) ? parentComparisonValue == null ? void 0 : parentComparisonValue[field.name] : void 0, conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    };
    if (resolveConditionalProperty(field.type.hidden, conditionalPropertyContext))
      return null;
    const readOnly = parent.readOnly || resolveConditionalProperty(field.type.readOnly, conditionalPropertyContext), fieldState = preparePrimitiveInputState({
      ...parent,
      comparisonValue: fieldComparisonValue,
      value: fieldValue,
      schemaType: field.type,
      path: fieldPath,
      readOnly
    });
    return {
      kind: "field",
      key: `field-${field.name}`,
      name: field.name,
      index,
      open: PathUtils.startsWith(fieldPath, parent.openPath),
      inSelectedGroup,
      groups: normalizedFieldGroupNames,
      // todo: consider support for collapsible primitive fields
      collapsible: !1,
      collapsed: !1,
      field: fieldState
    };
  }
}
function prepareObjectInputState(props2, enableHiddenCheck = !0) {
  var _a2;
  if (props2.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    value: props2.value,
    parent: props2.parent,
    document: props2.document,
    currentUser: props2.currentUser
  }, readOnly = props2.readOnly || resolveConditionalProperty(props2.schemaType.readOnly, conditionalPropertyContext), schemaTypeGroupConfig = props2.schemaType.groups || [], defaultGroupName = (_a2 = schemaTypeGroupConfig.find((g) => g.default) || ALL_FIELDS_GROUP) == null ? void 0 : _a2.name, groups = [ALL_FIELDS_GROUP, ...schemaTypeGroupConfig].flatMap((group2) => {
    var _a22;
    const groupHidden = resolveConditionalProperty(group2.hidden, conditionalPropertyContext), isSelected = group2.name === (((_a22 = props2.fieldGroupState) == null ? void 0 : _a22.value) || defaultGroupName), selected = props2.changesOpen ? group2.name === ALL_FIELDS_GROUP.name : isSelected, disabled = props2.changesOpen ? !selected : !1;
    return groupHidden ? [] : [
      {
        disabled,
        icon: group2 == null ? void 0 : group2.icon,
        name: group2.name,
        selected,
        title: group2.title
      }
    ];
  }), selectedGroup = groups.find((group2) => group2.selected), members = (props2.schemaType.fieldsets ? props2.schemaType.fieldsets : props2.schemaType.fields.map((field) => ({ single: !0, field }))).flatMap(
    (fieldSet, index) => {
      var _a22, _b, _c, _d;
      if (fieldSet.single) {
        const field = fieldSet.field, fieldMember = prepareFieldMember({
          field,
          parent: { ...props2, readOnly, groups, selectedGroup },
          index
        });
        return fieldMember ? [fieldMember] : [];
      }
      const fieldsetFieldNames = fieldSet.fields.map((f) => f.name), fieldsetHidden = resolveConditionalProperty(fieldSet.hidden, {
        currentUser: props2.currentUser,
        document: props2.document,
        parent: props2.value,
        value: pick__default.default(props2.value, fieldsetFieldNames)
      }), fieldsetReadOnly = resolveConditionalProperty(fieldSet.readOnly, {
        currentUser: props2.currentUser,
        document: props2.document,
        parent: props2.value,
        value: pick__default.default(props2.value, fieldsetFieldNames)
      }), fieldsetMembers = fieldSet.fields.flatMap(
        (field) => {
          if (fieldsetHidden)
            return [
              {
                kind: "hidden",
                key: `field-${field.name}`,
                name: field.name,
                index
              }
            ];
          const fieldMember = prepareFieldMember({
            field,
            parent: { ...props2, readOnly: readOnly || fieldsetReadOnly, groups, selectedGroup },
            index
          });
          return fieldMember ? [fieldMember] : [];
        }
      ), defaultCollapsedState = getCollapsedWithDefaults(fieldSet.options, props2.level), collapsed = (_c = (_b = (((_a22 = props2.collapsedFieldSets) == null ? void 0 : _a22.children) || {})[fieldSet.name]) == null ? void 0 : _b.value) != null ? _c : defaultCollapsedState.collapsed;
      return [
        {
          kind: "fieldSet",
          key: `fieldset-${fieldSet.name}`,
          _inSelectedGroup: isFieldEnabledByGroupFilter(groups, fieldSet.group, selectedGroup),
          groups: fieldSet.group ? castArray__default.default(fieldSet.group) : [],
          fieldSet: {
            path: PathUtils.pathFor(props2.path.concat(fieldSet.name)),
            name: fieldSet.name,
            title: fieldSet.title,
            description: fieldSet.description,
            hidden: !1,
            level: props2.level + 1,
            members: fieldsetMembers.filter(
              (member) => member.kind !== "hidden"
            ),
            collapsible: defaultCollapsedState == null ? void 0 : defaultCollapsedState.collapsible,
            collapsed,
            columns: (_d = fieldSet == null ? void 0 : fieldSet.options) == null ? void 0 : _d.columns
          }
        }
      ];
    }
  ), hasFieldGroups = schemaTypeGroupConfig.length > 0, filteredPresence = props2.presence.filter((item) => PathUtils.isEqual(item.path, props2.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$t, validation2 = props2.validation.filter((item) => PathUtils.isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), visibleMembers = members.filter(
    (member) => member.kind !== "hidden"
  );
  if (visibleMembers.length === 0 && enableHiddenCheck)
    return null;
  const visibleGroups = hasFieldGroups ? groups.flatMap((group2) => group2.name === ALL_FIELDS_GROUP.name || visibleMembers.some((member) => member.kind === "error" ? !1 : member.kind === "field" ? member.groups.includes(group2.name) : member.groups.includes(group2.name) || member.fieldSet.members.some(
    (fieldsetMember) => fieldsetMember.kind !== "error" && fieldsetMember.groups.includes(group2.name)
  )) ? group2 : []) : [], filtereredMembers = visibleMembers.flatMap(
    (member) => {
      if (member.kind === "error")
        return [member];
      if (member.kind === "field")
        return member.inSelectedGroup ? [member] : [];
      const filteredFieldsetMembers = member.fieldSet.members.filter(
        (fieldsetMember) => fieldsetMember.kind !== "field" || fieldsetMember.inSelectedGroup
      );
      return filteredFieldsetMembers.length > 0 ? [
        {
          ...member,
          fieldSet: { ...member.fieldSet, members: filteredFieldsetMembers }
        }
      ] : [];
    }
  ), node = {
    value: props2.value,
    changed: isChangedValue(props2.value, props2.comparisonValue),
    schemaType: props2.schemaType,
    readOnly,
    path: props2.path,
    id: PathUtils.toString(props2.path),
    level: props2.level,
    focused: PathUtils.isEqual(props2.path, props2.focusPath),
    focusPath: PathUtils.trimChildPath(props2.path, props2.focusPath),
    presence,
    validation: validation2,
    // this is currently needed by getExpandOperations which needs to know about hidden members
    // (e.g. members not matching current group filter) in order to determine what to expand
    members: filtereredMembers,
    groups: visibleGroups
  };
  return Object.defineProperty(node, "_allMembers", {
    value: members,
    enumerable: !1
  }), node;
}
function prepareArrayOfPrimitivesInputState(props2) {
  if (props2.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    comparisonValue: props2.comparisonValue,
    value: props2.value,
    parent: props2.parent,
    document: props2.document,
    currentUser: props2.currentUser
  };
  if (resolveConditionalProperty(props2.schemaType.hidden, conditionalPropertyContext))
    return null;
  const readOnly = props2.readOnly || resolveConditionalProperty(props2.schemaType.readOnly, conditionalPropertyContext), items = Array.isArray(props2.value) ? props2.value : [], filteredPresence = props2.presence.filter((item) => PathUtils.isEqual(item.path, props2.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$t, validation2 = props2.validation.filter((item) => PathUtils.isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), members = items.flatMap(
    (item, index) => prepareArrayOfPrimitivesMember({ arrayItem: item, parent: props2, index })
  );
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props2.changed || members.some((m) => m.kind === "item" && m.item.changed),
    value: props2.value,
    readOnly,
    schemaType: props2.schemaType,
    focused: PathUtils.isEqual(props2.path, props2.focusPath),
    focusPath: PathUtils.trimChildPath(props2.path, props2.focusPath),
    path: props2.path,
    id: PathUtils.toString(props2.path),
    level: props2.level,
    validation: validation2,
    presence,
    members
  };
}
function prepareArrayOfObjectsInputState(props2) {
  if (props2.level === MAX_FIELD_DEPTH)
    return null;
  const conditionalPropertyContext = {
    value: props2.value,
    parent: props2.parent,
    document: props2.document,
    currentUser: props2.currentUser
  };
  if (resolveConditionalProperty(props2.schemaType.hidden, conditionalPropertyContext))
    return null;
  const readOnly = props2.readOnly || resolveConditionalProperty(props2.schemaType.readOnly, conditionalPropertyContext), items = Array.isArray(props2.value) ? props2.value : [], filteredPresence = props2.presence.filter((item) => PathUtils.isEqual(item.path, props2.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$t, validation2 = props2.validation.filter((item) => PathUtils.isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.message, path: v.path })), members = items.flatMap(
    (item, index) => prepareArrayOfObjectsMember({
      arrayItem: item,
      parent: props2,
      index
    })
  );
  return {
    // checks for changes not only on the array itself, but also on any of its items
    changed: props2.changed || members.some((m) => m.kind === "item" && m.item.changed),
    value: props2.value,
    readOnly,
    schemaType: props2.schemaType,
    focused: PathUtils.isEqual(props2.path, props2.focusPath),
    focusPath: PathUtils.trimChildPath(props2.path, props2.focusPath),
    path: props2.path,
    id: PathUtils.toString(props2.path),
    level: props2.level,
    validation: validation2,
    presence,
    members
  };
}
function prepareArrayOfObjectsMember(props2) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const { arrayItem, parent, index } = props2, itemType = getItemType(parent.schemaType, arrayItem), key = arrayItem._key;
  if (!itemType) {
    const itemTypeName = content.resolveTypeName(arrayItem);
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        resolvedValueType: itemTypeName,
        value: arrayItem,
        validTypes: parent.schemaType.of
      }
    };
  }
  const itemPath = PathUtils.pathFor([...parent.path, { _key: key }]), itemLevel = parent.level + 1, conditionalPropertyContext = {
    value: parent.value,
    parent: props2.parent,
    document: parent.document,
    currentUser: parent.currentUser
  }, readOnly = parent.readOnly || resolveConditionalProperty(parent.schemaType.readOnly, conditionalPropertyContext), fieldGroupState = (_b = (_a2 = parent.fieldGroupState) == null ? void 0 : _a2.children) == null ? void 0 : _b[key], scopedCollapsedPaths = (_d = (_c = parent.collapsedPaths) == null ? void 0 : _c.children) == null ? void 0 : _d[key], scopedCollapsedFieldsets = (_f = (_e = parent.collapsedFieldSets) == null ? void 0 : _e.children) == null ? void 0 : _f[key], comparisonValue = Array.isArray(parent.comparisonValue) && parent.comparisonValue.find((i) => i._key === arrayItem._key) || void 0, itemState = prepareObjectInputState(
    {
      schemaType: itemType,
      level: itemLevel,
      document: parent.document,
      value: arrayItem,
      comparisonValue,
      changed: isChangedValue(arrayItem, comparisonValue),
      path: itemPath,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      currentUser: parent.currentUser,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      readOnly
    },
    !1
  ), defaultCollapsedState = getCollapsedWithDefaults(itemType.options, itemLevel), collapsed = (_g = scopedCollapsedPaths == null ? void 0 : scopedCollapsedPaths.value) != null ? _g : defaultCollapsedState.collapsed;
  return {
    kind: "item",
    key,
    index,
    open: PathUtils.startsWith(itemPath, parent.openPath),
    collapsed,
    collapsible: !0,
    parentSchemaType: parent.schemaType,
    item: itemState
  };
}
function prepareArrayOfPrimitivesMember(props2) {
  var _a2, _b;
  const { arrayItem, parent, index } = props2, itemType = getPrimitiveItemType(parent.schemaType, arrayItem), itemPath = PathUtils.pathFor([...parent.path, index]), itemValue = (_a2 = parent.value) == null ? void 0 : _a2[index], itemComparisonValue = (_b = parent.comparisonValue) == null ? void 0 : _b[index], itemLevel = parent.level + 1, key = `${(itemType == null ? void 0 : itemType.name) || "invalid-type"}-${String(index)}`;
  if (!itemType)
    return {
      kind: "error",
      key,
      index,
      error: {
        type: "INVALID_ITEM_TYPE",
        validTypes: parent.schemaType.of,
        resolvedValueType: content.resolveTypeName(itemType),
        value: itemValue
      }
    };
  const readOnly = parent.readOnly || resolveConditionalProperty(itemType.readOnly, {
    value: itemValue,
    parent: parent.value,
    document: parent.document,
    currentUser: parent.currentUser
  }), item = preparePrimitiveInputState({
    ...parent,
    path: itemPath,
    schemaType: itemType,
    level: itemLevel,
    value: itemValue,
    comparisonValue: itemComparisonValue,
    readOnly
  });
  return {
    kind: "item",
    key,
    index,
    parentSchemaType: parent.schemaType,
    open: PathUtils.isEqual(itemPath, parent.openPath),
    item
  };
}
function preparePrimitiveInputState(props2) {
  const filteredPresence = props2.presence.filter((item) => PathUtils.isEqual(item.path, props2.path)), presence = filteredPresence.length ? filteredPresence : EMPTY_ARRAY$t, validation2 = props2.validation.filter((item) => PathUtils.isEqual(item.path, props2.path)).map((v) => ({ level: v.level, message: v.message, path: v.path }));
  return {
    schemaType: props2.schemaType,
    changed: isChangedValue(props2.value, props2.comparisonValue),
    value: props2.value,
    level: props2.level,
    id: PathUtils.toString(props2.path),
    readOnly: props2.readOnly,
    focused: PathUtils.isEqual(props2.path, props2.focusPath),
    path: props2.path,
    presence,
    validation: validation2
  };
}
function prepareFormState(props2) {
  return prepareObjectInputState(props2);
}
function useFormState(schemaType, {
  comparisonValue,
  value,
  fieldGroupState,
  collapsedFieldSets,
  collapsedPaths,
  focusPath,
  openPath,
  presence,
  validation: validation2,
  readOnly,
  changesOpen
}) {
  const currentUser = useCurrentUser(), prev = React.useRef(null);
  return React.useLayoutEffect(() => {
    prev.current = null;
  }, [schemaType]), React.useMemo(() => {
    const next = prepareFormState({
      schemaType,
      document: value,
      fieldGroupState,
      collapsedFieldSets,
      collapsedPaths,
      value,
      comparisonValue,
      focusPath,
      openPath,
      readOnly,
      path: PathUtils.pathFor([]),
      level: 0,
      currentUser,
      presence,
      validation: validation2,
      changesOpen
    }), reconciled = immutableReconcile(prev.current, next);
    return prev.current = reconciled, reconciled;
  }, [
    schemaType,
    value,
    fieldGroupState,
    collapsedFieldSets,
    collapsedPaths,
    comparisonValue,
    focusPath,
    openPath,
    readOnly,
    currentUser,
    presence,
    validation2,
    changesOpen
  ]);
}
function isObjectFormNode(formNode) {
  return types.isObjectSchemaType(formNode.schemaType);
}
function isArrayOfObjectsFormNode(formNode) {
  return types.isArrayOfObjectsSchemaType(formNode.schemaType);
}
function hasAllMembers(value) {
  return "_allMembers" in value && Array.isArray(value._allMembers);
}
function getExpandOperations(node, path) {
  return [
    // make sure to expand all intermediate paths
    ...path.map((p, i) => ({ type: "expandPath", path: path.slice(0, i + 1) })),
    // make sure to expand all fieldsets and selects the groups that includes the intermediate nodes
    ...getFieldsetAndFieldGroupOperations(node, path)
  ];
}
function getFieldsetAndFieldGroupOperations(node, path) {
  return path.length === 0 ? [] : isObjectFormNode(node) && hasAllMembers(node) ? getObjectFieldsetAndFieldGroupOperations(node, path) : isArrayOfObjectsFormNode(node) ? getArrayFieldsetAndFieldGroupOperations(node, path) : [];
}
function getObjectFieldsetAndFieldGroupOperations(node, path) {
  var _a2, _b;
  if (path.length === 0)
    return [];
  const [fieldName, ...tail] = path, fieldsetMember = node._allMembers.find(
    (member) => member.kind === "fieldSet" && member.fieldSet.members.some(
      (field) => field.kind === "field" && field.name === fieldName
    )
  ), fieldMember = (fieldsetMember ? fieldsetMember.fieldSet.members : (
    // Note: we need to use the internal `_allMembers` array here instead of members since hidden/collapsed members are omitted from members
    node._allMembers
  )).find(
    (member) => member !== null && member.kind === "field" && member.name === fieldName
  ), schemaField = node.schemaType.fields.find((field) => field.name === fieldName), selectedGroupName = (_a2 = node.groups.find((group2) => group2.selected)) == null ? void 0 : _a2.name, defaultGroupName = (_b = (node.schemaType.groups || []).find((group2) => group2.default)) == null ? void 0 : _b.name, inSelectedGroup = selectedGroupName && (selectedGroupName === ALL_FIELDS_GROUP.name || schemaField && castArray__default.default(schemaField.group).includes(selectedGroupName)), ops = [];
  return inSelectedGroup || ops.push({
    type: "setSelectedGroup",
    path: node.path,
    groupName: defaultGroupName || ALL_FIELDS_GROUP.name
  }), fieldsetMember && ops.push({ type: "expandFieldSet", path: fieldsetMember.fieldSet.path }), fieldMember && hasAllMembers(fieldMember.field) && (isMemberArrayOfObjects(fieldMember) ? ops.push(...getArrayFieldsetAndFieldGroupOperations(fieldMember.field, tail)) : isMemberObject(fieldMember) && ops.push(...getObjectFieldsetAndFieldGroupOperations(fieldMember.field, tail))), ops;
}
function getArrayFieldsetAndFieldGroupOperations(state, path) {
  if (path.length === 0)
    return [];
  const [segment, ...rest] = path;
  if (!types.isKeySegment(segment))
    throw new Error("Expected path segment to be an object with a _key property");
  const foundMember = state.members.find(
    (member) => member.key === segment._key
  );
  return foundMember ? getFieldsetAndFieldGroupOperations(foundMember.item, rest) : [];
}
const IS_NUMERIC = /^\d+$/;
function unquote(str) {
  return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function splitAttr(segment) {
  const [attr, key] = segment.split("==");
  return { [attr]: unquote(key) };
}
function coerce(segment) {
  return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
function parseGradientPath(focusPathStr) {
  return focusPathStr.split(/[[.\]]/g).filter(Boolean).map((seg) => seg.includes("==") ? splitAttr(seg) : coerce(seg));
}
function encodePath(formBuilderPath) {
  return mutator.arrayToJSONMatchPath(formBuilderPath);
}
function decodePath(gradientPath) {
  return parseGradientPath(gradientPath);
}
function toMutationPatches(patches) {
  return patches.map(toMutationPatch);
}
function fromMutationPatches(origin, patches) {
  return flatten__default.default(patches.map((patch2) => toFormBuilderPatches(origin, patch2)));
}
const notIn = (values2) => (value) => !values2.includes(value);
function toFormBuilderPatches(origin, patch2) {
  return flatten__default.default(
    Object.keys(patch2).filter(notIn(["id", "ifRevisionID", "query"])).map((type) => {
      if (type === "unset")
        return patch2.unset.map((path) => ({
          type: "unset",
          path: decodePath(path),
          origin
        }));
      if (type === "insert") {
        const position = "before" in patch2.insert ? "before" : "after";
        return {
          type: "insert",
          position,
          path: decodePath(patch2.insert[position]),
          items: patch2.insert.items,
          origin
        };
      }
      return Object.keys(patch2[type]).map((gradientPath) => type === "set" ? {
        type: "set",
        path: decodePath(gradientPath),
        value: patch2[type][gradientPath],
        origin
      } : type === "inc" || type === "dec" ? {
        type,
        path: decodePath(gradientPath),
        value: patch2[type][gradientPath],
        origin
      } : type === "setIfMissing" ? {
        type: "setIfMissing",
        path: decodePath(gradientPath),
        value: patch2[type][gradientPath],
        origin
      } : type === "diffMatchPatch" ? {
        type,
        path: decodePath(gradientPath),
        value: patch2[type][gradientPath],
        origin
      } : (console.warn(new Error(`Unsupported patch type: ${type}`)), null)).filter(Boolean);
    })
  );
}
function toMutationPatch(patch2) {
  if (patch2.patchType !== SANITY_PATCH_TYPE && patch2.type)
    throw new Error(
      `Patch is missing "patchType" - import and use "${patch2.type}()" from "sanity/form"`
    );
  if (patch2.patchType !== SANITY_PATCH_TYPE)
    throw new Error(
      'Patch is missing "patchType" - import and use the patch method helpers from "sanity/form"'
    );
  const matchPath = mutator.arrayToJSONMatchPath(patch2.path || []);
  if (patch2.type === "insert") {
    const { position, items } = patch2;
    return {
      insert: {
        [position]: matchPath,
        items
      }
    };
  }
  if (patch2.type === "unset")
    return {
      unset: [matchPath]
    };
  if (!patch2.type)
    throw new Error(`Missing patch type in patch ${JSON.stringify(patch2)}`);
  return matchPath ? {
    [patch2.type]: {
      [matchPath]: patch2.value
    }
  } : {
    [patch2.type]: patch2.value
  };
}
const TransformPatches = React.memo(function(props2) {
  const { transform } = props2, callbacks = useFormCallbacks(), handleChange = React.useCallback(
    (patchEvent) => {
      const patches = patchEvent.patches, transformedPatches = transform(patches);
      callbacks.onChange(PatchEvent.from(transformedPatches));
    },
    [callbacks, transform]
  ), contextValue = React.useMemo(
    () => ({ ...callbacks, onChange: handleChange }),
    [callbacks, handleChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.FormCallbacksContext.Provider, { value: contextValue, children: props2.children });
});
function getSchemaField(schemaType, fieldPath) {
  var _a2;
  const paths = PathUtils__namespace.fromString(fieldPath), firstPath = paths[0];
  if (firstPath && types.isObjectSchemaType(schemaType)) {
    const field = (_a2 = schemaType == null ? void 0 : schemaType.fields) == null ? void 0 : _a2.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = PathUtils__namespace.toString(paths.slice(1));
      return nextPath ? getSchemaField(field.type, nextPath) : field;
    }
  }
}
function findArrayItemIndex(array, pathSegment) {
  if (typeof pathSegment == "number")
    return pathSegment;
  const index = findIndex__default.default(array, pathSegment);
  return index === -1 ? !1 : index;
}
function buildCommentBreadcrumbs(props2) {
  const { currentUser, schemaType, fieldPath, documentValue } = props2, paths = PathUtils__namespace.fromString(fieldPath), fieldPaths = [];
  let currentSchemaType = null;
  return paths.forEach((seg, index) => {
    var _a2, _b, _c, _d, _e;
    const currentPath = paths.slice(0, index + 1), previousPath = paths.slice(0, index), field = getSchemaField(schemaType, PathUtils__namespace.toString(currentPath)), isKeySegment = seg.hasOwnProperty("_key"), parentValue = getValueAtPath(documentValue, previousPath), currentValue = getValueAtPath(documentValue, currentPath), conditionalContext = {
      document: documentValue,
      currentUser,
      parent: parentValue,
      value: currentValue
    };
    if (isKeySegment && Array.isArray(parentValue)) {
      const arrayItemIndex = findArrayItemIndex(parentValue, seg), isNumber = typeof arrayItemIndex == "number";
      fieldPaths.push({
        invalid: arrayItemIndex === !1,
        isArrayItem: !0,
        title: isNumber ? `#${Number(arrayItemIndex) + 1}` : "Unknown array item"
      });
      return;
    }
    if (field != null && field.type) {
      const hidden = resolveConditionalProperty(field.type.hidden, conditionalContext);
      fieldPaths.push({
        invalid: hidden,
        isArrayItem: !1,
        title: getSchemaTypeTitle(field.type)
      }), currentSchemaType = field.type;
      return;
    }
    if (types.isArraySchemaType(currentSchemaType)) {
      const arrayValue = getValueAtPath(documentValue, previousPath), objectType = arrayValue == null ? void 0 : arrayValue._type, objectField = (_a2 = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _a2.find(
        (type) => type.name === objectType
      ), currentField = (_b = objectField == null ? void 0 : objectField.fields) == null ? void 0 : _b.find(
        (f) => f.name === seg
      );
      if (!objectType && currentValue) {
        const allCurrentFields = (_c = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _c.map((o) => o == null ? void 0 : o.fields).filter(Boolean).flat(), anonymousField = allCurrentFields == null ? void 0 : allCurrentFields.find((f) => (f == null ? void 0 : f.name) === seg), hidden = resolveConditionalProperty((_d = anonymousField == null ? void 0 : anonymousField.type) == null ? void 0 : _d.hidden, conditionalContext);
        anonymousField && (fieldPaths.push({
          invalid: hidden,
          isArrayItem: !1,
          title: getSchemaTypeTitle(anonymousField == null ? void 0 : anonymousField.type)
        }), currentSchemaType = anonymousField == null ? void 0 : anonymousField.type);
        return;
      }
      if (!currentField) {
        fieldPaths.push({
          invalid: !0,
          isArrayItem: !1,
          title: "Unknown field"
        });
        return;
      }
      const currentTitle = getSchemaTypeTitle(currentField == null ? void 0 : currentField.type), objectFieldHidden = resolveConditionalProperty(
        (_e = objectField == null ? void 0 : objectField.type) == null ? void 0 : _e.hidden,
        conditionalContext
      ), currentFieldHidden = resolveConditionalProperty(
        currentField == null ? void 0 : currentField.type.hidden,
        conditionalContext
      ), isHidden = objectFieldHidden || currentFieldHidden;
      fieldPaths.push({
        invalid: isHidden,
        isArrayItem: !1,
        title: currentTitle
      }), currentSchemaType = currentField == null ? void 0 : currentField.type;
      return;
    }
    fieldPaths.push({
      invalid: !0,
      isArrayItem: !1,
      title: "Unknown field"
    });
  }), fieldPaths;
}
function useCommentHasChanged(message) {
  const prevMessage = React.useRef(message);
  return React.useMemo(() => !isEqual__default.default(prevMessage.current, message), [message]);
}
function hasCommentMessageValue(value) {
  return value ? value == null ? void 0 : value.some(
    (block) => {
      var _a2;
      return types.isPortableTextTextBlock(block) && ((_a2 = (block == null ? void 0 : block.children) || []) == null ? void 0 : _a2.some((c) => types.isPortableTextSpan(c) ? c.text : c.userId));
    }
  ) : !1;
}
function commentIntentIfDiffers(parent, comment) {
  var _a2, _b;
  const parentIntent = (_a2 = parent == null ? void 0 : parent.context) == null ? void 0 : _a2.intent, intent = (_b = comment == null ? void 0 : comment.context) == null ? void 0 : _b.intent;
  if (intent && (!parentIntent || "preview" in intent.params && "preview" in parentIntent.params && intent.params.preview !== parentIntent.params.preview))
    return intent;
}
function isTextSelectionComment(comment) {
  var _a2, _b, _c, _d, _e, _f;
  return comment ? !!(((_c = (_b = (_a2 = comment == null ? void 0 : comment.target) == null ? void 0 : _a2.path) == null ? void 0 : _b.selection) == null ? void 0 : _c.type) === "text" && (_f = (_e = (_d = comment == null ? void 0 : comment.target) == null ? void 0 : _d.path) == null ? void 0 : _e.selection) != null && _f.value) : !1;
}
const EMPTY_ARRAY$i = [];
function buildCommentThreadItems(props2) {
  const { comments: comments2, currentUser, documentValue, schemaType, type } = props2, parentComments = comments2 == null ? void 0 : comments2.filter((c) => !c.parentCommentId);
  return type === "task" ? parentComments.map((parentComment) => {
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id);
    return {
      commentsCount: [parentComment, ...replies].length,
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue: !1,
      breadcrumbs: EMPTY_ARRAY$i,
      fieldPath: ""
    };
  }) : type === "field" ? parentComments.map((parentComment) => {
    var _a2, _b, _c;
    const crumbs = buildCommentBreadcrumbs({
      currentUser,
      documentValue,
      fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || "",
      schemaType
    });
    let hasTextSelection = !1;
    if (isTextSelectionComment(parentComment) && (hasTextSelection = !!((_b = parentComment.target.path) != null && _b.selection && parentComment.target.path.selection.value.some((v) => v.text))), crumbs.some((bc) => bc.invalid)) return;
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id), commentsCount = [parentComment, ...replies].length, hasReferencedValue = hasTextSelection;
    return {
      breadcrumbs: crumbs,
      commentsCount,
      fieldPath: ((_c = parentComment.target.path) == null ? void 0 : _c.field) || "",
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue
    };
  }).filter(Boolean) : EMPTY_ARRAY$i;
}
const DMP_MARGIN = 15;
function diffText(current, next) {
  const diff2 = diffMatchPatch$1.makeDiff(current, next), diffs = diffMatchPatch$1.cleanupEfficiency(diff2), levenshtein = diffsLevenshtein(diffs);
  return { patches: diffMatchPatch$1.makePatches(current, diffs, { margin: DMP_MARGIN }), levenshtein };
}
function diffApply(current, patches) {
  return diffMatchPatch$1.applyPatches(patches, current, {
    allowExceedingIndices: !0,
    margin: DMP_MARGIN
  })[0];
}
const CHILD_SYMBOL = "\uF0D0";
function toPlainTextWithChildSeparators(inputBlock) {
  return inputBlock.children.map((child) => types.isPortableTextSpan(child) ? child.text.replaceAll(CHILD_SYMBOL, " ") : "").join(CHILD_SYMBOL);
}
const COMMENT_INDICATORS = ["\uF000", "\uF001"], COMMENT_INDICATORS_REGEX = new RegExp(`[${COMMENT_INDICATORS.join("")}]`, "g"), EMPTY_ARRAY$h = [];
function buildRangeDecorationSelectionsFromComments(props2) {
  const { value, comments: comments2 } = props2;
  if (!value || value.length === 0) return EMPTY_ARRAY$h;
  const textSelections = comments2.filter(isTextSelectionComment), decorators = [];
  return textSelections.forEach((comment) => {
    var _a2, _b;
    (_b = (_a2 = comment.target.path) == null ? void 0 : _a2.selection) == null || _b.value.forEach((selectionMember) => {
      const matchedBlock = value.find((block) => block._key === selectionMember._key);
      if (!matchedBlock || !types.isPortableTextTextBlock(matchedBlock))
        return;
      const selectionText = selectionMember.text.replaceAll(COMMENT_INDICATORS_REGEX, ""), textWithChildSeparators = toPlainTextWithChildSeparators(matchedBlock), { patches } = diffText(selectionText, selectionMember.text), diffedText = diffApply(textWithChildSeparators, patches), startIndex = diffedText.indexOf(COMMENT_INDICATORS[0]), endIndex = diffedText.replaceAll(COMMENT_INDICATORS[0], "").indexOf(COMMENT_INDICATORS[1]), textWithoutCommentTags = diffedText.replaceAll(COMMENT_INDICATORS_REGEX, ""), oldCommentedText = selectionMember.text.slice(
        selectionMember.text.indexOf(COMMENT_INDICATORS[0]) + 1,
        selectionMember.text.indexOf(COMMENT_INDICATORS[1])
      ), newCommentedText = textWithoutCommentTags.slice(startIndex, endIndex), { levenshtein } = diffText(newCommentedText, oldCommentedText), threshold = Math.round(newCommentedText.length + oldCommentedText.length / 2);
      let nullSelection = !1;
      if (newCommentedText.length === 0 && (nullSelection = !0), levenshtein > threshold && (nullSelection = !0), startIndex + 1 === endIndex && (nullSelection = !0), startIndex !== -1 && endIndex !== -1) {
        let childIndexAnchor = 0, anchorOffset = 0, childIndexFocus = 0, focusOffset = 0;
        for (let i = 0; i < textWithoutCommentTags.length && (textWithoutCommentTags[i] === CHILD_SYMBOL && (i <= startIndex && (anchorOffset = -1, childIndexAnchor++), focusOffset = -1, childIndexFocus++), i < startIndex && anchorOffset++, i < startIndex + newCommentedText.length && focusOffset++, i !== startIndex + newCommentedText.length); i++)
          ;
        decorators.push({
          selection: {
            anchor: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexAnchor]._key }
              ],
              offset: anchorOffset
            },
            focus: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexFocus]._key }
              ],
              offset: focusOffset
            }
          },
          comment,
          range: { _key: matchedBlock._key, text: nullSelection ? "" : diffedText }
        });
      }
    });
  }), decorators.length === 0 ? EMPTY_ARRAY$h : decorators;
}
function diffsLevenshtein(diffs) {
  let levenshtein = 0, insertions = 0, deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0], data = diffs[x][1];
    switch (op) {
      case diffMatchPatch$1.DIFF_INSERT:
        insertions += data.length;
        break;
      case diffMatchPatch$1.DIFF_DELETE:
        deletions += data.length;
        break;
      case diffMatchPatch$1.DIFF_EQUAL:
        levenshtein += Math.max(insertions, deletions), insertions = 0, deletions = 0;
        break;
    }
  }
  return levenshtein += Math.max(insertions, deletions), levenshtein;
}
const CommentRangeDecoration = React.memo(function(props2) {
  const {
    children,
    commentId,
    currentHoveredCommentId,
    onClick,
    onHoverEnd,
    onHoverStart,
    selectedThreadId,
    threadId
  } = props2, decoratorRef = React.useRef(null), isNestedRef = React.useRef(!1), parentCommentId = React.useRef(null);
  React.useEffect(() => {
    var _a2, _b;
    const prevEl = (_a2 = decoratorRef.current) == null ? void 0 : _a2.previousSibling, nextEl = (_b = decoratorRef.current) == null ? void 0 : _b.nextSibling;
    if (!prevEl || !nextEl) {
      isNestedRef.current = !1;
      return;
    }
    const [key] = Object.keys(applyInlineCommentIdAttr("")), prevId = prevEl.getAttribute(key), nextId = nextEl.getAttribute(key), isNestedDecorator = !!(prevId && nextId && prevId === nextId);
    parentCommentId.current = isNestedDecorator ? prevId : null, isNestedRef.current = isNestedDecorator;
  }, []);
  const handleMouseEnter = React.useCallback(() => onHoverStart(commentId), [commentId, onHoverStart]), handleMouseLeave = React.useCallback(() => onHoverEnd(null), [onHoverEnd]), handleClick = React.useCallback(() => onClick(commentId), [commentId, onClick]), hovered = currentHoveredCommentId === commentId || currentHoveredCommentId === parentCommentId.current && isNestedRef.current;
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommentInlineHighlightSpan,
    {
      isAdded: !0,
      isHovered: hovered || selectedThreadId === threadId,
      isNested: isNestedRef.current,
      onClick: handleClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      ref: decoratorRef,
      ...applyInlineCommentIdAttr(threadId),
      children
    }
  );
});
function buildRangeDecorations(props2) {
  const {
    comments: comments2,
    currentHoveredCommentId,
    onDecorationClick,
    onDecorationHoverEnd,
    onDecorationHoverStart,
    onDecorationMoved,
    selectedThreadId,
    value
  } = props2;
  return buildRangeDecorationSelectionsFromComments({ comments: comments2, value }).map(({ selection, comment, range: range2 }) => ({
    component: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(
      CommentRangeDecoration,
      {
        commentId: comment._id,
        currentHoveredCommentId,
        onClick: onDecorationClick,
        onHoverEnd: onDecorationHoverEnd,
        onHoverStart: onDecorationHoverStart,
        selectedThreadId,
        threadId: comment.threadId,
        children
      }
    ),
    onMoved: onDecorationMoved,
    selection,
    payload: {
      commentId: comment._id,
      range: range2
    }
  }));
}
function buildTextSelectionFromFragment(props2) {
  const { fragment, value, selection } = props2;
  if (!selection)
    throw new Error("Selection is required");
  const normalizedSelection = selection.backward ? { backward: !1, anchor: selection.focus, focus: selection.anchor } : selection;
  return {
    type: "text",
    value: fragment.map((fragmentBlock) => {
      const originalBlock = value.find((b) => b._key === fragmentBlock._key);
      if (!types.isPortableTextTextBlock(originalBlock))
        return {
          _key: fragmentBlock._key,
          text: ""
        };
      const anchorBlockKey = types.isKeySegment(normalizedSelection.anchor.path[0]) && normalizedSelection.anchor.path[0]._key, focusBlockKey = types.isKeySegment(normalizedSelection.focus.path[0]) && normalizedSelection.focus.path[0]._key, fragmentBlockText = react$1.toPlainText([fragmentBlock]), fragmentStartSpan = types.isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[0] : void 0, fragmentEndSpan = types.isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[fragmentBlock.children.length - 1] : void 0;
      let originalTextBeforeSelection = "", startChildIndex = -1;
      if (anchorBlockKey === originalBlock._key)
        for (const child of originalBlock.children) {
          if (startChildIndex++, child._key === (fragmentStartSpan == null ? void 0 : fragmentStartSpan._key)) {
            originalTextBeforeSelection += types.isPortableTextSpan(child) && child.text.slice(0, Math.max(0, normalizedSelection.anchor.offset)) || "";
            break;
          }
          originalTextBeforeSelection += child.text;
        }
      let originalTextAfterSelection = "";
      if (focusBlockKey === originalBlock._key)
        for (const child of originalBlock.children.slice(startChildIndex).reverse()) {
          if (child._key === (fragmentEndSpan == null ? void 0 : fragmentEndSpan._key)) {
            originalTextAfterSelection = (types.isPortableTextSpan(child) && child.text.slice(normalizedSelection.focus.offset, child.text.length) || "") + originalTextAfterSelection;
            break;
          }
          originalTextAfterSelection = child.text + originalTextAfterSelection;
        }
      return {
        _key: originalBlock._key,
        text: `${originalTextBeforeSelection}${COMMENT_INDICATORS[0]}${fragmentBlockText}${COMMENT_INDICATORS[1]}${originalTextAfterSelection}`
      };
    })
  };
}
function mergeCommentReactions(reactionsA, reactionsB) {
  const mergedReactions = {};
  for (const reaction of reactionsA)
    mergedReactions[reaction._key] = { ...reaction };
  for (const reaction of reactionsB)
    mergedReactions[reaction._key] = { ...mergedReactions[reaction._key], ...reaction };
  return Object.values(mergedReactions);
}
function weakenReferences(node) {
  if (node && typeof node == "object" && node.hasOwnProperty("_ref"))
    return { ...node, _weak: !0 };
  if (Array.isArray(node))
    return node.map((item) => weakenReferences(item));
  if (node && typeof node == "object") {
    const result = {};
    return Object.keys(node).forEach((key) => {
      const value = node[key];
      typeof value == "object" && value !== null ? result[key] = weakenReferences(value) : result[key] = value;
    }), result;
  }
  return node;
}
function weakenReferencesInContentSnapshot(snapshot) {
  return weakenReferences(snapshot);
}
async function createOperation(props2) {
  const {
    activeTool,
    client: client2,
    comment,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getIntent,
    getNotificationValue,
    getThreadLength,
    onCreate,
    onCreateError,
    projectId,
    createAddonDataset,
    workspace
  } = props2, commentId = (comment == null ? void 0 : comment.id) || uuid.uuid(), authorId = currentUser.id, currentThreadLength = ((getThreadLength == null ? void 0 : getThreadLength(comment.threadId)) || 0) + 1;
  let nextComment;
  if (comment.type === "task" && (nextComment = {
    _id: commentId,
    _type: "comment",
    authorId,
    message: comment.message,
    lastEditedAt: void 0,
    parentCommentId: comment.parentCommentId,
    status: comment.status,
    threadId: comment.threadId,
    reactions: comment.reactions,
    context: {
      payload: {
        workspace
      },
      notification: comment.context.notification,
      tool: (activeTool == null ? void 0 : activeTool.name) || ""
    },
    target: {
      document: {
        _ref: documentId,
        _type: "reference",
        _weak: !0
      },
      documentType
    }
  }), comment.type === "field") {
    const {
      documentTitle = "",
      url = "",
      workspaceTitle = ""
    } = getNotificationValue({ commentId }) || {}, notification = {
      currentThreadLength,
      documentTitle,
      url,
      workspaceTitle
    }, intent = getIntent == null ? void 0 : getIntent({ id: documentId, type: documentType, path: comment.fieldPath }), contentSnapshot = weakenReferencesInContentSnapshot(comment.contentSnapshot);
    nextComment = {
      _id: commentId,
      _type: "comment",
      authorId,
      message: comment.message,
      lastEditedAt: void 0,
      parentCommentId: comment.parentCommentId,
      status: comment.status,
      threadId: comment.threadId,
      reactions: comment.reactions,
      context: {
        payload: {
          workspace
        },
        intent,
        notification,
        tool: (activeTool == null ? void 0 : activeTool.name) || ""
      },
      contentSnapshot,
      target: {
        documentRevisionId: documentRevisionId || "",
        path: {
          field: comment.fieldPath,
          selection: comment.selection
        },
        document: {
          _dataset: dataset,
          _projectId: projectId,
          _ref: documentId,
          _type: "crossDatasetReference",
          _weak: !0
        },
        documentType
      }
    };
  }
  if (nextComment) {
    if (onCreate == null || onCreate(nextComment), !client2) {
      try {
        const newAddonClient = await createAddonDataset();
        if (!newAddonClient)
          throw new Error("Failed to create addon dataset client");
        await newAddonClient.create(nextComment);
      } catch (err) {
        throw onCreateError == null || onCreateError(nextComment._id, err), err;
      }
      return;
    }
    try {
      await client2.create(nextComment);
    } catch (err) {
      throw onCreateError == null || onCreateError(nextComment._id, err), err;
    }
  }
}
function createReactionKey(userId, shortName) {
  return `${userId}-${shortName}`;
}
async function reactOperation(props2) {
  var _a2;
  const { client: client2, currentUser, id: id2, reaction, getComment, onUpdate } = props2, reactions = ((_a2 = getComment == null ? void 0 : getComment(id2)) == null ? void 0 : _a2.reactions) || [], currentUserReactions = reactions.filter((r) => r.userId === currentUser.id), _key = createReactionKey(currentUser.id, reaction.shortName), currentReaction = currentUserReactions.find(
    (r) => r._key === _key && r._optimisticState !== "removed"
  );
  if (currentReaction) {
    const next = reactions.map((r) => r._key === currentReaction._key ? { ...r, _optimisticState: "removed" } : r);
    onUpdate == null || onUpdate(id2, { reactions: next }), await client2.patch(id2).unset([`reactions[_key=="${_key}"]`]).commit();
    return;
  }
  if (!currentReaction) {
    const reactionItem = {
      _key,
      addedAt: (/* @__PURE__ */ new Date()).toISOString(),
      shortName: reaction.shortName,
      userId: currentUser.id
    }, optimisticReactionItem = { ...reactionItem, _optimisticState: "added" }, next = reactions.concat(optimisticReactionItem).filter((r) => !(r._key === reactionItem._key && r._optimisticState === "removed"));
    onUpdate == null || onUpdate(id2, { reactions: next }), await client2.patch(id2).setIfMissing({ reactions: [] }).append("reactions", [reactionItem]).commit();
  }
}
async function removeOperation(props2) {
  const { client: client2, id: id2, onRemove } = props2;
  onRemove == null || onRemove(id2), await Promise.all([
    client2.delete({ query: `*[_type == "comment" && parentCommentId == "${id2}"]` }),
    client2.delete(id2)
  ]);
}
const THROTTLE_TIME_MS = 1e3, THROTTLE_SETTINGS = {
  trailing: !0,
  leading: !1
}, throttleFunctionsMap = /* @__PURE__ */ new Map();
function getThrottledFunction(id2) {
  if (!throttleFunctionsMap.has(id2)) {
    const throttledFunction = throttle__default.default(postCommentUpdate, THROTTLE_TIME_MS, THROTTLE_SETTINGS);
    return throttleFunctionsMap.set(id2, throttledFunction), throttledFunction;
  }
  return throttleFunctionsMap.get(id2);
}
async function postCommentUpdate(props2) {
  const { client: client2, id: id2, comment, transactionId: transactionIdProp, onUpdate } = props2, transactionId = transactionIdProp || uuid.uuid(), patch2 = client2 == null ? void 0 : client2.patch(id2).set(comment), transaction = client2.transaction().transactionId(transactionId).patch(patch2);
  onUpdate == null || onUpdate(id2, comment), comment.status ? (await transaction.commit(), await client2.patch({ query: `*[_type == "comment" && parentCommentId == "${id2}"]` }).set({
    status: comment.status
  }).commit()) : await transaction.commit(), throttleFunctionsMap.delete(id2);
}
async function updateOperation(props2) {
  const { id: id2, comment, throttled: throttledProp } = props2, hasEditedMessage = "message" in comment, editedComment = {
    ...comment,
    lastEditedAt: (/* @__PURE__ */ new Date()).toISOString()
  }, nextComment = hasEditedMessage ? editedComment : comment;
  if (!throttledProp) {
    await postCommentUpdate({
      ...props2,
      comment: nextComment
    });
    return;
  }
  await getThrottledFunction(id2)({
    ...props2,
    comment: nextComment
  });
}
function useCommentOperations(opts) {
  const {
    client: client2,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getComment,
    getThreadLength,
    onCreate,
    onCreateError,
    onRemove,
    onTransactionStart,
    onUpdate,
    projectId,
    createAddonDataset,
    workspace,
    getCommentLink
  } = opts, getIntent = useCommentsIntent(), activeToolName = router.useRouterState(
    React.useCallback(
      (routerState) => typeof routerState.tool == "string" ? routerState.tool : void 0,
      []
    )
  ), tools = useTools(), activeTool = React.useMemo(
    () => tools.find((tool) => tool.name === activeToolName),
    [activeToolName, tools]
  ), { getNotificationValue } = useNotificationTarget({ documentId, documentType, getCommentLink }), handleCreate = React.useCallback(
    async (comment) => {
      currentUser != null && currentUser.id && await createOperation({
        activeTool,
        client: client2,
        comment,
        currentUser,
        dataset,
        documentId,
        documentRevisionId,
        documentType,
        getIntent,
        getNotificationValue,
        getThreadLength,
        onCreate,
        onCreateError,
        projectId,
        createAddonDataset,
        workspace
      });
    },
    [
      activeTool,
      client2,
      currentUser,
      dataset,
      documentId,
      documentRevisionId,
      documentType,
      getIntent,
      getNotificationValue,
      getThreadLength,
      onCreate,
      onCreateError,
      projectId,
      createAddonDataset,
      workspace
    ]
  ), handleRemove = React.useCallback(
    async (id2) => {
      client2 && await removeOperation({
        client: client2,
        id: id2,
        onRemove
      });
    },
    [client2, onRemove]
  ), handleUpdate = React.useCallback(
    async (id2, comment, updateOpts) => {
      if (!client2) return;
      const { throttled } = updateOpts || {}, nextTransactionId = uuid.uuid();
      onTransactionStart(id2, nextTransactionId), await updateOperation({
        client: client2,
        comment,
        throttled,
        id: id2,
        onUpdate,
        transactionId: nextTransactionId
      });
    },
    [client2, onTransactionStart, onUpdate]
  ), handleReact = React.useCallback(
    async (id2, reaction) => {
      !client2 || !(currentUser != null && currentUser.id) || await reactOperation({
        client: client2,
        currentUser,
        id: id2,
        reaction,
        getComment,
        onUpdate
      });
    },
    [client2, currentUser, getComment, onUpdate]
  );
  return React.useMemo(
    () => ({
      operation: {
        create: handleCreate,
        react: handleReact,
        remove: handleRemove,
        update: handleUpdate
      }
    }),
    [handleCreate, handleRemove, handleUpdate, handleReact]
  );
}
function useComments() {
  const value = React.useContext(_singletons.CommentsContext);
  if (!value)
    throw new Error("useComments must be used within a CommentsProvider");
  return value;
}
function useCommentsAuthoringPath() {
  const value = React.useContext(_singletons.CommentsAuthoringPathContext);
  if (!value)
    throw new Error("useCommentsAuthoringPath: missing context value");
  return value;
}
function useCommentsEnabled() {
  return React.useContext(_singletons.CommentsEnabledContext);
}
function useCommentsOnboarding() {
  const ctx = React.useContext(_singletons.CommentsOnboardingContext);
  if (!ctx)
    throw new Error("useCommentsOnboarding: missing context value");
  return ctx;
}
const BASE_SCROLL_OPTIONS = {
  behavior: "smooth",
  inline: "center",
  scrollMode: "if-needed"
}, GROUP_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "start"
}, INLINE_COMMENT_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_TO_FIELD_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_TO_COMMENT_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_OPTIONS_BY_TYPE = {
  comment: SCROLL_TO_COMMENT_OPTIONS,
  field: SCROLL_TO_FIELD_OPTIONS,
  group: GROUP_SCROLL_OPTIONS,
  "inline-comment": INLINE_COMMENT_SCROLL_OPTIONS
};
function generateValidAttrValue(id2) {
  const symbolsToRemove = /[[\]_"_=.]/g;
  return id2.replace(symbolsToRemove, "");
}
function applyCommentIdAttr(id2) {
  return {
    "data-comments-comment-id": generateValidAttrValue(id2)
  };
}
function applyCommentsFieldAttr(id2) {
  return {
    "data-comments-field-id": generateValidAttrValue(id2)
  };
}
function applyCommentsGroupAttr(id2) {
  return {
    "data-comments-group-id": generateValidAttrValue(id2)
  };
}
function applyInlineCommentIdAttr(id2) {
  return {
    "data-comments-inline-comment-id": generateValidAttrValue(id2)
  };
}
function useCommentsScroll(opts) {
  const { boundaryElement } = opts || {}, [scrollTarget, setScrollTarget] = React.useState(null), scrollOpts = React.useMemo(() => ({
    ...SCROLL_OPTIONS_BY_TYPE[(scrollTarget == null ? void 0 : scrollTarget.type) || "comment"],
    boundary: boundaryElement
  }), [boundaryElement, scrollTarget == null ? void 0 : scrollTarget.type]), handleScrollToComment = React.useCallback((commentId) => {
    setScrollTarget({ type: "comment", id: commentId });
  }, []), handleScrollToGroup = React.useCallback((threadId) => {
    setScrollTarget({ type: "group", id: threadId });
  }, []), handleScrollToField = React.useCallback((fieldPath) => {
    setScrollTarget({ type: "field", id: fieldPath });
  }, []), handleScrollToInlineComment = React.useCallback((commentId) => {
    setScrollTarget({ type: "inline-comment", id: commentId });
  }, []);
  return React.useEffect(() => {
    const raf2 = requestAnimationFrame(() => {
      if (!scrollTarget) return;
      const { type, id: id2 } = scrollTarget, element = document == null ? void 0 : document.querySelector(
        `[data-comments-${type}-id="${generateValidAttrValue(id2)}"]`
      );
      element && scrollIntoView__default.default(element, scrollOpts);
    });
    return () => {
      cancelAnimationFrame(raf2);
    };
  }, [scrollOpts, scrollTarget]), React.useMemo(
    () => ({
      scrollToComment: handleScrollToComment,
      scrollToField: handleScrollToField,
      scrollToGroup: handleScrollToGroup,
      scrollToInlineComment: handleScrollToInlineComment
    }),
    [handleScrollToComment, handleScrollToField, handleScrollToGroup, handleScrollToInlineComment]
  );
}
function useCommentsSelectedPath() {
  const ctx = React.useContext(_singletons.CommentsSelectedPathContext);
  if (!ctx)
    throw new Error("useCommentsSelectedPath: missing context value");
  return ctx;
}
const CommentLinkCopied = telemetry.defineEvent({
  name: "Comment Link Copied",
  version: 1,
  description: "The link to a comment is copied"
}), CommentViewedFromLink = telemetry.defineEvent({
  name: "Comment Viewed From Link",
  version: 1,
  description: "A comment is viewed from a link"
}), CommentListViewChanged = telemetry.defineEvent({
  name: "Comment List View Changed",
  version: 1,
  description: "The view of the comment list is changed"
});
function useCommentsTelemetry() {
  const telemetry2 = react.useTelemetry(), commentLinkCopied = React.useCallback(() => {
    telemetry2.log(CommentLinkCopied);
  }, [telemetry2]), commentViewedFromLink = React.useCallback(() => {
    telemetry2.log(CommentViewedFromLink);
  }, [telemetry2]), commentListViewChanged = React.useCallback(
    (view) => {
      telemetry2.log(CommentListViewChanged, { view });
    },
    [telemetry2]
  );
  return React.useMemo(
    () => ({
      commentLinkCopied,
      commentListViewChanged,
      commentViewedFromLink
    }),
    [commentLinkCopied, commentListViewChanged, commentViewedFromLink]
  );
}
function useCommentsUpsell() {
  return React.useContext(_singletons.CommentsUpsellContext) || {
    upsellData: null,
    handleOpenDialog: () => null,
    upsellDialogOpen: !1,
    telemetryLogs: {
      dialogSecondaryClicked: () => null,
      dialogPrimaryClicked: () => null,
      panelViewed: () => null,
      panelDismissed: () => null,
      panelPrimaryClicked: () => null,
      panelSecondaryClicked: () => null
    }
  };
}
function useResolveCommentsEnabled(documentId, documentType) {
  const { enabled: featureEnabled, isLoading, error } = useFeatureEnabled("studioComments"), { enabled } = useSource().document.comments, enabledFromConfig = React.useMemo(
    () => enabled({ documentType, documentId: getPublishedId(documentId) }),
    [documentId, documentType, enabled]
  );
  return React.useMemo(() => isLoading || !enabledFromConfig || error ? { enabled: !1, mode: null } : {
    enabled: !0,
    mode: featureEnabled ? "default" : "upsell"
  }, [isLoading, enabledFromConfig, error, featureEnabled]);
}
function createCommentsSet(comments2) {
  return comments2.reduce((acc, comment) => ({ ...acc, [comment._id]: comment }), {});
}
function commentsReducer(state, action) {
  var _a2;
  switch (action.type) {
    case "COMMENTS_SET": {
      const commentsById = createCommentsSet(action.comments);
      return {
        ...state,
        comments: commentsById
      };
    }
    case "COMMENT_ADDED": {
      const nextCommentResult = action.payload, nextCommentValue = nextCommentResult, nextComment = {
        [nextCommentResult._id]: {
          ...state.comments[nextCommentResult._id],
          ...nextCommentValue,
          _state: nextCommentResult._state || void 0,
          // If the comment is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the comments correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the comment.
          // Once the comment is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextCommentResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state,
        comments: {
          ...state.comments,
          ...nextComment
        }
      };
    }
    case "COMMENT_RECEIVED": {
      const nextCommentResult = action.payload;
      return {
        ...state,
        comments: {
          ...state.comments,
          [nextCommentResult._id]: nextCommentResult
        }
      };
    }
    case "COMMENT_DELETED": {
      const { [action.id]: _, ...restComments } = state.comments;
      return Object.keys(restComments).forEach((commentId) => {
        restComments[commentId].parentCommentId === action.id && delete restComments[commentId];
      }), {
        ...state,
        comments: restComments
      };
    }
    case "COMMENT_UPDATED": {
      const updatedComment = action.payload, id2 = updatedComment._id, comment = state.comments[id2], optimisticReactions = ((_a2 = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a2.filter((v) => v == null ? void 0 : v._optimisticState)) || [], incomingReactions = updatedComment.reactions || [], nextReactions = mergeCommentReactions(optimisticReactions, incomingReactions), nextComment = {
        // Add existing comment data
        ...comment,
        // Add incoming comment data
        ...updatedComment,
        // Add reactions merged with optimistic reactions
        reactions: nextReactions
      };
      return {
        ...state,
        comments: {
          ...state.comments,
          [id2]: nextComment
        }
      };
    }
    default:
      return state;
  }
}
const INITIAL_STATE$2 = {
  comments: {}
}, LISTEN_OPTIONS$1 = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query"
}, SORT_FIELD$1 = "_createdAt", SORT_ORDER$1 = "desc", QUERY_FILTERS$1 = ['_type == "comment"', "target.document._ref == $documentId"], QUERY_PROJECTION$1 = `{
  _createdAt,
  _id,
  authorId,
  contentSnapshot,
  context,
  lastEditedAt,
  message,
  parentCommentId,
  reactions,
  status,
  target,
  threadId
}`, QUERY_SORT_ORDER$1 = `order(${SORT_FIELD$1} ${SORT_ORDER$1})`, QUERY$1 = `*[${QUERY_FILTERS$1.join(" && ")}] ${QUERY_PROJECTION$1} | ${QUERY_SORT_ORDER$1}`;
function useCommentsStore(opts) {
  const { client: client2, documentId, onLatestTransactionIdReceived, transactionsIdMap } = opts, [state, dispatch] = React.useReducer(commentsReducer, INITIAL_STATE$2), [loading, setLoading] = React.useState(client2 !== null), [error, setError] = React.useState(null), didInitialFetch = React.useRef(!1), params = React.useMemo(() => ({ documentId: getPublishedId(documentId) }), [documentId]), initialFetch = React.useCallback(async () => {
    if (!client2) {
      setLoading(!1);
      return;
    }
    try {
      const res = await client2.fetch(QUERY$1, params);
      dispatch({ type: "COMMENTS_SET", comments: res }), setLoading(!1);
    } catch (err) {
      setError(err);
    }
  }, [client2, params]), handleListenerEvent = React.useCallback(
    async (event) => {
      var _a2;
      if (event.type === "welcome" && !didInitialFetch.current && (setLoading(!0), await initialFetch(), setLoading(!1), didInitialFetch.current = !0), event.type === "reconnect" && (setLoading(!0), didInitialFetch.current = !1), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextComment = event.result;
          nextComment && dispatch({
            type: "COMMENT_RECEIVED",
            payload: nextComment
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "COMMENT_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedComment = event.result, id2 = ((_a2 = event.result) == null ? void 0 : _a2._id) || "", transactionId = event.transactionId, latestTransactionId = transactionsIdMap.get(id2), isLatestTransaction = transactionId === latestTransactionId;
          if (!isLatestTransaction && latestTransactionId) return;
          updatedComment && (dispatch({
            type: "COMMENT_UPDATED",
            payload: updatedComment
          }), isLatestTransaction && onLatestTransactionIdReceived(id2));
        }
      }
    },
    [initialFetch, onLatestTransactionIdReceived, transactionsIdMap]
  ), listener$ = React.useMemo(() => client2 ? client2.observable.listen(QUERY$1, params, LISTEN_OPTIONS$1).pipe(
    rxjs.catchError((err) => (setError(err), rxjs.of(err)))
  ) : rxjs.of(), [client2, params]);
  return React.useEffect(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: React.useMemo(() => Object.values(state.comments), [state.comments]),
    dispatch,
    error,
    loading
  };
}
const EMPTY_ARRAY$g = [], EMPTY_COMMENTS_DATA = {
  open: EMPTY_ARRAY$g,
  resolved: EMPTY_ARRAY$g
}, CommentsProvider = React.memo(function(props2) {
  const {
    children,
    documentId,
    documentType,
    isCommentsOpen,
    onCommentsOpen,
    sortOrder,
    type,
    getCommentLink,
    onClearSelectedComment,
    selectedCommentId,
    isConnecting,
    onPathOpen
  } = props2, commentsEnabled = useCommentsEnabled(), [status, setStatus] = React.useState("open"), { client: client2, createAddonDataset, isCreatingDataset } = useAddonDataset(), publishedId = getPublishedId(documentId), editState2 = useEditState(publishedId, documentType, "low"), schemaType = useSchema().get(documentType), currentUser = useCurrentUser(), { name: workspaceName, dataset, projectId } = useWorkspace(), documentValue = React.useMemo(() => editState2.draft || editState2.published, [editState2.draft, editState2.published]), documentRevisionId = React.useMemo(() => documentValue == null ? void 0 : documentValue._rev, [documentValue]), transactionsIdMap = React.useMemo(() => /* @__PURE__ */ new Map(), []), handleOnLatestTransactionIdReceived = React.useCallback(
    (commentDocumentId) => {
      transactionsIdMap.delete(commentDocumentId);
    },
    [transactionsIdMap]
  ), {
    dispatch,
    data = EMPTY_ARRAY$g,
    error,
    loading
  } = useCommentsStore({
    documentId: publishedId,
    client: client2,
    transactionsIdMap,
    onLatestTransactionIdReceived: handleOnLatestTransactionIdReceived
  }), handleOnTransactionStart = React.useCallback(
    (commentDocumentId, transactionId) => {
      transactionsIdMap.set(commentDocumentId, transactionId);
    },
    [transactionsIdMap]
  ), handleSetStatus = React.useCallback(
    (newStatus) => commentsEnabled.mode === "upsell" && newStatus === "resolved" ? null : setStatus(newStatus),
    [setStatus, commentsEnabled]
  ), mentionOptions = useUserListWithPermissions(
    React.useMemo(() => ({ documentValue, permission: "read" }), [documentValue])
  ), threadItemsByStatus = React.useMemo(() => {
    if (!schemaType || !currentUser) return EMPTY_COMMENTS_DATA;
    const sorted = orderBy__default.default(data, ["_createdAt"], [sortOrder]), items = buildCommentThreadItems({
      comments: sorted,
      currentUser,
      documentValue,
      schemaType,
      type
    });
    return {
      open: items.filter((item) => item.parentComment.status === "open"),
      resolved: items.filter((item) => item.parentComment.status === "resolved")
    };
  }, [currentUser, data, documentValue, schemaType, sortOrder, type]), getThreadLength = React.useCallback(
    (threadId) => threadItemsByStatus.open.filter((item) => item.threadId === threadId).length,
    [threadItemsByStatus.open]
  ), getComment = React.useCallback((id2) => data == null ? void 0 : data.find((c) => c._id === id2), [data]), handleOnCreate = React.useCallback(
    (payload) => {
      var _a2, _b;
      const hasError = ((_b = (_a2 = data == null ? void 0 : data.find((c) => c._id === payload._id)) == null ? void 0 : _a2._state) == null ? void 0 : _b.type) === "createError";
      dispatch({
        type: "COMMENT_ADDED",
        payload: {
          ...payload,
          _state: hasError ? { type: "createRetrying" } : void 0
        }
      });
    },
    [data, dispatch]
  ), handleOnUpdate = React.useCallback(
    (id2, payload) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id2,
          ...payload
        }
      });
    },
    [dispatch]
  ), handleOnCreateError = React.useCallback(
    (id2, err) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id2,
          _state: {
            error: err,
            type: "createError"
          }
        }
      });
    },
    [dispatch]
  ), { operation } = useCommentOperations(
    React.useMemo(
      () => ({
        client: client2,
        currentUser,
        dataset,
        documentId: publishedId,
        documentRevisionId,
        documentType,
        getComment,
        getThreadLength,
        projectId,
        schemaType,
        workspace: workspaceName,
        // This function runs when the first comment creation is executed.
        // It is used to create the addon dataset and configure a client for
        // the addon dataset.
        createAddonDataset,
        // The following callbacks runs when the comment operation are executed.
        // They are used to update the local state of the comments immediately after
        // a comment operation has been executed. This is done to avoid waiting for
        // the real time listener to update the comments and make the UI feel more
        // responsive. The comment will be updated again when we receive an mutation
        // event from the real time listener.
        onCreate: handleOnCreate,
        onCreateError: handleOnCreateError,
        onUpdate: handleOnUpdate,
        onTransactionStart: handleOnTransactionStart,
        getCommentLink
      }),
      [
        client2,
        currentUser,
        dataset,
        publishedId,
        documentRevisionId,
        documentType,
        getComment,
        getThreadLength,
        projectId,
        schemaType,
        workspaceName,
        createAddonDataset,
        handleOnCreate,
        handleOnCreateError,
        handleOnUpdate,
        handleOnTransactionStart,
        getCommentLink
      ]
    )
  ), ctxValue = React.useMemo(
    () => ({
      documentId,
      documentType,
      isCreatingDataset,
      status,
      setStatus: handleSetStatus,
      getComment,
      getCommentLink,
      onClearSelectedComment,
      selectedCommentId,
      isCommentsOpen,
      onCommentsOpen,
      isConnecting,
      onPathOpen,
      comments: {
        data: threadItemsByStatus,
        error,
        loading: loading || isCreatingDataset || isConnecting || !1
      },
      operation: {
        create: operation.create,
        react: operation.react,
        remove: operation.remove,
        update: operation.update
      },
      mentionOptions
    }),
    [
      documentId,
      documentType,
      isCreatingDataset,
      status,
      handleSetStatus,
      getComment,
      getCommentLink,
      onClearSelectedComment,
      selectedCommentId,
      isCommentsOpen,
      onCommentsOpen,
      isConnecting,
      onPathOpen,
      threadItemsByStatus,
      error,
      loading,
      operation.create,
      operation.react,
      operation.remove,
      operation.update,
      mentionOptions
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.CommentsContext.Provider, { value: ctxValue, children });
}), CommentsEnabledProvider = React.memo(function(props2) {
  const { children, documentId, documentType } = props2, value = useResolveCommentsEnabled(documentId, documentType);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.CommentsEnabledContext.Provider, { value, children });
}), CommentsIntentProvider = React.memo(function(props2) {
  const { children, getIntent } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.CommentsIntentContext.Provider, { value: getIntent, children });
}), VERSION = 1, LOCAL_STORAGE_KEY$1 = `sanityStudio:comments:inspector:onboarding:dismissed:v${VERSION}`, setLocalStorage = (value) => {
  try {
    window.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(value));
  } catch {
  }
}, getLocalStorage = () => {
  try {
    const value = window.localStorage.getItem(LOCAL_STORAGE_KEY$1);
    return value ? JSON.parse(value) : !1;
  } catch {
    return !1;
  }
};
function CommentsOnboardingProvider(props2) {
  const { children } = props2, [dismissed, setDismissed] = React.useState(getLocalStorage()), handleDismiss = React.useCallback(() => {
    setDismissed(!0), setLocalStorage(!0);
  }, [setDismissed]), ctxValue = React.useMemo(
    () => ({
      setDismissed: handleDismiss,
      isDismissed: dismissed
    }),
    [handleDismiss, dismissed]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.CommentsOnboardingContext.Provider, { value: ctxValue, children });
}
const CommentsSelectedPathProvider = React.memo(function(props2) {
  const { children } = props2, [selectedPath, setSelectedPath] = React.useState(null), handleSelectPath = React.useCallback(
    (nextPath) => {
      isEqual__default.default(selectedPath, nextPath) || setSelectedPath(nextPath);
    },
    [selectedPath]
  ), ctxValue = React.useMemo(
    () => ({
      selectedPath,
      setSelectedPath: handleSelectPath
    }),
    [selectedPath, handleSelectPath]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.CommentsSelectedPathContext.Provider, { value: ctxValue, children });
}), TRANSFORMATIONS = {
  inlineIcon: (child, idx, block) => {
    var _a2, _b, _c, _d;
    if (!types.isPortableTextTextBlock(block)) return block;
    const hasTextLeft = !!(((_a2 = block.children[idx - 1]) == null ? void 0 : _a2._type) === "span" && (_b = block.children[idx - 1]) != null && _b.text), hasTextRight = !!(((_c = block.children[idx + 1]) == null ? void 0 : _c._type) === "span" && (_d = block.children[idx + 1]) != null && _d.text);
    return {
      ...child,
      hasTextRight,
      hasTextLeft
    };
  }
}, transformBlocks = (blocks) => blocks.map((block) => {
  if (types.isPortableTextTextBlock(block) && block._type === "block") {
    const children = block.children.map((child, idx) => TRANSFORMATIONS[child._type] ? TRANSFORMATIONS[child._type](child, idx, block) : child);
    return {
      ...block,
      children
    };
  }
  return block;
}), Divider$1 = styledComponents.styled(ui.Box)`
  height: 1px;
  background: var(--card-border-color);
  width: 100%;
`, SerializerContainer = styledComponents.styled.div`
  // Remove margin top of first element
  > div:first-child {
    margin-top: 0;
  }
  // Remove margin bottom to last box.
  > [data-ui='Box']:last-child {
    margin-bottom: 0;
  }
`, IconTextContainer = styledComponents.styled(ui.Text)((props2) => props2.accent ? `
    --card-icon-color: var(--card-accent-fg-color);
    ` : ""), AccentSpan = styledComponents.styled.span`
  color: var(--card-accent-fg-color);
  --card-icon-color: var(--card-accent-fg-color);
`, SemiboldSpan = styledComponents.styled.span(({ theme: theme2 }) => {
  const { weights } = theme2.sanity.fonts.text;
  return styledComponents.css`
    font-weight: ${weights.semibold};
  `;
}), InlineIcon = styledComponents.styled(icons.Icon)`
  &[data-sanity-icon] {
    /* Forces the icon to leave the necessary space to the right or left it has surrounding text */
    margin-left: ${(props2) => props2.$hasTextLeft ? "0" : ""};
    margin-right: ${(props2) => props2.$hasTextRight ? "0" : ""};
  }
`, Link$2 = styledComponents.styled.a`
  font-weight: 600;
  color: ${(props2) => props2.useTextColor ? "var(--card-muted-fg-color) !important" : ""};
`, DynamicIconContainer = styledComponents.styled.span`
  > svg {
    display: inline;
    font-size: calc(21 / 16 * 1rem) !important;
    margin: -0.375rem 0 !important;
    *[stroke] {
      stroke: currentColor;
    }
  }
`, accentSpanWrapper = (children) => /* @__PURE__ */ jsxRuntime.jsx(AccentSpan, { children }), DynamicIcon = (props2) => {
  const [ref, setRef] = React.useState(null);
  return React.useEffect(() => {
    if (!ref) return;
    const controller = new AbortController(), signal = controller.signal;
    return fetch(props2.icon.url, { signal }).then((response) => {
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      return response.text();
    }).then((data) => {
      ref && (ref.innerHTML = data);
    }).catch((error) => {
      error.name !== "AbortError" && console.error(error);
    }), () => {
      controller.abort();
    };
  }, [ref, props2.icon.url]), /* @__PURE__ */ jsxRuntime.jsx(DynamicIconContainer, { ref: setRef });
};
function NormalBlock$1(props2) {
  const { children } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginBottom: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children }) });
}
function HeadingBlock(props2) {
  const { children } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginY: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { size: 2, as: "h2", children }) });
}
const components$1 = {
  block: {
    normal: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock$1, { children }),
    h2: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(HeadingBlock, { children })
  },
  list: {
    bullet: ({ children }) => children,
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children })
  },
  listItem: {
    bullet: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock$1, { children }),
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock$1, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock$1, { children })
  },
  marks: {
    strong: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx("strong", { children }),
    semibold: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(SemiboldSpan, { children }),
    link: (props2) => /* @__PURE__ */ jsxRuntime.jsxs(
      Link$2,
      {
        href: props2.value.href,
        rel: "noopener noreferrer",
        target: "_blank",
        useTextColor: props2.value.useTextColor,
        children: [
          props2.children,
          props2.value.showIcon && /* @__PURE__ */ jsxRuntime.jsx(icons.LinkIcon, { style: { marginLeft: "2px" } })
        ]
      }
    ),
    accent: (props2) => /* @__PURE__ */ jsxRuntime.jsx(AccentSpan, { children: props2.children })
  },
  types: {
    inlineIcon: (props2) => /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.ConditionalWrapper, { condition: props2.value.accent, wrapper: accentSpanWrapper, children: props2.value.sanityIcon ? /* @__PURE__ */ jsxRuntime.jsx(
      InlineIcon,
      {
        symbol: props2.value.sanityIcon,
        $hasTextLeft: props2.value.hasTextLeft,
        $hasTextRight: props2.value.hasTextRight
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(DynamicIcon, { icon: props2.value.icon }) }),
    divider: () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(Divider$1, {}) }) }),
    iconAndText: (props2) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", paddingX: 2, paddingTop: 1, paddingBottom: 2, marginTop: 2, gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, style: { flexShrink: 0 }, children: [
        /* @__PURE__ */ jsxRuntime.jsx(IconTextContainer, { size: 1, accent: props2.value.accent, children: props2.value.sanityIcon ? /* @__PURE__ */ jsxRuntime.jsx(icons.Icon, { symbol: props2.value.sanityIcon }) : /* @__PURE__ */ jsxRuntime.jsx(DynamicIcon, { icon: props2.value.icon }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", accent: props2.value.accent, children: props2.value.title })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, accent: props2.value.accent, children: props2.value.text })
    ] })
  }
};
function UpsellDescriptionSerializer(props2) {
  const value = React.useMemo(() => transformBlocks(props2.blocks), [props2.blocks]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(SerializerContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(
    react$1.PortableText,
    {
      value,
      components: components$1,
      onMissingComponent: !1
    }
  ) }) });
}
const StyledButton$3 = styledComponents.styled(TooltipDelayGroupProvider.Button)(({ theme: theme$1 }) => {
  const { space } = theme.getTheme_v2(theme$1);
  return `
      position: absolute;
      top: ${space[3]}px;
      right: ${space[3]}px;
      z-index: 20;
      background: transparent;
      border-radius: 9999px;
      box-shadow: none;
      color: ${color.white.hex};
      --card-fg-color: ${color.white.hex};
      :hover {
        --card-fg-color: ${color.white.hex};
      }
    `;
}), Image$4 = styledComponents.styled.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 200px;
`;
function UpsellDialog(props2) {
  var _a2, _b, _c;
  const { data, onClose, onPrimaryClick, onSecondaryClick } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    TooltipDelayGroupProvider.Dialog,
    {
      id: "upsell-dialog",
      onClose,
      onClickOutside: onClose,
      __unstable_hideCloseButton: !0,
      bodyHeight: "fill",
      padding: !1,
      footer: {
        cancelButton: (_a2 = data.secondaryButton) != null && _a2.text ? {
          text: data.secondaryButton.text,
          mode: "bleed",
          tone: "default",
          iconRight: icons.LaunchIcon,
          ...data.secondaryButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.secondaryButton.url
          },
          onClick: onSecondaryClick
        } : void 0,
        confirmButton: {
          text: (_b = data.ctaButton) == null ? void 0 : _b.text,
          mode: "default",
          tone: "primary",
          ...data.ctaButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.ctaButton.url
          },
          onClick: onPrimaryClick
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          StyledButton$3,
          {
            icon: icons.CloseIcon,
            mode: "bleed",
            tone: "default",
            onClick: onClose,
            tabIndex: -1,
            tooltipProps: null
          }
        ),
        data.image && /* @__PURE__ */ jsxRuntime.jsx(Image$4, { src: data.image.asset.url, alt: (_c = data.image.asset.altText) != null ? _c : "" }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, paddingBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(UpsellDescriptionSerializer, { blocks: data.descriptionText }) }) })
      ]
    }
  );
}
const FEATURE$2 = "comments", TEMPLATE_OPTIONS$2 = { interpolate: /{{([\s\S]+?)}}/g }, BASE_URL$2 = "www.sanity.io";
function CommentsUpsellProvider(props2) {
  const [upsellDialogOpen, setUpsellDialogOpen] = React.useState(!1), [upsellData, setUpsellData] = React.useState(null), projectId = useProjectId(), telemetry2 = react.useTelemetry(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), telemetryLogs = React.useMemo(
    () => ({
      dialogSecondaryClicked: () => telemetry2.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE$2,
        type: "modal"
      }),
      dialogPrimaryClicked: () => telemetry2.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE$2,
        type: "modal"
      }),
      panelViewed: (source) => telemetry2.log(UpsellDialogViewed, {
        feature: FEATURE$2,
        type: "inspector",
        source
      }),
      panelDismissed: () => telemetry2.log(UpsellDialogDismissed, {
        feature: FEATURE$2,
        type: "inspector"
      }),
      panelPrimaryClicked: () => telemetry2.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE$2,
        type: "inspector"
      }),
      panelSecondaryClicked: () => telemetry2.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE$2,
        type: "inspector"
      })
    }),
    [telemetry2]
  ), handlePrimaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogPrimaryClicked();
  }, [telemetryLogs]), handleSecondaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogSecondaryClicked();
  }, [telemetryLogs]), handleClose = React.useCallback(() => {
    setUpsellDialogOpen(!1), telemetry2.log(UpsellDialogDismissed, {
      feature: FEATURE$2,
      type: "modal"
    });
  }, [telemetry2]);
  React.useEffect(() => {
    const sub = client2.observable.request({
      uri: "/journey/comments"
    }).subscribe({
      next: (data) => {
        if (data)
          try {
            const ctaUrl = template__default.default(data.ctaButton.url, TEMPLATE_OPTIONS$2);
            data.ctaButton.url = ctaUrl({ baseUrl: BASE_URL$2, projectId });
            const secondaryUrl = template__default.default(data.secondaryButton.url, TEMPLATE_OPTIONS$2);
            data.secondaryButton.url = secondaryUrl({ baseUrl: BASE_URL$2, projectId }), setUpsellData(data);
          } catch {
          }
      },
      error: () => {
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [client2, projectId]);
  const handleOpenDialog = React.useCallback(
    (source) => {
      setUpsellDialogOpen(!0), telemetry2.log(UpsellDialogViewed, {
        feature: FEATURE$2,
        type: "modal",
        source
      });
    },
    [telemetry2]
  ), ctxValue = React.useMemo(
    () => ({
      upsellDialogOpen,
      handleOpenDialog,
      upsellData,
      telemetryLogs
    }),
    [handleOpenDialog, upsellDialogOpen, upsellData, telemetryLogs]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(_singletons.CommentsUpsellContext.Provider, { value: ctxValue, children: [
    props2.children,
    upsellData && upsellDialogOpen && /* @__PURE__ */ jsxRuntime.jsx(
      UpsellDialog,
      {
        data: upsellData,
        onClose: handleClose,
        onPrimaryClick: handlePrimaryButtonClick,
        onSecondaryClick: handleSecondaryButtonClick
      }
    )
  ] });
}
function CommentsDocumentLayout(props2) {
  const { documentId, documentType } = props2;
  return useCommentsEnabled().mode !== null ? /* @__PURE__ */ jsxRuntime.jsx(CommentsDocumentLayoutInner, { ...props2 }) : /* @__PURE__ */ jsxRuntime.jsx(CommentsEnabledProvider, { documentId, documentType, children: /* @__PURE__ */ jsxRuntime.jsx(CommentsDocumentLayoutInner, { ...props2 }) });
}
function CommentsDocumentLayoutInner(props2) {
  return useCommentsEnabled().enabled ? /* @__PURE__ */ jsxRuntime.jsx(CommentsSelectedPathProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsAuthoringPathProvider, { children: props2.renderDefault(props2) }) }) : props2.renderDefault(props2);
}
const COMMENTS_INSPECTOR_NAME = "sanity/comments", COMMENTS_HIGHLIGHT_HUE_KEY = "yellow", COMMENT_REACTION_OPTIONS = [
  {
    shortName: ":+1:",
    title: "Thumbs up"
  },
  {
    shortName: ":-1:",
    title: "Thumbs down"
  },
  {
    shortName: ":heart:",
    title: "Heart"
  },
  {
    shortName: ":rocket:",
    title: "Rocket"
  },
  {
    shortName: ":heavy_plus_sign:",
    title: "Heavy plus sign"
  },
  {
    shortName: ":eyes:",
    title: "Eyes"
  }
], COMMENT_REACTION_EMOJIS = {
  ":-1:": "\u{1F44E}",
  ":+1:": "\u{1F44D}",
  ":eyes:": "\u{1F440}",
  ":heart:": "\u2764\uFE0F",
  ":heavy_plus_sign:": "\u2795",
  ":rocket:": "\u{1F680}"
}, ContentStack$1 = styledComponents.styled(ui.Stack)`
  width: 320px;
`;
function CommentsFieldButton(props2) {
  const {
    count,
    currentUser,
    fieldTitle,
    isCreatingDataset,
    mentionOptions,
    onChange,
    onClick,
    onClose,
    onCommentAdd,
    onDiscard,
    onInputKeyDown,
    open,
    value
  } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), [popoverElement, setPopoverElement] = React.useState(null), [addCommentButtonElement, setAddCommentButtonElement] = React.useState(
    null
  ), commentInputHandle = React.useRef(null), hasComments = count > 0, closePopover = React.useCallback(() => {
    open && (onClose(), addCommentButtonElement == null || addCommentButtonElement.focus());
  }, [addCommentButtonElement, open, onClose]), handleSubmit = React.useCallback(() => {
    onCommentAdd(), closePopover();
  }, [closePopover, onCommentAdd]), hasValue2 = React.useMemo(() => hasCommentMessageValue(value), [value]), startDiscard = React.useCallback(() => {
    var _a2;
    if (!hasValue2) {
      closePopover();
      return;
    }
    (_a2 = commentInputHandle.current) == null || _a2.discardDialogController.open();
  }, [closePopover, hasValue2]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || onInputKeyDown && onInputKeyDown(event);
    },
    [onInputKeyDown]
  ), handleDiscardCancel = React.useCallback(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null || _a2.discardDialogController.close();
  }, []), handleDiscardConfirm = React.useCallback(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null || _a2.discardDialogController.close(), closePopover(), onDiscard();
  }, [closePopover, onDiscard]), handlePopoverKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), handleClickOutside = React.useCallback(() => {
    open && startDiscard();
  }, [open, startDiscard]);
  return ui.useClickOutside(handleClickOutside, [popoverElement]), hasComments ? /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { portal: !0, placement: "top", content: t2("field-button.content", { count }), children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      "aria-label": t2("field-button.aria-label-open"),
      mode: "bleed",
      onClick,
      padding: 2,
      space: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.CommentIcon, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: count > 9 ? "9+" : count })
      ] })
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(ContentStack$1, { padding: 2, space: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
        CommentInput,
        {
          currentUser,
          focusLock: !0,
          focusOnMount: !0,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onKeyDown: handleInputKeyDown,
          onSubmit: handleSubmit,
          placeholder: /* @__PURE__ */ jsxRuntime.jsx(
            Translate,
            {
              t: t2,
              i18nKey: "compose.add-comment-input-placeholder",
              values: { field: fieldTitle }
            }
          ),
          readOnly: isCreatingDataset,
          ref: commentInputHandle,
          value
        }
      ) }),
      fallbackPlacements: ["bottom-end"],
      open,
      placement: "right-start",
      portal: !0,
      ref: setPopoverElement,
      onKeyDown: handlePopoverKeyDown,
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          "aria-label": t2("field-button.aria-label-add"),
          disabled: isCreatingDataset,
          icon: icons.AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setAddCommentButtonElement,
          selected: open,
          tooltipProps: {
            content: t2("field-button.title"),
            placement: "top"
          }
        }
      ) })
    }
  );
}
const messageCache = /* @__PURE__ */ new Map(), EMPTY_ARRAY$f = [], HIGHLIGHT_BLOCK_VARIANTS = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1
  },
  exit: {
    opacity: 0
  }
};
function CommentsField(props2) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(CommentFieldInner, { ...props2, mode }) : props2.renderDefault(props2);
}
const HighlightDiv = styledComponents.styled(framerMotion.motion.div)(({ theme: theme2 }) => {
  const { radius, space, color: color$1 } = theme2.sanity, bg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][color$1.dark ? 900 : 50].hex;
  return styledComponents.css`
    mix-blend-mode: ${color$1.dark ? "screen" : "multiply"};
    border-radius: ${radius[3]}px;
    top: -${space[2]}px;
    left: -${space[2]}px;
    bottom: -${space[2]}px;
    right: -${space[2]}px;
    pointer-events: none;
    position: absolute;
    z-index: 1;
    width: calc(100% + ${space[2] * 2}px);
    height: calc(100% + ${space[2] * 2}px);
    background-color: ${bg};
  `;
}), FieldStack = styledComponents.styled(ui.Stack)`
  position: relative;
`;
function CommentFieldInner(props2) {
  const { mode } = props2, currentUser = useCurrentUser(), { element: boundaryElement } = ui.useBoundaryElement(), rootRef = React.useRef(null), {
    comments: comments2,
    isCommentsOpen,
    isCreatingDataset,
    mentionOptions,
    onCommentsOpen,
    operation,
    setStatus,
    status
  } = useComments(), { upsellData, handleOpenDialog } = useCommentsUpsell(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { authoringPath, setAuthoringPath } = useCommentsAuthoringPath(), { scrollToGroup } = useCommentsScroll({
    boundaryElement
  }), fieldTitle = React.useMemo(() => getSchemaTypeTitle(props2.schemaType), [props2.schemaType]), stringPath = React.useMemo(() => PathUtils__namespace.toString(props2.path), [props2.path]), cachedValue = messageCache.get(stringPath) || null, [value, setValue] = React.useState(cachedValue), isOpen = React.useMemo(() => authoringPath === stringPath, [authoringPath, stringPath]), isSelected = React.useMemo(() => !isCommentsOpen || (selectedPath == null ? void 0 : selectedPath.origin) === "form" || (selectedPath == null ? void 0 : selectedPath.origin) === "url" ? !1 : (selectedPath == null ? void 0 : selectedPath.fieldPath) === stringPath, [isCommentsOpen, selectedPath == null ? void 0 : selectedPath.fieldPath, selectedPath == null ? void 0 : selectedPath.origin, stringPath]), isInlineCommentThread = React.useMemo(() => comments2.data.open.filter((c) => c.threadId === (selectedPath == null ? void 0 : selectedPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)), [comments2.data.open, selectedPath == null ? void 0 : selectedPath.threadId]), count = React.useMemo(() => comments2.data.open.map((c) => c.fieldPath === stringPath ? c.commentsCount : 0).reduce((acc, val) => acc + val, 0) || 0, [comments2.data.open, stringPath]), hasComments = count > 0, resetMessageValue = React.useCallback(() => {
    setValue(null), messageCache.delete(stringPath);
  }, [stringPath]), handleClick = React.useCallback(() => {
    var _a2;
    if (hasComments) {
      status === "resolved" && setStatus("open"), setAuthoringPath(null), onCommentsOpen == null || onCommentsOpen();
      const scrollToThreadId = (_a2 = comments2.data.open.find(
        (c) => c.fieldPath === PathUtils__namespace.toString(props2.path)
      )) == null ? void 0 : _a2.threadId;
      scrollToThreadId && (setSelectedPath({
        threadId: scrollToThreadId,
        origin: "form",
        fieldPath: PathUtils__namespace.toString(props2.path)
      }), scrollToGroup(scrollToThreadId));
      return;
    }
    if (mode === "upsell") {
      upsellData ? handleOpenDialog("field_action") : onCommentsOpen == null || onCommentsOpen();
      return;
    }
    setAuthoringPath(isOpen ? null : stringPath);
  }, [
    comments2.data.open,
    handleOpenDialog,
    hasComments,
    isOpen,
    mode,
    onCommentsOpen,
    props2.path,
    scrollToGroup,
    setAuthoringPath,
    setSelectedPath,
    setStatus,
    status,
    stringPath,
    upsellData
  ]), handleCommentAdd = React.useCallback(() => {
    if (value) {
      const newThreadId = uuid.uuid(), nextComment = {
        type: "field",
        fieldPath: PathUtils__namespace.toString(props2.path),
        message: value,
        parentCommentId: void 0,
        status: "open",
        threadId: newThreadId,
        // New comments have no reactions
        reactions: EMPTY_ARRAY$f
      };
      operation.create(nextComment), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), resetMessageValue(), setSelectedPath({
        threadId: newThreadId,
        origin: "form",
        fieldPath: PathUtils__namespace.toString(props2.path)
      }), scrollToGroup(newThreadId);
    }
  }, [
    onCommentsOpen,
    operation,
    props2.path,
    resetMessageValue,
    scrollToGroup,
    setSelectedPath,
    setStatus,
    status,
    value
  ]), handleClose = React.useCallback(() => setAuthoringPath(null), [setAuthoringPath]), handleOnChange = React.useCallback(
    (nextValue) => {
      setValue(nextValue), messageCache.set(stringPath, nextValue);
    },
    [stringPath]
  ), internalComments = React.useMemo(
    () => ({
      button: currentUser && /* @__PURE__ */ jsxRuntime.jsx(
        CommentsFieldButton,
        {
          count: Number(count),
          currentUser,
          fieldTitle,
          isCreatingDataset,
          mentionOptions,
          onChange: handleOnChange,
          onClick: handleClick,
          onClose: handleClose,
          onCommentAdd: handleCommentAdd,
          onDiscard: resetMessageValue,
          open: isOpen,
          value
        }
      ),
      hasComments,
      isAddingComment: isOpen
    }),
    [
      currentUser,
      count,
      fieldTitle,
      isCreatingDataset,
      mentionOptions,
      handleOnChange,
      handleClick,
      handleClose,
      handleCommentAdd,
      resetMessageValue,
      isOpen,
      value,
      hasComments
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(FieldStack, { ...applyCommentsFieldAttr(PathUtils__namespace.toString(props2.path)), ref: rootRef, children: [
    props2.renderDefault({
      ...props2,
      // eslint-disable-next-line camelcase
      __internal_comments: internalComments
    }),
    /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: isSelected && !isInlineCommentThread && /* @__PURE__ */ jsxRuntime.jsx(
      HighlightDiv,
      {
        animate: "animate",
        exit: "exit",
        initial: "initial",
        variants: HIGHLIGHT_BLOCK_VARIANTS
      }
    ) })
  ] });
}
function createDomRectFromElements(elements) {
  if (!elements || !elements.length) return null;
  const rects = elements.map((el) => el.getBoundingClientRect()), minX = Math.min(...rects.map((r) => r.x)) || 0, minY = Math.min(...rects.map((r) => r.y)) || 0, maxRight = Math.max(...rects.map((r) => r.right)) || 0, maxBottom = Math.max(...rects.map((r) => r.bottom)) || 0;
  return {
    x: minX,
    y: minY,
    width: maxRight - minX,
    height: maxBottom - minY,
    top: minY,
    right: maxRight,
    bottom: maxBottom,
    left: minX
  };
}
function useRectFromElements(props2) {
  const { scrollElement, disabled, selector } = props2, [rect, setRect] = React.useState(null), handleSetRect = React.useCallback(() => {
    if (disabled) return;
    const elements = document == null ? void 0 : document.querySelectorAll(selector);
    if (!elements) return;
    const nextRect = createDomRectFromElements(Array.from(elements));
    setRect(nextRect);
  }, [disabled, selector]);
  return React.useEffect(handleSetRect, [handleSetRect]), React.useEffect(() => {
    if (!(disabled || !scrollElement))
      return scrollElement.addEventListener("wheel", handleSetRect), () => {
        scrollElement.removeEventListener("wheel", handleSetRect);
      };
  }, [handleSetRect, disabled, scrollElement]), rect;
}
function useAuthoringReferenceElement(props2) {
  const { scrollElement, disabled, selector } = props2, rect = useRectFromElements({
    scrollElement,
    disabled,
    selector
  });
  return React.useMemo(() => rect ? {
    getBoundingClientRect: () => rect
  } : null, [rect]);
}
function getSelectionBoundingRect() {
  const selection = window.getSelection();
  let range2 = null;
  return selection && selection.rangeCount > 0 && (range2 = selection.getRangeAt(0)), (range2 == null ? void 0 : range2.getBoundingClientRect()) || null;
}
const MotionPopover$1 = styledComponents.styled(framerMotion.motion(TooltipDelayGroupProvider.Popover))`
  user-select: none;
`, POPOVER_FALLBACK_PLACEMENTS$3 = ["bottom", "top"], VARIANTS$4 = {
  hidden: { opacity: 0, y: -4 },
  visible: { opacity: 1, y: 0 }
};
function FloatingButtonPopover(props2) {
  const { disabled, onClick, onClickOutside, referenceElement } = props2, [popoverElement, setPopoverElement] = React.useState(null), { t: t2 } = useTranslation(commentsLocaleNamespace);
  ui.useClickOutside(onClickOutside, [popoverElement]);
  const disabledText = t2("inline-add-comment-button.disabled-overlap-title"), enabledText = t2("inline-add-comment-button.title");
  return /* @__PURE__ */ jsxRuntime.jsx(
    MotionPopover$1,
    {
      animate: "visible",
      content: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          "data-testid": "inline-comment-button",
          disabled,
          icon: disabled ? CommentDisabledIcon : icons.AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setPopoverElement,
          text: disabled ? disabledText : enabledText
        }
      ),
      contentEditable: !1,
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$3,
      initial: "hidden",
      open: !0,
      padding: 1,
      placement: "bottom",
      portal: !0,
      referenceElement,
      variants: VARIANTS$4
    }
  );
}
const POPOVER_FALLBACK_PLACEMENTS$2 = ["bottom", "top"], MotionPopover = framerMotion.motion(TooltipDelayGroupProvider.Popover), RootStack$1 = styledComponents.styled(ui.Stack)`
  width: 250px;
`, VARIANTS$3 = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
};
function InlineCommentInputPopover(props2) {
  const {
    currentUser,
    mentionOptions,
    onChange,
    onClickOutside,
    onDiscardConfirm,
    onSubmit,
    referenceElement,
    value
  } = props2, commentInputRef = React.useRef(null), [contentElement, setContentElement] = React.useState(null), handleDiscardConfirm = React.useCallback(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close(), onDiscardConfirm();
  }, [onDiscardConfirm]), handleDiscardCancel = React.useCallback(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close();
  }, []), handleClickOutside = React.useCallback(() => {
    var _a2;
    if (hasCommentMessageValue(value)) {
      (_a2 = commentInputRef.current) == null || _a2.discardDialogController.open();
      return;
    }
    onClickOutside();
  }, [onClickOutside, value]);
  return ui.useClickOutside(handleClickOutside, [contentElement]), /* @__PURE__ */ jsxRuntime.jsx(
    MotionPopover,
    {
      animate: "visible",
      content: /* @__PURE__ */ jsxRuntime.jsx(RootStack$1, { padding: 2, ref: setContentElement, children: /* @__PURE__ */ jsxRuntime.jsx(
        CommentInput,
        {
          currentUser,
          focusLock: !0,
          focusOnMount: !0,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onSubmit,
          ref: commentInputRef,
          value
        }
      ) }),
      "data-ui": "InlineCommentInputPopover",
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$2,
      initial: "hidden",
      open: !0,
      placement: "bottom",
      portal: !0,
      referenceElement,
      variants: VARIANTS$3
    }
  );
}
const EMPTY_ARRAY$e = [], AI_ASSIST_TYPE = "sanity.assist.instruction.prompt";
function CommentsPortableTextInput(props2) {
  const { enabled, mode } = useCommentsEnabled(), isAiAssist = props2.schemaType.name === AI_ASSIST_TYPE;
  return !enabled || isAiAssist ? props2.renderDefault(props2) : /* @__PURE__ */ jsxRuntime.jsx(CommentsPortableTextInputInner, { ...props2, mode });
}
const CommentsPortableTextInputInner = React.memo(function(props2) {
  var _a2, _b;
  const { mode } = props2, currentUser = useCurrentUser(), portal = ui.usePortal(), { comments: comments2, getComment, mentionOptions, onCommentsOpen, operation, setStatus, status } = useComments(), { setSelectedPath, selectedPath } = useCommentsSelectedPath(), { scrollToComment, scrollToGroup } = useCommentsScroll(), { handleOpenDialog } = useCommentsUpsell(), editorRef = React.useRef(null), mouseDownRef = React.useRef(!1), [authoringDecorationElement, setAuthoringDecorationElement] = React.useState(null), [nextCommentValue, setNextCommentValue] = React.useState(null), [nextCommentSelection, setNextCommentSelection] = React.useState(null), [currentSelection, setCurrentSelection] = React.useState(null), [currentSelectionRect, setCurrenSelectionRect] = React.useState(null), [currentHoveredCommentId, setCurrentHoveredCommentId] = React.useState(null), [canSubmit, setCanSubmit] = React.useState(!1), [rootElement, setRootElement] = React.useState(null), [isFullScreen, setIsFullScreen] = React.useState(!1), [addedCommentsDecorations, setAddedCommentsDecorations] = React.useState(EMPTY_ARRAY$e), stringFieldPath = React.useMemo(() => PathUtils__namespace.toString(props2.path), [props2.path]), handleSetCurrentSelectionRect = React.useCallback(() => {
    const rect = getSelectionBoundingRect();
    setCurrenSelectionRect(rect);
  }, []), resetStates = React.useCallback(() => {
    setCurrentSelection(null), setCurrenSelectionRect(null), setNextCommentSelection(null), setNextCommentValue(null), setCanSubmit(!1), setAuthoringDecorationElement(null);
  }, []), handleSelectCurrentSelection = React.useCallback(() => {
    if (mode === "upsell") {
      handleOpenDialog("pte");
      return;
    }
    setNextCommentSelection(currentSelection);
  }, [currentSelection, handleOpenDialog, mode]), handleCommentDiscardConfirm = React.useCallback(() => {
    resetStates();
  }, [resetStates]), textComments = React.useMemo(() => comments2.data.open.filter((comment) => comment.fieldPath === stringFieldPath).filter((c) => isTextSelectionComment(c.parentComment)).map((c) => c.parentComment), [comments2.data.open, stringFieldPath]), getFragment = React.useCallback(() => editorRef.current ? portableTextEditor.PortableTextEditor.getFragment(editorRef.current) : EMPTY_ARRAY$e, []), handleSubmit = React.useCallback(() => {
    if (!nextCommentSelection || !editorRef.current) return;
    const fragment = getFragment() || EMPTY_ARRAY$e, editorValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current);
    if (!editorValue) return;
    const textSelection = buildTextSelectionFromFragment({
      fragment,
      selection: nextCommentSelection,
      value: editorValue
    }), threadId = uuid.uuid();
    operation.create({
      type: "field",
      contentSnapshot: fragment,
      fieldPath: stringFieldPath,
      message: nextCommentValue,
      parentCommentId: void 0,
      reactions: EMPTY_ARRAY$e,
      selection: textSelection,
      status: "open",
      threadId
    }), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), setSelectedPath({
      fieldPath: stringFieldPath,
      threadId,
      origin: "form"
    }), scrollToGroup(threadId), resetStates();
  }, [
    nextCommentSelection,
    getFragment,
    operation,
    stringFieldPath,
    nextCommentValue,
    onCommentsOpen,
    status,
    setSelectedPath,
    scrollToGroup,
    resetStates,
    setStatus
  ]), handleDecoratorClick = React.useCallback(
    (commentId) => {
      var _a22;
      const comment = getComment(commentId);
      comment && (setSelectedPath({
        fieldPath: ((_a22 = comment.target.path) == null ? void 0 : _a22.field) || "",
        threadId: comment.threadId,
        origin: "form"
      }), onCommentsOpen == null || onCommentsOpen(), scrollToComment(comment._id));
    },
    [getComment, onCommentsOpen, scrollToComment, setSelectedPath]
  ), handleSelectionChange = React.useCallback(
    (selection) => {
      const isRangeSelected = (selection == null ? void 0 : selection.anchor.offset) !== (selection == null ? void 0 : selection.focus.offset), fragment = getFragment();
      if (!(fragment != null && fragment.every(types.isPortableTextTextBlock)) || !isRangeSelected) {
        setCanSubmit(!1);
        return;
      }
      mouseDownRef.current || handleSetCurrentSelectionRect(), setCurrentSelection(selection), setCanSubmit(!0);
    },
    [getFragment, handleSetCurrentSelectionRect]
  ), debounceSelectionChange = React.useMemo(
    () => debounce__default.default(handleSelectionChange, 200),
    [handleSelectionChange]
  ), handleMouseDown = React.useCallback(() => {
    mouseDownRef.current = !0;
  }, []), handleMouseUp = React.useCallback(() => {
    mouseDownRef.current = !1, handleSetCurrentSelectionRect();
  }, [handleSetCurrentSelectionRect]), handleRangeDecorationMoved = React.useCallback((details) => {
    var _a22;
    const { rangeDecoration, newSelection } = details, commentId = (_a22 = rangeDecoration.payload) == null ? void 0 : _a22.commentId;
    setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a3;
      return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === commentId ? {
        ...rangeDecoration,
        selection: newSelection,
        payload: { ...rangeDecoration.payload, dirty: !0 }
      } : p;
    }));
  }, []), updateCommentRange = React.useCallback(() => {
    const decoratorsToUpdate = addedCommentsDecorations.filter(
      (decorator) => {
        var _a22;
        return (_a22 = decorator.payload) == null ? void 0 : _a22.dirty;
      }
    );
    decoratorsToUpdate.length !== 0 && (decoratorsToUpdate.forEach((decorator) => {
      var _a22, _b2, _c, _d, _e;
      const commentId = (_a22 = decorator.payload) == null ? void 0 : _a22.commentId, comment = getComment(commentId || "");
      if (!comment || !editorRef.current) return;
      const editorValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$e, [updatedDecoration] = buildRangeDecorationSelectionsFromComments({
        comments: [comment],
        value: editorValue
      }), nextRange = updatedDecoration != null && updatedDecoration.range ? [updatedDecoration.range] : EMPTY_ARRAY$e, nextValue = updatedDecoration ? [
        ...((_c = (_b2 = comment.target.path) == null ? void 0 : _b2.selection) == null ? void 0 : _c.value.filter((r) => {
          var _a3;
          return r._key !== ((_a3 = nextRange[0]) == null ? void 0 : _a3._key);
        }).concat(nextRange).flat()) || EMPTY_ARRAY$e
      ] : EMPTY_ARRAY$e, nextComment = {
        target: {
          ...comment.target,
          path: {
            ...((_d = comment.target) == null ? void 0 : _d.path) || {},
            field: ((_e = comment.target.path) == null ? void 0 : _e.field) || "",
            selection: {
              type: "text",
              value: nextValue
            }
          }
        }
      };
      operation.update(comment._id, nextComment);
    }), setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a22, _b2;
      return (_b2 = (_a22 = decoratorsToUpdate.find(
        (d) => {
          var _a3, _b3;
          return ((_a3 = d.payload) == null ? void 0 : _a3.commentId) === ((_b3 = p.payload) == null ? void 0 : _b3.commentId);
        }
      )) == null ? void 0 : _a22.payload) != null && _b2.dirty ? {
        ...p,
        payload: { ...p.payload, dirty: !1 }
      } : p;
    }).filter((p) => p.selection !== null)));
  }, [addedCommentsDecorations, getComment, operation]), handleBuildRangeDecorations = React.useCallback(
    (commentsToDecorate) => {
      if (!editorRef.current) return EMPTY_ARRAY$e;
      const editorValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$e;
      return buildRangeDecorations({
        comments: commentsToDecorate,
        currentHoveredCommentId,
        onDecorationClick: handleDecoratorClick,
        onDecorationHoverEnd: setCurrentHoveredCommentId,
        onDecorationHoverStart: setCurrentHoveredCommentId,
        onDecorationMoved: handleRangeDecorationMoved,
        selectedThreadId: (selectedPath == null ? void 0 : selectedPath.threadId) || null,
        value: editorValue
      });
    },
    [
      currentHoveredCommentId,
      handleDecoratorClick,
      handleRangeDecorationMoved,
      selectedPath == null ? void 0 : selectedPath.threadId
    ]
  ), onEditorChange = React.useCallback(
    (change) => {
      change.type === "mutation" && updateCommentRange(), change.type === "selection" && debounceSelectionChange(change.selection);
    },
    [debounceSelectionChange, updateCommentRange]
  ), authoringDecoration = React.useMemo(() => nextCommentSelection ? {
    component: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(CommentInlineHighlightSpan, { isAuthoring: !0, ref: setAuthoringDecorationElement, children }),
    selection: nextCommentSelection
  } : null, [nextCommentSelection]), rangeDecorations = React.useMemo(() => [
    // Existing range decorations
    ...(props2 == null ? void 0 : props2.rangeDecorations) || EMPTY_ARRAY$e,
    // The range decoration when adding a comment
    ...authoringDecoration ? [authoringDecoration] : EMPTY_ARRAY$e,
    // The range decorations for existing comments
    ...addedCommentsDecorations
  ], [addedCommentsDecorations, authoringDecoration, props2 == null ? void 0 : props2.rangeDecorations]), currentSelectionIsOverlapping = React.useMemo(() => !currentSelection || addedCommentsDecorations.length === 0 ? !1 : addedCommentsDecorations.some((d) => {
    if (!editorRef.current) return !1;
    const testA = portableTextEditor.PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      currentSelection,
      d.selection
    ), testB = portableTextEditor.PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      d.selection,
      currentSelection
    );
    return testA || testB;
  }), [addedCommentsDecorations, currentSelection]), scrollElement = isFullScreen ? document.body : ((_a2 = portal.elements) == null ? void 0 : _a2.documentScrollElement) || document.body, boundaryElement = isFullScreen ? ((_b = portal.elements) == null ? void 0 : _b.documentScrollElement) || document.body : rootElement, popoverAuthoringReferenceElement = useAuthoringReferenceElement({
    scrollElement,
    disabled: !nextCommentSelection || !authoringDecorationElement,
    selector: '[data-inline-comment-state="authoring"]'
  }), selectionReferenceElement = React.useMemo(() => currentSelectionRect ? {
    getBoundingClientRect: () => currentSelectionRect
  } : null, [currentSelectionRect]);
  React.useEffect(() => {
    if (currentSelection)
      return scrollElement == null || scrollElement.addEventListener("wheel", handleSetCurrentSelectionRect), () => {
        scrollElement == null || scrollElement.removeEventListener("wheel", handleSetCurrentSelectionRect);
      };
  }, [currentSelection, scrollElement, handleSetCurrentSelectionRect]), React.useEffect(() => {
    const nextDecorations = handleBuildRangeDecorations(textComments);
    setAddedCommentsDecorations((current) => nextDecorations.map((nextDecoration) => {
      var _a22;
      const prevDecoration = current.find(
        (p) => {
          var _a3, _b2;
          return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === ((_b2 = nextDecoration.payload) == null ? void 0 : _b2.commentId);
        }
      );
      return (_a22 = prevDecoration == null ? void 0 : prevDecoration.payload) != null && _a22.dirty ? {
        ...nextDecoration,
        payload: { ...nextDecoration.payload, dirty: prevDecoration.payload.dirty }
      } : nextDecoration;
    }));
  }, [handleBuildRangeDecorations, textComments]);
  const showFloatingButton = !!(currentSelection && canSubmit && selectionReferenceElement && !mouseDownRef.current), showFloatingInput = !!(nextCommentSelection && popoverAuthoringReferenceElement);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: boundaryElement, children: /* @__PURE__ */ jsxRuntime.jsxs(framerMotion.AnimatePresence, { children: [
      showFloatingInput && currentUser && /* @__PURE__ */ jsxRuntime.jsx(
        InlineCommentInputPopover,
        {
          currentUser,
          mentionOptions,
          onChange: setNextCommentValue,
          onClickOutside: resetStates,
          onDiscardConfirm: handleCommentDiscardConfirm,
          onSubmit: handleSubmit,
          referenceElement: popoverAuthoringReferenceElement,
          value: nextCommentValue
        }
      ),
      showFloatingButton && !showFloatingInput && /* @__PURE__ */ jsxRuntime.jsx(
        FloatingButtonPopover,
        {
          disabled: currentSelectionIsOverlapping,
          onClick: handleSelectCurrentSelection,
          onClickOutside: resetStates,
          referenceElement: selectionReferenceElement
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { ref: setRootElement, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, children: props2.renderDefault({
      ...props2,
      onEditorChange,
      editorRef,
      rangeDecorations,
      onFullScreenChange: setIsFullScreen
    }) })
  ] });
});
function isPortableTextInputProps(inputProps) {
  return types.isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function CommentsInput(props2) {
  return isPortableTextInputProps(props2) ? /* @__PURE__ */ jsxRuntime.jsx(CommentsPortableTextInput, { ...props2 }) : props2.renderDefault(props2);
}
const FEEDBACK_FORM_LINK$1 = "https://snty.link/comments-beta-feedback", Span$2 = styledComponents.styled.span`
  margin-right: 0.2em;
`, Link$1 = styledComponents.styled.a`
  white-space: nowrap;
`, FooterCard = styledComponents.styled(ui.Card)({
  position: "relative",
  zIndex: 1
});
function CommentsInspectorFeedbackFooter() {
  const { t: t2 } = useTranslation(commentsLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(FooterCard, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
    t2("feature-feedback.title"),
    " ",
    /* @__PURE__ */ jsxRuntime.jsxs(Link$1, { href: FEEDBACK_FORM_LINK$1, target: "_blank", rel: "noreferrer", children: [
      /* @__PURE__ */ jsxRuntime.jsxs(Span$2, { children: [
        t2("feature-feedback.link"),
        " "
      ] }),
      " ",
      /* @__PURE__ */ jsxRuntime.jsx(icons.LaunchIcon, {})
    ] })
  ] }) });
}
const Root$b = styledComponents.styled(ui.Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
}), CommentsInspectorHeader = React.forwardRef(function(props2, ref) {
  const { t: t2 } = useTranslation(commentsLocaleNamespace), { onClose, onViewChange, view, mode } = props2, handleSetOpenView = React.useCallback(() => onViewChange("open"), [onViewChange]), handleSetResolvedView = React.useCallback(() => onViewChange("resolved"), [onViewChange]);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$b, { ref, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "medium", children: t2("feature-name") }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: "none", padding: 1, gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.MenuButton,
        {
          id: "comment-status-menu-button",
          button: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Button,
            {
              text: t2(view === "open" ? "status-filter.status-open" : "status-filter.status-resolved"),
              mode: "bleed",
              iconRight: icons.ChevronDownIcon
            }
          ),
          menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { style: { width: "180px" }, children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                iconRight: view === "open" ? icons.CheckmarkIcon : void 0,
                onClick: handleSetOpenView,
                text: t2("status-filter.status-open-full")
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.MenuItem,
              {
                iconRight: view === "resolved" ? icons.CheckmarkIcon : void 0,
                onClick: handleSetResolvedView,
                text: t2("status-filter.status-resolved-full"),
                tooltipProps: mode === "upsell" ? { content: t2("status-filter.status-resolved-full-upsell") } : void 0,
                disabled: mode === "upsell"
              }
            )
          ] }),
          popover: { placement: "bottom-end" }
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          "aria-label": t2("close-pane-button-text-aria-label"),
          icon: icons.CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t2("close-pane-button-text") }
        }
      )
    ] })
  ] }) });
}), RootLayer$1 = styledComponents.styled(ui.Layer)`
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
`;
function CommentsInspector(props2) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(RootLayer$1, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsInspectorInner, { ...props2, mode }) }) : null;
}
function CommentsInspectorInner(props2) {
  const { t: t2 } = useTranslation(commentsLocaleNamespace), { onClose, mode } = props2, [showDeleteDialog, setShowDeleteDialog] = React.useState(!1), [commentToDelete, setCommentToDelete] = React.useState(null), [deleteLoading, setDeleteLoading] = React.useState(!1), [deleteError, setDeleteError] = React.useState(null), rootRef = React.useRef(null), currentUser = useCurrentUser(), {
    comments: comments2,
    getComment,
    isCreatingDataset,
    mentionOptions,
    setStatus,
    status,
    operation,
    selectedCommentId,
    getCommentLink,
    onClearSelectedComment,
    onPathOpen
  } = useComments(), commentIdParamRef = React.useRef(selectedCommentId), didScrollToCommentFromParam = React.useRef(!1), pushToast = ui.useToast().push, { isTopLayer } = ui.useLayer(), { scrollToComment, scrollToField, scrollToInlineComment } = useCommentsScroll(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { isDismissed, setDismissed } = useCommentsOnboarding(), telemetry2 = useCommentsTelemetry(), { upsellData, telemetryLogs: upsellTelemetryLogs } = useCommentsUpsell(), currentComments = React.useMemo(() => comments2.data[status], [comments2, status]), { loading } = comments2, handleChangeView = React.useCallback(
    (nextView) => {
      setStatus(nextView), setSelectedPath(null), telemetry2.commentListViewChanged(nextView);
    },
    [setSelectedPath, setStatus, telemetry2]
  ), handleCloseInspector = React.useCallback(() => {
    onClose(), setSelectedPath(null);
  }, [onClose, setSelectedPath]), handleCopyLink = React.useMemo(() => getCommentLink ? (id2) => {
    navigator.clipboard.writeText(getCommentLink(id2)).then(() => {
      pushToast({
        closable: !0,
        status: "info",
        title: t2("copy-link-success-message")
      });
    }).catch(() => {
      pushToast({
        closable: !0,
        status: "error",
        title: t2("copy-link-error-message")
      });
    }), telemetry2.commentLinkCopied();
  } : void 0, [getCommentLink, pushToast, t2, telemetry2]), handleCreateRetry = React.useCallback(
    (id2) => {
      var _a2;
      const comment = getComment(id2);
      comment && operation.create({
        type: "field",
        fieldPath: ((_a2 = comment.target.path) == null ? void 0 : _a2.field) || "",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || [],
        status: comment.status,
        threadId: comment.threadId
      });
    },
    [getComment, operation]
  ), closeDeleteDialog = React.useCallback(() => {
    deleteLoading || (setShowDeleteDialog(!1), setCommentToDelete(null));
  }, [deleteLoading]), handlePathSelect = React.useCallback(
    (nextPath) => {
      if (setSelectedPath(nextPath), nextPath != null && nextPath.fieldPath) {
        const path = PathUtils__namespace.fromString(nextPath.fieldPath);
        onPathOpen == null || onPathOpen(path), scrollToField(nextPath.fieldPath), comments2.data.open.filter((c) => c.threadId === (nextPath == null ? void 0 : nextPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)) && nextPath.threadId && scrollToInlineComment(nextPath.threadId);
      }
    },
    [comments2.data.open, onPathOpen, scrollToField, scrollToInlineComment, setSelectedPath]
  ), handleNewThreadCreate = React.useCallback(
    (nextComment) => {
      var _a2;
      const fieldPath = ((_a2 = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a2.fieldPath) || "";
      operation.create({
        type: "field",
        fieldPath,
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: nextComment.reactions,
        status: nextComment.status,
        threadId: nextComment.threadId
      }), setSelectedPath({
        fieldPath,
        origin: "inspector",
        threadId: nextComment.threadId
      });
    },
    [operation, setSelectedPath]
  ), handleReply = React.useCallback(
    (nextComment) => {
      var _a2;
      operation.create({
        ...nextComment,
        type: "field",
        fieldPath: ((_a2 = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a2.fieldPath) || ""
      });
    },
    [operation]
  ), handleEdit = React.useCallback(
    (id2, nextComment) => {
      operation.update(id2, nextComment);
    },
    [operation]
  ), onDeleteStart = React.useCallback(
    (id2) => {
      var _a2;
      const parent = currentComments.find((c) => {
        var _a22;
        return ((_a22 = c.parentComment) == null ? void 0 : _a22._id) === id2;
      }), isParent = !!(parent && ((_a2 = parent == null ? void 0 : parent.replies) == null ? void 0 : _a2.length) > 0);
      setShowDeleteDialog(!0), setCommentToDelete({
        commentId: id2,
        isParent
      });
    },
    [currentComments]
  ), handleDeleteConfirm = React.useCallback(
    async (id2) => {
      try {
        setDeleteLoading(!0), await operation.remove(id2), closeDeleteDialog();
      } catch (err) {
        setDeleteError(err);
      } finally {
        setDeleteLoading(!1);
      }
    },
    [closeDeleteDialog, operation]
  ), handleStatusChange = React.useCallback(
    (id2, nextStatus) => {
      var _a2;
      if (operation.update(id2, {
        status: nextStatus
      }), nextStatus === "open") {
        setStatus("open");
        const comment = getComment(id2);
        if (!comment) return;
        setSelectedPath({
          fieldPath: ((_a2 = comment.target.path) == null ? void 0 : _a2.field) || null,
          origin: "inspector",
          threadId: comment.threadId || null
        }), scrollToComment(id2);
      }
    },
    [getComment, operation, scrollToComment, setSelectedPath, setStatus]
  ), handleReactionSelect = React.useCallback(
    (id2, reaction) => {
      operation.react(id2, reaction);
    },
    [operation]
  ), handleDeselectPath = React.useCallback(() => {
    selectedPath && isTopLayer && setSelectedPath(null);
  }, [isTopLayer, selectedPath, setSelectedPath]), handleClickOutside = React.useCallback(
    (e) => {
      var _a2;
      e.target instanceof HTMLElement && ((_a2 = e.target) != null && _a2.hasAttribute("data-slate-string")) || handleDeselectPath();
    },
    [handleDeselectPath]
  );
  ui.useClickOutside(handleClickOutside, [rootRef.current]), React.useEffect(() => (mode === "upsell" && ((selectedPath == null ? void 0 : selectedPath.origin) === "form" ? upsellTelemetryLogs.panelViewed("field_action") : commentIdParamRef.current ? upsellTelemetryLogs.panelViewed("link") : upsellTelemetryLogs.panelViewed("document_action")), () => {
    mode === "upsell" && upsellTelemetryLogs.panelDismissed();
  }), []), React.useEffect(() => {
    var _a2;
    const commentToScrollTo = getComment(commentIdParamRef.current || "");
    !loading && commentToScrollTo && didScrollToCommentFromParam.current === !1 && (setStatus(commentToScrollTo.status || "open"), setSelectedPath({
      fieldPath: ((_a2 = commentToScrollTo.target.path) == null ? void 0 : _a2.field) || null,
      origin: "url",
      threadId: commentToScrollTo.threadId || null
    }), scrollToComment(commentToScrollTo._id), didScrollToCommentFromParam.current = !0, commentIdParamRef.current = void 0, onClearSelectedComment == null || onClearSelectedComment(), telemetry2.commentViewedFromLink());
  }, [
    getComment,
    loading,
    onClearSelectedComment,
    scrollToComment,
    setSelectedPath,
    setStatus,
    telemetry2
  ]);
  const beforeListNode = React.useMemo(() => mode === "upsell" && upsellData ? /* @__PURE__ */ jsxRuntime.jsx(
    CommentsUpsellPanel,
    {
      data: upsellData,
      onPrimaryClick: upsellTelemetryLogs.panelPrimaryClicked,
      onSecondaryClick: upsellTelemetryLogs.panelSecondaryClicked
    }
  ) : null, [
    mode,
    upsellTelemetryLogs.panelPrimaryClicked,
    upsellTelemetryLogs.panelSecondaryClicked,
    upsellData
  ]);
  return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
    commentToDelete && showDeleteDialog && /* @__PURE__ */ jsxRuntime.jsx(
      CommentDeleteDialog,
      {
        ...commentToDelete,
        error: deleteError,
        loading: deleteLoading,
        onClose: closeDeleteDialog,
        onConfirm: handleDeleteConfirm
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Flex,
      {
        direction: "column",
        flex: 1,
        height: "fill",
        onClick: handleDeselectPath,
        overflow: "hidden",
        ref: rootRef,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            CommentsOnboardingPopover,
            {
              onDismiss: setDismissed,
              open: !isDismissed,
              placement: "left-start",
              children: /* @__PURE__ */ jsxRuntime.jsx(
                CommentsInspectorHeader,
                {
                  onClose: handleCloseInspector,
                  onViewChange: handleChangeView,
                  view: status,
                  mode
                }
              )
            }
          ),
          currentUser && /* @__PURE__ */ jsxRuntime.jsx(
            CommentsList,
            {
              beforeListNode,
              comments: currentComments,
              currentUser,
              error: comments2.error,
              loading,
              mentionOptions,
              mode,
              onCopyLink: handleCopyLink,
              onCreateRetry: handleCreateRetry,
              onDelete: onDeleteStart,
              onEdit: handleEdit,
              onNewThreadCreate: handleNewThreadCreate,
              onPathSelect: handlePathSelect,
              onReactionSelect: handleReactionSelect,
              onReply: handleReply,
              onStatusChange: handleStatusChange,
              readOnly: isCreatingDataset,
              selectedPath,
              status
            }
          ),
          mode === "default" && /* @__PURE__ */ jsxRuntime.jsx(CommentsInspectorFeedbackFooter, {})
        ]
      }
    )
  ] });
}
function useMenuItem() {
  const { t: t2 } = useTranslation(commentsLocaleNamespace), { enabled } = useCommentsEnabled();
  return {
    hidden: !enabled,
    icon: icons.CommentIcon,
    showAsAction: !0,
    title: t2("feature-name")
  };
}
const commentsInspector = {
  name: COMMENTS_INSPECTOR_NAME,
  component: CommentsInspector,
  useMenuItem
};
function CommentsStudioLayout(props2) {
  const { enabled, isLoading } = useFeatureEnabled("studioComments");
  return /* @__PURE__ */ jsxRuntime.jsx(AddonDatasetProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsOnboardingProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.ConditionalWrapper,
    {
      condition: !enabled && !isLoading,
      wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(CommentsUpsellProvider, { children }),
      children: props2.renderDefault(props2)
    }
  ) }) });
}
const comments = definePlugin({
  name: "sanity/comments",
  document: {
    inspectors: [commentsInspector],
    components: {
      unstable_layout: CommentsDocumentLayout
    }
  },
  form: {
    components: {
      field: CommentsField,
      input: CommentsInput
    }
  },
  studio: {
    components: {
      layout: CommentsStudioLayout
    }
  },
  i18n: { bundles: [commentsUsEnglishLocaleBundle] }
}), LOCAL_STORAGE_TZ_KEY = "scheduled-publishing::time-zone", SCHEDULE_ACTION_DICTIONARY = {
  publish: {
    actionName: "Publishing",
    badgeColor: "primary",
    badgeTone: "positive"
  },
  unpublish: {
    actionName: "Unpublishing",
    badgeColor: "danger",
    badgeTone: "critical"
  }
}, SCHEDULE_STATE_DICTIONARY = {
  scheduled: {
    title: "Upcoming"
  },
  succeeded: {
    title: "Completed"
  },
  cancelled: {
    title: "Failed"
  }
}, SCHEDULE_FILTERS = Object.keys(SCHEDULE_STATE_DICTIONARY).filter(
  (f) => !!f
), TOOL_HEADER_HEIGHT = 55, DOCUMENT_HAS_WARNINGS_TEXT = "This document has validation warnings.", DOCUMENT_HAS_ERRORS_TEXT = "This document has validation errors that should be resolved before its publish date.", SCHEDULE_FAILED_TEXT = "This schedule failed to run.", FORBIDDEN_RESPONSE_TEXT = "Forbidden. Please check that your project has access to Scheduled Publishing.", DATE_FORMAT = {
  // 1 Oct 22, 10:00 PM
  SMALL: "d MMM yy',' p",
  // 1 October 2022, 10:00 PM
  MEDIUM: "d MMMM yyyy',' p",
  // Saturday, 1 October 2022, 10:00 PM
  LARGE: "iiii',' d MMMM yyyy',' p"
}, DEFAULT_SCHEDULED_PUBLISH_PLUGIN_OPTIONS = {
  enabled: !0,
  // 25/12/2022 22:00
  inputDateTimeFormat: "dd/MM/yyyy HH:mm"
}, TOOL_NAME = "schedules", TOOL_TITLE = "Schedules", ErrorCallout = (props2) => {
  const { description, title } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { overflow: "hidden", padding: 4, radius: 2, shadow: 1, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 2, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: title }),
      description && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: description })
    ] })
  ] }) });
};
var rawTimeZones = [
  {
    name: "Pacific/Niue",
    alternativeName: "Niue Time",
    group: [
      "Pacific/Niue"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Niue",
    countryCode: "NU",
    mainCities: [
      "Alofi"
    ],
    rawOffsetInMinutes: -660,
    abbreviation: "NUT",
    rawFormat: "-11:00 Niue Time - Alofi"
  },
  {
    name: "Pacific/Midway",
    alternativeName: "Samoa Time",
    group: [
      "Pacific/Midway"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "United States Minor Outlying Islands",
    countryCode: "UM",
    mainCities: [
      "Midway"
    ],
    rawOffsetInMinutes: -660,
    abbreviation: "SST",
    rawFormat: "-11:00 Samoa Time - Midway"
  },
  {
    name: "Pacific/Pago_Pago",
    alternativeName: "Samoa Time",
    group: [
      "Pacific/Pago_Pago",
      "US/Samoa",
      "Pacific/Samoa",
      "Pacific/Midway"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "American Samoa",
    countryCode: "AS",
    mainCities: [
      "Pago Pago"
    ],
    rawOffsetInMinutes: -660,
    abbreviation: "SST",
    rawFormat: "-11:00 Samoa Time - Pago Pago"
  },
  {
    name: "Pacific/Rarotonga",
    alternativeName: "Cook Islands Time",
    group: [
      "Pacific/Rarotonga"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Cook Islands",
    countryCode: "CK",
    mainCities: [
      "Avarua"
    ],
    rawOffsetInMinutes: -600,
    abbreviation: "CKT",
    rawFormat: "-10:00 Cook Islands Time - Avarua"
  },
  {
    name: "America/Adak",
    alternativeName: "Hawaii-Aleutian Time",
    group: [
      "America/Adak",
      "US/Aleutian",
      "America/Atka"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "Adak"
    ],
    rawOffsetInMinutes: -600,
    abbreviation: "HAST",
    rawFormat: "-10:00 Hawaii-Aleutian Time - Adak"
  },
  {
    name: "Pacific/Honolulu",
    alternativeName: "Hawaii-Aleutian Time",
    group: [
      "Pacific/Honolulu",
      "US/Hawaii",
      "Pacific/Johnston"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "Honolulu",
      "East Honolulu",
      "Pearl City",
      "Hilo"
    ],
    rawOffsetInMinutes: -600,
    abbreviation: "HAST",
    rawFormat: "-10:00 Hawaii-Aleutian Time - Honolulu, East Honolulu, Pearl City, Hilo"
  },
  {
    name: "Pacific/Tahiti",
    alternativeName: "Tahiti Time",
    group: [
      "Pacific/Tahiti"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "French Polynesia",
    countryCode: "PF",
    mainCities: [
      "Faaa",
      "Papeete",
      "Punaauia"
    ],
    rawOffsetInMinutes: -600,
    abbreviation: "TAHT",
    rawFormat: "-10:00 Tahiti Time - Faaa, Papeete, Punaauia"
  },
  {
    name: "Pacific/Marquesas",
    alternativeName: "Marquesas Time",
    group: [
      "Pacific/Marquesas"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "French Polynesia",
    countryCode: "PF",
    mainCities: [
      "Marquesas"
    ],
    rawOffsetInMinutes: -570,
    abbreviation: "MART",
    rawFormat: "-09:30 Marquesas Time - Marquesas"
  },
  {
    name: "America/Anchorage",
    alternativeName: "Alaska Time",
    group: [
      "America/Anchorage",
      "America/Juneau",
      "America/Metlakatla",
      "America/Nome",
      "America/Sitka",
      "America/Yakutat",
      "US/Alaska"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "Anchorage",
      "Juneau",
      "Fairbanks",
      "Eagle River"
    ],
    rawOffsetInMinutes: -540,
    abbreviation: "AKST",
    rawFormat: "-09:00 Alaska Time - Anchorage, Juneau, Fairbanks, Eagle River"
  },
  {
    name: "Pacific/Gambier",
    alternativeName: "Gambier Time",
    group: [
      "Pacific/Gambier"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "French Polynesia",
    countryCode: "PF",
    mainCities: [
      "Gambier"
    ],
    rawOffsetInMinutes: -540,
    abbreviation: "GAMT",
    rawFormat: "-09:00 Gambier Time - Gambier"
  },
  {
    name: "America/Los_Angeles",
    alternativeName: "Pacific Time",
    group: [
      "America/Los_Angeles",
      "US/Pacific"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "Los Angeles",
      "San Diego",
      "San Jose",
      "San Francisco"
    ],
    rawOffsetInMinutes: -480,
    abbreviation: "PST",
    rawFormat: "-08:00 Pacific Time - Los Angeles, San Diego, San Jose, San Francisco"
  },
  {
    name: "America/Tijuana",
    alternativeName: "Pacific Time",
    group: [
      "America/Tijuana",
      "Mexico/BajaNorte",
      "America/Ensenada",
      "America/Santa_Isabel"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Mexico",
    countryCode: "MX",
    mainCities: [
      "Tijuana",
      "Mexicali",
      "Ensenada",
      "Rosarito"
    ],
    rawOffsetInMinutes: -480,
    abbreviation: "PST",
    rawFormat: "-08:00 Pacific Time - Tijuana, Mexicali, Ensenada, Rosarito"
  },
  {
    name: "America/Vancouver",
    alternativeName: "Pacific Time",
    group: [
      "America/Vancouver",
      "Canada/Pacific"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Vancouver",
      "Surrey",
      "Okanagan",
      "Victoria"
    ],
    rawOffsetInMinutes: -480,
    abbreviation: "PST",
    rawFormat: "-08:00 Pacific Time - Vancouver, Surrey, Okanagan, Victoria"
  },
  {
    name: "Pacific/Pitcairn",
    alternativeName: "Pitcairn Time",
    group: [
      "Pacific/Pitcairn"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Pitcairn",
    countryCode: "PN",
    mainCities: [
      "Adamstown"
    ],
    rawOffsetInMinutes: -480,
    abbreviation: "PST",
    rawFormat: "-08:00 Pitcairn Time - Adamstown"
  },
  {
    name: "America/Hermosillo",
    alternativeName: "Mexican Pacific Time",
    group: [
      "America/Hermosillo",
      "America/Mazatlan",
      "Mexico/BajaSur"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Mexico",
    countryCode: "MX",
    mainCities: [
      "Hermosillo",
      "Culiac\xE1n",
      "Ciudad Obreg\xF3n",
      "Mazatl\xE1n"
    ],
    rawOffsetInMinutes: -420,
    abbreviation: "GMT-7",
    rawFormat: "-07:00 Mexican Pacific Time - Hermosillo, Culiac\xE1n, Ciudad Obreg\xF3n, Mazatl\xE1n"
  },
  {
    name: "America/Edmonton",
    alternativeName: "Mountain Time",
    group: [
      "America/Cambridge_Bay",
      "America/Edmonton",
      "America/Inuvik",
      "America/Yellowknife",
      "Canada/Mountain"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Calgary",
      "Edmonton",
      "Red Deer",
      "Sherwood Park"
    ],
    rawOffsetInMinutes: -420,
    abbreviation: "MST",
    rawFormat: "-07:00 Mountain Time - Calgary, Edmonton, Red Deer, Sherwood Park"
  },
  {
    name: "America/Ciudad_Juarez",
    alternativeName: "Mountain Time",
    group: [
      "America/Ciudad_Juarez"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Mexico",
    countryCode: "MX",
    mainCities: [
      "Ciudad Ju\xE1rez"
    ],
    rawOffsetInMinutes: -420,
    abbreviation: "MST",
    rawFormat: "-07:00 Mountain Time - Ciudad Ju\xE1rez"
  },
  {
    name: "America/Denver",
    alternativeName: "Mountain Time",
    group: [
      "America/Boise",
      "America/Denver",
      "Navajo",
      "US/Mountain",
      "America/Shiprock"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "Denver",
      "El Paso",
      "Albuquerque",
      "Colorado Springs"
    ],
    rawOffsetInMinutes: -420,
    abbreviation: "MST",
    rawFormat: "-07:00 Mountain Time - Denver, El Paso, Albuquerque, Colorado Springs"
  },
  {
    name: "America/Phoenix",
    alternativeName: "Mountain Time",
    group: [
      "America/Phoenix",
      "US/Arizona",
      "America/Creston"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "Phoenix",
      "Tucson",
      "Mesa",
      "Chandler"
    ],
    rawOffsetInMinutes: -420,
    abbreviation: "MST",
    rawFormat: "-07:00 Mountain Time - Phoenix, Tucson, Mesa, Chandler"
  },
  {
    name: "America/Whitehorse",
    alternativeName: "Yukon Time",
    group: [
      "America/Creston",
      "America/Dawson",
      "America/Dawson_Creek",
      "America/Fort_Nelson",
      "America/Whitehorse",
      "Canada/Yukon"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Whitehorse",
      "Fort St. John",
      "Creston",
      "Dawson"
    ],
    rawOffsetInMinutes: -420,
    abbreviation: "YT",
    rawFormat: "-07:00 Yukon Time - Whitehorse, Fort St. John, Creston, Dawson"
  },
  {
    name: "America/Belize",
    alternativeName: "Central Time",
    group: [
      "America/Belize"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Belize",
    countryCode: "BZ",
    mainCities: [
      "Belize City",
      "San Ignacio",
      "San Pedro",
      "Orange Walk"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Belize City, San Ignacio, San Pedro, Orange Walk"
  },
  {
    name: "America/Chicago",
    alternativeName: "Central Time",
    group: [
      "America/Chicago",
      "America/Indiana/Knox",
      "America/Indiana/Tell_City",
      "America/Menominee",
      "America/North_Dakota/Beulah",
      "America/North_Dakota/Center",
      "America/North_Dakota/New_Salem",
      "US/Central",
      "US/Indiana-Starke",
      "America/Knox_IN"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "Chicago",
      "Houston",
      "San Antonio",
      "Dallas"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Chicago, Houston, San Antonio, Dallas"
  },
  {
    name: "America/Guatemala",
    alternativeName: "Central Time",
    group: [
      "America/Guatemala"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Guatemala",
    countryCode: "GT",
    mainCities: [
      "Guatemala City",
      "Villa Nueva",
      "Mixco",
      "Cob\xE1n"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Guatemala City, Villa Nueva, Mixco, Cob\xE1n"
  },
  {
    name: "America/Managua",
    alternativeName: "Central Time",
    group: [
      "America/Managua"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Nicaragua",
    countryCode: "NI",
    mainCities: [
      "Managua",
      "Le\xF3n",
      "Masaya",
      "Chinandega"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Managua, Le\xF3n, Masaya, Chinandega"
  },
  {
    name: "America/Mexico_City",
    alternativeName: "Central Time",
    group: [
      "America/Bahia_Banderas",
      "America/Chihuahua",
      "America/Merida",
      "America/Mexico_City",
      "America/Monterrey",
      "Mexico/General"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Mexico",
    countryCode: "MX",
    mainCities: [
      "Mexico City",
      "Iztapalapa",
      "Le\xF3n de los Aldama",
      "Puebla"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Mexico City, Iztapalapa, Le\xF3n de los Aldama, Puebla"
  },
  {
    name: "America/Matamoros",
    alternativeName: "Central Time",
    group: [
      "America/Matamoros",
      "America/Ojinaga"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Mexico",
    countryCode: "MX",
    mainCities: [
      "Reynosa",
      "Heroica Matamoros",
      "Nuevo Laredo",
      "Piedras Negras"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Reynosa, Heroica Matamoros, Nuevo Laredo, Piedras Negras"
  },
  {
    name: "America/Costa_Rica",
    alternativeName: "Central Time",
    group: [
      "America/Costa_Rica"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Costa Rica",
    countryCode: "CR",
    mainCities: [
      "San Jos\xE9",
      "Lim\xF3n",
      "San Francisco",
      "Alajuela"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - San Jos\xE9, Lim\xF3n, San Francisco, Alajuela"
  },
  {
    name: "America/El_Salvador",
    alternativeName: "Central Time",
    group: [
      "America/El_Salvador"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "El Salvador",
    countryCode: "SV",
    mainCities: [
      "San Salvador",
      "Soyapango",
      "San Miguel",
      "Santa Ana"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - San Salvador, Soyapango, San Miguel, Santa Ana"
  },
  {
    name: "America/Regina",
    alternativeName: "Central Time",
    group: [
      "America/Regina",
      "America/Swift_Current",
      "Canada/Saskatchewan"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Saskatoon",
      "Regina",
      "Prince Albert",
      "Moose Jaw"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Saskatoon, Regina, Prince Albert, Moose Jaw"
  },
  {
    name: "America/Tegucigalpa",
    alternativeName: "Central Time",
    group: [
      "America/Tegucigalpa"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Honduras",
    countryCode: "HN",
    mainCities: [
      "Tegucigalpa",
      "San Pedro Sula",
      "La Ceiba",
      "Choloma"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Tegucigalpa, San Pedro Sula, La Ceiba, Choloma"
  },
  {
    name: "America/Winnipeg",
    alternativeName: "Central Time",
    group: [
      "America/Rankin_Inlet",
      "America/Resolute",
      "America/Winnipeg",
      "Canada/Central",
      "America/Rainy_River"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Winnipeg",
      "Brandon",
      "Steinbach",
      "Kenora"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "CST",
    rawFormat: "-06:00 Central Time - Winnipeg, Brandon, Steinbach, Kenora"
  },
  {
    name: "Pacific/Easter",
    alternativeName: "Easter Island Time",
    group: [
      "Pacific/Easter",
      "Chile/EasterIsland"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Chile",
    countryCode: "CL",
    mainCities: [
      "Easter"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "EAST",
    rawFormat: "-06:00 Easter Island Time - Easter"
  },
  {
    name: "Pacific/Galapagos",
    alternativeName: "Galapagos Time",
    group: [
      "Pacific/Galapagos"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Ecuador",
    countryCode: "EC",
    mainCities: [
      "Galapagos"
    ],
    rawOffsetInMinutes: -360,
    abbreviation: "GALT",
    rawFormat: "-06:00 Galapagos Time - Galapagos"
  },
  {
    name: "America/Rio_Branco",
    alternativeName: "Acre Time",
    group: [
      "America/Eirunepe",
      "America/Rio_Branco",
      "Brazil/Acre",
      "America/Porto_Acre"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Brazil",
    countryCode: "BR",
    mainCities: [
      "Rio Branco",
      "Cruzeiro do Sul",
      "Senador Guiomard",
      "Sena Madureira"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "ACT",
    rawFormat: "-05:00 Acre Time - Rio Branco, Cruzeiro do Sul, Senador Guiomard, Sena Madureira"
  },
  {
    name: "America/Bogota",
    alternativeName: "Colombia Time",
    group: [
      "America/Bogota"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Colombia",
    countryCode: "CO",
    mainCities: [
      "Bogot\xE1",
      "Cali",
      "Medell\xEDn",
      "Barranquilla"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "COT",
    rawFormat: "-05:00 Colombia Time - Bogot\xE1, Cali, Medell\xEDn, Barranquilla"
  },
  {
    name: "America/Havana",
    alternativeName: "Cuba Time",
    group: [
      "America/Havana",
      "Cuba"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Cuba",
    countryCode: "CU",
    mainCities: [
      "Havana",
      "Santiago de Cuba",
      "Camag\xFCey",
      "Holgu\xEDn"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "CST",
    rawFormat: "-05:00 Cuba Time - Havana, Santiago de Cuba, Camag\xFCey, Holgu\xEDn"
  },
  {
    name: "America/Atikokan",
    alternativeName: "Eastern Time",
    group: [
      "America/Atikokan"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Atikokan"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Atikokan"
  },
  {
    name: "America/Cancun",
    alternativeName: "Eastern Time",
    group: [
      "America/Cancun"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Mexico",
    countryCode: "MX",
    mainCities: [
      "Canc\xFAn",
      "Chetumal",
      "Playa del Carmen",
      "Cozumel"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Canc\xFAn, Chetumal, Playa del Carmen, Cozumel"
  },
  {
    name: "America/Grand_Turk",
    alternativeName: "Eastern Time",
    group: [
      "America/Grand_Turk"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Turks and Caicos Islands",
    countryCode: "TC",
    mainCities: [
      "Cockburn Town"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Cockburn Town"
  },
  {
    name: "America/Cayman",
    alternativeName: "Eastern Time",
    group: [
      "America/Cayman"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Cayman Islands",
    countryCode: "KY",
    mainCities: [
      "George Town",
      "West Bay"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - George Town, West Bay"
  },
  {
    name: "America/Jamaica",
    alternativeName: "Eastern Time",
    group: [
      "America/Jamaica",
      "Jamaica"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Jamaica",
    countryCode: "JM",
    mainCities: [
      "Kingston",
      "New Kingston",
      "Spanish Town",
      "Portmore"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Kingston, New Kingston, Spanish Town, Portmore"
  },
  {
    name: "America/Nassau",
    alternativeName: "Eastern Time",
    group: [
      "America/Nassau"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Bahamas",
    countryCode: "BS",
    mainCities: [
      "Nassau",
      "Lucaya",
      "Freeport",
      "Killarney"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Nassau, Lucaya, Freeport, Killarney"
  },
  {
    name: "America/New_York",
    alternativeName: "Eastern Time",
    group: [
      "America/Detroit",
      "America/Indiana/Indianapolis",
      "America/Indiana/Marengo",
      "America/Indiana/Petersburg",
      "America/Indiana/Vevay",
      "America/Indiana/Vincennes",
      "America/Indiana/Winamac",
      "America/Kentucky/Louisville",
      "America/Kentucky/Monticello",
      "America/New_York",
      "US/Michigan",
      "US/East-Indiana",
      "America/Indianapolis",
      "America/Fort_Wayne",
      "America/Louisville",
      "US/Eastern"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "United States",
    countryCode: "US",
    mainCities: [
      "New York City",
      "Brooklyn",
      "Queens",
      "Philadelphia"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - New York City, Brooklyn, Queens, Philadelphia"
  },
  {
    name: "America/Panama",
    alternativeName: "Eastern Time",
    group: [
      "America/Panama",
      "America/Atikokan",
      "America/Cayman",
      "America/Coral_Harbour"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Panama",
    countryCode: "PA",
    mainCities: [
      "Panam\xE1",
      "San Miguelito",
      "Juan D\xEDaz",
      "David"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Panam\xE1, San Miguelito, Juan D\xEDaz, David"
  },
  {
    name: "America/Port-au-Prince",
    alternativeName: "Eastern Time",
    group: [
      "America/Port-au-Prince"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Haiti",
    countryCode: "HT",
    mainCities: [
      "Port-au-Prince",
      "Carrefour",
      "Delmas 73",
      "Port-de-Paix"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Port-au-Prince, Carrefour, Delmas 73, Port-de-Paix"
  },
  {
    name: "America/Toronto",
    alternativeName: "Eastern Time",
    group: [
      "America/Iqaluit",
      "America/Toronto",
      "America/Pangnirtung",
      "Canada/Eastern",
      "America/Nassau",
      "America/Montreal",
      "America/Nipigon",
      "America/Thunder_Bay"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Toronto",
      "Montr\xE9al",
      "Ottawa",
      "Mississauga"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "EST",
    rawFormat: "-05:00 Eastern Time - Toronto, Montr\xE9al, Ottawa, Mississauga"
  },
  {
    name: "America/Guayaquil",
    alternativeName: "Ecuador Time",
    group: [
      "America/Guayaquil"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Ecuador",
    countryCode: "EC",
    mainCities: [
      "Quito",
      "Guayaquil",
      "Cuenca",
      "Santo Domingo de los Colorados"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "ECT",
    rawFormat: "-05:00 Ecuador Time - Quito, Guayaquil, Cuenca, Santo Domingo de los Colorados"
  },
  {
    name: "America/Lima",
    alternativeName: "Peru Time",
    group: [
      "America/Lima"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Peru",
    countryCode: "PE",
    mainCities: [
      "Lima",
      "Callao",
      "Arequipa",
      "Trujillo"
    ],
    rawOffsetInMinutes: -300,
    abbreviation: "PET",
    rawFormat: "-05:00 Peru Time - Lima, Callao, Arequipa, Trujillo"
  },
  {
    name: "America/Manaus",
    alternativeName: "Amazon Time",
    group: [
      "America/Boa_Vista",
      "America/Campo_Grande",
      "America/Cuiaba",
      "America/Manaus",
      "America/Porto_Velho",
      "Brazil/West"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Brazil",
    countryCode: "BR",
    mainCities: [
      "Manaus",
      "Campo Grande",
      "Cuiab\xE1",
      "Porto Velho"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AMT",
    rawFormat: "-04:00 Amazon Time - Manaus, Campo Grande, Cuiab\xE1, Porto Velho"
  },
  {
    name: "America/St_Kitts",
    alternativeName: "Atlantic Time",
    group: [
      "America/St_Kitts"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Saint Kitts and Nevis",
    countryCode: "KN",
    mainCities: [
      "Basseterre"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Basseterre"
  },
  {
    name: "America/Blanc-Sablon",
    alternativeName: "Atlantic Time",
    group: [
      "America/Blanc-Sablon"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Blanc-Sablon"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Blanc-Sablon"
  },
  {
    name: "America/Montserrat",
    alternativeName: "Atlantic Time",
    group: [
      "America/Montserrat"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Montserrat",
    countryCode: "MS",
    mainCities: [
      "Brades",
      "Plymouth"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Brades, Plymouth"
  },
  {
    name: "America/Barbados",
    alternativeName: "Atlantic Time",
    group: [
      "America/Barbados"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Barbados",
    countryCode: "BB",
    mainCities: [
      "Bridgetown"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Bridgetown"
  },
  {
    name: "America/Port_of_Spain",
    alternativeName: "Atlantic Time",
    group: [
      "America/Port_of_Spain"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Trinidad and Tobago",
    countryCode: "TT",
    mainCities: [
      "Chaguanas",
      "Mon Repos",
      "San Fernando",
      "Port of Spain"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Chaguanas, Mon Repos, San Fernando, Port of Spain"
  },
  {
    name: "America/Martinique",
    alternativeName: "Atlantic Time",
    group: [
      "America/Martinique"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Martinique",
    countryCode: "MQ",
    mainCities: [
      "Fort-de-France",
      "Le Lamentin",
      "Le Robert",
      "Sainte-Marie"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Fort-de-France, Le Lamentin, Le Robert, Sainte-Marie"
  },
  {
    name: "America/St_Lucia",
    alternativeName: "Atlantic Time",
    group: [
      "America/St_Lucia"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Saint Lucia",
    countryCode: "LC",
    mainCities: [
      "Gros Islet",
      "Castries"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Gros Islet, Castries"
  },
  {
    name: "America/St_Barthelemy",
    alternativeName: "Atlantic Time",
    group: [
      "America/St_Barthelemy"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Saint Barthelemy",
    countryCode: "BL",
    mainCities: [
      "Gustavia"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Gustavia"
  },
  {
    name: "America/Halifax",
    alternativeName: "Atlantic Time",
    group: [
      "America/Glace_Bay",
      "America/Goose_Bay",
      "America/Halifax",
      "America/Moncton",
      "Canada/Atlantic"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "Halifax",
      "Moncton",
      "Sydney",
      "Dartmouth"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Halifax, Moncton, Sydney, Dartmouth"
  },
  {
    name: "Atlantic/Bermuda",
    alternativeName: "Atlantic Time",
    group: [
      "Atlantic/Bermuda"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Bermuda",
    countryCode: "BM",
    mainCities: [
      "Hamilton"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Hamilton"
  },
  {
    name: "America/St_Vincent",
    alternativeName: "Atlantic Time",
    group: [
      "America/St_Vincent"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Saint Vincent and the Grenadines",
    countryCode: "VC",
    mainCities: [
      "Kingstown"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Kingstown"
  },
  {
    name: "America/Kralendijk",
    alternativeName: "Atlantic Time",
    group: [
      "America/Kralendijk"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Bonaire, Saint Eustatius and Saba ",
    countryCode: "BQ",
    mainCities: [
      "Kralendijk"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Kralendijk"
  },
  {
    name: "America/Guadeloupe",
    alternativeName: "Atlantic Time",
    group: [
      "America/Guadeloupe"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Guadeloupe",
    countryCode: "GP",
    mainCities: [
      "Les Abymes",
      "Baie-Mahault",
      "Le Gosier",
      "Petit-Bourg"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Les Abymes, Baie-Mahault, Le Gosier, Petit-Bourg"
  },
  {
    name: "America/Marigot",
    alternativeName: "Atlantic Time",
    group: [
      "America/Marigot"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Saint Martin",
    countryCode: "MF",
    mainCities: [
      "Marigot"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Marigot"
  },
  {
    name: "America/Aruba",
    alternativeName: "Atlantic Time",
    group: [
      "America/Aruba"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Aruba",
    countryCode: "AW",
    mainCities: [
      "Oranjestad",
      "Noord",
      "Tanki Leendert",
      "San Nicolas"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Oranjestad, Noord, Tanki Leendert, San Nicolas"
  },
  {
    name: "America/Lower_Princes",
    alternativeName: "Atlantic Time",
    group: [
      "America/Lower_Princes"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Sint Maarten",
    countryCode: "SX",
    mainCities: [
      "Philipsburg"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Philipsburg"
  },
  {
    name: "America/Tortola",
    alternativeName: "Atlantic Time",
    group: [
      "America/Tortola"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "British Virgin Islands",
    countryCode: "VG",
    mainCities: [
      "Road Town"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Road Town"
  },
  {
    name: "America/Dominica",
    alternativeName: "Atlantic Time",
    group: [
      "America/Dominica"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Dominica",
    countryCode: "DM",
    mainCities: [
      "Roseau"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Roseau"
  },
  {
    name: "America/St_Thomas",
    alternativeName: "Atlantic Time",
    group: [
      "America/St_Thomas"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "U.S. Virgin Islands",
    countryCode: "VI",
    mainCities: [
      "Saint Croix",
      "Charlotte Amalie"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Saint Croix, Charlotte Amalie"
  },
  {
    name: "America/Grenada",
    alternativeName: "Atlantic Time",
    group: [
      "America/Grenada"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Grenada",
    countryCode: "GD",
    mainCities: [
      "Saint George's"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Saint George's"
  },
  {
    name: "America/Antigua",
    alternativeName: "Atlantic Time",
    group: [
      "America/Antigua"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Antigua and Barbuda",
    countryCode: "AG",
    mainCities: [
      "Saint John\u2019s"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Saint John\u2019s"
  },
  {
    name: "America/Puerto_Rico",
    alternativeName: "Atlantic Time",
    group: [
      "America/Puerto_Rico",
      "America/Virgin",
      "America/Anguilla",
      "America/Antigua",
      "America/Aruba",
      "America/Blanc-Sablon",
      "America/Curacao",
      "America/Dominica",
      "America/Grenada",
      "America/Guadeloupe",
      "America/Kralendijk",
      "America/Lower_Princes",
      "America/Marigot",
      "America/Montserrat",
      "America/Port_of_Spain",
      "America/St_Barthelemy",
      "America/St_Kitts",
      "America/St_Lucia",
      "America/St_Thomas",
      "America/St_Vincent",
      "America/Tortola"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Puerto Rico",
    countryCode: "PR",
    mainCities: [
      "San Juan",
      "Bayam\xF3n",
      "Carolina",
      "Ponce"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - San Juan, Bayam\xF3n, Carolina, Ponce"
  },
  {
    name: "America/Santo_Domingo",
    alternativeName: "Atlantic Time",
    group: [
      "America/Santo_Domingo"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Dominican Republic",
    countryCode: "DO",
    mainCities: [
      "Santo Domingo",
      "Santiago de los Caballeros",
      "Santo Domingo Oeste",
      "Santo Domingo Este"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Santo Domingo, Santiago de los Caballeros, Santo Domingo Oeste, Santo Domingo Este"
  },
  {
    name: "America/Anguilla",
    alternativeName: "Atlantic Time",
    group: [
      "America/Anguilla"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Anguilla",
    countryCode: "AI",
    mainCities: [
      "The Valley"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - The Valley"
  },
  {
    name: "America/Thule",
    alternativeName: "Atlantic Time",
    group: [
      "America/Thule"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Greenland",
    countryCode: "GL",
    mainCities: [
      "Thule"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Thule"
  },
  {
    name: "America/Curacao",
    alternativeName: "Atlantic Time",
    group: [
      "America/Curacao"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Curacao",
    countryCode: "CW",
    mainCities: [
      "Willemstad"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "AST",
    rawFormat: "-04:00 Atlantic Time - Willemstad"
  },
  {
    name: "America/La_Paz",
    alternativeName: "Bolivia Time",
    group: [
      "America/La_Paz"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Bolivia",
    countryCode: "BO",
    mainCities: [
      "La Paz",
      "Santa Cruz de la Sierra",
      "Cochabamba",
      "Sucre"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "BOT",
    rawFormat: "-04:00 Bolivia Time - La Paz, Santa Cruz de la Sierra, Cochabamba, Sucre"
  },
  {
    name: "America/Santiago",
    alternativeName: "Chile Time",
    group: [
      "America/Santiago",
      "Chile/Continental"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Chile",
    countryCode: "CL",
    mainCities: [
      "Santiago",
      "Puente Alto",
      "Antofagasta",
      "Vi\xF1a del Mar"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "CLT",
    rawFormat: "-04:00 Chile Time - Santiago, Puente Alto, Antofagasta, Vi\xF1a del Mar"
  },
  {
    name: "America/Guyana",
    alternativeName: "Guyana Time",
    group: [
      "America/Guyana"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Guyana",
    countryCode: "GY",
    mainCities: [
      "Georgetown",
      "Linden",
      "New Amsterdam"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "GYT",
    rawFormat: "-04:00 Guyana Time - Georgetown, Linden, New Amsterdam"
  },
  {
    name: "America/Asuncion",
    alternativeName: "Paraguay Time",
    group: [
      "America/Asuncion"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Paraguay",
    countryCode: "PY",
    mainCities: [
      "Asunci\xF3n",
      "Ciudad del Este",
      "San Lorenzo",
      "Capiat\xE1"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "PYT",
    rawFormat: "-04:00 Paraguay Time - Asunci\xF3n, Ciudad del Este, San Lorenzo, Capiat\xE1"
  },
  {
    name: "America/Caracas",
    alternativeName: "Venezuela Time",
    group: [
      "America/Caracas"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Venezuela",
    countryCode: "VE",
    mainCities: [
      "Caracas",
      "Maracaibo",
      "Maracay",
      "Valencia"
    ],
    rawOffsetInMinutes: -240,
    abbreviation: "VET",
    rawFormat: "-04:00 Venezuela Time - Caracas, Maracaibo, Maracay, Valencia"
  },
  {
    name: "America/St_Johns",
    alternativeName: "Newfoundland Time",
    group: [
      "America/St_Johns",
      "Canada/Newfoundland"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Canada",
    countryCode: "CA",
    mainCities: [
      "St. John's",
      "Mount Pearl",
      "Corner Brook",
      "Conception Bay South"
    ],
    rawOffsetInMinutes: -210,
    abbreviation: "NST",
    rawFormat: "-03:30 Newfoundland Time - St. John's, Mount Pearl, Corner Brook, Conception Bay South"
  },
  {
    name: "America/Argentina/Buenos_Aires",
    alternativeName: "Argentina Time",
    group: [
      "America/Argentina/Buenos_Aires",
      "America/Argentina/Catamarca",
      "America/Argentina/Cordoba",
      "America/Argentina/Jujuy",
      "America/Argentina/La_Rioja",
      "America/Argentina/Mendoza",
      "America/Argentina/Rio_Gallegos",
      "America/Argentina/Salta",
      "America/Argentina/San_Juan",
      "America/Argentina/San_Luis",
      "America/Argentina/Tucuman",
      "America/Argentina/Ushuaia",
      "America/Buenos_Aires",
      "America/Catamarca",
      "America/Argentina/ComodRivadavia",
      "America/Cordoba",
      "America/Rosario",
      "America/Jujuy",
      "America/Mendoza"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Argentina",
    countryCode: "AR",
    mainCities: [
      "Buenos Aires",
      "C\xF3rdoba",
      "Rosario",
      "Mar del Plata"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "ART",
    rawFormat: "-03:00 Argentina Time - Buenos Aires, C\xF3rdoba, Rosario, Mar del Plata"
  },
  {
    name: "America/Sao_Paulo",
    alternativeName: "Brasilia Time",
    group: [
      "America/Araguaina",
      "America/Bahia",
      "America/Belem",
      "America/Fortaleza",
      "America/Maceio",
      "America/Recife",
      "America/Santarem",
      "America/Sao_Paulo",
      "Brazil/East"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Brazil",
    countryCode: "BR",
    mainCities: [
      "S\xE3o Paulo",
      "Rio de Janeiro",
      "Belo Horizonte",
      "Salvador"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "BRT",
    rawFormat: "-03:00 Brasilia Time - S\xE3o Paulo, Rio de Janeiro, Belo Horizonte, Salvador"
  },
  {
    name: "Antarctica/Palmer",
    alternativeName: "Chile Time",
    group: [
      "Antarctica/Palmer",
      "Antarctica/Rothera"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "Palmer",
      "Rothera"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "CLT",
    rawFormat: "-03:00 Chile Time - Palmer, Rothera"
  },
  {
    name: "America/Punta_Arenas",
    alternativeName: "Chile Time",
    group: [
      "America/Punta_Arenas"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Chile",
    countryCode: "CL",
    mainCities: [
      "Punta Arenas",
      "Puerto Natales"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "CLT",
    rawFormat: "-03:00 Chile Time - Punta Arenas, Puerto Natales"
  },
  {
    name: "Atlantic/Stanley",
    alternativeName: "Falkland Islands Time",
    group: [
      "Atlantic/Stanley"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Falkland Islands",
    countryCode: "FK",
    mainCities: [
      "Stanley"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "FKST",
    rawFormat: "-03:00 Falkland Islands Time - Stanley"
  },
  {
    name: "America/Cayenne",
    alternativeName: "French Guiana Time",
    group: [
      "America/Cayenne"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "French Guiana",
    countryCode: "GF",
    mainCities: [
      "Cayenne",
      "Matoury",
      "Saint-Laurent-du-Maroni",
      "Kourou"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "GFT",
    rawFormat: "-03:00 French Guiana Time - Cayenne, Matoury, Saint-Laurent-du-Maroni, Kourou"
  },
  {
    name: "America/Miquelon",
    alternativeName: "St. Pierre & Miquelon Time",
    group: [
      "America/Miquelon"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Saint Pierre and Miquelon",
    countryCode: "PM",
    mainCities: [
      "Saint-Pierre"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "PM",
    rawFormat: "-03:00 St. Pierre & Miquelon Time - Saint-Pierre"
  },
  {
    name: "America/Paramaribo",
    alternativeName: "Suriname Time",
    group: [
      "America/Paramaribo"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Suriname",
    countryCode: "SR",
    mainCities: [
      "Paramaribo",
      "Lelydorp"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "SRT",
    rawFormat: "-03:00 Suriname Time - Paramaribo, Lelydorp"
  },
  {
    name: "America/Montevideo",
    alternativeName: "Uruguay Time",
    group: [
      "America/Montevideo"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Uruguay",
    countryCode: "UY",
    mainCities: [
      "Montevideo",
      "Salto",
      "Paysand\xFA",
      "Las Piedras"
    ],
    rawOffsetInMinutes: -180,
    abbreviation: "UYT",
    rawFormat: "-03:00 Uruguay Time - Montevideo, Salto, Paysand\xFA, Las Piedras"
  },
  {
    name: "America/Scoresbysund",
    alternativeName: "East Greenland Time",
    group: [
      "America/Scoresbysund"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Greenland",
    countryCode: "GL",
    mainCities: [
      "Scoresbysund"
    ],
    rawOffsetInMinutes: -120,
    abbreviation: "EGT",
    rawFormat: "-02:00 East Greenland Time - Scoresbysund"
  },
  {
    name: "America/Noronha",
    alternativeName: "Fernando de Noronha Time",
    group: [
      "America/Noronha",
      "Brazil/DeNoronha"
    ],
    continentCode: "SA",
    continentName: "South America",
    countryName: "Brazil",
    countryCode: "BR",
    mainCities: [
      "Noronha"
    ],
    rawOffsetInMinutes: -120,
    abbreviation: "FNT",
    rawFormat: "-02:00 Fernando de Noronha Time - Noronha"
  },
  {
    name: "Atlantic/South_Georgia",
    alternativeName: "South Georgia Time",
    group: [
      "Atlantic/South_Georgia"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "South Georgia and the South Sandwich Islands",
    countryCode: "GS",
    mainCities: [
      "Grytviken"
    ],
    rawOffsetInMinutes: -120,
    abbreviation: "GST",
    rawFormat: "-02:00 South Georgia Time - Grytviken"
  },
  {
    name: "America/Nuuk",
    alternativeName: "West Greenland Time",
    group: [
      "America/Nuuk",
      "America/Godthab"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Greenland",
    countryCode: "GL",
    mainCities: [
      "Nuuk"
    ],
    rawOffsetInMinutes: -120,
    abbreviation: "WGT",
    rawFormat: "-02:00 West Greenland Time - Nuuk"
  },
  {
    name: "Atlantic/Azores",
    alternativeName: "Azores Time",
    group: [
      "Atlantic/Azores"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Portugal",
    countryCode: "PT",
    mainCities: [
      "Ponta Delgada"
    ],
    rawOffsetInMinutes: -60,
    abbreviation: "AZOT",
    rawFormat: "-01:00 Azores Time - Ponta Delgada"
  },
  {
    name: "Atlantic/Cape_Verde",
    alternativeName: "Cape Verde Time",
    group: [
      "Atlantic/Cape_Verde"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Cabo Verde",
    countryCode: "CV",
    mainCities: [
      "Praia",
      "Mindelo",
      "Espargos",
      "Assomada"
    ],
    rawOffsetInMinutes: -60,
    abbreviation: "CVT",
    rawFormat: "-01:00 Cape Verde Time - Praia, Mindelo, Espargos, Assomada"
  },
  {
    name: "Africa/Abidjan",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Abidjan",
      "Iceland",
      "Africa/Accra",
      "Africa/Bamako",
      "Africa/Banjul",
      "Africa/Conakry",
      "Africa/Dakar",
      "Africa/Freetown",
      "Africa/Lome",
      "Africa/Nouakchott",
      "Africa/Ouagadougou",
      "Atlantic/Reykjavik",
      "Atlantic/St_Helena",
      "Africa/Timbuktu"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Ivory Coast",
    countryCode: "CI",
    mainCities: [
      "Abidjan",
      "Abobo",
      "Bouak\xE9",
      "Korhogo"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Abidjan, Abobo, Bouak\xE9, Korhogo"
  },
  {
    name: "Africa/Bamako",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Bamako"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Mali",
    countryCode: "ML",
    mainCities: [
      "Bamako",
      "Sikasso",
      "Koutiala",
      "S\xE9gou"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Bamako, Sikasso, Koutiala, S\xE9gou"
  },
  {
    name: "Africa/Bissau",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Bissau"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Guinea-Bissau",
    countryCode: "GW",
    mainCities: [
      "Bissau",
      "Gab\xFA",
      "Bafat\xE1"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Bissau, Gab\xFA, Bafat\xE1"
  },
  {
    name: "Africa/Conakry",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Conakry"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Guinea",
    countryCode: "GN",
    mainCities: [
      "Conakry",
      "Camayenne",
      "Nz\xE9r\xE9kor\xE9",
      "Kankan"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Conakry, Camayenne, Nz\xE9r\xE9kor\xE9, Kankan"
  },
  {
    name: "Africa/Dakar",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Dakar"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Senegal",
    countryCode: "SN",
    mainCities: [
      "Dakar",
      "Pikine",
      "Touba",
      "Thi\xE8s"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Dakar, Pikine, Touba, Thi\xE8s"
  },
  {
    name: "America/Danmarkshavn",
    alternativeName: "Greenwich Mean Time",
    group: [
      "America/Danmarkshavn"
    ],
    continentCode: "NA",
    continentName: "North America",
    countryName: "Greenland",
    countryCode: "GL",
    mainCities: [
      "Danmarkshavn"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Danmarkshavn"
  },
  {
    name: "Europe/Isle_of_Man",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Europe/Isle_of_Man"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Isle of Man",
    countryCode: "IM",
    mainCities: [
      "Douglas"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Douglas"
  },
  {
    name: "Europe/Dublin",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Europe/Dublin",
      "Eire"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Ireland",
    countryCode: "IE",
    mainCities: [
      "Dublin",
      "South Dublin",
      "Cork",
      "Limerick"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Dublin, South Dublin, Cork, Limerick"
  },
  {
    name: "Africa/Freetown",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Freetown"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Sierra Leone",
    countryCode: "SL",
    mainCities: [
      "Freetown",
      "Bo",
      "Kenema",
      "Koidu"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Freetown, Bo, Kenema, Koidu"
  },
  {
    name: "Atlantic/St_Helena",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Atlantic/St_Helena"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Saint Helena",
    countryCode: "SH",
    mainCities: [
      "Jamestown"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Jamestown"
  },
  {
    name: "Africa/Accra",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Accra"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Ghana",
    countryCode: "GH",
    mainCities: [
      "Kumasi",
      "Accra",
      "Tamale",
      "Takoradi"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Kumasi, Accra, Tamale, Takoradi"
  },
  {
    name: "Africa/Lome",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Lome"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Togo",
    countryCode: "TG",
    mainCities: [
      "Lom\xE9",
      "Sokod\xE9",
      "Kara",
      "Atakpam\xE9"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Lom\xE9, Sokod\xE9, Kara, Atakpam\xE9"
  },
  {
    name: "Europe/London",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Europe/London",
      "GB",
      "GB-Eire",
      "Europe/Guernsey",
      "Europe/Isle_of_Man",
      "Europe/Jersey",
      "Europe/Belfast"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "United Kingdom",
    countryCode: "GB",
    mainCities: [
      "London",
      "Birmingham",
      "Liverpool",
      "Glasgow"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - London, Birmingham, Liverpool, Glasgow"
  },
  {
    name: "Africa/Monrovia",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Monrovia"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Liberia",
    countryCode: "LR",
    mainCities: [
      "Monrovia",
      "Gbarnga",
      "Buchanan",
      "Ganta"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Monrovia, Gbarnga, Buchanan, Ganta"
  },
  {
    name: "Africa/Nouakchott",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Nouakchott"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Mauritania",
    countryCode: "MR",
    mainCities: [
      "Nouakchott",
      "Nouadhibou",
      "Kiffa",
      "Dar Naim"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Nouakchott, Nouadhibou, Kiffa, Dar Naim"
  },
  {
    name: "Africa/Ouagadougou",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Ouagadougou"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Burkina Faso",
    countryCode: "BF",
    mainCities: [
      "Ouagadougou",
      "Bobo-Dioulasso",
      "Koudougou",
      "Saaba"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Ouagadougou, Bobo-Dioulasso, Koudougou, Saaba"
  },
  {
    name: "Atlantic/Reykjavik",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Atlantic/Reykjavik",
      "Iceland"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Iceland",
    countryCode: "IS",
    mainCities: [
      "Reykjav\xEDk",
      "K\xF3pavogur",
      "Hafnarfj\xF6r\xF0ur",
      "Reykjanesb\xE6r"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Reykjav\xEDk, K\xF3pavogur, Hafnarfj\xF6r\xF0ur, Reykjanesb\xE6r"
  },
  {
    name: "Europe/Jersey",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Europe/Jersey"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Jersey",
    countryCode: "JE",
    mainCities: [
      "Saint Helier"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Saint Helier"
  },
  {
    name: "Europe/Guernsey",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Europe/Guernsey"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Guernsey",
    countryCode: "GG",
    mainCities: [
      "Saint Peter Port"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Saint Peter Port"
  },
  {
    name: "Africa/Banjul",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Banjul"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Gambia",
    countryCode: "GM",
    mainCities: [
      "Serekunda",
      "Brikama",
      "Bununka Kunda",
      "Sukuta"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Serekunda, Brikama, Bununka Kunda, Sukuta"
  },
  {
    name: "Africa/Sao_Tome",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Africa/Sao_Tome"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Sao Tome and Principe",
    countryCode: "ST",
    mainCities: [
      "S\xE3o Tom\xE9"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - S\xE3o Tom\xE9"
  },
  {
    name: "Antarctica/Troll",
    alternativeName: "Greenwich Mean Time",
    group: [
      "Antarctica/Troll"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "Troll"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "GMT",
    rawFormat: "+00:00 Greenwich Mean Time - Troll"
  },
  {
    name: "Africa/Casablanca",
    alternativeName: "Western European Time",
    group: [
      "Africa/Casablanca"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Morocco",
    countryCode: "MA",
    mainCities: [
      "Casablanca",
      "Rabat",
      "Fes",
      "Tangier"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "WET",
    rawFormat: "+00:00 Western European Time - Casablanca, Rabat, Fes, Tangier"
  },
  {
    name: "Africa/El_Aaiun",
    alternativeName: "Western European Time",
    group: [
      "Africa/El_Aaiun"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Western Sahara",
    countryCode: "EH",
    mainCities: [
      "Laayoune",
      "Dakhla",
      "Boujdour"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "WET",
    rawFormat: "+00:00 Western European Time - Laayoune, Dakhla, Boujdour"
  },
  {
    name: "Atlantic/Canary",
    alternativeName: "Western European Time",
    group: [
      "Atlantic/Canary"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Spain",
    countryCode: "ES",
    mainCities: [
      "Las Palmas de Gran Canaria",
      "Santa Cruz de Tenerife",
      "La Laguna",
      "Telde"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "WET",
    rawFormat: "+00:00 Western European Time - Las Palmas de Gran Canaria, Santa Cruz de Tenerife, La Laguna, Telde"
  },
  {
    name: "Europe/Lisbon",
    alternativeName: "Western European Time",
    group: [
      "Atlantic/Madeira",
      "Europe/Lisbon",
      "Portugal"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Portugal",
    countryCode: "PT",
    mainCities: [
      "Lisbon",
      "Porto",
      "Amadora",
      "Braga"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "WET",
    rawFormat: "+00:00 Western European Time - Lisbon, Porto, Amadora, Braga"
  },
  {
    name: "Atlantic/Faroe",
    alternativeName: "Western European Time",
    group: [
      "Atlantic/Faroe",
      "Atlantic/Faeroe"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Faroe Islands",
    countryCode: "FO",
    mainCities: [
      "T\xF3rshavn"
    ],
    rawOffsetInMinutes: 0,
    abbreviation: "WET",
    rawFormat: "+00:00 Western European Time - T\xF3rshavn"
  },
  {
    name: "Africa/Windhoek",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Windhoek"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Namibia",
    countryCode: "NA",
    mainCities: [
      "Windhoek",
      "Rundu",
      "Walvis Bay",
      "Swakopmund"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CAT",
    rawFormat: "+01:00 Central Africa Time - Windhoek, Rundu, Walvis Bay, Swakopmund"
  },
  {
    name: "Africa/Algiers",
    alternativeName: "Central European Time",
    group: [
      "Africa/Algiers"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Algeria",
    countryCode: "DZ",
    mainCities: [
      "Algiers",
      "Oran",
      "Constantine",
      "Annaba"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Algiers, Oran, Constantine, Annaba"
  },
  {
    name: "Europe/Amsterdam",
    alternativeName: "Central European Time",
    group: [
      "Europe/Amsterdam"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "The Netherlands",
    countryCode: "NL",
    mainCities: [
      "Amsterdam",
      "Rotterdam",
      "The Hague",
      "Utrecht"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Amsterdam, Rotterdam, The Hague, Utrecht"
  },
  {
    name: "Europe/Andorra",
    alternativeName: "Central European Time",
    group: [
      "Europe/Andorra"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Andorra",
    countryCode: "AD",
    mainCities: [
      "Andorra la Vella",
      "les Escaldes"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Andorra la Vella, les Escaldes"
  },
  {
    name: "Europe/Belgrade",
    alternativeName: "Central European Time",
    group: [
      "Europe/Belgrade",
      "Europe/Ljubljana",
      "Europe/Podgorica",
      "Europe/Sarajevo",
      "Europe/Skopje",
      "Europe/Zagreb"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Serbia",
    countryCode: "RS",
    mainCities: [
      "Belgrade",
      "Ni\u0161",
      "Novi Sad",
      "Zemun"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Belgrade, Ni\u0161, Novi Sad, Zemun"
  },
  {
    name: "Europe/Berlin",
    alternativeName: "Central European Time",
    group: [
      "Europe/Berlin",
      "Europe/Busingen",
      "Arctic/Longyearbyen",
      "Europe/Copenhagen",
      "Europe/Oslo",
      "Europe/Stockholm",
      "Atlantic/Jan_Mayen"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Germany",
    countryCode: "DE",
    mainCities: [
      "Berlin",
      "Hamburg",
      "Munich",
      "K\xF6ln"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Berlin, Hamburg, Munich, K\xF6ln"
  },
  {
    name: "Europe/Bratislava",
    alternativeName: "Central European Time",
    group: [
      "Europe/Bratislava"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Slovakia",
    countryCode: "SK",
    mainCities: [
      "Bratislava",
      "Ko\u0161ice",
      "Nitra",
      "Pre\u0161ov"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Bratislava, Ko\u0161ice, Nitra, Pre\u0161ov"
  },
  {
    name: "Europe/Brussels",
    alternativeName: "Central European Time",
    group: [
      "Europe/Brussels",
      "Europe/Amsterdam",
      "Europe/Luxembourg"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Belgium",
    countryCode: "BE",
    mainCities: [
      "Brussels",
      "Antwerpen",
      "Gent",
      "Charleroi"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Brussels, Antwerpen, Gent, Charleroi"
  },
  {
    name: "Europe/Budapest",
    alternativeName: "Central European Time",
    group: [
      "Europe/Budapest"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Hungary",
    countryCode: "HU",
    mainCities: [
      "Budapest",
      "Debrecen",
      "Szeged",
      "Miskolc"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Budapest, Debrecen, Szeged, Miskolc"
  },
  {
    name: "Europe/Copenhagen",
    alternativeName: "Central European Time",
    group: [
      "Europe/Copenhagen"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Denmark",
    countryCode: "DK",
    mainCities: [
      "Copenhagen",
      "\xC5rhus",
      "Odense",
      "Aalborg"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Copenhagen, \xC5rhus, Odense, Aalborg"
  },
  {
    name: "Europe/Gibraltar",
    alternativeName: "Central European Time",
    group: [
      "Europe/Gibraltar"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Gibraltar",
    countryCode: "GI",
    mainCities: [
      "Gibraltar"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Gibraltar"
  },
  {
    name: "Europe/Ljubljana",
    alternativeName: "Central European Time",
    group: [
      "Europe/Ljubljana"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Slovenia",
    countryCode: "SI",
    mainCities: [
      "Ljubljana",
      "Maribor",
      "Kranj",
      "Celje"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Ljubljana, Maribor, Kranj, Celje"
  },
  {
    name: "Arctic/Longyearbyen",
    alternativeName: "Central European Time",
    group: [
      "Arctic/Longyearbyen"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Svalbard and Jan Mayen",
    countryCode: "SJ",
    mainCities: [
      "Longyearbyen"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Longyearbyen"
  },
  {
    name: "Europe/Luxembourg",
    alternativeName: "Central European Time",
    group: [
      "Europe/Luxembourg"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Luxembourg",
    countryCode: "LU",
    mainCities: [
      "Luxembourg",
      "Esch-sur-Alzette",
      "Dudelange"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Luxembourg, Esch-sur-Alzette, Dudelange"
  },
  {
    name: "Europe/Madrid",
    alternativeName: "Central European Time",
    group: [
      "Africa/Ceuta",
      "Europe/Madrid"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Spain",
    countryCode: "ES",
    mainCities: [
      "Madrid",
      "Barcelona",
      "Valencia",
      "Sevilla"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Madrid, Barcelona, Valencia, Sevilla"
  },
  {
    name: "Europe/Monaco",
    alternativeName: "Central European Time",
    group: [
      "Europe/Monaco"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Monaco",
    countryCode: "MC",
    mainCities: [
      "Monaco",
      "Monte-Carlo"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Monaco, Monte-Carlo"
  },
  {
    name: "Europe/Oslo",
    alternativeName: "Central European Time",
    group: [
      "Europe/Oslo",
      "Atlantic/Jan_Mayen"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Norway",
    countryCode: "NO",
    mainCities: [
      "Oslo",
      "Bergen",
      "Trondheim",
      "Stavanger"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Oslo, Bergen, Trondheim, Stavanger"
  },
  {
    name: "Europe/Paris",
    alternativeName: "Central European Time",
    group: [
      "Europe/Paris",
      "Europe/Monaco"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "France",
    countryCode: "FR",
    mainCities: [
      "Paris",
      "Marseille",
      "Lyon",
      "Toulouse"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Paris, Marseille, Lyon, Toulouse"
  },
  {
    name: "Europe/Podgorica",
    alternativeName: "Central European Time",
    group: [
      "Europe/Podgorica"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Montenegro",
    countryCode: "ME",
    mainCities: [
      "Podgorica",
      "Nik\u0161i\u0107",
      "Herceg Novi",
      "Pljevlja"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Podgorica, Nik\u0161i\u0107, Herceg Novi, Pljevlja"
  },
  {
    name: "Europe/Prague",
    alternativeName: "Central European Time",
    group: [
      "Europe/Prague",
      "Europe/Bratislava"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Czechia",
    countryCode: "CZ",
    mainCities: [
      "Prague",
      "Brno",
      "Ostrava",
      "Pilsen"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Prague, Brno, Ostrava, Pilsen"
  },
  {
    name: "Europe/Rome",
    alternativeName: "Central European Time",
    group: [
      "Europe/Rome",
      "Europe/San_Marino",
      "Europe/Vatican"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Italy",
    countryCode: "IT",
    mainCities: [
      "Rome",
      "Milan",
      "Naples",
      "Turin"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Rome, Milan, Naples, Turin"
  },
  {
    name: "Europe/San_Marino",
    alternativeName: "Central European Time",
    group: [
      "Europe/San_Marino"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "San Marino",
    countryCode: "SM",
    mainCities: [
      "San Marino"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - San Marino"
  },
  {
    name: "Europe/Malta",
    alternativeName: "Central European Time",
    group: [
      "Europe/Malta"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Malta",
    countryCode: "MT",
    mainCities: [
      "San Pawl il-Ba\u0127ar",
      "Birkirkara",
      "Mosta",
      "Sliema"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - San Pawl il-Ba\u0127ar, Birkirkara, Mosta, Sliema"
  },
  {
    name: "Europe/Sarajevo",
    alternativeName: "Central European Time",
    group: [
      "Europe/Sarajevo"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Bosnia and Herzegovina",
    countryCode: "BA",
    mainCities: [
      "Sarajevo",
      "Banja Luka",
      "Zenica",
      "Tuzla"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Sarajevo, Banja Luka, Zenica, Tuzla"
  },
  {
    name: "Europe/Skopje",
    alternativeName: "Central European Time",
    group: [
      "Europe/Skopje"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "North Macedonia",
    countryCode: "MK",
    mainCities: [
      "Skopje",
      "Kumanovo",
      "Prilep",
      "Bitola"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Skopje, Kumanovo, Prilep, Bitola"
  },
  {
    name: "Europe/Stockholm",
    alternativeName: "Central European Time",
    group: [
      "Europe/Stockholm"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Sweden",
    countryCode: "SE",
    mainCities: [
      "Stockholm",
      "G\xF6teborg",
      "Malm\xF6",
      "Uppsala"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Stockholm, G\xF6teborg, Malm\xF6, Uppsala"
  },
  {
    name: "Europe/Tirane",
    alternativeName: "Central European Time",
    group: [
      "Europe/Tirane"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Albania",
    countryCode: "AL",
    mainCities: [
      "Tirana",
      "Durr\xEBs",
      "Elbasan",
      "Vlor\xEB"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Tirana, Durr\xEBs, Elbasan, Vlor\xEB"
  },
  {
    name: "Africa/Tunis",
    alternativeName: "Central European Time",
    group: [
      "Africa/Tunis"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Tunisia",
    countryCode: "TN",
    mainCities: [
      "Tunis",
      "Sfax",
      "Sousse",
      "Kairouan"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Tunis, Sfax, Sousse, Kairouan"
  },
  {
    name: "Europe/Vaduz",
    alternativeName: "Central European Time",
    group: [
      "Europe/Vaduz"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Liechtenstein",
    countryCode: "LI",
    mainCities: [
      "Vaduz"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Vaduz"
  },
  {
    name: "Europe/Vatican",
    alternativeName: "Central European Time",
    group: [
      "Europe/Vatican"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Vatican",
    countryCode: "VA",
    mainCities: [
      "Vatican City"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Vatican City"
  },
  {
    name: "Europe/Vienna",
    alternativeName: "Central European Time",
    group: [
      "Europe/Vienna"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Austria",
    countryCode: "AT",
    mainCities: [
      "Vienna",
      "Graz",
      "Linz",
      "Favoriten"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Vienna, Graz, Linz, Favoriten"
  },
  {
    name: "Europe/Warsaw",
    alternativeName: "Central European Time",
    group: [
      "Europe/Warsaw",
      "Poland"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Poland",
    countryCode: "PL",
    mainCities: [
      "Warsaw",
      "\u0141\xF3d\u017A",
      "Krak\xF3w",
      "Wroc\u0142aw"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Warsaw, \u0141\xF3d\u017A, Krak\xF3w, Wroc\u0142aw"
  },
  {
    name: "Europe/Zagreb",
    alternativeName: "Central European Time",
    group: [
      "Europe/Zagreb"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Croatia",
    countryCode: "HR",
    mainCities: [
      "Zagreb",
      "Split",
      "Rijeka",
      "Osijek"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Zagreb, Split, Rijeka, Osijek"
  },
  {
    name: "Europe/Zurich",
    alternativeName: "Central European Time",
    group: [
      "Europe/Zurich",
      "Europe/Busingen",
      "Europe/Vaduz"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Switzerland",
    countryCode: "CH",
    mainCities: [
      "Z\xFCrich",
      "Gen\xE8ve",
      "Basel",
      "Lausanne"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "CET",
    rawFormat: "+01:00 Central European Time - Z\xFCrich, Gen\xE8ve, Basel, Lausanne"
  },
  {
    name: "Africa/Bangui",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Bangui"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Central African Republic",
    countryCode: "CF",
    mainCities: [
      "Bangui",
      "Bimbo",
      "B\xE9goua",
      "Carnot"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Bangui, Bimbo, B\xE9goua, Carnot"
  },
  {
    name: "Africa/Malabo",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Malabo"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Equatorial Guinea",
    countryCode: "GQ",
    mainCities: [
      "Bata",
      "Malabo",
      "Ebebiyin"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Bata, Malabo, Ebebiyin"
  },
  {
    name: "Africa/Brazzaville",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Brazzaville"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Republic of the Congo",
    countryCode: "CG",
    mainCities: [
      "Brazzaville",
      "Pointe-Noire",
      "Dolisie",
      "Nkayi"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Brazzaville, Pointe-Noire, Dolisie, Nkayi"
  },
  {
    name: "Africa/Porto-Novo",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Porto-Novo"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Benin",
    countryCode: "BJ",
    mainCities: [
      "Cotonou",
      "Abomey-Calavi",
      "Porto-Novo",
      "Parakou"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Cotonou, Abomey-Calavi, Porto-Novo, Parakou"
  },
  {
    name: "Africa/Douala",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Douala"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Cameroon",
    countryCode: "CM",
    mainCities: [
      "Douala",
      "Yaound\xE9",
      "Bamenda",
      "Bafoussam"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Douala, Yaound\xE9, Bamenda, Bafoussam"
  },
  {
    name: "Africa/Kinshasa",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Kinshasa"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Democratic Republic of the Congo",
    countryCode: "CD",
    mainCities: [
      "Kinshasa",
      "Kikwit",
      "Masina",
      "Mbandaka"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Kinshasa, Kikwit, Masina, Mbandaka"
  },
  {
    name: "Africa/Lagos",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Lagos",
      "Africa/Bangui",
      "Africa/Brazzaville",
      "Africa/Douala",
      "Africa/Kinshasa",
      "Africa/Libreville",
      "Africa/Luanda",
      "Africa/Malabo",
      "Africa/Niamey",
      "Africa/Porto-Novo"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Nigeria",
    countryCode: "NG",
    mainCities: [
      "Lagos",
      "Kano",
      "Ibadan",
      "Abuja"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Lagos, Kano, Ibadan, Abuja"
  },
  {
    name: "Africa/Libreville",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Libreville"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Gabon",
    countryCode: "GA",
    mainCities: [
      "Libreville",
      "Port-Gentil",
      "Franceville",
      "Owendo"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Libreville, Port-Gentil, Franceville, Owendo"
  },
  {
    name: "Africa/Luanda",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Luanda"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Angola",
    countryCode: "AO",
    mainCities: [
      "Luanda",
      "Lubango",
      "Huambo",
      "Benguela"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Luanda, Lubango, Huambo, Benguela"
  },
  {
    name: "Africa/Ndjamena",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Ndjamena"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Chad",
    countryCode: "TD",
    mainCities: [
      "N'Djamena",
      "Moundou",
      "Ab\xE9ch\xE9",
      "Sarh"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - N'Djamena, Moundou, Ab\xE9ch\xE9, Sarh"
  },
  {
    name: "Africa/Niamey",
    alternativeName: "West Africa Time",
    group: [
      "Africa/Niamey"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Niger",
    countryCode: "NE",
    mainCities: [
      "Niamey",
      "Maradi",
      "Zinder",
      "Tahoua"
    ],
    rawOffsetInMinutes: 60,
    abbreviation: "WAT",
    rawFormat: "+01:00 West Africa Time - Niamey, Maradi, Zinder, Tahoua"
  },
  {
    name: "Africa/Bujumbura",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Bujumbura"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Burundi",
    countryCode: "BI",
    mainCities: [
      "Bujumbura",
      "Gitega",
      "Ngozi",
      "Rumonge"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Bujumbura, Gitega, Ngozi, Rumonge"
  },
  {
    name: "Africa/Gaborone",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Gaborone"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Botswana",
    countryCode: "BW",
    mainCities: [
      "Gaborone",
      "Francistown",
      "Mogoditshane",
      "Maun"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Gaborone, Francistown, Mogoditshane, Maun"
  },
  {
    name: "Africa/Harare",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Harare"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Zimbabwe",
    countryCode: "ZW",
    mainCities: [
      "Harare",
      "Bulawayo",
      "Chitungwiza",
      "Mutare"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Harare, Bulawayo, Chitungwiza, Mutare"
  },
  {
    name: "Africa/Juba",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Juba"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "South Sudan",
    countryCode: "SS",
    mainCities: [
      "Juba",
      "Winejok",
      "Yei",
      "Malakal"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Juba, Winejok, Yei, Malakal"
  },
  {
    name: "Africa/Khartoum",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Khartoum"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Sudan",
    countryCode: "SD",
    mainCities: [
      "Khartoum",
      "Omdurman",
      "Nyala",
      "Port Sudan"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Khartoum, Omdurman, Nyala, Port Sudan"
  },
  {
    name: "Africa/Kigali",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Kigali"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Rwanda",
    countryCode: "RW",
    mainCities: [
      "Kigali",
      "Gisenyi",
      "Butare",
      "Gitarama"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Kigali, Gisenyi, Butare, Gitarama"
  },
  {
    name: "Africa/Blantyre",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Blantyre"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Malawi",
    countryCode: "MW",
    mainCities: [
      "Lilongwe",
      "Blantyre",
      "Mzuzu",
      "Zomba"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Lilongwe, Blantyre, Mzuzu, Zomba"
  },
  {
    name: "Africa/Lubumbashi",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Lubumbashi"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Democratic Republic of the Congo",
    countryCode: "CD",
    mainCities: [
      "Lubumbashi",
      "Mbuji-Mayi",
      "Kananga",
      "Kisangani"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Lubumbashi, Mbuji-Mayi, Kananga, Kisangani"
  },
  {
    name: "Africa/Lusaka",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Lusaka"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Zambia",
    countryCode: "ZM",
    mainCities: [
      "Lusaka",
      "Ndola",
      "Kitwe",
      "Chipata"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Lusaka, Ndola, Kitwe, Chipata"
  },
  {
    name: "Africa/Maputo",
    alternativeName: "Central Africa Time",
    group: [
      "Africa/Maputo",
      "Africa/Blantyre",
      "Africa/Bujumbura",
      "Africa/Gaborone",
      "Africa/Harare",
      "Africa/Kigali",
      "Africa/Lubumbashi",
      "Africa/Lusaka"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Mozambique",
    countryCode: "MZ",
    mainCities: [
      "Maputo",
      "Matola",
      "Nampula",
      "Beira"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "CAT",
    rawFormat: "+02:00 Central Africa Time - Maputo, Matola, Nampula, Beira"
  },
  {
    name: "Europe/Athens",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Athens"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Greece",
    countryCode: "GR",
    mainCities: [
      "Athens",
      "Thessalon\xEDki",
      "P\xE1tra",
      "Piraeus"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Athens, Thessalon\xEDki, P\xE1tra, Piraeus"
  },
  {
    name: "Asia/Beirut",
    alternativeName: "Eastern European Time",
    group: [
      "Asia/Beirut"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Lebanon",
    countryCode: "LB",
    mainCities: [
      "Beirut",
      "Ra\u2019s Bayr\u016Bt",
      "Tripoli",
      "Sidon"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Beirut, Ra\u2019s Bayr\u016Bt, Tripoli, Sidon"
  },
  {
    name: "Europe/Bucharest",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Bucharest"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Romania",
    countryCode: "RO",
    mainCities: [
      "Bucharest",
      "Sector 3",
      "Ia\u015Fi",
      "Sector 6"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Bucharest, Sector 3, Ia\u015Fi, Sector 6"
  },
  {
    name: "Africa/Cairo",
    alternativeName: "Eastern European Time",
    group: [
      "Africa/Cairo",
      "Egypt"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Egypt",
    countryCode: "EG",
    mainCities: [
      "Cairo",
      "Alexandria",
      "Giza",
      "Shubr\u0101 al Khaymah"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Cairo, Alexandria, Giza, Shubr\u0101 al Khaymah"
  },
  {
    name: "Europe/Chisinau",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Chisinau",
      "Europe/Tiraspol"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Moldova",
    countryCode: "MD",
    mainCities: [
      "Chisinau",
      "Tiraspol",
      "B\u0103l\u0163i",
      "Bender"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Chisinau, Tiraspol, B\u0103l\u0163i, Bender"
  },
  {
    name: "Asia/Hebron",
    alternativeName: "Eastern European Time",
    group: [
      "Asia/Gaza",
      "Asia/Hebron"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Palestinian Territory",
    countryCode: "PS",
    mainCities: [
      "East Jerusalem",
      "Gaza",
      "Kh\u0101n Y\u016Bnis",
      "Jab\u0101ly\u0101"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - East Jerusalem, Gaza, Kh\u0101n Y\u016Bnis, Jab\u0101ly\u0101"
  },
  {
    name: "Europe/Helsinki",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Helsinki",
      "Europe/Mariehamn"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Finland",
    countryCode: "FI",
    mainCities: [
      "Helsinki",
      "Espoo",
      "Tampere",
      "Oulu"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Helsinki, Espoo, Tampere, Oulu"
  },
  {
    name: "Europe/Kaliningrad",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Kaliningrad"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Kaliningrad",
      "Chernyakhovsk",
      "Sovetsk",
      "Baltiysk"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Kaliningrad, Chernyakhovsk, Sovetsk, Baltiysk"
  },
  {
    name: "Europe/Kyiv",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Kyiv",
      "Europe/Uzhgorod",
      "Europe/Zaporozhye",
      "Europe/Kiev"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Ukraine",
    countryCode: "UA",
    mainCities: [
      "Kyiv",
      "Kharkiv",
      "Odesa",
      "Dnipro"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Kyiv, Kharkiv, Odesa, Dnipro"
  },
  {
    name: "Europe/Mariehamn",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Mariehamn"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Aland Islands",
    countryCode: "AX",
    mainCities: [
      "Mariehamn"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Mariehamn"
  },
  {
    name: "Asia/Nicosia",
    alternativeName: "Eastern European Time",
    group: [
      "Asia/Famagusta",
      "Asia/Nicosia",
      "Europe/Nicosia"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Cyprus",
    countryCode: "CY",
    mainCities: [
      "Nicosia",
      "Limassol",
      "Larnaca",
      "Str\xF3volos"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Nicosia, Limassol, Larnaca, Str\xF3volos"
  },
  {
    name: "Europe/Riga",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Riga"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Latvia",
    countryCode: "LV",
    mainCities: [
      "Riga",
      "Daugavpils",
      "Liep\u0101ja",
      "Jelgava"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Riga, Daugavpils, Liep\u0101ja, Jelgava"
  },
  {
    name: "Europe/Sofia",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Sofia"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Bulgaria",
    countryCode: "BG",
    mainCities: [
      "Sofia",
      "Plovdiv",
      "Varna",
      "Burgas"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Sofia, Plovdiv, Varna, Burgas"
  },
  {
    name: "Europe/Tallinn",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Tallinn"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Estonia",
    countryCode: "EE",
    mainCities: [
      "Tallinn",
      "Tartu",
      "Narva",
      "P\xE4rnu"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Tallinn, Tartu, Narva, P\xE4rnu"
  },
  {
    name: "Africa/Tripoli",
    alternativeName: "Eastern European Time",
    group: [
      "Africa/Tripoli",
      "Libya"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Libya",
    countryCode: "LY",
    mainCities: [
      "Tripoli",
      "Benghazi",
      "Misratah",
      "Zliten"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Tripoli, Benghazi, Misratah, Zliten"
  },
  {
    name: "Europe/Vilnius",
    alternativeName: "Eastern European Time",
    group: [
      "Europe/Vilnius"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Lithuania",
    countryCode: "LT",
    mainCities: [
      "Vilnius",
      "Kaunas",
      "Klaip\u0117da",
      "\u0160iauliai"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "EET",
    rawFormat: "+02:00 Eastern European Time - Vilnius, Kaunas, Klaip\u0117da, \u0160iauliai"
  },
  {
    name: "Asia/Jerusalem",
    alternativeName: "Israel Time",
    group: [
      "Asia/Jerusalem",
      "Israel",
      "Asia/Tel_Aviv"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Israel",
    countryCode: "IL",
    mainCities: [
      "Jerusalem",
      "Tel Aviv",
      "West Jerusalem",
      "Haifa"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "IST",
    rawFormat: "+02:00 Israel Time - Jerusalem, Tel Aviv, West Jerusalem, Haifa"
  },
  {
    name: "Africa/Johannesburg",
    alternativeName: "South Africa Time",
    group: [
      "Africa/Johannesburg",
      "Africa/Maseru",
      "Africa/Mbabane"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "South Africa",
    countryCode: "ZA",
    mainCities: [
      "Johannesburg",
      "Cape Town",
      "Durban",
      "Soweto"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "SAST",
    rawFormat: "+02:00 South Africa Time - Johannesburg, Cape Town, Durban, Soweto"
  },
  {
    name: "Africa/Mbabane",
    alternativeName: "South Africa Time",
    group: [
      "Africa/Mbabane"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Eswatini",
    countryCode: "SZ",
    mainCities: [
      "Manzini",
      "Mbabane",
      "Lobamba"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "SAST",
    rawFormat: "+02:00 South Africa Time - Manzini, Mbabane, Lobamba"
  },
  {
    name: "Africa/Maseru",
    alternativeName: "South Africa Time",
    group: [
      "Africa/Maseru"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Lesotho",
    countryCode: "LS",
    mainCities: [
      "Maseru",
      "Maputsoe",
      "Mohale's Hoek",
      "Mafeteng"
    ],
    rawOffsetInMinutes: 120,
    abbreviation: "SAST",
    rawFormat: "+02:00 South Africa Time - Maseru, Maputsoe, Mohale's Hoek, Mafeteng"
  },
  {
    name: "Asia/Kuwait",
    alternativeName: "Arabian Time",
    group: [
      "Asia/Kuwait"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Kuwait",
    countryCode: "KW",
    mainCities: [
      "Al A\u1E29mad\u012B",
      "\u1E28awall\u012B",
      "As S\u0101lim\u012Byah",
      "\u015Eab\u0101\u1E29 as S\u0101lim"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "AST",
    rawFormat: "+03:00 Arabian Time - Al A\u1E29mad\u012B, \u1E28awall\u012B, As S\u0101lim\u012Byah, \u015Eab\u0101\u1E29 as S\u0101lim"
  },
  {
    name: "Asia/Bahrain",
    alternativeName: "Arabian Time",
    group: [
      "Asia/Bahrain"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Bahrain",
    countryCode: "BH",
    mainCities: [
      "Ar Rif\u0101\u2018",
      "Manama",
      "Al Muharraq",
      "D\u0101r Kulayb"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "AST",
    rawFormat: "+03:00 Arabian Time - Ar Rif\u0101\u2018, Manama, Al Muharraq, D\u0101r Kulayb"
  },
  {
    name: "Asia/Baghdad",
    alternativeName: "Arabian Time",
    group: [
      "Asia/Baghdad"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Iraq",
    countryCode: "IQ",
    mainCities: [
      "Baghdad",
      "Al Maw\u015Fil al Jad\u012Bdah",
      "Al Ba\u015Frah al Qad\u012Bmah",
      "Mosul"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "AST",
    rawFormat: "+03:00 Arabian Time - Baghdad, Al Maw\u015Fil al Jad\u012Bdah, Al Ba\u015Frah al Qad\u012Bmah, Mosul"
  },
  {
    name: "Asia/Qatar",
    alternativeName: "Arabian Time",
    group: [
      "Asia/Qatar",
      "Asia/Bahrain"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Qatar",
    countryCode: "QA",
    mainCities: [
      "Doha",
      "Ar Rayy\u0101n",
      "Al Ma\u0163\u0101r al \u2018At\u012Bq",
      "Al Man\u015F\u016Brah"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "AST",
    rawFormat: "+03:00 Arabian Time - Doha, Ar Rayy\u0101n, Al Ma\u0163\u0101r al \u2018At\u012Bq, Al Man\u015F\u016Brah"
  },
  {
    name: "Asia/Riyadh",
    alternativeName: "Arabian Time",
    group: [
      "Asia/Riyadh",
      "Antarctica/Syowa",
      "Asia/Aden",
      "Asia/Kuwait"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Saudi Arabia",
    countryCode: "SA",
    mainCities: [
      "Jeddah",
      "Riyadh",
      "Mecca",
      "Medina"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "AST",
    rawFormat: "+03:00 Arabian Time - Jeddah, Riyadh, Mecca, Medina"
  },
  {
    name: "Asia/Aden",
    alternativeName: "Arabian Time",
    group: [
      "Asia/Aden"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Yemen",
    countryCode: "YE",
    mainCities: [
      "Sanaa",
      "Aden",
      "Al \u1E28udaydah",
      "Taiz"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "AST",
    rawFormat: "+03:00 Arabian Time - Sanaa, Aden, Al \u1E28udaydah, Taiz"
  },
  {
    name: "Asia/Amman",
    alternativeName: "Asia/Amman",
    group: [
      "Asia/Amman"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Jordan",
    countryCode: "JO",
    mainCities: [
      "Amman",
      "Zarqa",
      "Irbid",
      "Russeifa"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "GMT+3",
    rawFormat: "+03:00 Asia/Amman - Amman, Zarqa, Irbid, Russeifa"
  },
  {
    name: "Asia/Damascus",
    alternativeName: "Asia/Damascus",
    group: [
      "Asia/Damascus"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Syria",
    countryCode: "SY",
    mainCities: [
      "Aleppo",
      "Damascus",
      "Homs",
      "Latakia"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "GMT+3",
    rawFormat: "+03:00 Asia/Damascus - Aleppo, Damascus, Homs, Latakia"
  },
  {
    name: "Africa/Addis_Ababa",
    alternativeName: "East Africa Time",
    group: [
      "Africa/Addis_Ababa"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Ethiopia",
    countryCode: "ET",
    mainCities: [
      "Addis Ababa",
      "Jijiga",
      "Gonder",
      "Mek'ele"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Addis Ababa, Jijiga, Gonder, Mek'ele"
  },
  {
    name: "Indian/Antananarivo",
    alternativeName: "East Africa Time",
    group: [
      "Indian/Antananarivo"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Madagascar",
    countryCode: "MG",
    mainCities: [
      "Antananarivo",
      "Toamasina",
      "Antsirabe",
      "Mahajanga"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Antananarivo, Toamasina, Antsirabe, Mahajanga"
  },
  {
    name: "Africa/Asmara",
    alternativeName: "East Africa Time",
    group: [
      "Africa/Asmara"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Eritrea",
    countryCode: "ER",
    mainCities: [
      "Asmara",
      "Keren",
      "Himora",
      "Massawa"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Asmara, Keren, Himora, Massawa"
  },
  {
    name: "Africa/Dar_es_Salaam",
    alternativeName: "East Africa Time",
    group: [
      "Africa/Dar_es_Salaam"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Tanzania",
    countryCode: "TZ",
    mainCities: [
      "Dar es Salaam",
      "Mwanza",
      "Arusha",
      "Mbeya"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Dar es Salaam, Mwanza, Arusha, Mbeya"
  },
  {
    name: "Africa/Djibouti",
    alternativeName: "East Africa Time",
    group: [
      "Africa/Djibouti"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Djibouti",
    countryCode: "DJ",
    mainCities: [
      "Djibouti",
      "Ali Sabih",
      "Dikhil",
      "Tadjoura"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Djibouti, Ali Sabih, Dikhil, Tadjoura"
  },
  {
    name: "Africa/Kampala",
    alternativeName: "East Africa Time",
    group: [
      "Africa/Kampala"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Uganda",
    countryCode: "UG",
    mainCities: [
      "Kampala",
      "Gulu",
      "Lira",
      "Mbarara"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Kampala, Gulu, Lira, Mbarara"
  },
  {
    name: "Indian/Mayotte",
    alternativeName: "East Africa Time",
    group: [
      "Indian/Mayotte"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Mayotte",
    countryCode: "YT",
    mainCities: [
      "Mamoudzou",
      "Koungou",
      "Labattoir",
      "Kaou\xE9ni"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Mamoudzou, Koungou, Labattoir, Kaou\xE9ni"
  },
  {
    name: "Africa/Mogadishu",
    alternativeName: "East Africa Time",
    group: [
      "Africa/Mogadishu"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Somalia",
    countryCode: "SO",
    mainCities: [
      "Mogadishu",
      "Borama",
      "Hargeysa",
      "Berbera"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Mogadishu, Borama, Hargeysa, Berbera"
  },
  {
    name: "Indian/Comoro",
    alternativeName: "East Africa Time",
    group: [
      "Indian/Comoro"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Comoros",
    countryCode: "KM",
    mainCities: [
      "Moroni",
      "Moutsamoudou",
      "Fomboni"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Moroni, Moutsamoudou, Fomboni"
  },
  {
    name: "Africa/Nairobi",
    alternativeName: "East Africa Time",
    group: [
      "Africa/Nairobi",
      "Africa/Addis_Ababa",
      "Africa/Asmara",
      "Africa/Dar_es_Salaam",
      "Africa/Djibouti",
      "Africa/Kampala",
      "Africa/Mogadishu",
      "Indian/Antananarivo",
      "Indian/Comoro",
      "Indian/Mayotte",
      "Africa/Asmera"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Kenya",
    countryCode: "KE",
    mainCities: [
      "Nairobi",
      "Kakamega",
      "Mombasa",
      "Nakuru"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "EAT",
    rawFormat: "+03:00 East Africa Time - Nairobi, Kakamega, Mombasa, Nakuru"
  },
  {
    name: "Europe/Minsk",
    alternativeName: "Moscow Time",
    group: [
      "Europe/Minsk"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Belarus",
    countryCode: "BY",
    mainCities: [
      "Minsk",
      "Homyel'",
      "Hrodna",
      "Mahilyow"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "MSK",
    rawFormat: "+03:00 Moscow Time - Minsk, Homyel', Hrodna, Mahilyow"
  },
  {
    name: "Europe/Moscow",
    alternativeName: "Moscow Time",
    group: [
      "Europe/Kirov",
      "Europe/Moscow",
      "Europe/Volgograd",
      "W-SU"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Moscow",
      "Saint Petersburg",
      "Nizhniy Novgorod",
      "Kazan"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "MSK",
    rawFormat: "+03:00 Moscow Time - Moscow, Saint Petersburg, Nizhniy Novgorod, Kazan"
  },
  {
    name: "Europe/Simferopol",
    alternativeName: "Moscow Time",
    group: [
      "Europe/Simferopol"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Ukraine",
    countryCode: "UA",
    mainCities: [
      "Sevastopol",
      "Simferopol",
      "Kerch",
      "Yevpatoriya"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "MSK",
    rawFormat: "+03:00 Moscow Time - Sevastopol, Simferopol, Kerch, Yevpatoriya"
  },
  {
    name: "Antarctica/Syowa",
    alternativeName: "Syowa Time",
    group: [
      "Antarctica/Syowa"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "Syowa"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "SYOT",
    rawFormat: "+03:00 Syowa Time - Syowa"
  },
  {
    name: "Europe/Istanbul",
    alternativeName: "Turkey Time",
    group: [
      "Europe/Istanbul",
      "Turkey",
      "Asia/Istanbul"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Turkey",
    countryCode: "TR",
    mainCities: [
      "Istanbul",
      "Ankara",
      "Bursa",
      "\u0130zmir"
    ],
    rawOffsetInMinutes: 180,
    abbreviation: "TRT",
    rawFormat: "+03:00 Turkey Time - Istanbul, Ankara, Bursa, \u0130zmir"
  },
  {
    name: "Asia/Tehran",
    alternativeName: "Iran Time",
    group: [
      "Asia/Tehran",
      "Iran"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Iran",
    countryCode: "IR",
    mainCities: [
      "Tehran",
      "Mashhad",
      "Isfahan",
      "Karaj"
    ],
    rawOffsetInMinutes: 210,
    abbreviation: "IRST",
    rawFormat: "+03:30 Iran Time - Tehran, Mashhad, Isfahan, Karaj"
  },
  {
    name: "Asia/Yerevan",
    alternativeName: "Armenia Time",
    group: [
      "Asia/Yerevan"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Armenia",
    countryCode: "AM",
    mainCities: [
      "Yerevan",
      "Gyumri",
      "Vanadzor",
      "Vagharshapat"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "AMT",
    rawFormat: "+04:00 Armenia Time - Yerevan, Gyumri, Vanadzor, Vagharshapat"
  },
  {
    name: "Asia/Baku",
    alternativeName: "Azerbaijan Time",
    group: [
      "Asia/Baku"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Azerbaijan",
    countryCode: "AZ",
    mainCities: [
      "Baku",
      "Sumqay\u0131t",
      "Ganja",
      "Lankaran"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "AZT",
    rawFormat: "+04:00 Azerbaijan Time - Baku, Sumqay\u0131t, Ganja, Lankaran"
  },
  {
    name: "Asia/Tbilisi",
    alternativeName: "Georgia Time",
    group: [
      "Asia/Tbilisi"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Georgia",
    countryCode: "GE",
    mainCities: [
      "Tbilisi",
      "Batumi",
      "Kutaisi",
      "Rustavi"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "GET",
    rawFormat: "+04:00 Georgia Time - Tbilisi, Batumi, Kutaisi, Rustavi"
  },
  {
    name: "Asia/Dubai",
    alternativeName: "Gulf Time",
    group: [
      "Asia/Dubai",
      "Asia/Muscat",
      "Indian/Mahe",
      "Indian/Reunion"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "United Arab Emirates",
    countryCode: "AE",
    mainCities: [
      "Dubai",
      "Abu Dhabi",
      "Sharjah",
      "Al Ain City"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "GST",
    rawFormat: "+04:00 Gulf Time - Dubai, Abu Dhabi, Sharjah, Al Ain City"
  },
  {
    name: "Asia/Muscat",
    alternativeName: "Gulf Time",
    group: [
      "Asia/Muscat"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Oman",
    countryCode: "OM",
    mainCities: [
      "Muscat",
      "Seeb",
      "Bawshar",
      "\u2018Ibr\u012B"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "GST",
    rawFormat: "+04:00 Gulf Time - Muscat, Seeb, Bawshar, \u2018Ibr\u012B"
  },
  {
    name: "Indian/Mauritius",
    alternativeName: "Mauritius Time",
    group: [
      "Indian/Mauritius"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Mauritius",
    countryCode: "MU",
    mainCities: [
      "Port Louis",
      "Vacoas",
      "Beau Bassin-Rose Hill",
      "Curepipe"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "MUT",
    rawFormat: "+04:00 Mauritius Time - Port Louis, Vacoas, Beau Bassin-Rose Hill, Curepipe"
  },
  {
    name: "Indian/Reunion",
    alternativeName: "R\xE9union Time",
    group: [
      "Indian/Reunion"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Reunion",
    countryCode: "RE",
    mainCities: [
      "Saint-Denis",
      "Saint-Paul",
      "Saint-Pierre",
      "Le Tampon"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "RET",
    rawFormat: "+04:00 R\xE9union Time - Saint-Denis, Saint-Paul, Saint-Pierre, Le Tampon"
  },
  {
    name: "Europe/Samara",
    alternativeName: "Samara Time",
    group: [
      "Europe/Astrakhan",
      "Europe/Samara",
      "Europe/Saratov",
      "Europe/Ulyanovsk"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Samara",
      "Saratov",
      "Tolyatti",
      "Izhevsk"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "SAMT",
    rawFormat: "+04:00 Samara Time - Samara, Saratov, Tolyatti, Izhevsk"
  },
  {
    name: "Indian/Mahe",
    alternativeName: "Seychelles Time",
    group: [
      "Indian/Mahe"
    ],
    continentCode: "AF",
    continentName: "Africa",
    countryName: "Seychelles",
    countryCode: "SC",
    mainCities: [
      "Victoria"
    ],
    rawOffsetInMinutes: 240,
    abbreviation: "SCT",
    rawFormat: "+04:00 Seychelles Time - Victoria"
  },
  {
    name: "Asia/Kabul",
    alternativeName: "Afghanistan Time",
    group: [
      "Asia/Kabul"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Afghanistan",
    countryCode: "AF",
    mainCities: [
      "Kabul",
      "Her\u0101t",
      "Maz\u0101r-e Shar\u012Bf",
      "Kandah\u0101r"
    ],
    rawOffsetInMinutes: 270,
    abbreviation: "AFT",
    rawFormat: "+04:30 Afghanistan Time - Kabul, Her\u0101t, Maz\u0101r-e Shar\u012Bf, Kandah\u0101r"
  },
  {
    name: "Asia/Almaty",
    alternativeName: "East Kazakhstan Time",
    group: [
      "Asia/Almaty",
      "Asia/Qostanay"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Kazakhstan",
    countryCode: "KZ",
    mainCities: [
      "Almaty",
      "Shymkent",
      "Karagandy",
      "Taraz"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "ALMT",
    rawFormat: "+05:00 East Kazakhstan Time - Almaty, Shymkent, Karagandy, Taraz"
  },
  {
    name: "Indian/Kerguelen",
    alternativeName: "French Southern & Antarctic Time",
    group: [
      "Indian/Kerguelen"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "French Southern Territories",
    countryCode: "TF",
    mainCities: [
      "Port-aux-Fran\xE7ais"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "FSAT",
    rawFormat: "+05:00 French Southern & Antarctic Time - Port-aux-Fran\xE7ais"
  },
  {
    name: "Indian/Maldives",
    alternativeName: "Maldives Time",
    group: [
      "Indian/Maldives",
      "Indian/Kerguelen"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Maldives",
    countryCode: "MV",
    mainCities: [
      "Male"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "MVT",
    rawFormat: "+05:00 Maldives Time - Male"
  },
  {
    name: "Antarctica/Mawson",
    alternativeName: "Mawson Time",
    group: [
      "Antarctica/Mawson",
      "Antarctica/Vostok"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "Mawson",
      "Vostok"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "MAWT",
    rawFormat: "+05:00 Mawson Time - Mawson, Vostok"
  },
  {
    name: "Asia/Karachi",
    alternativeName: "Pakistan Time",
    group: [
      "Asia/Karachi"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Pakistan",
    countryCode: "PK",
    mainCities: [
      "Karachi",
      "Lahore",
      "Faisalabad",
      "Rawalpindi"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "PKT",
    rawFormat: "+05:00 Pakistan Time - Karachi, Lahore, Faisalabad, Rawalpindi"
  },
  {
    name: "Asia/Dushanbe",
    alternativeName: "Tajikistan Time",
    group: [
      "Asia/Dushanbe"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Tajikistan",
    countryCode: "TJ",
    mainCities: [
      "Dushanbe",
      "Isfara",
      "Istaravshan",
      "K\u016Dlob"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "TJT",
    rawFormat: "+05:00 Tajikistan Time - Dushanbe, Isfara, Istaravshan, K\u016Dlob"
  },
  {
    name: "Asia/Ashgabat",
    alternativeName: "Turkmenistan Time",
    group: [
      "Asia/Ashgabat",
      "Asia/Ashkhabad"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Turkmenistan",
    countryCode: "TM",
    mainCities: [
      "Ashgabat",
      "T\xFCrkmenabat",
      "Da\u015Foguz",
      "Mary"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "TMT",
    rawFormat: "+05:00 Turkmenistan Time - Ashgabat, T\xFCrkmenabat, Da\u015Foguz, Mary"
  },
  {
    name: "Asia/Tashkent",
    alternativeName: "Uzbekistan Time",
    group: [
      "Asia/Samarkand",
      "Asia/Tashkent"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Uzbekistan",
    countryCode: "UZ",
    mainCities: [
      "Tashkent",
      "Namangan",
      "Samarkand",
      "Andijon"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "UZT",
    rawFormat: "+05:00 Uzbekistan Time - Tashkent, Namangan, Samarkand, Andijon"
  },
  {
    name: "Asia/Aqtobe",
    alternativeName: "West Kazakhstan Time",
    group: [
      "Asia/Aqtau",
      "Asia/Aqtobe",
      "Asia/Atyrau",
      "Asia/Oral",
      "Asia/Qyzylorda"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Kazakhstan",
    countryCode: "KZ",
    mainCities: [
      "Aktobe",
      "Kyzylorda",
      "Oral",
      "Atyrau"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "AQTT",
    rawFormat: "+05:00 West Kazakhstan Time - Aktobe, Kyzylorda, Oral, Atyrau"
  },
  {
    name: "Asia/Yekaterinburg",
    alternativeName: "Yekaterinburg Time",
    group: [
      "Asia/Yekaterinburg"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Yekaterinburg",
      "Chelyabinsk",
      "Ufa",
      "Perm"
    ],
    rawOffsetInMinutes: 300,
    abbreviation: "YEKT",
    rawFormat: "+05:00 Yekaterinburg Time - Yekaterinburg, Chelyabinsk, Ufa, Perm"
  },
  {
    name: "Asia/Colombo",
    alternativeName: "India Time",
    group: [
      "Asia/Colombo"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Sri Lanka",
    countryCode: "LK",
    mainCities: [
      "Colombo",
      "Dehiwala-Mount Lavinia",
      "Maharagama",
      "Jaffna"
    ],
    rawOffsetInMinutes: 330,
    abbreviation: "IST",
    rawFormat: "+05:30 India Time - Colombo, Dehiwala-Mount Lavinia, Maharagama, Jaffna"
  },
  {
    name: "Asia/Kolkata",
    alternativeName: "India Time",
    group: [
      "Asia/Kolkata",
      "Asia/Calcutta"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "India",
    countryCode: "IN",
    mainCities: [
      "Mumbai",
      "Delhi",
      "Bengaluru",
      "Hyder\u0101b\u0101d"
    ],
    rawOffsetInMinutes: 330,
    abbreviation: "IST",
    rawFormat: "+05:30 India Time - Mumbai, Delhi, Bengaluru, Hyder\u0101b\u0101d"
  },
  {
    name: "Asia/Kathmandu",
    alternativeName: "Nepal Time",
    group: [
      "Asia/Kathmandu",
      "Asia/Katmandu"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Nepal",
    countryCode: "NP",
    mainCities: [
      "Kathmandu",
      "Bharatpur",
      "P\u0101tan",
      "Birga\xF1j"
    ],
    rawOffsetInMinutes: 345,
    abbreviation: "NPT",
    rawFormat: "+05:45 Nepal Time - Kathmandu, Bharatpur, P\u0101tan, Birga\xF1j"
  },
  {
    name: "Asia/Dhaka",
    alternativeName: "Bangladesh Time",
    group: [
      "Asia/Dhaka",
      "Asia/Dacca"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Bangladesh",
    countryCode: "BD",
    mainCities: [
      "Dhaka",
      "Chattogram",
      "Khulna",
      "Rangpur"
    ],
    rawOffsetInMinutes: 360,
    abbreviation: "BST",
    rawFormat: "+06:00 Bangladesh Time - Dhaka, Chattogram, Khulna, Rangpur"
  },
  {
    name: "Asia/Thimphu",
    alternativeName: "Bhutan Time",
    group: [
      "Asia/Thimphu",
      "Asia/Thimbu"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Bhutan",
    countryCode: "BT",
    mainCities: [
      "Thimphu",
      "Phuntsholing",
      "Tsirang",
      "Pun\u0101kha"
    ],
    rawOffsetInMinutes: 360,
    abbreviation: "BTT",
    rawFormat: "+06:00 Bhutan Time - Thimphu, Phuntsholing, Tsirang, Pun\u0101kha"
  },
  {
    name: "Asia/Urumqi",
    alternativeName: "China Time",
    group: [
      "Asia/Urumqi",
      "Asia/Kashgar"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "China",
    countryCode: "CN",
    mainCities: [
      "\xDCr\xFCmqi",
      "Shihezi",
      "Korla",
      "Aksu"
    ],
    rawOffsetInMinutes: 360,
    abbreviation: "CST",
    rawFormat: "+06:00 China Time - \xDCr\xFCmqi, Shihezi, Korla, Aksu"
  },
  {
    name: "Indian/Chagos",
    alternativeName: "Indian Ocean Time",
    group: [
      "Indian/Chagos"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "British Indian Ocean Territory",
    countryCode: "IO",
    mainCities: [
      "Chagos"
    ],
    rawOffsetInMinutes: 360,
    abbreviation: "IOT",
    rawFormat: "+06:00 Indian Ocean Time - Chagos"
  },
  {
    name: "Asia/Bishkek",
    alternativeName: "Kyrgyzstan Time",
    group: [
      "Asia/Bishkek"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Kyrgyzstan",
    countryCode: "KG",
    mainCities: [
      "Bishkek",
      "Osh",
      "Jalal-Abad",
      "Karakol"
    ],
    rawOffsetInMinutes: 360,
    abbreviation: "KGT",
    rawFormat: "+06:00 Kyrgyzstan Time - Bishkek, Osh, Jalal-Abad, Karakol"
  },
  {
    name: "Asia/Omsk",
    alternativeName: "Omsk Time",
    group: [
      "Asia/Omsk"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Omsk",
      "Tara",
      "Kalachinsk",
      "Isil\u2019kul\u2019"
    ],
    rawOffsetInMinutes: 360,
    abbreviation: "OMST",
    rawFormat: "+06:00 Omsk Time - Omsk, Tara, Kalachinsk, Isil\u2019kul\u2019"
  },
  {
    name: "Indian/Cocos",
    alternativeName: "Cocos Islands Time",
    group: [
      "Indian/Cocos"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Cocos Islands",
    countryCode: "CC",
    mainCities: [
      "West Island"
    ],
    rawOffsetInMinutes: 390,
    abbreviation: "CCT",
    rawFormat: "+06:30 Cocos Islands Time - West Island"
  },
  {
    name: "Asia/Yangon",
    alternativeName: "Myanmar Time",
    group: [
      "Asia/Yangon",
      "Indian/Cocos",
      "Asia/Rangoon"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Myanmar",
    countryCode: "MM",
    mainCities: [
      "Yangon",
      "Mandalay",
      "Nay Pyi Taw",
      "Mawlamyine"
    ],
    rawOffsetInMinutes: 390,
    abbreviation: "MMT",
    rawFormat: "+06:30 Myanmar Time - Yangon, Mandalay, Nay Pyi Taw, Mawlamyine"
  },
  {
    name: "Indian/Christmas",
    alternativeName: "Christmas Island Time",
    group: [
      "Indian/Christmas"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Christmas Island",
    countryCode: "CX",
    mainCities: [
      "Flying Fish Cove"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "CXT",
    rawFormat: "+07:00 Christmas Island Time - Flying Fish Cove"
  },
  {
    name: "Antarctica/Davis",
    alternativeName: "Davis Time",
    group: [
      "Antarctica/Davis"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "Davis"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "DAVT",
    rawFormat: "+07:00 Davis Time - Davis"
  },
  {
    name: "Asia/Hovd",
    alternativeName: "Hovd Time",
    group: [
      "Asia/Hovd"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Mongolia",
    countryCode: "MN",
    mainCities: [
      "Ulaangom",
      "Khovd",
      "\xD6lgii",
      "Altai"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "HOVT",
    rawFormat: "+07:00 Hovd Time - Ulaangom, Khovd, \xD6lgii, Altai"
  },
  {
    name: "Asia/Bangkok",
    alternativeName: "Indochina Time",
    group: [
      "Asia/Bangkok",
      "Asia/Phnom_Penh",
      "Asia/Vientiane",
      "Indian/Christmas"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Thailand",
    countryCode: "TH",
    mainCities: [
      "Bangkok",
      "Samut Prakan",
      "Mueang Nonthaburi",
      "Chon Buri"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "ICT",
    rawFormat: "+07:00 Indochina Time - Bangkok, Samut Prakan, Mueang Nonthaburi, Chon Buri"
  },
  {
    name: "Asia/Ho_Chi_Minh",
    alternativeName: "Indochina Time",
    group: [
      "Asia/Ho_Chi_Minh",
      "Asia/Saigon"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Vietnam",
    countryCode: "VN",
    mainCities: [
      "Ho Chi Minh City",
      "Da Nang",
      "Bi\xEAn H\xF2a",
      "C\u1EA7n Th\u01A1"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "ICT",
    rawFormat: "+07:00 Indochina Time - Ho Chi Minh City, Da Nang, Bi\xEAn H\xF2a, C\u1EA7n Th\u01A1"
  },
  {
    name: "Asia/Phnom_Penh",
    alternativeName: "Indochina Time",
    group: [
      "Asia/Phnom_Penh"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Cambodia",
    countryCode: "KH",
    mainCities: [
      "Phnom Penh",
      "Takeo",
      "Siem Reap",
      "Battambang"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "ICT",
    rawFormat: "+07:00 Indochina Time - Phnom Penh, Takeo, Siem Reap, Battambang"
  },
  {
    name: "Asia/Vientiane",
    alternativeName: "Indochina Time",
    group: [
      "Asia/Vientiane"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Laos",
    countryCode: "LA",
    mainCities: [
      "Vientiane",
      "Savannakhet",
      "Pakse",
      "Thakh\xE8k"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "ICT",
    rawFormat: "+07:00 Indochina Time - Vientiane, Savannakhet, Pakse, Thakh\xE8k"
  },
  {
    name: "Asia/Novosibirsk",
    alternativeName: "Novosibirsk Time",
    group: [
      "Asia/Barnaul",
      "Asia/Krasnoyarsk",
      "Asia/Novokuznetsk",
      "Asia/Novosibirsk",
      "Asia/Tomsk"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Novosibirsk",
      "Krasnoyarsk",
      "Barnaul",
      "Tomsk"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "NOVT",
    rawFormat: "+07:00 Novosibirsk Time - Novosibirsk, Krasnoyarsk, Barnaul, Tomsk"
  },
  {
    name: "Asia/Jakarta",
    alternativeName: "Western Indonesia Time",
    group: [
      "Asia/Jakarta",
      "Asia/Pontianak"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Indonesia",
    countryCode: "ID",
    mainCities: [
      "Jakarta",
      "Surabaya",
      "Bekasi",
      "Bandung"
    ],
    rawOffsetInMinutes: 420,
    abbreviation: "WIB",
    rawFormat: "+07:00 Western Indonesia Time - Jakarta, Surabaya, Bekasi, Bandung"
  },
  {
    name: "Antarctica/Casey",
    alternativeName: "Australian Western Time",
    group: [
      "Antarctica/Casey"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "Casey"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "AWST",
    rawFormat: "+08:00 Australian Western Time - Casey"
  },
  {
    name: "Australia/Perth",
    alternativeName: "Australian Western Time",
    group: [
      "Australia/Perth",
      "Australia/West"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Australia",
    countryCode: "AU",
    mainCities: [
      "Perth",
      "Mandurah",
      "Bunbury",
      "Baldivis"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "AWST",
    rawFormat: "+08:00 Australian Western Time - Perth, Mandurah, Bunbury, Baldivis"
  },
  {
    name: "Asia/Brunei",
    alternativeName: "Brunei Darussalam Time",
    group: [
      "Asia/Brunei"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Brunei",
    countryCode: "BN",
    mainCities: [
      "Bandar Seri Begawan",
      "Sengkurong",
      "Mentiri",
      "Kuala Belait"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "BNT",
    rawFormat: "+08:00 Brunei Darussalam Time - Bandar Seri Begawan, Sengkurong, Mentiri, Kuala Belait"
  },
  {
    name: "Asia/Makassar",
    alternativeName: "Central Indonesia Time",
    group: [
      "Asia/Makassar",
      "Asia/Ujung_Pandang"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Indonesia",
    countryCode: "ID",
    mainCities: [
      "Makassar",
      "Samarinda",
      "Denpasar",
      "Balikpapan"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "WITA",
    rawFormat: "+08:00 Central Indonesia Time - Makassar, Samarinda, Denpasar, Balikpapan"
  },
  {
    name: "Asia/Macau",
    alternativeName: "China Time",
    group: [
      "Asia/Macau",
      "Asia/Macao"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Macao",
    countryCode: "MO",
    mainCities: [
      "Macau",
      "Taipa",
      "Luhuan",
      "Lai Chi Van"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "CST",
    rawFormat: "+08:00 China Time - Macau, Taipa, Luhuan, Lai Chi Van"
  },
  {
    name: "Asia/Shanghai",
    alternativeName: "China Time",
    group: [
      "Asia/Shanghai",
      "PRC",
      "Asia/Chongqing",
      "Asia/Harbin",
      "Asia/Chungking"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "China",
    countryCode: "CN",
    mainCities: [
      "Shanghai",
      "Beijing",
      "Shenzhen",
      "Guangzhou"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "CST",
    rawFormat: "+08:00 China Time - Shanghai, Beijing, Shenzhen, Guangzhou"
  },
  {
    name: "Asia/Hong_Kong",
    alternativeName: "Hong Kong Time",
    group: [
      "Asia/Hong_Kong",
      "Hongkong"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Hong Kong",
    countryCode: "HK",
    mainCities: [
      "Hong Kong",
      "New Territories",
      "Kowloon",
      "Hong Kong Island"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "HKT",
    rawFormat: "+08:00 Hong Kong Time - Hong Kong, New Territories, Kowloon, Hong Kong Island"
  },
  {
    name: "Asia/Irkutsk",
    alternativeName: "Irkutsk Time",
    group: [
      "Asia/Irkutsk"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Irkutsk",
      "Ulan-Ude",
      "Bratsk",
      "Angarsk"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "IRKT",
    rawFormat: "+08:00 Irkutsk Time - Irkutsk, Ulan-Ude, Bratsk, Angarsk"
  },
  {
    name: "Asia/Kuala_Lumpur",
    alternativeName: "Malaysia Time",
    group: [
      "Asia/Kuala_Lumpur",
      "Asia/Kuching",
      "Asia/Brunei"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Malaysia",
    countryCode: "MY",
    mainCities: [
      "Kuala Lumpur",
      "Petaling Jaya",
      "Klang",
      "Johor Bahru"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "MYT",
    rawFormat: "+08:00 Malaysia Time - Kuala Lumpur, Petaling Jaya, Klang, Johor Bahru"
  },
  {
    name: "Asia/Manila",
    alternativeName: "Philippine Time",
    group: [
      "Asia/Manila"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Philippines",
    countryCode: "PH",
    mainCities: [
      "Quezon City",
      "Davao",
      "Manila",
      "Caloocan City"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "PHT",
    rawFormat: "+08:00 Philippine Time - Quezon City, Davao, Manila, Caloocan City"
  },
  {
    name: "Asia/Singapore",
    alternativeName: "Singapore Time",
    group: [
      "Asia/Singapore",
      "Singapore",
      "Asia/Kuala_Lumpur"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Singapore",
    countryCode: "SG",
    mainCities: [
      "Singapore",
      "Ulu Bedok",
      "Bedok New Town",
      "Tampines Estate"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "SGT",
    rawFormat: "+08:00 Singapore Time - Singapore, Ulu Bedok, Bedok New Town, Tampines Estate"
  },
  {
    name: "Asia/Taipei",
    alternativeName: "Taipei Time",
    group: [
      "Asia/Taipei",
      "ROC"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Taiwan",
    countryCode: "TW",
    mainCities: [
      "Taipei",
      "Kaohsiung",
      "Taichung",
      "Tainan"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "TWT",
    rawFormat: "+08:00 Taipei Time - Taipei, Kaohsiung, Taichung, Tainan"
  },
  {
    name: "Asia/Ulaanbaatar",
    alternativeName: "Ulaanbaatar Time",
    group: [
      "Asia/Choibalsan",
      "Asia/Ulaanbaatar",
      "Asia/Ulan_Bator"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Mongolia",
    countryCode: "MN",
    mainCities: [
      "Ulan Bator",
      "Erdenet",
      "Darhan",
      "M\xF6r\xF6n"
    ],
    rawOffsetInMinutes: 480,
    abbreviation: "ULAT",
    rawFormat: "+08:00 Ulaanbaatar Time - Ulan Bator, Erdenet, Darhan, M\xF6r\xF6n"
  },
  {
    name: "Australia/Eucla",
    alternativeName: "Australian Central Western Time",
    group: [
      "Australia/Eucla"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Australia",
    countryCode: "AU",
    mainCities: [
      "Eucla"
    ],
    rawOffsetInMinutes: 525,
    abbreviation: "ACWST",
    rawFormat: "+08:45 Australian Central Western Time - Eucla"
  },
  {
    name: "Asia/Dili",
    alternativeName: "East Timor Time",
    group: [
      "Asia/Dili"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Timor Leste",
    countryCode: "TL",
    mainCities: [
      "Dili",
      "Maliana",
      "Suai",
      "Likis\xE1"
    ],
    rawOffsetInMinutes: 540,
    abbreviation: "TLT",
    rawFormat: "+09:00 East Timor Time - Dili, Maliana, Suai, Likis\xE1"
  },
  {
    name: "Asia/Jayapura",
    alternativeName: "Eastern Indonesia Time",
    group: [
      "Asia/Jayapura"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Indonesia",
    countryCode: "ID",
    mainCities: [
      "Jayapura",
      "Ambon",
      "Sorong",
      "Ternate"
    ],
    rawOffsetInMinutes: 540,
    abbreviation: "WIT",
    rawFormat: "+09:00 Eastern Indonesia Time - Jayapura, Ambon, Sorong, Ternate"
  },
  {
    name: "Asia/Tokyo",
    alternativeName: "Japan Time",
    group: [
      "Asia/Tokyo",
      "Japan"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "Japan",
    countryCode: "JP",
    mainCities: [
      "Tokyo",
      "Yokohama",
      "Osaka",
      "Nagoya"
    ],
    rawOffsetInMinutes: 540,
    abbreviation: "JST",
    rawFormat: "+09:00 Japan Time - Tokyo, Yokohama, Osaka, Nagoya"
  },
  {
    name: "Asia/Pyongyang",
    alternativeName: "Korean Time",
    group: [
      "Asia/Pyongyang"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "North Korea",
    countryCode: "KP",
    mainCities: [
      "Pyongyang",
      "Hamh\u016Dng",
      "Namp\u2019o",
      "Sunch\u2019\u014Fn"
    ],
    rawOffsetInMinutes: 540,
    abbreviation: "KST",
    rawFormat: "+09:00 Korean Time - Pyongyang, Hamh\u016Dng, Namp\u2019o, Sunch\u2019\u014Fn"
  },
  {
    name: "Asia/Seoul",
    alternativeName: "Korean Time",
    group: [
      "Asia/Seoul",
      "ROK"
    ],
    continentCode: "AS",
    continentName: "Asia",
    countryName: "South Korea",
    countryCode: "KR",
    mainCities: [
      "Seoul",
      "Busan",
      "Incheon",
      "Daegu"
    ],
    rawOffsetInMinutes: 540,
    abbreviation: "KST",
    rawFormat: "+09:00 Korean Time - Seoul, Busan, Incheon, Daegu"
  },
  {
    name: "Pacific/Palau",
    alternativeName: "Palau Time",
    group: [
      "Pacific/Palau"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Palau",
    countryCode: "PW",
    mainCities: [
      "Ngerulmud"
    ],
    rawOffsetInMinutes: 540,
    abbreviation: "PWT",
    rawFormat: "+09:00 Palau Time - Ngerulmud"
  },
  {
    name: "Asia/Chita",
    alternativeName: "Yakutsk Time",
    group: [
      "Asia/Chita",
      "Asia/Khandyga",
      "Asia/Yakutsk"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Chita",
      "Yakutsk",
      "Blagoveshchensk",
      "Belogorsk"
    ],
    rawOffsetInMinutes: 540,
    abbreviation: "YAKT",
    rawFormat: "+09:00 Yakutsk Time - Chita, Yakutsk, Blagoveshchensk, Belogorsk"
  },
  {
    name: "Australia/Adelaide",
    alternativeName: "Australian Central Time",
    group: [
      "Australia/Adelaide",
      "Australia/Broken_Hill",
      "Australia/South",
      "Australia/Yancowinna"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Australia",
    countryCode: "AU",
    mainCities: [
      "Adelaide",
      "Adelaide Hills",
      "Mount Gambier",
      "Morphett Vale"
    ],
    rawOffsetInMinutes: 570,
    abbreviation: "ACST",
    rawFormat: "+09:30 Australian Central Time - Adelaide, Adelaide Hills, Mount Gambier, Morphett Vale"
  },
  {
    name: "Australia/Darwin",
    alternativeName: "Australian Central Time",
    group: [
      "Australia/Darwin",
      "Australia/North"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Australia",
    countryCode: "AU",
    mainCities: [
      "Darwin",
      "Alice Springs",
      "Palmerston"
    ],
    rawOffsetInMinutes: 570,
    abbreviation: "ACST",
    rawFormat: "+09:30 Australian Central Time - Darwin, Alice Springs, Palmerston"
  },
  {
    name: "Australia/Brisbane",
    alternativeName: "Australian Eastern Time",
    group: [
      "Australia/Brisbane",
      "Australia/Lindeman",
      "Australia/Queensland"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Australia",
    countryCode: "AU",
    mainCities: [
      "Brisbane",
      "Gold Coast",
      "Logan City",
      "Townsville"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "AEST",
    rawFormat: "+10:00 Australian Eastern Time - Brisbane, Gold Coast, Logan City, Townsville"
  },
  {
    name: "Australia/Sydney",
    alternativeName: "Australian Eastern Time",
    group: [
      "Antarctica/Macquarie",
      "Australia/Hobart",
      "Australia/Melbourne",
      "Australia/Sydney",
      "Australia/Tasmania",
      "Australia/Currie",
      "Australia/Victoria",
      "Australia/ACT",
      "Australia/NSW",
      "Australia/Canberra"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Australia",
    countryCode: "AU",
    mainCities: [
      "Sydney",
      "Melbourne",
      "Canberra",
      "Newcastle"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "AEST",
    rawFormat: "+10:00 Australian Eastern Time - Sydney, Melbourne, Canberra, Newcastle"
  },
  {
    name: "Pacific/Guam",
    alternativeName: "Chamorro Time",
    group: [
      "Pacific/Guam",
      "Pacific/Saipan"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Guam",
    countryCode: "GU",
    mainCities: [
      "Dededo Village",
      "Yigo Village",
      "Tamuning-Tumon-Harmon Village",
      "Tamuning"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "ChST",
    rawFormat: "+10:00 Chamorro Time - Dededo Village, Yigo Village, Tamuning-Tumon-Harmon Village, Tamuning"
  },
  {
    name: "Pacific/Saipan",
    alternativeName: "Chamorro Time",
    group: [
      "Pacific/Saipan"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Northern Mariana Islands",
    countryCode: "MP",
    mainCities: [
      "Saipan"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "ChST",
    rawFormat: "+10:00 Chamorro Time - Saipan"
  },
  {
    name: "Pacific/Chuuk",
    alternativeName: "Chuuk Time",
    group: [
      "Pacific/Chuuk",
      "Pacific/Truk",
      "Pacific/Yap"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Micronesia",
    countryCode: "FM",
    mainCities: [
      "Chuuk"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "CHUT",
    rawFormat: "+10:00 Chuuk Time - Chuuk"
  },
  {
    name: "Antarctica/DumontDUrville",
    alternativeName: "Dumont-d\u2019Urville Time",
    group: [
      "Antarctica/DumontDUrville"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "DumontDUrville"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "DDUT",
    rawFormat: "+10:00 Dumont-d\u2019Urville Time - DumontDUrville"
  },
  {
    name: "Pacific/Port_Moresby",
    alternativeName: "Papua New Guinea Time",
    group: [
      "Pacific/Port_Moresby",
      "Antarctica/DumontDUrville",
      "Pacific/Chuuk",
      "Pacific/Yap",
      "Pacific/Truk"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Papua New Guinea",
    countryCode: "PG",
    mainCities: [
      "Port Moresby",
      "Lae",
      "Mount Hagen",
      "Popondetta"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "PGT",
    rawFormat: "+10:00 Papua New Guinea Time - Port Moresby, Lae, Mount Hagen, Popondetta"
  },
  {
    name: "Asia/Vladivostok",
    alternativeName: "Vladivostok Time",
    group: [
      "Asia/Ust-Nera",
      "Asia/Vladivostok"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Khabarovsk",
      "Vladivostok",
      "Khabarovsk Vtoroy",
      "Komsomolsk-on-Amur"
    ],
    rawOffsetInMinutes: 600,
    abbreviation: "VLAT",
    rawFormat: "+10:00 Vladivostok Time - Khabarovsk, Vladivostok, Khabarovsk Vtoroy, Komsomolsk-on-Amur"
  },
  {
    name: "Australia/Lord_Howe",
    alternativeName: "Lord Howe Time",
    group: [
      "Australia/Lord_Howe",
      "Australia/LHI"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Australia",
    countryCode: "AU",
    mainCities: [
      "Lord Howe"
    ],
    rawOffsetInMinutes: 630,
    abbreviation: "LHST",
    rawFormat: "+10:30 Lord Howe Time - Lord Howe"
  },
  {
    name: "Pacific/Bougainville",
    alternativeName: "Bougainville Time",
    group: [
      "Pacific/Bougainville"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Papua New Guinea",
    countryCode: "PG",
    mainCities: [
      "Arawa"
    ],
    rawOffsetInMinutes: 660,
    abbreviation: "BST",
    rawFormat: "+11:00 Bougainville Time - Arawa"
  },
  {
    name: "Pacific/Kosrae",
    alternativeName: "Kosrae Time",
    group: [
      "Pacific/Kosrae",
      "Pacific/Pohnpei"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Micronesia",
    countryCode: "FM",
    mainCities: [
      "Kosrae",
      "Palikir - National Government Center"
    ],
    rawOffsetInMinutes: 660,
    abbreviation: "KOST",
    rawFormat: "+11:00 Kosrae Time - Kosrae, Palikir - National Government Center"
  },
  {
    name: "Pacific/Noumea",
    alternativeName: "New Caledonia Time",
    group: [
      "Pacific/Noumea"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "New Caledonia",
    countryCode: "NC",
    mainCities: [
      "Noum\xE9a",
      "Mont-Dore",
      "Dumb\xE9a"
    ],
    rawOffsetInMinutes: 660,
    abbreviation: "NCT",
    rawFormat: "+11:00 New Caledonia Time - Noum\xE9a, Mont-Dore, Dumb\xE9a"
  },
  {
    name: "Pacific/Norfolk",
    alternativeName: "Norfolk Island Time",
    group: [
      "Pacific/Norfolk"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Norfolk Island",
    countryCode: "NF",
    mainCities: [
      "Kingston"
    ],
    rawOffsetInMinutes: 660,
    abbreviation: "NFT",
    rawFormat: "+11:00 Norfolk Island Time - Kingston"
  },
  {
    name: "Asia/Sakhalin",
    alternativeName: "Sakhalin Time",
    group: [
      "Asia/Magadan",
      "Asia/Sakhalin",
      "Asia/Srednekolymsk"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Yuzhno-Sakhalinsk",
      "Magadan",
      "Korsakov",
      "Kholmsk"
    ],
    rawOffsetInMinutes: 660,
    abbreviation: "SAKT",
    rawFormat: "+11:00 Sakhalin Time - Yuzhno-Sakhalinsk, Magadan, Korsakov, Kholmsk"
  },
  {
    name: "Pacific/Guadalcanal",
    alternativeName: "Solomon Islands Time",
    group: [
      "Pacific/Guadalcanal",
      "Pacific/Pohnpei",
      "Pacific/Ponape"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Solomon Islands",
    countryCode: "SB",
    mainCities: [
      "Honiara"
    ],
    rawOffsetInMinutes: 660,
    abbreviation: "SBT",
    rawFormat: "+11:00 Solomon Islands Time - Honiara"
  },
  {
    name: "Pacific/Efate",
    alternativeName: "Vanuatu Time",
    group: [
      "Pacific/Efate"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Vanuatu",
    countryCode: "VU",
    mainCities: [
      "Port-Vila"
    ],
    rawOffsetInMinutes: 660,
    abbreviation: "VUT",
    rawFormat: "+11:00 Vanuatu Time - Port-Vila"
  },
  {
    name: "Pacific/Fiji",
    alternativeName: "Fiji Time",
    group: [
      "Pacific/Fiji"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Fiji",
    countryCode: "FJ",
    mainCities: [
      "Nasinu",
      "Suva",
      "Lautoka",
      "Nadi"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "FJT",
    rawFormat: "+12:00 Fiji Time - Nasinu, Suva, Lautoka, Nadi"
  },
  {
    name: "Pacific/Tarawa",
    alternativeName: "Gilbert Islands Time",
    group: [
      "Pacific/Tarawa",
      "Pacific/Funafuti",
      "Pacific/Majuro",
      "Pacific/Wake",
      "Pacific/Wallis"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Kiribati",
    countryCode: "KI",
    mainCities: [
      "Tarawa"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "GILT",
    rawFormat: "+12:00 Gilbert Islands Time - Tarawa"
  },
  {
    name: "Pacific/Majuro",
    alternativeName: "Marshall Islands Time",
    group: [
      "Pacific/Kwajalein",
      "Pacific/Majuro",
      "Kwajalein"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Marshall Islands",
    countryCode: "MH",
    mainCities: [
      "Majuro",
      "Kwajalein",
      "RMI Capitol"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "MHT",
    rawFormat: "+12:00 Marshall Islands Time - Majuro, Kwajalein, RMI Capitol"
  },
  {
    name: "Pacific/Nauru",
    alternativeName: "Nauru Time",
    group: [
      "Pacific/Nauru"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Nauru",
    countryCode: "NR",
    mainCities: [
      "Yaren"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "NRT",
    rawFormat: "+12:00 Nauru Time - Yaren"
  },
  {
    name: "Pacific/Auckland",
    alternativeName: "New Zealand Time",
    group: [
      "Pacific/Auckland",
      "NZ",
      "Antarctica/McMurdo",
      "Antarctica/South_Pole"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "New Zealand",
    countryCode: "NZ",
    mainCities: [
      "Auckland",
      "Wellington",
      "Christchurch",
      "Manukau City"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "NZST",
    rawFormat: "+12:00 New Zealand Time - Auckland, Wellington, Christchurch, Manukau City"
  },
  {
    name: "Antarctica/McMurdo",
    alternativeName: "New Zealand Time",
    group: [
      "Antarctica/McMurdo"
    ],
    continentCode: "AN",
    continentName: "Antarctica",
    countryName: "Antarctica",
    countryCode: "AQ",
    mainCities: [
      "McMurdo"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "NZST",
    rawFormat: "+12:00 New Zealand Time - McMurdo"
  },
  {
    name: "Asia/Kamchatka",
    alternativeName: "Petropavlovsk-Kamchatski Time",
    group: [
      "Asia/Anadyr",
      "Asia/Kamchatka"
    ],
    continentCode: "EU",
    continentName: "Europe",
    countryName: "Russia",
    countryCode: "RU",
    mainCities: [
      "Petropavlovsk-Kamchatsky",
      "Yelizovo",
      "Vilyuchinsk",
      "Anadyr"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "PETT",
    rawFormat: "+12:00 Petropavlovsk-Kamchatski Time - Petropavlovsk-Kamchatsky, Yelizovo, Vilyuchinsk, Anadyr"
  },
  {
    name: "Pacific/Funafuti",
    alternativeName: "Tuvalu Time",
    group: [
      "Pacific/Funafuti"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Tuvalu",
    countryCode: "TV",
    mainCities: [
      "Funafuti"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "TVT",
    rawFormat: "+12:00 Tuvalu Time - Funafuti"
  },
  {
    name: "Pacific/Wake",
    alternativeName: "Wake Island Time",
    group: [
      "Pacific/Wake"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "United States Minor Outlying Islands",
    countryCode: "UM",
    mainCities: [
      "Wake"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "WAKT",
    rawFormat: "+12:00 Wake Island Time - Wake"
  },
  {
    name: "Pacific/Wallis",
    alternativeName: "Wallis & Futuna Time",
    group: [
      "Pacific/Wallis"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Wallis and Futuna",
    countryCode: "WF",
    mainCities: [
      "Mata-Utu"
    ],
    rawOffsetInMinutes: 720,
    abbreviation: "WFT",
    rawFormat: "+12:00 Wallis & Futuna Time - Mata-Utu"
  },
  {
    name: "Pacific/Chatham",
    alternativeName: "Chatham Time",
    group: [
      "Pacific/Chatham",
      "NZ-CHAT"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "New Zealand",
    countryCode: "NZ",
    mainCities: [
      "Chatham"
    ],
    rawOffsetInMinutes: 765,
    abbreviation: "CHAST",
    rawFormat: "+12:45 Chatham Time - Chatham"
  },
  {
    name: "Pacific/Apia",
    alternativeName: "Apia Time",
    group: [
      "Pacific/Apia"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Samoa",
    countryCode: "WS",
    mainCities: [
      "Apia"
    ],
    rawOffsetInMinutes: 780,
    abbreviation: "WST",
    rawFormat: "+13:00 Apia Time - Apia"
  },
  {
    name: "Pacific/Kanton",
    alternativeName: "Phoenix Islands Time",
    group: [
      "Pacific/Kanton",
      "Pacific/Enderbury"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Kiribati",
    countryCode: "KI",
    mainCities: [
      "Kanton"
    ],
    rawOffsetInMinutes: 780,
    abbreviation: "PHOT",
    rawFormat: "+13:00 Phoenix Islands Time - Kanton"
  },
  {
    name: "Pacific/Fakaofo",
    alternativeName: "Tokelau Time",
    group: [
      "Pacific/Fakaofo"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Tokelau",
    countryCode: "TK",
    mainCities: [
      "Fakaofo"
    ],
    rawOffsetInMinutes: 780,
    abbreviation: "TKT",
    rawFormat: "+13:00 Tokelau Time - Fakaofo"
  },
  {
    name: "Pacific/Tongatapu",
    alternativeName: "Tonga Time",
    group: [
      "Pacific/Tongatapu"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Tonga",
    countryCode: "TO",
    mainCities: [
      "Nuku\u2018alofa"
    ],
    rawOffsetInMinutes: 780,
    abbreviation: "TOT",
    rawFormat: "+13:00 Tonga Time - Nuku\u2018alofa"
  },
  {
    name: "Pacific/Kiritimati",
    alternativeName: "Line Islands Time",
    group: [
      "Pacific/Kiritimati"
    ],
    continentCode: "OC",
    continentName: "Oceania",
    countryName: "Kiribati",
    countryCode: "KI",
    mainCities: [
      "Kiritimati"
    ],
    rawOffsetInMinutes: 840,
    abbreviation: "LINT",
    rawFormat: "+14:00 Line Islands Time - Kiritimati"
  }
];
function format$1({
  alternativeName,
  mainCities,
  rawOffsetInMinutes,
  currentTimeOffsetInMinutes
}, { useCurrentOffset = !1 } = {}) {
  return `${getOffsetString(useCurrentOffset ? currentTimeOffsetInMinutes : rawOffsetInMinutes).padStart(
    6,
    "+"
  )} ${alternativeName} - ${mainCities.join(", ")}`;
}
function getOffsetString(offsetInMinutes) {
  const absOffsetInMinutes = Math.abs(offsetInMinutes), [hours, minutes] = [
    Math.floor(absOffsetInMinutes / 60),
    absOffsetInMinutes % 60
  ].map((v) => v.toString().padStart(2, "0")), durationInHoursMinutes = `${hours}:${minutes}`;
  return `${offsetInMinutes >= 0 ? "+" : "-"}${durationInHoursMinutes}`;
}
const ianaRegex = /^[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?$/, typeToPos$1 = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function isValidIanaSpecifier(s) {
  return !!(s && s.match(ianaRegex));
}
function hackyOffset$1(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
}
function partsOffset$1(dtf, date) {
  const formatted = dtf.formatToParts(date), filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i], pos = typeToPos$1[type];
    typeof pos < "u" && (filled[pos] = parseInt(value, 10));
  }
  return filled;
}
function makeDTF(zone) {
  return new Intl.DateTimeFormat("en-US", {
    hourCycle: "h23",
    timeZone: zone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  });
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  return obj.year < 100 && obj.year >= 0 && (d = new Date(d), d.setUTCFullYear(d.getUTCFullYear() - 1900)), +d;
}
function getZoneOffset(timeZoneName) {
  if (!isValidIanaSpecifier(timeZoneName))
    return !1;
  const date = new Date(Date.now());
  let dtf;
  try {
    dtf = makeDTF(timeZoneName);
  } catch {
    return !1;
  }
  const [year, month, day, hour, minute, second] = dtf.formatToParts ? partsOffset$1(dtf, date) : hackyOffset$1(dtf, date), asUTC = objToLocalTS({
    year,
    month,
    day,
    hour,
    minute,
    second,
    millisecond: 0
  });
  let asTS = +date;
  const over = asTS % 1e3;
  return asTS -= over >= 0 ? over : 1e3 + over, (asUTC - asTS) / (60 * 1e3);
}
function getTimeZones(opts) {
  return rawTimeZones.reduce(
    function(acc, timeZone) {
      const timeZoneName = timeZone.name, currentOffset = getZoneOffset(timeZoneName);
      if (currentOffset === !1)
        return acc;
      const timeZoneWithCurrentTimeData = {
        ...timeZone,
        currentTimeOffsetInMinutes: currentOffset
      };
      return acc.push({
        ...timeZoneWithCurrentTimeData,
        currentTimeFormat: format$1(timeZoneWithCurrentTimeData, {
          useCurrentOffset: !0
        })
      }), acc;
    },
    []
  ).sort((a, b) => compareNumbers(a, b) || compareStrings(a.alternativeName, b.alternativeName) || compareStrings(a.mainCities[0], b.mainCities[0]));
}
function compareNumbers(x, y) {
  return x.currentTimeOffsetInMinutes - y.currentTimeOffsetInMinutes;
}
function compareStrings(x, y) {
  return typeof x == "string" && typeof y == "string" ? x.localeCompare(y) : 0;
}
function tzIntlTimeZoneName(length, date, options) {
  var dtf = getDTF(length, options.timeZone, options.locale);
  return dtf.formatToParts ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);
}
function partsTimeZone(dtf, date) {
  for (var formatted = dtf.formatToParts(date), i = formatted.length - 1; i >= 0; --i)
    if (formatted[i].type === "timeZoneName")
      return formatted[i].value;
}
function hackyTimeZone(dtf, date) {
  var formatted = dtf.format(date).replace(/\u200E/g, ""), tzNameMatch = / [\w-+ ]+$/.exec(formatted);
  return tzNameMatch ? tzNameMatch[0].substr(1) : "";
}
function getDTF(length, timeZone, locale) {
  if (locale && !locale.code)
    throw new Error(
      "date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`"
    );
  return new Intl.DateTimeFormat(locale ? [locale.code, "en-US"] : void 0, {
    timeZone,
    timeZoneName: length
  });
}
function tzTokenizeDate(date, timeZone) {
  var dtf = getDateTimeFormat(timeZone);
  return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function partsOffset(dtf, date) {
  try {
    for (var formatted = dtf.formatToParts(date), filled = [], i = 0; i < formatted.length; i++) {
      var pos = typeToPos[formatted[i].type];
      pos >= 0 && (filled[pos] = parseInt(formatted[i].value, 10));
    }
    return filled;
  } catch (error) {
    if (error instanceof RangeError)
      return [NaN];
    throw error;
  }
}
function hackyOffset(dtf, date) {
  var formatted = dtf.format(date), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
  return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
}
var dtfCache = {};
function getDateTimeFormat(timeZone) {
  if (!dtfCache[timeZone]) {
    var testDateFormatted = new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "\u200E06\u200E/\u200E25\u200E/\u200E2014\u200E \u200E00\u200E:\u200E00\u200E:\u200E00";
    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return dtfCache[timeZone];
}
function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
  var utcDate = /* @__PURE__ */ new Date(0);
  return utcDate.setUTCFullYear(fullYear, month, day), utcDate.setUTCHours(hour, minute, second, millisecond), utcDate;
}
var MILLISECONDS_IN_HOUR$1 = 36e5, MILLISECONDS_IN_MINUTE$2 = 6e4, patterns$1 = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
function tzParseTimezone(timezoneString, date, isUtcDate) {
  var token, absoluteOffset;
  if (!timezoneString || (token = patterns$1.timezoneZ.exec(timezoneString), token))
    return 0;
  var hours;
  if (token = patterns$1.timezoneHH.exec(timezoneString), token)
    return hours = parseInt(token[1], 10), validateTimezone(hours) ? -(hours * MILLISECONDS_IN_HOUR$1) : NaN;
  if (token = patterns$1.timezoneHHMM.exec(timezoneString), token) {
    hours = parseInt(token[2], 10);
    var minutes = parseInt(token[3], 10);
    return validateTimezone(hours, minutes) ? (absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2, token[1] === "+" ? -absoluteOffset : absoluteOffset) : NaN;
  }
  if (isValidTimezoneIANAString(timezoneString)) {
    date = new Date(date || Date.now());
    var utcDate = isUtcDate ? date : toUtcDate(date), offset = calcOffset(utcDate, timezoneString), fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
    return -fixedOffset;
  }
  return NaN;
}
function toUtcDate(date) {
  return newDateUTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  );
}
function calcOffset(date, timezoneString) {
  var tokens = tzTokenizeDate(date, timezoneString), asUTC = newDateUTC(
    tokens[0],
    tokens[1] - 1,
    tokens[2],
    tokens[3] % 24,
    tokens[4],
    tokens[5],
    0
  ).getTime(), asTS = date.getTime(), over = asTS % 1e3;
  return asTS -= over >= 0 ? over : 1e3 + over, asUTC - asTS;
}
function fixOffset(date, offset, timezoneString) {
  var localTS = date.getTime(), utcGuess = localTS - offset, o2 = calcOffset(new Date(utcGuess), timezoneString);
  if (offset === o2)
    return offset;
  utcGuess -= o2 - offset;
  var o3 = calcOffset(new Date(utcGuess), timezoneString);
  return o2 === o3 ? o2 : Math.max(o2, o3);
}
function validateTimezone(hours, minutes) {
  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
}
var validIANATimezoneCache = {};
function isValidTimezoneIANAString(timeZoneString) {
  if (validIANATimezoneCache[timeZoneString]) return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString }), validIANATimezoneCache[timeZoneString] = !0, !0;
  } catch {
    return !1;
  }
}
var MILLISECONDS_IN_MINUTE$1 = 60 * 1e3, formatters = {
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, localize, options) {
    var timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    if (timezoneOffset === 0)
      return "Z";
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, localize, options) {
    var timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, localize, options) {
    var timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, localize, options) {
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return tzIntlTimeZoneName("short", date, options);
      case "zzzz":
      default:
        return tzIntlTimeZoneName("long", date, options);
    }
  }
};
function getTimeZoneOffset(timeZone, originalDate) {
  var timeZoneOffset = timeZone ? tzParseTimezone(timeZone, originalDate, !0) / MILLISECONDS_IN_MINUTE$1 : originalDate.getTimezoneOffset();
  if (Number.isNaN(timeZoneOffset))
    throw new RangeError("Invalid time zone specified: " + timeZone);
  return timeZoneOffset;
}
function addLeadingZeros(number, targetLength) {
  for (var sign = number < 0 ? "-" : "", output = Math.abs(number).toString(); output.length < targetLength; )
    output = "0" + output;
  return sign + output;
}
function formatTimezone(offset, dirtyDelimeter) {
  var delimeter = dirtyDelimeter || "", sign = offset > 0 ? "-" : "+", absOffset = Math.abs(offset), hours = addLeadingZeros(Math.floor(absOffset / 60), 2), minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
  return sign + hours + delimeter + minutes;
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimeter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimeter);
}
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+", absOffset = Math.abs(offset), hours = Math.floor(absOffset / 60), minutes = absOffset % 60;
  if (minutes === 0)
    return sign + String(hours);
  var delimiter = dirtyDelimiter;
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
var formatters$1 = formatters, tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, MILLISECONDS_IN_HOUR = 36e5, MILLISECONDS_IN_MINUTE = 6e4, DEFAULT_ADDITIONAL_DIGITS = 2, patterns = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: tzPattern
};
function toDate(argument, dirtyOptions) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (argument === null)
    return /* @__PURE__ */ new Date(NaN);
  var options = dirtyOptions || {}, additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger__default.default(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (argument instanceof Date || typeof argument == "object" && Object.prototype.toString.call(argument) === "[object Date]")
    return new Date(argument.getTime());
  if (typeof argument == "number" || Object.prototype.toString.call(argument) === "[object Number]")
    return new Date(argument);
  if (!(typeof argument == "string" || Object.prototype.toString.call(argument) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var dateStrings = splitDateString(argument), parseYearResult = parseYear(dateStrings.date, additionalDigits), year = parseYearResult.year, restDateString = parseYearResult.restDateString, date = parseDate(restDateString, year);
  if (isNaN(date))
    return /* @__PURE__ */ new Date(NaN);
  if (date) {
    var timestamp = date.getTime(), time = 0, offset;
    if (dateStrings.time && (time = parseTime(dateStrings.time), isNaN(time)))
      return /* @__PURE__ */ new Date(NaN);
    if (dateStrings.timeZone || options.timeZone) {
      if (offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time)), isNaN(offset))
        return /* @__PURE__ */ new Date(NaN);
    } else
      offset = getTimezoneOffsetInMilliseconds__default.default(new Date(timestamp + time)), offset = getTimezoneOffsetInMilliseconds__default.default(new Date(timestamp + time + offset));
    return new Date(timestamp + time + offset);
  } else
    return /* @__PURE__ */ new Date(NaN);
}
function splitDateString(dateString) {
  var dateStrings = {}, parts = patterns.dateTimePattern.exec(dateString), timeString;
  if (parts ? (dateStrings.date = parts[1], timeString = parts[3]) : (parts = patterns.datePattern.exec(dateString), parts ? (dateStrings.date = parts[1], timeString = parts[2]) : (dateStrings.date = null, timeString = dateString)), timeString) {
    var token = patterns.timeZone.exec(timeString);
    token ? (dateStrings.time = timeString.replace(token[1], ""), dateStrings.timeZone = token[1].trim()) : dateStrings.time = timeString;
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var patternYYY = patterns.YYY[additionalDigits], patternYYYYY = patterns.YYYYY[additionalDigits], token;
  if (token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString), token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  }
  if (token = patterns.YY.exec(dateString) || patternYYY.exec(dateString), token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  }
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return null;
  var token, date, month, week;
  if (dateString.length === 0)
    return date = /* @__PURE__ */ new Date(0), date.setUTCFullYear(year), date;
  if (token = patterns.MM.exec(dateString), token)
    return date = /* @__PURE__ */ new Date(0), month = parseInt(token[1], 10) - 1, validateDate(year, month) ? (date.setUTCFullYear(year, month), date) : /* @__PURE__ */ new Date(NaN);
  if (token = patterns.DDD.exec(dateString), token) {
    date = /* @__PURE__ */ new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    return validateDayOfYearDate(year, dayOfYear) ? (date.setUTCFullYear(year, 0, dayOfYear), date) : /* @__PURE__ */ new Date(NaN);
  }
  if (token = patterns.MMDD.exec(dateString), token) {
    date = /* @__PURE__ */ new Date(0), month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    return validateDate(year, month, day) ? (date.setUTCFullYear(year, month, day), date) : /* @__PURE__ */ new Date(NaN);
  }
  if (token = patterns.Www.exec(dateString), token)
    return week = parseInt(token[1], 10) - 1, validateWeekDate(year, week) ? dayOfISOWeekYear(year, week) : /* @__PURE__ */ new Date(NaN);
  if (token = patterns.WwwD.exec(dateString), token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    return validateWeekDate(year, week, dayOfWeek) ? dayOfISOWeekYear(year, week, dayOfWeek) : /* @__PURE__ */ new Date(NaN);
  }
  return null;
}
function parseTime(timeString) {
  var token, hours, minutes;
  if (token = patterns.HH.exec(timeString), token)
    return hours = parseFloat(token[1].replace(",", ".")), validateTime(hours) ? hours % 24 * MILLISECONDS_IN_HOUR : NaN;
  if (token = patterns.HHMM.exec(timeString), token)
    return hours = parseInt(token[1], 10), minutes = parseFloat(token[2].replace(",", ".")), validateTime(hours, minutes) ? hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE : NaN;
  if (token = patterns.HHMMSS.exec(timeString), token) {
    hours = parseInt(token[1], 10), minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(",", "."));
    return validateTime(hours, minutes, seconds) ? hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1e3 : NaN;
  }
  return null;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0, day = day || 0;
  var date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7, diff2 = week * 7 + day + 1 - fourthOfJanuaryDay;
  return date.setUTCDate(date.getUTCDate() + diff2), date;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  if (month < 0 || month > 11)
    return !1;
  if (date != null) {
    if (date < 1)
      return !1;
    var isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month] || !isLeapYear && date > DAYS_IN_MONTH[month])
      return !1;
  }
  return !0;
}
function validateDayOfYearDate(year, dayOfYear) {
  if (dayOfYear < 1)
    return !1;
  var isLeapYear = isLeapYearIndex(year);
  return !(isLeapYear && dayOfYear > 366 || !isLeapYear && dayOfYear > 365);
}
function validateWeekDate(year, week, day) {
  return !(week < 0 || week > 52 || day != null && (day < 0 || day > 6));
}
function validateTime(hours, minutes, seconds) {
  return !(hours != null && (hours < 0 || hours >= 25) || minutes != null && (minutes < 0 || minutes >= 60) || seconds != null && (seconds < 0 || seconds >= 60));
}
var tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  var formatStr = String(dirtyFormatStr), options = dirtyOptions || {}, matches = formatStr.match(tzFormattingTokensRegExp);
  if (matches) {
    var date = toDate(options.originalDate || dirtyDate, options);
    formatStr = matches.reduce(function(result, token) {
      if (token[0] === "'")
        return result;
      var pos = result.indexOf(token), precededByQuotedSection = result[pos - 1] === "'", replaced = result.replace(
        token,
        "'" + formatters$1[token[0]](date, token, null, options) + "'"
      );
      return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
    }, formatStr);
  }
  return dateFnsFormat__default.default(dirtyDate, formatStr, options);
}
function utcToZonedTime(dirtyDate, timeZone, options) {
  var date = toDate(dirtyDate, options), offsetMilliseconds = tzParseTimezone(timeZone, date, !0), d = new Date(date.getTime() - offsetMilliseconds), resultDate = /* @__PURE__ */ new Date(0);
  return resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()), resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()), resultDate;
}
function formatInTimeZone(date, timeZone, formatStr, options) {
  var extendedOptions = cloneObject__default.default(options);
  return extendedOptions.timeZone = timeZone, extendedOptions.originalDate = date, format(utcToZonedTime(date, timeZone), formatStr, extendedOptions);
}
function zonedTimeToUtc(date, timeZone, options) {
  if (typeof date == "string" && !date.match(tzPattern)) {
    var extendedOptions = cloneObject__default.default(options);
    return extendedOptions.timeZone = timeZone, toDate(date, extendedOptions);
  }
  var d = toDate(date, options), utc = newDateUTC(
    d.getFullYear(),
    d.getMonth(),
    d.getDate(),
    d.getHours(),
    d.getMinutes(),
    d.getSeconds(),
    d.getMilliseconds()
  ).getTime(), offsetMilliseconds = tzParseTimezone(timeZone, new Date(utc));
  return new Date(utc + offsetMilliseconds);
}
const ToastDescription = (props2) => {
  const { body, title } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { paddingY: 1, space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}),
      title && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 2, weight: "semibold", children: title })
    ] }),
    body && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: body })
  ] });
}, rootName$1 = "scheduled-publishing:";
debug__default.default(rootName$1);
function debugWithName$1(name) {
  const namespace = `${rootName$1}${name}`;
  return debug__default.default && debug__default.default.enabled(namespace) ? debug__default.default(namespace) : debug__default.default(rootName$1);
}
function isClientError(e) {
  return typeof e != "object" || !e ? !1 : "statusCode" in e && "response" in e;
}
function getErrorMessage(err) {
  let message;
  return isClientError(err) ? err.response.statusCode === 403 ? message = FORBIDDEN_RESPONSE_TEXT : message = err.message : (err instanceof Error && (message = err.message), message = String(err)), message;
}
const debug$4 = debugWithName$1("useScheduleOperation"), allTimeZones = getTimeZones().map((tz) => ({
  abbreviation: tz.abbreviation,
  alternativeName: tz.alternativeName,
  mainCities: tz.mainCities.join(", "),
  // Main time zone name 'Africa/Dar_es_Salaam'
  name: tz.name,
  // Time zone name with underscores removed
  namePretty: tz.name.replaceAll("_", " "),
  offset: tz.currentTimeFormat.split(" ")[0],
  // all searchable text - this is transformed before being rendered in `<AutoComplete>`
  value: `${tz.currentTimeFormat} ${tz.abbreviation} ${tz.name}`
}));
function getLocalTimeZone() {
  return allTimeZones.find((tz) => tz.name === Intl.DateTimeFormat().resolvedOptions().timeZone) || // Default to GMT-0 if no user timeZone is found
  allTimeZones.find((timeZone) => timeZone.abbreviation === "GMT") || // Return the first time zone as a fallback
  allTimeZones[0];
}
function getStoredTimeZone() {
  const storedTimeZone = localStorage.getItem(LOCAL_STORAGE_TZ_KEY);
  try {
    if (storedTimeZone)
      return JSON.parse(storedTimeZone);
  } catch {
  }
  return getLocalTimeZone();
}
const useTimeZone = () => {
  const initialTimeZone = React.useMemo(() => getStoredTimeZone(), []), [timeZone, setTimeZone] = React.useState(initialTimeZone), toast = ui.useToast();
  React.useEffect(() => {
    const handler = () => {
      setTimeZone(getStoredTimeZone());
    };
    return window.addEventListener("timeZoneEventUpdate", handler), () => {
      window.removeEventListener("timeZoneEventUpdate", handler);
    };
  }, []);
  const formatDateTz = React.useCallback(
    ({
      date,
      format: format2 = DATE_FORMAT.LARGE,
      includeTimeZone,
      prefix
    }) => {
      let dateFormat = format2;
      return prefix && (dateFormat = `'${prefix}'${format2}`), includeTimeZone && (dateFormat = `${format2} (zzzz)`), formatInTimeZone(date, timeZone.name, dateFormat);
    },
    [timeZone.name]
  ), getCurrentZoneDate = React.useCallback(
    () => utcToZonedTime(/* @__PURE__ */ new Date(), timeZone.name),
    [timeZone.name]
  ), handleNewValue = React.useCallback(
    (tz) => {
      debug$4("handleNewValue:", tz), setTimeZone((prevTz) => {
        try {
          prevTz.name !== tz.name && (localStorage.setItem(LOCAL_STORAGE_TZ_KEY, JSON.stringify(tz)), window.dispatchEvent(new Event(
            "timeZoneEventUpdate"
            /* update */
          ))), toast.push({
            closable: !0,
            description: /* @__PURE__ */ jsxRuntime.jsx(
              ToastDescription,
              {
                body: `${tz.alternativeName} (${tz.namePretty})`,
                title: "Time zone updated"
              }
            ),
            duration: 15e3,
            // 15s
            status: "info"
          });
        } catch (err) {
          console.error(err), toast.push({
            closable: !0,
            description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { body: getErrorMessage(err), title: "Unable to update time zone" }),
            status: "error"
          });
        }
        return tz;
      });
    },
    [toast]
  ), utcToCurrentZoneDate = React.useCallback(
    (date) => utcToZonedTime(date, timeZone.name),
    [timeZone.name]
  ), zoneDateToUtc = React.useCallback(
    (date) => zonedTimeToUtc(date, timeZone.name),
    [timeZone.name]
  );
  return {
    formatDateTz,
    getCurrentZoneDate,
    setTimeZone: handleNewValue,
    timeZone,
    utcToCurrentZoneDate,
    zoneDateToUtc
  };
}, TimeZoneAlternativeNameSpan = styledComponents.styled.span(({ theme: theme2 }) => styledComponents.css`
    color: ${theme2.sanity.color.base.fg};
    font-weight: 500;
    margin-left: 1em;
  `), TimeZoneMainCitiesSpan = styledComponents.styled.span(({ theme: theme2 }) => styledComponents.css`
    color: ${theme2.sanity.color.input.default.readOnly.fg};
    margin-left: 1em;
  `), DialogTimeZone = (props2) => {
  const { onClose } = props2, { setTimeZone, timeZone } = useTimeZone(), [selectedTz, setSelectedTz] = React.useState(timeZone), handleTimeZoneChange = React.useCallback((value) => {
    const tz = allTimeZones.find((v) => v.value === value);
    setSelectedTz(tz);
  }, []), handleTimeZoneSelectLocal = React.useCallback(() => {
    setSelectedTz(getLocalTimeZone());
  }, []), handleTimeZoneUpdate = React.useCallback(() => {
    selectedTz && setTimeZone(selectedTz), onClose == null || onClose();
  }, [onClose, selectedTz, setTimeZone]), isDirty = (selectedTz == null ? void 0 : selectedTz.name) !== timeZone.name, isLocalTzSelected = React.useMemo(() => (selectedTz == null ? void 0 : selectedTz.name) === getLocalTimeZone().name, [selectedTz]), renderOption = React.useCallback((option) => /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "button", padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, textOverflow: "ellipsis", children: [
    /* @__PURE__ */ jsxRuntime.jsxs("span", { children: [
      "GMT",
      option.offset
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(TimeZoneAlternativeNameSpan, { children: option.alternativeName }),
    /* @__PURE__ */ jsxRuntime.jsx(TimeZoneMainCitiesSpan, { children: option.mainCities })
  ] }) }), []), renderValue = React.useCallback((_value, option) => option ? `${option.alternativeName} (${option.namePretty})` : "", []);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      footer: {
        confirmButton: {
          text: "Update time zone",
          disabled: !isDirty || !selectedTz,
          onClick: handleTimeZoneUpdate,
          tone: "primary"
        }
      },
      header: "Select time zone",
      id: "time-zone",
      onClose,
      width: 1,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { padding: 4, space: 5, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "The selected time zone will change how dates are represented in schedules." }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "space-between", children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: "Time zone" }),
              isLocalTzSelected && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "local time" })
            ] }),
            !isLocalTzSelected && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx("a", { onClick: handleTimeZoneSelectLocal, style: { cursor: "pointer" }, children: "Select local time zone" }) })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(
            ui.Autocomplete,
            {
              fontSize: 2,
              icon: icons.SearchIcon,
              id: "timezone",
              onChange: handleTimeZoneChange,
              openButton: !0,
              options: allTimeZones,
              padding: 4,
              placeholder: "Search for a city or time zone",
              popover: {
                boundaryElement: document.querySelector("body"),
                constrainSize: !0,
                placement: "bottom-start"
              },
              renderOption,
              renderValue,
              tabIndex: -1,
              value: selectedTz == null ? void 0 : selectedTz.value
            }
          )
        ] })
      ] })
    }
  );
};
function useDialogVisible() {
  const [dialogVisible, setDialogVisible] = React.useState(!1), hide = React.useCallback(() => {
    setDialogVisible(!1);
  }, []), show = React.useCallback(() => {
    setDialogVisible(!0);
  }, []);
  return {
    visible: dialogVisible,
    show,
    hide
  };
}
function useDialogTimeZone() {
  const { visible, show, hide } = useDialogVisible();
  return {
    DialogTimeZone: visible ? DialogTimeZone : null,
    dialogProps: {
      onClose: hide,
      visible
    },
    dialogTimeZoneShow: show,
    hide
  };
}
const ButtonTimeZone = (props2) => {
  const { useElementQueries } = props2, { timeZone } = useTimeZone(), { DialogTimeZone: DialogTimeZone2, dialogProps, dialogTimeZoneShow } = useDialogTimeZone();
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    DialogTimeZone2 && /* @__PURE__ */ jsxRuntime.jsx(DialogTimeZone2, { ...dialogProps }),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Tooltip,
      {
        content: `Displaying schedules in ${timeZone.alternativeName} (GMT${timeZone.offset})`,
        portal: !0,
        children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: useElementQueries ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { className: "button-small", children: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Button,
            {
              icon: icons.EarthAmericasIcon,
              mode: "bleed",
              onClick: dialogTimeZoneShow,
              text: `${timeZone.abbreviation}`
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { className: "button-large", children: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Button,
            {
              icon: icons.EarthAmericasIcon,
              mode: "bleed",
              onClick: dialogTimeZoneShow,
              text: `${timeZone.alternativeName} (${timeZone.namePretty})`
            }
          ) })
        ] }) : /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            icon: icons.EarthAmericasIcon,
            mode: "bleed",
            onClick: dialogTimeZoneShow,
            text: `${timeZone.alternativeName} (${timeZone.namePretty})`
          }
        ) })
      }
    )
  ] });
}, ButtonTimeZoneElementQuery = styledComponents.styled(ui.ElementQuery)`
  .button-small {
    display: block;
  }
  .button-large {
    display: none;
  }

  &[data-eq-min~='2'] {
    .button-small {
      display: none;
    }
    .button-large {
      display: block;
    }
  }
`, noop = () => {
}, UNDEFINED = (
  /*#__NOINLINE__*/
  noop()
), OBJECT = Object, isUndefined = (v) => v === UNDEFINED, isFunction = (v) => typeof v == "function", mergeObjects = (a, b) => ({
  ...a,
  ...b
}), isPromiseLike = (x) => isFunction(x.then), table = /* @__PURE__ */ new WeakMap();
let counter$1 = 0;
const stableHash = (arg) => {
  const type = typeof arg, constructor = arg && arg.constructor, isDate = constructor == Date;
  let result, index;
  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {
    if (result = table.get(arg), result) return result;
    if (result = ++counter$1 + "~", table.set(arg, result), constructor == Array) {
      for (result = "@", index = 0; index < arg.length; index++)
        result += stableHash(arg[index]) + ",";
      table.set(arg, result);
    }
    if (constructor == OBJECT) {
      result = "#";
      const keys = OBJECT.keys(arg).sort();
      for (; !isUndefined(index = keys.pop()); )
        isUndefined(arg[index]) || (result += index + ":" + stableHash(arg[index]) + ",");
      table.set(arg, result);
    }
  } else
    result = isDate ? arg.toJSON() : type == "symbol" ? arg.toString() : type == "string" ? JSON.stringify(arg) : "" + arg;
  return result;
}, SWRGlobalState = /* @__PURE__ */ new WeakMap(), EMPTY_CACHE = {}, INITIAL_CACHE = {}, STR_UNDEFINED = "undefined", isWindowDefined = typeof window != STR_UNDEFINED, isDocumentDefined = typeof document != STR_UNDEFINED, hasRequestAnimationFrame = () => isWindowDefined && typeof window.requestAnimationFrame != STR_UNDEFINED, createCacheHelper = (cache2, key) => {
  const state = SWRGlobalState.get(cache2);
  return [
    // Getter
    () => !isUndefined(key) && cache2.get(key) || EMPTY_CACHE,
    // Setter
    (info) => {
      if (!isUndefined(key)) {
        const prev = cache2.get(key);
        key in INITIAL_CACHE || (INITIAL_CACHE[key] = prev), state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);
      }
    },
    // Subscriber
    state[6],
    // Get server cache snapshot
    () => !isUndefined(key) && key in INITIAL_CACHE ? INITIAL_CACHE[key] : !isUndefined(key) && cache2.get(key) || EMPTY_CACHE
  ];
};
let online = !0;
const isOnline = () => online, [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  noop,
  noop
], isVisible = () => {
  const visibilityState = isDocumentDefined && document.visibilityState;
  return isUndefined(visibilityState) || visibilityState !== "hidden";
}, initFocus = (callback) => (isDocumentDefined && document.addEventListener("visibilitychange", callback), onWindowEvent("focus", callback), () => {
  isDocumentDefined && document.removeEventListener("visibilitychange", callback), offWindowEvent("focus", callback);
}), initReconnect = (callback) => {
  const onOnline = () => {
    online = !0, callback();
  }, onOffline = () => {
    online = !1;
  };
  return onWindowEvent("online", onOnline), onWindowEvent("offline", onOffline), () => {
    offWindowEvent("online", onOnline), offWindowEvent("offline", onOffline);
  };
}, preset = {
  isOnline,
  isVisible
}, defaultConfigOptions = {
  initFocus,
  initReconnect
}, IS_REACT_LEGACY = !React__default.default.useId, IS_SERVER = !isWindowDefined || "Deno" in window, rAF = (f) => hasRequestAnimationFrame() ? window.requestAnimationFrame(f) : setTimeout(f, 1), useIsomorphicLayoutEffect = IS_SERVER ? React.useEffect : React.useLayoutEffect, navigatorConnection = typeof navigator < "u" && navigator.connection, slowConnection = !IS_SERVER && navigatorConnection && ([
  "slow-2g",
  "2g"
].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData), serialize$2 = (key) => {
  if (isFunction(key))
    try {
      key = key();
    } catch {
      key = "";
    }
  const args = key;
  return key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "", [
    key,
    args
  ];
};
let __timestamp = 0;
const getTimestamp = () => ++__timestamp, FOCUS_EVENT = 0, RECONNECT_EVENT = 1, MUTATE_EVENT = 2, ERROR_REVALIDATE_EVENT = 3;
var events = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT,
  FOCUS_EVENT,
  MUTATE_EVENT,
  RECONNECT_EVENT
};
async function internalMutate(...args) {
  const [cache2, _key, _data, _opts] = args, options = mergeObjects({
    populateCache: !0,
    throwOnError: !0
  }, typeof _opts == "boolean" ? {
    revalidate: _opts
  } : _opts || {});
  let populateCache = options.populateCache;
  const rollbackOnErrorOption = options.rollbackOnError;
  let optimisticData = options.optimisticData;
  const rollbackOnError = (error) => typeof rollbackOnErrorOption == "function" ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== !1, throwOnError = options.throwOnError;
  if (isFunction(_key)) {
    const keyFilter = _key, matchedKeys = [], it = cache2.keys();
    for (const key of it)
      // Skip the special useSWRInfinite and useSWRSubscription keys.
      !/^\$(inf|sub)\$/.test(key) && keyFilter(cache2.get(key)._k) && matchedKeys.push(key);
    return Promise.all(matchedKeys.map(mutateByKey));
  }
  return mutateByKey(_key);
  async function mutateByKey(_k) {
    const [key] = serialize$2(_k);
    if (!key) return;
    const [get2, set2] = createCacheHelper(cache2, key), [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2), startRevalidate = () => {
      const revalidators = EVENT_REVALIDATORS[key];
      return (isFunction(options.revalidate) ? options.revalidate(get2().data, _k) : options.revalidate !== !1) && (delete FETCH[key], delete PRELOAD[key], revalidators && revalidators[0]) ? revalidators[0](MUTATE_EVENT).then(() => get2().data) : get2().data;
    };
    if (args.length < 3)
      return startRevalidate();
    let data = _data, error;
    const beforeMutationTs = getTimestamp();
    MUTATION[key] = [
      beforeMutationTs,
      0
    ];
    const hasOptimisticData = !isUndefined(optimisticData), state = get2(), displayedData = state.data, currentData = state._c, committedData = isUndefined(currentData) ? displayedData : currentData;
    if (hasOptimisticData && (optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData, set2({
      data: optimisticData,
      _c: committedData
    })), isFunction(data))
      try {
        data = data(committedData);
      } catch (err) {
        error = err;
      }
    if (data && isPromiseLike(data))
      if (data = await data.catch((err) => {
        error = err;
      }), beforeMutationTs !== MUTATION[key][0]) {
        if (error) throw error;
        return data;
      } else error && hasOptimisticData && rollbackOnError(error) && (populateCache = !0, set2({
        data: committedData,
        _c: UNDEFINED
      }));
    if (populateCache && !error)
      if (isFunction(populateCache)) {
        const populateCachedData = populateCache(data, committedData);
        set2({
          data: populateCachedData,
          error: UNDEFINED,
          _c: UNDEFINED
        });
      } else
        set2({
          data,
          error: UNDEFINED,
          _c: UNDEFINED
        });
    if (MUTATION[key][1] = getTimestamp(), Promise.resolve(startRevalidate()).then(() => {
      set2({
        _c: UNDEFINED
      });
    }), error) {
      if (throwOnError) throw error;
      return;
    }
    return data;
  }
}
const revalidateAllKeys = (revalidators, type) => {
  for (const key in revalidators)
    revalidators[key][0] && revalidators[key][0](type);
}, initCache = (provider, options) => {
  if (!SWRGlobalState.has(provider)) {
    const opts = mergeObjects(defaultConfigOptions, options), EVENT_REVALIDATORS = {}, mutate2 = internalMutate.bind(UNDEFINED, provider);
    let unmount = noop;
    const subscriptions = {}, subscribe = (key, callback) => {
      const subs = subscriptions[key] || [];
      return subscriptions[key] = subs, subs.push(callback), () => subs.splice(subs.indexOf(callback), 1);
    }, setter = (key, value, prev) => {
      provider.set(key, value);
      const subs = subscriptions[key];
      if (subs)
        for (const fn of subs)
          fn(value, prev);
    }, initProvider = () => {
      if (!SWRGlobalState.has(provider) && (SWRGlobalState.set(provider, [
        EVENT_REVALIDATORS,
        {},
        {},
        {},
        mutate2,
        setter,
        subscribe
      ]), !IS_SERVER)) {
        const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT))), releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
        unmount = () => {
          releaseFocus && releaseFocus(), releaseReconnect && releaseReconnect(), SWRGlobalState.delete(provider);
        };
      }
    };
    return initProvider(), [
      provider,
      mutate2,
      initProvider,
      unmount
    ];
  }
  return [
    provider,
    SWRGlobalState.get(provider)[4]
  ];
}, onErrorRetry = (_, __, config, revalidate, opts) => {
  const maxRetryCount = config.errorRetryCount, currentRetryCount = opts.retryCount, timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
  !isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount || setTimeout(revalidate, timeout, opts);
}, compare = (currentData, newData) => stableHash(currentData) == stableHash(newData), [cache, mutate] = initCache(/* @__PURE__ */ new Map()), defaultConfig = mergeObjects(
  {
    // events
    onLoadingSlow: noop,
    onSuccess: noop,
    onError: noop,
    onErrorRetry,
    onDiscarded: noop,
    // switches
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    // timeouts
    errorRetryInterval: slowConnection ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: slowConnection ? 5e3 : 3e3,
    // providers
    compare,
    isPaused: () => !1,
    cache,
    mutate,
    fallback: {}
  },
  // use web preset by default
  preset
), mergeConfigs = (a, b) => {
  const v = mergeObjects(a, b);
  if (b) {
    const { use: u1, fallback: f1 } = a, { use: u2, fallback: f2 } = b;
    u1 && u2 && (v.use = u1.concat(u2)), f1 && f2 && (v.fallback = mergeObjects(f1, f2));
  }
  return v;
}, SWRConfigContext = React.createContext({}), INFINITE_PREFIX = "$inf$", enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__, use$1 = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [], setupDevTools = () => {
  enableDevtools && (window.__SWR_DEVTOOLS_REACT__ = React__default.default);
}, normalize = (args) => isFunction(args[1]) ? [
  args[0],
  args[1],
  args[2] || {}
] : [
  args[0],
  null,
  (args[1] === null ? args[2] : args[1]) || {}
], useSWRConfig = () => mergeObjects(defaultConfig, React.useContext(SWRConfigContext)), middleware = (useSWRNext) => (key_, fetcher_, config) => useSWRNext(key_, fetcher_ && ((...args) => {
  const [key] = serialize$2(key_), [, , , PRELOAD] = SWRGlobalState.get(cache);
  if (key.startsWith(INFINITE_PREFIX))
    return fetcher_(...args);
  const req = PRELOAD[key];
  return isUndefined(req) ? fetcher_(...args) : (delete PRELOAD[key], req);
}), config), BUILT_IN_MIDDLEWARE = use$1.concat(middleware), withArgs = (hook) => function(...args) {
  const fallbackConfig = useSWRConfig(), [key, fn, _config] = normalize(args), config = mergeConfigs(fallbackConfig, _config);
  let next = hook;
  const { use: use2 } = config, middleware2 = (use2 || []).concat(BUILT_IN_MIDDLEWARE);
  for (let i = middleware2.length; i--; )
    next = middleware2[i](next);
  return next(key, fn || config.fetcher || null, config);
}, subscribeCallback = (key, callbacks, callback) => {
  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
  return keyedRevalidators.push(callback), () => {
    const index = keyedRevalidators.indexOf(callback);
    index >= 0 && (keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1], keyedRevalidators.pop());
  };
};
setupDevTools();
const use = React__default.default.use || ((promise) => {
  if (promise.status === "pending")
    throw promise;
  if (promise.status === "fulfilled")
    return promise.value;
  throw promise.status === "rejected" ? promise.reason : (promise.status = "pending", promise.then((v) => {
    promise.status = "fulfilled", promise.value = v;
  }, (e) => {
    promise.status = "rejected", promise.reason = e;
  }), promise);
}), WITH_DEDUPE = {
  dedupe: !0
}, useSWRHandler = (_key, fetcher, config) => {
  const { cache: cache2, compare: compare2, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config, [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2), [key, fnArg] = serialize$2(_key), initialMountedRef = React.useRef(!1), unmountedRef = React.useRef(!1), keyRef = React.useRef(key), fetcherRef = React.useRef(fetcher), configRef = React.useRef(config), getConfig = () => configRef.current, isActive = () => getConfig().isVisible() && getConfig().isOnline(), [getCache, setCache, subscribeCache, getInitialCache] = createCacheHelper(cache2, key), stateDependencies = React.useRef({}).current, fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData, isEqual2 = (prev, current) => {
    for (const _ in stateDependencies) {
      const t2 = _;
      if (t2 === "data") {
        if (!compare2(prev[t2], current[t2]) && (!isUndefined(prev[t2]) || !compare2(returnedData, current[t2])))
          return !1;
      } else if (current[t2] !== prev[t2])
        return !1;
    }
    return !0;
  }, getSnapshot = React.useMemo(() => {
    const shouldStartRequest = !key || !fetcher ? !1 : isUndefined(revalidateOnMount) ? getConfig().isPaused() || suspense ? !1 : isUndefined(revalidateIfStale) ? !0 : revalidateIfStale : revalidateOnMount, getSelectedCache = (state) => {
      const snapshot = mergeObjects(state);
      return delete snapshot._k, shouldStartRequest ? {
        isValidating: !0,
        isLoading: !0,
        ...snapshot
      } : snapshot;
    }, cachedData2 = getCache(), initialData = getInitialCache(), clientSnapshot = getSelectedCache(cachedData2), serverSnapshot = cachedData2 === initialData ? clientSnapshot : getSelectedCache(initialData);
    let memorizedSnapshot = clientSnapshot;
    return [
      () => {
        const newSnapshot = getSelectedCache(getCache());
        return isEqual2(newSnapshot, memorizedSnapshot) ? (memorizedSnapshot.data = newSnapshot.data, memorizedSnapshot.isLoading = newSnapshot.isLoading, memorizedSnapshot.isValidating = newSnapshot.isValidating, memorizedSnapshot.error = newSnapshot.error, memorizedSnapshot) : (memorizedSnapshot = newSnapshot, newSnapshot);
      },
      () => serverSnapshot
    ];
  }, [
    cache2,
    key
  ]), cached = index_js.useSyncExternalStore(React.useCallback(
    (callback) => subscribeCache(key, (current, prev) => {
      isEqual2(prev, current) || callback();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      cache2,
      key
    ]
  ), getSnapshot[0], getSnapshot[1]), isInitialMount = !initialMountedRef.current, hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0, cachedData = cached.data, data = isUndefined(cachedData) ? fallback : cachedData, error = cached.error, laggyDataRef = React.useRef(data), returnedData = keepPreviousData ? isUndefined(cachedData) ? laggyDataRef.current : cachedData : data, shouldDoInitialRevalidation = hasRevalidator && !isUndefined(error) ? !1 : isInitialMount && !isUndefined(revalidateOnMount) ? revalidateOnMount : getConfig().isPaused() ? !1 : suspense ? isUndefined(data) ? !1 : revalidateIfStale : isUndefined(data) || revalidateIfStale, defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation), isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating, isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading, revalidate = React.useCallback(
    async (revalidateOpts) => {
      const currentFetcher = fetcherRef.current;
      if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused())
        return !1;
      let newData, startAt, loading = !0;
      const opts = revalidateOpts || {}, shouldStartNewRequest = !FETCH[key] || !opts.dedupe, callbackSafeguard = () => IS_REACT_LEGACY ? !unmountedRef.current && key === keyRef.current && initialMountedRef.current : key === keyRef.current, finalState = {
        isValidating: !1,
        isLoading: !1
      }, finishRequestAndUpdateState = () => {
        setCache(finalState);
      }, cleanupState = () => {
        const requestInfo = FETCH[key];
        requestInfo && requestInfo[1] === startAt && delete FETCH[key];
      }, initialState2 = {
        isValidating: !0
      };
      isUndefined(getCache().data) && (initialState2.isLoading = !0);
      try {
        if (shouldStartNewRequest && (setCache(initialState2), config.loadingTimeout && isUndefined(getCache().data) && setTimeout(() => {
          loading && callbackSafeguard() && getConfig().onLoadingSlow(key, config);
        }, config.loadingTimeout), FETCH[key] = [
          currentFetcher(fnArg),
          getTimestamp()
        ]), [newData, startAt] = FETCH[key], newData = await newData, shouldStartNewRequest && setTimeout(cleanupState, config.dedupingInterval), !FETCH[key] || FETCH[key][1] !== startAt)
          return shouldStartNewRequest && callbackSafeguard() && getConfig().onDiscarded(key), !1;
        finalState.error = UNDEFINED;
        const mutationInfo = MUTATION[key];
        if (!isUndefined(mutationInfo) && // case 1
        (startAt <= mutationInfo[0] || // case 2
        startAt <= mutationInfo[1] || // case 3
        mutationInfo[1] === 0))
          return finishRequestAndUpdateState(), shouldStartNewRequest && callbackSafeguard() && getConfig().onDiscarded(key), !1;
        const cacheData = getCache().data;
        finalState.data = compare2(cacheData, newData) ? cacheData : newData, shouldStartNewRequest && callbackSafeguard() && getConfig().onSuccess(newData, key, config);
      } catch (err) {
        cleanupState();
        const currentConfig = getConfig(), { shouldRetryOnError } = currentConfig;
        currentConfig.isPaused() || (finalState.error = err, shouldStartNewRequest && callbackSafeguard() && (currentConfig.onError(err, key, currentConfig), (shouldRetryOnError === !0 || isFunction(shouldRetryOnError) && shouldRetryOnError(err)) && (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) && currentConfig.onErrorRetry(err, key, currentConfig, (_opts) => {
          const revalidators = EVENT_REVALIDATORS[key];
          revalidators && revalidators[0] && revalidators[0](events.ERROR_REVALIDATE_EVENT, _opts);
        }, {
          retryCount: (opts.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return loading = !1, finishRequestAndUpdateState(), !0;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      key,
      cache2
    ]
  ), boundMutate = React.useCallback(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...args) => internalMutate(cache2, keyRef.current, ...args),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (useIsomorphicLayoutEffect(() => {
    fetcherRef.current = fetcher, configRef.current = config, isUndefined(cachedData) || (laggyDataRef.current = cachedData);
  }), useIsomorphicLayoutEffect(() => {
    if (!key) return;
    const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
    let nextFocusRevalidatedAt = 0;
    const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, (type, opts = {}) => {
      if (type == events.FOCUS_EVENT) {
        const now = Date.now();
        getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive() && (nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval, softRevalidate());
      } else if (type == events.RECONNECT_EVENT)
        getConfig().revalidateOnReconnect && isActive() && softRevalidate();
      else {
        if (type == events.MUTATE_EVENT)
          return revalidate();
        if (type == events.ERROR_REVALIDATE_EVENT)
          return revalidate(opts);
      }
    });
    return unmountedRef.current = !1, keyRef.current = key, initialMountedRef.current = !0, setCache({
      _k: fnArg
    }), shouldDoInitialRevalidation && (isUndefined(data) || IS_SERVER ? softRevalidate() : rAF(softRevalidate)), () => {
      unmountedRef.current = !0, unsubEvents();
    };
  }, [
    key
  ]), useIsomorphicLayoutEffect(() => {
    let timer;
    function next() {
      const interval = isFunction(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;
      interval && timer !== -1 && (timer = setTimeout(execute2, interval));
    }
    function execute2() {
      !getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline()) ? revalidate(WITH_DEDUPE).then(next) : next();
    }
    return next(), () => {
      timer && (clearTimeout(timer), timer = -1);
    };
  }, [
    refreshInterval,
    refreshWhenHidden,
    refreshWhenOffline,
    key
  ]), React.useDebugValue(returnedData), suspense && isUndefined(data) && key) {
    if (!IS_REACT_LEGACY && IS_SERVER)
      throw new Error("Fallback data is required when using suspense in SSR.");
    fetcherRef.current = fetcher, configRef.current = config, unmountedRef.current = !1;
    const req = PRELOAD[key];
    if (!isUndefined(req)) {
      const promise = boundMutate(req);
      use(promise);
    }
    if (isUndefined(error)) {
      const promise = revalidate(WITH_DEDUPE);
      isUndefined(returnedData) || (promise.status = "fulfilled", promise.value = !0), use(promise);
    } else
      throw error;
  }
  return {
    mutate: boundMutate,
    get data() {
      return stateDependencies.data = !0, returnedData;
    },
    get error() {
      return stateDependencies.error = !0, error;
    },
    get isValidating() {
      return stateDependencies.isValidating = !0, isValidating;
    },
    get isLoading() {
      return stateDependencies.isLoading = !0, isLoading;
    }
  };
}, useSWR = withArgs(useSWRHandler);
function ScheduledPublishingEnabledProvider({ children }) {
  const { enabled, isLoading } = useFeatureEnabled("scheduledPublishing"), { scheduledPublishing: scheduledPublishing2 } = useWorkspace(), isWorkspaceEnabled = scheduledPublishing2.enabled, value = React.useMemo(() => !isWorkspaceEnabled || isLoading ? {
    enabled: !1,
    mode: null
  } : {
    enabled: !0,
    mode: enabled ? "default" : "upsell"
  }, [enabled, isLoading, isWorkspaceEnabled]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ScheduledPublishingEnabledContext.Provider, { value, children });
}
function useScheduledPublishingEnabled() {
  const context = React.useContext(_singletons.ScheduledPublishingEnabledContext);
  if (!context)
    throw new Error(
      "useScheduledPublishingEnabled must be used within a ScheduledPublishingEnabledProvider"
    );
  return context;
}
function getLastExecuteDate(schedule) {
  return (schedule == null ? void 0 : schedule.executedAt) || (schedule == null ? void 0 : schedule.executeAt);
}
function sortByExecuteDate({ reverseOrder } = { reverseOrder: !1 }) {
  return function(a, b) {
    const aExecuteDate = getLastExecuteDate(a), bExecuteDate = getLastExecuteDate(b);
    return aExecuteDate === bExecuteDate ? 0 : aExecuteDate === null ? 1 : bExecuteDate === null ? -1 : (aExecuteDate > bExecuteDate ? 1 : -1) * (reverseOrder ? -1 : 1);
  };
}
const debug$3 = debugWithName$1("useScheduleOperation");
function useScheduleApi() {
  const client2 = useClient({ apiVersion: "2022-09-01" });
  return React.useMemo(() => createScheduleApi(client2), [client2]);
}
function createScheduleApi(client2) {
  const { dataset, projectId } = client2.config();
  function _create({ date, documentId }) {
    debug$3("_create:", documentId);
    const roundedDate = new Date(date);
    return roundedDate.setSeconds(0), roundedDate.setMilliseconds(0), client2.request({
      body: {
        documents: [{ documentId }],
        executeAt: roundedDate,
        name: roundedDate
      },
      method: "POST",
      uri: `/schedules/${projectId}/${dataset}`
    });
  }
  function _delete({ scheduleId }) {
    return debug$3("_delete:", scheduleId), client2.request({
      method: "DELETE",
      uri: `/schedules/${projectId}/${dataset}/${scheduleId}`
    });
  }
  function _deleteMultiple({ scheduleIds }) {
    debug$3("_deleteMultiple:", scheduleIds);
    const requests = scheduleIds.map((scheduleId) => _delete({ scheduleId }));
    return Promise.allSettled(requests);
  }
  function _publish({ scheduleId }) {
    return debug$3("_publish:", scheduleId), client2.request({
      method: "POST",
      uri: `/schedules/${projectId}/${dataset}/${scheduleId}/publish`
    });
  }
  function _update({
    documentSchedule,
    scheduleId
  }) {
    return debug$3("_update:", scheduleId, documentSchedule), client2.request({
      body: documentSchedule,
      method: "PATCH",
      uri: `/schedules/${projectId}/${dataset}/${scheduleId}`
    });
  }
  return {
    create: _create,
    delete: _delete,
    deleteMultiple: _deleteMultiple,
    publish: _publish,
    update: _update
  };
}
var ScheduleEvents = /* @__PURE__ */ ((ScheduleEvents2) => (ScheduleEvents2.create = "scheduleCreate", ScheduleEvents2.delete = "scheduleDelete", ScheduleEvents2.deleteMultiple = "scheduleDeleteMultiple", ScheduleEvents2.publish = "schedulePublish", ScheduleEvents2.update = "scheduleUpdate", ScheduleEvents2))(ScheduleEvents || {});
function pluralize(word, count) {
  return `${count} ${word}${count === 1 ? "" : "s"}`;
}
const scheduleCustomEvent = (name, payload) => new CustomEvent(name, payload);
function useScheduleOperation() {
  const toast = ui.useToast(), { formatDateTz } = useTimeZone(), api = useScheduleApi();
  async function createSchedule({
    date,
    displayToast = !0,
    documentId
  }) {
    try {
      const data = await api.create({ date, documentId });
      window.dispatchEvent(
        scheduleCustomEvent("scheduleCreate", {
          detail: {
            date,
            documentId
          }
        })
      ), displayToast && data != null && data.executeAt && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(
          ToastDescription,
          {
            body: formatDateTz({
              date: new Date(data.executeAt),
              includeTimeZone: !0,
              prefix: "Publishing on "
            }),
            title: "Schedule created"
          }
        ),
        duration: 15e3,
        // 15s
        status: "success"
      });
    } catch (err) {
      displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { body: getErrorMessage(err), title: "Unable to create schedule" }),
        duration: 15e3,
        // 15s
        status: "error"
      });
    }
  }
  async function deleteSchedule({
    displayToast = !0,
    schedule
  }) {
    try {
      await api.delete({ scheduleId: schedule == null ? void 0 : schedule.id }), window.dispatchEvent(
        scheduleCustomEvent("scheduleDelete", {
          detail: {
            scheduleId: schedule == null ? void 0 : schedule.id
          }
        })
      ), displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { title: "Schedule deleted" }),
        status: "success"
      });
    } catch (err) {
      displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { body: getErrorMessage(err), title: "Unable to delete schedule" }),
        duration: 15e3,
        // 15s
        status: "error"
      });
    }
  }
  async function deleteSchedules({
    displayToast = !0,
    schedules
  }) {
    try {
      const scheduleIds = schedules.map((schedule) => schedule.id), response = await api.deleteMultiple({ scheduleIds }), { fulfilledIds, rejectedReasons } = response.reduce(
        (acc, v, index) => (v.status === "fulfilled" && acc.fulfilledIds.push(schedules[index].id), v.status === "rejected" && acc.rejectedReasons.push(`[${schedules[index].id}]: ${v.reason}`), acc),
        { fulfilledIds: [], rejectedReasons: [] }
      ), numFulfilledIds = fulfilledIds.length, numRejectedReasons = rejectedReasons.length;
      (fulfilledIds == null ? void 0 : fulfilledIds.length) > 0 && window.dispatchEvent(
        scheduleCustomEvent("scheduleDeleteMultiple", {
          detail: { scheduleIds: fulfilledIds }
        })
      ), displayToast && ((fulfilledIds == null ? void 0 : fulfilledIds.length) > 0 && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { title: `${pluralize("schedule", numFulfilledIds)} deleted` }),
        status: "success"
      }), (rejectedReasons == null ? void 0 : rejectedReasons.length) > 0 && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(
          ToastDescription,
          {
            body: rejectedReasons == null ? void 0 : rejectedReasons.toString(),
            title: `Unable to delete ${pluralize("schedule", numRejectedReasons)}`
          }
        ),
        duration: 15e3,
        // 15s
        status: "error"
      }));
    } catch (err) {
      displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { body: getErrorMessage(err), title: "Unable to delete schedules" }),
        duration: 15e3,
        // 15s
        status: "error"
      });
    }
  }
  async function publishSchedule({
    displayToast = !0,
    schedule
  }) {
    try {
      const scheduleId = schedule.id;
      await api.publish({ scheduleId }), window.dispatchEvent(scheduleCustomEvent("schedulePublish", { detail: { scheduleId } })), displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { title: "Document published" }),
        status: "success"
      });
    } catch (err) {
      displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { body: getErrorMessage(err), title: "Unable to publish schedule" }),
        duration: 15e3,
        // 15s
        status: "error"
      });
    }
  }
  async function updateSchedule({
    date,
    displayToast = !0,
    scheduleId
  }) {
    try {
      await api.update({ documentSchedule: { executeAt: date }, scheduleId }), window.dispatchEvent(scheduleCustomEvent("scheduleUpdate", { detail: { date, scheduleId } })), displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(
          ToastDescription,
          {
            body: formatDateTz({
              date: new Date(date),
              includeTimeZone: !0,
              prefix: "Publishing on "
            }),
            title: "Schedule updated"
          }
        ),
        duration: 15e3,
        // 15s
        status: "success"
      });
    } catch (err) {
      displayToast && toast.push({
        closable: !0,
        description: /* @__PURE__ */ jsxRuntime.jsx(ToastDescription, { body: getErrorMessage(err), title: "Unable to update schedule" }),
        duration: 15e3,
        // 15s
        status: "error"
      });
    }
  }
  return {
    createSchedule,
    deleteSchedule,
    deleteSchedules,
    publishSchedule,
    updateSchedule
  };
}
function useScheduleBaseUrl() {
  const client2 = useClient({ apiVersion: "2022-09-01" }), { dataset, projectId } = client2.config();
  return `/schedules/${projectId}/${dataset}`;
}
function useFetcher(queryKey) {
  const client2 = useClient({ apiVersion: "2022-09-01" });
  return React.useCallback(
    () => client2.request({
      query: queryKey.params,
      method: "GET",
      uri: queryKey.url
    }),
    [client2, queryKey]
  );
}
const NO_SCHEDULES = [];
function usePollSchedules({ documentId, state } = {}) {
  const { mode } = useScheduledPublishingEnabled(), swrOptions = React.useMemo(() => ({
    refreshWhenHidden: !1,
    refreshWhenOffline: !1,
    revalidateOnFocus: !1,
    shouldRetryOnError: !1,
    // Revalidate data only on default mode, upsell mode should not poll given the data won't change.
    refreshInterval: mode === "default" ? 1e4 : void 0,
    // 10s
    revalidateIfStale: mode === "default",
    revalidateOnReconnect: mode === "default"
  }), [mode]), url = useScheduleBaseUrl(), queryKey = React.useMemo(
    () => ({ params: { documentIds: documentId, state }, url }),
    [url, documentId, state]
  ), fetcher = useFetcher(queryKey), { data, error, mutate: mutate2 } = useSWR(queryKey, fetcher, swrOptions), handleDelete = React.useCallback(
    (event) => {
      mutate2(
        (currentData) => {
          var _a2;
          return {
            schedules: (_a2 = currentData == null ? void 0 : currentData.schedules) == null ? void 0 : _a2.filter(
              (schedule) => schedule.id !== event.detail.scheduleId
            )
          };
        },
        !0
        // revalidate SWR
      );
    },
    [mutate2]
  ), handleDeleteMultiple = React.useCallback(
    (event) => {
      mutate2(
        (currentData) => {
          var _a2;
          return {
            schedules: (_a2 = currentData == null ? void 0 : currentData.schedules) == null ? void 0 : _a2.filter(
              (schedule) => !event.detail.scheduleIds.includes(schedule.id)
            )
          };
        },
        !0
        // revalidate SWR
      );
    },
    [mutate2]
  ), handlePublish = React.useCallback(
    (event) => {
      mutate2(
        (currentData) => {
          const currentSchedules = (currentData == null ? void 0 : currentData.schedules) || [], index = currentSchedules.findIndex(
            (schedule) => schedule.id === event.detail.scheduleId
          );
          return {
            schedules: [
              ...currentSchedules.slice(0, index),
              {
                ...currentSchedules[index],
                executeAt: (/* @__PURE__ */ new Date()).toISOString(),
                state: "succeeded"
              },
              ...currentSchedules.slice(index + 1)
            ]
          };
        },
        !0
        // revalidate SWR
      );
    },
    [mutate2]
  ), handleUpdate = React.useCallback(
    (event) => {
      mutate2(
        (currentData) => {
          const currentSchedules = (currentData == null ? void 0 : currentData.schedules) || [], index = currentSchedules.findIndex(
            (schedule) => schedule.id === event.detail.scheduleId
          );
          return {
            schedules: [
              ...currentSchedules.slice(0, index),
              {
                ...currentSchedules[index],
                executeAt: event.detail.date
              },
              ...currentSchedules.slice(index + 1)
            ]
          };
        },
        !0
        // revalidate SWR
      );
    },
    [mutate2]
  );
  React.useEffect(() => (window.addEventListener(ScheduleEvents.delete, handleDelete), window.addEventListener(ScheduleEvents.deleteMultiple, handleDeleteMultiple), window.addEventListener(ScheduleEvents.publish, handlePublish), window.addEventListener(ScheduleEvents.update, handleUpdate), () => {
    window.removeEventListener(ScheduleEvents.delete, handleDelete), window.removeEventListener(ScheduleEvents.deleteMultiple, handleDeleteMultiple), window.removeEventListener(ScheduleEvents.publish, handlePublish), window.removeEventListener(ScheduleEvents.update, handleUpdate);
  }), [handleDelete, handleDeleteMultiple, handlePublish, handleUpdate]);
  const sortedSchedules = React.useMemo(
    () => {
      var _a2;
      return (_a2 = data == null ? void 0 : data.schedules) == null ? void 0 : _a2.sort(sortByExecuteDate());
    },
    [data == null ? void 0 : data.schedules]
  );
  return {
    error,
    isInitialLoading: !error && !data,
    schedules: sortedSchedules || NO_SCHEDULES
  };
}
const EMPTY_SCHEDULE = [];
function SchedulesProvider({
  children,
  value
}) {
  const [sortBy2, setSortBy] = React.useState(value.sortBy || "executeAt"), { utcToCurrentZoneDate } = useTimeZone(), filterByDate = React.useCallback(
    (wallDate) => function(schedule) {
      const executeDate = getLastExecuteDate(schedule);
      if (!executeDate)
        return !1;
      const scheduleDate = new Date(executeDate), zonedScheduleDate = utcToCurrentZoneDate(scheduleDate);
      return dateFns.isSameDay(zonedScheduleDate, wallDate);
    },
    [utcToCurrentZoneDate]
  ), filterByState = React.useCallback((scheduleState) => function(schedule) {
    return schedule.state === scheduleState;
  }, []), activeSchedules = React.useMemo(() => value.schedules.filter((scheduleState) => value.selectedDate ? filterByDate(value.selectedDate)(scheduleState) : filterByState(value.scheduleState)(scheduleState)).sort((a, b) => {
    if (sortBy2 === "createdAt")
      return a[sortBy2] < b[sortBy2] ? 1 : -1;
    if (sortBy2 === "executeAt") {
      const reverseOrder = !(value.scheduleState === "scheduled" || value.selectedDate);
      return sortByExecuteDate({ reverseOrder })(a, b);
    }
    return 1;
  }) || [], [
    filterByState,
    value.schedules,
    value.scheduleState,
    value.selectedDate,
    sortBy2,
    filterByDate
  ]), schedulesByDate = React.useCallback(
    (wallDate) => value.schedules.filter(filterByDate(wallDate)).sort(sortByExecuteDate()),
    [value.schedules, filterByDate]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    _singletons.SchedulesContext.Provider,
    {
      value: {
        activeSchedules,
        schedules: value.schedules || EMPTY_SCHEDULE,
        schedulesByDate,
        scheduleState: value.scheduleState,
        selectedDate: value.selectedDate,
        setSortBy,
        sortBy: sortBy2
      },
      children
    }
  );
}
function useSchedules() {
  const context = React.useContext(_singletons.SchedulesContext);
  if (context === void 0)
    throw new Error("useSchedules must be used within a SchedulesProvider");
  return context;
}
function useFilteredSchedules(schedules, filter) {
  return React.useMemo(
    () => schedules.filter((schedule) => schedule.state === filter),
    [schedules, filter]
  );
}
const ScheduleFilter = (props2) => {
  const { selected, schedules, state } = props2, count = useFilteredSchedules(schedules, state).length, hasItems = count > 0, critical = state === "cancelled", { href, onClick } = router.useStateLink({
    state: { state }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      as: "a",
      href,
      mode: "bleed",
      onClick,
      selected,
      tone: critical ? "critical" : "default",
      padding: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: SCHEDULE_STATE_DICTIONARY[state].title }),
        hasItems && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: count })
      ] })
    }
  );
}, ScheduleFilters = (props2) => {
  const { onClearDate, selectedDate } = props2, { navigate } = router.useRouter(), { schedules, scheduleState } = useSchedules(), handleMenuClick = (state) => {
    navigate(state);
  }, currentSchedules = useFilteredSchedules(schedules, scheduleState);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { display: ["block", "block", "none"], children: [
      selectedDate && /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          iconRight: icons.CloseIcon,
          onClick: onClearDate,
          text: dateFns.format(selectedDate, "d MMMM yyyy"),
          tone: "primary"
        }
      ),
      scheduleState && /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.MenuButton,
        {
          button: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Button,
            {
              iconRight: icons.SelectIcon,
              mode: "ghost",
              text: `${SCHEDULE_STATE_DICTIONARY[scheduleState].title} (${(currentSchedules == null ? void 0 : currentSchedules.length) || 0})`,
              tone: "default"
            }
          ),
          id: "state",
          menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { style: { minWidth: "175px" }, children: SCHEDULE_FILTERS.map((filter) => /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              iconRight: filter === scheduleState ? icons.CheckmarkIcon : void 0,
              onClick: handleMenuClick.bind(void 0, { state: filter }),
              text: SCHEDULE_STATE_DICTIONARY[filter].title
            },
            filter
          )) }),
          placement: "bottom"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { display: ["none", "none", "block"], children: [
      selectedDate && /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          iconRight: icons.CloseIcon,
          onClick: onClearDate,
          text: dateFns.format(selectedDate, "d MMMM yyyy"),
          tone: "primary"
        }
      ),
      scheduleState && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { gap: 2, children: SCHEDULE_FILTERS.map((filter) => /* @__PURE__ */ jsxRuntime.jsx(
        ScheduleFilter,
        {
          schedules,
          selected: scheduleState === filter,
          state: filter
        },
        filter
      )) })
    ] })
  ] });
}, Image$3 = styledComponents.styled.img((props2) => {
  const { media } = theme.getTheme_v2(props2.theme), responsiveStyles = ui._responsive(media, props2.$direction, (val) => ({
    width: val === "row" ? "50%" : "100%",
    height: val === "row" ? "auto" : "180px"
  }));
  return styledComponents.css`
    object-fit: cover;
    ${responsiveStyles}
  `;
}), DescriptionRoot = styledComponents.styled(ui.Box)`
  margin: auto 0;
`, HORIZONTAL_PADDING_Y = [3, 3, 5];
function UpsellPanel(props2) {
  var _a2;
  const { data, onPrimaryClick, onSecondaryClick, layout = "vertical" } = props2, direction = [
    "column",
    "column",
    layout === "horizontal" ? "row" : "column"
  ];
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 3, overflow: "hidden", border: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction, gap: 2, children: [
    data.image && /* @__PURE__ */ jsxRuntime.jsx(
      Image$3,
      {
        src: data.image.asset.url,
        alt: (_a2 = data.image.asset.altText) != null ? _a2 : "",
        $direction: direction
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(DescriptionRoot, { paddingX: 3, paddingY: layout === "horizontal" ? HORIZONTAL_PADDING_Y : 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.UpsellDescriptionSerializer, { blocks: data.descriptionText }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, justify: "flex-end", marginTop: 5, children: [
        data.secondaryButton.text && /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "bleed",
            text: data.secondaryButton.text,
            tone: "primary",
            iconRight: icons.LaunchIcon,
            ...data.secondaryButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.secondaryButton.url
            },
            onClick: onSecondaryClick
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            text: data.ctaButton.text,
            tone: "primary",
            ...data.ctaButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.ctaButton.url
            },
            onClick: onPrimaryClick
          }
        )
      ] })
    ] })
  ] }) });
}
function useProjectId() {
  return useSource().projectId;
}
const UpsellDialogViewed = telemetry.defineEvent({
  name: "Upsell Dialog Viewed",
  version: 1,
  description: "User viewed the upsell dialog"
}), UpsellDialogDismissed = telemetry.defineEvent({
  name: "Upsell Dialog Dismissed",
  version: 1,
  description: "User dismissed the upsell dialog"
}), UpsellDialogUpgradeCtaClicked = telemetry.defineEvent({
  name: "Upsell Dialog Upgrade CTA Clicked",
  version: 1,
  description: 'User clicked the "Upgrade" CTA in the upsell dialog'
}), UpsellDialogLearnMoreCtaClicked = telemetry.defineEvent({
  name: "Upsell Dialog Learn More CTA Clicked",
  version: 1,
  description: 'User clicked the "Learn More" CTA in the upsell dialog'
}), FEATURE$1 = "scheduled_publishing", TEMPLATE_OPTIONS$1 = { interpolate: /{{([\s\S]+?)}}/g }, BASE_URL$1 = "www.sanity.io";
function SchedulePublishingUpsellProvider(props2) {
  const [upsellDialogOpen, setUpsellDialogOpen] = React.useState(!1), [upsellData, setUpsellData] = React.useState(null), projectId = useProjectId(), telemetry2 = react.useTelemetry(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), telemetryLogs = React.useMemo(
    () => ({
      dialogSecondaryClicked: () => telemetry2.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE$1,
        type: "modal"
      }),
      dialogPrimaryClicked: () => telemetry2.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE$1,
        type: "modal"
      }),
      panelViewed: (source) => telemetry2.log(UpsellDialogViewed, {
        feature: FEATURE$1,
        type: "inspector",
        source
      }),
      panelDismissed: () => telemetry2.log(UpsellDialogDismissed, {
        feature: FEATURE$1,
        type: "inspector"
      }),
      panelPrimaryClicked: () => telemetry2.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE$1,
        type: "inspector"
      }),
      panelSecondaryClicked: () => telemetry2.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE$1,
        type: "inspector"
      })
    }),
    [telemetry2]
  ), handlePrimaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogPrimaryClicked();
  }, [telemetryLogs]), handleSecondaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogSecondaryClicked();
  }, [telemetryLogs]), handleClose = React.useCallback(() => {
    setUpsellDialogOpen(!1), telemetry2.log(UpsellDialogDismissed, {
      feature: FEATURE$1,
      type: "modal"
    });
  }, [telemetry2]);
  React.useEffect(() => {
    const sub = client2.observable.request({
      uri: "/journey/scheduled-publishing"
    }).subscribe({
      next: (data) => {
        if (data)
          try {
            const ctaUrl = template__default.default(data.ctaButton.url, TEMPLATE_OPTIONS$1);
            data.ctaButton.url = ctaUrl({ baseUrl: BASE_URL$1, projectId });
            const secondaryUrl = template__default.default(data.secondaryButton.url, TEMPLATE_OPTIONS$1);
            data.secondaryButton.url = secondaryUrl({ baseUrl: BASE_URL$1, projectId }), setUpsellData(data);
          } catch {
          }
      },
      error: () => {
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [client2, projectId]);
  const handleOpenDialog = React.useCallback(
    (source) => {
      setUpsellDialogOpen(!0), telemetry2.log(UpsellDialogViewed, {
        feature: FEATURE$1,
        type: "modal",
        source
      });
    },
    [telemetry2]
  ), ctxValue = React.useMemo(
    () => ({
      upsellDialogOpen,
      handleOpenDialog,
      upsellData,
      telemetryLogs
    }),
    [handleOpenDialog, upsellDialogOpen, upsellData, telemetryLogs]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(_singletons.SchedulePublishUpsellContext.Provider, { value: ctxValue, children: [
    props2.children,
    upsellData && upsellDialogOpen && /* @__PURE__ */ jsxRuntime.jsx(
      UpsellDialog,
      {
        data: upsellData,
        onClose: handleClose,
        onPrimaryClick: handlePrimaryButtonClick,
        onSecondaryClick: handleSecondaryButtonClick
      }
    )
  ] });
}
function useSchedulePublishingUpsell() {
  return React.useContext(_singletons.SchedulePublishUpsellContext);
}
const BigIconComingSoon = (props2) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    width: "100",
    height: "100",
    viewBox: "0 0 100 100",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props2,
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M54 26C54 28.7614 49.0751 31 43 31C36.9249 31 32 28.7614 32 26C32 23.2386 36.9249 7 43 7C49.0751 7 54 23.2386 54 26Z",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M65 71.5V57M65 71.5L60.5789 69.0132M65 71.5L60.5789 73.9868M65 57L57 52.5L54 54.1875M65 57V42.5M65 57L57 47M65 57L58.1586 60.8483M65 57L60.5789 67.5M65 42.5L57 38L54 39.6875M65 42.5L57 47M65 42.5V27.5M57 47L65 27.5M57 47L54 39.6875M57 47L54 45.3125M57 47L54 50.75M57 23L65 27.5M57 23L54 24.6875V39.6875M57 23V60M65 27.5L57 32L54 30.3125",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M54 76C54 78.7614 49.0751 81 43 81C36.9249 81 32 78.7614 32 76M54 76H60.5V63L54 57M54 76V57M32 76H25V63L32 57M32 76V57M32 26V57M54 26V57M54 45C54 47.7614 49.0751 50 43 50V35C49.0751 35 54 32.7614 54 30",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M43 45.5701H44.8976L45.8465 43.1981L46.9679 42.7335L49.3162 43.7399L50.658 42.3981L49.6516 40.0499L50.1161 38.9284L52.4882 37.9795V36.0819L50.1161 35.1331L49.6516 34.0116M47.1334 34.9653C47.5197 35.5597 47.7441 36.269 47.7441 37.0307C47.7441 39.1268 46.0449 40.826 43.9488 40.826C43.6212 40.826 43.3033 40.7845 43 40.7064",
          stroke: "#7B8CA8",
          strokeWidth: "1.2",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M63.5464 78.6739L64.9606 78.0321L67.4355 78.5135L68.6174 78.2913L69.6174 77.1566H71.6174L72.6174 78.2913L73.7994 78.5135L76.2743 78.0321L77.6885 78.6739M63.5464 78.6739L64.607 79.7972L64.1174 80.3336L63.5464 80.4373M63.5464 78.6739V80.4373M77.6885 78.6739L76.6278 79.7972L77.1174 80.3336L77.6885 80.4373M77.6885 78.6739V80.4373M63.5464 80.4373L61.6174 80.7875V81.6952L64.1174 82.1491L64.607 82.6855L63.5464 83.8088L64.9606 84.4506L67.4355 83.9693L68.6174 84.1915L69.6174 85.3261H71.6174L72.6174 84.1915L73.7994 83.9693L76.2743 84.4506L77.6885 83.8088L76.6278 82.6855L77.1174 82.1491L79.6174 81.6952V80.7875L77.6885 80.4373",
          stroke: "#7B8CA8",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M79.6174 81.4647V84.7162L77.6885 85.0664M76.2743 87.4716L77.6885 86.8298V85.0664M76.2743 87.4716L73.7994 86.9902L72.6174 87.2124L71.6174 88.3471M76.2743 87.4716V84.7162M61.6174 81.4647V84.7162L63.5464 85.0664M71.6174 88.3471H69.6174M71.6174 88.3471V85.3261M69.6174 88.3471L68.6174 87.2124L67.4355 86.9902L64.9606 87.4716M69.6174 88.3471V85.3261M64.9606 87.4716L64.2535 87.1507L63.5464 86.8298V85.0664M64.9606 87.4716V84.6825M63.5464 84.039V85.0664M77.6885 84.039V85.0664",
          stroke: "#7B8CA8",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M73.6174 81.2412C73.6174 81.9932 72.2743 82.6028 70.6174 82.6028C68.9606 82.6028 67.6174 81.9932 67.6174 81.2412C67.6174 80.4892 68.9606 79.8796 70.6174 79.8796C72.2743 79.8796 73.6174 80.4892 73.6174 81.2412Z",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M90 85.3616C90 86.1136 88.6569 86.7232 87 86.7232C85.3431 86.7232 84 86.1136 84 85.3616M90 85.3616C90 84.6096 88.6569 84 87 84C85.3431 84 84 84.6096 84 85.3616M90 85.3616V87.3616C90 88.1136 88.6569 88.7232 87 88.7232C85.3431 88.7232 84 88.1136 84 87.3616V85.3616",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M82 89.8648C82 90.3425 81.3284 90.7297 80.5 90.7297C79.6716 90.7297 79 90.3425 79 89.8648M82 89.8648C82 89.3872 81.3284 89 80.5 89C79.6716 89 79 89.3872 79 89.8648M82 89.8648V91.1352C82 91.6128 81.3284 92 80.5 92C79.6716 92 79 91.6128 79 91.1352V89.8648",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M52.7555 46.7289L52.5381 45.0136L51.2951 44.6903L50.2695 46.0824L49.4558 46.1956L48.0892 45.1364L46.9817 45.7867L47.2408 47.4962L46.7455 48.1517L45.0302 48.3691L44.7069 49.612M51.1084 47.9593C49.8968 47.6442 48.6622 48.2485 48.1434 49.3385",
          stroke: "#7B8CA8",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M39 80.5L38 83.5C38 84.8807 40.2386 86 43 86C45.7614 86 48 84.8807 48 83.5L47 80.5",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M32 77L31 80C31 81.3807 33.2386 82.5 36 82.5C36.9107 82.5 37.7646 82.3783 38.5 82.1655",
          stroke: "#7B8CA8",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M54 77L55 80C55 81.3807 52.7614 82.5 50 82.5C49.0893 82.5 48.2354 82.3783 47.5 82.1655",
          stroke: "#7B8CA8",
          strokeWidth: "1.2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      )
    ]
  }
), BigIconScreen = (props2) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    width: "100",
    height: "100",
    viewBox: "0 0 100 100",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props2,
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M35 84.5L41.7308 67H50V69.5M65 84.5L58.2692 67M32 65H42.5H50H57.5H81V23H19V65H24",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M84 16V23H16V16M84 16H16M84 16L82 14H18L16 16", stroke: "#7B8CA8", strokeWidth: "1.2" }),
      /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M24 65H18L17 67H83L82 65H32", stroke: "#7B8CA8", strokeWidth: "1.2" }),
      /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: "50", cy: "72", r: "2", stroke: "#7B8CA8", strokeWidth: "1.2" }),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M24 63C24 61.8954 24.8954 61 26 61H30C31.1046 61 32 61.8954 32 63V67H24V63Z",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M24 65C24 63.8954 24.8954 63 26 63H30C31.1046 63 32 63.8954 32 65V67H24V65Z",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M28 44.9975C31.0617 44.62 33.5601 42.4793 35.2478 39.995C36.199 38.5947 36.9116 37.0761 36.9653 35.3597C36.9973 34.3355 36.8332 33.1459 35.8944 32.5454C35.3035 32.1675 34.4935 32.0285 33.8044 32.0022C32.7788 31.9631 32.1643 32.4357 31.8489 33.4197C30.3123 38.2145 33.0184 42.7025 36.3911 45.8977C38.1152 47.531 40.0746 48.9275 42.1179 50.1294C43.9867 51.2287 46.003 52.2595 48.1189 52.7885C48.9466 52.9954 50.4951 53.3913 51.3211 52.954C52.3579 52.4051 51.8285 49.7323 51.7091 48.9809C51.3862 46.9486 50.7293 45.0311 49.8726 43.1662C49.3791 42.0918 48.7948 40.8004 47.9999 39.8967C47.4959 39.3237 47.1331 39.4889 47.1101 40.2278C47.0699 41.5204 47.5768 42.7535 48.3103 43.7973C50.633 47.1024 54.4924 49.4656 58.2792 50.6985C59.9643 51.2471 61.8953 51.7306 63.6853 51.6193C65.3845 51.5137 65.6225 50.1321 65.7287 48.655C65.9958 44.9405 64.9629 40.7695 62.6403 37.7963C61.615 36.4839 60.3547 35.6334 58.6879 35.4476C57.7554 35.3437 56.665 35.3303 55.7391 35.5097C54.8073 35.6903 54.0162 36.297 54.3371 37.3462C54.6464 38.3572 55.8044 39.0666 56.6444 39.5759C57.983 40.3876 59.4813 40.9898 61.0262 41.2624C63.2658 41.6576 65.1745 41.1715 67.141 40.1346C67.9966 39.6835 68.8825 39.1795 69.4379 38.3861",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      )
    ]
  }
), BigIconSuccess = (props2) => /* @__PURE__ */ jsxRuntime.jsxs(
  "svg",
  {
    width: "100",
    height: "100",
    viewBox: "0 0 100 100",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props2,
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M35.5034 34.5961C35.6531 34.1763 35.8628 33.792 36.1352 33.4478C37.6813 31.4827 40.9503 31.2145 44.9898 32.3554M35.5034 34.5961L24.12 78.5806C23.4656 81.1092 26.1309 83.2083 28.4357 81.9796L68.4485 60.6484M35.5034 34.5961C34.2315 38.1622 37.2902 44.2842 43.0792 50.0342M68.4485 60.6484C68.8174 60.4078 69.1391 60.118 69.4084 59.7777C70.9736 57.7883 70.4521 54.4677 68.3472 50.7308M68.4485 60.6484C65.1795 62.7806 58.1999 61.0522 51.0413 56.4338M49.3164 55.2667C48.6043 54.7622 47.8933 54.2299 47.1867 53.6707C46.3331 52.9953 45.5161 52.3044 44.7387 51.6037M49.3164 55.2667C49.8913 55.674 50.4669 56.0632 51.0413 56.4338M49.3164 55.2667C52.3445 53.1871 58.7283 49.8329 66.4965 47.8874M51.0413 56.4338C55.9305 53.432 62.4593 51.6876 68.3472 50.7308M43.0792 50.0342C43.6098 50.5612 44.1634 51.0852 44.7387 51.6037M43.0792 50.0342C44.4006 45.7138 45.8116 38.387 44.9898 32.3554M44.7387 51.6037C47.6743 44.2968 48.7135 38.3712 48.6643 33.6916M63.9622 36.487C63.2905 34.23 62.35 29.5386 63.9622 28.8293C65.9774 27.9426 68.5569 33.5045 70.8139 32.2148C73.0709 30.9251 69.4435 27.7814 70.8139 25.2019C72.1842 22.6224 79.6002 28.4262 81.2123 23.4285C82.502 19.4304 79.7614 16.6574 78.2298 15.7708M66.4965 47.8874C70.7697 46.8171 75.462 46.1731 80.2449 46.4019L80.2449 49.7068C77.5329 49.6936 73.1535 49.9498 68.3472 50.7308M66.4965 47.8874C64.45 45.1054 61.6564 42.2264 58.3003 39.5859C55.0633 37.039 51.7429 35.0416 48.6643 33.6916M48.6643 33.6916C48.5822 25.8794 45.4671 21.5396 43.0792 20.043L39.941 23.4285C42.9851 25.0774 44.4569 28.4441 44.9898 32.3554",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M32.2094 47.3001C31.0515 50.5465 34.6857 56.6214 40.9597 61.5862C47.2404 66.5562 53.9958 68.696 56.8839 66.8122",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M28.8867 60.1903C28.1245 62.3275 30.5169 66.3267 34.6472 69.595C38.7818 72.8669 43.229 74.2755 45.1303 73.0354",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M26.2718 70.2225C25.8147 71.5039 27.2491 73.9016 29.7254 75.8611C32.2044 77.8228 34.8707 78.6673 36.0106 77.9238",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M28.0529 44.1724C29.5354 43.1981 32.3735 40.6904 31.8652 38.4538C31.2298 35.6581 22.8425 38.9622 22.7155 36.5477C22.5884 34.1331 27.0361 30.575 26.909 28.6688C26.7819 26.7626 18.6489 30.8291 18.6489 26.8896C18.6489 23.738 21.36 22.1029 22.7155 21.6793",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "21.8833",
          y: "50.1122",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 21.8833 50.1122)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "16.0527",
          y: "36.722",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(4.36851 16.0527 36.722)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "27.9448",
          y: "22.8353",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 27.9448 22.8353)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "53.7065",
          y: "33.443",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 53.7065 33.443)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "67.3447",
          y: "13.743",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 67.3447 13.743)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "74.9219",
          y: "54.6584",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 74.9219 54.6584)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "70.3755",
          y: "66.7814",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 70.3755 66.7814)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "77.9526",
          y: "78.9045",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 77.9526 78.9045)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        "rect",
        {
          x: "82.4985",
          y: "62.2353",
          width: "3.03077",
          height: "3.03077",
          transform: "rotate(-24.7154 82.4985 62.2353)",
          stroke: "#7B8CA8",
          strokeWidth: "1.2"
        }
      )
    ]
  }
), EmptySchedules = (props2) => {
  const { scheduleState, selectedDate } = props2;
  let BigIcon, description, heading;
  switch (scheduleState) {
    case "succeeded": {
      description = "When a scheduled document is successfully published it moves to this list view.", heading = "No completed scheduled publications ... yet", BigIcon = BigIconComingSoon;
      break;
    }
    case "cancelled": {
      description = "Schedules can fail for several reasons, for example when their documents are deleted. When they do, they show up here.", heading = "No failed scheduled publications", BigIcon = BigIconSuccess;
      break;
    }
    case "scheduled": {
      description = "When editing a document, create a new scheduled publication from the menu next to the Publish button.", heading = "No upcoming scheduled publications", BigIcon = BigIconScreen;
      break;
    }
  }
  return selectedDate && (description = "No schedules for this date.", heading = dateFns.format(selectedDate, "d MMMM yyyy"), BigIcon = BigIconScreen), /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { paddingX: 6, paddingBottom: 8, paddingTop: 7, radius: 2, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", children: BigIcon && /* @__PURE__ */ jsxRuntime.jsx(BigIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      heading && /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { align: "center", size: 1, children: heading }),
      description && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, children: description })
    ] })
  ] }) });
}, isLiveEditEnabled = (schemaType) => schemaType.liveEdit === !0;
function getPreviewStateObservable(documentPreviewStore, schemaType, documentId, title) {
  const draft$ = isLiveEditEnabled(schemaType) ? rxjs.of({ snapshot: null }) : documentPreviewStore.observeForPreview(
    { _type: "reference", _ref: getDraftId(documentId) },
    schemaType
  ), published$ = documentPreviewStore.observeForPreview(
    { _type: "reference", _ref: getPublishedId(documentId) },
    schemaType
  );
  return rxjs.combineLatest([draft$, published$]).pipe(
    operators.map(([draft, published]) => ({
      draft: draft.snapshot ? { title, ...draft.snapshot || {} } : null,
      isLoading: !1,
      published: published.snapshot ? { title, ...published.snapshot || {} } : null
    })),
    operators.startWith({ draft: null, isLoading: !0, published: null })
  );
}
function getScheduledDocument(schedule) {
  var _a2;
  return (_a2 = schedule.documents) == null ? void 0 : _a2[0];
}
function getScheduledDocumentId(schedule) {
  var _a2;
  return (_a2 = getScheduledDocument(schedule)) == null ? void 0 : _a2.documentId.replaceAll("drafts.", "");
}
function usePreviewState(documentId, schemaType) {
  const documentPreviewStore = useDocumentPreviewStore(), [paneItemPreview, setPaneItemPreview] = React.useState({});
  return React.useEffect(() => {
    if (!schemaType)
      return;
    const subscription = getPreviewStateObservable(
      documentPreviewStore,
      schemaType,
      documentId,
      ""
    ).subscribe((state) => {
      setPaneItemPreview(state);
    });
    return () => {
      subscription == null || subscription.unsubscribe();
    };
  }, [documentPreviewStore, schemaType, documentId]), paneItemPreview;
}
function useSchema() {
  return useSource().schema;
}
function useScheduleSchemaType(schedule) {
  const firstDocument = getScheduledDocument(schedule), schema2 = useSchema(), schemaName = firstDocument.documentType;
  return React.useMemo(() => {
    if (schemaName)
      return schema2.get(schemaName);
  }, [schemaName, schema2]);
}
function useSchemaType(schemaName) {
  const schema2 = useSchema();
  return React.useMemo(() => schema2.get(schemaName), [schemaName, schema2]);
}
const DateWithTooltipElementQuery = styledComponents.styled(ui.ElementQuery)`
  .date-small {
    display: inline;
  }
  .date-medium {
    display: none;
  }
  .date-large {
    display: none;
  }

  &[data-eq-min~='1'] {
    .date-small {
      display: none;
    }
    .date-medium {
      display: inline;
    }
    .date-large {
      display: none;
    }
  }

  &[data-eq-min~='2'] {
    .date-small {
      display: none;
    }
    .date-medium {
      display: none;
    }
    .date-large {
      display: inline;
    }
  }
`;
function DocumentActionPropsProvider({
  children,
  value
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.DocumentActionPropsContext.Provider, { value, children });
}
function useDocumentActionProps() {
  const context = React.useContext(_singletons.DocumentActionPropsContext);
  if (context === void 0)
    throw new Error("useDocumentActionProps must be used within a DocumentActionPropsProvider");
  return context;
}
function useScheduleForm(schedule) {
  const [isDirty, setIsDirty] = React.useState(!1), [formData, setFormData] = React.useState(
    schedule && schedule != null && schedule.executeAt ? {
      date: schedule.executeAt
    } : null
  ), handleFormChange = React.useCallback(
    (form) => {
      const equalDates = (schedule == null ? void 0 : schedule.executeAt) && new Date(schedule.executeAt).getTime() === new Date(form == null ? void 0 : form.date).getTime();
      setFormData(form), setIsDirty(!equalDates);
    },
    [schedule == null ? void 0 : schedule.executeAt]
  );
  return {
    formData,
    isDirty,
    onFormChange: handleFormChange
  };
}
function CalendarDay$1(props2) {
  const { date, focused, isCurrentMonth, isToday, customValidation, onSelect, selected } = props2, isValid = React.useMemo(() => customValidation ? customValidation(dateFns.endOfDay(date)) : !0, [date, customValidation]), handleClick = React.useCallback(() => {
    isValid && onSelect(date);
  }, [date, isValid, onSelect]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", { "aria-selected": selected, "data-ui": "CalendarDay", children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Card,
    {
      "aria-label": date.toDateString(),
      "aria-pressed": selected,
      as: "button",
      __unstable_focusRing: !0,
      "data-weekday": !0,
      "data-focused": focused ? "true" : "",
      disabled: !isValid,
      role: "button",
      tabIndex: -1,
      onClick: handleClick,
      padding: 3,
      radius: 2,
      selected,
      tone: isToday || selected ? "primary" : "default",
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Text,
        {
          muted: !selected && !isCurrentMonth,
          style: { textAlign: "center" },
          weight: isCurrentMonth ? "medium" : "regular",
          children: date.getDate()
        }
      )
    }
  ) });
}
const MONTH_NAMES$1 = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], WEEK_DAY_NAMES$1 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], HOURS_24 = range__default.default(0, 24), ARROW_KEYS$1 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], TAIL_WEEKDAYS$1 = [1, 2, 3, 4, 5, 6], getWeekStartsOfMonth$1 = (date) => {
  const firstDay = dateFns.startOfMonth(date);
  return dateFns.eachWeekOfInterval({
    start: firstDay,
    end: dateFns.lastDayOfMonth(firstDay)
  });
}, getWeekDaysFromWeekStarts$1 = (weekStarts) => weekStarts.map((weekStart) => [
  weekStart,
  ...TAIL_WEEKDAYS$1.map((d) => dateFns.addDays(weekStart, d))
]), getWeeksOfMonth$1 = (date) => getWeekDaysFromWeekStarts$1(getWeekStartsOfMonth$1(date)).map(
  (days) => ({
    number: dateFns.getWeek(days[0]),
    days
  })
);
function CalendarMonth$1(props2) {
  const { getCurrentZoneDate } = useTimeZone(), { customValidation } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "aria-hidden": props2.hidden || !1, "data-ui": "CalendarMonth", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { gap: 1, style: { gridTemplateColumns: "repeat(7, minmax(44px, 46px))" }, children: [
    WEEK_DAY_NAMES$1.map((weekday) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", style: { textAlign: "center" }, children: weekday }) }, weekday)),
    getWeeksOfMonth$1(props2.date).map(
      (week, weekIdx) => week.days.map((date, dayIdx) => {
        const focused = props2.focused && dateFns.isSameDay(date, props2.focused), selected = props2.selected && dateFns.isSameDay(date, props2.selected), isToday = dateFns.isSameDay(date, getCurrentZoneDate()), isCurrentMonth = props2.focused && dateFns.isSameMonth(date, props2.focused);
        return /* @__PURE__ */ jsxRuntime.jsx(
          CalendarDay$1,
          {
            date,
            focused,
            isCurrentMonth,
            isToday,
            customValidation,
            onSelect: props2.onSelect,
            selected
          },
          `${weekIdx}-${dayIdx}`
        );
      })
    )
  ] }) });
}
const features = {
  dayPresets: !1,
  timePresets: !1
}, YearInput = ({ onChange, ...props2 }) => {
  const handleChange = React.useCallback(
    (event) => {
      const numericValue = parseInt(event.currentTarget.value, 10);
      isNaN(numericValue) || onChange(numericValue);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(LazyTextInput, { ...props2, onChange: handleChange, inputMode: "numeric" });
}, PRESERVE_FOCUS_ELEMENT$1 = /* @__PURE__ */ jsxRuntime.jsx(
  "span",
  {
    "data-preserve-focus": !0,
    style: { overflow: "hidden", position: "absolute", outline: "none" },
    tabIndex: -1
  }
), Calendar$1 = React.forwardRef(function(props2, forwardedRef) {
  const { getCurrentZoneDate, zoneDateToUtc } = useTimeZone(), {
    selectTime,
    onFocusedDateChange,
    selectedDate = getCurrentZoneDate(),
    focusedDate = selectedDate,
    timeStep = 1,
    onSelect,
    customValidation,
    ...restProps
  } = props2, setFocusedDate = React.useCallback(
    (date) => onFocusedDateChange(zoneDateToUtc(date)),
    [onFocusedDateChange, zoneDateToUtc]
  ), setFocusedDateMonth = React.useCallback(
    (month) => setFocusedDate(dateFns.setDate(dateFns.setMonth(focusedDate, month), 1)),
    [focusedDate, setFocusedDate]
  ), handleFocusedMonthChange = React.useCallback(
    (e) => setFocusedDateMonth(Number(e.currentTarget.value)),
    [setFocusedDateMonth]
  ), moveFocusedDate = React.useCallback(
    (by) => setFocusedDate(dateFns.addMonths(focusedDate, by)),
    [focusedDate, setFocusedDate]
  ), setFocusedDateYear = React.useCallback(
    (year) => setFocusedDate(dateFns.setYear(focusedDate, year)),
    [focusedDate, setFocusedDate]
  ), handleDateChange = React.useCallback(
    (date) => {
      onSelect(
        zoneDateToUtc(
          dateFns.setMinutes(dateFns.setHours(date, selectedDate.getHours()), selectedDate.getMinutes())
        )
      );
    },
    [onSelect, selectedDate, zoneDateToUtc]
  ), handleMinutesChange = React.useCallback(
    (event) => {
      const m = Number(event.currentTarget.value);
      onSelect(zoneDateToUtc(dateFns.setMinutes(selectedDate, m)));
    },
    [onSelect, selectedDate, zoneDateToUtc]
  ), handleHoursChange = React.useCallback(
    (event) => {
      const m = Number(event.currentTarget.value);
      onSelect(zoneDateToUtc(dateFns.setHours(selectedDate, m)));
    },
    [onSelect, selectedDate, zoneDateToUtc]
  );
  React.useCallback(
    (hours, mins) => {
      onSelect(zoneDateToUtc(dateFns.setHours(dateFns.setMinutes(selectedDate, mins), hours)));
    },
    [onSelect, selectedDate, zoneDateToUtc]
  );
  const ref = ui.useForwardedRef(forwardedRef), focusCurrentWeekDay = React.useCallback(() => {
    var _a2, _b;
    (_b = (_a2 = ref.current) == null ? void 0 : _a2.querySelector('[data-focused="true"]')) == null || _b.focus();
  }, [ref]), handleKeyDown = React.useCallback(
    (event) => {
      var _a2, _b;
      if (ARROW_KEYS$1.includes(event.key)) {
        if (event.preventDefault(), event.currentTarget.hasAttribute("data-calendar-grid")) {
          focusCurrentWeekDay();
          return;
        }
        event.key === "ArrowUp" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, -7))), event.key === "ArrowDown" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, 7))), event.key === "ArrowLeft" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, -1))), event.key === "ArrowRight" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, 1))), (_b = (_a2 = ref.current) == null ? void 0 : _a2.querySelector("[data-preserve-focus]")) == null || _b.focus();
      }
    },
    [zoneDateToUtc, ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]
  );
  React.useEffect(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]), React.useEffect(() => {
    var _a2;
    (_a2 = document.activeElement) != null && _a2.matches(
      "[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]"
    ) && focusCurrentWeekDay();
  }, [ref, focusCurrentWeekDay, focusedDate]);
  const handleNowClick = React.useCallback(() => onSelect(/* @__PURE__ */ new Date()), [onSelect]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { "data-ui": "Calendar", ...restProps, ref, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          CalendarMonthSelect,
          {
            moveFocusedDate,
            onChange: handleFocusedMonthChange,
            value: focusedDate == null ? void 0 : focusedDate.getMonth()
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          CalendarYearSelect,
          {
            moveFocusedDate,
            onChange: setFocusedDateYear,
            value: focusedDate.getFullYear()
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(
        ui.Box,
        {
          "data-calendar-grid": !0,
          onKeyDown: handleKeyDown,
          marginTop: 2,
          overflow: "hidden",
          tabIndex: 0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              CalendarMonth$1,
              {
                date: focusedDate,
                focused: focusedDate,
                customValidation,
                onSelect: handleDateChange,
                selected: selectedDate
              }
            ),
            PRESERVE_FOCUS_ELEMENT$1
          ]
        }
      )
    ] }),
    selectTime && /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 2, style: { borderTop: "1px solid var(--card-border-color)" }, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Select,
            {
              "aria-label": "Select hour",
              value: selectedDate == null ? void 0 : selectedDate.getHours(),
              onChange: handleHoursChange,
              children: HOURS_24.map((h) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: h, children: `${h}`.padStart(2, "0") }, h))
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: ":" }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Select,
            {
              "aria-label": "Select minutes",
              value: selectedDate == null ? void 0 : selectedDate.getMinutes(),
              onChange: handleMinutesChange,
              children: range__default.default(0, 60, timeStep).map((m) => /* @__PURE__ */ jsxRuntime.jsx("option", { value: m, children: `${m}`.padStart(2, "0") }, m))
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { text: "Set to current time", mode: "bleed", onClick: handleNowClick }) })
      ] }),
      features.timePresets
    ] })
  ] });
});
function CalendarMonthSelect(props2) {
  const { moveFocusedDate, onChange, value } = props2, handlePrevMonthClick = React.useCallback(() => moveFocusedDate(-1), [moveFocusedDate]), handleNextMonthClick = React.useCallback(() => moveFocusedDate(1), [moveFocusedDate]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        "aria-label": "Go to previous month",
        onClick: handlePrevMonthClick,
        mode: "bleed",
        icon: icons.ChevronLeftIcon,
        paddingX: 2,
        radius: 0
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Select, { radius: 0, value, onChange, children: MONTH_NAMES$1.map((m, i) => (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ jsxRuntime.jsx("option", { value: i, children: m }, i)
    )) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        "aria-label": "Go to next month",
        mode: "bleed",
        icon: icons.ChevronRightIcon,
        onClick: handleNextMonthClick,
        paddingX: 2,
        radius: 0
      }
    )
  ] });
}
function CalendarYearSelect(props2) {
  const { moveFocusedDate, onChange, value } = props2, handlePrevYearClick = React.useCallback(() => moveFocusedDate(-12), [moveFocusedDate]), handleNextYearClick = React.useCallback(() => moveFocusedDate(12), [moveFocusedDate]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        "aria-label": "Previous year",
        onClick: handlePrevYearClick,
        mode: "bleed",
        icon: icons.ChevronLeftIcon,
        paddingX: 2,
        radius: 0
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(YearInput, { value, onChange, radius: 0, style: { width: 65 } }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        "aria-label": "Next year",
        onClick: handleNextYearClick,
        mode: "bleed",
        icon: icons.ChevronRightIcon,
        paddingX: 2,
        radius: 0
      }
    )
  ] });
}
const DatePicker = React.forwardRef(function(props2, ref) {
  const { utcToCurrentZoneDate } = useTimeZone(), { value = /* @__PURE__ */ new Date(), onChange, customValidation, ...rest } = props2, [focusedDate, setFocusedDay] = React.useState(), handleSelect = React.useCallback(
    (nextDate) => {
      onChange(nextDate), setFocusedDay(void 0);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Calendar$1,
    {
      ...rest,
      ref,
      selectedDate: utcToCurrentZoneDate(value),
      onSelect: handleSelect,
      focusedDate: utcToCurrentZoneDate(focusedDate || value),
      onFocusedDateChange: setFocusedDay,
      customValidation
    }
  );
}), DateTimeInput$1 = React.forwardRef(function(props2, forwardedRef) {
  const {
    value,
    inputValue,
    customValidation,
    onInputChange,
    onChange,
    selectTime,
    timeStep,
    ...rest
  } = props2, [popoverRef, setPopoverRef] = React.useState(null), inputRef = ui.useForwardedRef(forwardedRef), buttonRef = React.useRef(null), [isPickerOpen, setPickerOpen] = React.useState(!1), portal = ui.usePortal();
  ui.useClickOutside(() => setPickerOpen(!1), [popoverRef]);
  const handleDeactivation = React.useCallback(() => {
    var _a2, _b;
    (_a2 = inputRef.current) == null || _a2.focus(), (_b = inputRef.current) == null || _b.select();
  }, [inputRef]), handleKeyUp = React.useCallback((e) => {
    e.key === "Escape" && setPickerOpen(!1);
  }, []), handleClick = React.useCallback(() => setPickerOpen(!0), []), suffix = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { padding: "5px" }, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      ref: buttonRef,
      icon: icons.CalendarIcon,
      mode: "bleed",
      padding: 2,
      onClick: handleClick,
      style: { display: "block" },
      "data-testid": "select-date-button"
    }
  ) });
  return /* @__PURE__ */ jsxRuntime.jsx(
    LazyTextInput,
    {
      ref: inputRef,
      ...rest,
      value: inputValue,
      onChange: onInputChange,
      suffix: isPickerOpen ? (
        // Note: we're conditionally inserting the popover here due to an
        // issue with popovers rendering incorrectly on subsequent renders
        // see https://github.com/sanity-io/design/issues/519
        /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset: 1e3, children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Popover,
          {
            constrainSize: !0,
            content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { onDeactivation: handleDeactivation, children: /* @__PURE__ */ jsxRuntime.jsx(
              DatePicker,
              {
                selectTime,
                timeStep,
                onKeyUp: handleKeyUp,
                value,
                onChange,
                customValidation
              }
            ) }) }),
            "data-testid": "date-input-dialog",
            fallbackPlacements: ["bottom", "bottom-start", "top-end", "top", "top-start"],
            floatingBoundary: portal.element,
            open: !0,
            placement: "bottom-end",
            portal: !0,
            radius: 2,
            ref: setPopoverRef,
            children: suffix
          }
        ) })
      ) : suffix
    }
  );
}), CommonDateTimeInput = React.forwardRef(function(props2, forwardedRef) {
  const {
    value,
    markers,
    title,
    description,
    placeholder,
    parseInputValue,
    formatInputValue,
    deserialize: deserialize2,
    serialize: serialize2,
    selectTime,
    timeStep,
    readOnly,
    level,
    onChange,
    customValidation,
    ...rest
  } = props2, [localValue, setLocalValue] = React.useState(null);
  React.useEffect(() => {
    setLocalValue(null);
  }, [value]);
  const { zoneDateToUtc } = useTimeZone(), undefinedValue = typeof value > "u", handleDatePickerInputChange = React.useCallback(
    (event) => {
      const nextInputValue = event.currentTarget.value, result = nextInputValue === "" ? null : parseInputValue(nextInputValue);
      result === null ? (onChange(null), undefinedValue && localValue && setLocalValue(null)) : result.isValid ? onChange(serialize2(zoneDateToUtc(result.date))) : setLocalValue(nextInputValue);
    },
    [undefinedValue, zoneDateToUtc, localValue, serialize2, onChange, parseInputValue]
  ), handleDatePickerChange = React.useCallback(
    (nextDate) => {
      onChange(nextDate ? serialize2(nextDate) : null);
    },
    [serialize2, onChange]
  ), inputRef = ui.useForwardedRef(forwardedRef), id2 = React.useId(), parseResult = localValue ? parseInputValue(localValue) : value ? deserialize2(value) : null, inputValue = localValue || (parseResult != null && parseResult.isValid ? formatInputValue(parseResult.date) : value), nodeValidations = React.useMemo(
    () => markers.map((m) => {
      var _a2, _b;
      return {
        level: m.level,
        path: m.path,
        message: (_b = m.message) != null ? _b : (_a2 = m.item) == null ? void 0 : _a2.message
      };
    }),
    [markers]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    FormField,
    {
      validation: parseResult != null && parseResult.error ? [
        ...nodeValidations,
        {
          level: "error",
          message: parseResult.error,
          path: []
        }
        // casting to marker to avoid having to implement cloneWithMessage on item
      ] : nodeValidations,
      title,
      level,
      description,
      inputId: id2,
      children: readOnly ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { value: inputValue, readOnly: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(
        DateTimeInput$1,
        {
          ...rest,
          id: id2,
          selectTime,
          timeStep,
          placeholder: placeholder || `e.g. ${formatInputValue(/* @__PURE__ */ new Date())}`,
          ref: inputRef,
          value: parseResult == null ? void 0 : parseResult.date,
          inputValue: inputValue || "",
          readOnly: !!readOnly,
          onInputChange: handleDatePickerInputChange,
          onChange: handleDatePickerChange,
          customValidity: parseResult == null ? void 0 : parseResult.error,
          customValidation
        }
      )
    }
  );
});
function isValidDate(date) {
  return date instanceof Date && !isNaN(date.valueOf());
}
function parseOptions(options = {}) {
  return {
    customValidation: options.customValidation || function() {
      return !0;
    },
    customValidationMessage: options.customValidationMessage || "Invalid date.",
    calendarTodayLabel: options.calendarTodayLabel || "Today",
    timeStep: "timeStep" in options && Number(options.timeStep) || 1
  };
}
function serialize$1(date) {
  return date.toISOString();
}
function deserialize$1(isoString) {
  const deserialized = new Date(isoString);
  return isValidDate(deserialized) ? { isValid: !0, date: deserialized } : { isValid: !1, error: `Invalid date value: "${isoString}"` };
}
function enforceTimeStep(dateString, timeStep) {
  if (!timeStep || timeStep === 1)
    return dateString;
  const date = dateFns.parseISO(dateString), minutes = dateFns.getMinutes(date), leftOver = minutes % timeStep;
  return serialize$1(leftOver !== 0 ? dateFns.setMinutes(date, minutes - leftOver) : date);
}
const DateTimeInput = React.forwardRef(function(props2, forwardedRef) {
  const { type, onChange, ...rest } = props2, { title, description, placeholder } = type, { scheduledPublishing: scheduledPublishing2 } = useWorkspace(), inputDateTimeFormat = scheduledPublishing2.inputDateTimeFormat, { getCurrentZoneDate, timeZone } = useTimeZone(), { customValidation, customValidationMessage, timeStep } = parseOptions(type.options), handleChange = React.useCallback(
    (nextDate) => {
      let date = nextDate;
      date !== null && timeStep > 1 && (date = enforceTimeStep(date, timeStep)), onChange(date);
    },
    [onChange, timeStep]
  ), formatInputValue = React.useCallback(
    (date) => formatInTimeZone(date, timeZone.name, `${inputDateTimeFormat}`),
    [inputDateTimeFormat, timeZone.name]
  ), parseInputValue = React.useCallback(
    (inputValue) => {
      const parsed = dateFns.parse(inputValue, `${inputDateTimeFormat}`, getCurrentZoneDate());
      return dateFns.isValid(parsed) ? customValidation(parsed) ? {
        isValid: !0,
        date: parsed
      } : {
        isValid: !1,
        error: customValidationMessage
      } : {
        isValid: !1,
        error: `Invalid date. Must be in the format "${inputDateTimeFormat}"`
      };
    },
    [customValidation, customValidationMessage, getCurrentZoneDate, inputDateTimeFormat]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommonDateTimeInput,
    {
      ...rest,
      onChange: handleChange,
      ref: forwardedRef,
      selectTime: !0,
      timeStep,
      title,
      description,
      placeholder,
      serialize: serialize$1,
      deserialize: deserialize$1,
      formatInputValue,
      customValidation,
      parseInputValue
    }
  );
}), ScheduleForm = (props2) => {
  const { onChange, value } = props2, { getCurrentZoneDate } = useTimeZone(), [inputValue, setInputValue] = React.useState();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(
    DateTimeInput,
    {
      level: 0,
      markers: [],
      onChange: (date) => {
        date && onChange && (onChange({ date }), setInputValue(date));
      },
      type: {
        name: "date",
        options: {
          customValidation: (selectedDate) => selectedDate > getCurrentZoneDate(),
          customValidationMessage: "Date cannot be in the past."
        },
        title: "Date and time"
      },
      value: inputValue === void 0 ? value == null ? void 0 : value.date : inputValue
    }
  ) }) });
};
function EditScheduleForm(props2) {
  const { onChange, value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    props2.children,
    /* @__PURE__ */ jsxRuntime.jsx(ScheduleForm, { onChange, value })
  ] });
}
const DialogHeader = (props2) => {
  const { title } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ButtonTimeZoneElementQuery, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
    title,
    /* @__PURE__ */ jsxRuntime.jsx("input", { style: { opacity: 0, position: "absolute", width: 0 }, tabIndex: -1, type: "button" }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 2, style: { marginTop: "-1em", marginBottom: "-1em" }, children: /* @__PURE__ */ jsxRuntime.jsx(ButtonTimeZone, { useElementQueries: !0 }) })
  ] }) });
}, DialogScheduleEdit = (props2) => {
  const { onClose, schedule } = props2, { updateSchedule } = useScheduleOperation(), { formData, isDirty, onFormChange } = useScheduleForm(schedule), handleScheduleUpdate = React.useCallback(() => {
    formData != null && formData.date && updateSchedule({
      date: formData.date,
      scheduleId: schedule.id
    }).then(onClose);
  }, [schedule.id, updateSchedule, onClose, formData == null ? void 0 : formData.date]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      footer: {
        confirmButton: {
          text: "Update",
          disabled: !isDirty,
          onClick: handleScheduleUpdate
        }
      },
      header: /* @__PURE__ */ jsxRuntime.jsx(DialogHeader, { title: "Edit schedule" }),
      id: "time-zone",
      onClose,
      width: 1,
      children: /* @__PURE__ */ jsxRuntime.jsx(EditScheduleForm, { onChange: onFormChange, value: formData })
    }
  );
};
function useDialogScheduleEdit(schedule) {
  const { visible, show, hide } = useDialogVisible();
  return {
    DialogScheduleEdit: visible ? DialogScheduleEdit : null,
    dialogProps: {
      onClose: hide,
      schedule,
      visible
    },
    dialogScheduleEditShow: show,
    hide
  };
}
const EMPTY_ARRAY$d = [];
function InsufficientPermissionsMessage({
  currentUser,
  context
}) {
  const { t: t2 } = useTranslation(), list = useListFormat({ style: "short", type: "unit" }), roles = (currentUser == null ? void 0 : currentUser.roles) || EMPTY_ARRAY$d, Roles = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: list.formatToParts(roles.map((role) => role.title || startCase__default.default(role.name))).map(
      (i, index) => i.type === "element" ? (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ jsxRuntime.jsx("code", { children: i.value }, `${i.value}-${index}`)
      ) : (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ jsxRuntime.jsx(React.Fragment, { children: i.value }, `${i.value}-${index}`)
      )
    ) }),
    [roles, list]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.AccessDeniedIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t2("insufficient-permissions-message.title") })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      Translate,
      {
        i18nKey: "insufficient-permissions-message.not-authorized-explanation",
        t: t2,
        context
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { marginTop: 4, marginBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { i18nKey: "insufficient-permissions-message.roles", t: t2, components: { Roles } }) }) })
  ] });
}
const MenuItemWithPermissionsTooltip = (props2) => {
  const {
    currentUser,
    hasPermission,
    icon,
    onClick,
    permissionsOperationLabel,
    title,
    tone,
    disabled
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        InsufficientPermissionsMessage,
        {
          currentUser,
          context: permissionsOperationLabel
        }
      ) }),
      disabled: hasPermission,
      placement: "left",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.MenuItem,
        {
          disabled: !hasPermission || disabled,
          icon,
          onClick,
          text: title,
          tone
        }
      ) })
    }
  );
}, ContextMenuItems = (props2) => {
  const { actions, onDelete, onEdit, schedule, schemaType } = props2, { mode } = useScheduledPublishingEnabled(), firstDocument = getScheduledDocument(schedule), currentUser = useCurrentUser(), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: firstDocument.documentId,
    type: schemaType == null ? void 0 : schemaType.name,
    permission: "publish"
  }), { deleteSchedule, publishSchedule } = useScheduleOperation(), insufficientPermissions = !isPermissionsLoading && !(permissions != null && permissions.granted), handleEdit = () => {
    onEdit == null || onEdit();
  }, handleDelete = () => {
    deleteSchedule({ schedule }).then(() => onDelete == null ? void 0 : onDelete());
  }, handleExecute = () => {
    publishSchedule({ schedule });
  };
  return currentUser ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    (actions == null ? void 0 : actions.edit) && /* @__PURE__ */ jsxRuntime.jsx(
      MenuItemWithPermissionsTooltip,
      {
        currentUser,
        hasPermission: !insufficientPermissions,
        icon: icons.CalendarIcon,
        onClick: handleEdit,
        permissionsOperationLabel: "edit-schedules",
        title: "Edit schedule",
        disabled: mode === "upsell"
      }
    ),
    (actions == null ? void 0 : actions.execute) && /* @__PURE__ */ jsxRuntime.jsx(
      MenuItemWithPermissionsTooltip,
      {
        currentUser,
        hasPermission: !insufficientPermissions,
        icon: icons.PublishIcon,
        onClick: handleExecute,
        permissionsOperationLabel: "execute-schedules",
        title: "Publish now",
        disabled: mode === "upsell"
      }
    ),
    (actions == null ? void 0 : actions.delete) && /* @__PURE__ */ jsxRuntime.jsx(
      MenuItemWithPermissionsTooltip,
      {
        currentUser,
        hasPermission: !insufficientPermissions,
        icon: icons.TrashIcon,
        onClick: handleDelete,
        permissionsOperationLabel: "delete-schedules",
        title: "Delete schedule",
        tone: "critical",
        disabled: mode === "upsell"
      }
    ),
    (actions == null ? void 0 : actions.clear) && /* @__PURE__ */ jsxRuntime.jsx(
      MenuItemWithPermissionsTooltip,
      {
        currentUser,
        hasPermission: !insufficientPermissions,
        icon: icons.CheckmarkCircleIcon,
        onClick: handleDelete,
        permissionsOperationLabel: "delete-schedules",
        title: "Clear completed schedule",
        disabled: mode === "upsell"
      }
    )
  ] }) : null;
}, ScheduleContextMenu = (props2) => {
  const { actions, onDelete, onEdit, schedule, schemaType } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
      id: "contextMenu",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsx(
        ContextMenuItems,
        {
          actions,
          onDelete,
          onEdit,
          schedule,
          schemaType
        }
      ) }),
      placement: "left",
      popover: { portal: !0, tone: "default" }
    }
  );
}, EMPTY_VALIDATION_STATUS = {
  validation: [],
  isValidating: !1
};
function getValidationState(validationMarkers = EMPTY_VALIDATION_STATUS.validation) {
  const hasError = validationMarkers.filter(types.isValidationErrorMarker).length > 0, hasWarning = validationMarkers.filter(types.isValidationWarningMarker).length > 0;
  let validationTone = "default";
  return hasWarning && (validationTone = "default"), hasError && (validationTone = "critical"), {
    markers: validationMarkers,
    validationTone,
    hasError,
    hasWarning
  };
}
function useValidationState(markers) {
  return React.useMemo(() => getValidationState(markers), [markers]);
}
const INITIAL$1 = { validation: [], isValidating: !1 };
function useValidationStatus(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.validation(publishedDocId, docTypeName),
    [documentStore.pair, publishedDocId, docTypeName],
    INITIAL$1
  );
}
const VALIDATION_DELAY_MS = 1500;
function ValidateScheduleDoc({ schedule, updateValidation }) {
  const schemaType = useScheduleSchemaType(schedule), id2 = getScheduledDocumentId(schedule);
  return !id2 || !(schemaType != null && schemaType.name) ? null : /* @__PURE__ */ jsxRuntime.jsx(
    DelayedValidationRunner,
    {
      id: id2,
      schemaName: schemaType.name,
      updateValidation
    }
  );
}
function DelayedValidationRunner({ id: id2, schemaName, updateValidation }) {
  const [ready, setReady] = React.useState(!1);
  return React.useEffect(() => {
    const timeout = setTimeout(() => {
      setReady(!0);
    }, VALIDATION_DELAY_MS);
    return () => {
      clearTimeout(timeout);
    };
  }, []), ready ? /* @__PURE__ */ jsxRuntime.jsx(ValidationRunner, { id: id2, schemaName, updateValidation }) : null;
}
function ValidationRunner({ id: id2, schemaName, updateValidation }) {
  const validationStatus = useValidationStatus(id2, schemaName);
  return React.useEffect(() => {
    validationStatus.isValidating || updateValidation(validationStatus);
  }, [updateValidation, validationStatus]), null;
}
function usePublishedId(id2) {
  return React.useMemo(() => id2 ? id2.replaceAll("drafts.", "") : void 0, [id2]);
}
const StyledText$2 = styledComponents.styled(ui.Text)`
  white-space: initial;
`, MENU_ITEM_TONES = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationListItem(props2) {
  var _a2, _b;
  const { marker, onClick, path, truncate: truncate2 } = props2, handleClick = React.useCallback(() => {
    onClick && onClick(marker.path);
  }, [marker.path, onClick]), menuItemTone = MENU_ITEM_TONES[marker == null ? void 0 : marker.level] || void 0, message = (_b = marker.message) != null ? _b : (_a2 = marker.item) == null ? void 0 : _a2.message, children = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
      marker.level === "error" && /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}),
      marker.level === "warning" && /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}),
      marker.level === "info" && /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {})
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, flex: 1, paddingLeft: 3, children: [
      path && /* @__PURE__ */ jsxRuntime.jsx(StyledText$2, { size: 1, weight: "semibold", children: path }),
      message && /* @__PURE__ */ jsxRuntime.jsx(StyledText$2, { muted: !0, size: 1, textOverflow: truncate2 ? "ellipsis" : void 0, children: message })
    ] })
  ] });
  return /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { padding: 1, onClick: handleClick, radius: 2, tone: menuItemTone, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children }) });
}
function ValidationList(props2) {
  const { documentType, kind, validation: validation2, onFocus, onClose, truncate: truncate2 } = props2, errors = validation2.filter(types.isValidationErrorMarker), warnings = validation2.filter(types.isValidationWarningMarker), info = validation2.filter(types.isValidationInfoMarker), handleClick = React.useCallback(
    (path = []) => {
      onFocus && onFocus(path), onClose && onClose();
    },
    [onFocus, onClose]
  ), resolvePathTitle = (path) => {
    const fields = documentType && documentType.fields, field = fields && fields.find((curr) => curr.name === path[0]);
    return field && field.type.title || "";
  }, hasErrors = errors.length > 0, hasWarnings = warnings.length > 0, hasInfo = info.length > 0;
  return !hasErrors && !hasWarnings && !hasInfo ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Container, { width: 0, "data-kind": kind, "data-testid": "validation-list", children: [
    hasErrors && errors.map((_error, i) => /* @__PURE__ */ jsxRuntime.jsx(
      ValidationListItem,
      {
        truncate: truncate2,
        path: resolvePathTitle(_error.path),
        marker: _error,
        onClick: handleClick
      },
      i
    )),
    hasWarnings && warnings.map((_warning, i) => /* @__PURE__ */ jsxRuntime.jsx(
      ValidationListItem,
      {
        truncate: truncate2,
        path: resolvePathTitle(_warning.path),
        marker: _warning,
        onClick: handleClick
      },
      i
    )),
    hasInfo && info.map((_info, i) => /* @__PURE__ */ jsxRuntime.jsx(
      ValidationListItem,
      {
        truncate: truncate2,
        path: resolvePathTitle(_info.path),
        marker: _info,
        onClick: handleClick
      },
      i
    ))
  ] });
}
const POPOVER_PROPS$3 = {
  portal: !0,
  constrainSize: !0,
  preventOverflow: !0,
  tone: "default",
  width: 0,
  placement: "bottom-end"
};
function ValidationInfo(props2) {
  const { type, markers, menuHeader, documentId } = props2, router$1 = router.useRouter(), { hasError, hasWarning } = useValidationState(markers), visibility = hasError || hasWarning ? "visible" : "hidden", id2 = React.useId() || "", publishId = usePublishedId(documentId), onFocus = React.useCallback(
    (path) => {
      publishId && router$1.navigateIntent("edit", {
        id: publishId,
        path: encodeURIComponent(PathUtils__namespace.toString(path))
      });
    },
    [router$1, publishId]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      id: id2 || "",
      button: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          tooltipProps: { content: "Show validation issues" },
          mode: "bleed",
          "data-testid": "schedule-validation-list-button",
          icon: hasError ? icons.ErrorOutlineIcon : icons.WarningOutlineIcon,
          style: { visibility },
          tone: hasError ? "critical" : "default"
        }
      ),
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 1, children: [
        menuHeader != null ? menuHeader : null,
        /* @__PURE__ */ jsxRuntime.jsx(
          ValidationList,
          {
            documentType: type,
            validation: markers,
            onFocus
          }
        )
      ] }) }) }),
      popover: POPOVER_PROPS$3
    }
  );
}
const DateWithTooltip = (props2) => {
  const { date, useElementQueries } = props2, { formatDateTz } = useTimeZone(), distance = dateFns.formatDistance(date, /* @__PURE__ */ new Date(), {
    addSuffix: !0
  }), dateTimeLarge = formatDateTz({ date, format: DATE_FORMAT.LARGE }), dateTimeMedium = formatDateTz({ date, format: DATE_FORMAT.MEDIUM }), dateTimeSmall = formatDateTz({ date, format: DATE_FORMAT.SMALL });
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: distance, portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx("span", { children: useElementQueries ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("span", { className: "date-small", children: dateTimeSmall }),
    /* @__PURE__ */ jsxRuntime.jsx("span", { className: "date-medium", children: dateTimeMedium }),
    /* @__PURE__ */ jsxRuntime.jsx("span", { className: "date-large", children: dateTimeLarge })
  ] }) : dateTimeLarge }) }) });
}, POPOVER_PROPS$2 = {
  portal: !0,
  constrainSize: !0,
  preventOverflow: !0,
  tone: "default",
  width: 0
}, StateReasonFailedInfo = (props2) => {
  const { stateReason } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      id: "stateReason",
      button: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          tooltipProps: { content: "Schedule failed" },
          mode: "bleed",
          "data-testid": "schedule-validation-list-button",
          icon: icons.ErrorOutlineIcon,
          tone: "critical"
        }
      ),
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Container, { padding: 2, width: 0, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: SCHEDULE_FAILED_TEXT }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, marginTop: 4, padding: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, style: { color: color.red[700].hex }, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, style: { color: color.red[700].hex }, weight: "medium", children: stateReason })
        ] })
      ] }) }),
      popover: POPOVER_PROPS$2
    }
  );
}, User = (props2) => {
  const { id: id2 } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { user: id2, withTooltip: !0 });
}, StatusDotPlaceholder = styledComponents.styled(ui.Box)`
  width: 9px;
`, PreviewWrapper = (props2) => {
  const {
    children,
    contextMenu,
    linkComponent,
    onClick,
    previewState,
    publishedDocumentId,
    schedule,
    schemaType,
    useElementQueries
  } = props2, { mode } = useScheduledPublishingEnabled(), [validationStatus, setValidationStatus] = React.useState(EMPTY_VALIDATION_STATUS), { validation: validation2 } = validationStatus, { hasError, validationTone } = useValidationState(validation2), { formatDateTz } = useTimeZone(), executeDate = getLastExecuteDate(schedule), scheduleDate = executeDate ? new Date(executeDate) : null;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Card,
    {
      padding: 1,
      radius: 2,
      shadow: 1,
      tone: validationTone,
      style: mode === "upsell" && schedule.state === "scheduled" ? { opacity: 0.7 } : void 0,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, justify: "space-between", children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Tooltip,
          {
            delay: { open: 400 },
            placement: "bottom-end",
            content: /* @__PURE__ */ jsxRuntime.jsx(DocumentStatus, { draft: previewState == null ? void 0 : previewState.draft, published: previewState == null ? void 0 : previewState.published }),
            disabled: !(previewState != null && previewState.draft) && !(previewState != null && previewState.published),
            children: /* @__PURE__ */ jsxRuntime.jsx(
              ui.Card,
              {
                __unstable_focusRing: !0,
                as: linkComponent || void 0,
                "data-as": onClick || linkComponent ? "a" : void 0,
                flex: 1,
                onClick,
                padding: 1,
                radius: 2,
                tabIndex: 0,
                tone: validationTone,
                children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, justify: "flex-start", paddingLeft: children ? 0 : [1, 2], children: [
                  children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { flexBasis: "auto", flexGrow: 1 }, children }),
                  schedule.action === "unpublish" && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { style: { flexShrink: 0 }, children: /* @__PURE__ */ jsxRuntime.jsx(
                    ui.Badge,
                    {
                      fontSize: 0,
                      mode: "outline",
                      tone: SCHEDULE_ACTION_DICTIONARY[schedule.action].badgeTone,
                      children: schedule.action
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { display: ["block", "none"], style: { flexShrink: 0, width: "90px" }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: scheduleDate ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: formatDateTz({ date: scheduleDate, format: "dd/MM/yyyy" }) }),
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: formatDateTz({ date: scheduleDate, format: "p" }) })
                  ] }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx("em", { children: "No date specified" }) }) }) }),
                  /* @__PURE__ */ jsxRuntime.jsx(
                    ui.Box,
                    {
                      display: ["none", "block"],
                      style: { flexShrink: 0, maxWidth: "250px", width: children ? "35%" : "auto" },
                      children: scheduleDate ? /* @__PURE__ */ jsxRuntime.jsx(DateWithTooltip, { date: scheduleDate, useElementQueries }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx("em", { children: "No date specified" }) })
                    }
                  ),
                  !children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { visibility: "hidden" }, children: /* @__PURE__ */ jsxRuntime.jsx(SanityDefaultPreview, { isPlaceholder: !0 }) }),
                  /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", style: { flexShrink: 0, marginLeft: "auto" }, children: [
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { display: ["none", "none", "block"], marginX: 3, style: { flexShrink: 0 }, children: /* @__PURE__ */ jsxRuntime.jsx(User, { id: schedule == null ? void 0 : schedule.author }) }),
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { display: ["none", "block"], marginX: [2, 2, 3], style: { flexShrink: 0 }, children: previewState != null && previewState.draft || previewState != null && previewState.published ? /* @__PURE__ */ jsxRuntime.jsx(
                      DocumentStatusIndicator,
                      {
                        draft: previewState == null ? void 0 : previewState.draft,
                        published: previewState == null ? void 0 : previewState.published
                      }
                    ) : /* @__PURE__ */ jsxRuntime.jsx(StatusDotPlaceholder, {}) })
                  ] })
                ] })
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "center", style: { width: "38px" }, children: [
          schedule.state === "scheduled" && /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(ValidateScheduleDoc, { schedule, updateValidation: setValidationStatus }),
            /* @__PURE__ */ jsxRuntime.jsx(
              ValidationInfo,
              {
                markers: validation2,
                type: schemaType,
                documentId: publishedDocumentId,
                menuHeader: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: hasError ? DOCUMENT_HAS_ERRORS_TEXT : DOCUMENT_HAS_WARNINGS_TEXT }) })
              }
            )
          ] }),
          schedule.state === "cancelled" && /* @__PURE__ */ jsxRuntime.jsx(StateReasonFailedInfo, { stateReason: schedule.stateReason })
        ] }),
        schedule.state === "cancelled" && /* @__PURE__ */ jsxRuntime.jsx(StateReasonFailedInfo, { stateReason: schedule.stateReason }),
        contextMenu && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { flexShrink: 0 }, paddingRight: 2, children: contextMenu })
      ] })
    }
  );
}, DocumentPreview$1 = (props2) => {
  const { schedule, schemaType } = props2, { DialogScheduleEdit: DialogScheduleEdit2, dialogProps, dialogScheduleEditShow } = useDialogScheduleEdit(schedule), { onComplete } = useDocumentActionProps(), publishedId = React.useMemo(() => getScheduledDocumentId(schedule), [schedule]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    DialogScheduleEdit2 && /* @__PURE__ */ jsxRuntime.jsx(DialogScheduleEdit2, { ...dialogProps }),
    /* @__PURE__ */ jsxRuntime.jsx(
      PreviewWrapper,
      {
        contextMenu: /* @__PURE__ */ jsxRuntime.jsx(
          ScheduleContextMenu,
          {
            actions: {
              delete: !0,
              edit: !0
            },
            onDelete: onComplete,
            onEdit: dialogScheduleEditShow,
            schedule,
            schemaType
          }
        ),
        onClick: dialogScheduleEditShow,
        publishedDocumentId: publishedId,
        schedule,
        schemaType
      }
    )
  ] });
}, FallbackContextMenu = (props2) => {
  const { onDelete, schedule } = props2, { deleteSchedule } = useScheduleOperation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
      id: "contextMenu",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.MenuItem,
        {
          icon: icons.TrashIcon,
          onClick: () => {
            deleteSchedule({ schedule }).then(() => onDelete == null ? void 0 : onDelete());
          },
          text: "Delete schedule",
          tone: "critical"
        }
      ) }),
      placement: "left",
      popover: { portal: !0, tone: "default" }
    }
  );
}, NoSchemaItem = ({ schedule }) => /* @__PURE__ */ jsxRuntime.jsx(
  PreviewWrapper,
  {
    contextMenu: /* @__PURE__ */ jsxRuntime.jsx(FallbackContextMenu, { schedule }),
    schedule,
    useElementQueries: !0,
    children: /* @__PURE__ */ jsxRuntime.jsx(
      SanityDefaultPreview,
      {
        icon: icons.UnknownIcon,
        layout: "default",
        subtitle: /* @__PURE__ */ jsxRuntime.jsx("em", { children: "It may have been deleted" }),
        title: /* @__PURE__ */ jsxRuntime.jsx("em", { style: { color: color.red[600].hex }, children: "Document not found" })
      }
    )
  }
), ToolPreview = (props2) => {
  const { previewState, schedule, schemaType } = props2, visibleDocument = previewState.draft || previewState.published, isCompleted = schedule.state === "succeeded", isScheduled = schedule.state === "scheduled", { DialogScheduleEdit: DialogScheduleEdit2, dialogProps, dialogScheduleEditShow } = useDialogScheduleEdit(schedule), publishedId = usePublishedId(visibleDocument == null ? void 0 : visibleDocument._id), LinkComponent2 = React.useMemo(() => {
    const Component = React.forwardRef((linkProps, ref) => /* @__PURE__ */ jsxRuntime.jsx(
      router.IntentLink,
      {
        ...linkProps,
        intent: "edit",
        params: {
          type: schemaType.name,
          id: visibleDocument && getPublishedId(visibleDocument == null ? void 0 : visibleDocument._id)
        },
        ref
      }
    ));
    return Component.displayName = "LinkComponent", Component;
  }, [schemaType, visibleDocument]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    DialogScheduleEdit2 && /* @__PURE__ */ jsxRuntime.jsx(DialogScheduleEdit2, { ...dialogProps }),
    /* @__PURE__ */ jsxRuntime.jsx(
      PreviewWrapper,
      {
        contextMenu: /* @__PURE__ */ jsxRuntime.jsx(
          ScheduleContextMenu,
          {
            actions: {
              clear: isCompleted,
              delete: !isCompleted,
              edit: isScheduled,
              execute: isScheduled
            },
            onEdit: dialogScheduleEditShow,
            schedule,
            schemaType
          }
        ),
        linkComponent: LinkComponent2,
        previewState,
        publishedDocumentId: publishedId,
        schedule,
        schemaType,
        useElementQueries: !0,
        children: previewState.isLoading ? /* @__PURE__ */ jsxRuntime.jsx(
          SanityDefaultPreview,
          {
            icon: schemaType == null ? void 0 : schemaType.icon,
            isPlaceholder: previewState.isLoading,
            layout: "default"
          }
        ) : /* @__PURE__ */ jsxRuntime.jsx(Preview$1, { layout: "default", schemaType, value: visibleDocument })
      }
    )
  ] });
}, ScheduleItem = (props2) => {
  const { schedule, type } = props2, firstDocument = getScheduledDocument(schedule), schemaType = useScheduleSchemaType(schedule), previewState = usePreviewState(firstDocument == null ? void 0 : firstDocument.documentId, schemaType), invalidDocument = !(previewState.draft || previewState.published) && !previewState.isLoading, preview = React.useMemo(() => !schemaType || invalidDocument ? /* @__PURE__ */ jsxRuntime.jsx(NoSchemaItem, { schedule }) : type === "document" ? /* @__PURE__ */ jsxRuntime.jsx(DocumentPreview$1, { schedule, schemaType }) : type === "tool" ? /* @__PURE__ */ jsxRuntime.jsx(ToolPreview, { previewState, schedule, schemaType }) : null, [invalidDocument, type, previewState, schedule, schemaType]);
  return /* @__PURE__ */ jsxRuntime.jsx(DateWithTooltipElementQuery, { children: preview });
}, SCHEDULE_RENDER_DELAY_MS = 200;
function VirtualListItem(props2) {
  const {
    item: { content: content2, virtualRow },
    measureElement
  } = props2, style = React.useMemo(
    () => ({
      position: "absolute",
      top: 0,
      left: 0,
      width: "100%",
      transform: `translateY(${virtualRow.start}px)`
    }),
    [virtualRow]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Box,
    {
      "data-index": virtualRow.index,
      paddingBottom: 2,
      ref: measureElement,
      style,
      children: typeof content2 == "string" ? /* @__PURE__ */ jsxRuntime.jsx(MonthHeading, { content: content2 }) : /* @__PURE__ */ jsxRuntime.jsx(DelayedScheduleItem, { schedule: content2 })
    },
    virtualRow.key
  );
}
function DelayedScheduleItem({ schedule }) {
  const [delayedScheduleItem, setDelayedScheduleItem] = React.useState(/* @__PURE__ */ jsxRuntime.jsx(PlaceholderScheduleItem, {}));
  return React.useEffect(() => {
    let canUpdate = !0;
    const timeout = setTimeout(() => {
      canUpdate && setDelayedScheduleItem(/* @__PURE__ */ jsxRuntime.jsx(ScheduleItem, { schedule, type: "tool" }));
    }, SCHEDULE_RENDER_DELAY_MS);
    return () => {
      canUpdate = !1, clearTimeout(timeout);
    };
  }, [schedule]), delayedScheduleItem;
}
function MonthHeading({ content: content2 }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "flex-end", paddingBottom: 2, paddingTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { muted: !0, size: 1, children: content2 }) });
}
function PlaceholderScheduleItem() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, radius: 2, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(SanityDefaultPreview, { isPlaceholder: !0 }) }) });
}
function getLocalizedDate(date) {
  return new Date(date).toLocaleString("default", {
    month: "long",
    year: "numeric"
  });
}
const VirtualList = () => {
  const { activeSchedules, scheduleState, sortBy: sortBy2 } = useSchedules(), { measureElement, virtualList, totalSize, containerRef } = useVirtualizedSchedules(
    activeSchedules,
    sortBy2
  ), { deleteSchedules } = useScheduleOperation(), handleClearSchedules = () => {
    deleteSchedules({ schedules: activeSchedules || [] });
  };
  return React.useEffect(() => {
    var _a2;
    (_a2 = containerRef == null ? void 0 : containerRef.current) == null || _a2.scrollTo(0, 0);
  }, [scheduleState, sortBy2, containerRef]), /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Box,
    {
      paddingBottom: 6,
      paddingTop: 1,
      paddingX: 4,
      ref: containerRef,
      style: {
        position: "relative",
        overflowX: "hidden",
        overflowY: "auto",
        height: "100%",
        boxSizing: "border-box"
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Box,
          {
            style: {
              height: `${totalSize}px`,
              width: "100%",
              position: "relative"
            },
            children: virtualList.map((item) => /* @__PURE__ */ jsxRuntime.jsx(VirtualListItem, { item, measureElement }, item.key))
          }
        ),
        scheduleState === "succeeded" && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", marginTop: 6, children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            icon: icons.CheckmarkCircleIcon,
            mode: "ghost",
            onClick: handleClearSchedules,
            text: "Clear all completed schedules"
          }
        ) })
      ]
    }
  );
};
function useVirtualizedSchedules(activeSchedules, sortBy2) {
  const containerRef = React.useRef(null), listSourceItems = React.useMemo(() => {
    const items = [];
    return activeSchedules.forEach((schedule, index) => {
      if (sortBy2 == "executeAt") {
        const previousSchedule = activeSchedules[index - 1], previousExecuteDate = getLastExecuteDate(previousSchedule), datePrevious = index > 0 && previousExecuteDate ? getLocalizedDate(previousExecuteDate) : null, currentExecuteDate = getLastExecuteDate(schedule), dateCurrent = currentExecuteDate ? getLocalizedDate(currentExecuteDate) : null;
        dateCurrent !== datePrevious && items.push(dateCurrent || "No date specified");
      }
      items.push(schedule);
    }), items;
  }, [activeSchedules, sortBy2]), virtualizer = reactVirtual.useVirtualizer({
    count: listSourceItems.length,
    getScrollElement: () => containerRef.current,
    estimateSize: () => 50,
    overscan: 5
  }), virtualList = virtualizer.getVirtualItems().map((virtualRow) => {
    const item = listSourceItems[virtualRow.index];
    return {
      content: item,
      key: typeof item == "string" ? item : item.id,
      virtualRow
    };
  });
  return {
    containerRef,
    measureElement: virtualizer.measureElement,
    totalSize: virtualizer.getTotalSize(),
    virtualList
  };
}
const Panel = styledComponents.styled(ui.Container)`
  width: auto;
`, Schedules$1 = () => {
  const { activeSchedules, selectedDate, scheduleState } = useSchedules(), { upsellData, telemetryLogs } = useSchedulePublishingUpsell(), { mode } = useScheduledPublishingEnabled(), showWarning = mode === "upsell" && scheduleState === "scheduled";
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { style: { height: "100%" }, children: [
    mode === "upsell" && upsellData && /* @__PURE__ */ jsxRuntime.jsx(Panel, { width: 1, padding: 4, paddingBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      UpsellPanel,
      {
        layout: "horizontal",
        data: upsellData,
        onPrimaryClick: telemetryLogs.panelPrimaryClicked,
        onSecondaryClick: telemetryLogs.panelSecondaryClicked
      }
    ) }),
    activeSchedules.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(Panel, { width: 1, padding: 4, paddingTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(EmptySchedules, { scheduleState, selectedDate }) }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      showWarning && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { margin: 4, marginBottom: 2, padding: 3, tone: "caution", radius: 3, shadow: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "Your scheduled documents won't be published automatically unless you upgrade your plan. You can still publish them manually." })
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: showWarning ? 0 : 4, children: /* @__PURE__ */ jsxRuntime.jsx(VirtualList, {}) })
    ] })
  ] });
}, SchedulesContextMenu = () => {
  const { setSortBy, sortBy: sortBy2 } = useSchedules();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
      id: "sort",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { style: { minWidth: "250px" }, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            icon: icons.SortIcon,
            iconRight: sortBy2 === "createdAt" ? icons.CheckmarkIcon : void 0,
            onClick: () => setSortBy("createdAt"),
            text: "Sort by time added"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            icon: icons.SortIcon,
            iconRight: sortBy2 === "executeAt" ? icons.CheckmarkIcon : void 0,
            onClick: () => setSortBy("executeAt"),
            text: "Sort by time scheduled"
          }
        )
      ] })
    }
  );
}, Pip = (props2) => {
  const { mode = "default", selected } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Box,
    {
      style: {
        ...mode === "default" ? {
          background: color.gray[selected ? 100 : 300].hex
        } : {},
        ...mode === "failed" ? {
          background: color.red[500].hex
        } : {},
        borderRadius: "2px",
        height: "2px",
        width: "100%"
      }
    }
  );
};
function CalendarDay(props2) {
  const { date, focused, isCurrentMonth, isToday, onSelect, selected } = props2, { schedulesByDate } = useSchedules(), schedules = schedulesByDate(date), handleClick = React.useCallback(() => {
    onSelect(selected ? void 0 : date);
  }, [date, onSelect, selected]);
  let tone;
  isToday || selected ? tone = "primary" : (dateFns.isWeekend(date), tone = "default");
  const hasSchedules = schedules.length > 0, { completed, failed, upcoming } = React.useMemo(() => ({
    completed: schedules.filter((s) => s.state === "succeeded"),
    failed: schedules.filter((s) => s.state === "cancelled"),
    upcoming: schedules.filter((s) => s.state === "scheduled")
  }), [schedules]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", { "aria-selected": selected, "data-ui": "CalendarDay", children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(TooltipContent, { date, schedules }),
      disabled: !hasSchedules,
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        ui.Card,
        {
          "aria-label": date.toDateString(),
          "aria-pressed": selected,
          as: "button",
          __unstable_focusRing: !0,
          "data-weekday": !0,
          "data-focused": focused ? "true" : "",
          role: "button",
          tabIndex: -1,
          onClick: handleClick,
          paddingX: 3,
          paddingY: 4,
          radius: 2,
          selected,
          style: { position: "relative" },
          tone,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              ui.Text,
              {
                size: 1,
                style: {
                  opacity: !selected && !isCurrentMonth ? 0.35 : 1,
                  textAlign: "center"
                },
                children: selected ? /* @__PURE__ */ jsxRuntime.jsx(icons.CloseIcon, {}) : date.getDate()
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              ui.Box,
              {
                style: {
                  bottom: 2,
                  left: 2,
                  position: "absolute",
                  right: 2
                },
                children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, justify: "center", children: [
                  completed.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(Pip, { selected }),
                  upcoming.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(Pip, { selected }),
                  failed.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(Pip, { mode: "failed", selected })
                ] })
              }
            )
          ]
        }
      )
    }
  ) });
}
function TooltipContent(props2) {
  const { date, schedules = [] } = props2, { formatDateTz } = useTimeZone(), schedulesByState = schedules.reduce(
    (acc, val) => (acc[val.state].push(val), acc),
    {
      cancelled: [],
      succeeded: [],
      scheduled: []
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: dateFns.format(date, "d MMMM yyyy") }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: Object.keys(schedulesByState).map((key) => {
      const stateSchedules = schedulesByState[key];
      return stateSchedules.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { muted: !0, size: 0, children: SCHEDULE_STATE_DICTIONARY[key].title }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: stateSchedules.filter((schedule) => schedule.executeAt).map((schedule) => {
          const executeDate = getLastExecuteDate(schedule);
          return executeDate ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { width: "60px" }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "regular", children: formatDateTz({ date: new Date(executeDate), format: "p" }) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(
              ui.Flex,
              {
                align: "center",
                style: { flexShrink: 0, opacity: schedule.action === "unpublish" ? 1 : 0 },
                children: /* @__PURE__ */ jsxRuntime.jsx(
                  ui.Badge,
                  {
                    fontSize: 0,
                    mode: "outline",
                    tone: SCHEDULE_ACTION_DICTIONARY[schedule.action].badgeTone,
                    children: schedule.action
                  }
                )
              }
            )
          ] }, schedule.id) : null;
        }) })
      ] }, key);
    }) })
  ] });
}
const MONTH_NAMES = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], WEEK_DAY_NAMES = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], TAIL_WEEKDAYS = [1, 2, 3, 4, 5, 6], getWeekStartsOfMonth = (date) => {
  const firstDay = dateFns.startOfMonth(date);
  return dateFns.eachWeekOfInterval({
    start: firstDay,
    end: dateFns.lastDayOfMonth(firstDay)
  });
}, getWeekDaysFromWeekStarts = (weekStarts) => weekStarts.map((weekStart) => [
  weekStart,
  ...TAIL_WEEKDAYS.map((d) => dateFns.addDays(weekStart, d))
]), getWeeksOfMonth = (date) => getWeekDaysFromWeekStarts(getWeekStartsOfMonth(date)).map(
  (days) => ({
    number: dateFns.getWeek(days[0]),
    days
  })
);
function CalendarMonth(props2) {
  const { getCurrentZoneDate } = useTimeZone();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "aria-hidden": props2.hidden || !1, "data-ui": "CalendarMonth", children: /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Grid,
    {
      style: {
        gridGap: "1px",
        gridTemplateColumns: "repeat(7, 1fr)"
      },
      children: [
        WEEK_DAY_NAMES.map((weekday) => /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            paddingY: 3,
            children: /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { size: 1, style: { textAlign: "center" }, children: weekday.slice(0, 1) })
          },
          weekday
        )),
        getWeeksOfMonth(props2.date).map(
          (week, weekIdx) => week.days.map((date, dayIdx) => {
            const focused = props2.focused && dateFns.isSameDay(date, props2.focused), selected = props2.selected && dateFns.isSameDay(date, props2.selected), isToday = dateFns.isSameDay(date, getCurrentZoneDate()), isCurrentMonth = props2.focused && dateFns.isSameMonth(date, props2.focused);
            return /* @__PURE__ */ jsxRuntime.jsx(
              CalendarDay,
              {
                date,
                focused,
                isCurrentMonth,
                isToday,
                onSelect: props2.onSelect,
                selected
              },
              `${weekIdx}-${dayIdx}`
            );
          })
        )
      ]
    }
  ) });
}
const PRESERVE_FOCUS_ELEMENT = /* @__PURE__ */ jsxRuntime.jsx(
  "span",
  {
    "data-preserve-focus": !0,
    style: { overflow: "hidden", position: "absolute", outline: "none" },
    tabIndex: -1
  }
), Calendar = React.forwardRef(function(props2, forwardedRef) {
  const { focusedDate, onFocusedDateChange, onSelect, selectedDate, ...restProps } = props2, { zoneDateToUtc } = useTimeZone(), setFocusedDate = React.useCallback(
    (date) => onFocusedDateChange(zoneDateToUtc(date)),
    [onFocusedDateChange, zoneDateToUtc]
  ), moveFocusedDate = React.useCallback(
    (by) => setFocusedDate(dateFns.addMonths(focusedDate, by)),
    [focusedDate, setFocusedDate]
  ), handleDateChange = React.useCallback(
    (date) => {
      if (date) {
        const targetDate = zoneDateToUtc(
          dateFns.setMinutes(dateFns.setHours(date, date.getHours()), date.getMinutes())
        );
        onSelect(targetDate), onFocusedDateChange(targetDate);
      } else
        onSelect(void 0);
    },
    [onSelect, zoneDateToUtc, onFocusedDateChange]
  ), ref = ui.useForwardedRef(forwardedRef), focusCurrentWeekDay = React.useCallback(() => {
    var _a2, _b;
    (_b = (_a2 = ref.current) == null ? void 0 : _a2.querySelector('[data-focused="true"]')) == null || _b.focus();
  }, [ref]), handleKeyDown = React.useCallback(
    (event) => {
      var _a2, _b;
      if (ARROW_KEYS.includes(event.key)) {
        if (event.preventDefault(), event.currentTarget.hasAttribute("data-calendar-grid")) {
          focusCurrentWeekDay();
          return;
        }
        event.key === "ArrowUp" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, -7))), event.key === "ArrowDown" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, 7))), event.key === "ArrowLeft" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, -1))), event.key === "ArrowRight" && onFocusedDateChange(zoneDateToUtc(dateFns.addDays(focusedDate, 1))), (_b = (_a2 = ref.current) == null ? void 0 : _a2.querySelector("[data-preserve-focus]")) == null || _b.focus();
      }
    },
    [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate, zoneDateToUtc]
  );
  React.useEffect(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]), React.useEffect(() => {
    var _a2;
    (_a2 = document.activeElement) != null && _a2.matches(
      "[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]"
    ) && focusCurrentWeekDay();
  }, [ref, focusCurrentWeekDay, focusedDate]);
  const handleNowClick = React.useCallback(() => {
    const now = /* @__PURE__ */ new Date();
    onSelect(now), onFocusedDateChange(now);
  }, [onSelect, onFocusedDateChange]), handlePrevMonthClick = React.useCallback(() => moveFocusedDate(-1), [moveFocusedDate]), handleNextMonthClick = React.useCallback(() => moveFocusedDate(1), [moveFocusedDate]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { "data-ui": "Calendar", ...restProps, ref, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Flex,
      {
        align: "center",
        paddingLeft: 4,
        style: {
          borderBottom: "1px solid var(--card-border-color)",
          minHeight: `${TOOL_HEADER_HEIGHT}px`,
          position: "sticky",
          top: 0
        },
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, justify: "space-between", children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { weight: "medium", size: 1, children: [
            MONTH_NAMES[focusedDate == null ? void 0 : focusedDate.getMonth()],
            " ",
            focusedDate == null ? void 0 : focusedDate.getFullYear()
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { paddingRight: 3, gap: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.Button,
              {
                icon: icons.ChevronLeftIcon,
                mode: "bleed",
                onClick: handlePrevMonthClick,
                tooltipProps: { content: "Previous month" }
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.Button,
              {
                icon: icons.ChevronRightIcon,
                mode: "bleed",
                onClick: handleNextMonthClick,
                tooltipProps: { content: "Next month" }
              }
            )
          ] }) })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Box,
      {
        "data-calendar-grid": !0,
        onKeyDown: handleKeyDown,
        overflow: "hidden",
        paddingBottom: 1,
        paddingX: 1,
        tabIndex: 0,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            CalendarMonth,
            {
              date: focusedDate,
              focused: focusedDate,
              onSelect: handleDateChange,
              selected: selectedDate
            }
          ),
          PRESERVE_FOCUS_ELEMENT
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, style: { borderBottom: "1px solid var(--card-border-color)" }, children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { mode: "bleed", onClick: handleNowClick, width: "fill", text: "Today" }) })
  ] });
}), ToolCalendar = (props2) => {
  const { onSelect, selectedDate } = props2, { getCurrentZoneDate, utcToCurrentZoneDate } = useTimeZone(), [focusedDate, setFocusedDate] = React.useState(selectedDate || getCurrentZoneDate()), handleFocusDateChange = React.useCallback(
    (date) => {
      setFocusedDate(utcToCurrentZoneDate(date));
    },
    [utcToCurrentZoneDate]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Calendar,
    {
      focusedDate,
      onFocusedDateChange: handleFocusDateChange,
      onSelect,
      selectedDate
    }
  );
}, Column = styledComponents.styled(ui.Box)`
  flex-direction: column;
  &:not(:last-child) {
    border-right: 1px solid var(--card-border-color);
  }
`, NO_SCHEDULE = [], DATE_SLUG_FORMAT = "yyyy-MM-dd";
function Tool() {
  const router$1 = router.useRouter(), { sanity: theme2 } = ui.useTheme(), { error, isInitialLoading, schedules = NO_SCHEDULE } = usePollSchedules(), lastScheduleState = React.useRef(), scheduleState = router$1.state.state, selectedDate = router$1.state.date ? dateFns.parse(router$1.state.date, DATE_SLUG_FORMAT, /* @__PURE__ */ new Date()) : void 0;
  React.useEffect(() => {
    router$1.state.state && (lastScheduleState.current = router$1.state.state);
  }, [router$1.state.state]), useFallbackNavigation(router$1, scheduleState, selectedDate);
  const { formatDateTz } = useTimeZone(), schedulesContext = React.useMemo(
    () => ({
      schedules,
      scheduleState,
      selectedDate
    }),
    [schedules, scheduleState, selectedDate]
  ), handleClearDate = () => {
    router$1.navigate({ state: (lastScheduleState == null ? void 0 : lastScheduleState.current) || SCHEDULE_FILTERS[0] });
  };
  return /* @__PURE__ */ jsxRuntime.jsx(SchedulesProvider, { value: schedulesContext, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", height: "fill", flex: 1, overflow: "hidden", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, height: "fill", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Column,
      {
        display: ["none", null, null, "flex"],
        style: {
          position: "sticky",
          top: 0,
          width: "350px"
        },
        children: /* @__PURE__ */ jsxRuntime.jsx(ToolCalendar, { onSelect: (date) => {
          date ? router$1.navigate({ date: formatDateTz({ date, format: DATE_SLUG_FORMAT }) }) : router$1.navigate({ state: (lastScheduleState == null ? void 0 : lastScheduleState.current) || SCHEDULE_FILTERS[0] });
        }, selectedDate })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(Column, { display: "flex", flex: 1, overflow: "hidden", children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ButtonTimeZoneElementQuery,
        {
          style: {
            background: theme2.color.card.enabled.bg,
            position: "sticky",
            top: 0,
            zIndex: 1
          },
          children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Flex,
            {
              align: "center",
              paddingLeft: 4,
              paddingRight: 3,
              style: {
                borderBottom: "1px solid var(--card-border-color)",
                minHeight: `${TOOL_HEADER_HEIGHT}px`
              },
              children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, justify: "space-between", children: [
                /* @__PURE__ */ jsxRuntime.jsx(ScheduleFilters, { onClearDate: handleClearDate, selectedDate }),
                /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
                  /* @__PURE__ */ jsxRuntime.jsx(ButtonTimeZone, { useElementQueries: !0 }),
                  /* @__PURE__ */ jsxRuntime.jsx(SchedulesContextMenu, {})
                ] })
              ] })
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", flex: 1, children: [
        error && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 4, paddingX: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
          ErrorCallout,
          {
            description: "More information in the developer console.",
            title: "Something went wrong, unable to retrieve schedules."
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: isInitialLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: "Loading..." }) }) : (
          // Loaded schedules
          /* @__PURE__ */ jsxRuntime.jsx(Schedules$1, {})
        ) })
      ] })
    ] })
  ] }) }) });
}
function useFallbackNavigation(router2, filter, selectedDate) {
  React.useEffect(() => {
    !filter && !selectedDate && router2.navigate({ state: SCHEDULE_FILTERS[0] }, { replace: !0 });
  }, [selectedDate, router2, filter]);
}
const DialogFooter = (props2) => {
  const { buttonText = "Action", disabled, icon, onAction, onComplete, tone = "positive" } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { width: "full", gap: 3, justify: "flex-end", children: [
    /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { mode: "bleed", onClick: onComplete, text: "Cancel" }),
    onAction && /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { disabled, icon, onClick: onAction, text: buttonText, tone })
  ] });
};
function NewScheduleInfo({ id: id2, schemaType }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
      "Schedule this document to be published at any time in the future.",
      /* @__PURE__ */ jsxRuntime.jsx("br", {}),
      "Any edits in the meantime will be added to the scheduled document."
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "Visit the Schedules page to get an overview of all schedules." }),
    /* @__PURE__ */ jsxRuntime.jsx(ValidationWarning, { id: id2, type: schemaType })
  ] });
}
function ValidationWarning({ id: id2, type }) {
  const publishedId = usePublishedId(id2), schema2 = useSchemaType(type), validationStatus = useValidationStatus(publishedId, type), { hasError } = useValidationState(validationStatus.validation);
  return hasError ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, radius: 1, shadow: 1, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ValidationInfo,
      {
        markers: validationStatus.validation,
        type: schema2,
        documentId: publishedId
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: DOCUMENT_HAS_ERRORS_TEXT })
  ] }) }) : null;
}
const Schedules = (props2) => {
  const { schedules } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, children: schedules.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "No schedules" }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: schedules.map((schedule) => /* @__PURE__ */ jsxRuntime.jsx(ScheduleItem, { schedule, type: "document" }, schedule.id)) }) });
}, debug$2 = debugWithName$1("ScheduleAction"), ScheduleAction = (props2) => {
  const { draft, id: id2, liveEdit, onComplete, published, type } = props2, currentUser = useCurrentUser(), [permissions, isPermissionsLoading] = useDocumentPairPermissions({
    id: id2,
    type,
    permission: "publish"
  }), { createSchedule } = useScheduleOperation(), { enabled, mode } = useScheduledPublishingEnabled(), { handleOpenDialog } = useSchedulePublishingUpsell(), [dialogOpen, setDialogOpen] = React.useState(!1), { formData, onFormChange } = useScheduleForm(), {
    error: fetchError,
    isInitialLoading,
    schedules
  } = usePollSchedules({
    documentId: id2,
    state: "scheduled"
  });
  debug$2("schedules", schedules);
  const hasExistingSchedules = schedules && schedules.length > 0, documentExists = draft !== null || published !== null, insufficientPermissions = !isPermissionsLoading && !(permissions != null && permissions.granted), handleDialogOpen = React.useCallback(() => {
    mode === "upsell" ? handleOpenDialog("document_action") : setDialogOpen(!0);
  }, [mode, handleOpenDialog]), handleScheduleCreate = React.useCallback(() => {
    formData != null && formData.date && createSchedule({ date: formData.date, documentId: id2 }).then(onComplete);
  }, [onComplete, createSchedule, id2, formData == null ? void 0 : formData.date]), title = hasExistingSchedules ? "Edit Schedule" : "Schedule";
  if (insufficientPermissions)
    return {
      disabled: !0,
      icon: icons.CalendarIcon,
      label: title,
      title: /* @__PURE__ */ jsxRuntime.jsx(InsufficientPermissionsMessage, { currentUser, context: "edit-schedules" })
    };
  let tooltip = "This document doesn't exist yet";
  documentExists && (tooltip = null), isInitialLoading && (tooltip = "Loading schedules"), liveEdit && (tooltip = "Live Edit is enabled for this content type and publishing happens automatically as you make changes");
  const dialog = {
    content: fetchError ? /* @__PURE__ */ jsxRuntime.jsx(
      ErrorCallout,
      {
        description: "More information in the developer console.",
        title: "Something went wrong, unable to retrieve schedules."
      }
    ) : /* @__PURE__ */ jsxRuntime.jsx(DocumentActionPropsProvider, { value: props2, children: hasExistingSchedules ? /* @__PURE__ */ jsxRuntime.jsx(Schedules, { schedules }) : /* @__PURE__ */ jsxRuntime.jsx(EditScheduleForm, { onChange: onFormChange, value: formData, children: /* @__PURE__ */ jsxRuntime.jsx(NewScheduleInfo, { id: id2, schemaType: type }) }) }),
    footer: !hasExistingSchedules && /* @__PURE__ */ jsxRuntime.jsx(
      DialogFooter,
      {
        buttonText: "Schedule",
        disabled: !(formData != null && formData.date),
        icon: icons.ClockIcon,
        onAction: handleScheduleCreate,
        onComplete,
        tone: "primary"
      }
    ),
    header: /* @__PURE__ */ jsxRuntime.jsx(DialogHeader, { title }),
    onClose: onComplete,
    type: "dialog"
  };
  return enabled ? {
    dialog: dialogOpen && dialog,
    disabled: isInitialLoading || !documentExists || liveEdit,
    label: title,
    icon: icons.CalendarIcon,
    onHandle: handleDialogOpen,
    title: tooltip && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { maxWidth: "315px" }, children: tooltip })
  } : null;
};
function resolveDocumentActions(existingActions) {
  return existingActions.findIndex((a) => a.action === "publish") < 0 ? [ScheduleAction, ...existingActions] : existingActions.flatMap(
    (action) => action.action === "publish" ? [action, ScheduleAction] : action
  );
}
const debug$1 = debugWithName$1("ScheduledBadge"), ScheduledBadge = (props2) => {
  const { schedules } = usePollSchedules({ documentId: props2.id, state: "scheduled" });
  debug$1("schedules", schedules);
  const upcomingSchedule = schedules == null ? void 0 : schedules[0];
  if (!upcomingSchedule || !upcomingSchedule.executeAt)
    return null;
  const formattedDateTime = dateFns.format(new Date(upcomingSchedule.executeAt), DATE_FORMAT.LARGE);
  return {
    color: SCHEDULE_ACTION_DICTIONARY[upcomingSchedule.action].badgeColor,
    label: "Scheduled",
    title: `${SCHEDULE_ACTION_DICTIONARY[upcomingSchedule.action].actionName} on ${formattedDateTime} (local time)`
  };
};
function resolveDocumentBadges(existingBadges) {
  return [...existingBadges, ScheduledBadge];
}
function ScheduleBanner(props2) {
  const { id: id2, markers } = props2, publishedId = usePublishedId(id2), { hasError } = useValidationState(markers), { schedules } = usePollSchedules({ documentId: publishedId, state: "scheduled" }), { mode } = useScheduledPublishingEnabled();
  return schedules.length > 0 ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { marginBottom: 4, children: [
    mode === "upsell" && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "caution", padding: 3, radius: 3, shadow: 1, marginBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, padding: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: "Scheduled publishing is not available on your current plan" })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        padding: 3,
        radius: 1,
        shadow: 1,
        tone: hasError ? "critical" : "primary",
        style: mode === "upsell" ? { opacity: 0.7 } : void 0,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, marginBottom: 1, padding: 1, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}) }),
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx("span", { style: { fontWeight: 600 }, children: "Upcoming schedule" }),
              " (local time)"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: schedules.map((schedule) => {
            if (!schedule.executeAt)
              return null;
            const formattedDateTime = dateFns.format(new Date(schedule.executeAt), DATE_FORMAT.LARGE);
            return /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: formattedDateTime }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { style: { opacity: schedule.action === "unpublish" ? 1 : 0 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 0, mode: "outline", children: schedule.action }) })
            ] }, schedule.id);
          }) }),
          hasError && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "regular", children: DOCUMENT_HAS_ERRORS_TEXT }) })
        ] })
      }
    )
  ] }) : null;
}
function ScheduledDocumentInput(props2) {
  const { value, validation: validation2, children } = props2, doc = value, markers = React.useMemo(
    () => validation2.map((v) => ({
      level: v.level,
      path: v.path,
      item: { message: v.message },
      message: v.message
    })),
    [validation2]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    doc != null && doc._id ? /* @__PURE__ */ jsxRuntime.jsx(ScheduleBanner, { id: doc._id, markers }) : null,
    children
  ] });
}
const DocumentBannerInput = (props2) => {
  const { schemaType } = props2;
  return getRootType(schemaType).name === "document" ? /* @__PURE__ */ jsxRuntime.jsx(ScheduledDocumentInput, { ...props2, children: props2.renderDefault(props2) }) : props2.renderDefault(props2);
};
function getRootType(type) {
  return type.type ? getRootType(type.type) : type;
}
function SchedulePublishingStudioLayoutInner(props2) {
  const { enabled, mode } = useScheduledPublishingEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.ConditionalWrapper,
    {
      condition: mode === "upsell",
      wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(SchedulePublishingUpsellProvider, { children }),
      children: props2.renderDefault(props2)
    }
  ) : props2.renderDefault(props2);
}
function SchedulePublishingStudioLayout(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ScheduledPublishingEnabledProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(SchedulePublishingStudioLayoutInner, { ...props2 }) });
}
const SCHEDULED_PUBLISHING_NAME = "sanity/scheduled-publishing", scheduledPublishing = definePlugin({
  // Renamed from 'scheduled-publishing' to 'sanity/scheduled-publishing' to avoid duplicates, see packages/sanity/src/core/config/flattenConfig.ts - DEPRECATED_PLUGINS.
  name: SCHEDULED_PUBLISHING_NAME,
  document: {
    actions: (prev) => resolveDocumentActions(prev),
    badges: (prev) => resolveDocumentBadges(prev)
  },
  form: {
    components: {
      input: DocumentBannerInput
    }
  },
  studio: {
    components: {
      layout: SchedulePublishingStudioLayout
    }
  },
  tools: (prev) => [
    ...prev,
    {
      name: TOOL_NAME,
      title: TOOL_TITLE,
      icon: icons.CalendarIcon,
      component: Tool,
      router: router.route.create("/", [router.route.create("/state/:state"), router.route.create("/date/:date")])
    }
  ]
}), tasksLocaleNamespace = "tasks", tasksUsEnglishLocaleBundle = {
  locale: "en-US",
  namespace: tasksLocaleNamespace,
  resources: () => Promise.resolve().then(function() {
    return require("./_chunks-cjs/resources2.js");
  })
};
function TasksEnabledProvider({ children }) {
  var _a2;
  const { enabled, isLoading } = useFeatureEnabled("sanityTasks"), isWorkspaceEnabled = (_a2 = useWorkspace().tasks) == null ? void 0 : _a2.enabled, value = React.useMemo(() => !isWorkspaceEnabled || isLoading ? {
    enabled: !1,
    mode: null
  } : {
    enabled: !0,
    mode: enabled ? "default" : "upsell"
  }, [enabled, isLoading, isWorkspaceEnabled]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.TasksEnabledContext.Provider, { value, children });
}
function useTasksEnabled() {
  return React.useContext(_singletons.TasksEnabledContext);
}
function IsLastPaneProvider({ children, isLastPane }) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.IsLastPaneContext.Provider, { value: isLastPane, children });
}
function useIsLastPane() {
  return React.useContext(_singletons.IsLastPaneContext);
}
function MentionUserProvider(props2) {
  const [selectedDocument, setSelectedDocument] = React.useState(null), mentionOptions = useUserListWithPermissions({
    documentValue: selectedDocument,
    permission: "read"
  }), value = React.useMemo(
    () => ({
      mentionOptions,
      selectedDocument,
      setSelectedDocument
    }),
    [mentionOptions, selectedDocument, setSelectedDocument]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.MentionUserContext.Provider, { value, children: props2.children });
}
function useMentionUser() {
  const context = React.useContext(_singletons.MentionUserContext);
  if (!context)
    throw new Error("useMentionUser must be used within a MentionUserProvider");
  return context;
}
const TaskCreated = telemetry.defineEvent({
  name: "Task Created",
  version: 1,
  description: "A task is created"
}), TaskStatusChanged = telemetry.defineEvent({
  name: "Task Status Changed",
  version: 1,
  description: "Task status changed"
}), TaskDuplicated = telemetry.defineEvent({
  name: "Task Duplicated",
  version: 1,
  description: "A task is duplicated"
}), TaskRemoved = telemetry.defineEvent({
  name: "Task Removed",
  version: 1,
  description: "A task is removed"
}), TaskLinkCopied = telemetry.defineEvent({
  name: "Task Link Copied",
  version: 1,
  description: "The link to a task is copied"
}), TaskLinkOpened = telemetry.defineEvent({
  name: "Task Link Opened",
  version: 1,
  description: "User visited the studio through a link with a task"
}), initialState = {
  viewMode: "list",
  selectedTask: null,
  activeTabId: "assigned",
  duplicateTaskValues: null,
  isOpen: !1
};
function reducer(state, action) {
  switch (action.type) {
    case "TOGGLE_TASKS_VIEW":
      return action.payload === !1 ? {
        ...initialState,
        isOpen: action.payload
      } : {
        ...state,
        isOpen: action.payload
      };
    case "CREATE_TASK":
      return {
        ...state,
        viewMode: "create",
        selectedTask: uuid.uuid()
      };
    case "EDIT_TASK":
      return {
        ...state,
        viewMode: "edit",
        selectedTask: action.payload.id
      };
    case "EDIT_DRAFT":
      return {
        ...state,
        viewMode: "draft",
        selectedTask: action.payload.id
      };
    case "DUPLICATE_TASK":
      return {
        ...state,
        viewMode: "duplicate",
        selectedTask: uuid.uuid(),
        duplicateTaskValues: action.payload.duplicateTaskValues
      };
    case "SET_ACTIVE_TAB":
      return {
        ...state,
        viewMode: "list",
        activeTabId: action.payload
      };
    case "NAVIGATE_TO_LIST":
      return {
        ...state,
        viewMode: "list"
      };
    default:
      return state;
  }
}
const TasksNavigationProvider = ({ children }) => {
  const [state, dispatch] = React.useReducer(reducer, initialState), router$1 = router.useRouter(), toast = ui.useToast(), telemetry2 = react.useTelemetry(), setViewMode = React.useCallback((viewMode) => {
    switch (viewMode.type) {
      case "list":
        dispatch({ type: "NAVIGATE_TO_LIST" });
        break;
      case "create":
        dispatch({ type: "CREATE_TASK" });
        break;
      case "edit":
        dispatch({ type: "EDIT_TASK", payload: { id: viewMode.id } });
        break;
      case "duplicate":
        dispatch({
          type: "DUPLICATE_TASK",
          payload: { duplicateTaskValues: viewMode.duplicateTaskValues }
        });
        break;
      case "draft":
        dispatch({ type: "EDIT_DRAFT", payload: { id: viewMode.id } });
        break;
    }
  }, []), setActiveTab = React.useCallback((tabId) => {
    dispatch({ type: "SET_ACTIVE_TAB", payload: tabId });
  }, []), handleCloseTasks = React.useCallback(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !1 });
  }, []), handleOpenTasks = React.useCallback(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !0 });
  }, []), handleCopyLinkToTask = React.useCallback(() => {
    const url = new URL(window.location.href);
    url.searchParams.set("sidebar", "tasks"), url.searchParams.set("viewMode", state.viewMode), state.selectedTask && url.searchParams.set("selectedTask", state.selectedTask), navigator.clipboard.writeText(url.toString()).then(() => {
      toast.push({
        closable: !0,
        status: "info",
        title: "Copied link to clipboard"
      }), telemetry2.log(TaskLinkCopied);
    }).catch(() => {
      toast.push({
        closable: !0,
        status: "error",
        title: "Failed to copy link to clipboard"
      });
    });
  }, [state.selectedTask, state.viewMode, telemetry2, toast]), searchParamsAsString = new URLSearchParams(router$1.state._searchParams).toString();
  return React.useEffect(() => {
    if (searchParamsAsString) {
      const searchParams = new URLSearchParams(searchParamsAsString);
      if (searchParams.get("sidebar") !== "tasks")
        return;
      dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !0 });
      const viewMode = searchParams.get("viewMode"), selectedTask = searchParams.get("selectedTask");
      viewMode === "edit" && selectedTask && (dispatch({ type: "EDIT_TASK", payload: { id: selectedTask } }), telemetry2.log(TaskLinkOpened));
    }
  }, [searchParamsAsString, telemetry2]), /* @__PURE__ */ jsxRuntime.jsx(
    _singletons.TasksNavigationContext.Provider,
    {
      value: {
        state,
        setViewMode,
        setActiveTab,
        handleCloseTasks,
        handleOpenTasks,
        handleCopyLinkToTask
      },
      children
    }
  );
};
function useTasksNavigation() {
  return React.useContext(_singletons.TasksNavigationContext) || {
    state: {
      activeTabId: "assigned",
      viewMode: "list",
      selectedTask: null,
      isOpen: !1,
      duplicateTaskValues: null
    },
    setActiveTab: () => null,
    setViewMode: () => null,
    handleCloseTasks: () => null,
    handleCopyLinkToTask: () => null,
    handleOpenTasks: () => null
  };
}
function createTasksSet(tasks2) {
  return tasks2.reduce((acc, task) => ({ ...acc, [task._id]: task }), {});
}
function tasksReducer(state, action) {
  switch (action.type) {
    case "TASKS_SET": {
      const tasksById = createTasksSet(action.tasks);
      return {
        ...state,
        tasks: tasksById
      };
    }
    case "TASK_ADDED": {
      const nextTaskResult = action.payload, nextTaskValue = nextTaskResult, nextTask = {
        [nextTaskResult._id]: {
          ...state.tasks[nextTaskResult._id],
          ...nextTaskValue,
          _state: nextTaskResult._state || void 0,
          // If the task is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the tasks correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the task.
          // Once the task is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextTaskResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state,
        tasks: {
          ...state.tasks,
          ...nextTask
        }
      };
    }
    case "TASK_RECEIVED": {
      const nextTaskResult = action.payload;
      return {
        ...state,
        tasks: {
          ...state.tasks,
          [nextTaskResult._id]: nextTaskResult
        }
      };
    }
    case "TASK_DELETED": {
      const { [action.id]: _, ...restTasks } = state.tasks;
      return {
        ...state,
        tasks: restTasks
      };
    }
    case "TASK_UPDATED": {
      const updatedTask = action.payload, id2 = updatedTask._id, nextTask = {
        // Add existing task data
        ...state.tasks[id2],
        // Add incoming task data
        ...updatedTask
      };
      return {
        ...state,
        tasks: {
          ...state.tasks,
          [id2]: nextTask
        }
      };
    }
    default:
      return state;
  }
}
const INITIAL_STATE$1 = {
  tasks: {}
}, LISTEN_OPTIONS = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query"
}, SORT_FIELD = "_createdAt", SORT_ORDER = "desc", QUERY_FILTERS = ['_type == "tasks.task"'], QUERY_PROJECTION = `{
  ...,
}`, QUERY_SORT_ORDER = `order(${SORT_FIELD} ${SORT_ORDER})`, QUERY = `*[${QUERY_FILTERS.join(" && ")}] ${QUERY_PROJECTION} | ${QUERY_SORT_ORDER}`;
function useTasksStore(opts) {
  const { client: client2 } = useAddonDataset(), { documentId } = opts, [state, dispatch] = React.useReducer(tasksReducer, INITIAL_STATE$1), [isLoading, setIsLoading] = React.useState(client2 !== null), [error, setError] = React.useState(null), params = React.useMemo(
    () => ({ documentId: documentId ? getPublishedId(documentId) : null }),
    [documentId]
  ), initialFetch = React.useCallback(async () => {
    if (!client2) {
      setIsLoading(!1);
      return;
    }
    try {
      const res = await client2.fetch(QUERY, params);
      dispatch({ type: "TASKS_SET", tasks: res }), setIsLoading(!1);
    } catch (err) {
      setError(err);
    }
  }, [client2, params]), handleListenerEvent = React.useCallback(
    async (event) => {
      if (event.type === "welcome" && (setIsLoading(!0), await initialFetch(), setIsLoading(!1)), event.type === "reconnect" && setIsLoading(!0), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextTask = event.result;
          nextTask && dispatch({
            type: "TASK_RECEIVED",
            payload: nextTask
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "TASK_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedTask = event.result;
          updatedTask && dispatch({
            type: "TASK_UPDATED",
            payload: updatedTask
          });
        }
      }
    },
    [initialFetch]
  ), listener$ = React.useMemo(() => client2 ? client2.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(
    rxjs.catchError((err) => (setError(err), rxjs.of(err)))
  ) : rxjs.of(), [client2, params]);
  return React.useEffect(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: React.useMemo(() => Object.values(state.tasks), [state.tasks]),
    dispatch,
    error,
    isLoading
  };
}
const EMPTY_ARRAY$c = [];
function TasksProvider(props2) {
  const { children } = props2, [activeDocument, setActiveDocument] = React.useState(null), { data = EMPTY_ARRAY$c, isLoading } = useTasksStore({}), debouncedSetActiveDocument = React.useCallback(debounce__default.default(setActiveDocument, 1e3), []), value = React.useMemo(
    () => ({
      activeDocument,
      setActiveDocument: debouncedSetActiveDocument,
      isLoading,
      data: data != null ? data : []
    }),
    [activeDocument, data, isLoading, debouncedSetActiveDocument]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.TasksContext.Provider, { value, children });
}
function useTasks() {
  return React.useContext(_singletons.TasksContext) || {
    activeDocument: null,
    setActiveDocument: () => null,
    data: [],
    isLoading: !1
  };
}
const FEATURE = "tasks", TEMPLATE_OPTIONS = { interpolate: /{{([\s\S]+?)}}/g }, BASE_URL = "www.sanity.io", API_VERSION$2 = "2024-04-19";
function TasksUpsellProvider(props2) {
  const [upsellDialogOpen, setUpsellDialogOpen] = React.useState(!1), [upsellData, setUpsellData] = React.useState(null), projectId = useProjectId(), telemetry2 = react.useTelemetry(), client2 = useClient({ apiVersion: API_VERSION$2 }), telemetryLogs = React.useMemo(
    () => ({
      dialogSecondaryClicked: () => telemetry2.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      dialogPrimaryClicked: () => telemetry2.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      panelViewed: (source) => telemetry2.log(UpsellDialogViewed, {
        feature: FEATURE,
        type: "inspector",
        source
      }),
      panelDismissed: () => telemetry2.log(UpsellDialogDismissed, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelPrimaryClicked: () => telemetry2.log(UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelSecondaryClicked: () => telemetry2.log(UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      })
    }),
    [telemetry2]
  ), handlePrimaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogPrimaryClicked();
  }, [telemetryLogs]), handleSecondaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogSecondaryClicked();
  }, [telemetryLogs]), handleClose = React.useCallback(() => {
    setUpsellDialogOpen(!1), telemetry2.log(UpsellDialogDismissed, {
      feature: FEATURE,
      type: "modal"
    });
  }, [telemetry2]);
  React.useEffect(() => {
    const sub = client2.observable.request({
      uri: "/journey/tasks"
    }).subscribe({
      next: (data) => {
        if (data)
          try {
            const ctaUrl = template__default.default(data.ctaButton.url, TEMPLATE_OPTIONS);
            data.ctaButton.url = ctaUrl({ baseUrl: BASE_URL, projectId });
            const secondaryUrl = template__default.default(data.secondaryButton.url, TEMPLATE_OPTIONS);
            data.secondaryButton.url = secondaryUrl({ baseUrl: BASE_URL, projectId }), setUpsellData(data);
          } catch {
          }
      },
      error: () => {
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [client2, projectId]);
  const handleOpenDialog = React.useCallback(
    (source) => {
      setUpsellDialogOpen(!0), telemetry2.log(UpsellDialogViewed, {
        feature: FEATURE,
        type: "modal",
        source
      });
    },
    [telemetry2]
  ), ctxValue = React.useMemo(
    () => ({
      upsellDialogOpen,
      handleOpenDialog,
      upsellData,
      telemetryLogs
    }),
    [handleOpenDialog, upsellDialogOpen, upsellData, telemetryLogs]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(_singletons.TasksUpsellContext.Provider, { value: ctxValue, children: [
    props2.children,
    upsellData && upsellDialogOpen && /* @__PURE__ */ jsxRuntime.jsx(
      UpsellDialog,
      {
        data: upsellData,
        onClose: handleClose,
        onPrimaryClick: handlePrimaryButtonClick,
        onSecondaryClick: handleSecondaryButtonClick
      }
    )
  ] });
}
function useTasksUpsell() {
  return React.useContext(_singletons.TasksUpsellContext) || {
    upsellData: null,
    handleOpenDialog: () => null,
    upsellDialogOpen: !1,
    telemetryLogs: {
      dialogSecondaryClicked: () => null,
      dialogPrimaryClicked: () => null,
      panelViewed: () => null,
      panelDismissed: () => null,
      panelPrimaryClicked: () => null,
      panelSecondaryClicked: () => null
    }
  };
}
function TaskCreateAction() {
  const { handleOpenTasks, setViewMode } = useTasksNavigation(), { enabled, mode } = useTasksEnabled(), { handleOpenDialog } = useTasksUpsell(), handleCreateTaskFromDocument = React.useCallback(() => {
    mode === "upsell" ? handleOpenDialog("document_action") : (handleOpenTasks(), setViewMode({ type: "create" }));
  }, [handleOpenTasks, setViewMode, mode, handleOpenDialog]), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return enabled ? {
    icon: icons.TaskIcon,
    label: t2("actions.create.text"),
    title: t2("actions.create.text"),
    group: ["paneActions"],
    onHandle: handleCreateTaskFromDocument
  } : null;
}
function SetActiveDocumentInner(document2) {
  const { documentId, documentType } = document2, isLast = useIsLastPane(), { setActiveDocument } = useTasks();
  return React.useEffect(() => (documentId && isLast && documentType && (setActiveDocument == null || setActiveDocument({
    documentId: getPublishedId(documentId),
    documentType
  })), () => {
    isLast && (setActiveDocument == null || setActiveDocument(null));
  }), [documentId, documentType, isLast, setActiveDocument]), null;
}
function SetActiveDocument(document2) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(SetActiveDocumentInner, { ...document2 }) : null;
}
function TasksDocumentInputLayout(props2) {
  var _a2, _b;
  const documentId = (_a2 = props2.value) == null ? void 0 : _a2._id, documentType = (_b = props2.value) == null ? void 0 : _b._type;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(SetActiveDocument, { documentId, documentType }),
    props2.renderDefault(props2)
  ] });
}
const ButtonContainer = styledComponents.styled.div`
  position: relative;
  [data-ui='Badge'] {
    position: absolute;
    top: -2px;
    right: -2px;
  }
`;
function TasksFooterOpenTasks() {
  const { data, activeDocument } = useTasks(), { handleOpenTasks, setActiveTab } = useTasksNavigation(), mediaIndex = ui.useMediaIndex(), pendingTasks = React.useMemo(
    () => activeDocument != null && activeDocument.documentId ? data.filter((item) => {
      var _a2;
      return ((_a2 = item.target) == null ? void 0 : _a2.document._ref) === activeDocument.documentId && item.status === "open" && item.createdByUser;
    }) : [],
    [activeDocument, data]
  ), handleOnClick = React.useCallback(() => {
    handleOpenTasks(), setActiveTab("document");
  }, [handleOpenTasks, setActiveTab]), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return pendingTasks.length === 0 ? null : mediaIndex < 3 ? /* @__PURE__ */ jsxRuntime.jsxs(ButtonContainer, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        mode: "bleed",
        icon: icons.TaskIcon,
        size: "large",
        onClick: handleOnClick,
        tooltipProps: {
          content: t2("document.footer.open-tasks.placeholder", {
            count: pendingTasks.length
          })
        }
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { tone: "primary", fontSize: 0, children: pendingTasks.length })
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      mode: "bleed",
      tooltipProps: {
        content: t2("document.footer.open-tasks.placeholder", {
          count: pendingTasks.length
        })
      },
      text: t2("document.footer.open-tasks.text", { count: pendingTasks.length }),
      onClick: handleOnClick
    }
  );
}
function getTargetValue({
  documentId,
  documentType,
  dataset,
  projectId
}) {
  return {
    documentType,
    document: {
      _ref: getPublishedId(documentId),
      _type: "crossDatasetReference",
      _dataset: dataset,
      _projectId: projectId,
      _weak: !0
    }
  };
}
function getMentionedUsers(description) {
  if (!description) return [];
  const subscribers = [];
  return description == null || description.forEach((block) => {
    types.isPortableTextTextBlock(block) && block.children.forEach((child) => {
      child._type === "mention" && typeof child.userId == "string" && !subscribers.includes(child.userId) && subscribers.push(child.userId);
    });
  }), subscribers;
}
const API_VERSION$1 = "2024-03-05", TASK_STATUS = [
  { value: "open", title: "To Do", icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CircleIcon, {}) },
  { value: "closed", title: "Done", icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkCircleIcon, {}) }
], FIELDS_TO_GROUP = [
  "title",
  "status",
  "assignedTo",
  "dueBy",
  "target",
  "description"
], GROUP_TIME = 2 * 60 * 1e3;
function groupChanges(changes) {
  const groupedChanges = [];
  for (const change of changes) {
    const lastChangeProcessed = groupedChanges[groupedChanges.length - 1];
    if (!lastChangeProcessed) {
      groupedChanges.push(change);
      continue;
    }
    if (!FIELDS_TO_GROUP.includes(change.field)) {
      groupedChanges.push(change);
      continue;
    }
    if (lastChangeProcessed.author === change.author && lastChangeProcessed.field === change.field) {
      const lastChangeDate = new Date(lastChangeProcessed.timestamp), changeDate = new Date(change.timestamp);
      if (Math.abs(lastChangeDate.getTime() - changeDate.getTime()) <= GROUP_TIME) {
        lastChangeProcessed.to = change.to, lastChangeProcessed.timestamp = change.timestamp;
        continue;
      }
    }
    groupedChanges.push(change);
  }
  return groupedChanges;
}
function omitRev(document2) {
  const { _rev, ...doc } = document2;
  return doc;
}
function trackFieldChanges(newestDocument, transactions, fieldsToTrack) {
  let currentDocument = omitRev(newestDocument);
  const changes = [];
  let previousDocument = currentDocument;
  for (const transaction of transactions) {
    const { timestamp, effects } = transaction, documentId = transaction.documentIDs[0], effect = effects[documentId];
    !effect || !effect.revert || (previousDocument = mendoza.applyPatch(currentDocument, effect.revert), fieldsToTrack.forEach((field) => {
      (previousDocument == null ? void 0 : previousDocument[field]) !== (currentDocument == null ? void 0 : currentDocument[field]) && changes.push({
        field,
        from: previousDocument == null ? void 0 : previousDocument[field],
        to: currentDocument == null ? void 0 : currentDocument[field],
        timestamp,
        author: transaction.author
      });
    }), currentDocument = previousDocument);
  }
  const changesSortedByTimestamp = changes.sort((a, b) => a.timestamp.localeCompare(b.timestamp)), createdByUserIndex = changesSortedByTimestamp.findIndex(
    (change) => change.field === "createdByUser"
  );
  return groupChanges(changesSortedByTimestamp.slice(createdByUserIndex + 1));
}
function useActivityLog(task) {
  var _a2;
  const [changes, setChanges] = React.useState([]), client2 = useClient({ apiVersion: API_VERSION$1 }), { dataset, token } = client2.config(), queryParams = "tag=sanity.studio.tasks.history&effectFormat=mendoza&excludeContent=true&includeIdentifiedDocumentsOnly=true&reverse=true", publishedId = getPublishedId((_a2 = task == null ? void 0 : task._id) != null ? _a2 : ""), transactionsUrl = client2.getUrl(
    `/data/history/${dataset}/transactions/${publishedId}?${queryParams}`
  ), fetchAndParse = React.useCallback(
    async (newestTaskDocument) => {
      try {
        if (!publishedId) return;
        const transactions = [], reader = (await getJsonStream(transactionsUrl, token)).getReader();
        let result;
        for (; result = await reader.read(), !result.done; ) {
          if ("error" in result.value)
            throw new Error(result.value.error.description || result.value.error.type);
          transactions.push(result.value);
        }
        const fieldsToTrack = [
          "createdByUser",
          "title",
          "description",
          "dueBy",
          "assignedTo",
          "status",
          "target"
        ], parsedChanges = await trackFieldChanges(
          newestTaskDocument,
          [...transactions],
          fieldsToTrack
        );
        setChanges(parsedChanges);
      } catch (error) {
        console.error("Failed to fetch and parse activity log", error);
      }
    },
    [transactionsUrl, token, publishedId]
  );
  return React.useEffect(() => {
    fetchAndParse(task);
  }, [fetchAndParse, task._rev]), { changes };
}
function useDocumentPreviewValues(options) {
  var _a2;
  const { documentId, documentType } = options || {}, schemaType = useSchema().get(documentType), documentPreviewStore = useDocumentPreviewStore(), previewState = reactRx.useMemoObservable(() => !documentId || !schemaType ? rxjs.of(null) : getPreviewStateObservable$1(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), isLoading = (_a2 = previewState == null ? void 0 : previewState.isLoading) != null ? _a2 : !0, { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title), subtitle = (draft == null ? void 0 : draft.subtitle) || (published == null ? void 0 : published.subtitle), description = (draft == null ? void 0 : draft.description) || (published == null ? void 0 : published.description), media = (draft == null ? void 0 : draft.media) || (published == null ? void 0 : published.media);
  return {
    isLoading,
    value: {
      title: documentTitle,
      subtitle,
      media,
      description
    }
  };
}
function useTaskOperations() {
  const { client: client2, createAddonDataset } = useAddonDataset(), currentUser = useCurrentUser(), handleCreate = React.useCallback(
    async (payload) => {
      if (!currentUser)
        throw new Error("No current user found. Unable to create task.");
      const task = {
        ...payload,
        authorId: currentUser.id,
        _type: "tasks.task"
      };
      if (!client2)
        try {
          const newCreatedClient = await createAddonDataset();
          if (!newCreatedClient) throw new Error("No addon client found. Unable to create task.");
          return await newCreatedClient.create(task);
        } catch (err) {
          throw err;
        }
      try {
        return await client2.create(task);
      } catch (err) {
        throw err;
      }
    },
    [client2, createAddonDataset, currentUser]
  ), handleEdit = React.useCallback(
    async (id2, set2) => {
      try {
        if (!client2)
          throw new Error("No client. Unable to create task.");
        return await client2.patch(id2).set(set2).commit();
      } catch (e) {
        throw e;
      }
    },
    [client2]
  ), handleRemove = React.useCallback(
    async (id2) => {
      try {
        if (!client2)
          throw new Error("No client. Unable to create task.");
        await client2.delete(id2);
      } catch (e) {
        throw e;
      }
    },
    [client2]
  );
  return React.useMemo(
    () => ({
      create: handleCreate,
      edit: handleEdit,
      remove: handleRemove
    }),
    [handleCreate, handleEdit, handleRemove]
  );
}
function useRemoveTask({ id: id2, onError, onRemoved }) {
  const [removeStatus, setRemoveStatus] = React.useState("idle"), [showDialog, setShowDialog] = React.useState(!1), [error, setError] = React.useState(null), operations = useTaskOperations(), handleRemove = React.useCallback(async () => {
    try {
      setRemoveStatus("loading"), await operations.remove(id2), onRemoved == null || onRemoved(), setRemoveStatus("idle"), await new Promise((resolve) => setTimeout(resolve, 300)), setShowDialog(!1);
    } catch (e) {
      onError == null || onError(e.message), setError(e.message), setRemoveStatus("error");
    } finally {
      setRemoveStatus("idle");
    }
  }, [id2, operations, onError, onRemoved]), handleOpenDialog = React.useCallback(() => {
    setShowDialog(!0);
  }, [setShowDialog]), handleCloseDialog = React.useCallback(() => {
    setShowDialog(!1);
  }, [setShowDialog]);
  return {
    removeStatus,
    showDialog,
    error,
    handleRemove,
    handleOpenDialog,
    handleCloseDialog
  };
}
const DATE_FORMAT_OPTIONS = {
  month: "long",
  day: "2-digit",
  minute: "2-digit",
  hour: "2-digit",
  second: "2-digit"
}, RELATIVE_TIME_OPTIONS$1 = {
  minimal: !0,
  useTemporalPhrase: !0
}, Strong = styledComponents.styled.strong`
  font-weight: 600;
`, NoWrap = styledComponents.styled.span`
  white-space: nowrap;
`;
function UpdatedTimeAgo(timestamp) {
  const date = new Date(timestamp), formattedDate = useDateTimeFormat(DATE_FORMAT_OPTIONS).format(date);
  return { timeAgo: useRelativeTime(date || "", RELATIVE_TIME_OPTIONS$1), formattedDate };
}
function UserName({ userId }) {
  const [user, isLoading] = useUser(userId);
  return isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "15ch" } }) : /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: user == null ? void 0 : user.displayName });
}
const DUE_BY_DATE_OPTIONS = {
  month: "short",
  day: "numeric"
};
function DueByChange({ date }) {
  const dueBy = new Date(date), formattedDate = useDateTimeFormat(DUE_BY_DATE_OPTIONS).format(dueBy);
  return /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: /* @__PURE__ */ jsxRuntime.jsx(NoWrap, { children: formattedDate }) });
}
const LinkWrapper = styledComponents.styled.span`
  > a {
    color: var(--card-fg-muted-color);
    text-decoration: underline;
    text-underline-offset: 1px;
    font-weight: 600;
  }
`;
function TargetContentChange({ target }) {
  const schema2 = useSchema(), documentId = target.document._ref, documentType = target.documentType, documentSchema = schema2.get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  });
  return isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "15ch" } }) : documentSchema ? /* @__PURE__ */ jsxRuntime.jsx(LinkWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(router.IntentLink, { intent: "edit", params: { id: documentId, type: documentType }, children: value == null ? void 0 : value.title }) }) : null;
}
function getChangeDetails(activity) {
  var _a2, _b;
  switch (activity.field) {
    case "status": {
      const statusTitle = (_a2 = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _a2.title;
      return {
        text: "changed status to",
        icon: ((_b = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _b.icon) || /* @__PURE__ */ jsxRuntime.jsx(icons.CircleIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: statusTitle })
      };
    }
    case "target":
      return activity.to ? {
        text: "set target content to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.LinkIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(TargetContentChange, { target: activity.to })
      } : {
        text: "removed target content",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.LinkIcon, {}),
        changeTo: void 0
      };
    case "dueBy":
      return activity.from ? activity.to ? {
        text: "changed the due date to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(DueByChange, { date: activity.to })
      } : {
        text: "removed the due date",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}),
        changeTo: void 0
      } : {
        text: "set the due date to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(DueByChange, { date: activity.to })
      };
    case "assignedTo":
      return activity.to ? {
        text: "assigned to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.UserIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(UserName, { userId: activity.to })
      } : {
        text: "unassigned this task",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.UserIcon, {}),
        changeTo: void 0
      };
    case "description":
      return {
        text: "updated the task description",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.EditIcon, {}),
        changeTo: void 0
      };
    case "title":
      return {
        text: "updated the task title",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.EditIcon, {}),
        changeTo: void 0
      };
    default:
      return {
        text: "",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CircleIcon, {})
      };
  }
}
const EditedAt = React.memo(
  function(props2) {
    const { activity } = props2, { formattedDate, timeAgo } = UpdatedTimeAgo(activity.timestamp), { icon, text, changeTo } = getChangeDetails(activity);
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, marginLeft: 1, marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: icon }) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(UserName, { userId: activity.author }),
        " ",
        text,
        " ",
        changeTo,
        " \u2022",
        " ",
        /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: formattedDate, placement: "top-end", children: /* @__PURE__ */ jsxRuntime.jsx(NoWrap, { children: /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: formattedDate, children: timeAgo }) }) })
      ] })
    ] });
  },
  (prevProps, nextProps) => prevProps.activity.timestamp === nextProps.activity.timestamp
), AvatarRoot = styledComponents.styled.div(
  (props2) => {
    var _a2, _b;
    const theme$1 = theme.getTheme_v2(props2.theme);
    return styledComponents.css`
      min-height: ${(_a2 = theme$1.avatar.sizes[props2.$size]) == null ? void 0 : _a2.size}px;
      min-width: ${(_b = theme$1.avatar.sizes[props2.$size]) == null ? void 0 : _b.size}px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      ${props2.$border ? "box-shadow: inset 0 0 0 1px var(--card-border-color);" : ""};
      ${props2.$removeBg ? "--card-avatar-gray-bg-color: transparent;" : ""}
    `;
  }
), AvatarSkeleton = styledComponents.styled(ui.Skeleton)((props2) => {
  var _a2, _b;
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    height: ${(_a2 = theme$1.avatar.sizes[props2.$size]) == null ? void 0 : _a2.size}px;
    width: ${(_b = theme$1.avatar.sizes[props2.$size]) == null ? void 0 : _b.size}px;
    border-radius: 50%;
  `;
});
function TasksUserAvatar(props2) {
  const { user, size = 0, border = !0 } = props2, [loadedUser, loading] = useUser((user == null ? void 0 : user.id) || "");
  return loading ? /* @__PURE__ */ jsxRuntime.jsx(AvatarSkeleton, { $size: size, animated: !0 }) : !user || !loadedUser ? /* @__PURE__ */ jsxRuntime.jsx(AvatarRoot, { $size: size, $border: border, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size, children: /* @__PURE__ */ jsxRuntime.jsx(icons.UserIcon, {}) }) }) : /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: loadedUser.displayName,
      disabled: !props2.withTooltip,
      portal: !0,
      fallbackPlacements: ["top", "top-start"],
      placement: "top-end",
      children: /* @__PURE__ */ jsxRuntime.jsx(AvatarRoot, { $size: size, $removeBg: !!(loadedUser != null && loadedUser.imageUrl), children: /* @__PURE__ */ jsxRuntime.jsx(
        UserAvatar,
        {
          user: loadedUser,
          size,
          ...loadedUser != null && loadedUser.imageUrl ? { color: void 0 } : {},
          ...props2.withTooltip ? { title: null } : {}
        }
      ) })
    }
  );
}
const ActivityChildrenRoot = styledComponents.styled(ui.Flex)`
  height: 100%;
`, ActivityItemChildrenContainer = styledComponents.styled.div`
  width: 100%;
`;
function ActivityItem({ avatarPaddingTop = 1, userId, children }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, paddingTop: avatarPaddingTop, children: /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: { id: userId }, size: 0 }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ActivityChildrenRoot, { align: "center", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ActivityItemChildrenContainer, { children }) })
  ] });
}
function TasksActivityCommentInput(props2) {
  const { mentionOptions, currentUser, onSubmit } = props2, { mode } = useTasksEnabled(), [value, setValue] = React.useState(null), editorRef = React.useRef(null), hasValue2 = React.useMemo(() => hasCommentMessageValue(value), [value]), handleChange = React.useCallback((nextValue) => {
    setValue(nextValue);
  }, []), handleSubmit = React.useCallback(() => {
    hasValue2 && (onSubmit(value), setValue(null));
  }, [hasValue2, onSubmit, value]), handleDiscardCancel = React.useCallback(() => {
    var _a2;
    (_a2 = editorRef.current) == null || _a2.discardDialogController.close();
  }, []), handleDiscardConfirm = React.useCallback(() => {
    var _a2;
    (_a2 = editorRef.current) == null || _a2.discardDialogController.close(), setValue(null);
  }, []), handleKeyDown = React.useCallback(
    (e) => {
      var _a2, _b;
      e.key === "Escape" && (e.preventDefault(), e.stopPropagation(), hasValue2 ? (_a2 = editorRef.current) == null || _a2.discardDialogController.open() : ((_b = editorRef.current) == null || _b.discardDialogController.close(), setValue(null)));
    },
    [hasValue2]
  ), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(ActivityItem, { userId: currentUser.id, avatarPaddingTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "transparent", radius: 3, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    CommentInput,
    {
      withAvatar: !1,
      currentUser,
      expandOnFocus: !0,
      mentionOptions,
      onChange: handleChange,
      onDiscardConfirm: handleDiscardConfirm,
      onDiscardCancel: handleDiscardCancel,
      onKeyDown: handleKeyDown,
      onSubmit: handleSubmit,
      readOnly: mode === "upsell",
      placeholder: t2(mode === "upsell" ? "panel.comment.placeholder.upsell" : "panel.comment.placeholder"),
      ref: editorRef,
      value
    }
  ) }) });
}
const COMMENTS_LIST_ITEM_AVATAR_CONFIG = {
  parentCommentAvatar: !1,
  threadCommentsAvatar: !0,
  replyAvatar: !0,
  avatarSize: 0
}, CommentListItemRoot = styledComponents.styled.div((props2) => {
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    [data-ui='CommentsListItem'] {
      padding-right: ${theme$1.space[2]}px;
    }

    // Increase the padding when the comment input is focused
    [data-ui='CommentInputEditableWrap']:focus-within {
      padding-bottom: ${theme$1.space[2]}px;
    }
  `;
});
function TasksActivityCommentItem(props2) {
  const { parentComment } = props2, { mode } = useTasksEnabled();
  return /* @__PURE__ */ jsxRuntime.jsx(ActivityItem, { userId: parentComment.authorId, avatarPaddingTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(CommentListItemRoot, { children: /* @__PURE__ */ jsxRuntime.jsx(
    CommentsListItem,
    {
      ...props2,
      avatarConfig: COMMENTS_LIST_ITEM_AVATAR_CONFIG,
      canReply: !0,
      isSelected: !1,
      mode: mode != null ? mode : "default"
    }
  ) }) });
}
const UserSkeleton = styledComponents.styled(ui.TextSkeleton)`
  max-width: 15ch;
  width: '100%';
`, TasksActivityCreatedAt = React.memo(
  function(props2) {
    var _a2;
    const { createdAt, authorId } = props2, [user, loading] = useUser(authorId), { timeAgo, formattedDate } = UpdatedTimeAgo(createdAt), { t: t2 } = useTranslation(tasksLocaleNamespace);
    return /* @__PURE__ */ jsxRuntime.jsx(ActivityItem, { userId: authorId, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, muted: !0, children: [
      /* @__PURE__ */ jsxRuntime.jsxs("strong", { style: { fontWeight: 600 }, children: [
        loading ? /* @__PURE__ */ jsxRuntime.jsx(UserSkeleton, {}) : (_a2 = user == null ? void 0 : user.displayName) != null ? _a2 : t2("panel.activity.unknown-user"),
        " "
      ] }),
      t2("panel.activity.created-fragment"),
      " \u2022",
      " ",
      /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: formattedDate, placement: "top-end", children: /* @__PURE__ */ jsxRuntime.jsx(NoWrap, { children: /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: createdAt, children: timeAgo }) }) })
    ] }) }) });
  },
  (prevProps, nextProps) => prevProps.createdAt === nextProps.createdAt
);
function TasksSubscribers(props2) {
  var _a2, _b;
  const { value, onChange, path, currentUserId } = props2, buttonText = (_a2 = value.subscribers) != null && _a2.includes(currentUserId) ? "Unsubscribe" : "Subscribe", handleToggleSubscribe = React.useCallback(() => {
    const subscribers = value.subscribers || [];
    subscribers.includes(currentUserId) || onChange(set(subscribers.concat(currentUserId), path)), subscribers.includes(currentUserId) && onChange(
      set(
        subscribers.filter((subscriberId) => subscriberId !== currentUserId),
        path
      )
    );
  }, [value.subscribers, currentUserId, onChange, path]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { mode: "bleed", text: buttonText, onClick: handleToggleSubscribe }),
    value.subscribers && ((_b = value.subscribers) == null ? void 0 : _b.length) > 0 && /* @__PURE__ */ jsxRuntime.jsx(TasksSubscriberAvatars, { subscriberIds: value.subscribers })
  ] });
}
const EMPTY_ARRAY$b = [];
function TasksSubscriberAvatars(props2) {
  const { subscriberIds: subscriberIdsProp } = props2, subscriberIds = React.useMemo(() => (subscriberIdsProp == null ? void 0 : subscriberIdsProp.filter(Boolean)) || EMPTY_ARRAY$b, [subscriberIdsProp]);
  return /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { initial: !1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarStack, { maxLength: 3, size: 0, children: subscriberIds.map((subscriberId) => /* @__PURE__ */ jsxRuntime.jsx(
    framerMotion.motion.div,
    {
      exit: { opacity: 0, translateX: "2px", scale: 0.9 },
      animate: {
        opacity: 1,
        translateX: 0,
        scale: 1,
        transition: { type: "just", duration: 0.2 }
      },
      initial: { opacity: 0, translateX: "2px", scale: 0.9 },
      children: /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: { id: subscriberId }, size: 0 })
    },
    subscriberId
  )) }) });
}
const EMPTY_ARRAY$a = [], VARIANTS$2 = {
  hidden: { opacity: 0, x: 0 },
  visible: { opacity: 1, x: 0 }
}, MotionStack = styledComponents.styled(framerMotion.motion(ui.Stack))``;
function TasksActivityLog(props2) {
  const { value, onChange, path, activityData = [] } = props2, currentUser = useCurrentUser(), { title: workspaceTitle, basePath } = useWorkspace(), { comments: comments2, mentionOptions, operation, getComment } = useComments(), [commentToDeleteId, setCommentToDeleteId] = React.useState(null), [commentDeleteError, setCommentDeleteError] = React.useState(null), [commentDeleteLoading, setCommentDeleteLoading] = React.useState(!1), loading = comments2.loading, taskComments = comments2.data.open, handleGetNotificationValue = React.useCallback(
    (message, commentId) => {
      const studioUrl = new URL(`${window.location.origin}${basePath ? `${basePath}/` : ""}`);
      studioUrl.searchParams.set("sidebar", "tasks"), studioUrl.searchParams.set("selectedTask", value == null ? void 0 : value._id), studioUrl.searchParams.set("viewMode", "edit"), studioUrl.searchParams.set("commentId", commentId);
      const mentionedUsers = getMentionedUsers(message), subscribers = Array.from(/* @__PURE__ */ new Set([...value.subscribers || [], ...mentionedUsers]));
      return {
        documentTitle: value.title || "Sanity task",
        url: studioUrl.toString(),
        workspaceTitle,
        subscribers
      };
    },
    [basePath, value == null ? void 0 : value._id, value.title, workspaceTitle, value.subscribers]
  ), handleCommentCreate = React.useCallback(
    (message) => {
      const commentId = uuid.uuid(), notification = handleGetNotificationValue(message, commentId), nextComment = {
        id: commentId,
        type: "task",
        message,
        parentCommentId: void 0,
        reactions: EMPTY_ARRAY$a,
        status: "open",
        threadId: uuid.uuid(),
        context: {
          notification
        }
      };
      onChange(set(notification.subscribers, ["subscribers"])), operation.create(nextComment);
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentReply = React.useCallback(
    (nextComment) => {
      const commentId = uuid.uuid(), notification = handleGetNotificationValue(nextComment.message, commentId);
      onChange(set(notification.subscribers, ["subscribers"])), operation.create({
        id: commentId,
        type: "task",
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: EMPTY_ARRAY$a,
        status: "open",
        threadId: nextComment.threadId,
        context: {
          notification
        }
      });
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentCreateRetry = React.useCallback(
    (id2) => {
      const comment = getComment(id2);
      if (!comment) return;
      const notification = handleGetNotificationValue(comment.message, comment._id);
      onChange(set(notification.subscribers, ["subscribers"])), operation.create({
        type: "task",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || EMPTY_ARRAY$a,
        status: comment.status,
        threadId: comment.threadId,
        context: {
          notification
        }
      });
    },
    [getComment, operation, handleGetNotificationValue, onChange]
  ), handleCommentReact = React.useCallback(
    (id2, reaction) => {
      operation.react(id2, reaction);
    },
    [operation]
  ), handleDeleteCommentStart = React.useCallback((id2) => setCommentToDeleteId(id2), []), handleDeleteCommentCancel = React.useCallback(() => setCommentToDeleteId(null), []), handleDeleteCommentConfirm = React.useCallback(
    async (id2) => {
      try {
        setCommentDeleteLoading(!0), setCommentDeleteError(null), await operation.remove(id2), setCommentToDeleteId(null);
      } catch (err) {
        setCommentDeleteError(err);
      } finally {
        setCommentDeleteLoading(!1);
      }
    },
    [operation]
  ), handleCommentEdit = React.useCallback(
    (id2, next) => {
      operation.update(id2, next);
    },
    [operation]
  ), activity = React.useMemo(() => {
    const taskActivity = activityData.map((item) => ({
      _type: "activity",
      payload: item,
      timestamp: item.timestamp
    })), commentsActivity = taskComments.map((comment) => ({
      _type: "comment",
      payload: comment,
      timestamp: comment.parentComment._createdAt
    }));
    return taskActivity.concat(commentsActivity).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
  }, [activityData, taskComments]), { t: t2 } = useTranslation(tasksLocaleNamespace), commentToDeleteIsParent = React.useMemo(() => {
    var _a2;
    const parent = taskComments.find((c) => {
      var _a22;
      return ((_a22 = c.parentComment) == null ? void 0 : _a22._id) === commentToDeleteId;
    });
    return !!(parent && ((_a2 = parent == null ? void 0 : parent.replies) == null ? void 0 : _a2.length) > 0);
  }, [commentToDeleteId, taskComments]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    commentToDeleteId && /* @__PURE__ */ jsxRuntime.jsx(
      CommentDeleteDialog,
      {
        commentId: commentToDeleteId,
        error: commentDeleteError,
        isParent: commentToDeleteIsParent,
        loading: commentDeleteLoading,
        onClose: handleDeleteCommentCancel,
        onConfirm: handleDeleteCommentConfirm
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 2, weight: "semibold", children: t2("panel.activity.title") }) }),
        (currentUser == null ? void 0 : currentUser.id) && /* @__PURE__ */ jsxRuntime.jsx(
          TasksSubscribers,
          {
            currentUserId: currentUser.id,
            value,
            onChange,
            path
          }
        )
      ] }),
      loading && /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0, title: "Loading activity" }),
      /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: !loading && /* @__PURE__ */ jsxRuntime.jsxs(MotionStack, { animate: "visible", initial: "hidden", space: 4, variants: VARIANTS$2, children: [
        value.createdByUser && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { paddingBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          TasksActivityCreatedAt,
          {
            createdAt: value.createdByUser,
            authorId: value.authorId
          }
        ) }),
        currentUser && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, marginTop: 1, children: [
          activity.map((item) => item._type === "activity" ? /* @__PURE__ */ jsxRuntime.jsx(EditedAt, { activity: item.payload }, item.timestamp) : /* @__PURE__ */ jsxRuntime.jsx(
            TasksActivityCommentItem,
            {
              currentUser,
              mentionOptions,
              onCreateRetry: handleCommentCreateRetry,
              onDelete: handleDeleteCommentStart,
              onEdit: handleCommentEdit,
              onReactionSelect: handleCommentReact,
              onReply: handleCommentReply,
              parentComment: item.payload.parentComment,
              replies: item.payload.replies
            },
            item.payload.parentComment._id
          )),
          /* @__PURE__ */ jsxRuntime.jsx(
            TasksActivityCommentInput,
            {
              currentUser,
              mentionOptions,
              onSubmit: handleCommentCreate
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
function MentionUserMenuItem(props2) {
  const { user, onSelect, pressed } = props2, { t: t2 } = useTranslation(tasksLocaleNamespace), handleSelect = React.useCallback(() => onSelect(user.id), [user, onSelect]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { onClick: handleSelect, padding: 1, disabled: !user.granted, pressed, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, flex: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: user.id ? user : void 0, size: 1 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", title: user.displayName, children: user.displayName })
    ] }),
    !user.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t2("form.input.assignee.unauthorized.text") })
  ] }) });
}
const StyledMenu$5 = styledComponents.styled(ui.Menu)`
  width: 308px;
  border-radius: 3px;
`, IGNORED_KEYS = [
  "Control",
  "Shift",
  "Alt",
  "Enter",
  "Home",
  "End",
  "PageUp",
  "PageDown",
  "Meta",
  "Tab",
  "CapsLock"
], NO_ASSIGNEE_OPTION = {
  id: "",
  displayName: "No assignee",
  granted: !0
};
function MentionsMenu$1({ onSelect, value = "" }) {
  const [searchTerm, setSearchTerm] = React.useState(""), { mentionOptions } = useMentionUser(), inputRef = React.useRef(null), options = [NO_ASSIGNEE_OPTION].concat(mentionOptions.data || []), handleSearchChange = React.useCallback((event) => {
    setSearchTerm(event.currentTarget.value);
  }, []), filteredOptions = React.useMemo(() => {
    var _a2;
    if (!searchTerm) return options || [];
    const deburredSearchTerm = deburr__default.default(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      searchName: deburr__default.default(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a2 = deburredOptions == null ? void 0 : deburredOptions.filter((option) => option == null ? void 0 : option.searchName.includes(deburredSearchTerm))) == null ? void 0 : _a2.sort((a, b) => {
      const matchA = a.searchName.startsWith(deburredSearchTerm), matchB = b.searchName.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || [];
  }, [options, searchTerm]), renderItem2 = React.useCallback(
    (user) => /* @__PURE__ */ jsxRuntime.jsx(
      MentionUserMenuItem,
      {
        user,
        onSelect,
        pressed: user.id === value
      },
      user.id
    ),
    [onSelect, value]
  ), handleKeyDown = React.useCallback((event) => {
    var _a2;
    event.target !== inputRef.current && (IGNORED_KEYS.includes(event.key) || (_a2 = inputRef.current) == null || _a2.focus());
  }, []), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return mentionOptions.loading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) }) : /* @__PURE__ */ jsxRuntime.jsxs("div", { onKeyDown: handleKeyDown, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        placeholder: t2("form.input.assignee.search.placeholder"),
        autoFocus: !0,
        border: !1,
        onChange: handleSearchChange,
        value: searchTerm,
        fontSize: 1,
        icon: icons.UserIcon,
        ref: inputRef,
        name: "assigneeSearch",
        autoComplete: "off"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: { maxHeight: "320px", overflowY: "scroll", paddingTop: "8px" }, children: filteredOptions.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, children: t2("form.input.assignee.search.no-users.text") }) }) : filteredOptions.map(renderItem2) })
  ] });
}
function AssigneeSelectionMenu(props2) {
  const { onSelect, menuButton, value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: menuButton,
      id: "assign-user-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsx(StyledMenu$5, { children: /* @__PURE__ */ jsxRuntime.jsx(MentionsMenu$1, { onSelect, value }) }),
      popover: {
        placement: "bottom",
        fallbackPlacements: ["bottom"],
        portal: !0,
        constrainSize: !0
      }
    }
  );
}
const FocusableCard = styledComponents.styled(ui.Card)((props2) => {
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    &[data-as='button'] {
      border: 1px solid var(--card-border-color);
      &:focus-within {
        border: 1px solid var(--card-focus-ring-color);
      }
      --card-muted-fg-color: ${theme$1.color.input.default.enabled.placeholder};
    }
  `;
});
function AssigneeCreateFormField(props2) {
  const { value, onChange } = props2, { mentionOptions } = useMentionUser(), mentionedUser = React.useMemo(
    () => {
      var _a2;
      return (_a2 = mentionOptions.data) == null ? void 0 : _a2.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), onSelect = React.useCallback((userId) => onChange(set(userId)), [onChange]), { t: t2 } = useTranslation(tasksLocaleNamespace), displayText = React.useMemo(() => {
    if (value) {
      if (mentionOptions.loading) return /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "10ch" } });
      if (mentionedUser) return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser) return t2("form.input.assignee.user-not-found.text");
    }
    return t2("form.input.assignee.search.placeholder");
  }, [mentionOptions.loading, mentionedUser, value, t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: /* @__PURE__ */ jsxRuntime.jsx(FocusableCard, { "data-as": "button", padding: 1, radius: 2, tabIndex: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: mentionedUser, size: 1, border: !1 }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", muted: !mentionedUser, children: displayText })
        ] }),
        value && mentionedUser && !mentionedUser.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t2("form.input.assignee.unauthorized.text") })
      ] }) })
    }
  );
}
const StyledButton$2 = styledComponents.styled(ui.Button)`
  padding: 3px 6px;
`;
function AssigneeEditFormField(props2) {
  const { value, onChange, path } = props2, subscribers = useFormValue(["subscribers"]), { mentionOptions } = useMentionUser(), mentionedUser = React.useMemo(
    () => {
      var _a2;
      return (_a2 = mentionOptions.data) == null ? void 0 : _a2.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), { t: t2 } = useTranslation(tasksLocaleNamespace), onSelect = React.useCallback(
    (userId) => {
      onChange(set(userId, path)), subscribers && !subscribers.includes(userId) && userId && onChange(set([...subscribers, userId], ["subscribers"]));
    },
    [onChange, path, subscribers]
  ), displayText = React.useMemo(() => {
    if (value) {
      if (mentionOptions.loading) return /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "10ch" } });
      if (mentionedUser) return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser) return t2("form.input.assignee.user-not-found.text");
    }
    return t2("form.input.assignee.no-user-assigned.text");
  }, [mentionOptions.loading, mentionedUser, value, t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: /* @__PURE__ */ jsxRuntime.jsx(StyledButton$2, { mode: "ghost", padding: 0, children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Tooltip,
        {
          content: t2(value ? "form.input.assignee.user-assigned.tooltip" : "form.input.assignee.no-user-assigned.tooltip"),
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, flex: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: mentionedUser, size: 0 }),
              /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: displayText }) })
            ] }),
            value && mentionedUser && !mentionedUser.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t2("form.input.assignee.unauthorized.text") })
          ] })
        }
      ) })
    }
  );
}
const serialize = (date) => legacyDateFormat.format(date, legacyDateFormat.DEFAULT_DATE_FORMAT), deserialize = (value) => legacyDateFormat.parse(value, legacyDateFormat.DEFAULT_DATE_FORMAT);
function DateEditFormField(props2) {
  var _a2;
  const { value, onChange, path } = props2, { t: coreT } = useTranslation(), { t: t2 } = useTranslation(tasksLocaleNamespace), [pickerOpen, setPickerOpen] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), buttonRef = React.useRef(null), dateFormatter = useDateTimeFormat({ dateStyle: "long" }), dueByeDisplayValue = React.useMemo(() => {
    if (!value) return { short: "----", full: "----" };
    const dueFormated = dateFormatter.format(new Date(value)), [monthAndDay] = dueFormated.split(",");
    return { short: monthAndDay, full: dueFormated };
  }, [dateFormatter, value]);
  ui.useClickOutside(() => setPickerOpen(!1), [popoverRef]);
  const handleKeyUp = React.useCallback((e) => {
    e.key === "Escape" && setPickerOpen(!1);
  }, []), handleClick = React.useCallback(() => setPickerOpen((p) => !p), []), calendarLabels = React.useMemo(() => getCalendarLabels(coreT), [coreT]), handleChange = React.useCallback(
    (nextDate) => {
      onChange(nextDate ? set(serialize(nextDate), path) : unset(path)), setPickerOpen(!1);
    },
    [onChange, path]
  ), deserializedValue = deserialize(value), handleDeactivation = React.useCallback(() => {
    var _a22;
    (_a22 = buttonRef.current) == null || _a22.focus();
  }, [buttonRef]), dueDateIsThisYear = ((_a2 = deserializedValue == null ? void 0 : deserializedValue.date) == null ? void 0 : _a2.getFullYear()) === (/* @__PURE__ */ new Date()).getFullYear();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      constrainSize: !0,
      "data-testid": "date-input-dialog",
      portal: !0,
      ref: setPopoverRef,
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(FocusLock__default.default, { onDeactivation: handleDeactivation, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          DatePicker$2,
          {
            calendarLabels,
            selectTime: !1,
            timeStep: 1,
            onKeyUp: handleKeyUp,
            value: deserializedValue.date,
            onChange: handleChange
          }
        ),
        value && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "flex-start", padding: 3, paddingTop: 0, children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "bleed",
            text: t2("form.input.date.buttons.remove.text"),
            onClick: () => handleChange(null),
            tone: "critical"
          }
        ) })
      ] }) }),
      open: pickerOpen,
      placement: "bottom",
      fallbackPlacements: ["bottom-start", "bottom-end"],
      children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          icon: icons.CalendarIcon,
          mode: "ghost",
          text: dueDateIsThisYear ? dueByeDisplayValue.short : dueByeDisplayValue.full,
          onClick: handleClick,
          ref: buttonRef,
          tooltipProps: {
            content: t2(value ? "form.input.date.buttons.tooltip" : "form.input.date.buttons.empty.tooltip")
          }
        }
      )
    }
  );
}
const NormalText$1 = styledComponents.styled(ui.Text)`
  word-break: break-word;
`;
function DescriptionInputBlock(props2) {
  const { children } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(NormalText$1, { size: 1, children }) });
}
const renderBlock$1 = (blockProps) => {
  const { children } = blockProps;
  return /* @__PURE__ */ jsxRuntime.jsx(DescriptionInputBlock, { children });
}, DescriptionInputRoot = styledComponents.styled.div((props2) => {
  const theme$1 = theme.getTheme_v2(props2.theme), verticalPadding = props2.$mode === "edit" ? theme$1.space[1] : theme$1.space[3], minHeight = props2.$mode === "edit" ? 120 : 200;
  return styledComponents.css`
    /* select CommentInputEditableWrap and change the padding */
    [data-ui='CommentInputEditableWrap'] {
      overflow: hidden;
      padding: ${props2.$mode === "edit" ? `${verticalPadding}px 0px` : `${verticalPadding}px ${theme$1.space[2]}px`};
      min-height: ${Math.max(props2.$minHeight + verticalPadding, minHeight)}px !important;
    }
    #comment-input-root {
      box-shadow: ${props2.$mode === "edit" ? "none" : ""};
    }
    [data-ui='CommentInputActions'] {
      display: none !important;
    }
  `;
});
function DescriptionInput(props2) {
  const {
    value: _propValue,
    mode,
    inputProps: { onChange }
  } = props2, value = _propValue, currentUser = useCurrentUser(), { mentionOptions } = useMentionUser(), handleChange = React.useCallback((next) => onChange(set(next)), [onChange]), [rootRef, setRootRef] = React.useState(null), [textBoxScrollHeight, setTextBoxScrollHeight] = React.useState(200), setTextboxHeight = React.useCallback((ref) => {
    const textBox = ref.querySelector('[role="textbox"]');
    if (!textBox) return;
    const height = textBox.scrollHeight;
    setTextBoxScrollHeight(height);
  }, []), handleSetRootRef = React.useCallback((ref) => {
    ref && React.startTransition(() => {
      setRootRef(ref);
    });
  }, []), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return React.useEffect(() => {
    rootRef && setTextboxHeight(rootRef);
  }, [value, setTextboxHeight, rootRef]), currentUser ? /* @__PURE__ */ jsxRuntime.jsx(DescriptionInputRoot, { $mode: mode, ref: handleSetRootRef, $minHeight: textBoxScrollHeight, children: /* @__PURE__ */ jsxRuntime.jsx(
    CommentInput,
    {
      expandOnFocus: !1,
      currentUser,
      mentionOptions,
      onChange: handleChange,
      value: value != null ? value : [],
      withAvatar: !1,
      placeholder: t2("form.input.description.placeholder"),
      onDiscardConfirm: () => null,
      renderBlock: renderBlock$1
    }
  ) }) : null;
}
const FieldWrapperRoot = styledComponents.styled.div((props2) => {
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    // Reset the padding of the field header content box
    [data-ui='fieldHeaderContentBox'] {
      padding: 0;
      label {
        font-weight: ${theme$1.font.text.weights.regular};
      }
    }
  `;
});
function FieldWrapper(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(FieldWrapperRoot, { children: props2.renderDefault(props2) });
}
const StatusMenuButton = React.forwardRef(function(props2, ref) {
  var _a2;
  const { t: t2 } = useTranslation(tasksLocaleNamespace), { value, options, ...rest } = props2, selectedOption = options.find((option) => option.value === value), icon = (_a2 = TASK_STATUS.find((status) => status.value === value)) == null ? void 0 : _a2.icon;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      ...rest,
      ref,
      tooltipProps: { content: t2("form.input.status.button.tooltip") },
      icon,
      text: (selectedOption == null ? void 0 : selectedOption.title) || value,
      tone: "default",
      mode: "ghost"
    }
  );
});
function StatusSelector(props2) {
  const { value, onChange, options, path } = props2, telemetry2 = react.useTelemetry(), handleStatusChange = React.useCallback(
    (next) => {
      onChange(set(next, path)), telemetry2.log(TaskStatusChanged, { from: value, to: next });
    },
    [onChange, path, telemetry2, value]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(StatusMenuButton, { value, options }),
      id: "reference-menuButton",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: options.map((option) => {
        var _a2;
        const isSelected = value === option.value, icon = (_a2 = TASK_STATUS.find((status) => status.value === option.value)) == null ? void 0 : _a2.icon;
        return /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            icon: typeof option.value == "string" && icon || icons.CircleIcon,
            text: option.title || option.value,
            pressed: isSelected,
            iconRight: isSelected && /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}),
            onClick: () => handleStatusChange(option.value)
          },
          option.title
        );
      }) })
    }
  );
}
function ConfigErrorsScreen$1() {
  return /* @__PURE__ */ jsxRuntime.jsx("div", { children: "Config errors" });
}
function CurrentWorkspaceProvider({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(WorkspaceLoaderBoundary, { LoadingComponent: LoadingBlock, ConfigErrorsComponent: ConfigErrorsScreen$1, children });
}
const EmptyReferenceRoot = styledComponents.styled(ui.Card)((props2) => {
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    &:focus {
      border: 1px solid var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      border: 1px solid var(--card-focus-ring-color);
    }
    &:hover {
      border-color: ${theme$1.color.input.default.hovered.border};
    }
  `;
}), Placeholder = styledComponents.styled(ui.Text)((props2) => `
      color: ${theme.getTheme_v2(props2.theme).color.input.default.enabled.placeholder};
      margin-left: 3px;
  `), TargetRoot = styledComponents.styled(ui.Card)`
  position: relative;
  [data-ui='show-on-hover'] {
    opacity: 0;
    position: absolute;
    right: 6px;
    top: 4px;
    display: flex;
  }
  &:focus-within,
  &:hover {
    padding-right: 36px;
    /* Hides the preview status dot, the button will take it's position. */
    [data-testid='compact-preview__status'] {
      opacity: 0;
    }
    [data-ui='show-on-hover'] {
      transition: opacity 200ms;
      opacity: 1;
    }
  }
`, StyledIntentLink$1 = styledComponents.styled(router.IntentLink)(() => styledComponents.css`
    text-decoration: none;
    width: 100%;
    overflow: hidden;
    cursor: pointer;
    &:focus {
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
  `);
function Preview(props2) {
  const { value, handleRemove } = props2, documentId = value.document._ref, documentType = value.documentType, schemaType = useSchema().get(value.documentType), documentPresence = useDocumentPresence(documentId), { t: t2 } = useTranslation(tasksLocaleNamespace), CardLink = React.useMemo(
    () => React.forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsxRuntime.jsx(
        StyledIntentLink$1,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return schemaType ? /* @__PURE__ */ jsxRuntime.jsx(TargetRoot, { border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", justify: "space-between", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: CardLink, radius: 2, "data-as": "button", children: /* @__PURE__ */ jsxRuntime.jsx(
      SearchResultItemPreview,
      {
        documentId: value.document._ref,
        layout: "compact",
        presence: documentPresence,
        schemaType,
        showBadge: !1
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx("div", { "data-ui": "show-on-hover", children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.CloseIcon,
        mode: "bleed",
        onClick: handleRemove,
        tooltipProps: { content: t2("form.input.target.buttons.remove.text") }
      }
    ) })
  ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: t2("form.input.target.error.schema-not-found") });
}
function TargetField(props2) {
  const [open, setOpen] = React.useState(!1), { dataset, projectId } = useWorkspace(), {
    mode,
    inputProps: { onChange },
    value: _propValue
  } = props2, value = _propValue, handleItemSelect = React.useCallback(
    (item) => {
      onChange(
        set(
          getTargetValue({
            documentId: item._id,
            documentType: item._type,
            dataset,
            projectId
          })
        )
      );
    },
    [dataset, projectId, onChange]
  ), handleRemove = React.useCallback(() => {
    onChange(unset());
  }, [onChange]), handleOpenSearch = React.useCallback(() => {
    setOpen(!0);
  }, [setOpen]), handleCloseSearch = React.useCallback(() => {
    setOpen(!1);
  }, [setOpen]), handleKeyDown = React.useCallback((event) => {
    (event.key === "Enter" || event.key === " ") && setOpen(!0);
  }, []), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: mode === "edit", paddingBottom: mode === "edit" ? 4 : 0, children: /* @__PURE__ */ jsxRuntime.jsx(FieldWrapperRoot, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset: 100, children: /* @__PURE__ */ jsxRuntime.jsxs(CurrentWorkspaceProvider, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
      mode === "create" && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-ui": "fieldHeaderContentBox", children: /* @__PURE__ */ jsxRuntime.jsx(
        FormFieldHeaderText,
        {
          description: props2.description,
          inputId: props2.inputId,
          title: props2.title,
          validation: props2.validation,
          deprecated: void 0
        }
      ) }),
      value ? /* @__PURE__ */ jsxRuntime.jsx(Preview, { value, handleRemove }) : /* @__PURE__ */ jsxRuntime.jsx(
        EmptyReferenceRoot,
        {
          border: !0,
          radius: 2,
          paddingX: 2,
          paddingY: 3,
          onClick: handleOpenSearch,
          onKeyDown: handleKeyDown,
          tabIndex: 0,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, justify: "flex-start", align: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(Placeholder, { size: 1, children: t2("form.input.target.search.placeholder") })
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(SearchProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(
      SearchPopover,
      {
        open,
        onClose: handleCloseSearch,
        onItemSelect: handleItemSelect,
        disableIntentLink: !0
      }
    ) })
  ] }) }) }) });
}
const Root$a = styledComponents.styled.div((props2) => `
      display: grid;
      grid-template-columns: 1fr;
      padding-top: ${theme.getTheme_v2(props2.theme).space[3]}px;
    `), TitleInput = styledComponents.styled.textarea((props2) => {
  const { color: color2, font } = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    resize: none;
    overflow: hidden;
    appearance: none;
    background: none;
    border: 0;
    padding: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${font.text.weights.semibold};
    font-size: ${font.text.sizes[3].fontSize}px;
    line-height: ${font.text.sizes[3].lineHeight}px;
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;
    transition: height 500ms;
    /* NOTE: This is a hack to disable Chrome’s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    color: ${color2.input.default.enabled.fg};

    &::placeholder {
      color: ${color2.input.default.enabled.placeholder};
    }
  `;
});
function Title(props2) {
  const { value, onChange, placeholder, path } = props2, ref = React.useRef(null);
  React.useEffect(() => {
    ref.current && (ref.current.style.height = "auto", ref.current.style.height = `${ref.current.scrollHeight}px`);
  }, [value]);
  const handleChange = React.useCallback(
    (event) => {
      const inputValue = event.currentTarget.value;
      return inputValue || onChange(unset(path)), onChange(set(inputValue.replace(/\n/g, ""), path));
    },
    [onChange, path]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Root$a, { children: /* @__PURE__ */ jsxRuntime.jsx(
    TitleInput,
    {
      ref,
      autoFocus: !value,
      value,
      placeholder,
      onChange: handleChange,
      rows: 1
    }
  ) });
}
function TitleField(props2) {
  const { value, inputProps } = props2, { onChange, schemaType } = inputProps;
  return /* @__PURE__ */ jsxRuntime.jsx(Title, { value, onChange, placeholder: schemaType.placeholder });
}
const getTaskSubscribers = (task) => {
  const subscribers = task.subscribers || [];
  return getMentionedUsers(task.description).forEach((user) => {
    subscribers.includes(user) || subscribers.push(user);
  }), task.assignedTo && (subscribers.includes(task.assignedTo) || subscribers.push(task.assignedTo)), subscribers;
};
function FormCreate(props2) {
  const [creating, setCreating] = React.useState(!1), { onChange } = props2, { setViewMode, setActiveTab } = useTasksNavigation(), toast = ui.useToast(), telemetry2 = react.useTelemetry(), [createMore, setCreateMore] = React.useState(!1), handleCreateMore = React.useCallback(() => setCreateMore((p) => !p), []), value = props2.value, onRemove = React.useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { handleRemove, removeStatus } = useRemoveTask({ id: value._id, onRemoved: onRemove }), { t: t2 } = useTranslation(tasksLocaleNamespace), { data } = useTasks(), savedTask = data.find((task) => task._id === value._id);
  React.useEffect(() => {
    creating && savedTask != null && savedTask.createdByUser && (telemetry2.log(TaskCreated), toast.push({
      closable: !0,
      status: "success",
      title: t2("form.status.success")
    }), setCreating(!1), createMore ? setViewMode({ type: "create" }) : setActiveTab("subscribed"));
  }, [creating, savedTask == null ? void 0 : savedTask.createdByUser]), React.useEffect(() => {
    let timeoutId = null;
    return creating && (timeoutId = setTimeout(() => {
      setCreating(!1), toast.push({
        closable: !0,
        status: "error",
        title: t2("form.status.error.creation-failed")
      });
    }, 1e4)), () => {
      timeoutId && clearTimeout(timeoutId);
    };
  }, [creating]);
  const handleCreate = React.useCallback(async () => {
    if (setCreating(!0), !(value != null && value.title)) {
      toast.push({
        closable: !0,
        status: "error",
        title: t2("form.status.error.title-required")
      });
      return;
    }
    onChange([
      set(getTaskSubscribers(value), ["subscribers"]),
      set((/* @__PURE__ */ new Date()).toISOString(), ["createdByUser"])
    ]);
  }, [value, onChange, t2, toast]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    props2.renderDefault(props2),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { paddingTop: 1, gap: 4, children: [
      value._rev && /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          onClick: handleRemove,
          mode: "bleed",
          icon: icons.TrashIcon,
          tooltipProps: {
            content: t2("buttons.discard.text")
          },
          disabled: removeStatus === "loading",
          loading: removeStatus === "loading"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, justify: "flex-end", flex: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Switch, { onChange: handleCreateMore, checked: createMore }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t2("form.input.create-more.text") })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          text: t2("buttons.create.text"),
          onClick: handleCreate,
          disabled: creating,
          loading: creating
        }
      )
    ] }) })
  ] });
}
function RemoveTaskDialog(props2) {
  const { handleCloseDialog, handleRemove, removeStatus, showDialog } = props2, { t: t2 } = useTranslation(tasksLocaleNamespace);
  return showDialog ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      id: "remove-task",
      header: t2("dialog.remove-task.title"),
      onClose: handleCloseDialog,
      footer: {
        cancelButton: {
          text: t2("dialog.remove-task.buttons.cancel.text"),
          onClick: handleCloseDialog
        },
        confirmButton: {
          text: t2("dialog.remove-task.buttons.confirm.text"),
          tone: "critical",
          onClick: handleRemove,
          loading: removeStatus === "loading"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: t2("dialog.remove-task.body") }) })
    }
  ) : null;
}
const FirstRow = styledComponents.styled(ui.Flex)((props2) => {
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    column-gap: ${theme$1.space[2]}px;
    row-gap: ${theme$1.space[3]}px;
  `;
});
function FormActionsMenu({ id: id2, value }) {
  const { setViewMode, handleCopyLinkToTask } = useTasksNavigation(), { mode } = useTasksEnabled(), telemetry2 = react.useTelemetry(), onTaskRemoved = React.useCallback(() => {
    setViewMode({ type: "list" }), telemetry2.log(TaskRemoved);
  }, [setViewMode, telemetry2]), removeTask = useRemoveTask({ id: id2, onRemoved: onTaskRemoved }), duplicateTask = React.useCallback(() => {
    setViewMode({ type: "duplicate", duplicateTaskValues: value }), telemetry2.log(TaskDuplicated);
  }, [setViewMode, telemetry2, value]), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        id: "edit-task-menu",
        button: /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
        popover: {
          placement: "bottom",
          fallbackPlacements: ["bottom-end", "bottom-start"]
        },
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("menuitem.duplicate.text"),
              icon: icons.CopyIcon,
              onClick: duplicateTask,
              tooltipProps: mode === "upsell" ? { content: t2("menuitem.duplicate.upsell-tooltip") } : void 0,
              disabled: mode === "upsell"
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("menuitem.copylink.text"),
              icon: icons.LinkIcon,
              onClick: handleCopyLinkToTask
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              text: t2("menuitem.delete.text"),
              icon: icons.TrashIcon,
              onClick: removeTask.handleOpenDialog,
              tone: "critical"
            }
          )
        ] })
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(RemoveTaskDialog, { ...removeTask })
  ] });
}
function FormEditInner(props2) {
  var _a2, _b, _c, _d, _e, _f;
  const statusField = props2.schemaType.fields.find((f) => f.name === "status"), value = props2.value, currentUser = useCurrentUser(), { t: t2 } = useTranslation(tasksLocaleNamespace), activityData = useActivityLog(value).changes, handleChangeAndSubscribe = React.useCallback(
    (patch2) => {
      const subscribers = value.subscribers || [];
      props2.onChange(patch2), currentUser && (subscribers.includes(currentUser.id) || props2.onChange(set([...subscribers, currentUser.id], ["subscribers"])));
    },
    [currentUser, props2, value.subscribers]
  );
  if (!statusField)
    throw new Error("Status field not found");
  return (_a2 = props2.value) != null && _a2._id ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        Title,
        {
          onChange: handleChangeAndSubscribe,
          value: (_b = props2.value) == null ? void 0 : _b.title,
          path: ["title"],
          placeholder: t2("form.input.title.placeholder")
        }
      ) }),
      /* @__PURE__ */ jsxRuntime.jsx(FormActionsMenu, { id: (_c = props2.value) == null ? void 0 : _c._id, value })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
      FirstRow,
      {
        paddingBottom: 3,
        paddingTop: 4,
        align: "flex-start",
        justify: "flex-start",
        wrap: "wrap",
        children: /* @__PURE__ */ jsxRuntime.jsxs(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            StatusSelector,
            {
              value: (_d = props2.value) == null ? void 0 : _d.status,
              path: ["status"],
              onChange: handleChangeAndSubscribe,
              options: statusField.type.options.list
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            AssigneeEditFormField,
            {
              value: (_e = props2.value) == null ? void 0 : _e.assignedTo,
              onChange: handleChangeAndSubscribe,
              path: ["assignedTo"]
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            DateEditFormField,
            {
              value: (_f = props2.value) == null ? void 0 : _f.dueBy,
              onChange: handleChangeAndSubscribe,
              path: ["dueBy"]
            }
          )
        ] })
      }
    ) }),
    props2.renderDefault(props2),
    /* @__PURE__ */ jsxRuntime.jsx(
      CommentsProvider,
      {
        documentId: value._id,
        documentType: "tasks.task",
        sortOrder: "asc",
        type: "task",
        children: /* @__PURE__ */ jsxRuntime.jsx(CurrentWorkspaceProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, paddingTop: 4, marginTop: 4, paddingBottom: 6, children: /* @__PURE__ */ jsxRuntime.jsx(
          TasksActivityLog,
          {
            value,
            onChange: props2.onChange,
            path: ["subscribers"],
            activityData
          }
        ) }) })
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, {});
}
function FormEdit(props2) {
  const value = props2.value, currentUser = useCurrentUser(), transformPatches = React.useCallback(
    (patches) => {
      if (!currentUser || patches.some((patch2) => patch2.path[0] === "subscribers") || patches.some((patch2) => patch2.path[0] === "context" && patch2.path[1] === "notification"))
        return patches;
      const subscribers = value.subscribers || [], newSubscribers = [...subscribers], changeAssigneePatch = patches.find((patch2) => patch2.path[0] === "assignedTo");
      changeAssigneePatch && changeAssigneePatch.type === "set" && typeof changeAssigneePatch.value == "string" && !newSubscribers.includes(changeAssigneePatch.value) && newSubscribers.push(changeAssigneePatch.value), newSubscribers.includes(currentUser.id) || newSubscribers.push(currentUser.id);
      const changedDescriptionPatch = patches.find(
        (patch2) => patch2.path[0] === "description" && patch2.type === "set"
      );
      if (changedDescriptionPatch) {
        const prevMentionedUser = getMentionedUsers(value.description), newDescription = changedDescriptionPatch.type === "set" ? changedDescriptionPatch.value : void 0;
        getMentionedUsers(newDescription).filter((user) => !prevMentionedUser.includes(user)).forEach((user) => {
          newSubscribers.includes(user) || newSubscribers.push(user);
        });
      }
      return newSubscribers.length !== subscribers.length && patches.push(set(newSubscribers, ["subscribers"])), patches;
    },
    [currentUser, value.subscribers, value.description]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TransformPatches, { transform: transformPatches, children: /* @__PURE__ */ jsxRuntime.jsx(FormEditInner, { ...props2 }) });
}
function getTaskURL(taskId, basePath, toolName = "") {
  let path = window.location.origin;
  basePath && (path += basePath), toolName && (path += `/${toolName}`);
  const currentUrl = new URL(`${path}/`);
  return currentUrl.searchParams.set("sidebar", "tasks"), currentUrl.searchParams.set("selectedTask", taskId), currentUrl.searchParams.set("viewMode", "edit"), currentUrl.toString();
}
function TasksNotificationTargetInner(props2) {
  var _a2, _b, _c, _d;
  const { inputProps } = props2, { onChange } = inputProps, activeToolName = router.useRouterState(
    React.useCallback(
      (routerState) => typeof routerState.tool == "string" ? routerState.tool : void 0,
      []
    )
  ), { target, _id, context, _rev } = useFormValue([]), { title: workspaceTitle, basePath } = useWorkspace(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), imageBuilder = React.useMemo(() => imageUrlBuilder__default.default(client2), [client2]), documentId = (_b = (_a2 = target == null ? void 0 : target.document) == null ? void 0 : _a2._ref) != null ? _b : "", documentType = (_c = target == null ? void 0 : target.documentType) != null ? _c : "", { isLoading: previewValuesLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), targetContentTitle = (value == null ? void 0 : value.title) || null, imageUrl = assetUtils.isImageSource(value == null ? void 0 : value.media) ? imageBuilder.image(value.media).width(96).height(96).url() : null, notificationTarget = React.useMemo(() => {
    var _a22;
    const contextUrl = (_a22 = context == null ? void 0 : context.notification) == null ? void 0 : _a22.url;
    return {
      url: (
        // Avoid updating the contextURL in dev mode if it already exists, persist the deployed one.
        contextUrl && isDev ? contextUrl : getTaskURL(_id, basePath, activeToolName)
      ),
      workspaceTitle,
      targetContentImageUrl: imageUrl,
      targetContentTitle
    };
  }, [
    (_d = context == null ? void 0 : context.notification) == null ? void 0 : _d.url,
    _id,
    basePath,
    activeToolName,
    workspaceTitle,
    imageUrl,
    targetContentTitle
  ]);
  return React.useEffect(() => {
    documentId && documentType && previewValuesLoading || _rev && (deepEquals__default.default(context == null ? void 0 : context.notification, notificationTarget) || onChange(set(notificationTarget, ["notification"])));
  }, [_rev, context, documentId, documentType, notificationTarget, previewValuesLoading, onChange]), null;
}
function TasksNotificationTarget(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(CurrentWorkspaceProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksNotificationTargetInner, { ...props2 }) });
}
const targetContentField = (mode) => types.defineField({
  type: "object",
  name: "target",
  title: "Target",
  components: {
    field: (props2) => /* @__PURE__ */ jsxRuntime.jsx(TargetField, { ...props2, mode })
  },
  fields: [
    {
      name: "document",
      type: "crossDatasetReference",
      dataset: "playground",
      weak: !0,
      studioUrl: ({ id: id2, type }) => `intent/edit/id=${id2};type=${type}/`,
      to: [
        {
          type: "any_document",
          preview: {
            select: { title: "title" }
          }
        }
      ]
    },
    {
      name: "documentType",
      type: "string",
      title: "Document type"
    }
  ]
}), descriptionInputField = (mode) => types.defineField({
  type: "array",
  name: "description",
  title: "Description",
  components: {
    field: (props2) => /* @__PURE__ */ jsxRuntime.jsx(DescriptionInput, { ...props2, mode })
  },
  of: [
    {
      type: "block",
      name: "block",
      of: [
        {
          name: "mention",
          type: "object",
          fields: [
            {
              name: "userId",
              type: "string"
            }
          ]
        }
      ],
      marks: {
        annotations: []
      },
      styles: [{ title: "Normal", value: "normal" }],
      lists: []
    }
  ]
}), taskSchema = (mode) => types.defineType({
  type: "document",
  name: "tasks.task",
  liveEdit: !0,
  components: {
    input: mode === "edit" ? FormEdit : FormCreate
  },
  fields: [
    {
      type: "string",
      title: "Title",
      name: "title",
      placeholder: "Task title",
      components: {
        field: TitleField
      },
      hidden: mode === "edit"
    },
    ...mode === "edit" ? [targetContentField(mode), descriptionInputField(mode)] : [descriptionInputField(mode), targetContentField(mode)],
    {
      type: "string",
      name: "assignedTo",
      title: "Assign to",
      placeholder: "Select assignee",
      components: {
        field: FieldWrapper,
        input: AssigneeCreateFormField
      },
      hidden: mode === "edit"
    },
    {
      type: "date",
      name: "dueBy",
      title: "Deadline",
      placeholder: "yyyy-mm-dd",
      components: {
        field: FieldWrapper
      },
      hidden: mode === "edit"
    },
    {
      type: "string",
      name: "authorId",
      hidden: !0
    },
    {
      type: "string",
      name: "createdByUser",
      hidden: !0
    },
    {
      type: "array",
      of: [{ type: "string" }],
      name: "subscribers",
      hidden: !0
    },
    {
      type: "string",
      name: "status",
      title: "Status",
      options: {
        list: TASK_STATUS.map((s) => ({ value: s.value, title: s.title }))
      },
      hidden: !0
    },
    {
      type: "object",
      name: "context",
      components: {
        field: TasksNotificationTarget
      },
      fields: [
        {
          type: "object",
          name: "notification",
          fields: [
            {
              type: "string",
              name: "url"
            },
            {
              type: "string",
              name: "workspaceTitle"
            },
            {
              type: "string",
              name: "targetContentImageUrl"
            },
            {
              type: "string",
              name: "targetContentTitle"
            }
          ]
        }
      ]
    }
  ]
});
function TasksAddonWorkspaceProviderInner({
  children,
  mode,
  addonDataset
}) {
  const apiHost = useClient({ apiVersion: API_VERSION$1 }).config().apiHost, basePath = "", source = useSource(), addonDatasetConfig = React.useMemo(
    () => ({
      basePath,
      dataset: addonDataset,
      name: `addon-dataset-${addonDataset}`,
      projectId: source.projectId,
      apiHost,
      schema: {
        types: [taskSchema(mode)]
      }
    }),
    [source.projectId, mode, apiHost, addonDataset, basePath]
  ), { workspaces } = React.useMemo(
    () => prepareConfig(addonDatasetConfig, { basePath }),
    [addonDatasetConfig, basePath]
  ), addonWorkspace = useWorkspaceLoader(workspaces[0]);
  return addonWorkspace ? /* @__PURE__ */ jsxRuntime.jsx(WorkspaceProvider, { workspace: addonWorkspace, children: /* @__PURE__ */ jsxRuntime.jsx(SourceProvider, { source: addonWorkspace.unstable_sources[0], children: /* @__PURE__ */ jsxRuntime.jsx(ResourceCacheProvider, { children }) }) }) : null;
}
function TasksAddonWorkspaceProvider(props2) {
  const { client: addonDatasetClient, ready, createAddonDataset } = useAddonDataset(), addonDataset = addonDatasetClient == null ? void 0 : addonDatasetClient.config().dataset;
  return React.useEffect(() => {
    !addonDataset && ready && createAddonDataset();
  }, [addonDataset, ready, createAddonDataset]), addonDataset ? /* @__PURE__ */ jsxRuntime.jsx(TasksAddonWorkspaceProviderInner, { ...props2, addonDataset }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, {});
}
function useTasksFormBuilder(options) {
  const { documentType = "tasks.task", documentId, initialValue = {} } = options, tasksSchemaType = useSchema().get(documentType);
  if (!tasksSchemaType)
    throw new Error(`Schema type for '${documentType}' not found`);
  const { validation: validationRaw } = useValidationStatus(documentId, documentType), validation2 = useUnique(validationRaw), [focusPath, setFocusPath] = React.useState([]), [openPath, setOpenPath] = React.useState([]), [collapsedPaths, onSetCollapsedPath] = React.useState(), [collapsedFieldSets, onSetCollapsedFieldSets] = React.useState(), [fieldGroupState, onSetFieldGroupState] = React.useState(), [presence] = React.useState([]), handleFocus = React.useCallback(
    (nextFocusPath) => {
      setFocusPath(nextFocusPath);
    },
    [setFocusPath]
  ), handleBlur = React.useCallback(() => {
    setFocusPath([]);
  }, []), handleOnSetCollapsedPath = React.useCallback((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = React.useCallback((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = React.useCallback(
    (path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)),
    []
  ), { patch: patch2 } = useDocumentOperation(documentId, documentType), patchRef = React.useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch2.execute(toMutationPatches(event.patches), initialValue);
  };
  const handleChange = React.useCallback((event) => patchRef.current(event), []), connectionState = useConnectionState(documentId, documentType), editState2 = useEditState(documentId, documentType), value = (editState2 == null ? void 0 : editState2.draft) || (editState2 == null ? void 0 : editState2.published) || initialValue, formState = useFormState(tasksSchemaType, {
    value,
    comparisonValue: value,
    readOnly: !1,
    changesOpen: !1,
    presence,
    focusPath,
    openPath,
    collapsedPaths,
    collapsedFieldSets,
    fieldGroupState,
    validation: validation2
  }), ready = editState2.ready && connectionState === "connected", patchChannel = React.useMemo(() => createPatchChannel(), []);
  return formState === null || !ready ? { loading: !0 } : {
    id: "root",
    onChange: handleChange,
    // eslint-disable-next-line camelcase
    __internal_patchChannel: patchChannel,
    // eslint-disable-next-line camelcase
    __internal_fieldActions: void 0,
    onPathFocus: handleFocus,
    onPathOpen: setOpenPath,
    onPathBlur: handleBlur,
    onFieldGroupSelect: handleSetActiveFieldGroup,
    onSetFieldSetCollapsed: handleOnSetCollapsedFieldSet,
    onSetPathCollapsed: handleOnSetCollapsedPath,
    collapsedPaths,
    collapsedFieldSets,
    focusPath: formState.focusPath,
    changed: formState.changed,
    focused: formState.focused,
    groups: formState.groups,
    validation: formState.validation,
    members: formState.members,
    presence: formState.presence,
    schemaType: tasksSchemaType,
    value: formState.value
  };
}
const VARIANTS$1 = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.2, delay: 0.2 }
  }
}, FormBuilderRoot = styledComponents.styled(framerMotion.motion.div)((props2) => {
  const theme$1 = theme.getTheme_v2(props2.theme);
  return `
    // Update spacing for the form builder
    & > [data-ui='Stack'] {
      grid-gap: ${ui.rem(theme$1.space[4])};
    }
`;
}), TasksFormBuilderInner = ({
  documentId,
  initialValue
}) => {
  var _a2, _b;
  const formBuilderProps = useTasksFormBuilder({
    documentType: "tasks.task",
    documentId,
    initialValue
  }), { setSelectedDocument } = useMentionUser(), target = formBuilderProps.loading || (_a2 = formBuilderProps.value) == null ? void 0 : _a2.target, targetId = (_b = target == null ? void 0 : target.document) == null ? void 0 : _b._ref, targetType = target == null ? void 0 : target.documentType;
  return React.useEffect(() => {
    setSelectedDocument(targetId && targetType ? { _id: targetId, _type: targetType } : null);
  }, [targetId, targetType, setSelectedDocument]), /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: formBuilderProps.loading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(FormBuilderRoot, { id: "wrapper", initial: "hidden", animate: "visible", variants: VARIANTS$1, children: /* @__PURE__ */ jsxRuntime.jsx(FormBuilder, { ...formBuilderProps }) }) });
};
function TasksFormBuilder() {
  const currentUser = useCurrentUser(), { activeDocument } = useTasks(), { dataset, projectId } = useWorkspace(), {
    state: { selectedTask, viewMode, duplicateTaskValues }
  } = useTasksNavigation(), initialValue = React.useMemo(() => {
    if (currentUser && selectedTask) {
      if (viewMode === "duplicate")
        return {
          ...duplicateTaskValues,
          title: `${duplicateTaskValues == null ? void 0 : duplicateTaskValues.title} (copy)`,
          // Set the new task title
          createdByUser: void 0,
          // Remove the createdByUser field
          _id: selectedTask,
          // Set the new task ID
          _type: "tasks.task",
          authorId: currentUser.id,
          // Set the author ID
          status: "open"
        };
      if (viewMode === "create")
        return {
          _id: selectedTask,
          _type: "tasks.task",
          authorId: currentUser.id,
          status: "open",
          subscribers: [currentUser.id],
          target: activeDocument ? getTargetValue({
            documentId: activeDocument.documentId,
            documentType: activeDocument.documentType,
            dataset,
            projectId
          }) : void 0
        };
    }
  }, [activeDocument, currentUser, dataset, duplicateTaskValues, projectId, selectedTask, viewMode]);
  return currentUser ? selectedTask ? (
    // This provider needs to be mounted before the TasksAddonWorkspaceProvider.
    /* @__PURE__ */ jsxRuntime.jsx(MentionUserProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksAddonWorkspaceProvider, { mode: viewMode === "edit" ? "edit" : "create", children: /* @__PURE__ */ jsxRuntime.jsx(
      TasksFormBuilderInner,
      {
        documentId: selectedTask,
        currentUser,
        initialValue
      }
    ) }) })
  ) : null : /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0, title: "Loading current user" });
}
const HEADING_BY_STATUS = {
  open: {
    assigned: {
      heading: "empty-state.status.list.open.assigned.heading",
      text: "empty-state.status.list.open.assigned.text"
    },
    document: { heading: "empty-state.status.list.open.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.open.subscribed.heading",
      text: "empty-state.status.list.open.subscribed.text"
    }
  },
  closed: {
    assigned: {
      heading: "empty-state.status.list.closed.assigned.heading",
      text: "empty-state.status.list.closed.assigned.text"
    },
    document: { heading: "empty-state.status.list.closed.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.closed.subscribed.heading",
      text: "empty-state.status.list.closed.subscribed.text"
    }
  }
};
function EmptyStatusListState({ status }) {
  const {
    state: { activeTabId }
  } = useTasksNavigation(), { t: t2 } = useTranslation(tasksLocaleNamespace), { heading, text } = HEADING_BY_STATUS[status][activeTabId];
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: t2(heading) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2(text) })
  ] });
}
const EMPTY_TASK_LIST = {
  assigned: {
    heading: "empty-state.list.assigned.heading",
    text: "empty-state.list.assigned.text"
  },
  subscribed: {
    heading: "empty-state.list.subscribed.heading",
    text: "empty-state.list.subscribed.text"
  },
  document: {
    heading: "empty-state.list.document.heading",
    text: "empty-state.list.document.text"
  },
  noActiveDocument: {
    heading: "empty-state.list.no-active-document.heading",
    text: "empty-state.list.no-active-document.text"
  }
}, Root$9 = styledComponents.styled.div`
  max-width: 268px;
  margin: 0 auto;
  height: 100%;
  margin-top: 40%;
`, AnimatedText = styledComponents.styled(ui.Text)`
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  animation: fadeIn 0.2s ease-in-out;
`;
function EmptyTasksListState() {
  const { activeDocument } = useTasks(), { mode } = useTasksEnabled(), {
    state: { activeTabId },
    setViewMode
  } = useTasksNavigation(), key = !activeDocument && activeTabId === "document" ? "noActiveDocument" : activeTabId, { heading, text } = EMPTY_TASK_LIST[key], { t: t2 } = useTranslation(tasksLocaleNamespace), handleTaskCreate = React.useCallback(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$9, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 3, align: "center", flex: 1, justify: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(AnimatedText, { size: 1, weight: "semibold", children: t2(heading) }, key),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 6, paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(AnimatedText, { size: 1, align: "center", children: t2(text) }, key) }),
    mode !== "upsell" && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.AddIcon,
        text: t2("empty-state.list.create-new"),
        onClick: handleTaskCreate
      }
    )
  ] }) });
}
const StyledIntentLink = styledComponents.styled(router.IntentLink)((props2) => `
  text-decoration: underline;
  text-decoration-color: ${theme.getTheme_v2(props2.theme).color.input.default.enabled.border};
  text-underline-offset: 2px;
`);
function DocumentPreview({
  documentId,
  documentType
}) {
  const documentSchema = useSchema().get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), Link2 = React.useMemo(
    () => React.forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsxRuntime.jsx(
        StyledIntentLink,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return documentSchema ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) }),
    isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { size: 1, muted: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, as: Link2, weight: "medium", style: { maxWidth: "20ch" }, textOverflow: "ellipsis", children: (value == null ? void 0 : value.title) || "Untitled" })
  ] }) : null;
}
function TasksStatus(props2) {
  const operations = useTaskOperations(), { documentId, status } = props2, [checkboxValue, setCheckboxValue] = React.useState(status === "closed"), [isLoading, setIsLoading] = React.useState(!1), handleCheckboxChange = React.useCallback(
    async (event) => {
      const isChecked = event.target.checked;
      setCheckboxValue(isChecked), setIsLoading(!0);
      try {
        isChecked ? await operations.edit(documentId, { status: "closed" }) : isChecked || await operations.edit(documentId, { status: "open" });
      } catch (error) {
        console.error("An error occurred while updating the task status", error);
      } finally {
        setIsLoading(!1);
      }
    },
    [documentId, operations]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: isLoading ? /* @__PURE__ */ jsxRuntime.jsx("div", { style: { height: "17px", width: "17px" }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { marginLeft: "3.5px", marginRight: "3.5px", marginTop: "3.5px" } }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Checkbox, { onChange: handleCheckboxChange, checked: checkboxValue, disabled: isLoading }) });
}
const TitleButton = styledComponents.styled(ui.Button)`
  width: 100%;
  max-width: 100%;
`, TaskDetailsRoot = styledComponents.styled(ui.Flex)`
  /* Checkbox width is 17px and first row gap is 12px. */
  margin-left: 29px;
`;
function getTargetDocumentMeta(target) {
  var _a2;
  if ((_a2 = target == null ? void 0 : target.document) != null && _a2._ref)
    return {
      _ref: target == null ? void 0 : target.document._ref,
      _type: target == null ? void 0 : target.documentType
    };
}
function TaskDueDate({ dueBy }) {
  const fullDateFormatter = useDateTimeFormat({ dateStyle: "medium" }), monthAndDayFormatter = useDateTimeFormat({ month: "short", day: "numeric" }), dayFormatter = useDateTimeFormat({ weekday: "long" }), dateOptions = React.useMemo(() => {
    const date = new Date(dueBy);
    return {
      fullDate: fullDateFormatter.format(date),
      monthAndDay: monthAndDayFormatter.format(date),
      day: dayFormatter.format(date),
      isDueByToday: dateFns.isToday(date),
      isDueThisWeek: dateFns.isThisISOWeek(date)
    };
  }, [dayFormatter, dueBy, fullDateFormatter, monthAndDayFormatter]), { fullDate, monthAndDay, day, isDueByToday, isDueThisWeek } = dateOptions;
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: fullDate, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: isDueByToday ? "critical" : "transparent", padding: 1, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, {
    as: "time",
    size: 1,
    dateTime: dueBy,
    muted: !0,
    // eslint-disable-next-line no-nested-ternary
    children: isDueByToday ? "Today" : isDueThisWeek ? day : monthAndDay
  }) }) }) });
}
function TasksListItem(props2) {
  const { assignedTo, title, dueBy, target, onSelect, documentId, status } = props2, targetDocument = React.useMemo(() => getTargetDocumentMeta(target), [target]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksStatus, { documentId, status }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TitleButton, { onClick: onSelect, mode: "bleed", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title || "Untitled" }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: assignedTo ? { id: assignedTo } : void 0, withTooltip: !0 })
    ] }),
    (dueBy || targetDocument) && /* @__PURE__ */ jsxRuntime.jsxs(TaskDetailsRoot, { align: "center", gap: 2, paddingX: 0, children: [
      dueBy && /* @__PURE__ */ jsxRuntime.jsx(TaskDueDate, { dueBy }),
      targetDocument && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        DocumentPreview,
        {
          documentId: targetDocument._ref,
          documentType: targetDocument._type
        }
      ) })
    ] })
  ] });
}
const EMPTY_ARRAY$9 = [], getLabelForStatus = (status) => {
  const statusConfig = TASK_STATUS.find((item) => item.value === status);
  return statusConfig == null ? void 0 : statusConfig.title;
}, DetailsFlex = styledComponents.styled(ui.Flex)`
  [data-ui='summary-icon'] {
    transition: transform 0.2s;
    transform: rotate(-90deg);
  }
  &[open] [data-ui='summary-icon'] {
    transform: rotate(0);
  }
  > summary::-webkit-details-marker {
    display: none;
  }
`, SummaryBox = styledComponents.styled(ui.Box)`
  list-style: none;
`;
function TaskList(props2) {
  const { status, tasks: tasks2, onTaskSelect } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(DetailsFlex, { forwardedAs: "details", direction: "column", open: status === "open", children: [
    /* @__PURE__ */ jsxRuntime.jsx(SummaryBox, { forwardedAs: "summary", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, paddingY: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", muted: !0, children: getLabelForStatus(status) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, { "data-ui": "summary-icon" }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, marginTop: 4, paddingBottom: 5, children: (tasks2 == null ? void 0 : tasks2.length) > 0 ? tasks2.map((task, index) => {
      const showDivider = index < tasks2.length - 1;
      return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TasksListItem,
          {
            documentId: task._id,
            title: task.title,
            dueBy: task.dueBy,
            assignedTo: task.assignedTo,
            target: task.target,
            onSelect: () => onTaskSelect(task._id),
            status: task.status
          }
        ),
        showDivider && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {})
      ] }, task._id);
    }) : /* @__PURE__ */ jsxRuntime.jsx(EmptyStatusListState, { status }) })
  ] });
}
function TasksList(props2) {
  var _a2, _b;
  const { items = EMPTY_ARRAY$9, onTaskSelect } = props2, tasksByStatus = React.useMemo(
    () => items.reduce((acc, task) => (acc[task.status] || (acc[task.status] = []), acc[task.status].push(task), acc), {}),
    [items]
  ), hasOpenTasks = ((_a2 = tasksByStatus.open) == null ? void 0 : _a2.length) > 0, hasClosedTasks = ((_b = tasksByStatus.closed) == null ? void 0 : _b.length) > 0;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, flex: 1, children: !hasOpenTasks && !hasClosedTasks ? /* @__PURE__ */ jsxRuntime.jsx(EmptyTasksListState, {}) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(TaskList, { status: "open", tasks: tasksByStatus.open, onTaskSelect }),
    /* @__PURE__ */ jsxRuntime.jsx(TaskList, { status: "closed", tasks: tasksByStatus.closed, onTaskSelect })
  ] }) });
}
function TasksUpsellPanel() {
  const {
    upsellData: data,
    telemetryLogs: { panelPrimaryClicked: onPrimaryClick, panelSecondaryClicked: onSecondaryClick }
  } = useTasksUpsell();
  return data ? /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 6, children: /* @__PURE__ */ jsxRuntime.jsx(
    UpsellPanel,
    {
      data,
      onPrimaryClick,
      onSecondaryClick
    }
  ) }) }) : null;
}
const FEEDBACK_FORM_LINK = "https://snty.link/tasks-feedback", Span$1 = styledComponents.styled.span`
  margin-right: 0.2em;
`, Link = styledComponents.styled.a`
  white-space: nowrap;
  > [data-sanity-icon] {
    --card-icon-color: var(--card-link-color);
  }
`;
function LinkComponent(props2) {
  return /* @__PURE__ */ jsxRuntime.jsxs(Link, { href: FEEDBACK_FORM_LINK, target: "_blank", rel: "noreferrer", children: [
    /* @__PURE__ */ jsxRuntime.jsx(Span$1, { children: props2.children }),
    " ",
    /* @__PURE__ */ jsxRuntime.jsx(icons.LaunchIcon, {})
  ] });
}
function TasksListFeedbackFooter() {
  const { t: t2 } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { i18nKey: "list.feedback.text", t: t2, components: { Link: LinkComponent } }) }) });
}
const LIST_STYLES = {
  marginLeft: "-0.5em",
  justifyContent: "space-between",
  display: "flex"
};
function TasksListTabs({ activeTabId, onChange }) {
  const { t: t2 } = useTranslation(tasksLocaleNamespace), tabs = React.useMemo(
    () => [
      {
        id: "assigned",
        label: t2("tab.assigned.label")
      },
      {
        id: "subscribed",
        label: t2("tab.subscribed.label")
      },
      {
        id: "document",
        label: t2("tab.document.label")
      }
    ],
    [t2]
  ), handleTabChange = React.useCallback(
    (tab) => {
      onChange(tab.id);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.TabList, { space: 2, style: LIST_STYLES, children: tabs.map((tab) => /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tab,
    {
      "aria-controls": `${tab.id}-panel`,
      id: `${tab.id}-tab`,
      onClick: () => handleTabChange(tab),
      selected: tab.id === activeTabId,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: tab.label })
    },
    `${tab.id}-tab`
  )) });
}
const Divider = styledComponents.styled.div((props2) => `
    height: 25px;
    width: 1px;
    background-color: ${theme.getTheme_v2(props2.theme).color.input.default.enabled.border};
  `);
function TasksActiveTabNavigation(props2) {
  const { items: allItems } = props2, { state, setViewMode } = useTasksNavigation(), { selectedTask } = state, items = allItems.filter((t22) => t22.status === "open"), currentItemIndex = items.findIndex((item) => item._id === selectedTask), goToPreviousTask = React.useCallback(() => {
    const prevTaskId = currentItemIndex > 0 ? items[currentItemIndex - 1]._id : items[items.length - 1]._id;
    setViewMode({ type: "edit", id: prevTaskId });
  }, [currentItemIndex, items, setViewMode]), goToNextTask = React.useCallback(() => {
    const nextTaskId = currentItemIndex < items.length - 1 ? items[currentItemIndex + 1]._id : items[0]._id;
    setViewMode({ type: "edit", id: nextTaskId });
  }, [currentItemIndex, items, setViewMode]), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return items.length ? /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        tooltipProps: { content: t2("buttons.previous.tooltip") },
        mode: "bleed",
        icon: icons.ChevronLeftIcon,
        onClick: goToPreviousTask
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: t2("panel.navigation.tooltip"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
      currentItemIndex + 1,
      " / ",
      items.length
    ] }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        tooltipProps: { content: t2("buttons.next.tooltip") },
        mode: "bleed",
        icon: icons.ChevronRightIcon,
        onClick: goToNextTask
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(Divider, {})
  ] }) }) : null;
}
const MENU_BUTTON_POPOVER_PROPS = {
  constrainSize: !0,
  fallbackPlacements: ["bottom-end"],
  placement: "bottom-end",
  portal: !0
}, StyledMenu$4 = styledComponents.styled(ui.Menu)`
  width: 220px;
`;
function TasksDraftsMenuItem(props2) {
  const { isSelected, item, onSelect } = props2, handleClick = React.useCallback(() => {
    onSelect(item._id);
  }, [item._id, onSelect]), iconRight = isSelected ? icons.CheckmarkIcon : void 0, text = item.title || "Untitled";
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuItem,
    {
      iconRight,
      onClick: handleClick,
      pressed: isSelected,
      selected: isSelected,
      text
    }
  );
}
function TasksHeaderDraftsMenu() {
  const { data } = useTasks(), { state, setViewMode } = useTasksNavigation(), { viewMode, selectedTask } = state, currentUser = useCurrentUser(), draftTasks = React.useMemo(() => currentUser != null && currentUser.id ? data.filter((task) => {
    const isAuthoredByUser = task.authorId === currentUser.id, isDraft2 = !task.createdByUser, hasEdits = task._updatedAt !== task._createdAt, isNotTheTaskBeingCreated = viewMode === "create" ? task._id !== selectedTask : !0;
    return isAuthoredByUser && isDraft2 && isNotTheTaskBeingCreated && hasEdits;
  }) : [], [data, selectedTask, currentUser == null ? void 0 : currentUser.id, viewMode]), handleSelectTask = React.useCallback(
    (id2) => {
      setViewMode({ type: "draft", id: id2 });
    },
    [setViewMode]
  ), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return draftTasks.length ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { text: t2("buttons.draft.text"), mode: "ghost", iconRight: icons.ChevronDownIcon }),
      id: "edit-task-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(StyledMenu$4, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: t2("panel.drafts.title") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
        draftTasks == null ? void 0 : draftTasks.map((task) => /* @__PURE__ */ jsxRuntime.jsx(
          TasksDraftsMenuItem,
          {
            isSelected: selectedTask === task._id,
            item: task,
            onSelect: handleSelectTask
          },
          task._id
        ))
      ] }),
      popover: MENU_BUTTON_POPOVER_PROPS
    }
  ) : null;
}
function TasksSidebarHeader(props2) {
  const { items: allItems } = props2, { mode } = useTasksEnabled(), { state, setViewMode, handleCloseTasks } = useTasksNavigation(), { viewMode, activeTabId } = state, handleTaskCreate = React.useCallback(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]), handleGoBack = React.useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { t: t2 } = useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "space-between", align: "center", gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", flex: 1, children: viewMode === "list" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 2, weight: "semibold", children: t2("panel.title") }) }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { mode: "bleed", space: 2, padding: 2, onClick: handleGoBack, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("panel.title") }) }),
      /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", style: { textTransform: "capitalize" }, children: viewMode === "create" || viewMode === "draft" ? t2("panel.create.title") : activeTabId }) })
    ] }) }),
    (viewMode === "create" || viewMode === "draft") && /* @__PURE__ */ jsxRuntime.jsx(TasksHeaderDraftsMenu, {}),
    viewMode === "edit" && /* @__PURE__ */ jsxRuntime.jsx(TasksActiveTabNavigation, { items: allItems }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
      viewMode === "list" && /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          icon: icons.AddIcon,
          onClick: handleTaskCreate,
          mode: "bleed",
          text: t2("buttons.new.text"),
          disabled: mode === "upsell",
          tooltipProps: mode === "upsell" ? {
            content: t2("buttons.new.upsell-tooltip")
          } : void 0
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          tooltipProps: {
            content: t2("panel.close.tooltip")
          },
          iconRight: icons.CloseIcon,
          mode: "bleed",
          onClick: handleCloseTasks
        }
      )
    ] })
  ] });
}
const RootCard$2 = styledComponents.styled(ui.Card)`
  flex: 1;
  flex-direction: column;
`, HeaderStack = styledComponents.styled(ui.Stack)`
  border-bottom: 1px solid var(--card-border-color);
`, ContentFlex$1 = styledComponents.styled(ui.Flex)`
  overflow-y: scroll;
  overflow-x: hidden;
`;
function TasksStudioSidebarInner() {
  const { mode } = useTasksEnabled(), { activeDocument, data, isLoading } = useTasks(), { state, setActiveTab, setViewMode } = useTasksNavigation(), { activeTabId, viewMode, selectedTask } = state, currentUser = useCurrentUser(), onTaskSelect = React.useCallback((id2) => setViewMode({ type: "edit", id: id2 }), [setViewMode]), filteredList = React.useMemo(() => data.filter((item) => {
    var _a2, _b;
    return item.createdByUser ? activeTabId === "assigned" ? item.assignedTo === (currentUser == null ? void 0 : currentUser.id) : activeTabId === "subscribed" ? (currentUser == null ? void 0 : currentUser.id) && ((_a2 = item.subscribers) == null ? void 0 : _a2.includes(currentUser.id)) : activeTabId === "document" ? (activeDocument == null ? void 0 : activeDocument.documentId) && ((_b = item.target) == null ? void 0 : _b.document._ref) === activeDocument.documentId : !1 : !1;
  }), [activeDocument == null ? void 0 : activeDocument.documentId, activeTabId, data, currentUser]), content2 = React.useMemo(() => viewMode !== "list" ? /* @__PURE__ */ jsxRuntime.jsx(TasksFormBuilder, {}, selectedTask) : isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, {}) }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    mode === "upsell" && /* @__PURE__ */ jsxRuntime.jsx(TasksUpsellPanel, {}),
    /* @__PURE__ */ jsxRuntime.jsx(TasksList, { items: filteredList, onTaskSelect })
  ] }), [filteredList, isLoading, onTaskSelect, selectedTask, viewMode, mode]);
  return /* @__PURE__ */ jsxRuntime.jsxs(RootCard$2, { display: "flex", height: "fill", flex: 1, overflow: "hidden", children: [
    /* @__PURE__ */ jsxRuntime.jsxs(HeaderStack, { space: 3, padding: 3, sizing: "border", children: [
      /* @__PURE__ */ jsxRuntime.jsx(TasksSidebarHeader, { items: filteredList }),
      viewMode === "list" && !isLoading && /* @__PURE__ */ jsxRuntime.jsx(TasksListTabs, { activeTabId, onChange: setActiveTab })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ContentFlex$1,
      {
        direction: "column",
        flex: 1,
        overflow: "auto",
        padding: 3,
        paddingTop: 4,
        paddingX: 4,
        sizing: "border",
        children: content2
      }
    ),
    viewMode === "list" && /* @__PURE__ */ jsxRuntime.jsx(TasksListFeedbackFooter, {})
  ] });
}
function TasksStudioSidebar() {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(TasksStudioSidebarInner, {}) : null;
}
const VARIANTS = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
}, TRANSITION = { duration: 0.2 }, FULLSCREEN_MEDIA_INDEX = 1, POSITION_ABSOLUTE_MEDIA_INDEX = 2, RootFlex$2 = styledComponents.styled(ui.Flex)(({ theme: theme2 }) => {
  const media = theme2.sanity.media;
  return styledComponents.css`
    min-height: 100%;

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      position: relative;
    }
  `;
}), SidebarMotionLayer = styledComponents.styled(framerMotion.motion(ui.Layer))(({ theme: theme2 }) => {
  const media = theme2.sanity.media;
  return styledComponents.css`
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 360px;
    border-left: 1px solid var(--card-border-color);
    box-sizing: border-box;
    overflow: hidden;

    box-shadow:
      0px 6px 8px -4px var(--card-shadow-umbra-color),
      0px 12px 17px -1px var(--card-shadow-penumbra-color);

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      bottom: 0;
      position: absolute;
      right: 0;
      top: 0;
    }

    @media (max-width: ${media[FULLSCREEN_MEDIA_INDEX]}px) {
      border-left: 0;
      min-width: 100%;
      left: 0;
    }
  `;
});
function TasksStudioActiveToolLayoutInner(props2) {
  const mediaIndex = ui.useMediaIndex(), {
    state: { isOpen }
  } = useTasksNavigation(), scrollLock = mediaIndex <= FULLSCREEN_MEDIA_INDEX && isOpen;
  return /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$2, { sizing: "border", height: "fill", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, height: "fill", overflow: scrollLock ? "hidden" : "auto", children: props2.renderDefault(props2) }),
    /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { initial: !1, children: isOpen && /* @__PURE__ */ jsxRuntime.jsx(
      SidebarMotionLayer,
      {
        animate: "visible",
        zOffset: 100,
        height: "fill",
        initial: "hidden",
        transition: TRANSITION,
        variants: VARIANTS,
        children: /* @__PURE__ */ jsxRuntime.jsx(TasksStudioSidebar, {})
      }
    ) })
  ] });
}
function TasksStudioActiveToolLayout(props2) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(TasksStudioActiveToolLayoutInner, { ...props2 }) : props2.renderDefault(props2);
}
const TasksStudioLayoutInner = (props2) => {
  const { enabled, mode } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(AddonDatasetProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.ConditionalWrapper,
    {
      condition: mode === "upsell",
      wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(TasksUpsellProvider, { children }),
      children: /* @__PURE__ */ jsxRuntime.jsx(TasksProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksNavigationProvider, { children: props2.renderDefault(props2) }) })
    }
  ) }) : props2.renderDefault(props2);
};
function TasksStudioLayout(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(TasksEnabledProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksStudioLayoutInner, { ...props2 }) });
}
const EMPTY_ARRAY$8 = [];
function TasksStudioNavbarInner(props2) {
  const {
    handleOpenTasks,
    handleCloseTasks,
    state: { isOpen }
  } = useTasksNavigation(), { t: t2 } = useTranslation(tasksLocaleNamespace), handleClick = React.useCallback(() => {
    isOpen ? handleCloseTasks() : handleOpenTasks();
  }, [isOpen, handleOpenTasks, handleCloseTasks]), actions = React.useMemo(() => [
    ...(props2 == null ? void 0 : props2.__internal_actions) || EMPTY_ARRAY$8,
    {
      icon: icons.PanelRightIcon,
      location: "topbar",
      name: "tasks-topbar",
      onAction: handleClick,
      selected: isOpen,
      title: t2("actions.open.text")
    },
    {
      icon: icons.TaskIcon,
      location: "sidebar",
      name: "tasks-sidebar",
      onAction: handleClick,
      selected: isOpen,
      title: t2("actions.open.text")
    }
  ], [handleClick, isOpen, props2 == null ? void 0 : props2.__internal_actions, t2]);
  return props2.renderDefault({
    ...props2,
    // eslint-disable-next-line camelcase
    __internal_actions: actions
  });
}
function TasksStudioNavbar(props2) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(TasksStudioNavbarInner, { ...props2 }) : props2.renderDefault(props2);
}
const TASKS_NAME = "sanity/tasks", tasks = definePlugin({
  name: "sanity/tasks",
  // eslint-disable-next-line camelcase
  __internal_tasks: {
    footerAction: /* @__PURE__ */ jsxRuntime.jsx(TasksFooterOpenTasks, {})
  },
  document: {
    actions: (prev) => [...prev, TaskCreateAction].filter(Boolean)
  },
  studio: {
    components: {
      layout: TasksStudioLayout,
      navbar: TasksStudioNavbar,
      activeToolLayout: TasksStudioActiveToolLayout
    }
  },
  form: {
    components: {
      input: (props2) => {
        var _a2;
        return props2.id === "root" && ((_a2 = props2.schemaType.type) == null ? void 0 : _a2.name) === "document" ? /* @__PURE__ */ jsxRuntime.jsx(TasksDocumentInputLayout, { ...props2 }) : props2.renderDefault(props2);
      }
    }
  },
  i18n: {
    bundles: [tasksUsEnglishLocaleBundle]
  }
}), defaultPlugins = [comments(), tasks(), scheduledPublishing()];
function getDefaultPlugins(options, plugins) {
  return defaultPlugins.filter((plugin) => plugin.name === SCHEDULED_PUBLISHING_NAME ? options.scheduledPublishing.enabled && !!(plugins != null && plugins.length) : plugin.name === TASKS_NAME ? options.tasks.enabled : !0);
}
function getDefaultPluginsOptions(workspace) {
  return {
    tasks: {
      enabled: !0,
      ...workspace.unstable_tasks,
      ...workspace.tasks
    },
    scheduledPublishing: {
      ...DEFAULT_SCHEDULED_PUBLISH_PLUGIN_OPTIONS,
      ...workspace.scheduledPublishing
    }
  };
}
function resolveSchemaTypes({
  config,
  context
}) {
  return resolveConfigProperty({
    propertyName: "schema.types",
    config,
    context,
    initialValue: [],
    reducer: schemaTypesReducer
  });
}
class SchemaError extends Error {
  constructor(schema2) {
    super("SchemaError"), this.schema = schema2, this.name = "SchemaError";
  }
}
const isError = (p) => p.severity === "error";
function normalizeIcon(icon, title, subtitle = "") {
  return reactIs.isValidElementType(icon) ? React.createElement(icon) : React.isValidElement(icon) ? icon : createDefaultIcon(title, subtitle);
}
const preparedWorkspaces = /* @__PURE__ */ new WeakMap();
function prepareConfig(config, options) {
  if (!Array.isArray(config) && "missingConfigFile" in config)
    throw new ConfigResolutionError({
      name: "",
      type: "configuration file",
      causes: ["No `sanity.config.ts` file found", "No `sanity.config.js` file found"]
    });
  const rootPath = getRootPath(options == null ? void 0 : options.basePath), workspaceOptions = Array.isArray(config) ? config : [config];
  try {
    validateWorkspaces({ workspaces: workspaceOptions });
  } catch (e) {
    throw new ConfigResolutionError({
      name: "",
      type: "workspace",
      causes: [e.message]
    });
  }
  return { type: "prepared-config", workspaces: workspaceOptions.map((rawWorkspace) => {
    if (preparedWorkspaces.has(rawWorkspace))
      return preparedWorkspaces.get(rawWorkspace);
    const defaultPluginsOptions = getDefaultPluginsOptions(rawWorkspace), { unstable_sources: nestedSources = [], ...rootSource } = rawWorkspace, resolvedSources = [rootSource, ...nestedSources].map(({ plugins, ...source }) => ({
      ...source,
      plugins: [...plugins != null ? plugins : [], ...getDefaultPlugins(defaultPluginsOptions, plugins)]
    })).map((source) => {
      const { projectId, dataset } = source;
      let schemaTypes;
      try {
        schemaTypes = resolveSchemaTypes({
          config: source,
          context: { projectId, dataset }
        });
      } catch (e) {
        throw new ConfigResolutionError({
          name: source.name,
          type: "source",
          causes: [e]
        });
      }
      const schema2 = createSchema({
        name: source.name,
        types: schemaTypes
      }), schemaValidationProblemGroups = schema2._validation, schemaErrors = schemaValidationProblemGroups == null ? void 0 : schemaValidationProblemGroups.filter(
        (msg) => msg.problems.some(isError)
      );
      if (schemaValidationProblemGroups && schemaErrors != null && schemaErrors.length)
        throw new SchemaError(schema2);
      const auth = getAuthStore(source), i18n = prepareI18n(source), source$ = auth.state.pipe(
        operators.map(({ client: client2, authenticated, currentUser }) => resolveSource({
          config: source,
          client: client2,
          currentUser,
          schema: schema2,
          authenticated,
          auth,
          i18n
        })),
        operators.shareReplay(1)
      );
      return {
        name: source.name,
        projectId: source.projectId,
        dataset: source.dataset,
        title: source.title || startCase__default.default(source.name),
        auth,
        schema: schema2,
        i18n: i18n.source,
        source: source$
      };
    }), title = rootSource.title || startCase__default.default(rootSource.name), workspaceSummary = {
      type: "workspace-summary",
      auth: resolvedSources[0].auth,
      basePath: joinBasePath(rootPath, rootSource.basePath),
      dataset: rootSource.dataset,
      schema: resolvedSources[0].schema,
      i18n: resolvedSources[0].i18n,
      customIcon: !!rootSource.icon,
      icon: normalizeIcon(rootSource.icon, title, `${rootSource.projectId} ${rootSource.dataset}`),
      name: rootSource.name || "default",
      projectId: rootSource.projectId,
      theme: rootSource.theme || ui.studioTheme,
      title,
      subtitle: rootSource.subtitle,
      __internal: {
        sources: resolvedSources
      },
      // eslint-disable-next-line camelcase
      __internal_serverDocumentActions: rawWorkspace.__internal_serverDocumentActions,
      ...defaultPluginsOptions
    };
    return preparedWorkspaces.set(rawWorkspace, workspaceSummary), workspaceSummary;
  }) };
}
function getAuthStore(source) {
  if (isAuthStore(source.auth))
    return source.auth;
  const clientFactory = source.unstable_clientFactory || client.createClient, { projectId, dataset, apiHost } = source;
  return createAuthStore({ apiHost, ...source.auth, clientFactory, dataset, projectId });
}
function getBifurClient(client2, auth) {
  const bifurVersionedClient = client2.withConfig({ apiVersion: "2022-06-30" }), { dataset, url: baseUrl, requestTagPrefix = "sanity.studio" } = bifurVersionedClient.config(), urlWithTag = `${`${baseUrl.replace(/\/+$/, "")}/socket/${dataset}`.replace(/^http/, "ws")}?tag=${requestTagPrefix}`, options = auth.token ? { token$: auth.token } : {};
  return bifurClient.fromUrl(urlWithTag, options);
}
function resolveSource({
  config,
  client: client2,
  currentUser,
  schema: schema2,
  authenticated,
  auth,
  i18n
}) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const { dataset, projectId } = config, bifur = getBifurClient(client2, auth), errors = [], clients = {}, getClient = (options) => {
    if (!options || !options.apiVersion)
      throw new Error("Missing required `apiVersion` option");
    return clients[options.apiVersion] || (clients[options.apiVersion] = client2.withConfig(options)), clients[options.apiVersion];
  }, context = {
    client: client2,
    getClient,
    currentUser,
    dataset,
    projectId,
    schema: schema2,
    i18n: i18n.source
  }, wrappedClient = client2;
  context.client = [...Object.keys(client2), ...Object.keys(wrappedClient.__proto__)].reduce(
    (acc, key) => {
      const original = Object.hasOwnProperty.call(client2, key) ? wrappedClient[key] : wrappedClient.__proto__[key];
      return Object.defineProperty(acc, key, {
        get() {
          return console.warn(
            '`configContext.client` is deprecated and will be removed in the next release! Use `context.getClient({apiVersion: "2021-06-07"})` instead'
          ), original;
        }
      });
    },
    {}
  );
  let templates;
  try {
    templates = resolveConfigProperty({
      config,
      context,
      propertyName: "schema.templates",
      reducer: schemaTemplatesReducer,
      initialValue: schema2.getTypeNames().filter((typeName) => !/^sanity\./.test(typeName)).map((typeName) => schema2.get(typeName)).filter(isNonNullable$3).filter((schemaType) => {
        var _a22;
        return ((_a22 = schemaType.type) == null ? void 0 : _a22.name) === "document";
      }).map((schemaType) => ({
        id: schemaType.name,
        schemaType: schemaType.name,
        title: schemaType.title || schemaType.name,
        icon: schemaType.icon,
        value: schemaType.initialValue || { _type: schemaType.name }
      }))
    });
  } catch (e) {
    throw new ConfigResolutionError({
      name: config.name,
      type: "source",
      causes: [e]
    });
  }
  let tools;
  try {
    tools = resolveConfigProperty({
      config,
      context,
      initialValue: [],
      propertyName: "tools",
      reducer: toolsReducer
    });
  } catch (e) {
    throw new ConfigResolutionError({
      name: config.name,
      type: "source",
      causes: [e]
    });
  }
  if (tools.some(({ name }) => name === "tool"))
    throw new Error('A tool cannot have the name "tool". Please enter a different name.');
  const initialTemplatesResponses = templates.filter((template2) => {
    var _a22;
    return !((_a22 = template2.parameters) != null && _a22.length);
  }).map(
    (template2) => ({
      templateId: template2.id,
      description: template2.description,
      icon: template2.icon,
      title: template2.title
    })
  ), templateMap = templates.reduce((acc, template2) => (acc.set(template2.id, template2), acc), /* @__PURE__ */ new Map()), resolveNewDocumentOptions = (creationContext) => {
    const { schemaType: schemaTypeName } = creationContext, templateResponses = resolveConfigProperty({
      config,
      context: { ...context, creationContext },
      initialValue: initialTemplatesResponses,
      propertyName: "document.resolveNewDocumentOptions",
      reducer: newDocumentOptionsResolver
    }), templateErrors = [];
    if (templateErrors.length)
      throw new ConfigResolutionError({
        name: config.name,
        type: "source",
        causes: templateErrors
      });
    return templateResponses.map((response, index) => {
      const template2 = templateMap.get(response.templateId);
      if (!template2)
        throw new Error(`Could not find template with ID \`${response.templateId}\``);
      const schemaType = schema2.get(template2.schemaType);
      if (!schemaType)
        throw new Error(
          `Could not find matching schema type \`${template2.schemaType}\` for template \`${template2.id}\``
        );
      const title = response.title || template2.title, defaultSubtitle = (schemaType == null ? void 0 : schemaType.title) === title || schemaType == null ? void 0 : schemaType.title;
      return {
        id: `${response.templateId}-${index}`,
        templateId: response.templateId,
        type: "initialValueTemplateItem",
        title,
        i18n: response.i18n || template2.i18n,
        subtitle: response.subtitle || defaultSubtitle,
        description: response.description || template2.description,
        icon: response.icon || template2.icon || (schemaType == null ? void 0 : schemaType.icon),
        initialDocumentId: response.initialDocumentId,
        parameters: response.parameters,
        schemaType: template2.schemaType
      };
    }).filter((item) => {
      var _a22;
      return !schemaTypeName || creationContext.type === "document" ? !0 : schemaTypeName === ((_a22 = templateMap.get(item.templateId)) == null ? void 0 : _a22.schemaType);
    });
  };
  let staticInitialValueTemplateItems;
  try {
    staticInitialValueTemplateItems = resolveNewDocumentOptions({ type: "global" });
  } catch (e) {
    errors.push(e);
  }
  if (errors.length)
    throw new ConfigResolutionError({
      name: config.name,
      type: "source",
      causes: errors
    });
  return {
    type: "source",
    name: config.name,
    title: config.title || startCase__default.default(config.name),
    schema: schema2,
    getClient,
    dataset,
    projectId,
    tools,
    currentUser,
    authenticated,
    templates,
    auth,
    i18n: i18n.source,
    // eslint-disable-next-line camelcase
    __internal_tasks: internalTasksReducer({
      config
    }),
    document: {
      actions: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialDocumentActions,
        propertyName: "document.actions",
        reducer: documentActionsReducer
      }),
      badges: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialDocumentBadges,
        propertyName: "document.badges",
        reducer: documentBadgesReducer
      }),
      unstable_fieldActions: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialDocumentFieldActions,
        propertyName: "document.unstable_fieldActions",
        reducer: documentFieldActionsReducer
      }),
      inspectors: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: EMPTY_ARRAY$t,
        propertyName: "document.inspectors",
        reducer: documentInspectorsReducer
      }),
      resolveProductionUrl: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: void 0,
        propertyName: "resolveProductionUrl",
        asyncReducer: resolveProductionUrlReducer
      }),
      resolveNewDocumentOptions,
      unstable_languageFilter: (partialContext) => resolveConfigProperty({
        config,
        context: { ...context, ...partialContext },
        initialValue: initialLanguageFilter,
        propertyName: "document.unstable_languageFilter",
        reducer: documentLanguageFilterReducer
      }),
      /** @todo this is deprecated so it will eventually be removed */
      unstable_comments: {
        enabled: (partialContext) => documentCommentsEnabledReducer({
          context: partialContext,
          config,
          initialValue: !0
        })
      },
      comments: {
        enabled: (partialContext) => documentCommentsEnabledReducer({
          context: partialContext,
          config,
          initialValue: !0
        })
      }
    },
    form: {
      file: {
        assetSources: resolveConfigProperty({
          config,
          context,
          initialValue: [FileSource],
          propertyName: "formBuilder.file.assetSources",
          reducer: fileAssetSourceResolver
        }),
        directUploads: (
          // TODO: consider refactoring this to `noDirectUploads` or similar
          // default value for this is `true`
          ((_b = (_a2 = config.form) == null ? void 0 : _a2.file) == null ? void 0 : _b.directUploads) === void 0 ? !0 : config.form.file.directUploads
        )
      },
      image: {
        assetSources: resolveConfigProperty({
          config,
          context,
          initialValue: [ImageSource],
          propertyName: "formBuilder.image.assetSources",
          reducer: imageAssetSourceResolver
        }),
        directUploads: (
          // TODO: consider refactoring this to `noDirectUploads` or similar
          // default value for this is `true`
          ((_d = (_c = config.form) == null ? void 0 : _c.image) == null ? void 0 : _d.directUploads) === void 0 ? !0 : config.form.image.directUploads
        )
      }
    },
    search: {
      filters: filterDefinitions,
      operators: operatorDefinitions,
      unstable_partialIndexing: {
        enabled: partialIndexingEnabledReducer({
          config,
          initialValue: (_g = (_f = (_e = config.search) == null ? void 0 : _e.unstable_partialIndexing) == null ? void 0 : _f.enabled) != null ? _g : !1
        })
      },
      enableLegacySearch: resolveConfigProperty({
        config,
        context,
        reducer: legacySearchEnabledReducer,
        propertyName: "enableLegacySearch",
        initialValue: !0
      })
      // we will use this when we add search config to PluginOptions
      /*filters: resolveConfigProperty({
        config,
        context: context,
        initialValue: filterDefinitions,
        propertyName: 'search.filters',
        reducer: searchFilterReducer,
      }),
      operators: resolveConfigProperty({
        config,
        context: context,
        initialValue: operatorDefinitions as SearchOperatorDefinition[],
        propertyName: 'search.operators',
        reducer: searchOperatorsReducer,
      }),*/
    },
    __internal: {
      bifur,
      i18next: i18n.i18next,
      staticInitialValueTemplateItems,
      options: config
    }
  };
}
function getRootPath(basePath) {
  const rootPath = basePath || "";
  if (typeof rootPath != "string" || rootPath.length > 0 && !rootPath.startsWith("/"))
    throw new ConfigResolutionError({
      name: "",
      type: "options",
      causes: ["basePath must be a string, and must start with a slash"]
    });
  return rootPath === "/" ? "" : rootPath;
}
function joinBasePath(rootPath, basePath) {
  return `/${[rootPath, basePath || ""].map((path) => path.replace(/^\/+/g, "").replace(/\/+$/g, "")).filter(Boolean).join("/")}`;
}
function resolveConfig(config) {
  const { workspaces } = prepareConfig(config);
  return rxjs.combineLatest(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    workspaces.flatMap(
      (workspaceSummary) => rxjs.combineLatest(workspaceSummary.__internal.sources.map(({ source }) => source)).pipe(
        operators.map(
          (sources) => ({
            ...workspaceSummary,
            ...sources[0],
            unstable_sources: sources,
            type: "workspace"
          })
        )
      )
    )
  );
}
async function createWorkspaceFromConfig(options) {
  const client2 = "getClient" in options ? options.getClient({ apiVersion: "2023-11-13" }) : void 0, [workspace] = await rxjs.firstValueFrom(
    resolveConfig({
      ...options,
      ...client2 && "currentUser" in options && {
        auth: createMockAuthStore({ ...options, client: client2 })
      }
    })
  );
  return workspace;
}
async function createSourceFromConfig(options) {
  return (await createWorkspaceFromConfig(options)).unstable_sources[0];
}
function useConfigContextFromSource(source) {
  const { projectId, dataset, schema: schema2, currentUser, getClient, i18n } = source;
  return React.useMemo(() => ({ projectId, dataset, schema: schema2, currentUser, getClient, i18n }), [projectId, dataset, schema2, currentUser, getClient, i18n]);
}
function getConfigContextFromSource(source) {
  const { projectId, dataset, schema: schema2, currentUser, getClient, i18n } = source;
  return { projectId, dataset, schema: schema2, currentUser, getClient, i18n };
}
function WorkspacesProvider({ config, children, basePath }) {
  const { workspaces } = React.useMemo(() => prepareConfig(config, { basePath }), [config, basePath]);
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.WorkspacesContext.Provider, { value: workspaces, children });
}
function RouterHistoryProvider({
  children,
  history: history2
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.RouterHistoryContext.Provider, { value: history2, children });
}
function useRouterHistory() {
  const value = React.useContext(_singletons.RouterHistoryContext);
  if (!value) throw new Error("Could not find `RouterHistoryProvider` context");
  return value;
}
const ActiveWorkspaceMatcherProvider = React.memo(function({
  children,
  history: history2,
  activeWorkspace,
  setActiveWorkspace
}) {
  const value = React.useMemo(
    () => ({
      activeWorkspace,
      setActiveWorkspace
    }),
    [activeWorkspace, setActiveWorkspace]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ActiveWorkspaceMatcherContext.Provider, { value, children: /* @__PURE__ */ jsxRuntime.jsx(RouterHistoryProvider, { history: history2, children }) });
});
function createCommonBasePathRegex(workspaces) {
  const commonBasePath = workspaces.map(
    (workspace) => (
      // gets the segments from the basePath
      workspace.basePath.slice(1).split("/")
    )
  ).reduce((commonSegments, segments) => {
    for (let i = 0; i < commonSegments.length; i++) {
      const commonSegment = commonSegments[i], segment = segments[i].toLowerCase();
      if (commonSegment !== segment)
        return commonSegments.slice(0, i);
    }
    return commonSegments;
  });
  function createCommonBasePathRegexRecursively([first, ...rest]) {
    return first ? `(\\/${escapeRegExp__default.default(first)}${createCommonBasePathRegexRecursively(rest)}(\\/|$))?` : "";
  }
  return new RegExp(`^${createCommonBasePathRegexRecursively(commonBasePath)}$`, "i");
}
function matchWorkspace({
  pathname,
  workspaces,
  basePathRegex
}) {
  const [firstWorkspace] = workspaces;
  for (const { workspace, basePath, basePathRegex: basePathRegex2 } of workspaces)
    if (basePathRegex2.test(pathname) || basePath === "/")
      return { type: "match", workspace };
  return pathname === "/" ? { type: "redirect", pathname: firstWorkspace.basePath } : basePathRegex.test(pathname) ? { type: "redirect", pathname: firstWorkspace.basePath } : { type: "not-found" };
}
function useNormalizedWorkspaces(workspaces) {
  return React.useMemo(
    () => normalizedWorkspaces(workspaces),
    [workspaces]
  );
}
function normalizedWorkspaces(workspaces) {
  return workspaces.map((workspace) => {
    const basePath = workspace.basePath || "/";
    return {
      workspace,
      name: workspace.name,
      basePath,
      // this regex ends with a `(\\/|$)` (forward slash or end) to prevent false
      // matches where the pathname is a false subset of the current pathname.
      // e.g. if the `workspace.basePath` is `/base/foobar` and the current
      // pathname is `/base/foo`, then that should not be a match
      basePathRegex: new RegExp(`^${escapeRegExp__default.default(basePath)}(\\/|$)`, "i")
    };
  });
}
function useSyncPathnameWithWorkspace(history2, _workspaces) {
  const workspaces = useNormalizedWorkspaces(_workspaces), basePathRegex = React.useMemo(() => createCommonBasePathRegex(workspaces), [workspaces]), [serverSnapshot] = React.useState(() => history2.location.pathname), store = React.useMemo(() => ({
    subscribe: (onStoreChange) => history2.listen(onStoreChange),
    getSnapshot: () => history2.location.pathname,
    getServerSnapshot: () => serverSnapshot,
    selector: (pathname) => matchWorkspace({ basePathRegex, pathname, workspaces }),
    isEqual: (a, b) => {
      if (a.type !== b.type) return !1;
      switch (a.type) {
        case "match":
          return a.workspace === b.workspace;
        case "redirect":
          return a.pathname === b.pathname;
        case "not-found":
          return !0;
        default:
          throw new Error(`Unknown type: ${a.type}`);
      }
    }
  }), [basePathRegex, history2, serverSnapshot, workspaces]);
  return withSelector_js.useSyncExternalStoreWithSelector(
    store.subscribe,
    store.getSnapshot,
    store.getServerSnapshot,
    store.selector,
    store.isEqual
  );
}
const createHistory = () => typeof document > "u" ? history$1.createMemoryHistory() : history$1.createBrowserHistory();
function ActiveWorkspaceMatcher({
  children,
  LoadingComponent,
  NotFoundComponent,
  unstable_history: historyProp
}) {
  const workspaces = useWorkspaces(), history2 = React.useMemo(() => historyProp || createHistory(), [historyProp]), setActiveWorkspaceName = React.useCallback(
    (workspaceName) => {
      const foundWorkspace = workspaces.find((workspace) => workspace.name === workspaceName);
      foundWorkspace && history2.push(foundWorkspace.basePath);
    },
    [history2, workspaces]
  ), handleNavigateToDefaultWorkspace = React.useCallback(() => {
    setActiveWorkspaceName(workspaces[0].name);
  }, [setActiveWorkspaceName, workspaces]), result = useSyncPathnameWithWorkspace(history2, workspaces);
  switch (React.useEffect(() => {
    result.type === "redirect" && history2.replace(result.pathname);
  }, [history2, result]), result.type) {
    case "match":
      return /* @__PURE__ */ jsxRuntime.jsx(
        ActiveWorkspaceMatcherProvider,
        {
          activeWorkspace: result.workspace,
          history: history2,
          setActiveWorkspace: setActiveWorkspaceName,
          children
        }
      );
    case "redirect":
      return /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {});
    case "not-found":
      return /* @__PURE__ */ jsxRuntime.jsx(NotFoundComponent, { onNavigateToDefaultWorkspace: handleNavigateToDefaultWorkspace });
    default:
      throw new Error(`Unknown type: ${result.type}`);
  }
}
function useActiveWorkspace() {
  const value = React.useContext(_singletons.ActiveWorkspaceMatcherContext);
  if (!value) throw new Error("Could not find `ActiveWorkspaceMatcher` context");
  return value;
}
const API_VERSION = "v2023-11-13";
function AddonDatasetProvider(props2) {
  const { children } = props2, { dataset, projectId } = useWorkspace(), originalClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), [addonDatasetClient, setAddonDatasetClient] = React.useState(null), [isCreatingDataset, setIsCreatingDataset] = React.useState(!1), [ready, setReady] = React.useState(!1), getAddonDatasetName = React.useCallback(async () => {
    var _a2;
    const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({
      uri: `/projects/${projectId}/datasets?datasetProfile=comments&addonFor=${dataset}`,
      tag: "sanity.studio"
    });
    return (_a2 = res == null ? void 0 : res[0]) == null ? void 0 : _a2.name;
  }, [dataset, originalClient, projectId]), handleCreateClient = React.useCallback(
    (addonDatasetName) => originalClient.withConfig({
      apiVersion: API_VERSION,
      dataset: addonDatasetName,
      projectId,
      requestTagPrefix: "sanity.studio",
      useCdn: !1,
      withCredentials: !0
    }),
    [originalClient, projectId]
  ), handleCreateAddonDataset = React.useCallback(async () => {
    setIsCreatingDataset(!0);
    try {
      const addonDatasetName = await getAddonDatasetName();
      if (addonDatasetName) {
        const client2 = handleCreateClient(addonDatasetName);
        return setAddonDatasetClient(client2), setIsCreatingDataset(!1), client2;
      }
    } catch {
    }
    try {
      const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({
        uri: `/comments/${dataset}/setup`,
        method: "POST"
      }), datasetName = res == null ? void 0 : res.datasetName;
      if (!datasetName)
        return setIsCreatingDataset(!1), null;
      const client2 = handleCreateClient(datasetName);
      return setAddonDatasetClient(client2), client2;
    } catch (err) {
      throw err;
    } finally {
      setIsCreatingDataset(!1);
    }
  }, [dataset, getAddonDatasetName, handleCreateClient, originalClient]);
  React.useEffect(() => {
    getAddonDatasetName().then((addonDatasetName) => {
      if (!addonDatasetName) return;
      const client2 = handleCreateClient(addonDatasetName);
      setAddonDatasetClient(client2);
    }).finally(() => {
      setReady(!0);
    });
  }, [getAddonDatasetName, handleCreateClient]);
  const ctxValue = React.useMemo(
    () => ({
      client: addonDatasetClient,
      createAddonDataset: handleCreateAddonDataset,
      isCreatingDataset,
      ready
    }),
    [addonDatasetClient, handleCreateAddonDataset, isCreatingDataset, ready]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.AddonDatasetContext.Provider, { value: ctxValue, children });
}
function useAddonDataset() {
  const ctx = React.useContext(_singletons.AddonDatasetContext);
  if (!ctx)
    throw new Error("useAddonDataset: missing context value");
  return ctx;
}
function useSystemScheme() {
  return ui.usePrefersDark() ? "dark" : "light";
}
function ColorThemeProvider({
  children,
  scheme: _scheme
}) {
  const systemScheme = useSystemScheme();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeProvider, { scheme: _scheme === "system" ? systemScheme : _scheme, theme: ui.studioTheme, children });
}
const LOCAL_STORAGE_KEY = "sanityStudio:ui:colorScheme";
function ColorSchemeProvider({
  children,
  onSchemeChange,
  scheme: schemeProp
}) {
  return schemeProp ? /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeCustomProvider, { scheme: schemeProp, onSchemeChange, children }) : /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeLocalStorageProvider, { onSchemeChange, children });
}
function ColorSchemeLocalStorageProvider({
  children,
  onSchemeChange
}) {
  const store = React.useMemo(() => {
    let snapshot;
    const subscribers = /* @__PURE__ */ new Set();
    return {
      subscribe: (onStoreChange) => (snapshot || (snapshot = getScheme(localStorage.getItem(LOCAL_STORAGE_KEY)) || "system"), subscribers.add(onStoreChange), () => {
        subscribers.delete(onStoreChange);
      }),
      getSnapshot: () => snapshot,
      setSnapshot: (nextScheme) => {
        snapshot = getScheme(nextScheme);
        for (const subscription of subscribers)
          subscription();
      },
      // Only called during server-side rendering, and hydration if using hydrateRoot
      // https://beta.reactjs.org/apis/react/useSyncExternalStore#adding-support-for-server-rendering
      getServerSnapshot: () => "system"
    };
  }, []), scheme = React.useSyncExternalStore(store.subscribe, store.getSnapshot, store.getServerSnapshot);
  return React.useEffect(() => {
    typeof onSchemeChange == "function" && onSchemeChange(scheme), localStorage.setItem(LOCAL_STORAGE_KEY, scheme);
  }, [onSchemeChange, scheme]), /* @__PURE__ */ jsxRuntime.jsx(_singletons.ColorSchemeSetValueContext.Provider, { value: store.setSnapshot, children: /* @__PURE__ */ jsxRuntime.jsx(_singletons.ColorSchemeValueContext.Provider, { value: scheme, children: /* @__PURE__ */ jsxRuntime.jsx(ColorThemeProvider, { scheme, children }) }) });
}
function getScheme(scheme) {
  switch (scheme) {
    case "dark":
    case "light":
      return scheme;
    default:
      return "system";
  }
}
function ColorSchemeCustomProvider({
  children,
  onSchemeChange,
  scheme
}) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    _singletons.ColorSchemeSetValueContext.Provider,
    {
      value: typeof onSchemeChange == "function" ? onSchemeChange : !1,
      children: /* @__PURE__ */ jsxRuntime.jsx(_singletons.ColorSchemeValueContext.Provider, { value: scheme, children: /* @__PURE__ */ jsxRuntime.jsx(ColorThemeProvider, { scheme, children }) })
    }
  );
}
function useColorSchemeSetValue() {
  const setValue = React.useContext(_singletons.ColorSchemeSetValueContext);
  if (setValue === null) throw new Error("Could not find `ColorSchemeSetValueContext` context");
  return setValue;
}
function _useColorSchemeInternalValue() {
  const value = React.useContext(_singletons.ColorSchemeValueContext);
  if (value === null) throw new Error("Could not find `ColorSchemeValueContext` context");
  return value;
}
function useColorSchemeValue() {
  const scheme = _useColorSchemeInternalValue(), systemScheme = useSystemScheme();
  return scheme === "system" ? systemScheme : scheme;
}
function useColorScheme() {
  const scheme = useColorSchemeValue(), setScheme = useColorSchemeSetValue();
  return React.useMemo(() => ({ scheme, setScheme }), [scheme, setScheme]);
}
function useColorSchemeOptions(setScheme, t2) {
  const scheme = _useColorSchemeInternalValue();
  return React.useMemo(() => [
    {
      title: t2("user-menu.color-scheme.system-title"),
      name: "system",
      label: t2("user-menu.color-scheme.system-description"),
      selected: scheme === "system",
      onSelect: () => setScheme("system"),
      icon: icons.DesktopIcon
    },
    {
      title: t2("user-menu.color-scheme.dark-title"),
      name: "dark",
      label: t2("user-menu.color-scheme.dark-description"),
      selected: scheme === "dark",
      onSelect: () => setScheme("dark"),
      icon: icons.MoonIcon
    },
    {
      title: t2("user-menu.color-scheme.light-title"),
      name: "light",
      label: t2("user-menu.color-scheme.light-description"),
      selected: scheme === "light",
      onSelect: () => setScheme("light"),
      icon: icons.SunIcon
    }
  ], [scheme, setScheme, t2]);
}
function createOperatorDefinitionDictionary(operatorDefinitions2) {
  return operatorDefinitions2.reduce((acc, val) => (acc[val.type] = val, acc), {});
}
function getOperatorDefinition(operators2, operatorType) {
  return operatorType ? operators2[operatorType] : void 0;
}
function getOperatorInitialValue(operators2, operatorType) {
  var _a2;
  return (_a2 = getOperatorDefinition(operators2, operatorType)) == null ? void 0 : _a2.initialValue;
}
function buildSearchFilter(filterDefinition, fieldId) {
  var _a2;
  return {
    fieldId,
    filterName: filterDefinition.name,
    operatorType: ((_a2 = filterDefinition == null ? void 0 : filterDefinition.operators.find((operator) => operator.type === "item")) == null ? void 0 : _a2.name) || ""
  };
}
function generateFilterQuery({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  filters,
  operatorDefinitions: operatorDefinitions2
}) {
  return filters.filter(
    (filter) => validateFilter({
      filter,
      filterDefinitions: filterDefinitions2,
      fieldDefinitions,
      operatorDefinitions: operatorDefinitions2
    })
  ).map((filter) => {
    var _a2;
    return (_a2 = getOperatorDefinition(operatorDefinitions2, filter.operatorType)) == null ? void 0 : _a2.groqFilter({
      fieldPath: resolveFieldPath({ filter, fieldDefinitions, filterDefinitions: filterDefinitions2 }),
      value: filter == null ? void 0 : filter.value
    });
  }).filter((filter) => !isEmpty__default.default(filter)).filter(isNonNullable$3).join(" && ");
}
function getFieldFromFilter(fields, filter) {
  return filter != null && filter.fieldId ? fields[filter.fieldId] : void 0;
}
function getFilterKey(filter) {
  return [filter.filterName, ...filter.fieldId ? [filter.fieldId] : []].join("-");
}
function narrowDocumentTypes({
  fieldDefinitions,
  filters,
  types: types2
}) {
  const selectedDocumentTypes = types2.map((type) => type.name), filteredDocumentTypes = Object.values(fieldDefinitions).filter((field) => filters.map((filter) => filter == null ? void 0 : filter.fieldId).includes(field.id)).filter((field) => field.documentTypes.length > 0).map((field) => field.documentTypes), intersectingDocumentTypes = intersection__default.default(...filteredDocumentTypes), documentTypes = [];
  return selectedDocumentTypes.length > 0 && documentTypes.push(selectedDocumentTypes), intersectingDocumentTypes.length > 0 && documentTypes.push(intersectingDocumentTypes), intersection__default.default(...documentTypes).sort();
}
function resolveFieldPath({
  filter,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2
}) {
  const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter), filterDefinition = getFilterDefinition(filterDefinitions2, filter.filterName);
  if (filterDefinition)
    switch (filterDefinition.type) {
      case "field":
        return fieldDefinition == null ? void 0 : fieldDefinition.fieldPath;
      case "pinned":
        return filterDefinition == null ? void 0 : filterDefinition.fieldPath;
      default:
        return;
    }
}
function validateFilter({
  filter,
  filterDefinitions: filterDefinitions2,
  fieldDefinitions,
  operatorDefinitions: operatorDefinitions2
}) {
  const filterDef = getFilterDefinition(filterDefinitions2, filter.filterName), operatorDef = getOperatorDefinition(operatorDefinitions2, filter.operatorType), fieldDef = getFieldFromFilter(fieldDefinitions, filter);
  return !(!filterDef || !operatorDef || filter.fieldId && !fieldDef || filterDef.type === "field" && (!(fieldDef != null && fieldDef.fieldPath) || !filter.fieldId || !operatorDef.groqFilter({
    fieldPath: fieldDef.fieldPath,
    value: filter.value
  })) || filterDef.type === "pinned" && !operatorDef.groqFilter({
    fieldPath: filterDef.fieldPath,
    value: filter.value
  }));
}
const isEscape$1 = isHotkeyEsm.isHotkey("escape"), MAX_HEIGHT = 500, HiddenOverlay = styledComponents.styled.div`
  background: transparent;
  height: 100%;
  left: 0;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: -1;
`;
function FilterPopoverWrapper({
  anchorElement,
  children,
  onClose
}) {
  const { isTopLayer } = ui.useLayer(), handleGlobalKeyDown = React.useCallback(
    (event) => {
      isEscape$1(event) && isTopLayer && onClose();
    },
    [isTopLayer, onClose]
  );
  ui.useGlobalKeyDown(handleGlobalKeyDown);
  const popoverOffset = usePopoverOffset(anchorElement || null);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(HiddenOverlay, { onClick: onClose }),
    /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !1, returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        display: "flex",
        overflow: "hidden",
        radius: POPOVER_RADIUS,
        style: {
          maxHeight: `min(calc(100vh - ${popoverOffset}px - ${POPOVER_VERTICAL_MARGIN}px - ${POPOVER_INPUT_PADDING}px), ${MAX_HEIGHT}px`,
          zIndex: 1
        },
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children })
      }
    ) })
  ] });
}
function calcPopoverOffset(element) {
  const rect = element.getBoundingClientRect();
  return rect.y + rect.height + POPOVER_VERTICAL_MARGIN;
}
function usePopoverOffset(element) {
  const [offset, setOffset] = React.useState(element && calcPopoverOffset(element)), handleWindowResize = React.useCallback(() => {
    element && setOffset(calcPopoverOffset(element));
  }, [element]);
  return React.useEffect(() => {
    element && setOffset(calcPopoverOffset(element));
  }, [element]), React.useEffect(() => (window.addEventListener("resize", handleWindowResize), () => window.removeEventListener("resize", handleWindowResize)), [handleWindowResize]), offset;
}
const SearchHeaderBox = styledComponents.styled(ui.Box)`
  border-bottom: 1px solid ${({ theme: theme2 }) => theme2.sanity.color.base.border};
  flex-shrink: 0;
`, SearchHeaderContentFlex = styledComponents.styled(ui.Flex)`
  box-sizing: border-box;
`, FilterPopoverContentHeader = React.forwardRef(function({ ariaInputLabel, onChange, onClear, typeFilter }, ref) {
  const {
    state: { fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(SearchHeaderBox, { children: /* @__PURE__ */ jsxRuntime.jsx(SearchHeaderContentFlex, { align: "center", flex: 1, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
    CustomTextInput,
    {
      __unstable_disableFocusRing: !0,
      $smallClearButton: !0,
      "aria-label": ariaInputLabel,
      autoComplete: "off",
      border: !1,
      clearButton: !!typeFilter,
      fontSize: fullscreen ? 2 : 1,
      icon: icons.SearchIcon,
      muted: !0,
      onChange,
      onClear,
      placeholder: t2("search.filter-placeholder"),
      ref,
      spellCheck: !1,
      radius: 2,
      value: typeFilter
    }
  ) }) });
});
function createFilterMenuItems({
  documentTypesNarrowed,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  schema: schema2,
  titleFilter,
  types: types2,
  t: t2
}) {
  const fieldFilters = Object.values(fieldDefinitions).filter((fieldDef) => includesTitleInFieldDefinition(fieldDef, titleFilter)).map((fieldDef) => {
    const filterDef = getFilterDefinition(filterDefinitions2, fieldDef.filterName);
    return filterDef ? buildSearchFilter(filterDef, fieldDef.id) : null;
  }).filter(isNonNullable$3), pinnedItems = buildPinnedMenuItems({
    fieldDefinitions,
    filterDefinitions: filterDefinitions2,
    titleFilter
  });
  return documentTypesNarrowed.length === 0 ? [
    ...pinnedItems,
    // All fields
    ...filterGroup({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: fieldFilters,
      headerTitle: t2("search.filter-all-fields-header"),
      id: "field"
    })
  ] : [
    ...pinnedItems,
    // All shared / narrowed items
    ...buildFieldMenuItemsNarrowed({
      documentTypesNarrowed,
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: fieldFilters,
      schema: schema2,
      types: types2,
      t: t2
    })
  ];
}
function filterGroup({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  filters,
  id: id2,
  headerTitle,
  tone
}) {
  const header = {
    title: headerTitle || "",
    tone: tone || "default",
    type: "header"
  }, filterItems = filters.map(
    (filter) => ({
      fieldDefinition: getFieldFromFilter(fieldDefinitions, filter),
      filterDefinition: getFilterDefinition(filterDefinitions2, filter.filterName),
      filter,
      group: id2,
      tone: tone || "default",
      type: "filter"
    })
  );
  return filterItems.length > 0 ? [
    ...headerTitle ? [header] : [],
    //
    ...filterItems
  ] : [];
}
function buildFieldMenuItemsNarrowed({
  documentTypesNarrowed,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  filters,
  schema: schema2,
  types: types2,
  t: t2
}) {
  const sharedFilters = filters.filter((filter) => {
    const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter);
    return sharesDocumentTypes(documentTypesNarrowed, fieldDefinition);
  }), sharedItems = documentTypesNarrowed.length > 1 && types2.length > 1 ? filterGroup({
    fieldDefinitions,
    filterDefinitions: filterDefinitions2,
    filters: sharedFilters,
    headerTitle: t2("search.filter-shared-fields-header"),
    id: "shared",
    tone: "primary"
  }) : [], groupedItems = documentTypesNarrowed.map((documentType) => {
    const docType = schema2.get(documentType);
    return {
      // Note: it shouldn't be possible to select document types that do not exist in schema,
      // and there is no way to inject it into state (eg not persisted in URL), thus we leave
      // this fallback (`Unknown type`) only as a edge-case safety net and will not translate it.
      title: (docType == null ? void 0 : docType.title) || startCase__default.default(docType == null ? void 0 : docType.name) || "(Unknown type)",
      documentType
    };
  }).sort((a, b) => a.title.localeCompare(b.title)).map(({ documentType, title }) => {
    const groupFilters = filters.filter((filter) => {
      const fieldDefinition = getFieldFromFilter(fieldDefinitions, filter);
      return includesDocumentTypes([documentType], fieldDefinition);
    });
    return filterGroup({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: groupFilters,
      id: title,
      headerTitle: title
    });
  }).flat();
  return [...sharedItems, ...groupedItems];
}
function buildPinnedMenuItems({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  titleFilter
}) {
  const ungroupedPinnedFilters = Object.values(filterDefinitions2).filter(isPinnedFilterDefWithoutGroup).filter((filterDef) => includesTitleInPinnedFilterDefinition(filterDef, titleFilter)).map((filterDef) => buildSearchFilter(filterDef)), groupedPinnedFilters = Object.values(filterDefinitions2).filter(isPinnedFilterDefWithGroup).filter((filterDef) => includesTitleInPinnedFilterDefinition(filterDef, titleFilter)).reduce((acc, val) => (acc[val.group] = acc[val.group] || [], acc[val.group].push(buildSearchFilter(val)), acc), {});
  return [
    // Ungrouped
    ...filterGroup({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      filters: ungroupedPinnedFilters,
      id: "pinned-ungrouped",
      tone: "primary"
    }),
    // Grouped
    ...Object.entries(groupedPinnedFilters).flatMap(
      ([groupTitle, filters]) => filterGroup({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        filters,
        headerTitle: groupTitle,
        id: groupTitle,
        tone: "primary"
      })
    )
  ];
}
function includesDocumentTypes(documentTypes, fieldDefinition) {
  return fieldDefinition == null ? void 0 : fieldDefinition.documentTypes.some((type) => documentTypes.includes(type));
}
function includesTitleInFieldDefinition(field, currentTitle) {
  return field.titlePath.join("/").toLowerCase().includes(currentTitle.toLowerCase());
}
function includesTitleInPinnedFilterDefinition(filter, currentTitle) {
  return filter.title.toLowerCase().includes(currentTitle.toLowerCase());
}
function isPinnedFilterDefWithGroup(filterDef) {
  return filterDef.type === "pinned" && typeof (filterDef == null ? void 0 : filterDef.group) < "u";
}
function isPinnedFilterDefWithoutGroup(filterDef) {
  return filterDef.type === "pinned" && typeof (filterDef == null ? void 0 : filterDef.group) > "u";
}
function sharesDocumentTypes(documentTypes, fieldDefinition) {
  return difference__default.default(documentTypes, (fieldDefinition == null ? void 0 : fieldDefinition.documentTypes) || []).length === 0;
}
function FilterTitle({ filter, maxLength }) {
  const {
    state: { definitions }
  } = useSearchState(), title = React.useMemo(() => {
    const filterDef = getFilterDefinition(definitions.filters, filter.filterName);
    switch (filterDef == null ? void 0 : filterDef.type) {
      case "field": {
        const fieldDefinition = getFieldFromFilter(definitions.fields, filter);
        return fieldDefinition != null && fieldDefinition.titlePath ? fieldDefinition.titlePath[fieldDefinition.titlePath.length - 1] : null;
      }
      case "pinned":
        return filterDef.title;
      default:
        return null;
    }
  }, [definitions, filter]);
  return title ? maxLength && title.length > maxLength ? /* @__PURE__ */ jsxRuntime.jsxs("span", { children: [
    title.slice(0, maxLength),
    "\u2026"
  ] }) : /* @__PURE__ */ jsxRuntime.jsx("span", { children: title }) : null;
}
function FilterIcon({ filter }) {
  var _a2;
  const {
    state: { definitions }
  } = useSearchState(), icon = (_a2 = getFilterDefinition(definitions.filters, filter.filterName)) == null ? void 0 : _a2.icon;
  return icon ? React.createElement(icon) : /* @__PURE__ */ jsxRuntime.jsx(icons.UnknownIcon, {});
}
function FilterDetails({ filter }) {
  var _a2;
  const {
    state: { definitions }
  } = useSearchState(), fieldDefinition = getFieldFromFilter(definitions.fields, filter);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    (fieldDefinition == null ? void 0 : fieldDefinition.titlePath) && ((_a2 = fieldDefinition.titlePath) == null ? void 0 : _a2.length) > 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 0, children: fieldDefinition.titlePath.slice(0, -1).map((pathTitle, index) => /* @__PURE__ */ jsxRuntime.jsxs(
      React.Fragment,
      {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx("span", { children: pathTitle }),
          index !== fieldDefinition.titlePath.length - 2 && /* @__PURE__ */ jsxRuntime.jsx(
            "span",
            {
              style: {
                opacity: 0.75,
                paddingLeft: "0.25em",
                paddingRight: "0.25em"
              },
              children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {})
            }
          )
        ]
      },
      index
    )) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { flexShrink: 0 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(FilterIcon, { filter }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(FilterTitle, { filter }) })
    ] })
  ] });
}
function sanitizeFieldValue(name) {
  return React.isValidElement(name) ? stripHtmlTags(server.renderToString(name)) : typeof name == "string" ? name : "";
}
function stripHtmlTags(str) {
  var _a2;
  return ((_a2 = new DOMParser().parseFromString(str, "text/html")) == null ? void 0 : _a2.body.textContent) || "";
}
const MAX_VISIBLE_TYPES = 10;
function FilterTooltip({
  children,
  fieldDefinition,
  filterDefinition,
  visible
}) {
  const {
    state: { documentTypesNarrowed }
  } = useSearchState(), { t: t2 } = useTranslation(), schema2 = useSchema(), fieldDefinitionDocumentTypeTitles = React.useMemo(() => fieldDefinition != null && fieldDefinition.documentTypes ? fieldDefinition.documentTypes.map((d) => {
    const defType = schema2.get(d);
    return (defType == null ? void 0 : defType.title) || startCase__default.default(defType == null ? void 0 : defType.name);
  }).filter(isNonNullable$3).sort() : [], [fieldDefinition == null ? void 0 : fieldDefinition.documentTypes, schema2]), fieldDefinitionDescription = React.useMemo(() => {
    if (fieldDefinition != null && fieldDefinition.documentTypes) {
      const descriptions = fieldDefinition.documentTypes.map((d) => {
        const defType = schema2.get(d);
        if (defType) {
          const field = getSchemaField$1(defType, fieldDefinition.fieldPath);
          return (field == null ? void 0 : field.type.description) && sanitizeFieldValue(field == null ? void 0 : field.type.description);
        }
        return null;
      }).filter(isNonNullable$3).sort(), uniqueDescriptions = uniq__default.default(descriptions);
      if (uniqueDescriptions.length === 1)
        return uniqueDescriptions[0];
    }
  }, [fieldDefinition == null ? void 0 : fieldDefinition.documentTypes, fieldDefinition == null ? void 0 : fieldDefinition.fieldPath, schema2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "default", radius: 2, style: { maxWidth: "250px" }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        fieldDefinition && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.filter-field-tooltip-name") }),
          /* @__PURE__ */ jsxRuntime.jsx(
            TextWithTone,
            {
              size: 1,
              style: { fontFamily: "monospace" },
              tone: "primary",
              textOverflow: "ellipsis",
              children: fieldDefinition == null ? void 0 : fieldDefinition.name
            }
          )
        ] }),
        fieldDefinitionDescription && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.filter-field-tooltip-description") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: truncateString(fieldDefinitionDescription, 256) })
        ] }),
        (filterDefinition == null ? void 0 : filterDefinition.description) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: truncateString(filterDefinition.description, 256) }),
        !documentTypesNarrowed.length && fieldDefinitionDocumentTypeTitles.length > 0 && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.filter-field-tooltip-used-in-document-types") }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: fieldDefinitionDocumentTypeTitles.length }) })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "regular", muted: !0, children: [
            fieldDefinitionDocumentTypeTitles.slice(0, MAX_VISIBLE_TYPES).join(", "),
            (fieldDefinitionDocumentTypeTitles == null ? void 0 : fieldDefinitionDocumentTypeTitles.length) > MAX_VISIBLE_TYPES ? ` +${fieldDefinitionDocumentTypeTitles.length - MAX_VISIBLE_TYPES} more` : ""
          ] })
        ] })
      ] }) }),
      disabled: !visible,
      fallbackPlacements: ["left"],
      placement: "right",
      portal: !0,
      children
    }
  );
}
const MenuItemFilter = React.memo(function({
  item,
  onClose,
  ...rest
}) {
  const {
    dispatch,
    state: { filters }
  } = useSearchState(), handleClick = React.useCallback(() => {
    dispatch({ filter: item.filter, type: "TERMS_FILTERS_ADD" }), onClose == null || onClose();
  }, [dispatch, item.filter, onClose]), isAlreadyActive = !!filters.find((f) => getFilterKey(f) === getFilterKey(item.filter)), tooltipEnabled = !!(item.fieldDefinition || item.filterDefinition.description);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      disabled: isAlreadyActive,
      fontSize: 1,
      justify: "flex-start",
      mode: "bleed",
      onClick: isAlreadyActive ? void 0 : handleClick,
      padding: 0,
      style: { position: "relative", whiteSpace: "normal", width: "100%" },
      tabIndex: -1,
      tone: item == null ? void 0 : item.tone,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        FilterTooltip,
        {
          fieldDefinition: item.fieldDefinition,
          filterDefinition: item.filterDefinition,
          visible: tooltipEnabled,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(FilterDetails, { filter: item.filter }) })
        }
      )
    }
  ) });
}), MenuItemHeader = React.memo(function({ item }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, paddingX: 2, paddingY: 3, tone: item == null ? void 0 : item.tone, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", weight: "medium", children: item.title }) }) });
}), POPOVER_STYLES$1 = { width: "300px" };
function AddFilterPopoverContent({ onClose }) {
  const [inputElement, setInputElement] = React.useState(null), [titleFilter, setTitleFilter] = React.useState(""), { t: t2 } = useTranslation(), handleFilterChange = React.useCallback(
    (e) => setTitleFilter(e.currentTarget.value),
    [setTitleFilter]
  ), handleFilterClear = React.useCallback(() => setTitleFilter(""), []), schema2 = useSchema(), {
    state: {
      documentTypesNarrowed,
      definitions,
      filters,
      terms: { types: types2 }
    }
  } = useSearchState(), filteredMenuItems = React.useMemo(
    () => createFilterMenuItems({
      documentTypesNarrowed,
      fieldDefinitions: definitions.fields,
      filterDefinitions: definitions.filters,
      schema: schema2,
      titleFilter,
      types: types2,
      t: t2
    }),
    [documentTypesNarrowed, definitions.fields, definitions.filters, schema2, titleFilter, types2, t2]
  ), renderItem2 = React.useCallback(
    (item) => item.type === "filter" ? /* @__PURE__ */ jsxRuntime.jsx(MenuItemFilter, { item, onClose, paddingBottom: 1 }) : item.type === "header" ? /* @__PURE__ */ jsxRuntime.jsx(MenuItemHeader, { item }) : null,
    [onClose]
  ), getItemDisabled = React.useCallback(
    (index) => {
      const filterItem = filteredMenuItems[index];
      return filterItem.type !== "filter" || !!filters.find((f) => getFilterKey(f) === getFilterKey(filterItem.filter));
    },
    [filteredMenuItems, filters]
  ), getItemKey2 = React.useCallback(
    (index) => {
      const menuItem = filteredMenuItems[index];
      switch (menuItem.type) {
        case "filter":
          return [
            ...menuItem.group ? [menuItem.group] : [],
            //
            getFilterKey(menuItem.filter)
          ].join("-");
        case "header":
          return `${menuItem.type}-${menuItem.title}`;
        default:
          return index;
      }
    },
    [filteredMenuItems]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", style: POPOVER_STYLES$1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      FilterPopoverContentHeader,
      {
        ariaInputLabel: t2("search.filter-by-title-aria-label"),
        onChange: handleFilterChange,
        onClear: handleFilterClear,
        ref: setInputElement,
        typeFilter: titleFilter
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
      filteredMenuItems.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
        CommandList,
        {
          activeItemDataAttr: "data-hovered",
          ariaLabel: t2("search.filters-aria-label", { count: filteredMenuItems.length }),
          autoFocus: "input",
          getItemDisabled,
          getItemKey: getItemKey2,
          inputElement,
          itemHeight: 45,
          items: filteredMenuItems,
          overscan: 20,
          padding: 1,
          paddingBottom: 0,
          renderItem: renderItem2
        }
      ),
      filteredMenuItems.length == 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: t2("search.filter-no-matches-found", { filter: titleFilter }) }) })
    ] })
  ] });
}
function AddFilterButton() {
  const [open, setOpen] = React.useState(!1), [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), { t: t2 } = useTranslation(), {
    state: { fullscreen }
  } = useSearchState(), handleClose = React.useCallback(() => setOpen(!1), []), handleOpen = React.useCallback(() => setOpen(!0), []);
  return ui.useClickOutside(handleClose, [buttonElement, popoverElement]), /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0],
      content: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: /* @__PURE__ */ jsxRuntime.jsx(AddFilterPopoverContent, { onClose: handleClose }) }),
      open,
      placement: "bottom-start",
      radius: POPOVER_RADIUS,
      ref: setPopoverElement,
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          icon: icons.AddIcon,
          mode: "bleed",
          onClick: handleOpen,
          size: fullscreen ? "large" : "default",
          ref: setButtonElement,
          selected: open,
          text: t2("search.action.add-filter")
        }
      )
    }
  );
}
const DocumentTypeFilterItem = React.memo(function({
  selected,
  type,
  ...rest
}) {
  var _a2, _b;
  const { dispatch } = useSearchState(), handleTypeAdd = React.useCallback(() => {
    dispatch({ type: "TERMS_TYPE_ADD", schemaType: type });
  }, [dispatch, type]), handleTypeRemove = React.useCallback(() => {
    dispatch({ type: "TERMS_TYPE_REMOVE", schemaType: type });
  }, [dispatch, type]), handleClick = React.useCallback(() => {
    selected ? handleTypeRemove() : handleTypeAdd();
  }, [handleTypeAdd, handleTypeRemove, selected]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      iconRight: selected && icons.CheckmarkIcon,
      justify: "flex-start",
      mode: "bleed",
      onClick: handleClick,
      width: "fill",
      size: "large",
      tabIndex: -1,
      text: (_b = type.title) != null ? _b : type.name,
      tone: selected ? "primary" : "default"
    },
    (_a2 = type.title) != null ? _a2 : type.name
  ) });
}), ClearButtonBox = styledComponents.styled(ui.Box)`
  border-top: 1px solid ${({ theme: theme2 }) => theme2.sanity.color.base.border};
  flex-shrink: 0;
`, POPOVER_STYLES = { width: "250px" };
function DocumentTypesPopoverContent() {
  const [inputElement, setInputElement] = React.useState(null), [typeFilter, setTypeFilter] = React.useState(""), commandListRef = React.useRef(null), { t: t2 } = useTranslation(), schema2 = useSchema(), {
    dispatch,
    state: {
      terms: { types: selectedTypes }
    }
  } = useSearchState(), [selectedTypesSnapshot, setSelectedTypesSnapshot] = React.useState(selectedTypes), documentTypeItems = useGetDocumentTypeItems(
    schema2,
    selectedTypes,
    selectedTypesSnapshot,
    typeFilter
  ), handleFilterChange = React.useCallback(
    (e) => setTypeFilter(e.currentTarget.value),
    [setTypeFilter]
  ), handleFilterClear = React.useCallback(() => setTypeFilter(""), []), handleTypesClear = React.useCallback(() => {
    var _a2, _b;
    setSelectedTypesSnapshot([]), dispatch({ type: "TERMS_TYPES_CLEAR" }), (_a2 = commandListRef == null ? void 0 : commandListRef.current) == null || _a2.focusInputElement(), (_b = commandListRef == null ? void 0 : commandListRef.current) == null || _b.scrollToIndex(0);
  }, [dispatch]), getItemKey2 = React.useCallback(
    (index) => {
      const virtualItem = documentTypeItems[index];
      switch (virtualItem.type) {
        case "divider":
          return `${virtualItem.type}-${index}`;
        case "header":
          return `${virtualItem.type}-${virtualItem.title}`;
        case "item":
          return `${virtualItem.type}-${virtualItem.item.name}`;
        default:
          return index;
      }
    },
    [documentTypeItems]
  ), renderItem2 = React.useCallback((item) => item.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}) }) : item.type === "header" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { margin: 2, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: item.title }) }) : item.type === "item" ? /* @__PURE__ */ jsxRuntime.jsx(DocumentTypeFilterItem, { paddingBottom: 1, selected: item.selected, type: item.item }) : null, []), getItemDisabled = React.useCallback(
    (index) => documentTypeItems[index].type !== "item",
    [documentTypeItems]
  ), getItemSelected = React.useCallback(
    (index) => {
      const item = documentTypeItems[index];
      return item.type === "item" && item.selected;
    },
    [documentTypeItems]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", style: POPOVER_STYLES, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      FilterPopoverContentHeader,
      {
        ariaInputLabel: t2("search.action.filter-by-document-type-aria-label"),
        onChange: handleFilterChange,
        onClear: handleFilterClear,
        ref: setInputElement,
        typeFilter
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
      documentTypeItems.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
        CommandList,
        {
          activeItemDataAttr: "data-hovered",
          ariaLabel: t2("search.document-types-aria-label"),
          ariaMultiselectable: !0,
          autoFocus: "input",
          getItemDisabled,
          getItemSelected,
          getItemKey: getItemKey2,
          inputElement,
          itemHeight: 37,
          items: documentTypeItems,
          overscan: 20,
          padding: 1,
          paddingBottom: 0,
          ref: commandListRef,
          renderItem: renderItem2
        }
      ),
      !documentTypeItems.length && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: t2("search.document-types-no-matches-found", { filter: typeFilter }) }) })
    ] }),
    !typeFilter && selectedTypes.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ClearButton, { onClick: handleTypesClear, selectedTypes })
  ] });
}
function ClearButton({ onClick, selectedTypes }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ClearButtonBox, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      "aria-label": t2("search.action.clear-type-filters-aria-label"),
      "data-name": "type-filter-button",
      disabled: selectedTypes.length === 0,
      mode: "bleed",
      onClick,
      text: t2("search.action.clear-type-filters-label"),
      tone: "primary"
    }
  ) }) });
}
function useGetDocumentTypeItems(schema2, selectedTypes, selectedTypesSnapshot, typeFilter) {
  return React.useMemo(() => {
    const [itemsSelected, itemsUnselected] = partition__default.default(
      getSelectableOmnisearchTypes(schema2, typeFilter),
      (type) => selectedTypesSnapshot.includes(type)
    ), hasSelectedItems = itemsSelected.length > 0, hasUnselectedItems = itemsSelected.length > 0, items = [];
    return hasSelectedItems && items.push({ title: "Selected", type: "header" }), itemsSelected.forEach(
      (item) => items.push({ item, selected: selectedTypes.includes(item), type: "item" })
    ), hasSelectedItems && hasUnselectedItems && items.push({ type: "divider" }), itemsUnselected.forEach(
      (item) => items.push({ item, selected: selectedTypes.includes(item), type: "item" })
    ), items;
  }, [schema2, selectedTypes, selectedTypesSnapshot, typeFilter]);
}
const FALLBACK_PLACEMENTS = ["top-start", "bottom-start"];
function DocumentTypesButton() {
  const [open, setOpen] = React.useState(!1), [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), {
    state: {
      fullscreen,
      terms: { types: types2 }
    }
  } = useSearchState(), { t: t2 } = useTranslation(), handleClose = React.useCallback(() => setOpen(!1), []), handleOpen = React.useCallback(() => setOpen(!0), []);
  ui.useClickOutside(handleClose, [buttonElement, popoverElement]);
  const title = React.useMemo(() => documentTypesTruncated({ types: types2, t: t2 }), [types2, t2]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0],
      content: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: /* @__PURE__ */ jsxRuntime.jsx(DocumentTypesPopoverContent, {}) }),
      open,
      placement: "bottom-start",
      fallbackPlacements: FALLBACK_PLACEMENTS,
      portal: !0,
      radius: POPOVER_RADIUS,
      ref: setPopoverElement,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          iconRight: icons.ChevronDownIcon,
          mode: "ghost",
          onClick: handleOpen,
          size: fullscreen ? "large" : "default",
          ref: setButtonElement,
          selected: open,
          text: title,
          tone: "default"
        }
      )
    }
  );
}
const CustomBox = styledComponents.styled(ui.Box)`
  flex-shrink: ${({ $flexShrink = 0 }) => $flexShrink};
`;
function FilterLabel({ filter, fontSize = 1, showContent = !0 }) {
  const { t: t2 } = useTranslation(), {
    state: { definitions, fullscreen }
  } = useSearchState(), operator = getOperatorDefinition(definitions.operators, filter.operatorType), ButtonValue = operator == null ? void 0 : operator.buttonValueComponent, filterValue = filter.value, components2 = React.useMemo(
    () => ({
      Field: () => /* @__PURE__ */ jsxRuntime.jsx(CustomBox, { $flexShrink: fullscreen ? 1 : 0, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", size: fontSize, textOverflow: "ellipsis", weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(FilterTitle, { filter, maxLength: fullscreen ? 25 : 40 }) }) }),
      Operator: ({ children }) => showContent ? /* @__PURE__ */ jsxRuntime.jsx(CustomBox, { $flexShrink: 0, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", size: fontSize, textOverflow: "ellipsis", weight: "regular", children }) }) : null,
      Value: ({ children }) => showContent ? /* @__PURE__ */ jsxRuntime.jsx(CustomBox, { $flexShrink: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "default", size: fontSize, textOverflow: "ellipsis", weight: "medium", children: ButtonValue ? /* @__PURE__ */ jsxRuntime.jsx(ButtonValue, { value: filterValue }) : children }) }) : null
    }),
    [filter, fontSize, fullscreen, showContent, ButtonValue, filterValue]
  );
  if (operator != null && operator.descriptionKey || console.warn("Missing `descriptionKey` for operator `%s`", filter.operatorType), !showContent || !(operator != null && operator.descriptionKey)) {
    const Field = components2.Field;
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Field, {}) });
  }
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: operator == null ? void 0 : operator.descriptionKey,
      components: components2,
      values: getFilterValues(filter)
    }
  ) });
}
function getFilterValues(filter) {
  const values2 = {};
  return typeof filter.value == "number" && (values2.count = filter.value), isStringOrNumber(filter.value) && (values2.value = filter.value), isRecord$4(filter.value) && "from" in filter.value && isStringOrNumber(filter.value.from) && (values2.from = filter.value.from), isRecord$4(filter.value) && "to" in filter.value && isStringOrNumber(filter.value.to) && (values2.to = filter.value.to), values2;
}
function isStringOrNumber(value) {
  return typeof value == "string" || typeof value == "number";
}
function FilterError(props2) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...props2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t2("search.error.display-filter-title") }),
      /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "critical", children: t2("search.error.display-filter-description") })
    ] })
  ] }) });
}
function CustomMenuItem$1({
  onClick,
  operator,
  selected
}) {
  const handleClick = React.useCallback(() => onClick(operator.type), [onClick, operator.type]), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuItem,
    {
      onClick: handleClick,
      pressed: selected,
      tone: "default",
      text: t2(operator.nameKey),
      iconRight: operator == null ? void 0 : operator.icon
    }
  );
}
function OperatorsMenuButton({ filter, operator }) {
  var _a2;
  const menuButtonId = React.useId(), { t: t2 } = useTranslation(), { dispatch, state } = useSearchState(), operatorItems = (_a2 = getFilterDefinition(state.definitions.filters, filter.filterName)) == null ? void 0 : _a2.operators, handleClick = React.useCallback(
    (operatorType) => {
      dispatch({
        filterKey: getFilterKey(filter),
        operatorType,
        type: "TERMS_FILTERS_SET_OPERATOR"
      });
    },
    [dispatch, filter]
  );
  return !operator || !operatorItems || operatorItems.length <= 1 ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { mode: "ghost", iconRight: icons.ChevronDownIcon, text: t2(operator.nameKey) }),
      id: menuButtonId || "",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: operatorItems.map((item, index) => {
        if (item.type === "item") {
          const menuOperator = getOperatorDefinition(state.definitions.operators, item.name);
          return menuOperator ? /* @__PURE__ */ jsxRuntime.jsx(
            CustomMenuItem$1,
            {
              onClick: handleClick,
              operator: menuOperator,
              selected: operator.type === item.name
            },
            index
          ) : null;
        }
        return item.type === "divider" ? /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}, index) : null;
      }) }),
      placement: "bottom-start",
      popover: {
        constrainSize: !0,
        portal: !1,
        radius: 2
      }
    }
  ) });
}
function FilterForm({ filter }) {
  const [errorParams, setErrorParams] = React.useState(null), {
    dispatch,
    state: { definitions, fullscreen }
  } = useSearchState(), filterDefinition = getFilterDefinition(definitions.filters, filter.filterName), operator = getOperatorDefinition(definitions.operators, filter.operatorType), fieldDefinition = getFieldFromFilter(definitions.fields, filter), filterKey = getFilterKey(filter), handleClose = React.useCallback(() => {
    dispatch({
      filterKey: getFilterKey(filter),
      type: "TERMS_FILTERS_REMOVE"
    });
  }, [dispatch, filter]), handleValueChange = React.useCallback(
    (value) => {
      dispatch({
        filterKey,
        type: "TERMS_FILTERS_SET_VALUE",
        value
      });
    },
    [dispatch, filterKey]
  ), handleCatchError = React.useCallback((params) => {
    setErrorParams(params);
  }, []), Component = operator == null ? void 0 : operator.inputComponent;
  return errorParams ? /* @__PURE__ */ jsxRuntime.jsx(FilterError, { padding: 4 }) : /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: handleCatchError, children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !supportsTouch, returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column-reverse", children: [
    Component && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
      Component,
      {
        fieldDefinition,
        onChange: handleValueChange,
        value: filter.value
      },
      filter.operatorType
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, justify: "space-between", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 1, paddingRight: 2, paddingY: 1, children: /* @__PURE__ */ jsxRuntime.jsx(FilterDetails, { filter }) }),
        fullscreen && /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            icon: icons.TrashIcon,
            mode: "bleed",
            onClick: handleClose,
            tone: "critical",
            tooltipProps: { content: "Remove filter" }
          }
        )
      ] }),
      (filterDefinition == null ? void 0 : filterDefinition.description) && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 3, radius: 2, tone: "transparent", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: filterDefinition.description }) }),
      /* @__PURE__ */ jsxRuntime.jsx(OperatorsMenuButton, { filter, operator })
    ] }) })
  ] }) }) });
}
const ContainerFlex = styledComponents.styled(ui.Flex)`
  max-width: 480px;
  min-width: 150px;
  overflow: hidden;
  overflow: clip;
  width: 100%;
`;
function FilterPopoverContent({ filter }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(ContainerFlex, { direction: "column", children: [
    /* @__PURE__ */ jsxRuntime.jsx(FilterForm, { filter }),
    DEBUG_MODE
  ] });
}
const CloseButton = styledComponents.styled(ui.Button)`
  border-radius: ${({ theme: theme2 }) => `0 ${ui.rem(theme2.sanity.radius[2])} ${ui.rem(theme2.sanity.radius[2])} 0`};
`, CloseCard = styledComponents.styled(ui.Card)`
  position: absolute;
  right: 0;
`, ContainerDiv = styledComponents.styled.div`
  align-items: center;
  display: inline-flex;
  max-width: 100%;
  position: relative;
`, LabelButton = styledComponents.styled(ui.Button)`
  border: none;
  width: 100%;
`;
function FilterButton({ filter, initialOpen }) {
  const [open, setOpen] = React.useState(initialOpen), [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), {
    dispatch,
    state: { definitions, fullscreen }
  } = useSearchState(), { t: t2 } = useTranslation(), handleClose = React.useCallback(() => setOpen(!1), []), handleOpen = React.useCallback(() => setOpen(!0), []), handleRemove = React.useCallback(
    () => dispatch({
      filterKey: getFilterKey(filter),
      type: "TERMS_FILTERS_REMOVE"
    }),
    [dispatch, filter]
  ), handleKeyDown = React.useCallback(
    (event) => {
      ["Backspace", "Delete"].includes(event.key) && handleRemove();
    },
    [handleRemove]
  );
  ui.useClickOutside(handleClose, [buttonElement, popoverElement]);
  const isValid = validateFilter({
    fieldDefinitions: definitions.fields,
    filter,
    filterDefinitions: definitions.filters,
    operatorDefinitions: definitions.operators
  });
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      __unstable_margins: [POPOVER_VERTICAL_MARGIN, 0, 0, 0],
      content: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverWrapper, { anchorElement: buttonElement, onClose: handleClose, children: /* @__PURE__ */ jsxRuntime.jsx(FilterPopoverContent, { filter }) }),
      constrainSize: !0,
      open,
      overflow: "auto",
      placement: "bottom-start",
      portal: !0,
      radius: POPOVER_RADIUS,
      ref: setPopoverElement,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ContainerDiv, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            __unstable_focusRing: !0,
            display: "flex",
            radius: 2,
            tone: isValid ? "primary" : "transparent",
            children: /* @__PURE__ */ jsxRuntime.jsx(
              LabelButton,
              {
                mode: "bleed",
                onClick: handleOpen,
                onKeyDown: handleKeyDown,
                paddingLeft: fullscreen ? 3 : 2,
                paddingRight: fullscreen ? 3 : 5,
                paddingY: fullscreen ? 3 : 2,
                ref: setButtonElement,
                children: /* @__PURE__ */ jsxRuntime.jsx(FilterLabel, { filter, showContent: isValid })
              }
            )
          }
        ),
        !fullscreen && /* @__PURE__ */ jsxRuntime.jsx(
          CloseCard,
          {
            __unstable_focusRing: !0,
            display: "flex",
            radius: 2,
            tone: isValid ? "primary" : "transparent",
            children: /* @__PURE__ */ jsxRuntime.jsx(
              CloseButton,
              {
                "aria-label": t2("search.action.remove-filter-aria-label"),
                fontSize: 1,
                icon: icons.CloseIcon,
                mode: "bleed",
                onClick: handleRemove,
                onKeyDown: handleKeyDown,
                padding: 2,
                radius: 2
              }
            )
          }
        )
      ] })
    }
  );
}
function Filters({ showTypeFilter = !0 }) {
  const {
    dispatch,
    state: {
      filters,
      fullscreen,
      lastAddedFilter,
      terms: { types: types2 }
    }
  } = useSearchState(), { t: t2 } = useTranslation(), isMounted = React.useRef(!1), handleClear = React.useCallback(() => {
    showTypeFilter && dispatch({ type: "TERMS_TYPES_CLEAR" }), dispatch({ type: "TERMS_FILTERS_CLEAR" });
  }, [dispatch, showTypeFilter]), clearFiltersButtonVisible = filters.length > 0 || showTypeFilter && types2.length > 0;
  React.useEffect(() => {
    isMounted.current = !0;
  }, []);
  const lastAddedFilterKey = lastAddedFilter && getFilterKey(lastAddedFilter), ClearFiltersButton = () => /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      mode: "bleed",
      onClick: handleClear,
      size: fullscreen ? "large" : "default",
      text: t2("search.action.clear-filters"),
      tone: "critical"
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, justify: "space-between", padding: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, gap: 2, wrap: "wrap", children: [
        showTypeFilter && /* @__PURE__ */ jsxRuntime.jsx(DocumentTypesButton, {}),
        filters == null ? void 0 : filters.map((filter) => {
          const key = getFilterKey(filter);
          return /* @__PURE__ */ jsxRuntime.jsx(
            FilterButton,
            {
              filter,
              initialOpen: isMounted.current && lastAddedFilterKey === key
            },
            key
          );
        }),
        !fullscreen && /* @__PURE__ */ jsxRuntime.jsx(AddFilterButton, {})
      ] }),
      clearFiltersButtonVisible && !fullscreen && /* @__PURE__ */ jsxRuntime.jsx(ClearFiltersButton, {})
    ] }),
    fullscreen && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "space-between", paddingBottom: 2, paddingX: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(AddFilterButton, {}),
      clearFiltersButtonVisible && /* @__PURE__ */ jsxRuntime.jsx(ClearFiltersButton, {})
    ] }),
    DEBUG_MODE
  ] });
}
const rotate = styledComponents.keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styledComponents.styled(icons.SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`, FilterDiv = styledComponents.styled.div`
  line-height: 0;
  position: relative;
`, SearchHeader = React.forwardRef(function({ ariaInputLabel, onClose }, ref) {
  const isMountedRef = React.useRef(!1), { t: t2 } = useTranslation(), {
    dispatch,
    state: {
      filters,
      filtersVisible,
      fullscreen,
      result: { loading },
      terms
    }
  } = useSearchState(), { types: types2, query } = terms, hasValidTerms = hasSearchableTerms({ terms }), ariaLabel = t2(ariaInputLabel || hasValidTerms ? "search.search-results-aria-label" : "search.recent-searches-aria-label"), handleFiltersToggle = React.useCallback(
    () => dispatch({ type: "FILTERS_VISIBLE_SET", visible: !filtersVisible }),
    [dispatch, filtersVisible]
  ), handleQueryChange = React.useCallback(
    (e) => dispatch({ type: "TERMS_QUERY_SET", query: e.currentTarget.value }),
    [dispatch]
  ), handleQueryClear = React.useCallback(() => {
    dispatch({ type: "TERMS_QUERY_SET", query: "" });
  }, [dispatch]);
  React.useEffect(() => {
    fullscreen || dispatch({ type: "FILTERS_VISIBLE_SET", visible: !0 });
  }, [dispatch, fullscreen]), React.useEffect(() => {
    isMountedRef.current = !0;
  }, []);
  const notificationBadgeVisible = filters.length > 0 || types2.length > 0;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: fullscreen ? 2 : 1, padding: fullscreen ? 2 : 1, children: [
    fullscreen && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": t2("search.action.close-search-aria-label"),
        icon: icons.ArrowLeftIcon,
        mode: "bleed",
        onClick: onClose,
        size: "large",
        tooltipProps: { content: t2("search.action.close-search-aria-label") }
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      CustomTextInput,
      {
        __unstable_disableFocusRing: !0,
        $background: fullscreen,
        $smallClearButton: fullscreen,
        "aria-label": ariaLabel,
        autoComplete: "off",
        border: !1,
        clearButton: !!query,
        fontSize: [2, 2, 1],
        icon: loading ? AnimatedSpinnerIcon : icons.SearchIcon,
        onChange: handleQueryChange,
        onClear: handleQueryClear,
        placeholder: t2("search.placeholder"),
        radius: 2,
        ref,
        spellCheck: !1,
        value: query
      }
    ) }),
    fullscreen && /* @__PURE__ */ jsxRuntime.jsx(FilterDiv, { children: /* @__PURE__ */ jsxRuntime.jsx(
      StatusButton,
      {
        "aria-expanded": filtersVisible,
        "aria-label": t2("search.action.toggle-filters-aria-label", {
          context: filtersVisible ? "hide" : "show"
        }),
        icon: icons.ControlsIcon,
        mode: "bleed",
        onClick: handleFiltersToggle,
        selected: filtersVisible,
        size: "large",
        tone: notificationBadgeVisible ? "primary" : void 0,
        tooltipProps: {
          content: t2("search.action.toggle-filters-label", {
            context: filtersVisible ? "hide" : "show"
          })
        }
      }
    ) })
  ] }) });
}), isSearchHotKey = isHotkeyEsm.isHotkey(`mod+${GLOBAL_SEARCH_KEY}`), isEscape = isHotkeyEsm.isHotkey("escape");
function useSearchHotkeys({
  open,
  onClose,
  onOpen
}) {
  const { isTopLayer } = ui.useLayer(), handleClose = React.useCallback(() => {
    onClose == null || onClose();
  }, [onClose]), handleGlobalKeyDown = React.useCallback(
    (event) => {
      isSearchHotKey(event) && (event.preventDefault(), open ? handleClose() : onOpen == null || onOpen()), isEscape(event) && open && isTopLayer && handleClose();
    },
    [handleClose, isTopLayer, open, onOpen]
  );
  ui.useGlobalKeyDown(handleGlobalKeyDown);
}
function SearchWrapper({
  children,
  hasValidTerms,
  onClose,
  onOpen,
  open
}) {
  const isMountedRef = React.useRef(!1), {
    dispatch,
    searchCommandList,
    setOnClose,
    state: { result }
  } = useSearchState(), handleClose = React.useCallback(() => {
    var _a2;
    dispatch({ index: (_a2 = searchCommandList == null ? void 0 : searchCommandList.getTopIndex()) != null ? _a2 : -1, type: "LAST_ACTIVE_INDEX_SET" }), onClose();
  }, [dispatch, onClose, searchCommandList]);
  return useSearchHotkeys({ onClose: handleClose, onOpen, open }), React.useEffect(() => {
    setOnClose(handleClose);
  }, [handleClose, setOnClose]), React.useEffect(() => {
    (!hasValidTerms || result.loaded) && isMountedRef.current && dispatch({ index: 0, type: "LAST_ACTIVE_INDEX_SET" });
  }, [dispatch, hasValidTerms, result.loaded]), React.useEffect(() => {
    !hasValidTerms && isMountedRef.current && !open && dispatch({ type: "ORDERING_RESET" });
  }, [dispatch, hasValidTerms, open]), React.useEffect(() => {
    isMountedRef != null && isMountedRef.current || (isMountedRef.current = !0);
  }, []), children;
}
const MAX_OBJECT_TRAVERSAL_DEPTH = 3;
function createFieldDefinitions(schema2, filterDefinitions2) {
  var _a2;
  const searchableDocumentTypeNames = getSearchableOmnisearchTypes(schema2).map((s) => s.name), { documentTypes, objectTypes } = (((_a2 = schema2._original) == null ? void 0 : _a2.types) || []).filter(
    (t2) => isDocumentObjectDefinition(t2) ? searchableDocumentTypeNames.includes(t2.name) : !0
  ).filter((schemaType) => schemaType.name !== "slug").filter((schemaType) => !schemaType.name.startsWith("sanity.")).reduce(
    (acc, schemaType) => (isDocumentObjectDefinition(schemaType) && (acc.documentTypes[schemaType.name] = schemaType), isObjectDefinition(schemaType) && (acc.objectTypes[schemaType.name] = schemaType), acc),
    { documentTypes: {}, objectTypes: {} }
  ) || { documentTypes: {}, objectTypes: {} }, supportedFieldTypes = getSupportedFieldTypes(filterDefinitions2);
  return getDocumentFieldDefinitions(supportedFieldTypes, documentTypes, objectTypes);
}
function createFieldDefinitionDictionary(fieldDefinitions) {
  return fieldDefinitions.reduce((acc, val) => (acc[val.id] = val, acc), {});
}
function generateFieldId(field) {
  return [field.type, field.fieldPath, field.filterName, field.documentTypes.join(",")].join("-");
}
function getDocumentFieldDefinitions(supportedFieldTypes, documentTypes, objectTypes) {
  function addFieldDefinitionRecursive({
    acc,
    defType,
    depth = 0,
    documentType,
    prevFieldPath,
    prevTitlePath
  }) {
    var _a2;
    const continueRecursion = depth <= MAX_OBJECT_TRAVERSAL_DEPTH, isInternalField = defType.name.startsWith("_"), title = defType != null && defType.title ? sanitizeFieldValue(defType.title) : startCase__default.default(defType.name), fieldPath = prevFieldPath ? `${prevFieldPath}.${defType.name}` : defType.name, titlePath = prevTitlePath ? [...prevTitlePath, title] : [title];
    if (!continueRecursion) return;
    const existingObject = objectTypes[defType.type], existingDocument = documentTypes[defType.type], inlineObject = isObjectDefinition(defType) ? defType : null, targetObject = existingDocument || existingObject || inlineObject;
    if (targetObject) {
      (_a2 = targetObject == null ? void 0 : targetObject.fields) == null || _a2.forEach(
        (field) => addFieldDefinitionRecursive({
          acc,
          defType: field,
          depth: depth + 1,
          documentType,
          prevFieldPath: fieldPath,
          prevTitlePath: titlePath
        })
      );
      return;
    }
    supportedFieldTypes.includes(defType.type) && acc.push({
      documentTypes: documentType && !isInternalField ? [documentType] : [],
      fieldPath,
      filterName: resolveFilterName(defType),
      id: "",
      name: defType.name,
      titlePath,
      title,
      type: defType.type
    });
  }
  return Object.values(documentTypes).reduce((acc, documentType) => {
    const documentFields = documentType.fields.reduce((a, field) => (addFieldDefinitionRecursive({ acc: a, defType: field, documentType: documentType.name }), a), []);
    return acc.push(...documentFields), acc;
  }, []).reduce((acc, val) => {
    const prevIndex = acc.findIndex(
      (v) => v.fieldPath === val.fieldPath && v.title === val.title && v.type === val.type
    );
    return prevIndex > -1 ? acc[prevIndex] = {
      ...acc[prevIndex],
      documentTypes: [...acc[prevIndex].documentTypes, ...val.documentTypes]
    } : acc.push(val), acc;
  }, []).map(addFieldDefinitionId).sort(sortFieldDefinitions);
}
function addFieldDefinitionId(field) {
  return {
    ...field,
    id: generateFieldId(field)
  };
}
function isArrayOfPrimitives(schemaType) {
  var _a2;
  return isArrayDefinition(schemaType) ? schemaType.of.every((item) => ["boolean", "number", "string"].includes(item.type)) && ((_a2 = schemaType.options) != null && _a2.list ? schemaType.options.list.length > 0 : !1) : !1;
}
function isArrayDefinition(schemaType) {
  return schemaType.type === "array";
}
function isDocumentObjectDefinition(schemaType) {
  return schemaType.type === "document";
}
function isObjectDefinition(schemaType) {
  return schemaType.type === "object";
}
function isStringDefinition(schemaType) {
  return schemaType.type === "string";
}
function isStringListDefinition(schemaType) {
  var _a2;
  return isStringDefinition(schemaType) && (_a2 = schemaType.options) != null && _a2.list ? schemaType.options.list.length > 0 : !1;
}
function resolveFilterName(schemaType) {
  if (isStringListDefinition(schemaType))
    return "stringList";
  if (isArrayDefinition(schemaType)) {
    if (schemaType.of.some((item) => item.type === "reference"))
      return "arrayReferences";
    if (schemaType.of.find((item) => item.type === "block"))
      return "portableText";
    if (isArrayOfPrimitives(schemaType))
      return "arrayList";
  }
  return schemaType.type;
}
function sortFieldDefinitions(a, b) {
  const aTitlePath = a.titlePath.slice(0, -1).join("/"), bTitlePath = b.titlePath.slice(0, -1).join("/");
  return a.title.localeCompare(b.title) || aTitlePath.localeCompare(bTitlePath) || a.fieldPath.localeCompare(b.fieldPath);
}
const RECENT_SEARCH_VERSION$1 = 2, STORED_SEARCHES_NAMESPACE = "studio.search.recent", defaultValue = {
  version: RECENT_SEARCH_VERSION$1,
  recentSearches: []
};
function useStoredSearch() {
  const keyValueStore = useKeyValueStore(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), { dataset } = client2.config(), keyValueStoreKey = React.useMemo(() => `${STORED_SEARCHES_NAMESPACE}.${dataset}`, [dataset]), [value, setValue] = React.useState(defaultValue), settings = React.useMemo(() => keyValueStore.getKey(keyValueStoreKey), [keyValueStore, keyValueStoreKey]);
  React.useEffect(() => {
    const sub = settings.pipe(
      operators.startWith(defaultValue),
      operators.map((data) => data ? (data == null ? void 0 : data.version) !== RECENT_SEARCH_VERSION$1 ? (keyValueStore.setKey(keyValueStoreKey, defaultValue), defaultValue) : data : defaultValue)
    ).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [settings, keyValueStore, keyValueStoreKey]);
  const set2 = React.useCallback(
    (newValue) => {
      setValue(newValue), keyValueStore.setKey(keyValueStoreKey, newValue);
    },
    [keyValueStore, keyValueStoreKey]
  );
  return React.useMemo(() => [value, set2], [set2, value]);
}
const MAX_RECENT_SEARCHES = 5, RECENT_SEARCH_VERSION = 2;
function useRecentSearchesStore() {
  const [storedSearch, setStoredSearch] = useStoredSearch(), schema2 = useSchema(), {
    search: { operators: operators2, filters }
  } = useSource(), { fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 } = React.useMemo(() => ({
    fieldDefinitions: createFieldDefinitionDictionary(createFieldDefinitions(schema2, filters)),
    filterDefinitions: createFilterDefinitionDictionary(filters),
    operatorDefinitions: createOperatorDefinitionDictionary(operators2)
  }), [filters, operators2, schema2]);
  return {
    /**
     * Write a search term to Local Storage and return updated recent searches.
     */
    addSearch: (searchTerm, searchFilters) => {
      const validStoredFilters = (searchFilters || []).map(
        (filter) => ({
          fieldId: filter.fieldId,
          filterName: filter.filterName,
          operatorType: filter.operatorType,
          value: filter.value
        })
      ).filter(
        (filter) => validateFilter({
          fieldDefinitions,
          filter,
          filterDefinitions: filterDefinitions2,
          operatorDefinitions: operatorDefinitions2
        })
      ), newSearchItem = {
        created: (/* @__PURE__ */ new Date()).toISOString(),
        filters: validStoredFilters,
        terms: {
          query: searchTerm.query.trim(),
          typeNames: searchTerm.types.map((s) => s.name)
        }
      }, newRecent = {
        version: RECENT_SEARCH_VERSION,
        recentSearches: [
          newSearchItem,
          ...storedSearch.recentSearches.filter((r) => !isEqual__default.default(omit__default.default(r, "created"), omit__default.default(newSearchItem, "created")))
        ].slice(0, MAX_RECENT_SEARCHES)
      };
      return setStoredSearch(newRecent), getRecentSearchTerms({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        operatorDefinitions: operatorDefinitions2,
        schema: schema2,
        storedSearch: newRecent,
        setStoredSearch
      });
    },
    /**
     * Fetch all recent searches from Local Storage.
     * Invalid search terms will be filtered out and terms will be re-written to Local Storage.
     */
    getRecentSearches: () => getRecentSearchTerms({
      fieldDefinitions,
      filterDefinitions: filterDefinitions2,
      operatorDefinitions: operatorDefinitions2,
      schema: schema2,
      storedSearch,
      setStoredSearch
    }),
    /**
     * Remove all search terms from Local Storage and return updated recent searches.
     */
    removeSearch: () => {
      const newRecent = {
        ...storedSearch,
        recentSearches: []
      };
      return setStoredSearch(newRecent), getRecentSearchTerms({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        operatorDefinitions: operatorDefinitions2,
        schema: schema2,
        storedSearch: newRecent,
        setStoredSearch
      });
    },
    /**
     * Remove a search term from Local Storage and return updated recent searches.
     */
    removeSearchAtIndex: (index) => {
      if (index < 0 || index > storedSearch.recentSearches.length)
        return getRecentSearchTerms({
          fieldDefinitions,
          filterDefinitions: filterDefinitions2,
          operatorDefinitions: operatorDefinitions2,
          schema: schema2,
          storedSearch,
          setStoredSearch
        });
      const newRecent = {
        ...storedSearch,
        recentSearches: [
          ...storedSearch.recentSearches.slice(0, index),
          ...storedSearch.recentSearches.slice(index + 1)
        ]
      };
      return setStoredSearch(newRecent), getRecentSearchTerms({
        fieldDefinitions,
        filterDefinitions: filterDefinitions2,
        operatorDefinitions: operatorDefinitions2,
        schema: schema2,
        storedSearch: newRecent,
        setStoredSearch
      });
    }
  };
}
function getRecentSearchTerms({
  schema: schema2,
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  operatorDefinitions: operatorDefinitions2,
  storedSearch,
  setStoredSearch
}) {
  return sanitizeStoredSearch({
    studioSchema: schema2,
    filterDefinitions: filterDefinitions2,
    fieldDefinitions,
    operatorDefinitions: operatorDefinitions2,
    storedSearch,
    setStoredSearch
  }).recentSearches.filter((r) => !!r.terms).map((r, index) => ({
    __recent: {
      index,
      timestamp: new Date(r.created).getTime()
    },
    filters: r.filters,
    query: r.terms.query,
    types: r.terms.typeNames.map((typeName) => schema2.get(typeName)).filter((s) => !!(s && s.jsonType === "object"))
  }));
}
function sanitizeStoredSearch({
  fieldDefinitions,
  filterDefinitions: filterDefinitions2,
  operatorDefinitions: operatorDefinitions2,
  studioSchema,
  storedSearch,
  setStoredSearch
}) {
  const searchableTypeNames = getSearchableOmnisearchTypes(studioSchema).map(
    (schema2) => schema2.name
  ), filteredSearch = storedSearch.recentSearches.filter((recentSearch) => (
    // Has valid searchable types (not hidden by omnisearch)
    recentSearch.terms.typeNames.every((typeName) => searchableTypeNames.includes(typeName)) && recentSearch.filters.every(
      (filter) => validateFilter({ fieldDefinitions, filter, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 })
    )
  )), newStoredSearch = {
    version: RECENT_SEARCH_VERSION,
    recentSearches: filteredSearch
  };
  return newStoredSearch.recentSearches.length < storedSearch.recentSearches.length && setStoredSearch(newStoredSearch), newStoredSearch;
}
function Instructions() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", direction: "column", gap: 4, paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: "search.instructions",
      components: {
        ControlsIcon: () => /* @__PURE__ */ jsxRuntime.jsx(icons.ControlsIcon, { style: { padding: "0 0.25rem" } }, 0)
      }
    }
  ) }) }) });
}
function DocumentTypesPill({ availableCharacters, types: types2 }) {
  const { t: t2 } = useTranslation(), title = React.useMemo(
    () => documentTypesTruncated({ availableCharacters, types: types2, t: t2 }),
    [availableCharacters, types2, t2]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, padding: 2, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: title }) });
}
const FilterPillCard = styledComponents.styled(ui.Card)`
  cursor: default;
`;
function FilterPill({ filter }) {
  return /* @__PURE__ */ jsxRuntime.jsx(FilterPillCard, { border: !0, padding: 2, radius: 2, tone: "primary", children: /* @__PURE__ */ jsxRuntime.jsx(FilterLabel, { filter }) });
}
const DEFAULT_COMBINED_TYPE_COUNT = 40, RecentSearchItemButton = styledComponents.styled(ui.Button)`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[2])};
  cursor: default;
  width: 100%;
`, SearchItemPillsBox = styledComponents.styled(ui.Box)`
  flex-shrink: 3;
`, SearchItemQueryFlex = styledComponents.styled(ui.Flex)`
  flex-shrink: 2;
`, CloseButtonDiv = styledComponents.styled.div`
  opacity: 0.8;
  visibility: hidden;

  @media (hover: hover) {
    ${RecentSearchItemButton}:hover & {
      visibility: visible;
    }
    &:hover {
      opacity: 0.4;
    }
  }
`;
function RecentSearchItem({
  index,
  maxVisibleTypePillChars = DEFAULT_COMBINED_TYPE_COUNT,
  value,
  ...rest
}) {
  var _a2;
  const { dispatch } = useSearchState(), recentSearchesStore = useRecentSearchesStore(), availableCharacters = maxVisibleTypePillChars - value.query.length, handleClick = React.useCallback(() => {
    dispatch({ type: "TERMS_SET", filters: value == null ? void 0 : value.filters, terms: value }), recentSearchesStore && (recentSearchesStore == null || recentSearchesStore.addSearch(value, value == null ? void 0 : value.filters));
  }, [dispatch, recentSearchesStore, value]), handleDelete = React.useCallback(
    (event) => {
      event.stopPropagation(), recentSearchesStore && (recentSearchesStore == null || recentSearchesStore.removeSearchAtIndex(index));
    },
    [index, recentSearchesStore]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ...rest, children: /* @__PURE__ */ jsxRuntime.jsx(
    RecentSearchItemButton,
    {
      mode: "bleed",
      onClick: handleClick,
      paddingLeft: 3,
      paddingRight: 1,
      paddingY: 1,
      tabIndex: -1,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "stretch", children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { paddingY: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ClockIcon, {}) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "\u200B" })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "stretch", flex: 1, gap: 2, justify: "flex-start", marginLeft: 3, wrap: "wrap", children: [
          value.query && /* @__PURE__ */ jsxRuntime.jsx(SearchItemQueryFlex, { align: "center", paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", weight: "medium", children: value.query }) }),
          value.types.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(SearchItemPillsBox, { children: /* @__PURE__ */ jsxRuntime.jsx(DocumentTypesPill, { availableCharacters, types: value.types }) }),
          (_a2 = value == null ? void 0 : value.filters) == null ? void 0 : _a2.map((filter, i) => /* @__PURE__ */ jsxRuntime.jsx(FilterPill, { filter }, i))
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(CloseButtonDiv, { onClick: handleDelete, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.CloseIcon, {}) }) }) }) })
      ] })
    }
  ) });
}
const VIRTUAL_LIST_RECENT_SEARCH_ITEM_HEIGHT = 36, MAX_COMBINED_TYPE_COUNT_SMALL = 20, MAX_COMBINED_TYPE_COUNT_LARGE = 40, RecentSearchesBox = styledComponents.styled(ui.Card)`
  overflow-x: hidden;
  overflow-y: auto;
  position: relative;
`;
function RecentSearches({ inputElement }) {
  const {
    dispatch,
    state: { filtersVisible, fullscreen }
  } = useSearchState(), recentSearchesStore = useRecentSearchesStore(), recentSearches = React.useMemo(
    () => recentSearchesStore == null ? void 0 : recentSearchesStore.getRecentSearches(),
    [recentSearchesStore]
  ), commandListRef = React.useRef(null), { t: t2 } = useTranslation(), handleClearRecentSearchesClick = React.useCallback(() => {
    var _a2;
    recentSearchesStore && recentSearchesStore.removeSearch(), (_a2 = commandListRef == null ? void 0 : commandListRef.current) == null || _a2.focusInputElement();
  }, [recentSearchesStore]), mediaIndex = ui.useMediaIndex(), maxVisibleTypePillChars = React.useMemo(() => mediaIndex < 2 ? MAX_COMBINED_TYPE_COUNT_SMALL : MAX_COMBINED_TYPE_COUNT_LARGE, [mediaIndex]), renderItem2 = React.useCallback(
    (item, { virtualIndex }) => /* @__PURE__ */ jsxRuntime.jsx(
      RecentSearchItem,
      {
        index: virtualIndex,
        maxVisibleTypePillChars,
        paddingBottom: 1,
        value: item
      }
    ),
    [maxVisibleTypePillChars]
  ), hasRecentSearches = !!recentSearches.length;
  return /* @__PURE__ */ jsxRuntime.jsx(
    RecentSearchesBox,
    {
      borderTop: hasRecentSearches || !hasRecentSearches && !filtersVisible && fullscreen,
      flex: 1,
      children: recentSearches.length > 0 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 2, paddingTop: 4, paddingX: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t2("search.recent-searches-label") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
          CommandList,
          {
            activeItemDataAttr: "data-hovered",
            ariaLabel: t2("search.recent-searches-aria-label"),
            inputElement,
            initialIndex: 0,
            itemHeight: VIRTUAL_LIST_RECENT_SEARCH_ITEM_HEIGHT,
            items: recentSearches,
            paddingX: 2,
            paddingY: 1,
            renderItem: renderItem2
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 2, paddingTop: 1, paddingX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.Button,
          {
            mode: "bleed",
            onClick: handleClearRecentSearchesClick,
            tone: "default",
            text: t2("search.action.clear-recent-searches"),
            muted: !0
          }
        ) })
      ] }) : !filtersVisible && fullscreen && /* @__PURE__ */ jsxRuntime.jsx(Instructions, {})
    }
  );
}
function NoResults() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "aria-live": "assertive", space: 4, paddingX: 4, paddingY: 5, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, weight: "medium", children: t2("search.no-results-title") }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: t2("search.no-results-help-description") })
  ] }) });
}
const TextWithToneStyle = styledComponents.styled(ui.Text)`
  &:not([data-muted]) {
    &[data-tone='default'] {
      --card-fg-color: var(--card-badge-default-fg-color);
    }
    &[data-tone='primary'] {
      --card-fg-color: var(--card-badge-primary-fg-color);
    }
    &[data-tone='positive'] {
      --card-fg-color: var(--card-badge-positive-fg-color);
    }
    &[data-tone='caution'] {
      --card-fg-color: var(--card-badge-caution-fg-color);
    }
    &[data-tone='critical'] {
      --card-fg-color: var(--card-badge-critical-fg-color);
    }
  }

  &[data-dimmed] {
    opacity: 0.3;
  }
`, TextWithTone = React.forwardRef(function(props2, ref) {
  const { tone, dimmed, muted, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TextWithToneStyle,
    {
      "data-ui": "TextWithTone",
      "data-dimmed": dimmed ? "" : void 0,
      "data-muted": muted ? "" : void 0,
      "data-tone": tone,
      muted,
      ref,
      ...rest
    }
  );
});
function SearchError() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: "center",
      "aria-live": "assertive",
      direction: "column",
      flex: 1,
      gap: 3,
      marginY: 2,
      padding: 4,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
        /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 2, tone: "critical", weight: "medium", children: t2("search.error.unspecified-error-title") }),
        /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { size: 1, tone: "critical", children: t2("search.error.unspecified-error-help-description") })
      ]
    }
  );
}
const getOrderings = ({ enableLegacySearch }) => ({
  createdAsc: {
    ignoreScore: !0,
    sort: { direction: "asc", field: "_createdAt" },
    titleKey: "search.ordering.created-ascending-label"
  },
  createdDesc: {
    ignoreScore: !0,
    sort: { direction: "desc", field: "_createdAt" },
    titleKey: "search.ordering.created-descending-label"
  },
  relevance: {
    customMeasurementLabel: "relevance",
    ...enableLegacySearch ? { sort: { direction: "desc", field: "_updatedAt" } } : {},
    titleKey: "search.ordering.best-match-label"
  },
  updatedAsc: {
    ignoreScore: !0,
    sort: { direction: "asc", field: "_updatedAt" },
    titleKey: "search.ordering.updated-ascending-label"
  },
  updatedDesc: {
    ignoreScore: !0,
    sort: { direction: "desc", field: "_updatedAt" },
    titleKey: "search.ordering.updated-descending-label"
  }
}), SortMenuContentFlex = styledComponents.styled(ui.Flex)`
  box-sizing: border-box;
`;
function isSearchDivider(item) {
  return item.type === "divider";
}
function CustomMenuItem({ ordering }) {
  const { t: t2 } = useTranslation(), {
    dispatch,
    state: { ordering: currentOrdering }
  } = useSearchState(), handleClick = React.useCallback(() => {
    dispatch({ ordering, type: "ORDERING_SET" });
  }, [dispatch, ordering]), isSelected = React.useMemo(() => isEqual__default.default(currentOrdering, ordering), [currentOrdering, ordering]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuItem,
    {
      onClick: handleClick,
      pressed: isSelected,
      tone: "default",
      text: t2(ordering.titleKey)
    }
  );
}
function SortMenu() {
  const { t: t2 } = useTranslation(), { enableLegacySearch = !1 } = sanity.useWorkspace().search, {
    state: { ordering }
  } = useSearchState(), menuButtonId = React.useId(), menuOrderings = React.useMemo(() => {
    const orderings = getOrderings({ enableLegacySearch });
    return [
      orderings.relevance,
      { type: "divider" },
      orderings.createdAsc,
      orderings.createdDesc,
      { type: "divider" },
      orderings.updatedAsc,
      orderings.updatedDesc
    ];
  }, [enableLegacySearch]), currentMenuItem = menuOrderings.find(
    (item) => isEqual__default.default(ordering, item) && !isSearchDivider(item)
  );
  return currentMenuItem ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, children: /* @__PURE__ */ jsxRuntime.jsx(SortMenuContentFlex, { align: "center", flex: 1, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { mode: "bleed", icon: icons.SortIcon, text: t2(currentMenuItem.titleKey) }),
      id: menuButtonId || "",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: menuOrderings.map((item, index) => isSearchDivider(item) ? /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}, index) : /* @__PURE__ */ jsxRuntime.jsx(
        CustomMenuItem,
        {
          ordering: item
        },
        index
      )) }),
      placement: "bottom-start",
      popover: { portal: !0, radius: 2 }
    }
  ) }) }) : null;
}
const DebugScoreCard = styledComponents.styled(ui.Card)`
  cursor: help;
  left: 0;
  position: absolute;
  top: 0;
`;
function DebugOverlay({ data }) {
  const { score } = data;
  let tone = "default";
  score <= 0.1 ? tone = "critical" : score >= 0.5 && (tone = "primary");
  const matchingStories = data.stories.filter((story) => story.score > 0);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: matchingStories.length ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: matchingStories.map((story) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 0, weight: "medium", children: story.path }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 0, children: story.why })
      ] }, story.path)) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 0, children: "No matches" }) }),
      placement: "bottom-start",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(DebugScoreCard, { padding: 1, shadow: 1, tone, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Code, { size: 0, children: [
        "score: ",
        score
      ] }) })
    }
  ) });
}
const VIRTUAL_LIST_SEARCH_RESULT_ITEM_HEIGHT = 57, VIRTUAL_LIST_OVERSCAN = 4, SearchResultsInnerFlex = styledComponents.styled(ui.Flex)`
  opacity: ${({ $loading }) => $loading ? 0.5 : 1};
  overflow-x: hidden;
  overflow-y: auto;
  position: relative;
  transition: 300ms opacity;
  width: 100%;
`;
function SearchResults({ disableIntentLink, inputElement, onItemSelect }) {
  const {
    dispatch,
    onClose,
    setSearchCommandList,
    state: { debug: debug2, filters, fullscreen, lastActiveIndex, result, terms }
  } = useSearchState(), { t: t2 } = useTranslation(), recentSearchesStore = useRecentSearchesStore(), hasSearchResults = !!result.hits.length, hasNoSearchResults = !result.hits.length && result.loaded, hasError = result.error, handleSearchResultClick = React.useCallback(() => {
    recentSearchesStore && recentSearchesStore.addSearch(terms, filters), onClose == null || onClose();
  }, [filters, onClose, recentSearchesStore, terms]), handleEndReached = React.useCallback(() => {
    dispatch({ type: "PAGE_INCREMENT" });
  }, [dispatch]), renderItem2 = React.useCallback(
    (item) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        SearchResultItem,
        {
          disableIntentLink,
          documentId: getPublishedId(item.hit._id) || "",
          documentType: item.hit._type,
          onClick: handleSearchResultClick,
          onItemSelect,
          paddingY: 1
        }
      ),
      debug2 && /* @__PURE__ */ jsxRuntime.jsx(DebugOverlay, { data: item })
    ] }),
    [debug2, disableIntentLink, handleSearchResultClick, onItemSelect]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Card,
    {
      borderTop: fullscreen || !!(hasError || hasSearchResults || hasNoSearchResults),
      flex: 1,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", children: [
        hasSearchResults && /* @__PURE__ */ jsxRuntime.jsx(SortMenu, {}),
        /* @__PURE__ */ jsxRuntime.jsx(SearchResultsInnerFlex, { $loading: result.loading, "aria-busy": result.loading, flex: 1, children: hasError ? /* @__PURE__ */ jsxRuntime.jsx(SearchError, {}) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          hasSearchResults && /* @__PURE__ */ jsxRuntime.jsx(
            CommandList,
            {
              activeItemDataAttr: "data-hovered",
              ariaLabel: t2("search.search-results-label"),
              "data-testid": "search-results",
              fixedHeight: !0,
              initialIndex: lastActiveIndex,
              inputElement,
              itemHeight: VIRTUAL_LIST_SEARCH_RESULT_ITEM_HEIGHT,
              items: result.hits,
              overscan: VIRTUAL_LIST_OVERSCAN,
              onEndReached: handleEndReached,
              paddingX: 2,
              paddingY: 1,
              ref: setSearchCommandList,
              renderItem: renderItem2
            }
          ),
          hasNoSearchResults && /* @__PURE__ */ jsxRuntime.jsx(NoResults, {})
        ] }) })
      ] })
    }
  ) });
}
const ANIMATION_TRANSITION$1 = {
  duration: 0.4,
  type: "spring"
}, CARD_VARIANTS = {
  open: { opacity: 1, scale: 1, x: "-50%" },
  closed: { opacity: 0, scale: 0.99, x: "-50%" }
}, OVERLAY_VARIANTS = {
  open: { opacity: 1 },
  closed: { opacity: 0 }
}, Y_POSITION = 12, MotionOverlay = styledComponents.styled(framerMotion.motion(ui.Card))`
  background-color: var(--card-backdrop-color);
  bottom: 0;
  left: 0;
  position: absolute;
  right: 0;
  top: 0;
`, SearchMotionCard = styledComponents.styled(framerMotion.motion(ui.Card))`
  display: flex !important;
  flex-direction: column;
  left: 50%;
  max-height: min(
    calc(100vh - ${Y_POSITION}vh - ${POPOVER_INPUT_PADDING}px),
    ${POPOVER_MAX_HEIGHT}px
  );
  position: absolute;
  top: ${Y_POSITION}vh;
  width: min(calc(100vw - ${POPOVER_INPUT_PADDING * 2}px), ${POPOVER_MAX_WIDTH}px);
`;
function SearchPopover({
  disableFocusLock,
  disableIntentLink,
  onClose,
  onItemSelect,
  onOpen,
  open
}) {
  const [inputElement, setInputElement] = React.useState(null), popoverElement = React.useRef(null), { isTopLayer, zIndex } = ui.useLayer();
  useTranslation();
  const {
    onClose: onSearchClose,
    state: { filtersVisible, terms }
  } = useSearchState(), hasValidTerms = hasSearchableTerms({ terms }), handleClickOutside = React.useCallback(() => {
    isTopLayer && onSearchClose && open && onSearchClose();
  }, [isTopLayer, onSearchClose, open]);
  return ui.useClickOutside(handleClickOutside, [popoverElement.current]), /* @__PURE__ */ jsxRuntime.jsx(SearchWrapper, { hasValidTerms, onClose, onOpen, open, children: /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: open && /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { children: /* @__PURE__ */ jsxRuntime.jsxs(FocusLock__default.default, { autoFocus: !supportsTouch, disabled: disableFocusLock, returnFocus: !0, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      MotionOverlay,
      {
        animate: "open",
        exit: "closed",
        initial: "closed",
        style: { zIndex },
        transition: ANIMATION_TRANSITION$1,
        variants: OVERLAY_VARIANTS
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(
      SearchMotionCard,
      {
        animate: "open",
        exit: "closed",
        initial: "closed",
        overflow: "hidden",
        radius: POPOVER_RADIUS,
        ref: popoverElement,
        shadow: 2,
        style: { zIndex },
        transition: ANIMATION_TRANSITION$1,
        variants: CARD_VARIANTS,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(SearchHeader, { onClose, ref: setInputElement }),
          filtersVisible && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(Filters, {}) }),
          hasValidTerms ? /* @__PURE__ */ jsxRuntime.jsx(
            SearchResults,
            {
              inputElement,
              onItemSelect,
              disableIntentLink
            }
          ) : /* @__PURE__ */ jsxRuntime.jsx(RecentSearches, { inputElement })
        ]
      }
    )
  ] }) }) }) });
}
function isRecentSearchTerms(terms) {
  return typeof terms.__recent < "u";
}
const rootName = "core:studio:navbar:search:";
debug__default.default(rootName);
function debugWithName(name) {
  const namespace = `${rootName}${name}`;
  return debug__default.default && debug__default.default.enabled(namespace) ? debug__default.default(namespace) : debug__default.default(rootName);
}
function isDebugMode() {
  return typeof window > "u" ? !1 : window.location.hash.slice(1).split(";").includes(DEBUG_FRAGMENT);
}
function initialSearchState({
  currentUser,
  fullscreen,
  definitions,
  pagination,
  enableLegacySearch
}) {
  return {
    currentUser,
    debug: isDebugMode(),
    documentTypesNarrowed: [],
    filters: [],
    filtersVisible: !0,
    fullscreen,
    lastActiveIndex: -1,
    ordering: getOrderings({ enableLegacySearch }).relevance,
    ...pagination,
    result: {
      error: null,
      hasLocal: !1,
      hits: [],
      loaded: !1,
      loading: !1
    },
    terms: {
      query: "",
      types: []
    },
    definitions,
    enableLegacySearch
  };
}
const debug = debugWithName("reducer");
function searchReducer(state, action) {
  var _a2, _b;
  let prefix = "\u{1F50D}";
  switch (action.type.startsWith("SEARCH_REQUEST") && (prefix = "\u{1F6A8}"), action.type.startsWith("RECENT_SEARCHES") && (prefix = "\u{1F4BE}"), debug(prefix, action), action.type) {
    case "FILTERS_VISIBLE_SET":
      return {
        ...state,
        filtersVisible: action.visible
      };
    case "LAST_ACTIVE_INDEX_SET":
      return {
        ...state,
        lastActiveIndex: action.index
      };
    case "ORDERING_RESET":
      return {
        ...state,
        ordering: getOrderings({ enableLegacySearch: state.enableLegacySearch }).relevance,
        terms: stripRecent(state.terms),
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    case "ORDERING_SET":
      return {
        ...state,
        ordering: action.ordering,
        terms: stripRecent(state.terms),
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    case "PAGE_INCREMENT":
      return {
        ...state,
        cursor: (_a2 = state.nextCursor) != null ? _a2 : state.cursor,
        nextCursor: null,
        terms: stripRecent(state.terms)
      };
    case "SEARCH_CLEAR":
      return {
        ...state,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          hasLocal: !1,
          hits: []
        }
      };
    case "SEARCH_REQUEST_COMPLETE":
      return {
        ...state,
        nextCursor: (_b = action.nextCursor) != null ? _b : null,
        result: {
          ...state.result,
          error: null,
          hasLocal: !0,
          hits: state.result.hasLocal ? deduplicate([...state.result.hits, ...action.hits]) : action.hits,
          loaded: !0,
          loading: !1
        }
      };
    case "SEARCH_REQUEST_ERROR":
      return {
        ...state,
        result: {
          ...state.result,
          error: action.error,
          loaded: !1,
          loading: !1
        }
      };
    case "SEARCH_REQUEST_START":
      return {
        ...state,
        result: {
          ...state.result,
          loaded: !1,
          loading: !0
        }
      };
    case "TERMS_FILTERS_ADD": {
      const newFilter = {
        ...action.filter,
        value: getOperatorInitialValue(state.definitions.operators, action.filter.operatorType)
      }, filters = [...state.filters, newFilter];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: state.terms.types
        }),
        filters,
        lastAddedFilter: newFilter,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        },
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    }
    case "TERMS_FILTERS_CLEAR": {
      const filters = [];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: state.terms.types
        }),
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        },
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    }
    case "TERMS_FILTERS_REMOVE": {
      const index = state.filters.findIndex((filter) => getFilterKey(filter) === action.filterKey), filters = [
        ...state.filters.slice(0, index),
        //
        ...state.filters.slice(index + 1)
      ];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: state.terms.types
        }),
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        },
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    }
    case "TERMS_FILTERS_SET_OPERATOR": {
      const matchedFilter = state.filters.find(
        (filter) => getFilterKey(filter) === action.filterKey
      ), currentOperator = getOperatorDefinition(
        state.definitions.operators,
        matchedFilter == null ? void 0 : matchedFilter.operatorType
      ), nextOperator = getOperatorDefinition(state.definitions.operators, action.operatorType), nextInitialValue = nextOperator == null ? void 0 : nextOperator.initialValue, inputComponentChanged = (currentOperator == null ? void 0 : currentOperator.inputComponent) != (nextOperator == null ? void 0 : nextOperator.inputComponent), filters = state.filters.map((filter) => getFilterKey(filter) === action.filterKey ? {
        ...filter,
        operatorType: action.operatorType,
        ...inputComponentChanged ? { value: nextInitialValue } : {}
      } : filter);
      return {
        ...state,
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        },
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    }
    case "TERMS_FILTERS_SET_VALUE": {
      const filters = state.filters.map((filter) => getFilterKey(filter) === action.filterKey ? {
        ...filter,
        value: action.value
      } : filter);
      return {
        ...state,
        filters,
        terms: {
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        },
        result: {
          ...state.result,
          hasLocal: !1
        }
      };
    }
    case "TERMS_QUERY_SET":
      return {
        ...state,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          query: action.query
        })
      };
    case "TERMS_SET": {
      const filters = action.filters || [], types2 = [
        ...state.terms.types || [],
        //
        ...action.terms.types
      ].sort(sortTypes);
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters,
          types: types2
        }),
        filters,
        lastAddedFilter: null,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: {
          ...action.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            filters,
            operatorDefinitions: state.definitions.operators
          })
        }
      };
    }
    case "TERMS_TYPE_ADD": {
      const types2 = [
        ...state.terms.types || [],
        //
        action.schemaType
      ].sort(sortTypes), documentTypesNarrowed = narrowDocumentTypes({
        fieldDefinitions: state.definitions.fields,
        filters: [],
        types: types2
      }), filters = state.filters.filter((f) => {
        const fieldDefinition = getFieldFromFilter(state.definitions.fields, f);
        return fieldDefinition ? fieldDefinition.documentTypes.length === 0 ? !0 : documentTypesNarrowed.every(
          (type) => fieldDefinition.documentTypes.findIndex((t2) => t2 === type) > -1
        ) : !0;
      });
      return {
        ...state,
        documentTypesNarrowed,
        filters,
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          filter: generateFilterQuery({
            fieldDefinitions: state.definitions.fields,
            filterDefinitions: state.definitions.filters,
            operatorDefinitions: state.definitions.operators,
            filters
          }),
          types: types2
        })
      };
    }
    case "TERMS_TYPE_REMOVE": {
      const types2 = (state.terms.types || []).filter((s) => s !== action.schemaType);
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters: state.filters,
          types: types2
        }),
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          types: types2
        })
      };
    }
    case "TERMS_TYPES_CLEAR": {
      const types2 = [];
      return {
        ...state,
        documentTypesNarrowed: narrowDocumentTypes({
          fieldDefinitions: state.definitions.fields,
          filters: state.filters,
          types: types2
        }),
        cursor: null,
        nextCursor: null,
        result: {
          ...state.result,
          loaded: !1,
          hasLocal: !1
        },
        terms: stripRecent({
          ...state.terms,
          types: []
        })
      };
    }
    default:
      return state;
  }
}
function stripRecent(terms) {
  if (isRecentSearchTerms(terms)) {
    const { __recent, ...rest } = terms;
    return rest;
  }
  return terms;
}
function deduplicate(hits) {
  const hitsById = hits.reduce((map, hit) => {
    const id2 = getPublishedId(hit.hit._id);
    return {
      ...map,
      [id2]: hit
    };
  }, {});
  return Object.values(hitsById);
}
function SearchProvider({ children, fullscreen }) {
  const onCloseRef = React.useRef(null), [searchCommandList, setSearchCommandList] = React.useState(null), schema2 = useSchema(), currentUser = useCurrentUser(), {
    search: { operators: operators2, filters, enableLegacySearch }
  } = useSource(), { fieldDefinitions, filterDefinitions: filterDefinitions2, operatorDefinitions: operatorDefinitions2 } = React.useMemo(() => ({
    fieldDefinitions: createFieldDefinitionDictionary(createFieldDefinitions(schema2, filters)),
    filterDefinitions: createFilterDefinitionDictionary(filters),
    operatorDefinitions: createOperatorDefinitionDictionary(operators2)
  }), [filters, operators2, schema2]), initialState2 = React.useMemo(
    () => initialSearchState({
      currentUser,
      fullscreen,
      definitions: {
        fields: fieldDefinitions,
        operators: operatorDefinitions2,
        filters: filterDefinitions2
      },
      pagination: {
        cursor: null,
        nextCursor: null
      },
      enableLegacySearch
    }),
    [
      currentUser,
      fieldDefinitions,
      filterDefinitions2,
      fullscreen,
      operatorDefinitions2,
      enableLegacySearch
    ]
  ), [state, dispatch] = React.useReducer(searchReducer, initialState2), { documentTypesNarrowed, filters: currentFilters, ordering, cursor, result, terms } = state, isMountedRef = React.useRef(!1), previousOrderingRef = React.useRef(initialState2.ordering), previousCursorRef = React.useRef(initialState2.cursor), previousTermsRef = React.useRef(initialState2.terms), { handleSearch, searchState } = useSearch({
    initialState: { ...result, terms },
    onComplete: (searchResult) => dispatch({ ...searchResult, type: "SEARCH_REQUEST_COMPLETE" }),
    onError: (error) => dispatch({ error, type: "SEARCH_REQUEST_ERROR" }),
    onStart: () => dispatch({ type: "SEARCH_REQUEST_START" }),
    schema: schema2
  }), hasValidTerms = hasSearchableTerms({ terms }), documentTypes = documentTypesNarrowed.map((documentType) => schema2.get(documentType)), completeFilters = currentFilters.filter(
    (filter) => validateFilter({
      fieldDefinitions,
      filter,
      filterDefinitions: filterDefinitions2,
      operatorDefinitions: operatorDefinitions2
    })
  ), handleSetOnClose = React.useCallback((onClose) => {
    onCloseRef.current = onClose;
  }, []);
  return React.useEffect(() => {
    var _a2, _b;
    const orderingChanged = !isEqual__default.default(ordering, previousOrderingRef.current), cursorChanged = cursor !== previousCursorRef.current, termsChanged = !isEqual__default.default(terms, previousTermsRef.current);
    if (orderingChanged || cursorChanged || termsChanged) {
      let sortLabel = "findability-sort:";
      (ordering != null && ordering.customMeasurementLabel || ordering.sort) && (sortLabel += (ordering == null ? void 0 : ordering.customMeasurementLabel) || `${(_a2 = ordering.sort) == null ? void 0 : _a2.field} ${(_b = ordering.sort) == null ? void 0 : _b.direction}`), handleSearch({
        options: {
          // Comments prepended to each query for future measurement
          comments: [
            ...isRecentSearchTerms(terms) ? [`findability-recent-search:${terms.__recent.index}`] : [],
            `findability-selected-types:${terms.types.length}`,
            sortLabel,
            "findability-source: global",
            `findability-filter-count:${completeFilters.length}`
          ],
          limit: SEARCH_LIMIT,
          skipSortByScore: ordering.ignoreScore,
          ...ordering.sort ? { sort: [ordering.sort] } : {},
          cursor: cursor || void 0
        },
        terms: {
          ...terms,
          // Narrow document type search
          ...documentTypes ? { types: documentTypes } : {}
        }
      }), previousCursorRef.current = cursor;
    }
    previousOrderingRef.current = ordering, previousTermsRef.current = terms;
  }, [
    completeFilters.length,
    currentFilters,
    documentTypes,
    handleSearch,
    hasValidTerms,
    ordering,
    searchState.terms,
    terms,
    cursor
  ]), React.useEffect(() => {
    !hasValidTerms && isMountedRef != null && isMountedRef.current && result.hits.length > 0 && dispatch({ type: "SEARCH_CLEAR" }), isMountedRef.current = !0;
  }, [dispatch, hasValidTerms, result.hits, terms.query, terms.types]), /* @__PURE__ */ jsxRuntime.jsx(
    _singletons.SearchContext.Provider,
    {
      value: {
        dispatch,
        onClose: onCloseRef == null ? void 0 : onCloseRef.current,
        searchCommandList,
        setSearchCommandList,
        setOnClose: handleSetOnClose,
        state: {
          ...state,
          fullscreen
        }
      },
      children
    }
  );
}
const SearchButton = React.forwardRef(function({ onClick }, ref) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      "aria-label": t2("search.action-open-aria-label"),
      "data-testid": "studio-search",
      icon: icons.SearchIcon,
      tooltipProps: {
        content: t2("search.button.tooltip"),
        hotkeys: [GLOBAL_SEARCH_KEY_MODIFIER, GLOBAL_SEARCH_KEY.toUpperCase()],
        portal: !0
      },
      onClick,
      mode: "bleed",
      ref
    }
  );
}), InnerCard = styledComponents.styled(ui.Card)`
  flex-direction: column;
  overflow: hidden;
  overflow: clip;
  pointer-events: all;
  position: relative;
`, SearchDialogBox = styledComponents.styled(ui.Box)`
  height: 100%;
  left: 0;
  overflow: hidden;
  overflow: clip;
  pointer-events: none;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 1;
`;
function SearchDialog({ onClose, onOpen, open }) {
  const [inputElement, setInputElement] = React.useState(null), { scheme } = useColorScheme();
  useTranslation();
  const {
    state: { filtersVisible, terms }
  } = useSearchState(), hasValidTerms = hasSearchableTerms({ terms });
  return /* @__PURE__ */ jsxRuntime.jsx(SearchWrapper, { hasValidTerms, onClose, onOpen, open, children: open && /* @__PURE__ */ jsxRuntime.jsx(ui.Portal, { children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !supportsTouch, returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsx(SearchDialogBox, { children: /* @__PURE__ */ jsxRuntime.jsxs(InnerCard, { display: "flex", height: "fill", scheme, tone: "default", children: [
    /* @__PURE__ */ jsxRuntime.jsx(SearchHeader, { onClose, ref: setInputElement }),
    filtersVisible && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(Filters, {}) }),
    hasValidTerms ? /* @__PURE__ */ jsxRuntime.jsx(SearchResults, { inputElement }) : /* @__PURE__ */ jsxRuntime.jsx(RecentSearches, { inputElement })
  ] }) }) }) }) });
}
function StudioLogo(props2) {
  const { title } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, "data-testid": "studio-logo", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", children: title }) });
}
function StudioActiveToolLayout(props2) {
  const { activeTool } = props2;
  return React.createElement(activeTool.component, { tool: activeTool });
}
function NoToolsScreen() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, shadow: 1, tone: "caution", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, marginLeft: 3, space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "medium", children: "No configured tools" }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: "Please configure a tool in your Studio configuration." }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        "a",
        {
          href: "https://www.sanity.io/docs/studio-tools",
          rel: "noreferrer",
          target: "_blank",
          children: "Learn how to add a tool \u2192"
        }
      ) })
    ] })
  ] }) }) }) }) });
}
function RedirectingScreen(props2) {
  const { reason = "Redirecting\u2026" } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, shadow: 1, tone: "primary", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DoubleChevronRightIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, marginLeft: 3, space: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "bold", children: reason }) })
  ] }) }) }) }) });
}
function ToolNotFoundScreen(props2) {
  const { toolName } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, radius: 2, shadow: 1, tone: "caution", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, marginLeft: 3, space: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { as: "h1", size: 1, weight: "medium", children: [
      "Tool not found: ",
      /* @__PURE__ */ jsxRuntime.jsx("code", { children: toolName })
    ] }) })
  ] }) }) }) }) });
}
const WORKSPACES_DOCS_URL = "https://www.sanity.io/docs/workspaces", useWorkspaceAuthStates = createHookFromObservableFactory(
  (workspaces) => rxjs.combineLatest(
    workspaces.map(
      (workspace) => (
        // eslint-disable-next-line max-nested-callbacks
        workspace.auth.state.pipe(operators.map((state) => [workspace.name, state]))
      )
    )
  ).pipe(operators.map((entries) => Object.fromEntries(entries)))
), STATE_TITLES = {
  "logged-in": "",
  "logged-out": "Signed out",
  "no-access": ""
}, Media$1 = styledComponents.styled.div`
  width: ${(props2) => props2.$size === "small" ? "25px" : "41px"};
  height: ${(props2) => props2.$size === "small" ? "25px" : "41px"};

  svg {
    width: 100%;
    height: 100%;
  }
`, WorkspacePreviewIcon = ({
  icon,
  size = "small"
}) => {
  const iconComponent = React.useMemo(() => createIcon(icon), [icon]);
  return /* @__PURE__ */ jsxRuntime.jsx(Media$1, { $size: size, children: iconComponent });
}, createIcon = (icon) => {
  if (reactIs.isValidElementType(icon)) return React.createElement(icon);
  if (React.isValidElement(icon)) return icon;
};
function WorkspacePreview(props2) {
  const { state, subtitle, selected, title, icon, iconRight } = props2, iconRightComponent = React.useMemo(() => createIcon(iconRight), [iconRight]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: "none", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(WorkspacePreviewIcon, { icon, size: "small" }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: title }),
      subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: subtitle })
    ] }),
    state && STATE_TITLES[state] && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, textOverflow: "ellipsis", children: STATE_TITLES[state] }) }),
    (selected || iconRightComponent) && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 4, paddingLeft: 3, paddingRight: 2, children: [
      selected && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}) }),
      iconRightComponent && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: iconRightComponent })
    ] })
  ] });
}
const LINKS = [
  {
    url: "https://slack.sanity.io/",
    i18nKey: "workspaces.community-title",
    title: "Community"
  },
  {
    url: "https://www.sanity.io/docs",
    i18nKey: "workspaces.docs-title",
    title: "Docs"
  },
  {
    url: "https://www.sanity.io/legal/privacy",
    i18nKey: "workspaces.privacy-title",
    title: "Privacy"
  },
  {
    url: "https://www.sanity.io",
    i18nKey: "workspaces.sanity-io-title",
    title: "sanity.io"
  }
], StyledText$1 = styledComponents.styled(ui.Text)`
  a {
    color: inherit;
  }
`;
function Layout(props2) {
  const { children, footer, header } = props2;
  return useTranslation(), /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 6, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 3, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
      typeof header == "object" && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: header }),
      typeof header == "string" && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { align: "center", size: 1, children: header }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !!header, borderBottom: !!footer, children }) }),
      footer && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: footer })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 4, justify: "center", align: "center", paddingBottom: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 3, children: /* @__PURE__ */ jsxRuntime.jsx(logos.SanityLogo, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 2, children: LINKS.map((link, index) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(StyledText$1, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx("a", { href: link.url, target: "_blank", rel: "noopener noreferrer", children: link.title }) }),
        index < LINKS.length - 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: "\u2022" })
      ] }, link.title)) })
    ] })
  ] });
}
function WorkspaceAuth() {
  var _a2;
  const workspaces = useWorkspaces(), { activeWorkspace, setActiveWorkspace } = useActiveWorkspace(), [authStates] = useWorkspaceAuthStates(workspaces), [selectedWorkspaceName, setSelectedWorkspaceName] = React.useState(
    (activeWorkspace == null ? void 0 : activeWorkspace.name) || null
  ), selectedWorkspace = workspaces.length === 1 ? workspaces[0] : workspaces.find((workspace) => workspace.name === selectedWorkspaceName), LoginComponent = (_a2 = selectedWorkspace == null ? void 0 : selectedWorkspace.auth) == null ? void 0 : _a2.LoginComponent, handleBack = React.useCallback(() => setSelectedWorkspaceName(null), []), { t: t2 } = useTranslation();
  return authStates ? LoginComponent && selectedWorkspace ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    workspaces.length > 1 && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: icons.ArrowLeftIcon,
        mode: "bleed",
        onClick: handleBack,
        text: t2("workspaces.action.choose-another-workspace")
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      Layout,
      {
        header: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
          WorkspacePreview,
          {
            icon: selectedWorkspace.icon,
            title: selectedWorkspace.title,
            subtitle: selectedWorkspace == null ? void 0 : selectedWorkspace.subtitle
          }
        ) }),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 2, paddingBottom: 3, paddingTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
          LoginComponent,
          {
            projectId: selectedWorkspace.projectId,
            redirectPath: window.location.pathname.startsWith(selectedWorkspace.basePath) ? (
              // NOTE: the fragment cannot be preserved because it's used
              // to transfer an sid to a token
              `${window.location.pathname}${window.location.search}`
            ) : selectedWorkspace.basePath
          },
          selectedWorkspaceName
        ) })
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(
    Layout,
    {
      header: t2("workspaces.choose-your-workspace-label"),
      footer: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          as: "a",
          href: WORKSPACES_DOCS_URL,
          icon: icons.AddIcon,
          mode: "bleed",
          rel: "noopener noreferrer",
          size: "large",
          target: "__blank",
          text: t2("workspaces.action.add-workspace")
        }
      ) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, paddingX: 1, paddingY: 2, children: workspaces.map((workspace) => {
        const state = authStates[workspace.name].authenticated ? "logged-in" : workspace.auth.LoginComponent ? "logged-out" : "no-access";
        return /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            as: "button",
            radius: 2,
            padding: 2,
            onClick: () => {
              state === "logged-in" && workspace.name !== activeWorkspace.name && setActiveWorkspace(workspace.name), state === "logged-out" && setSelectedWorkspaceName(workspace.name);
            },
            children: /* @__PURE__ */ jsxRuntime.jsx(
              WorkspacePreview,
              {
                icon: workspace == null ? void 0 : workspace.icon,
                iconRight: icons.ChevronRightIcon,
                state,
                subtitle: workspace == null ? void 0 : workspace.subtitle,
                title: (workspace == null ? void 0 : workspace.title) || workspace.name
              }
            )
          },
          workspace.name
        );
      }) })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 });
}
const StyledMenu$3 = styledComponents.styled(ui.Menu)`
  max-width: 350px;
  min-width: 250px;
`, POPOVER_PROPS$1 = {
  constrainSize: !0,
  fallbackPlacements: ["bottom-end", "bottom"],
  placement: "bottom-end"
};
function WorkspaceMenuButton() {
  const workspaces = useWorkspaces(), { activeWorkspace, setActiveWorkspace } = useActiveWorkspace(), [authStates] = useWorkspaceAuthStates(workspaces), { navigateUrl } = router.useRouter(), { t: t2 } = useTranslation();
  if (!(workspaces.length > 1))
    return null;
  const disabled = !authStates;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: t2("workspaces.select-workspace-tooltip"), disabled, portal: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { disabled, mode: "bleed", padding: 2, width: "fill", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: activeWorkspace.title }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) })
      ] }) }) }) }),
      id: "workspace-menu",
      menu: !disabled && authStates ? /* @__PURE__ */ jsxRuntime.jsx(StyledMenu$3, { children: workspaces.map((workspace) => {
        const state = authStates[workspace.name].authenticated ? "logged-in" : workspace.auth.LoginComponent ? "logged-out" : "no-access", handleSelectWorkspace = () => {
          state === "logged-in" && workspace.name !== activeWorkspace.name && setActiveWorkspace(workspace.name), state === "logged-out" && navigateUrl({ path: workspace.basePath });
        }, isSelected = workspace.name === activeWorkspace.name;
        return /* @__PURE__ */ jsxRuntime.jsx(
          TooltipDelayGroupProvider.MenuItem,
          {
            badgeText: STATE_TITLES[state],
            iconRight: isSelected ? icons.CheckmarkIcon : void 0,
            onClick: handleSelectWorkspace,
            pressed: isSelected,
            preview: /* @__PURE__ */ jsxRuntime.jsx(WorkspacePreviewIcon, { icon: workspace.icon, size: "small" }),
            selected: isSelected,
            __unstable_subtitle: workspace.subtitle,
            __unstable_space: 1,
            text: (workspace == null ? void 0 : workspace.title) || workspace.name
          },
          workspace.name
        );
      }) }) : void 0,
      popover: POPOVER_PROPS$1
    }
  );
}
function AuthenticateScreen() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", overflow: "auto", paddingX: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { height: "fill", direction: "column", align: "center", justify: "center", paddingTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(WorkspaceAuth, {}) }) }) });
}
function ConfigErrorsScreen() {
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: "TODO: implement config errors screen" });
}
const ScreenReaderLabel = styledComponents.styled.label`
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  overflow: clip;
  position: absolute;
  white-space: nowrap;
  width: 1px;
`;
function CorsOriginErrorScreen(props2) {
  const { projectId } = props2, origin = window.location.origin, corsUrl = React.useMemo(() => {
    const url = new URL(`https://sanity.io/manage/project/${projectId}/api`);
    return url.searchParams.set("cors", "add"), url.searchParams.set("origin", origin), url.searchParams.set("credentials", ""), url.toString();
  }, [origin, projectId]);
  return React.useEffect(() => {
    const handleFocus = () => {
      window.location.reload();
    };
    return window.addEventListener("focus", handleFocus), () => {
      window.removeEventListener("focus", handleFocus);
    };
  }, []), /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      id: "cors-error-dialog",
      header: "Before you continue...",
      width: 1,
      footer: {
        confirmButton: {
          text: "Continue",
          iconRight: icons.LaunchIcon,
          as: "a",
          href: corsUrl,
          target: "_blank",
          rel: "noopener noreferrer",
          tone: "primary"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { children: [
          "To access your content, you need to ",
          /* @__PURE__ */ jsxRuntime.jsx("b", { children: "add the following URL as a CORS origin" }),
          " to your Sanity project."
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ScreenReaderLabel, { "aria-hidden": "true", children: "CORS URL to be added" }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { value: origin, readOnly: !0 })
      ] })
    }
  ) });
}
function NotAuthenticatedScreen() {
  const [currentUser, setCurrentUser] = React.useState(null), [error, handleError] = React.useState(null);
  if (error) throw error;
  const { activeWorkspace } = useActiveWorkspace(), handleLogout = React.useCallback(() => {
    var _a2, _b;
    (_b = (_a2 = activeWorkspace.auth).logout) == null || _b.call(_a2);
  }, [activeWorkspace]);
  React.useEffect(() => {
    const subscription = activeWorkspace.auth.state.subscribe({
      next: ({ currentUser: user }) => {
        setCurrentUser(user);
      },
      error: handleError
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [activeWorkspace]);
  const providerTitle = getProviderTitle(currentUser == null ? void 0 : currentUser.provider), providerHelp = providerTitle ? ` through ${providerTitle}` : "";
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      id: "not-authorized-dialog",
      header: "Not authorized",
      width: 1,
      footer: {
        confirmButton: {
          text: "Sign out",
          onClick: handleLogout,
          tone: "default"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "You are not authorized to access this studio. Maybe you could ask someone to invite you to collaborate on this project?" }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { children: [
          "If you think this is an error, verify that you are signed in with the correct account. You are currently signed in as",
          " ",
          /* @__PURE__ */ jsxRuntime.jsxs("strong", { children: [
            currentUser == null ? void 0 : currentUser.name,
            " (",
            currentUser == null ? void 0 : currentUser.email,
            ")"
          ] }),
          providerHelp,
          "."
        ] })
      ] })
    }
  ) });
}
function NotFoundScreen(props2) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", sizing: "border", tone: "caution", display: "flex", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "row", justify: "center", flex: 1, align: "center", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h1", children: "Workspace not found" }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        text: "Go to default workspace",
        onClick: props2.onNavigateToDefaultWorkspace,
        mode: "ghost"
      }
    ) })
  ] }) }) });
}
function renderPath(path) {
  return path.map((segment) => segment.kind === "type" ? `${segment.name || "<unnamed>"}(${segment.type})` : segment.kind === "property" ? segment.name : null).filter(Boolean).join(" > ");
}
function reportWarnings(schema2) {
  const problemGroups = schema2._validation, groupsWithWarnings = problemGroups == null ? void 0 : problemGroups.filter(
    (group2) => group2.problems.some((problem) => problem.severity === "warning")
  );
  (groupsWithWarnings == null ? void 0 : groupsWithWarnings.length) !== 0 && (console.groupCollapsed(`\u26A0\uFE0F Schema has ${groupsWithWarnings == null ? void 0 : groupsWithWarnings.length} warnings`), groupsWithWarnings == null || groupsWithWarnings.forEach((group2) => {
    const path = renderPath(group2.path);
    console.group(`%cAt ${path}`, "color: #FF7636"), group2.problems.forEach((problem) => {
      console.log(problem.message);
    }), console.groupEnd();
  }), console.groupEnd());
}
const TONES = {
  error: "critical",
  warning: "caution"
}, SegmentSpan = styledComponents.styled.code`
  && {
    background: none;
    color: inherit;
  }
`, ErrorMessageText = styledComponents.styled(ui.Text)`
  white-space: pre-line;
`;
function SchemaProblemGroups(props2) {
  const { problemGroups } = props2;
  useTranslation();
  const items = React.useMemo(() => {
    const ret = [];
    for (const problemGroup of problemGroups)
      for (const problem of problemGroup.problems)
        ret.push({ group: problemGroup, problem });
    return ret;
  }, [problemGroups]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 4, children: items.map(({ group: group2, problem }, i) => {
    const isError2 = problem.severity === "error", isWarning = problem.severity === "warning", schemaType = getTypeInfo(group2);
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { border: !0, padding: 4, radius: 2, tone: TONES[problem.severity], children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
          isError2 && /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}),
          isWarning && /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {})
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: schemaType ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          capitalize__default.default(schemaType.type),
          ' type "',
          schemaType.name,
          '"'
        ] }) : null }) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, overflow: "auto", padding: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Breadcrumbs,
        {
          separator: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "\u2192" }),
          children: group2.path.map((segment, j) => {
            if (segment.kind === "type") {
              const text = `${_renderSegmentName(
                segment.name || `<anonymous ${segment.type}>`
              )}:${segment.type}`;
              return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { title: text, size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(SegmentSpan, { children: text }) }, j);
            }
            return segment.kind === "property" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { title: segment.name, size: 1, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(SegmentSpan, { children: segment.name }) }, j) : null;
          })
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "ul", marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ErrorMessageText, { muted: !0, size: 1, children: problem.message }),
        problem.helpId && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          "a",
          {
            href: generateHelpUrl_esm.generateHelpUrl(problem.helpId),
            target: "_blank",
            rel: "noopener noreferrer",
            children: "View documentation \u2192"
          }
        ) })
      ] }) }) })
    ] }, i);
  }) });
}
function getTypeInfo(problem) {
  const first = problem.path[0];
  return first.kind === "type" ? { name: first.name || `<anonymous ${first.type}>`, type: first.type } : null;
}
function _renderSegmentName(str) {
  return str != null && str.startsWith("<unnamed_type_@_index") ? `[${str.slice(1, -1).split("_")[4]}]` : str;
}
function SchemaErrorsScreen({ schema: schema2 }) {
  var _a2;
  const groupsWithErrors = ((_a2 = schema2._validation) == null ? void 0 : _a2.filter(
    (group2) => group2.problems.some((problem) => problem.severity === "error")
  )) || [];
  return React.useEffect(() => reportWarnings(schema2), [schema2]), /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { height: "fill", overflow: "auto", paddingY: [4, 5, 6, 7], paddingX: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h1", children: "Schema errors" }),
    /* @__PURE__ */ jsxRuntime.jsx(SchemaProblemGroups, { problemGroups: groupsWithErrors })
  ] }) }) });
}
function StudioErrorBoundary({
  children,
  heading = "An error occured"
}) {
  const [{ error }, setError] = React.useState({ error: null }), message = isRecord$4(error) && typeof error.message == "string" && error.message, stack = isRecord$4(error) && typeof error.stack == "string" && error.stack, handleResetError = React.useCallback(() => setError({ error: null }), []);
  return useHotModuleReload.useHotModuleReload(handleResetError), error instanceof CorsOriginError ? /* @__PURE__ */ jsxRuntime.jsx(CorsOriginErrorScreen, { projectId: error == null ? void 0 : error.projectId }) : error instanceof SchemaError ? /* @__PURE__ */ jsxRuntime.jsx(SchemaErrorsScreen, { schema: error.schema }) : error ? /* @__PURE__ */ jsxRuntime.jsx(
    ui.Card,
    {
      height: "fill",
      overflow: "auto",
      paddingY: [4, 5, 6, 7],
      paddingX: 4,
      sizing: "border",
      tone: "critical",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { children: heading }),
        /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { onClick: handleResetError, text: "Retry", tone: "default" }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, radius: 2, overflow: "auto", padding: 4, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
          message && /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsxs("strong", { children: [
            "Error: ",
            message
          ] }) }),
          stack && /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { size: 1, children: stack })
        ] }) })
      ] }) })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: setError, children });
}
const SearchFullscreenPortalCard = styledComponents.styled(ui.Card)`
  height: 100%;
  left: 0;
  overflow: hidden;
  overflow: clip;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 200;
`;
function StudioLayout() {
  const Layout2 = useLayoutComponent();
  return /* @__PURE__ */ jsxRuntime.jsx(Layout2, {});
}
function StudioLayoutComponent() {
  var _a2;
  const { name, title, tools } = useWorkspace(), router$1 = router.useRouter(), activeToolName = router.useRouterState(
    React.useCallback(
      (routerState) => typeof routerState.tool == "string" ? routerState.tool : void 0,
      []
    )
  ), activeTool = React.useMemo(
    () => tools.find((tool) => tool.name === activeToolName),
    [activeToolName, tools]
  ), [searchFullscreenOpen, setSearchFullscreenOpen] = React.useState(!1), [searchFullscreenPortalEl, setSearchFullscreenPortalEl] = React.useState(
    null
  ), [searchOpen, setSearchOpen] = React.useState(!1), documentTitle = React.useMemo(() => {
    const mainTitle = title || startCase__default.default(name);
    return activeToolName ? `${startCase__default.default(activeToolName)} | ${mainTitle}` : mainTitle;
  }, [activeToolName, name, title]), toolControlsDocumentTitle = !!(activeTool != null && activeTool.controlsDocumentTitle);
  React.useEffect(() => {
    toolControlsDocumentTitle || (document.title = documentTitle);
  }, [documentTitle, toolControlsDocumentTitle]);
  const handleSearchFullscreenOpenChange = React.useCallback((open) => {
    setSearchFullscreenOpen(open);
  }, []), handleSearchOpenChange = React.useCallback((open) => {
    setSearchOpen(open);
  }, []), navbarContextValue = React.useMemo(
    () => ({
      searchFullscreenOpen,
      searchFullscreenPortalEl,
      searchOpen,
      onSearchFullscreenOpenChange: handleSearchFullscreenOpenChange,
      onSearchOpenChange: handleSearchOpenChange
    }),
    [
      searchFullscreenOpen,
      searchFullscreenPortalEl,
      searchOpen,
      handleSearchFullscreenOpenChange,
      handleSearchOpenChange
    ]
  ), Navbar = useNavbarComponent(), ActiveToolLayout = useActiveToolLayoutComponent(), isLegacyDeskRedirect = !activeTool && (activeToolName === "desk" || !activeToolName) && typeof window < "u" && /\/desk(\/|$)/.test(window.location.pathname) && tools.some((tool) => tool.name === "structure");
  return React.useEffect(() => {
    isLegacyDeskRedirect && router$1.navigateUrl({
      path: window.location.pathname.replace(/\/desk/, "/structure"),
      replace: !0
    });
  }, [isLegacyDeskRedirect, router$1]), /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { "data-ui": "ToolScreen", direction: "column", height: "fill", "data-testid": "studio-layout", children: [
    /* @__PURE__ */ jsxRuntime.jsx(_singletons.NavbarContext.Provider, { value: navbarContextValue, children: /* @__PURE__ */ jsxRuntime.jsx(Navbar, {}) }),
    isLegacyDeskRedirect && /* @__PURE__ */ jsxRuntime.jsx(RedirectingScreen, {}),
    tools.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(NoToolsScreen, {}),
    tools.length > 0 && !activeTool && activeToolName && !isLegacyDeskRedirect && /* @__PURE__ */ jsxRuntime.jsx(ToolNotFoundScreen, { toolName: activeToolName }),
    searchFullscreenOpen && /* @__PURE__ */ jsxRuntime.jsx(SearchFullscreenPortalCard, { ref: setSearchFullscreenPortalEl, overflow: "auto" }),
    /* @__PURE__ */ jsxRuntime.jsx(StudioErrorBoundary, { heading: `The ${activeTool == null ? void 0 : activeTool.name} tool crashed`, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: 1, hidden: searchFullscreenOpen, children: activeTool && activeToolName && /* @__PURE__ */ jsxRuntime.jsx(
      router.RouteScope,
      {
        scope: activeToolName,
        __unsafe_disableScopedSearchParams: (_a2 = activeTool.router) == null ? void 0 : _a2.__unsafe_disableScopedSearchParams,
        children: /* @__PURE__ */ jsxRuntime.jsx(React.Suspense, { fallback: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }), children: /* @__PURE__ */ jsxRuntime.jsx(ActiveToolLayout, { activeTool }) })
      }
    ) }) }, activeTool == null ? void 0 : activeTool.name)
  ] });
}
function pickToolMenuComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.toolMenu;
}
function pickNavbarComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.navbar;
}
function pickLayoutComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.layout;
}
function pickActiveToolLayoutComponent(plugin) {
  var _a2, _b;
  return (_b = (_a2 = plugin.studio) == null ? void 0 : _a2.components) == null ? void 0 : _b.activeToolLayout;
}
function useToolMenuComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioToolMenu,
    pick: pickToolMenuComponent
  });
}
function useNavbarComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioNavbar,
    pick: pickNavbarComponent
  });
}
function useLayoutComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioLayoutComponent,
    pick: pickLayoutComponent
  });
}
function useActiveToolLayoutComponent() {
  return useMiddlewareComponents({
    defaultComponent: StudioActiveToolLayout,
    pick: pickActiveToolLayoutComponent
  });
}
function ConfigIssuesButton() {
  var _a2;
  const groupsWithWarnings = ((_a2 = useSchema()._validation) == null ? void 0 : _a2.filter(
    (group2) => group2.problems.some((problem) => problem.severity === "warning")
  )) || [], { scheme } = useColorScheme(), { t: t2 } = useTranslation(), dialogId = React.useId(), [isDialogOpen, setDialogOpen] = React.useState(!1), [buttonElement, setButtonElement] = React.useState(null), handleOpen = React.useCallback(() => setDialogOpen(!0), []), handleClose = React.useCallback(() => {
    setDialogOpen(!1), buttonElement && buttonElement.focus();
  }, [buttonElement]);
  return groupsWithWarnings.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      StatusButton,
      {
        icon: icons.WarningOutlineIcon,
        mode: "bleed",
        onClick: handleOpen,
        ref: setButtonElement,
        selected: isDialogOpen,
        tone: "caution",
        "aria-label": t2("configuration-issues.button.label"),
        tooltipProps: { scheme, content: t2("configuration-issues.button.tooltip") }
      }
    ),
    isDialogOpen && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Dialog,
      {
        header: "Configuration issues",
        width: 2,
        onClickOutside: handleClose,
        onClose: handleClose,
        scheme,
        id: dialogId,
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { as: "h2", size: 1, weight: "medium", children: [
              "Found ",
              groupsWithWarnings.length,
              " schema warnings"
            ] }),
            " ",
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "Configuration checks are only performed during development and will not be visible in production builds" })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(SchemaProblemGroups, { problemGroups: groupsWithWarnings })
        ] })
      }
    )
  ] });
}
const TrialDialogViewed = telemetry.defineEvent({
  name: "Trial Dialog Viewed",
  version: 1,
  description: "User viewed a dialog or popover related to free trial"
}), TrialDialogDismissed = telemetry.defineEvent({
  name: "Trial Dialog Dismissed",
  version: 1,
  description: "User dismissed a dialog or popover related to free trial"
}), TrialDialogCTAClicked = telemetry.defineEvent({
  name: "Trial Dialog CTA Clicked",
  version: 1,
  description: "User clicked a CTA in a dialog or popover related to free trial"
});
function getTrialStage({
  showOnLoad,
  dialogId
}) {
  return showOnLoad && dialogId.toLowerCase() === "free-upgrade-popover" ? "trialStarted" : showOnLoad && dialogId.toLowerCase() === "trial-ending-popover" ? "trialEndingSoon" : showOnLoad && dialogId.toLowerCase() === "project-downgraded-to-free" ? "trialEnded" : !showOnLoad && dialogId.toLowerCase() === "after-trial-upgrade" ? "postTrial" : "trialActive";
}
const StyledButton$1 = styledComponents.styled(TooltipDelayGroupProvider.Button)`
  position: absolute;
  top: 12px;
  right: 12px;
  z-index: 20;
  background: transparent;
  border-radius: 9999px;
  box-shadow: none;
  color: white;
  --card-fg-color: white;
  :hover {
    --card-fg-color: white;
  }
`, Image$2 = styledComponents.styled.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 196px;
`, StyledDialog$1 = styledComponents.styled(TooltipDelayGroupProvider.Dialog)`
  > [data-ui='DialogCard'] {
    max-width: 22.5rem;
  }
`;
function DialogContent({
  onClose,
  onOpenNext,
  onOpenUrlCallback,
  content: content2,
  open
}) {
  var _a2, _b, _c, _d, _e;
  function handleClose() {
    onClose("xClick");
  }
  function handleClickOutside() {
    onClose("outsideClick");
  }
  function handleCTAClose() {
    onClose("ctaClicked");
  }
  const schemeValue = useColorSchemeValue();
  return open ? /* @__PURE__ */ jsxRuntime.jsxs(
    StyledDialog$1,
    {
      id: "free-trial-modal",
      onClose,
      onClickOutside: handleClickOutside,
      padding: !1,
      __unstable_hideCloseButton: !0,
      scheme: schemeValue,
      footer: {
        cancelButton: (_a2 = content2.secondaryButton) != null && _a2.text ? {
          text: content2.secondaryButton.text,
          mode: "bleed",
          tone: "default",
          onClick: handleClose
        } : void 0,
        confirmButton: {
          text: (_b = content2.ctaButton) == null ? void 0 : _b.text,
          mode: "default",
          tone: "primary",
          ...((_c = content2.ctaButton) == null ? void 0 : _c.action) === "openUrl" ? {
            href: content2.ctaButton.url,
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            onClick: onOpenUrlCallback
          } : {
            onClick: ((_d = content2.ctaButton) == null ? void 0 : _d.action) === "openNext" ? onOpenNext : handleCTAClose
          }
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          StyledButton$1,
          {
            icon: icons.CloseIcon,
            mode: "bleed",
            tone: "default",
            onClick: handleClose,
            tabIndex: -1,
            tooltipProps: null
          }
        ),
        content2.image && /* @__PURE__ */ jsxRuntime.jsx(Image$2, { src: content2.image.asset.url, alt: (_e = content2.image.asset.altText) != null ? _e : "" }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 3, direction: "column", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { size: 2, children: content2.headingText }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(UpsellDescriptionSerializer, { blocks: content2.descriptionText }) })
        ] })
      ]
    }
  ) : null;
}
const CenteredStroke = styledComponents.styled.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
`, SvgFilledOutline = ({ daysLeft, totalDays }) => {
  const progress = totalDays - daysLeft, percentage = Math.round(progress / totalDays * 100), radius = 10, strokeDasharray = 2 * Math.PI * radius, strokeDashOffset = strokeDasharray * ((100 - percentage) / 100), strokeWidth = 1.2, size = radius * 2 + strokeWidth;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(CenteredStroke, { children: /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: size,
      height: size,
      viewBox: `0 0 ${size} ${size}`,
      style: { transform: "rotate(-90deg)" },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "circle",
          {
            r: radius,
            cx: size / 2,
            cy: size / 2,
            fill: "transparent",
            strokeWidth,
            stroke: percentage > 75 ? color.yellow[600].hex : color.purple[400].hex
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "circle",
          {
            r: radius,
            cx: size / 2,
            cy: size / 2,
            fill: "transparent",
            strokeWidth,
            stroke: "var(--card-border-color)",
            strokeDasharray,
            strokeDashoffset: strokeDashOffset
          }
        )
      ]
    }
  ) }) });
}, FreeTrialButtonTopbar = React.forwardRef(function({ toggleShowContent, daysLeft, totalDays }, ref) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(
    TooltipDelayGroupProvider.Button,
    {
      mode: "bleed",
      onClick: toggleShowContent,
      ref,
      tooltipProps: {
        content: daysLeft ? t2("free-trial.tooltip.days-count", { count: daysLeft }) : t2("free-trial.tooltip.trial-finished")
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.BoltIcon, {}) }),
        daysLeft > 0 && /* @__PURE__ */ jsxRuntime.jsx(SvgFilledOutline, { daysLeft, totalDays })
      ]
    }
  );
}), FreeTrialButtonSidebar = React.forwardRef(function({ toggleShowContent, daysLeft }, ref) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      ref,
      icon: icons.BoltIcon,
      justify: "flex-start",
      mode: "bleed",
      size: "large",
      onClick: toggleShowContent,
      text: daysLeft ? t2("user-menu.action.free-trial", { count: daysLeft }) : t2("user-menu.action.free-trial-finished")
    }
  );
}), useFreeTrialContext = () => {
  const context = React.useContext(_singletons.FreeTrialContext);
  if (!context)
    throw new Error("useFreeTrial must be used within a FreeTrialProvider");
  return context;
}, Image$1 = styledComponents.styled.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 180px;
`;
function PopoverContent({ content: content2, handleClose, handleOpenNext }) {
  var _a2, _b, _c, _d, _e;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 3, overflow: "hidden", width: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Container, { width: 0, children: [
    content2.image && /* @__PURE__ */ jsxRuntime.jsx(Image$1, { src: content2.image.asset.url, alt: (_a2 = content2.image.asset.altText) != null ? _a2 : "" }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 3, direction: "column", children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { size: 1, children: content2.headingText }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(UpsellDescriptionSerializer, { blocks: content2.descriptionText }) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { width: "full", gap: 3, justify: "flex-end", padding: 3, children: [
      ((_b = content2.secondaryButton) == null ? void 0 : _b.text) && /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          mode: "bleed",
          text: content2.secondaryButton.text,
          tone: "default",
          onClick: () => handleClose("xClick")
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          mode: "default",
          tooltipProps: null,
          text: (_c = content2.ctaButton) == null ? void 0 : _c.text,
          autoFocus: !0,
          tone: "primary",
          ...((_d = content2.ctaButton) == null ? void 0 : _d.action) === "openUrl" ? {
            href: content2.ctaButton.url,
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a"
          } : {
            onClick: ((_e = content2.ctaButton) == null ? void 0 : _e.action) === "openNext" ? handleOpenNext : () => handleClose("ctaClicked")
          }
        }
      )
    ] })
  ] }) });
}
function FreeTrial({ type }) {
  const { data, showDialog, showOnLoad, toggleShowContent } = useFreeTrialContext(), scheme = useColorSchemeValue(), telemetry2 = react.useTelemetry(), [ref, setRef] = React.useState(null), [showPopover, setShowPopover] = React.useState(!1);
  React.useEffect(() => {
    ref && setShowPopover(!0);
  }, [ref]);
  const closeAndReOpen = React.useCallback(() => toggleShowContent(!0), [toggleShowContent]), toggleDialog = React.useCallback(() => {
    ref == null || ref.focus(), toggleShowContent(!1);
  }, [toggleShowContent, ref]), handleClose = React.useCallback(
    (dialogType) => (action) => {
      const dialog = (data == null ? void 0 : data.showOnLoad) || (data == null ? void 0 : data.showOnClick);
      dialog && telemetry2.log(TrialDialogDismissed, {
        dialogId: dialog.id,
        dialogRevision: dialog._rev,
        dialogType,
        source: "studio",
        trialDaysLeft: data.daysLeft,
        dialogTrialStage: getTrialStage({ showOnLoad, dialogId: dialog.id }),
        dialogDismissAction: action
      }), toggleDialog();
    },
    [data, toggleDialog, showOnLoad, telemetry2]
  ), handleDialogCTAClick = React.useCallback(
    (action) => () => {
      const dialog = (data == null ? void 0 : data.showOnLoad) || (data == null ? void 0 : data.showOnClick);
      dialog && telemetry2.log(TrialDialogCTAClicked, {
        dialogId: dialog.id,
        dialogRevision: dialog._rev,
        dialogType: "modal",
        source: "studio",
        trialDaysLeft: data.daysLeft,
        dialogTrialStage: getTrialStage({ showOnLoad, dialogId: dialog.id }),
        dialogCtaType: action === "openURL" ? "upgrade" : "learnMore"
      }), closeAndReOpen();
    },
    [data, closeAndReOpen, telemetry2, showOnLoad]
  ), handlePopoverCTAClick = React.useCallback(() => {
    data != null && data.showOnLoad && telemetry2.log(TrialDialogCTAClicked, {
      dialogId: data.showOnLoad.id,
      dialogRevision: data.showOnLoad._rev,
      dialogType: "popover",
      source: "studio",
      trialDaysLeft: data.daysLeft,
      dialogTrialStage: getTrialStage({ showOnLoad: !0, dialogId: data.showOnLoad.id }),
      dialogCtaType: "learnMore"
    }), closeAndReOpen();
  }, [data == null ? void 0 : data.showOnLoad, data == null ? void 0 : data.daysLeft, closeAndReOpen, telemetry2]), handleOnTrialButtonClick = React.useCallback(() => {
    data != null && data.showOnClick && telemetry2.log(TrialDialogViewed, {
      dialogId: data.showOnClick.id,
      dialogRevision: data.showOnClick._rev,
      dialogTrigger: "fromClick",
      dialogType: "modal",
      source: "studio",
      trialDaysLeft: data.daysLeft,
      dialogTrialStage: getTrialStage({ showOnLoad: !0, dialogId: data.showOnClick.id })
    }), closeAndReOpen();
  }, [data == null ? void 0 : data.showOnClick, data == null ? void 0 : data.daysLeft, telemetry2, closeAndReOpen]);
  if (!(data != null && data.id)) return null;
  const dialogToRender = showOnLoad ? data.showOnLoad : data.showOnClick;
  if (!dialogToRender) return null;
  const button = type === "sidebar" ? /* @__PURE__ */ jsxRuntime.jsx(
    FreeTrialButtonSidebar,
    {
      toggleShowContent: handleOnTrialButtonClick,
      daysLeft: data.daysLeft,
      ref: setRef
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    FreeTrialButtonTopbar,
    {
      toggleShowContent: handleOnTrialButtonClick,
      daysLeft: data.daysLeft,
      totalDays: data.totalDays,
      ref: setRef
    }
  );
  return (dialogToRender == null ? void 0 : dialogToRender.dialogType) === "popover" ? /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      open: showDialog && showPopover,
      size: 0,
      scheme,
      radius: 3,
      portal: !0,
      placement: type === "sidebar" ? "top" : "bottom-end",
      content: /* @__PURE__ */ jsxRuntime.jsx(
        PopoverContent,
        {
          content: dialogToRender,
          handleClose: handleClose("popover"),
          handleOpenNext: handlePopoverCTAClick
        }
      ),
      children: button
    }
  ) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    button,
    /* @__PURE__ */ jsxRuntime.jsx(
      DialogContent,
      {
        content: dialogToRender,
        onClose: handleClose("modal"),
        onOpenNext: handleDialogCTAClick("openNext"),
        onOpenUrlCallback: handleDialogCTAClick("openURL"),
        open: showDialog
      }
    )
  ] });
}
const SANITY_VERSION = "3.43.0", FreeTrialProvider = ({ children }) => {
  var _a2;
  const router$1 = router.useRouter(), [data, setData] = React.useState(null), [showDialog, setShowDialog] = React.useState(!1), [showOnLoad, setShowOnLoad] = React.useState(!1), client2 = useClient({ apiVersion: "2023-12-11" }), telemetry2 = react.useTelemetry();
  React.useEffect(() => {
    const dialog = data == null ? void 0 : data.showOnLoad;
    showDialog && showOnLoad && dialog && telemetry2.log(TrialDialogViewed, {
      dialogId: dialog.id,
      dialogRevision: dialog._rev,
      dialogTrialStage: getTrialStage({ showOnLoad, dialogId: dialog.id }),
      dialogTrigger: showOnLoad ? "auto" : "fromClick",
      dialogType: dialog.dialogType,
      source: "studio",
      trialDaysLeft: data.daysLeft
    });
  }, [showDialog, data, showOnLoad, telemetry2]);
  const searchParamsAsString = new URLSearchParams(router$1.state._searchParams).toString();
  React.useEffect(() => {
    const searchParams = new URLSearchParams(searchParamsAsString), queryParams = new URLSearchParams();
    queryParams.append("studioVersion", SANITY_VERSION);
    const trialState = searchParams.get("trialState");
    trialState && queryParams.append("trialState", trialState);
    const seenBefore = searchParams.get("seenBefore");
    seenBefore && queryParams.append("seenBefore", seenBefore);
    const queryURL = queryParams.get("trialState") ? "/journey/trial/override" : "/journey/trial", request = client2.observable.request({
      url: `${queryURL}?${queryParams.toString()}`
    }).subscribe(
      (response) => {
        setData(response), response != null && response.showOnLoad && (setShowOnLoad(!0), setShowDialog(!0));
      },
      () => {
      }
    );
    return () => {
      request.unsubscribe();
    };
  }, [client2, searchParamsAsString]);
  const toggleShowContent = React.useCallback(
    (closeAndReOpen = !1) => {
      var _a22;
      showOnLoad ? (setShowOnLoad(!1), setShowDialog(closeAndReOpen), (_a22 = data == null ? void 0 : data.showOnLoad) != null && _a22.id && client2.request({ url: `/journey/trial/${data == null ? void 0 : data.showOnLoad.id}`, method: "POST" })) : setShowDialog((p) => !p);
    },
    [client2, showOnLoad, (_a2 = data == null ? void 0 : data.showOnLoad) == null ? void 0 : _a2.id]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.FreeTrialContext.Provider, { value: { data, showDialog, toggleShowContent, showOnLoad }, children });
};
function SanityLogo() {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      width: "100%",
      height: "100%",
      viewBox: "0 0 33 33",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "100%", height: "100%", fill: "#EC5446" }),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M10.1637 8.5498C10.1637 11.3854 11.9461 13.0725 15.5143 13.9622L19.2955 14.8235C22.6725 15.5855 24.729 17.4783 24.729 20.5619C24.7553 21.9053 24.3107 23.2168 23.4698 24.2765C23.4698 21.1999 21.8499 19.5376 17.9425 18.538L14.2299 17.7086C11.257 17.0423 8.9623 15.4863 8.9623 12.1368C8.94666 10.8433 9.36932 9.58143 10.1637 8.5498Z",
            fill: "white"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M21.1463 19.8069C22.7591 20.8206 23.4662 22.2384 23.4662 24.2729C22.1313 25.953 19.7861 26.8958 17.0297 26.8958C12.3899 26.8958 9.1427 24.6521 8.42111 20.7533H12.8769C13.4506 22.5432 14.9695 23.3726 16.9972 23.3726C19.4722 23.3726 21.1175 22.0753 21.1499 19.7998",
            fill: "#F8B1AA"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M12.4801 12.7536C11.7436 12.3236 11.1394 11.7057 10.7316 10.9656C10.3238 10.2255 10.1276 9.3907 10.1638 8.54984C11.4518 6.88396 13.6923 5.8667 16.4235 5.8667C21.1499 5.8667 23.8848 8.31945 24.5595 11.7717H20.2732C19.8006 10.4107 18.6172 9.35089 16.4596 9.35089C14.1541 9.35089 12.5811 10.6694 12.4909 12.7536",
            fill: "#F8B1AA"
          }
        )
      ]
    }
  );
}
const LOGO_MARK_SIZE = 25, RADIUS = 2, LogoMarkContainer = styledComponents.styled(ui.Card).attrs({
  overflow: "hidden",
  radius: RADIUS
})`
  height: ${LOGO_MARK_SIZE}px;
  width: ${LOGO_MARK_SIZE}px;
`, StyledCard$1 = styledComponents.styled(ui.Card)`
  border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[RADIUS])};
  display: flex;
  outline: none;
  text-decoration: none;
  &:focus-visible {
    box-shadow: ${({ theme: theme2 }) => focusRingStyle$1({
  base: theme2.sanity.color.base,
  focusRing: { ...theme2.sanity.focusRing, offset: 1 }
})};
  }
`;
function HomeButton() {
  const workspaces = useWorkspaces(), { activeWorkspace } = useActiveWorkspace(), { href: rootHref, onClick: handleRootClick } = router.useStateLink({ state: {} }), multipleWorkspaces = workspaces.length > 1;
  return /* @__PURE__ */ jsxRuntime.jsx(StyledCard$1, { as: "a", href: rootHref, onClick: handleRootClick, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(LogoMarkContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", children: multipleWorkspaces || activeWorkspace.customIcon ? /* @__PURE__ */ jsxRuntime.jsx(WorkspacePreviewIcon, { icon: activeWorkspace.icon, size: "small" }) : /* @__PURE__ */ jsxRuntime.jsx(SanityLogo, {}) }) }),
    !multipleWorkspaces && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: activeWorkspace.title }) })
  ] }) });
}
function AppearanceMenu$1({
  setScheme
}) {
  const { t: t2 } = useTranslation(), options = useColorSchemeOptions(setScheme, t2);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", padding: 2, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 1, children: options.map(({ icon, label, name, onSelect, selected, title }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Button,
    {
      "aria-label": label,
      icon,
      iconRight: selected && /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}),
      justify: "flex-start",
      mode: "bleed",
      onClick: onSelect,
      selected,
      size: "large",
      text: title
    }
  ) }, name)) }) });
}
function LocaleMenu$1() {
  return useLocale(), null;
}
function ManageMenu$1() {
  const { currentUser, projectId } = useWorkspace(), isAdmin = !!(currentUser && userHasRole(currentUser, "administrator")), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, flex: "none", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { as: "ul", space: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(FreeTrial, { type: "sidebar" }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": t2("user-menu.action.manage-project-aria-label"),
        as: "a",
        href: `https://sanity.io/manage/project/${projectId}`,
        icon: icons.CogIcon,
        justify: "flex-start",
        mode: "bleed",
        size: "large",
        target: "_blank",
        text: t2("user-menu.action.manage-project")
      }
    ) }),
    isAdmin && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": t2("user-menu.action.invite-members-aria-label"),
        as: "a",
        href: `https://sanity.io/manage/project/${projectId}/members`,
        icon: icons.UsersIcon,
        justify: "flex-start",
        mode: "bleed",
        size: "large",
        target: "_blank",
        text: t2("user-menu.action.invite-members")
      }
    ) })
  ] }) });
}
const ANIMATION_TRANSITION = {
  bounce: 0,
  damping: 20,
  mass: 0.5,
  stiffness: 200,
  type: "spring"
}, BACKDROP_VARIANTS = {
  open: {
    opacity: 1
  },
  closed: {
    opacity: 0
  }
}, INNER_CARD_VARIANTS = {
  open: {
    x: "0%"
  },
  closed: {
    x: "-100%"
  }
}, Root$8 = styledComponents.styled(ui.Layer)`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
`, BackdropMotion = styledComponents.styled(framerMotion.motion(ui.Card))`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--card-shadow-penumbra-color);
`, InnerCardMotion = styledComponents.styled(framerMotion.motion(ui.Card))`
  position: relative;
  pointer-events: all;
  flex-direction: column;
  height: 100%;
  min-width: 200px;
  max-width: 280px;
  overflow: auto;
`, NavDrawer = React.memo(function(props2) {
  const { __internal_actions: actions, activeToolName, isOpen, onClose, tools } = props2, setScheme = useColorSchemeSetValue(), { auth, currentUser } = useWorkspace(), workspaces = useWorkspaces(), ToolMenu = useToolMenuComponent(), { t: t2 } = useTranslation(), handleKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && onClose();
    },
    [onClose]
  ), handleActionClick = React.useCallback(
    (action) => {
      action == null || action(), onClose();
    },
    [onClose]
  ), actionNodes = React.useMemo(() => {
    var _a2;
    return (_a2 = actions == null ? void 0 : actions.filter((v) => v.location === "sidebar")) == null ? void 0 : _a2.map((action) => /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        icon: action == null ? void 0 : action.icon,
        justify: "flex-start",
        mode: "bleed",
        onClick: () => handleActionClick(action.onAction),
        selected: action.selected,
        size: "large",
        text: action.title,
        width: "fill"
      },
      action.name
    ));
  }, [actions, handleActionClick]);
  return /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { returnFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(Root$8, { onKeyDown: handleKeyDown, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      BackdropMotion,
      {
        animate: "open",
        "data-open": isOpen,
        exit: "closed",
        initial: "closed",
        onClick: onClose,
        transition: ANIMATION_TRANSITION,
        variants: BACKDROP_VARIANTS
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(
      InnerCardMotion,
      {
        animate: "open",
        "data-open": isOpen,
        display: "flex",
        exit: "closed",
        height: "fill",
        initial: "closed",
        shadow: 1,
        transition: ANIMATION_TRANSITION,
        variants: INNER_CARD_VARIANTS,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, padding: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, align: "center", paddingRight: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, align: "center", children: [
                /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 1, user: "me" }),
                /* @__PURE__ */ jsxRuntime.jsx(
                  ui.Box,
                  {
                    flex: 1,
                    marginLeft: 3,
                    title: (currentUser == null ? void 0 : currentUser.name) || (currentUser == null ? void 0 : currentUser.email),
                    children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: (currentUser == null ? void 0 : currentUser.name) || (currentUser == null ? void 0 : currentUser.email) })
                  }
                )
              ] }) }),
              /* @__PURE__ */ jsxRuntime.jsx(
                TooltipDelayGroupProvider.Button,
                {
                  icon: icons.CloseIcon,
                  mode: "bleed",
                  onClick: onClose,
                  tooltipProps: { content: t2("user-menu.close-menu") }
                }
              )
            ] }),
            workspaces.length > 1 && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, gap: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(HomeButton, {}),
              /* @__PURE__ */ jsxRuntime.jsx(WorkspaceMenuButton, {})
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", flex: 1, justify: "space-between", overflow: "auto", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
              ToolMenu,
              {
                activeToolName,
                closeSidebar: onClose,
                context: "sidebar",
                isSidebarOpen: isOpen,
                tools
              }
            ) }),
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", children: [
              actionNodes && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 1, children: actionNodes }) }),
              setScheme && /* @__PURE__ */ jsxRuntime.jsx(AppearanceMenu$1, { setScheme }),
              /* @__PURE__ */ jsxRuntime.jsx(LocaleMenu$1, {}),
              /* @__PURE__ */ jsxRuntime.jsx(ManageMenu$1, {})
            ] })
          ] }),
          auth.logout && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: "none", padding: 2, borderTop: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Button,
            {
              iconRight: icons.LeaveIcon,
              justify: "flex-start",
              mode: "bleed",
              onClick: auth.logout,
              size: "large",
              text: t2("user-menu.action.sign-out")
            }
          ) }) })
        ]
      }
    )
  ] }) }) });
});
function isQueryMatch(query, option) {
  const lowercaseTitle = option.title.toLowerCase();
  return query.trim().toLowerCase().split(/[\s\-_]+/).every((word) => lowercaseTitle.includes(word));
}
function sortResultRelevance(query, a, b) {
  const titleA = a.title.toLowerCase(), titleB = b.title.toLowerCase(), lowercaseQuery = query.trim().toLowerCase();
  return titleA.startsWith(lowercaseQuery) && !titleB.startsWith(lowercaseQuery) ? -1 : titleB.startsWith(lowercaseQuery) && !titleA.startsWith(lowercaseQuery) ? 1 : titleA.includes(lowercaseQuery) && !titleB.includes(lowercaseQuery) ? -1 : titleB.includes(lowercaseQuery) && !titleA.includes(lowercaseQuery) ? 1 : 0;
}
function filterOptions(options, query, getI18nText) {
  return options.map((option) => ({
    ...option,
    title: getI18nText({ ...option, title: (option == null ? void 0 : option.title) || option.id }).title
  })).sort((a, b) => a.title.localeCompare(b.title)).filter((option) => isQueryMatch(query, option)).sort((a, b) => sortResultRelevance(query, a, b));
}
const StyledPopover$3 = styledComponents.styled(TooltipDelayGroupProvider.Popover)(() => styledComponents.css`
    [data-ui='Popover__wrapper'] {
      width: 320px;
      display: flex;
      flex-direction: column;
      border-radius: ${({ theme: theme2 }) => theme2.sanity.radius[3]}px;
      position: relative;
      overflow: hidden;
      overflow: clip;
    }
  `), StyledDialog = styledComponents.styled(TooltipDelayGroupProvider.Dialog)(() => styledComponents.css`
    [data-ui='DialogCard'] {
      justify-content: flex-start;
    }
  `), RootFlex$1 = styledComponents.styled(ui.Flex)``, PopoverHeaderCard = styledComponents.styled(ui.Card)`
  min-height: max-content;
`, DialogHeaderCard = styledComponents.styled(ui.Card)`
  min-height: max-content;
`, PopoverListFlex = styledComponents.styled(ui.Flex)((props2) => {
  const { $maxDisplayedItems, $itemHeight } = props2;
  return styledComponents.css`
    --item-height: ${$itemHeight}px;
    --max-items: ${$maxDisplayedItems};
    --list-padding: 0.5rem;

    position: relative;
    max-height: calc(var(--item-height) * var(--max-items) + var(--list-padding));
    min-height: calc((var(--item-height) * 1));
  `;
}), INLINE_PREVIEW_HEIGHT = 33;
function NewDocumentListOption(props2) {
  const { option, currentUser, onClick, preview } = props2, params = React.useMemo(
    () => ({ template: option.templateId, type: option.schemaType }),
    [option.schemaType, option.templateId]
  ), { onClick: onIntentClick, href } = router.useIntentLink({
    intent: "create",
    params
  }), handleDocumentClick = React.useCallback(
    (event) => {
      onIntentClick(event), onClick(option);
    },
    [onIntentClick, onClick, option]
  ), { title } = useI18nText(option);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      disabled: option.hasPermission,
      portal: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(InsufficientPermissionsMessage, { currentUser, context: "create-document" }),
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: option.hasPermission ? "a" : "button",
          "data-testid": `create-new-${option.templateId}`,
          disabled: !option.hasPermission,
          href,
          marginBottom: 1,
          onClick: handleDocumentClick,
          padding: preview === "inline" ? 3 : 4,
          radius: 2,
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: preview === "inline" ? 1 : void 0, children: title })
        }
      ) })
    },
    option.id
  );
}
const ContentFlex = styledComponents.styled(ui.Flex)`
  min-height: 100px;
`;
function NewDocumentList(props2) {
  const { currentUser, loading, onDocumentClick, options, preview, searchQuery, textInputElement } = props2, { t: t2 } = useTranslation(), hasOptions = options.length > 0 && !loading, handleDocumentClick = React.useCallback(() => {
    onDocumentClick();
  }, [onDocumentClick]), getItemDisabled = React.useCallback(
    (index) => {
      var _a2;
      return ((_a2 = options[index]) == null ? void 0 : _a2.hasPermission) === !1;
    },
    [options]
  ), renderItem2 = React.useCallback(
    (item) => /* @__PURE__ */ jsxRuntime.jsx(
      NewDocumentListOption,
      {
        currentUser,
        onClick: handleDocumentClick,
        option: item,
        preview
      },
      item.id
    ),
    [currentUser, handleDocumentClick, preview]
  );
  return loading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) : !hasOptions && searchQuery ? /* @__PURE__ */ jsxRuntime.jsx(
    ContentFlex,
    {
      align: "center",
      flex: 1,
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(Translate, { t: t2, i18nKey: "new-document.no-results", values: { searchQuery } }) })
    }
  ) : hasOptions ? /* @__PURE__ */ jsxRuntime.jsx(
    CommandList,
    {
      activeItemDataAttr: "data-hovered",
      ariaLabel: t2("new-document.new-document"),
      autoFocus: supportsTouch ? void 0 : "input",
      getItemDisabled,
      inputElement: textInputElement,
      itemHeight: INLINE_PREVIEW_HEIGHT,
      items: options,
      overscan: 5,
      padding: preview === "inline" ? 1 : 2,
      paddingBottom: 0,
      renderItem: renderItem2
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    ContentFlex,
    {
      align: "center",
      flex: 1,
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: t2("new-document.no-document-types-found") })
    }
  );
}
const MAX_DISPLAYED_ITEMS = 10;
function NewDocumentButton(props2) {
  const { canCreateDocument, modal = "popover", loading, options } = props2, [open, setOpen] = React.useState(!1), [searchQuery, setSearchQuery] = React.useState(""), [popoverElement, setPopoverElement] = React.useState(null), [dialogElement, setDialogElement] = React.useState(null), [buttonElement, setButtonElement] = React.useState(null), [searchInputElement, setSearchInputElement] = React.useState(null), { t: t2 } = useTranslation(), getI18nText = useGetI18nText(options), { scheme } = useColorScheme(), currentUser = useCurrentUser(), schema2 = useSchema(), hasNewDocumentOptions = options.length > 0, disabled = !canCreateDocument || !hasNewDocumentOptions, placeholder = t2("new-document.filter-placeholder"), title = t2("new-document.title"), openDialogAriaLabel = t2("new-document.open-dialog-aria-label"), validOptions = React.useMemo(
    () => options.filter((option) => {
      const optionSchema = schema2.get(option.schemaType);
      return optionSchema && !types.isDeprecatedSchemaType(optionSchema);
    }),
    [options, schema2]
  ), filteredOptions = React.useMemo(
    () => filterOptions(validOptions, searchQuery, getI18nText),
    [validOptions, searchQuery, getI18nText]
  ), handleSearchChange = React.useCallback((event) => {
    setSearchQuery(event.currentTarget.value);
  }, []), handleToggleOpen = React.useCallback(() => setOpen((v) => !v), []), handleClose = React.useCallback(() => {
    setOpen(!1), setSearchQuery(""), buttonElement == null || buttonElement.focus();
  }, [buttonElement]), handleOpenButtonKeyDown = React.useCallback(
    (e) => {
      e.key === "ArrowDown" && !open && setOpen(!0);
    },
    [open]
  ), handlePopoverKeyDown = React.useCallback(
    (e) => {
      (e.key === "Escape" || e.key === "Tab") && open && handleClose();
    },
    [handleClose, open]
  );
  ui.useClickOutside(() => {
    open && handleClose();
  }, [buttonElement, dialogElement, popoverElement]);
  const sharedListProps = React.useMemo(
    () => ({
      currentUser,
      loading,
      onDocumentClick: handleToggleOpen,
      options: filteredOptions,
      searchQuery,
      preview: modal === "popover" ? "inline" : "default",
      textInputElement: searchInputElement
    }),
    [
      currentUser,
      filteredOptions,
      handleToggleOpen,
      loading,
      modal,
      searchInputElement,
      searchQuery
    ]
  ), sharedTextInputProps = React.useMemo(
    () => ({
      __unstable_disableFocusRing: !0,
      border: !1,
      "data-testid": "new-document-button-search-input",
      defaultValue: searchQuery,
      disabled: loading,
      icon: icons.SearchIcon,
      onChange: handleSearchChange,
      placeholder,
      ref: setSearchInputElement
    }),
    [handleSearchChange, loading, placeholder, searchQuery]
  ), sharedOpenButtonProps = React.useMemo(
    () => ({
      "aria-label": openDialogAriaLabel,
      "data-testid": "new-document-button",
      disabled: disabled || loading,
      icon: icons.AddIcon,
      text: t2("new-document.button"),
      mode: "ghost",
      onClick: handleToggleOpen,
      ref: setButtonElement,
      selected: open
    }),
    [disabled, handleToggleOpen, loading, open, openDialogAriaLabel, t2]
  ), tooltipContent = React.useMemo(() => hasNewDocumentOptions ? canCreateDocument ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("new-document.create-new-document-label") }) : /* @__PURE__ */ jsxRuntime.jsx(InsufficientPermissionsMessage, { currentUser, context: "create-any-document" }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("new-document.no-document-types-label") }), [canCreateDocument, currentUser, hasNewDocumentOptions, t2]), sharedTooltipProps = React.useMemo(
    () => ({
      content: tooltipContent,
      disabled: loading || open,
      scheme
    }),
    [loading, open, scheme, tooltipContent]
  );
  return modal === "dialog" ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { ...sharedTooltipProps, children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { ...sharedOpenButtonProps }) }) }),
    open && /* @__PURE__ */ jsxRuntime.jsx(
      StyledDialog,
      {
        header: title,
        id: "create-new-document-dialog",
        onClickOutside: handleClose,
        onClose: handleClose,
        ref: setDialogElement,
        scheme,
        width: 1,
        children: /* @__PURE__ */ jsxRuntime.jsxs(RootFlex$1, { direction: "column", flex: 1, height: "fill", children: [
          /* @__PURE__ */ jsxRuntime.jsx(DialogHeaderCard, { padding: 2, borderBottom: !0, children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.TextInput,
            {
              "data-testid": "new-document-button-search-input",
              ...sharedTextInputProps
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", overflow: "hidden", children: /* @__PURE__ */ jsxRuntime.jsx(NewDocumentList, { ...sharedListProps }) })
        ] })
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(
    StyledPopover$3,
    {
      constrainSize: !0,
      onKeyDown: handlePopoverKeyDown,
      open,
      portal: !0,
      radius: 3,
      ref: setPopoverElement,
      scheme,
      content: /* @__PURE__ */ jsxRuntime.jsxs(
        RootFlex$1,
        {
          direction: "column",
          flex: 1,
          forwardedAs: FocusLock__default.default,
          height: "fill",
          returnFocus: !0,
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(PopoverHeaderCard, { sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.TextInput, { ...sharedTextInputProps, fontSize: 1, radius: 1 }) }) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(
              PopoverListFlex,
              {
                $itemHeight: INLINE_PREVIEW_HEIGHT,
                $maxDisplayedItems: MAX_DISPLAYED_ITEMS,
                direction: "column",
                overflow: "hidden",
                children: /* @__PURE__ */ jsxRuntime.jsx(NewDocumentList, { ...sharedListProps })
              }
            )
          ]
        }
      ),
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { ...sharedTooltipProps, children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          ...sharedOpenButtonProps,
          "aria-expanded": open,
          "aria-haspopup": "true",
          onKeyDown: handleOpenButtonKeyDown
        }
      ) }) }) })
    }
  );
}
function useNewDocumentOptions() {
  const {
    __internal: { staticInitialValueTemplateItems }
  } = useSource(), [permissions, loading] = useTemplatePermissions({
    templateItems: staticInitialValueTemplateItems
  }), canCreateDocument = (permissions == null ? void 0 : permissions.some((p) => staticInitialValueTemplateItems.some((t2) => t2.id === p.id))) || !1, optionsWithPermissions = React.useMemo(() => staticInitialValueTemplateItems.map((item) => {
    var _a2;
    return {
      ...item,
      title: (item == null ? void 0 : item.title) || item.id,
      hasPermission: ((_a2 = permissions == null ? void 0 : permissions.find((p) => p.id === item.id)) == null ? void 0 : _a2.granted) || !1
    };
  }), [permissions, staticInitialValueTemplateItems]);
  return {
    canCreateDocument,
    loading,
    options: optionsWithPermissions
  };
}
const PresenceMenuItem = React.memo(function(props2) {
  const { presence, focused, onFocus } = props2, [menuItemElement, setMenuItemElement] = React.useState(null), { t: t2 } = useTranslation(), lastActiveLocation = orderBy__default.default(presence.locations || [], ["lastActiveAt"], ["desc"]).find(
    (location) => location.documentId
  ), hasLink = !!(lastActiveLocation != null && lastActiveLocation.documentId);
  React.useEffect(() => {
    focused && menuItemElement && (menuItemElement.focus(), menuItemElement.setAttribute("data-selected", "")), focused || menuItemElement == null || menuItemElement.removeAttribute("data-selected");
  }, [menuItemElement, focused]);
  const handleFocus = React.useCallback(() => {
    onFocus(presence.user.id);
  }, [onFocus, presence.user.id]), LinkComponent2 = React.useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      React.forwardRef(function(linkProps, ref) {
        return lastActiveLocation != null && lastActiveLocation.path ? /* @__PURE__ */ jsxRuntime.jsx(
          router.IntentLink,
          {
            ...linkProps,
            intent: "edit",
            params: {
              id: lastActiveLocation == null ? void 0 : lastActiveLocation.documentId,
              path: PathUtils__namespace.toString(lastActiveLocation == null ? void 0 : lastActiveLocation.path)
            },
            ref
          }
        ) : null;
      })
    ),
    [lastActiveLocation]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuItem,
    {
      as: lastActiveLocation ? LinkComponent2 : "div",
      "data-as": "a",
      disabled: !hasLink,
      onFocus: handleFocus,
      preview: /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 1, user: presence.user }, presence.user.id),
      ref: setMenuItemElement,
      text: presence.user.displayName,
      tooltipProps: hasLink ? void 0 : { content: t2("presence.not-in-a-document"), placement: "left" }
    }
  );
}), StyledMenu$2 = styledComponents.styled(ui.Menu)`
  max-width: 260px;
`, FooterStack = styledComponents.styled(ui.Stack)`
  position: sticky;
  bottom: 0;
  background-color: var(--card-bg-color);
`;
function PresenceMenu() {
  const presence = useGlobalPresence(), { projectId } = useWorkspace(), { scheme } = useColorScheme(), { t: t2 } = useTranslation(), hasPresence = presence.length > 0, [focusedId, setFocusedId] = React.useState(), handleItemFocus = React.useCallback((id2) => {
    setFocusedId(id2);
  }, []), handleClearFocusedItem = React.useCallback(() => {
    setFocusedId("");
  }, []), handleClose = React.useCallback(() => {
    setFocusedId("");
  }, []), button = React.useMemo(() => /* @__PURE__ */ jsxRuntime.jsx(
    StatusButton,
    {
      icon: icons.UsersIcon,
      "aria-label": t2("presence.aria-label"),
      mode: "bleed",
      tone: hasPresence ? "positive" : void 0,
      tooltipProps: {
        content: t2("presence.tooltip-content")
      }
    }
  ), [hasPresence, t2]), popoverProps = React.useMemo(
    () => ({
      constrainSize: !0,
      fallbackPlacements: ["bottom"],
      placement: "bottom",
      portal: !0,
      scheme
    }),
    [scheme]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button,
      "aria-label": t2("presence.aria-label"),
      id: "global-presence-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(StyledMenu$2, { children: [
        hasPresence && presence.map((item) => /* @__PURE__ */ jsxRuntime.jsx(
          PresenceMenuItem,
          {
            focused: focusedId === item.user.id,
            onFocus: handleItemFocus,
            presence: item
          },
          item.user.id
        )),
        !hasPresence && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: t2("presence.no-one-else-title") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t2("presence.no-one-else-description") })
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(FooterStack, { space: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              as: "a",
              href: `https://sanity.io/manage/project/${projectId}`,
              iconRight: icons.CogIcon,
              onFocus: handleClearFocusedItem,
              rel: "noopener noreferrer",
              target: "_blank",
              text: t2("presence.action.manage-members")
            }
          )
        ] })
      ] }),
      onClose: handleClose,
      popover: popoverProps
    }
  );
}
function getHelpResources(client2, locale) {
  return client2.withConfig({ apiVersion: "1" }).observable.request({
    url: "/help",
    /*
      query and tag is used by analytics for tracking.
      Builds to: `{m: ['sanity@3.0.2']}' and serializes to: `?m=sanity@3.0.2`.
      Final format will be e.g. https://api.sanity.io/v1/help?tag=sanity.studio.module.version-check&m=sanity%403.0.2
      */
    query: { m: [`sanity@${SANITY_VERSION}`], locale },
    tag: "module.version-check",
    json: !0
  });
}
function useGetHelpResources() {
  const client2 = useClient({ apiVersion: "1" }), locale = useCurrentLocale().id, moduleStatus$ = React.useMemo(() => getHelpResources(client2, locale), [client2, locale]);
  return useLoadable(moduleStatus$);
}
function ResourcesMenuItems({ error, isLoading, value }) {
  var _a2;
  const sections = (_a2 = value == null ? void 0 : value.resources) == null ? void 0 : _a2.sectionArray, latestStudioVersion = value == null ? void 0 : value.latestVersion, { t: t2 } = useTranslation();
  if (isLoading)
    return /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 });
  const fallbackLinks = /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        as: "a",
        text: t2("help-resources.action.join-our-community"),
        href: "https://www.sanity.io/exchange/community",
        target: "_blank"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        as: "a",
        text: t2("help-resources.action.help-and-support"),
        href: "https://www.sanity.io/contact/support",
        target: "_blank"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        as: "a",
        text: t2("help-resources.action.contact-sales"),
        href: "https://www.sanity.io/contact/sales?ref=studio",
        target: "_blank"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {})
  ] });
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    (value === void 0 || error) && /* @__PURE__ */ jsxRuntime.jsx("div", { children: fallbackLinks }),
    !error && (sections == null ? void 0 : sections.map((subSection) => subSection ? /* @__PURE__ */ jsxRuntime.jsx(SubSection, { subSection }, subSection._key) : null)),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, weight: "medium", textOverflow: "ellipsis", children: t2("help-resources.studio-version", { studioVersion: SANITY_VERSION }) }),
      !error && latestStudioVersion && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, textOverflow: "ellipsis", children: t2("help-resources.latest-sanity-version", {
        latestVersion: latestStudioVersion
      }) }) })
    ] })
  ] });
}
function SubSection({ subSection }) {
  var _a2;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    (_a2 = subSection == null ? void 0 : subSection.items) == null ? void 0 : _a2.map((item) => {
      if (!item || !item.title) return null;
      switch (item._type) {
        case "externalLink":
          return item.url ? /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              as: "a",
              tone: "default",
              text: item.title,
              href: item.url,
              target: "_blank"
            },
            item._key
          ) : null;
        case "internalAction":
          return item.type ? item.type === "show-welcome-modal" && /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.MenuItem, { text: item.title }, item._key) : null;
        default:
          return null;
      }
    }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {})
  ] });
}
const StyledMenu$1 = styledComponents.styled(ui.Menu)`
  max-width: 300px;
  min-width: 200px;
`;
function ResourcesButton() {
  const { t: t2 } = useTranslation(), { value, error, isLoading } = useGetHelpResources();
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          "aria-label": t2("help-resources.title"),
          icon: icons.HelpCircleIcon,
          mode: "bleed",
          tooltipProps: { content: t2("help-resources.title") }
        }
      ),
      id: "menu-button-resources",
      menu: /* @__PURE__ */ jsxRuntime.jsx(StyledMenu$1, { children: /* @__PURE__ */ jsxRuntime.jsx(ResourcesMenuItems, { error, isLoading, value }) }),
      popover: { constrainSize: !0 }
    }
  );
}
function LocaleMenu() {
  return useLocale(), null;
}
function AppearanceMenu({
  setScheme
}) {
  const { t: t2 } = useTranslation(), options = useColorSchemeOptions(setScheme, t2);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    options.map(({ icon, label, name, onSelect, selected, title }) => /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        "aria-label": label,
        icon,
        onClick: onSelect,
        pressed: selected,
        text: title,
        iconRight: selected && /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {})
      },
      name
    ))
  ] });
}
const Root$7 = styledComponents.styled.div`
  position: absolute;
  width: 18px;
  height: 18px;
  background: var(--card-bg-color);
  bottom: -4px;
  right: -4px;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 1px solid var(--card-bg-color);
  box-sizing: content-box;

  svg {
    box-sizing: content-box;
    border: 1px solid var(--card-hairline-soft-color);
    border-radius: 50%;
    padding: 2px;
    width: 12px;
    height: 12px;
  }

  &[data-logo='github'] {
    svg {
      path {
        fill: var(--card-fg-color);
      }
    }
  }

  &[data-logo='saml'] {
    svg {
      path {
        fill: var(--card-fg-color);
      }
    }
  }
`, Google = /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ jsxRuntime.jsxs("g", { clipPath: "url(#clip0)", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M12 6.13764C12 5.72977 11.9663 5.31971 11.8943 4.91846H6.12036V7.22895H9.42684C9.28963 7.97412 8.84876 8.63332 8.20322 9.05221V10.5514H10.1759C11.3342 9.50637 12 7.9631 12 6.13764Z",
        fill: "#4285F4"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M6.12019 12.0002C7.77118 12.0002 9.16349 11.4688 10.1779 10.5517L8.20529 9.05253C7.65646 9.41851 6.94793 9.62574 6.12244 9.62574C4.52544 9.62574 3.17136 8.56971 2.68552 7.1499H0.649902V8.69537C1.68908 10.7215 3.80567 12.0002 6.12019 12.0002V12.0002Z",
        fill: "#34A853"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M2.68332 7.14986C2.4269 6.40469 2.4269 5.59778 2.68332 4.8526V3.30713H0.649951C-0.218278 5.00252 -0.218278 6.99995 0.649951 8.69533L2.68332 7.14986V7.14986Z",
        fill: "#FBBC04"
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: "M6.12019 2.37483C6.99291 2.3616 7.8364 2.68348 8.46845 3.27433L10.2161 1.56131C9.1095 0.542752 7.64071 -0.017233 6.12019 0.000404333C3.80566 0.000404333 1.68908 1.27911 0.649902 3.3074L2.68326 4.85288C3.16686 3.43087 4.52319 2.37483 6.12019 2.37483V2.37483Z",
        fill: "#EA4335"
      }
    )
  ] }),
  /* @__PURE__ */ jsxRuntime.jsx("defs", { children: /* @__PURE__ */ jsxRuntime.jsx("clipPath", { id: "clip0", children: /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "12", height: "12", fill: "white" }) }) })
] }), GitHub = /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ jsxRuntime.jsx("g", { clipPath: "url(#clip0)", children: /* @__PURE__ */ jsxRuntime.jsx(
    "path",
    {
      d: "M11.195 3.13503C10.6711 2.22838 9.91808 1.47537 9.01144 0.951471C8.09222 0.414976 7.08837 0.146729 5.99987 0.146729C4.91137 0.146729 3.90752 0.414976 2.98831 0.951471C2.08163 1.47534 1.32862 2.22836 0.804744 3.13503C0.268248 4.05497 0 5.05883 0 6.14659C0 7.45399 0.381531 8.62978 1.14459 9.67394C1.90765 10.7181 2.89327 11.4408 4.10143 11.8419C4.24208 11.868 4.34624 11.8497 4.41392 11.7872C4.44666 11.7577 4.47263 11.7215 4.49006 11.681C4.50749 11.6405 4.51595 11.5967 4.51488 11.5527C4.51488 11.537 4.51361 11.3963 4.51105 11.1307C4.5085 10.8651 4.50722 10.6334 4.50722 10.4355L4.32745 10.4666C4.18407 10.4895 4.03885 10.4986 3.89375 10.494C3.71159 10.4908 3.53001 10.4725 3.35087 10.4393C3.16049 10.4045 2.98119 10.3246 2.82796 10.2064C2.66705 10.0846 2.54715 9.91661 2.48428 9.72484L2.40602 9.54506C2.34022 9.40286 2.25754 9.2691 2.15976 9.14666C2.04775 9.00072 1.93447 8.90176 1.81991 8.84977L1.76518 8.81064C1.72769 8.78356 1.6936 8.75205 1.66367 8.71679C1.63479 8.6841 1.61108 8.64719 1.59334 8.60734C1.57766 8.57085 1.5907 8.54085 1.63247 8.51731C1.67461 8.49405 1.75123 8.48256 1.86068 8.48256L2.01692 8.50582C2.12108 8.52662 2.24996 8.5891 2.40356 8.69326C2.5585 8.79876 2.68797 8.93748 2.78254 9.09932C2.90239 9.31294 3.04695 9.47575 3.21624 9.58775C3.38552 9.69976 3.55609 9.75576 3.72793 9.75576C3.87725 9.7578 4.02641 9.74479 4.17312 9.7169C4.29459 9.69195 4.41264 9.65254 4.52473 9.59952C4.57162 9.25037 4.69931 8.98212 4.90782 8.79477C4.63684 8.76849 4.36827 8.72157 4.10444 8.6544C3.84797 8.58382 3.60133 8.48141 3.37029 8.34958C3.12825 8.218 2.91442 8.04015 2.74095 7.82613C2.57421 7.6178 2.4374 7.34417 2.3305 7.00524C2.2236 6.6663 2.1707 6.27584 2.1718 5.83383C2.1718 5.20357 2.37757 4.66708 2.7891 4.22435C2.59629 3.75006 2.61453 3.21885 2.84383 2.63073C2.99487 2.58385 3.21879 2.61897 3.51559 2.73608C3.81239 2.85319 4.02983 2.95352 4.16792 3.03707C4.30601 3.12025 4.41665 3.19058 4.49983 3.24804C5.48153 2.9773 6.51821 2.9773 7.49991 3.24804L7.79679 3.0606C8.0249 2.92356 8.26549 2.80849 8.51535 2.71693C8.79135 2.61276 9.00231 2.58412 9.14825 2.63101C9.38248 3.21949 9.40327 3.7507 9.21064 4.22462C9.62199 4.66735 9.82776 5.20385 9.82795 5.83411C9.82795 6.27684 9.77459 6.66904 9.66787 7.01071C9.56116 7.35238 9.42325 7.62601 9.25415 7.8316C9.07785 8.04326 8.86311 8.21966 8.62124 8.35149C8.39008 8.48329 8.14337 8.5857 7.88682 8.65632C7.62412 8.72277 7.35674 8.76915 7.087 8.79505C7.35698 9.02927 7.49206 9.3994 7.49225 9.90543V11.5527C7.49115 11.5964 7.49929 11.6398 7.51612 11.6802C7.53295 11.7206 7.5581 11.7569 7.58993 11.7869C7.65505 11.8493 7.75794 11.8675 7.89858 11.8416C9.10693 11.4403 10.0926 10.7177 10.8557 9.67367C11.6188 8.62968 12.0003 7.4539 12.0003 6.14632C11.9997 5.05873 11.7313 4.05497 11.195 3.13503V3.13503Z",
      fill: "black"
    }
  ) }),
  /* @__PURE__ */ jsxRuntime.jsx("defs", { children: /* @__PURE__ */ jsxRuntime.jsx("clipPath", { id: "clip0", children: /* @__PURE__ */ jsxRuntime.jsx("rect", { width: "12", height: "12", fill: "white" }) }) })
] }), Saml = /* @__PURE__ */ jsxRuntime.jsxs("svg", { width: "17", height: "9", viewBox: "0 0 17 9", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M0.0691681 5.98162C0.115833 7.24157 1.07247 8.00221 2.59841 8.00221C4.17102 8.00221 5.12299 7.19957 5.12299 5.86962C5.12299 4.83832 4.55367 4.25501 3.25172 3.96569L2.56108 3.80703C1.8331 3.64837 1.53445 3.38704 1.53445 2.91106C1.53445 2.40708 1.94977 2.09442 2.61708 2.09442C3.27505 2.09442 3.6997 2.43508 3.75103 2.99039H5.00166C4.95966 1.78643 4.01236 0.997795 2.60308 0.997795C1.14713 0.997795 0.218496 1.79577 0.218496 3.05105C0.218496 4.04968 0.815808 4.69366 2.03376 4.96898L2.73374 5.13231C3.51304 5.30497 3.8117 5.54763 3.8117 6.00495C3.8117 6.55093 3.34972 6.90092 2.62174 6.90092C1.85644 6.90092 1.38045 6.56493 1.31979 5.98162H0.0691681Z" }),
  /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M5.97695 5.98162C6.02362 7.24157 6.98025 8.00221 8.5062 8.00221C10.0788 8.00221 11.0308 7.19957 11.0308 5.86962C11.0308 4.83832 10.4615 4.25501 9.15951 3.96569L8.46886 3.80703C7.74089 3.64837 7.44223 3.38704 7.44223 2.91106C7.44223 2.40708 7.85755 2.09442 8.52486 2.09442C9.18284 2.09442 9.60749 2.43508 9.65882 2.99039H10.9094C10.8674 1.78643 9.92015 0.997795 8.51086 0.997795C7.05492 0.997795 6.12628 1.79577 6.12628 3.05105C6.12628 4.04968 6.72359 4.69366 7.94155 4.96898L8.64153 5.13231C9.42083 5.30497 9.71949 5.54763 9.71949 6.00495C9.71949 6.55093 9.2575 6.90092 8.52953 6.90092C7.76422 6.90092 7.28824 6.56493 7.22758 5.98162H5.97695Z" }),
  /* @__PURE__ */ jsxRuntime.jsx("path", { d: "M16.9852 5.01565V3.98435C16.9852 2.11309 16.0099 0.997795 14.3953 0.997795C12.7807 0.997795 11.8054 2.11309 11.8054 3.98435V5.01565C11.8054 6.88692 12.7807 8.00221 14.3953 8.00221C16.0099 8.00221 16.9852 6.88692 16.9852 5.01565ZM14.3953 6.82625C13.5833 6.82625 13.154 6.21494 13.154 5.00165V3.99835C13.154 2.78506 13.5833 2.17375 14.3953 2.17375C15.2073 2.17375 15.6366 2.78506 15.6366 3.99835V5.00165C15.6366 6.21494 15.2073 6.82625 14.3953 6.82625Z" })
] }), LoginProviderLogo = ({ provider }) => {
  const isSaml = provider == null ? void 0 : provider.startsWith("saml-");
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$7, { "data-logo": isSaml ? "saml" : provider, children: [
    provider === "google" && Google,
    provider === "github" && GitHub,
    provider === "sanity" && /* @__PURE__ */ jsxRuntime.jsx(logos.SanityMonogram, {}),
    isSaml && Saml
  ] });
};
function ManageMenu() {
  const { currentUser, projectId } = useWorkspace(), isAdmin = !!(currentUser && userHasRole(currentUser, "administrator")), { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        as: "a",
        "aria-label": t2("user-menu.action.manage-project-aria-label"),
        href: `https://sanity.io/manage/project/${projectId}`,
        target: "_blank",
        text: t2("user-menu.action.manage-project"),
        icon: icons.CogIcon
      }
    ),
    isAdmin && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuItem,
      {
        as: "a",
        "aria-label": t2("user-menu.action.invite-members-aria-label"),
        href: `https://sanity.io/manage/project/${projectId}/members`,
        target: "_blank",
        text: t2("user-menu.action.invite-members"),
        icon: icons.UsersIcon
      }
    )
  ] });
}
const StyledMenu = styledComponents.styled(ui.Menu)`
  min-width: 200px;
  max-width: 300px;
`, AvatarBox = styledComponents.styled(ui.Box)`
  position: relative;
  min-width: ${({ theme: theme2 }) => theme2.sanity.avatar.sizes[2].size}px;
  min-height: ${({ theme: theme2 }) => theme2.sanity.avatar.sizes[2].size}px;
`;
function UserMenu() {
  const { currentUser, auth } = useWorkspace(), scheme = useColorSchemeValue(), setScheme = useColorSchemeSetValue(), providerTitle = getProviderTitle(currentUser == null ? void 0 : currentUser.provider), { t: t2 } = useTranslation(), popoverProps = React.useMemo(
    () => ({
      placement: "bottom",
      portal: !0,
      preventOverflow: !0,
      scheme,
      constrainSize: !0
    }),
    [scheme]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { mode: "bleed", padding: 0, radius: "full", children: /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 1, user: "me" }) }),
      id: "user-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(StyledMenu, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Tooltip,
            {
              disabled: !providerTitle,
              portal: !0,
              content: t2("user-menu.login-provider", { providerTitle }),
              children: /* @__PURE__ */ jsxRuntime.jsxs(AvatarBox, { marginRight: 3, children: [
                /* @__PURE__ */ jsxRuntime.jsx(UserAvatar, { size: 2, user: "me" }),
                (currentUser == null ? void 0 : currentUser.provider) && /* @__PURE__ */ jsxRuntime.jsx(LoginProviderLogo, { provider: currentUser.provider })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, flex: 1, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", textOverflow: "ellipsis", children: currentUser == null ? void 0 : currentUser.name }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, textOverflow: "ellipsis", children: currentUser == null ? void 0 : currentUser.email })
          ] })
        ] }) }),
        setScheme && /* @__PURE__ */ jsxRuntime.jsx(AppearanceMenu, { setScheme }),
        /* @__PURE__ */ jsxRuntime.jsx(LocaleMenu, {}),
        /* @__PURE__ */ jsxRuntime.jsx(ManageMenu, {}),
        auth.logout && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              iconRight: icons.LeaveIcon,
              text: t2("user-menu.action.sign-out"),
              disabled: !auth.logout,
              ...auth.logout && { onClick: auth.logout }
            }
          )
        ] })
      ] }),
      popover: popoverProps
    }
  );
}
const EMPTY_ARRAY$7 = [], RootLayer = styledComponents.styled(ui.Layer)`
  min-height: auto;
  position: relative;

  &[data-search-open='true'] {
    top: 0;
    position: sticky;
  }
`, RootCard$1 = styledComponents.styled(ui.Card)`
  line-height: 0;
`, NavGrid = styledComponents.styled(ui.Grid)`
  grid-template-columns: auto auto auto;
  @media screen and (min-width: ${({ theme: theme2 }) => `${theme2.sanity.media[3]}px`}) {
    grid-template-columns: 1fr auto 1fr;
  }
`;
function StudioNavbar(props2) {
  const {
    // eslint-disable-next-line camelcase
    __internal_actions: actions = EMPTY_ARRAY$7
  } = props2, { name, tools } = useWorkspace(), routerState = router.useRouterState(), mediaIndex = ui.useMediaIndex(), activeToolName = typeof routerState.tool == "string" ? routerState.tool : void 0, newDocumentOptions = useNewDocumentOptions(), { t: t2 } = useTranslation(), {
    onSearchFullscreenOpenChange,
    onSearchOpenChange,
    searchFullscreenOpen,
    searchFullscreenPortalEl,
    searchOpen
  } = React.useContext(_singletons.NavbarContext), ToolMenu = useToolMenuComponent(), [drawerOpen, setDrawerOpen] = React.useState(!1), routerStateRef = React.useRef(routerState), workspaceNameRef = React.useRef(name);
  React.useEffect(() => {
    (routerStateRef.current.tool !== routerState.tool || name !== workspaceNameRef.current) && setDrawerOpen(!1), routerStateRef.current = routerState, workspaceNameRef.current = name;
  }, [name, routerState]);
  const [drawerButtonEl, setDrawerButtonEl] = React.useState(null), [searchOpenButtonEl, setSearchOpenButtonEl] = React.useState(null), shouldRender = React.useMemo(
    () => ({
      resources: mediaIndex > 1,
      collapsedPresenceMenu: mediaIndex <= 1,
      loginStatus: mediaIndex > 1,
      searchFullscreen: mediaIndex <= 1,
      configIssues: mediaIndex > 1 && isDev,
      newDocumentFullscreen: mediaIndex <= 1,
      tools: mediaIndex >= 3
    }),
    [mediaIndex]
  );
  React.useEffect(() => {
    onSearchFullscreenOpenChange(searchFullscreenOpen);
  }, [searchFullscreenOpen, onSearchFullscreenOpenChange]), React.useEffect(() => {
    shouldRender.searchFullscreen ? onSearchOpenChange(!1) : onSearchFullscreenOpenChange(!1);
  }, [onSearchFullscreenOpenChange, onSearchOpenChange, shouldRender.searchFullscreen]);
  const handleOpenSearch = React.useCallback(() => {
    onSearchOpenChange(!0);
  }, [onSearchOpenChange]), handleOpenSearchFullscreen = React.useCallback(() => {
    onSearchFullscreenOpenChange(!0);
  }, [onSearchFullscreenOpenChange]), handleCloseSearch = React.useCallback(() => {
    onSearchOpenChange(!1);
  }, [onSearchOpenChange]), handleCloseSearchFullscreen = React.useCallback(() => {
    onSearchFullscreenOpenChange(!1), searchOpenButtonEl == null || searchOpenButtonEl.focus();
  }, [onSearchFullscreenOpenChange, searchOpenButtonEl]), handleCloseDrawer = React.useCallback(() => {
    setDrawerOpen(!1), drawerButtonEl == null || drawerButtonEl.focus();
  }, [drawerButtonEl]), handleOpenDrawer = React.useCallback(() => {
    setDrawerOpen(!0);
  }, []), actionNodes = React.useMemo(() => {
    var _a2;
    return shouldRender.tools ? (_a2 = actions == null ? void 0 : actions.filter((v) => v.location === "topbar")) == null ? void 0 : _a2.map((action) => /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        iconRight: action == null ? void 0 : action.icon,
        mode: "bleed",
        onClick: action == null ? void 0 : action.onAction,
        selected: action.selected,
        text: action.title
      },
      action.name
    )) : null;
  }, [actions, shouldRender.tools]);
  return /* @__PURE__ */ jsxRuntime.jsx(FreeTrialProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(RootLayer, { zOffset: 100, "data-search-open": searchFullscreenOpen, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      RootCard$1,
      {
        borderBottom: !0,
        "data-testid": "studio-navbar",
        "data-ui": "Navbar",
        padding: 3,
        sizing: "border",
        children: /* @__PURE__ */ jsxRuntime.jsxs(NavGrid, { gap: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, justify: "flex-start", children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
              !shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(
                TooltipDelayGroupProvider.Button,
                {
                  mode: "bleed",
                  icon: icons.MenuIcon,
                  onClick: handleOpenDrawer,
                  ref: setDrawerButtonEl,
                  tooltipProps: { content: t2("user-menu.open-menu"), placement: "bottom" }
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
                /* @__PURE__ */ jsxRuntime.jsx(HomeButton, {}),
                /* @__PURE__ */ jsxRuntime.jsx(WorkspaceMenuButton, {})
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntime.jsx(
              NewDocumentButton,
              {
                ...newDocumentOptions,
                modal: shouldRender.newDocumentFullscreen ? "dialog" : "popover"
              }
            ),
            !shouldRender.searchFullscreen && /* @__PURE__ */ jsxRuntime.jsx(SearchButton, { onClick: handleOpenSearch, ref: setSearchOpenButtonEl })
          ] }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", children: shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(
            ToolMenu,
            {
              activeToolName,
              closeSidebar: handleCloseDrawer,
              context: "topbar",
              isSidebarOpen: !1,
              tools
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, justify: "flex-end", children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(SearchProvider, { fullscreen: shouldRender.searchFullscreen, children: /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: document.body, children: shouldRender.searchFullscreen ? /* @__PURE__ */ jsxRuntime.jsx(ui.PortalProvider, { element: searchFullscreenPortalEl, children: /* @__PURE__ */ jsxRuntime.jsx(
                SearchDialog,
                {
                  onClose: handleCloseSearchFullscreen,
                  onOpen: handleOpenSearchFullscreen,
                  open: searchFullscreenOpen
                }
              ) }) : /* @__PURE__ */ jsxRuntime.jsx(
                SearchPopover,
                {
                  onClose: handleCloseSearch,
                  onOpen: handleOpenSearch,
                  open: searchOpen
                }
              ) }) }) }),
              shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(FreeTrial, { type: "topbar" }),
              shouldRender.configIssues && /* @__PURE__ */ jsxRuntime.jsx(ConfigIssuesButton, {}),
              shouldRender.resources && /* @__PURE__ */ jsxRuntime.jsx(ResourcesButton, {}),
              /* @__PURE__ */ jsxRuntime.jsx(PresenceMenu, {}),
              shouldRender.searchFullscreen && /* @__PURE__ */ jsxRuntime.jsx(
                SearchButton,
                {
                  onClick: handleOpenSearchFullscreen,
                  ref: setSearchOpenButtonEl
                }
              ),
              actionNodes
            ] }),
            shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", marginLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(UserMenu, {}) })
          ] }) })
        ] })
      }
    ),
    !shouldRender.tools && /* @__PURE__ */ jsxRuntime.jsx(
      NavDrawer,
      {
        __internal_actions: actions,
        activeToolName,
        isOpen: drawerOpen,
        onClose: handleCloseDrawer,
        tools
      }
    )
  ] }) });
}
function _isReactElement(node) {
  return !!node;
}
const OptionObserveElement = styledComponents.styled(ObserveElement)`
  list-style: none;
  white-space: nowrap;
  flex-shrink: 0;
  opacity: 0;
  visibility: hidden;
`, HiddenRow = styledComponents.styled(ui.Flex)`
  opacity: 0;
  height: 0.1px;
  overflow: hidden;
`, CollapseTabList = React.forwardRef(function(props2, ref) {
  const {
    children: childrenProp,
    gap,
    menuButtonProps,
    disableRestoreFocusOnClose,
    onMenuClose,
    collapsed,
    ...rest
  } = props2, [rootEl, setRootEl] = React.useState(null), [hiddenElements, setHiddenElements] = React.useState([]), [showChildren, setShowChildren] = React.useState(!1), children = React.useMemo(
    () => React.Children.toArray(childrenProp).filter(_isReactElement),
    [childrenProp]
  ), displayChildren = React.useMemo(() => collapsed || !showChildren ? null : children.filter((c) => !hiddenElements.some((h) => h.key === c.key)), [children, collapsed, hiddenElements, showChildren]), intersectionOptions = React.useMemo(
    () => ({
      root: rootEl,
      threshold: 1,
      rootMargin: "1px"
    }),
    [rootEl]
  ), menuButton = React.useMemo(
    () => (menuButtonProps == null ? void 0 : menuButtonProps.button) || /* @__PURE__ */ jsxRuntime.jsx(ContextMenuButton, {}),
    [menuButtonProps]
  ), menuOptionsArray = React.useMemo(
    () => collapsed ? children : (
      // eslint-disable-next-line max-nested-callbacks
      children.filter(({ key }) => hiddenElements.find((o) => o.key === key))
    ),
    [children, hiddenElements, collapsed]
  ), handleIntersection = React.useCallback(
    (e, child) => {
      const isHidden = hiddenElements.some((el) => el.key === child.key);
      showChildren || setShowChildren(!0);
      const isIntersecting = e.isIntersecting;
      !isHidden && !isIntersecting && setHiddenElements((prev) => [...prev, child]), isHidden && isIntersecting && setHiddenElements((prev) => prev.filter((el) => el.key !== child.key));
    },
    [hiddenElements, showChildren, setShowChildren, setHiddenElements]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", ref, sizing: "border", style: { position: "relative" }, ...rest, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "center", gap, flex: 1, children: [
      displayChildren,
      (hiddenElements.length > 0 || collapsed) && /* @__PURE__ */ jsxRuntime.jsx(
        CollapseOverflowMenu,
        {
          disableRestoreFocusOnClose,
          menuButton,
          menuButtonProps,
          menuOptions: menuOptionsArray,
          onMenuClose
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(HiddenRow, { justify: "flex-start", gap, ref: setRootEl, "data-hidden": !0, "aria-hidden": "true", children: [
      React.cloneElement(menuButton, {
        disabled: !0,
        "aria-hidden": !0
      }),
      children == null ? void 0 : children.map((child) => /* @__PURE__ */ jsxRuntime.jsx(
        OptionObserveElement,
        {
          options: intersectionOptions,
          onIntersectionChange: (e) => handleIntersection(e[0], child),
          children: React.cloneElement(child, {
            disabled: !0,
            "aria-hidden": !0,
            tabIndex: -1
          })
        },
        `${child.key}_observer`
      ))
    ] })
  ] });
}), ToolLink = React.forwardRef(function(props2, ref) {
  const { name, ...rest } = props2, state = router.useRouterState(
    React.useCallback(
      () => ({
        tool: name,
        // make sure to clear tool state when navigating to another tool
        [name]: void 0
      }),
      [name]
    )
  );
  return /* @__PURE__ */ jsxRuntime.jsx(router.StateLink, { state, ...rest, ref });
});
function ToolCollapseMenu(props2) {
  const { activeToolName, tools } = props2, { scheme } = useColorScheme(), [collapseMenuEl, setCollapseMenuEl] = React.useState(null);
  useRovingFocus({
    rootElement: collapseMenuEl,
    navigation: ["arrows"]
  });
  const menuButtonProps = React.useMemo(
    () => ({
      popover: {
        constrainSize: !0,
        portal: !0,
        scheme
      }
    }),
    [scheme]
  ), children = React.useMemo(
    () => tools.map((tool, index) => {
      const title = (tool == null ? void 0 : tool.title) || startCase__default.default(tool.name), Link2 = React.forwardRef(function(linkProps, ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(ToolLink, { ...linkProps, ref, name: tool.name, children: linkProps.children });
      });
      return /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          as: Link2,
          "data-as": "a",
          mode: "bleed",
          selected: activeToolName === tool.name,
          text: title
        },
        `${tool.name}-${index}`
      );
    }),
    [activeToolName, tools]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", marginX: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
    CollapseTabList,
    {
      "data-testid": "tool-collapse-menu",
      gap: 1,
      menuButtonProps,
      ref: setCollapseMenuEl,
      children
    }
  ) });
}
function ToolVerticalMenu(props2) {
  const { activeToolName, isVisible: isVisible2, tools } = props2;
  return React.useMemo(
    () => /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "ul", space: 1, children: tools.map((tool) => {
      const title = (tool == null ? void 0 : tool.title) || startCase__default.default(tool.name), Link2 = React.forwardRef(function(linkProps, ref) {
        return /* @__PURE__ */ jsxRuntime.jsx(ToolLink, { ...linkProps, ref, name: tool.name, children: linkProps.children });
      });
      return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(
        TooltipDelayGroupProvider.Button,
        {
          as: Link2,
          justify: "flex-start",
          mode: "bleed",
          selected: activeToolName === tool.name,
          size: "large",
          tabIndex: isVisible2 ? 0 : -1,
          text: title
        }
      ) }, tool.name);
    }) }),
    [activeToolName, isVisible2, tools]
  );
}
function StudioToolMenu(props2) {
  const { context, isSidebarOpen, tools, ...restProps } = props2;
  return tools.length <= 1 ? null : context === "sidebar" ? /* @__PURE__ */ jsxRuntime.jsx(ToolVerticalMenu, { isVisible: isSidebarOpen, tools, ...restProps }) : /* @__PURE__ */ jsxRuntime.jsx(ToolCollapseMenu, { tools, ...restProps });
}
const SCROLLBAR_SIZE = 12, SCROLLBAR_BORDER_SIZE = 4;
function buildResizeHandleDataUri(hexColor) {
  const encodedStrokeColor = encodeURIComponent(hexColor);
  return `url("data:image/svg+xml,${`%3Csvg width='9' height='9' viewBox='0 0 9 9' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 8L8 1' stroke='${encodedStrokeColor}' stroke-linecap='round'/%3E%3Cpath d='M5 8L8 5' stroke='${encodedStrokeColor}' stroke-linecap='round'/%3E%3C/svg%3E%0A`}")`;
}
const GlobalStyle = styledComponents.createGlobalStyle((props2) => {
  const { color: color2, font } = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    ::-webkit-resizer {
      background-image: ${buildResizeHandleDataUri(color2.icon)};
      background-repeat: no-repeat;
      background-position: bottom right;
    }

    ::-webkit-scrollbar {
      width: ${SCROLLBAR_SIZE}px;
      height: ${SCROLLBAR_SIZE}px;
    }

    ::-webkit-scrollbar-corner {
      background-color: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background-clip: content-box;
      background-color: var(--card-border-color, ${color2.border});
      border: ${SCROLLBAR_BORDER_SIZE}px solid transparent;
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: var(--card-muted-fg-color, ${color2.muted.fg});
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    *::selection {
      background-color: ${theme.rgba(color2.focusRing, 0.3)};
    }

    html {
      background-color: ${color2.bg};
    }

    body {
      scrollbar-gutter: stable;
    }

    #sanity {
      font-family: ${font.text.family};
    }

    b {
      font-weight: ${font.text.weights.medium};
    }

    strong {
      font-weight: ${font.text.weights.medium};
    }
  `;
}), errorChannel = globalScope.__sanityErrorChannel;
function ErrorLogger() {
  const { push: pushToast } = ui.useToast();
  return React.useEffect(() => {
    if (errorChannel)
      return errorChannel.subscribe((msg) => {
        msg.error && (isKnownError(msg.error) || (console.error(msg.error), pushToast({
          // Use the error message as the ID in order to prevent duplicates from showing
          // A bit of a hack, but serves
          id: msg.error.message,
          closable: !0,
          description: msg.error.message,
          duration: 5e3,
          title: "Uncaught error",
          status: "error"
        })));
      });
  }, [pushToast]), null;
}
function isKnownError(err) {
  return err instanceof SchemaError || err instanceof CorsOriginError || err instanceof ConfigResolutionError;
}
function AuthBoundary({
  children,
  AuthenticateComponent = AuthenticateScreen,
  LoadingComponent = LoadingBlock,
  NotAuthenticatedComponent = NotAuthenticatedScreen
}) {
  const [error, handleError] = React.useState(null);
  if (error) throw error;
  const [loggedIn, setLoggedIn] = React.useState(
    "loading"
  ), { activeWorkspace } = useActiveWorkspace();
  return React.useEffect(() => {
    var _a2, _b;
    (_b = (_a2 = activeWorkspace.auth).handleCallbackUrl) == null || _b.call(_a2).catch(handleError);
  }, [activeWorkspace.auth]), React.useEffect(() => {
    const subscription = activeWorkspace.auth.state.subscribe({
      next: ({ authenticated, currentUser }) => {
        var _a2;
        if (((_a2 = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _a2.length) === 0) {
          setLoggedIn("unauthorized");
          return;
        }
        setLoggedIn(authenticated ? "logged-in" : "logged-out");
      },
      error: handleError
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [activeWorkspace]), loggedIn === "loading" ? /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {}) : loggedIn === "unauthorized" ? /* @__PURE__ */ jsxRuntime.jsx(NotAuthenticatedComponent, {}) : loggedIn === "logged-out" ? /* @__PURE__ */ jsxRuntime.jsx(AuthenticateComponent, {}) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children });
}
const Z_OFFSET$1 = {
  toast: [100, 11e3]
}, sessionId = telemetry.createSessionId();
function StudioTelemetryProvider(props2) {
  const client2 = useClient({ apiVersion: "v2023-12-18" }), projectId = client2.config().projectId, store = React.useMemo(() => telemetry.createBatchedStore(sessionId, {
    // submit any pending events every <n> ms
    flushInterval: 3e4,
    // implements user consent resolving
    resolveConsent: () => client2.request({ uri: "/intake/telemetry-status" }),
    // implements sending events to backend
    sendEvents: (batch) => client2.request({
      uri: "/intake/batch",
      method: "POST",
      json: !0,
      body: { projectId, batch }
    }),
    // opts into a different strategy for sending events when the browser close, reload or navigate away from the current page
    sendBeacon: (batch) => navigator.sendBeacon(client2.getUrl("/intake/batch"), JSON.stringify({ projectId, batch }))
  }), [client2, projectId]);
  return React.useEffect(() => {
    store.logger.updateUserProperties({
      userAgent: navigator.userAgent,
      screen: {
        density: window.devicePixelRatio,
        height: window.screen.height,
        width: window.screen.width,
        innerHeight: window.innerHeight,
        innerWidth: window.innerWidth
      },
      studioVersion: SANITY_VERSION,
      plugins: arrify__default.default(props2.config).flatMap(
        (config) => {
          var _a2;
          return ((_a2 = config.plugins) == null ? void 0 : _a2.flatMap((plugin) => ({
            name: plugin.name || "<unnamed>"
          }))) || [];
        }
      )
    });
  }, [props2.config, store.logger]), /* @__PURE__ */ jsxRuntime.jsx(react.TelemetryProvider, { store, children: props2.children });
}
function _buildTints(bg, mid, fg) {
  return {
    50: polished.mix(0.1, mid, bg),
    100: polished.mix(0.2, mid, bg),
    200: polished.mix(0.4, mid, bg),
    300: polished.mix(0.6, mid, bg),
    400: polished.mix(0.8, mid, bg),
    500: mid,
    600: polished.mix(0.8, mid, fg),
    700: polished.mix(0.6, mid, fg),
    800: polished.mix(0.4, mid, fg),
    900: polished.mix(0.2, mid, fg),
    950: polished.mix(0.1, mid, fg)
  };
}
function _toHex(color2) {
  const { red, green, blue } = polished.parseToRgb(color2);
  return polished.rgb(red, green, blue);
}
function _isDark(bg, fg) {
  return polished.getLuminance(bg) < polished.getLuminance(fg);
}
function _multiply(bg, fg) {
  const b = theme.parseColor(bg), s = theme.parseColor(fg);
  return theme.rgbToHex(theme.multiply(b, s));
}
function _screen(bg, fg) {
  const b = theme.parseColor(bg), s = theme.parseColor(fg);
  return theme.rgbToHex(theme.screen(b, s));
}
const NEUTRAL_TONES = ["default", "transparent"];
function buildColor(legacyPalette, legacyTones) {
  return theme.createColorTheme({
    base: ({ dark: navbar, name }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, dark = stateTones.dark, blend = navbar ? _screen : _multiply, tints = stateTones[name] || stateTones.default;
      if (name === "default") {
        const skeletonFrom2 = stateTones.default[100];
        return {
          fg: stateTones.fg,
          bg: stateTones.bg,
          border: stateTones.default[200],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: theme.rgba(stateTones.default[500], 0.4),
            umbra: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.2),
            penumbra: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.14),
            ambient: theme.rgba(dark ? legacyPalette.black : stateTones.default[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (name === "transparent") {
        const bg2 = tints[50], skeletonFrom2 = blend(bg2, tints[100]);
        return {
          fg: tints[900],
          bg: bg2,
          border: tints[300],
          focusRing: legacyPalette.focus.base,
          shadow: {
            outline: theme.rgba(tints[500], dark ? 0.2 : 0.4),
            umbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.2),
            penumbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.14),
            ambient: theme.rgba(dark ? legacyPalette.black : tints[500], 0.12)
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = tints[50], skeletonFrom = blend(bg, tints[100]);
      return {
        fg: tints[900],
        bg,
        border: tints[200],
        focusRing: tints[500],
        shadow: {
          outline: theme.rgba(tints[500], dark ? 0.2 : 0.4),
          umbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.2),
          penumbra: theme.rgba(dark ? legacyPalette.black : tints[500], 0.14),
          ambient: theme.rgba(dark ? legacyPalette.black : tints[500], 0.12)
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    solid: ({ base, dark: navbar, name, state, tone }) => {
      const buttonTones = navbar ? legacyTones.button.navbar : legacyTones.button.default, dark = buttonTones.dark, blend = dark ? _screen : _multiply, blendInvert = dark ? _multiply : _screen, defaultTints = buttonTones[name] || buttonTones.default, isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = buttonTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = blend(base.bg, tints[200]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[200]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[50])
          },
          accent: {
            fg: blend(base.bg, tints[50])
          },
          link: {
            fg: blend(base.bg, tints[50])
          },
          code: {
            bg: bg2,
            fg: blend(base.bg, tints[50])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[600]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[600]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        const bg2 = blend(base.bg, tints[800]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        isNeutral && (tints = buttonTones.primary);
        const bg2 = blend(base.bg, tints[800]), skeletonFrom2 = blendInvert(bg2, tints[800]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[800]),
          fg: blend(base.bg, buttonTones.bg),
          icon: blend(base.bg, buttonTones.bg),
          muted: {
            fg: blend(base.bg, tints[200])
          },
          accent: {
            fg: blendInvert(bg2, buttonTones.critical[300])
          },
          link: {
            fg: blendInvert(bg2, buttonTones.primary[200])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[200])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = blend(base.bg, tints[500]), skeletonFrom = blendInvert(bg, tints[800]);
      return {
        bg,
        border: blend(base.bg, tints[500]),
        fg: blend(base.bg, buttonTones.bg),
        icon: blend(base.bg, buttonTones.bg),
        muted: {
          fg: blend(base.bg, tints[100])
        },
        accent: {
          fg: blendInvert(bg, buttonTones.critical[200])
        },
        link: {
          fg: blendInvert(bg, buttonTones.primary[100])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(base.bg, tints[100])
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    muted: ({ base, dark: navbar, name, state, tone }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply, defaultTints = stateTones[name] || stateTones.default, isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
      let tints = stateTones[tone === "default" ? name : tone] || defaultTints;
      if (state === "disabled") {
        tints = defaultTints;
        const bg2 = base.bg, skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[200]),
          icon: blend(base.bg, tints[200]),
          muted: {
            fg: blend(bg2, tints[100])
          },
          accent: {
            fg: blend(bg2, tints[100])
          },
          link: {
            fg: blend(bg2, tints[100])
          },
          code: {
            bg: bg2,
            fg: blend(bg2, tints[100])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "hovered") {
        const bg2 = blend(base.bg, tints[50]), skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[900]),
          icon: blend(base.bg, tints[900]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(base.bg, stateTones.critical[500])
          },
          link: {
            fg: blend(base.bg, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(base.bg, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "pressed") {
        isNeutral && (tints = stateTones.primary);
        const bg2 = blend(base.bg, tints[100]), skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(base.bg, tints[800]),
          icon: blend(base.bg, tints[800]),
          muted: {
            fg: blend(base.bg, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      if (state === "selected") {
        isNeutral && (tints = stateTones.primary);
        const bg2 = blend(base.bg, tints[100]), skeletonFrom2 = blend(bg2, tints[100]);
        return {
          bg: bg2,
          border: blend(bg2, tints[100]),
          fg: blend(bg2, tints[800]),
          icon: blend(bg2, tints[800]),
          muted: {
            fg: blend(bg2, tints[600])
          },
          accent: {
            fg: blend(bg2, stateTones.critical[500])
          },
          link: {
            fg: blend(bg2, stateTones.primary[600])
          },
          code: {
            bg: blend(bg2, tints[50]),
            fg: blend(bg2, tints[600])
          },
          skeleton: {
            from: skeletonFrom2,
            to: theme.rgba(skeletonFrom2, 0.5)
          }
        };
      }
      const bg = base.bg, skeletonFrom = blend(base.bg, tints[100]);
      return {
        bg,
        border: blend(bg, tints[100]),
        fg: blend(bg, tints[700]),
        icon: blend(bg, tints[700]),
        muted: {
          fg: blend(bg, tints[600])
        },
        accent: {
          fg: blend(bg, stateTones.critical[500])
        },
        link: {
          fg: blend(bg, stateTones.primary[600])
        },
        code: {
          bg: blend(bg, tints[50]),
          fg: blend(bg, tints[600])
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    button: ({ base, mode, muted, solid }) => mode === "bleed" ? {
      enabled: {
        ...muted.enabled,
        border: muted.enabled.bg
      },
      hovered: {
        ...muted.hovered,
        border: muted.hovered.bg
      },
      pressed: {
        ...muted.pressed,
        border: muted.pressed.bg
      },
      selected: {
        ...muted.selected,
        border: muted.selected.bg
      },
      disabled: {
        ...muted.disabled,
        border: muted.disabled.bg
      }
    } : mode === "ghost" ? {
      ...solid,
      enabled: {
        ...muted.enabled,
        border: base.border
      },
      disabled: muted.disabled
    } : solid,
    card: ({ base, dark: navbar, muted, name, solid, state }) => {
      if (state === "hovered")
        return muted[name].hovered;
      if (state === "disabled")
        return muted[name].disabled;
      const isNeutral = NEUTRAL_TONES.includes(name), stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, tints = stateTones[name] || stateTones.default, dark = stateTones.dark, blend = dark ? _screen : _multiply;
      if (state === "pressed")
        return isNeutral ? muted.primary.pressed : muted[name].pressed;
      if (state === "selected")
        return isNeutral ? solid.primary.enabled : solid[name].enabled;
      const bg = base.bg, skeletonFrom = blend(base.bg, tints[dark ? 900 : 100]);
      return {
        bg,
        fg: base.fg,
        icon: base.fg,
        border: base.border,
        muted: {
          fg: blend(base.bg, tints[dark ? 400 : 600])
        },
        accent: {
          fg: blend(base.bg, stateTones.critical[dark ? 400 : 500])
        },
        link: {
          fg: blend(base.bg, stateTones.primary[dark ? 400 : 600])
        },
        code: {
          bg: blend(base.bg, tints[dark ? 950 : 50]),
          fg: tints[dark ? 400 : 600]
        },
        skeleton: {
          from: skeletonFrom,
          to: theme.rgba(skeletonFrom, 0.5)
        }
      };
    },
    input: ({ base, dark: navbar, mode, state }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply;
      if (mode === "invalid") {
        const tints = stateTones.critical;
        return {
          bg: blend(base.bg, tints[50]),
          bg2: blend(base.bg, tints[50]),
          fg: blend(base.bg, tints[700]),
          border: blend(base.bg, tints[200]),
          placeholder: blend(base.bg, tints[400])
        };
      }
      return state === "hovered" ? {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: blend(base.bg, color.hues.gray[300].hex),
        placeholder: blend(base.bg, color.hues.gray[400].hex)
      } : state === "disabled" ? {
        bg: blend(base.bg, color.hues.gray[50].hex),
        bg2: blend(base.bg, color.hues.gray[50].hex),
        fg: blend(base.bg, color.hues.gray[200].hex),
        border: blend(base.bg, color.hues.gray[100].hex),
        placeholder: blend(base.bg, color.hues.gray[100].hex)
      } : state === "readOnly" ? {
        bg: blend(base.bg, color.hues.gray[50].hex),
        bg2: blend(base.bg, color.hues.gray[50].hex),
        fg: blend(base.bg, color.hues.gray[800].hex),
        border: blend(base.bg, color.hues.gray[200].hex),
        placeholder: blend(base.bg, color.hues.gray[400].hex)
      } : {
        bg: base.bg,
        bg2: base.bg,
        fg: base.fg,
        border: base.border,
        placeholder: blend(base.bg, color.hues.gray[700].hex)
      };
    },
    selectable: ({ base, muted, tone, solid, state }) => state === "enabled" ? {
      ...muted[tone].enabled,
      bg: base.bg
    } : state === "pressed" ? tone === "default" ? muted.primary.pressed : muted[tone].pressed : state === "selected" ? tone === "default" ? solid.primary.enabled : solid[tone].enabled : state === "disabled" ? {
      ...muted[tone].disabled,
      bg: base.bg
    } : muted[tone][state],
    spot: ({ base, key }) => {
      const dark = _isDark(base.bg, base.fg);
      return (dark ? _screen : _multiply)(base.bg, color.hues[key][dark ? 400 : 500].hex);
    },
    syntax: ({ base, dark: navbar }) => {
      const stateTones = navbar ? legacyTones.state.navbar : legacyTones.state.default, blend = stateTones.dark ? _screen : _multiply, mainShade = 600, secondaryShade = 400;
      return {
        atrule: blend(base.bg, color.hues.purple[mainShade].hex),
        attrName: blend(base.bg, stateTones.positive[mainShade]),
        attrValue: blend(base.bg, stateTones.caution[mainShade]),
        attribute: blend(base.bg, stateTones.caution[mainShade]),
        boolean: blend(base.bg, color.hues.purple[mainShade].hex),
        builtin: blend(base.bg, color.hues.purple[mainShade].hex),
        cdata: blend(base.bg, stateTones.caution[mainShade]),
        char: blend(base.bg, stateTones.caution[mainShade]),
        class: blend(base.bg, color.hues.orange[mainShade].hex),
        className: blend(base.bg, color.hues.cyan[mainShade].hex),
        comment: blend(base.bg, stateTones.default[secondaryShade]),
        constant: blend(base.bg, color.hues.purple[mainShade].hex),
        deleted: blend(base.bg, stateTones.critical[mainShade]),
        doctype: blend(base.bg, stateTones.default[secondaryShade]),
        entity: blend(base.bg, stateTones.critical[mainShade]),
        function: blend(base.bg, stateTones.positive[mainShade]),
        hexcode: blend(base.bg, stateTones.primary[mainShade]),
        id: blend(base.bg, color.hues.purple[mainShade].hex),
        important: blend(base.bg, color.hues.purple[mainShade].hex),
        inserted: blend(base.bg, stateTones.caution[mainShade]),
        keyword: blend(base.bg, color.hues.magenta[mainShade].hex),
        number: blend(base.bg, color.hues.purple[mainShade].hex),
        operator: blend(base.bg, color.hues.magenta[mainShade].hex),
        prolog: blend(base.bg, stateTones.default[secondaryShade]),
        property: blend(base.bg, stateTones.primary[mainShade]),
        pseudoClass: blend(base.bg, stateTones.caution[mainShade]),
        pseudoElement: blend(base.bg, stateTones.caution[mainShade]),
        punctuation: blend(base.bg, stateTones.default[mainShade]),
        regex: blend(base.bg, stateTones.primary[mainShade]),
        selector: blend(base.bg, stateTones.critical[mainShade]),
        string: blend(base.bg, stateTones.caution[mainShade]),
        symbol: blend(base.bg, color.hues.purple[mainShade].hex),
        tag: blend(base.bg, stateTones.critical[mainShade]),
        unit: blend(base.bg, color.hues.orange[mainShade].hex),
        url: blend(base.bg, stateTones.critical[mainShade]),
        variable: blend(base.bg, stateTones.critical[mainShade])
      };
    }
  });
}
function buildFonts(cssCustomProperties) {
  return {
    ...ui.studioTheme.fonts,
    code: {
      ...ui.studioTheme.fonts.code,
      family: cssCustomProperties["--font-family-monospace"] || ui.studioTheme.fonts.code.family
    },
    heading: {
      ...ui.studioTheme.fonts.heading,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    },
    label: {
      ...ui.studioTheme.fonts.label,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    },
    text: {
      ...ui.studioTheme.fonts.text,
      family: cssCustomProperties["--font-family-base"] || ui.studioTheme.fonts.code.family
    }
  };
}
function buildLegacyPalette(cssCustomProperties) {
  return {
    black: _toHex(cssCustomProperties["--black"]),
    component: {
      bg: _toHex(cssCustomProperties["--component-bg"]),
      fg: _toHex(cssCustomProperties["--component-text-color"])
    },
    defaultButton: {
      default: {
        base: _toHex(cssCustomProperties["--default-button-color"])
      },
      primary: {
        base: _toHex(cssCustomProperties["--default-button-primary-color"])
      },
      success: {
        base: _toHex(cssCustomProperties["--default-button-success-color"])
      },
      warning: {
        base: _toHex(cssCustomProperties["--default-button-warning-color"])
      },
      danger: {
        base: _toHex(cssCustomProperties["--default-button-danger-color"])
      }
    },
    focus: {
      base: _toHex(cssCustomProperties["--focus-color"])
    },
    gray: {
      base: _toHex(cssCustomProperties["--gray-base"])
    },
    mainNavigation: {
      bg: _toHex(cssCustomProperties["--main-navigation-color"]),
      fg: _toHex(cssCustomProperties["--main-navigation-color--inverted"])
    },
    state: {
      info: {
        fg: _toHex(cssCustomProperties["--state-info-color"])
      },
      success: {
        fg: _toHex(cssCustomProperties["--state-success-color"])
      },
      warning: {
        fg: _toHex(cssCustomProperties["--state-warning-color"])
      },
      danger: {
        fg: _toHex(cssCustomProperties["--state-danger-color"])
      }
    }
  };
}
function buildLegacyTones(legacyPalette) {
  return {
    state: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.gray.base,
          legacyPalette.component.fg
        ),
        transparent: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.gray.base,
          legacyPalette.component.fg
        ),
        primary: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.info.fg,
          legacyPalette.component.fg
        ),
        positive: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.success.fg,
          legacyPalette.component.fg
        ),
        caution: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.warning.fg,
          legacyPalette.component.fg
        ),
        critical: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.state.danger.fg,
          legacyPalette.component.fg
        )
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.gray.base,
          legacyPalette.mainNavigation.fg
        ),
        transparent: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.gray.base,
          legacyPalette.mainNavigation.fg
        ),
        primary: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.info.fg,
          legacyPalette.mainNavigation.fg
        ),
        positive: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.success.fg,
          legacyPalette.mainNavigation.fg
        ),
        caution: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.warning.fg,
          legacyPalette.mainNavigation.fg
        ),
        critical: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.state.danger.fg,
          legacyPalette.mainNavigation.fg
        )
      }
    },
    button: {
      default: {
        bg: legacyPalette.component.bg,
        fg: legacyPalette.component.fg,
        dark: _isDark(legacyPalette.component.bg, legacyPalette.component.fg),
        default: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.component.fg
        ),
        transparent: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.component.fg
        ),
        primary: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.primary.base,
          legacyPalette.component.fg
        ),
        positive: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.success.base,
          legacyPalette.component.fg
        ),
        caution: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.warning.base,
          legacyPalette.component.fg
        ),
        critical: _buildTints(
          legacyPalette.component.bg,
          legacyPalette.defaultButton.danger.base,
          legacyPalette.component.fg
        )
      },
      navbar: {
        bg: legacyPalette.mainNavigation.bg,
        fg: legacyPalette.mainNavigation.fg,
        dark: _isDark(legacyPalette.mainNavigation.bg, legacyPalette.mainNavigation.fg),
        default: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.mainNavigation.fg
        ),
        transparent: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.default.base,
          legacyPalette.mainNavigation.fg
        ),
        primary: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.primary.base,
          legacyPalette.mainNavigation.fg
        ),
        positive: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.success.base,
          legacyPalette.mainNavigation.fg
        ),
        caution: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.warning.base,
          legacyPalette.mainNavigation.fg
        ),
        critical: _buildTints(
          legacyPalette.mainNavigation.bg,
          legacyPalette.defaultButton.danger.base,
          legacyPalette.mainNavigation.fg
        )
      }
    }
  };
}
function buildLegacyTheme(partialLegacyTheme) {
  const legacyTheme = resolveLegacyTheme(partialLegacyTheme), legacyPalette = buildLegacyPalette(legacyTheme), legacyTones = buildLegacyTones(legacyPalette), color2 = buildColor(legacyPalette, legacyTones), fonts = buildFonts(legacyTheme);
  return {
    __dark: _isDark(color2.light.default.base.bg, color2.light.default.base.fg),
    __legacy: !0,
    color: color2,
    fonts
  };
}
const defaultCustomProperties = {
  "--font-family-monospace": ui.studioTheme.fonts.code.family,
  "--font-family-base": ui.studioTheme.fonts.text.family,
  "--black": color.black.hex,
  "--white": color.white.hex,
  // Brand
  "--brand-primary": color.blue[500].hex,
  // Component
  "--component-bg": color.white.hex,
  "--component-text-color": color.black.hex,
  // Gray
  "--gray": color.gray[500].hex,
  "--gray-base": color.gray[500].hex,
  // Default button
  "--default-button-color": color.gray[500].hex,
  "--default-button-danger-color": color.red[500].hex,
  "--default-button-primary-color": color.blue[500].hex,
  "--default-button-success-color": color.green[500].hex,
  "--default-button-warning-color": color.yellow[500].hex,
  // Focus
  "--focus-color": color.blue[500].hex,
  // Screen
  "--screen-medium-break": "512px",
  "--screen-default-break": "640px",
  "--screen-large-break": "960px",
  "--screen-xlarge-break": "1600px",
  // State
  "--state-info-color": color.blue[500].hex,
  "--state-success-color": color.green[500].hex,
  "--state-warning-color": color.yellow[500].hex,
  "--state-danger-color": color.red[500].hex,
  // Navbar
  "--main-navigation-color": color.black.hex,
  "--main-navigation-color--inverted": color.white.hex
};
function resolveLegacyTheme(legacyTheme) {
  const props2 = {
    ...defaultCustomProperties,
    ...legacyTheme
  };
  return props2["--focus-color"] = legacyTheme["--focus-color"] || props2["--brand-primary"], props2["--default-button-primary-color"] = legacyTheme["--default-button-primary-color"] || props2["--brand-primary"], props2["--main-navigation-color"] = legacyTheme["--main-navigation-color"] || props2["--black"], props2["--main-navigation-color--inverted"] = legacyTheme["--main-navigation-color--inverted"] || props2["--white"], props2["--state-info-color"] = legacyTheme["--brand-primary"] || props2["--brand-primary"], props2;
}
const defaultTheme = theme.buildTheme(), isThemerTheme = (theme2) => theme2.__themer === !0;
function getThemeValues(theme2) {
  var _a2, _b;
  return {
    ...defaultTheme,
    v2: theme2.v2,
    fonts: isThemerTheme(theme2) ? defaultTheme.fonts : (_a2 = theme2.fonts) != null ? _a2 : defaultTheme.fonts,
    color: (_b = theme2.color) != null ? _b : defaultTheme.color
  };
}
function StudioThemeProvider({ children }) {
  const theme2 = useActiveWorkspace().activeWorkspace.theme;
  if (theme2.__legacy) {
    const scheme = theme2.__dark ? "dark" : "light";
    return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ColorSchemeSetValueContext.Provider, { value: !1, children: /* @__PURE__ */ jsxRuntime.jsx(_singletons.ColorSchemeValueContext.Provider, { value: scheme, children: /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeProvider, { scheme, theme: getThemeValues(theme2), children: /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { children }) }) }) });
  }
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeProvider, { theme: getThemeValues(theme2), children: /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { children }) });
}
const ListItem = styledComponents.styled(ui.Flex)``, ErrorMessageRoot = styledComponents.styled(ui.Box).attrs({ padding: 4 })``;
function ErrorMessage({ error, message, path, stack }) {
  React.useEffect(() => {
    console.error(error);
  }, [error]);
  const last = path[path.length - 1];
  return /* @__PURE__ */ jsxRuntime.jsxs(ErrorMessageRoot, { forwardedAs: ui.Flex, direction: "column", gap: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", gap: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { weight: "medium", size: 3, children: [
      startCase__default.default(last.type),
      " Error"
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "critical", overflow: "auto", padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { children: message }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { as: "ul", direction: "column", gap: 2, children: path.map(({ name, type }, index) => /* @__PURE__ */ jsxRuntime.jsxs(ListItem, { forwardedAs: "li", gap: 2, align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { children: name }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: type }) })
    ] }, index)) }),
    stack && /* @__PURE__ */ jsxRuntime.jsxs("details", { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "summary", children: "Stack Trace" }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", marginTop: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { children: stack }) })
    ] })
  ] });
}
function createRouter(opts) {
  const { basePath = "/", tools } = opts, toolRoute = router.route.create("/:tool", (toolParams) => {
    let tool = tools.find((current) => current.name === toolParams.tool);
    return !tool && toolParams.tool === "desk" && (tool = tools.find((current) => current.name === "structure")), tool ? router.route.scope(tool.name, "/", tool.router) : router.route.create("/");
  });
  return router.route.create(basePath, [router.route.intents("/intent"), toolRoute]);
}
function getOrderedTools(tools) {
  const config = {}.toolSwitcher || {}, order = config.order || [], hidden = config.hidden || [];
  if (!order.length && !hidden.length)
    return tools;
  const keyed = tools.reduce((target, tool) => {
    const title = tool.title || "<unknown>";
    if (!tool.name)
      return console.warn(`Tool "${title}" does not have the required "name" property`), target;
    if (target[tool.name]) {
      const existing = target[tool.name].tool.title;
      return console.warn(`Tools with duplicate name "${tool.name}" found ("${title}" and "${existing}")`), target;
    }
    const toolIndex = order.indexOf(tool.name);
    return target[tool.name] = {
      tool,
      index: toolIndex === -1 ? 1 / 0 : toolIndex
    }, target;
  }, {}), isVisible2 = (tool) => hidden.indexOf(tool.name) === -1, ret = tools.filter(isVisible2);
  return ret.sort((tool1, tool2) => {
    const toolA = keyed[tool1.name], toolB = keyed[tool2.name], indexA = toolA ? toolA.index : 1 / 0, indexB = toolB ? toolB.index : 1 / 0;
    return indexA === indexB ? 0 : indexA - indexB;
  }), ret;
}
const WEIGHTED_CREATE_INTENT_PARAMS = ["template"], WEIGHTED_EDIT_INTENT_PARAMS = ["mode"];
function resolveUrlStateWithDefaultTool(tools, state) {
  const defaultTool = getOrderedTools(tools)[0];
  return !state || state.tool || !defaultTool ? state : Object.assign({}, state, {
    tool: defaultTool.name
  });
}
function makeBackwardsCompatible(tools, state) {
  return state && (getOrderedTools(tools).find((tool) => tool.name === state.space) ? { ...state, tool: state.space, space: void 0 } : state);
}
function resolveDefaultState(tools, state) {
  return resolveUrlStateWithDefaultTool(
    tools,
    makeBackwardsCompatible(tools, state)
  );
}
function resolveIntentState(tools, prevState, nextState) {
  var _a2;
  const { intent, params, payload } = nextState;
  if (typeof intent != "string")
    throw new Error("intent must be a string");
  if (!isRecord$4(params))
    throw new Error("intent params must be a string");
  const orderedTools = getOrderedTools(tools), currentTool = prevState != null && prevState.tool ? orderedTools.find((tool) => tool.name === prevState.tool) : null, otherTools = currentTool ? orderedTools.filter((tool) => tool !== currentTool) : orderedTools;
  let weightedParams = [];
  intent === "create" ? weightedParams = WEIGHTED_CREATE_INTENT_PARAMS : intent === "edit" && (weightedParams = WEIGHTED_EDIT_INTENT_PARAMS);
  const initialMatch = { score: -1, tool: null }, { tool: matchingTool } = (currentTool ? [currentTool, ...otherTools] : orderedTools).reduce(
    (prev, tool) => {
      if (!tool || typeof tool.canHandleIntent != "function")
        return prev;
      const canHandle = tool.canHandleIntent(intent, params, prevState && prevState[tool.name]);
      if (typeof canHandle == "boolean")
        return canHandle && prev.score < 0 ? { score: 0, tool } : prev;
      if (!isRecord$4(canHandle))
        return prev;
      const score = weightedParams.reduce((prevScore, weightedParam) => weightedParam in params && canHandle[weightedParam] === !0 ? prevScore + 1 : prevScore, 0);
      return score > prev.score ? { score, tool } : prev;
    },
    initialMatch
  );
  if (matchingTool != null && matchingTool.getIntentState) {
    const _toolState = matchingTool.getIntentState(
      intent,
      params,
      prevState && prevState[matchingTool.name],
      payload
    ), { _searchParams, ...toolState } = _toolState, nextUrlState = {
      ...prevState,
      tool: matchingTool.name,
      [matchingTool.name]: toolState
    };
    return (_a2 = matchingTool.router) != null && _a2.__unsafe_disableScopedSearchParams ? nextUrlState._searchParams = _searchParams : toolState._searchParams = _searchParams, {
      type: "state",
      isNotFound: !1,
      state: nextUrlState
    };
  }
  return {
    type: "intent",
    isNotFound: !0,
    intent: { name: intent, params }
  };
}
function decodeUrlState(rootRouter, pathname) {
  return {
    type: "state",
    state: rootRouter.decode(pathname) || {},
    isNotFound: rootRouter.isNotFound(pathname)
  };
}
function WorkspaceRouterProvider({
  children,
  LoadingComponent,
  workspace
}) {
  const { basePath, tools } = workspace, history2 = useRouterHistory(), router$1 = React.useMemo(() => createRouter({ basePath, tools }), [basePath, tools]), [state, onNavigate] = useRouterFromWorkspaceHistory(history2, router$1, tools);
  return state ? /* @__PURE__ */ jsxRuntime.jsx(router.RouterProvider, { onNavigate, router: router$1, state, children }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {});
}
function useRouterFromWorkspaceHistory(history2, router2, tools) {
  var _a2;
  const store = React.useMemo(() => {
    const routerBasePath = router2.getBasePath(), routerBasePathRegex = new RegExp(`^${escapeRegExp__default.default(routerBasePath)}(\\/|$)`, "i"), shouldHandle = (pathname) => (
      // this is necessary to prevent emissions intended for other workspaces.
      routerBasePath === "/" ? !0 : routerBasePathRegex.test(pathname)
    );
    return {
      subscribe: (onStoreChange) => history2.listen(onStoreChange),
      getSnapshot: () => `${history2.location.pathname}${history2.location.search || ""}`,
      // Always return null for the server snapshot, as we can't know how to resolve intents until after authentication is done, which is browser-only
      getServerSnapshot: () => null,
      selector: (pathname) => typeof pathname == "string" && shouldHandle(pathname) ? decodeUrlState(router2, pathname) : null
    };
  }, [history2, router2]), event = withSelector_js.useSyncExternalStoreWithSelector(
    store.subscribe,
    store.getSnapshot,
    store.getServerSnapshot,
    store.selector,
    isEqual__default.default
  ), prevEvent = React.useRef(event);
  React.useEffect(() => {
    var _a22;
    if ((event == null ? void 0 : event.type) === "state" && !((_a22 = event.state) != null && _a22.intent)) {
      const defaultState = resolveDefaultState(tools, event.state);
      defaultState && defaultState !== event.state && history2.replace(router2.encode(defaultState));
    }
  }, [event == null ? void 0 : event.state, event == null ? void 0 : event.type, history2, router2, tools]), React.useEffect(() => {
    const resolvedIntent = maybeResolveIntent(event, router2, tools, prevEvent);
    resolvedIntent ? history2.replace(resolvedIntent) : prevEvent.current = event;
  }, [event, history2, router2, tools]);
  const handleNavigate = React.useMemo(() => ({ path, replace }) => {
    const predictedEvent = store.selector(path), resolvedIntent = maybeResolveIntent(predictedEvent, router2, tools, prevEvent), resolvedPath = typeof resolvedIntent == "string" ? resolvedIntent : path;
    replace ? history2.replace(resolvedPath) : history2.push(resolvedPath);
  }, [history2, router2, store, tools]);
  return [(_a2 = event == null ? void 0 : event.state) != null ? _a2 : null, handleNavigate];
}
function maybeResolveIntent(event, router2, tools, prevEvent) {
  var _a2, _b;
  if ((event == null ? void 0 : event.type) === "state" && (_a2 = event.state) != null && _a2.intent) {
    const redirectState = resolveIntentState(
      tools,
      ((_b = prevEvent.current) == null ? void 0 : _b.type) === "state" ? prevEvent.current.state : {},
      event.state
    );
    if ((redirectState == null ? void 0 : redirectState.type) === "state")
      return router2.encode(redirectState.state);
  }
  return null;
}
function useWorkspaceLoader(activeWorkspace) {
  const [error, handleError] = React.useState(null);
  if (error) throw error;
  const [workspace, setWorkspace] = React.useState(null);
  return React.useEffect(() => {
    const subscription = rxjs.combineLatest(
      activeWorkspace.__internal.sources.map(
        ({ source }) => source.pipe(
          operators.catchError((err) => {
            if (err instanceof ConfigResolutionError) return rxjs.of(err);
            throw err;
          })
        )
      )
    ).pipe(
      operators.map((results) => {
        const errors = results.filter((result) => result instanceof ConfigResolutionError);
        if (errors.length)
          throw new ConfigResolutionError({
            name: activeWorkspace.name,
            causes: errors,
            type: "workspace"
          });
        return results;
      }),
      operators.map(
        ([rootSource, ...restOfSources]) => ({
          ...activeWorkspace,
          ...rootSource,
          unstable_sources: [rootSource, ...restOfSources],
          type: "workspace"
        })
      )
    ).subscribe({
      next: setWorkspace,
      error: handleError
    });
    return () => subscription.unsubscribe();
  }, [activeWorkspace]), workspace;
}
function WorkspaceLoader({
  children,
  LoadingComponent
}) {
  const { activeWorkspace } = useActiveWorkspace(), workspace = useWorkspaceLoader(activeWorkspace);
  return workspace ? /* @__PURE__ */ jsxRuntime.jsx(WorkspaceProvider, { workspace, children: /* @__PURE__ */ jsxRuntime.jsx(
    SourceProvider,
    {
      source: workspace.unstable_sources[0],
      children: /* @__PURE__ */ jsxRuntime.jsx(WorkspaceRouterProvider, { LoadingComponent, workspace, children })
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(LoadingComponent, {});
}
function WorkspaceLoaderBoundary({ ConfigErrorsComponent, ...props2 }) {
  const [{ error }, setError] = React.useState({ error: null });
  if (error) throw error;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: setError, children: /* @__PURE__ */ jsxRuntime.jsx(WorkspaceLoader, { ...props2 }) });
}
Refractor__default.default.registerLanguage(bash__default.default);
Refractor__default.default.registerLanguage(javascript__default.default);
Refractor__default.default.registerLanguage(json__default.default);
Refractor__default.default.registerLanguage(jsx2__default.default);
Refractor__default.default.registerLanguage(typescript__default.default);
function StudioProvider({
  children,
  config,
  basePath,
  onSchemeChange,
  scheme,
  unstable_history: history2,
  unstable_noAuthBoundary: noAuthBoundary
}) {
  const _children = /* @__PURE__ */ jsxRuntime.jsx(WorkspaceLoaderBoundary, { LoadingComponent: LoadingBlock, ConfigErrorsComponent: ConfigErrorsScreen, children: /* @__PURE__ */ jsxRuntime.jsx(StudioTelemetryProvider, { config, children: /* @__PURE__ */ jsxRuntime.jsx(LocaleProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ResourceCacheProvider, { children }) }) }) });
  return /* @__PURE__ */ jsxRuntime.jsx(ColorSchemeProvider, { onSchemeChange, scheme, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.ToastProvider, { paddingY: 7, zOffset: Z_OFFSET$1.toast, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ErrorLogger, {}),
    /* @__PURE__ */ jsxRuntime.jsx(StudioErrorBoundary, { children: /* @__PURE__ */ jsxRuntime.jsx(WorkspacesProvider, { config, basePath, children: /* @__PURE__ */ jsxRuntime.jsx(
      ActiveWorkspaceMatcher,
      {
        unstable_history: history2,
        NotFoundComponent: NotFoundScreen,
        LoadingComponent: LoadingBlock,
        children: /* @__PURE__ */ jsxRuntime.jsx(StudioThemeProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(UserColorManagerProvider, { children: noAuthBoundary ? _children : /* @__PURE__ */ jsxRuntime.jsx(
          AuthBoundary,
          {
            LoadingComponent: LoadingBlock,
            AuthenticateComponent: AuthenticateScreen,
            NotAuthenticatedComponent: NotAuthenticatedScreen,
            children: _children
          }
        ) }) })
      }
    ) }) })
  ] }) });
}
function Studio(props2) {
  const {
    basePath,
    config,
    onSchemeChange,
    scheme,
    unstable_globalStyles: globalStyles2,
    unstable_history,
    unstable_noAuthBoundary
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    StudioProvider,
    {
      basePath,
      config,
      onSchemeChange,
      scheme,
      unstable_history,
      unstable_noAuthBoundary,
      children: [
        globalStyles2 && /* @__PURE__ */ jsxRuntime.jsx(GlobalStyle, {}),
        /* @__PURE__ */ jsxRuntime.jsx(StudioLayout, {})
      ]
    }
  );
}
function renderStudio(rootElement, config, options = !1) {
  if (!rootElement)
    throw new Error("Missing root element to mount application into");
  const opts = typeof options == "boolean" ? { reactStrictMode: options } : options, { reactStrictMode = !1, basePath } = opts, root = client$2.createRoot(rootElement);
  return root.render(
    reactStrictMode ? /* @__PURE__ */ jsxRuntime.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntime.jsx(Studio, { config, basePath, unstable_globalStyles: !0 }) }) : /* @__PURE__ */ jsxRuntime.jsx(Studio, { config, basePath, unstable_globalStyles: !0 })
  ), () => root.unmount();
}
function useClient(clientOptions) {
  const source = useSource();
  return clientOptions ? source.getClient(clientOptions) : (console.warn(
    'Calling `useClient()` without specifying an API version is deprecated and will stop working in the next dev-preview release - please migrate to use `useClient({apiVersion: "2021-06-07"})`.'
  ), source.getClient({ apiVersion: "2021-06-07" }));
}
const INITIAL = "connecting";
function useConnectionState(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.documentEvents(publishedDocId, docTypeName).pipe(
      operators.map((ev) => ev.type),
      operators.map((eventType) => eventType !== "reconnect"),
      operators.switchMap(
        (isConnected) => isConnected ? rxjs.of("connected") : rxjs.timer(200).pipe(operators.mapTo("reconnecting"))
      ),
      operators.startWith(INITIAL),
      operators.distinctUntilChanged()
    ),
    [documentStore.pair, publishedDocId, docTypeName],
    INITIAL
  );
}
function useDataset() {
  return useSource().dataset;
}
function useDocumentOperation(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.editOperations(publishedDocId, docTypeName),
    [docTypeName, documentStore.pair, publishedDocId]
  );
}
function useDocumentOperationEvent(publishedDocId, docTypeName) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.operationEvents(publishedDocId, docTypeName),
    [documentStore.pair, publishedDocId, docTypeName]
  );
}
function useEditState(publishedDocId, docTypeName, priority = "default") {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(() => {
    if (priority === "low") {
      const base = documentStore.pair.editState(publishedDocId, docTypeName).pipe(rxjs.share());
      return rxjs.merge(
        base.pipe(rxjs.take(1)),
        base.pipe(
          rxjs.skip(1),
          rxjs.debounce(() => rxjs.timer(1e3))
        )
      );
    }
    return documentStore.pair.editState(publishedDocId, docTypeName);
  }, [documentStore.pair, publishedDocId, docTypeName, priority]);
}
const EMPTY_ARRAY$6 = [], INITIAL_LOADING_STATE = {
  enabled: !0,
  error: null,
  features: EMPTY_ARRAY$6,
  isLoading: !0
};
function fetchFeatures({ versionedClient }) {
  return versionedClient.observable.request({
    uri: "/features",
    tag: "features"
  });
}
const cachedFeatureRequest = /* @__PURE__ */ new Map();
function useFeatureEnabled(featureKey) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), { projectId } = useSource();
  if (!cachedFeatureRequest.get(projectId)) {
    const features2 = fetchFeatures({ versionedClient }).pipe(operators.shareReplay());
    cachedFeatureRequest.set(projectId, features2);
  }
  return reactRx.useMemoObservable(
    () => (cachedFeatureRequest.get(projectId) || rxjs.of(EMPTY_ARRAY$6)).pipe(
      operators.map((features2 = []) => ({
        isLoading: !1,
        enabled: !!(features2 != null && features2.includes(featureKey)),
        features: features2,
        error: null
      })),
      operators.startWith(INITIAL_LOADING_STATE),
      operators.catchError((error) => rxjs.of({ isLoading: !1, enabled: !1, features: EMPTY_ARRAY$6, error }))
    ),
    [featureKey, projectId],
    INITIAL_LOADING_STATE
  );
}
const PERIODS = ["days", "hours", "minutes", "seconds", "milliseconds"];
function useFormattedDuration(durationMs, options) {
  const { style = "short", resolution = "seconds" } = options || {}, unitDisplay = style, locale = useCurrentLocale().id, listFormat = useListFormat({ type: "unit", style }), isNegative = durationMs < 0, duration = parseMilliseconds(Math.abs(durationMs)), formatters2 = React.useMemo(
    () => ({
      days: intlCache.numberFormat(locale, { style: "unit", unit: "day", unitDisplay }),
      hours: intlCache.numberFormat(locale, { style: "unit", unit: "hour", unitDisplay }),
      minutes: intlCache.numberFormat(locale, { style: "unit", unit: "minute", unitDisplay }),
      seconds: intlCache.numberFormat(locale, { style: "unit", unit: "second", unitDisplay }),
      milliseconds: intlCache.numberFormat(locale, {
        style: "unit",
        unit: "millisecond",
        unitDisplay
      })
    }),
    [locale, unitDisplay]
  ), parts = [];
  for (const period of PERIODS) {
    const value = duration[period];
    if (!value || resolution === "seconds" && period === "milliseconds")
      continue;
    const prefix = isNegative && parts.length === 0 ? "-" : "";
    parts.push(`${prefix}${formatters2[period].format(value)}`);
  }
  const formatted = parts.length === 0 ? (
    // If passing duration 0, we still want to show something
    formatters2[resolution].format(0)
  ) : (
    // Usually, we want to join the parts with the locales list formatter
    listFormat.format(parts)
  ), iso8601 = durationToISO8601(duration, isNegative);
  return { formatted, iso8601 };
}
function parseMilliseconds(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 864e5),
    hours: Math.trunc(milliseconds / 36e5) % 24,
    minutes: Math.trunc(milliseconds / 6e4) % 60,
    seconds: Math.trunc(milliseconds / 1e3) % 60,
    milliseconds: Math.trunc(milliseconds) % 1e3
  };
}
function durationToISO8601(dur, isNegative) {
  const date = dur.days ? `${dur.days}D` : "";
  let time = "";
  if (dur.hours && (time += `${dur.hours}H`), dur.minutes && (time += `${dur.minutes}M`), dur.milliseconds ? time += `${((dur.seconds * 1e3 + dur.milliseconds) / 1e3).toFixed(3)}S` : dur.seconds && (time += `${dur.seconds}S`), !date && !time)
    return "PT0S";
  const duration = `P${(time ? [date, time] : [date]).join("T")}`;
  return isNegative ? `-${duration}` : duration;
}
function useNumberFormat(options = {}) {
  const currentLocale = useCurrentLocale().id;
  return intlCache.numberFormat(currentLocale, options);
}
const FIVE_SECONDS = 1e3 * 5, TWENTY_SECONDS = 1e3 * 20, ONE_MINUTE = 1e3 * 60, ONE_HOUR = ONE_MINUTE * 60, NO_YEAR_DATE_ONLY_FORMAT = {
  month: "short",
  day: "numeric"
}, DATE_ONLY_FORMAT = {
  ...NO_YEAR_DATE_ONLY_FORMAT,
  year: "numeric"
}, FULL_DATE_FORMAT = {
  ...DATE_ONLY_FORMAT,
  hour: "numeric",
  minute: "numeric"
};
function useRelativeTime(time, options = {}) {
  const resolved = useFormatRelativeTime(time, options), [, forceUpdate] = React.useReducer((x) => x + 1, 0);
  return React.useEffect(() => {
    let timerId;
    function tick(interval) {
      timerId = window.setTimeout(() => {
        forceUpdate(), timerId = window.setTimeout(() => tick(interval), interval);
      }, interval);
    }
    return resolved.refreshInterval !== null && tick(resolved.refreshInterval), () => {
      timerId !== null && clearTimeout(timerId);
    };
  }, [forceUpdate, resolved.refreshInterval]), resolved.timestamp;
}
function useFormatRelativeTime(date, opts = {}) {
  const { t: t2 } = useTranslation(), currentLocale = useCurrentLocale().id, { timeZone, minimal } = opts, parsedDate = date instanceof Date ? date : new Date(date), useTemporalPhrase = !!opts.useTemporalPhrase, format2 = React.useCallback(
    function(count, unit) {
      const isNextOrPrevDay = unit === "day" && Math.abs(count) === 1, isNextOrPrevWeek = unit === "week" && Math.abs(count) === 1;
      return useTemporalPhrase || isNextOrPrevDay ? intlCache.relativeTimeFormat(currentLocale, {
        // Force 'long' formatting for dates within the next/previous week as `Intl.RelativeTimeFormat`
        // will display these as `next wk.` or `last wk.` – which we don't want!
        // Idiomatic dates should always be displayed in full. There may be a more elegant way to handle this.
        style: minimal && !isNextOrPrevWeek ? "short" : "long",
        numeric: "auto"
      }).format(count, unit) : intlCache.numberFormat(currentLocale, { style: "unit", unit, unitDisplay: minimal ? "short" : "long" }).format(Math.abs(count));
    },
    [currentLocale, useTemporalPhrase, minimal]
  );
  if (!parsedDate.getTime())
    return {
      timestamp: "",
      refreshInterval: null
    };
  const now = opts.relativeTo || Date.now(), diffMonths = dateFns.differenceInMonths(now, parsedDate), diffYears = dateFns.differenceInYears(now, parsedDate);
  if (diffMonths || diffYears)
    return opts.minimal && diffYears === 0 ? {
      timestamp: intlCache.dateTimeFormat(currentLocale, { ...NO_YEAR_DATE_ONLY_FORMAT, timeZone }).format(parsedDate),
      refreshInterval: null
    } : opts.minimal ? {
      timestamp: intlCache.dateTimeFormat(currentLocale, { ...DATE_ONLY_FORMAT, timeZone }).format(parsedDate),
      refreshInterval: null
    } : {
      timestamp: intlCache.dateTimeFormat(currentLocale, { ...FULL_DATE_FORMAT, timeZone }).format(parsedDate),
      refreshInterval: null
    };
  const diffWeeks = dateFns.differenceInWeeks(parsedDate, now);
  if (diffWeeks)
    return {
      timestamp: format2(diffWeeks, "week"),
      refreshInterval: ONE_HOUR
    };
  const diffDays = dateFns.differenceInDays(parsedDate, now);
  if (diffDays)
    return {
      timestamp: format2(diffDays, "day"),
      refreshInterval: ONE_HOUR
    };
  const diffHours = dateFns.differenceInHours(parsedDate, now);
  if (diffHours)
    return {
      timestamp: format2(diffHours, "hour"),
      refreshInterval: ONE_MINUTE
    };
  const diffMins = dateFns.differenceInMinutes(parsedDate, now);
  if (diffMins)
    return {
      timestamp: format2(diffMins, "minute"),
      refreshInterval: TWENTY_SECONDS
    };
  const diffSeconds = dateFns.differenceInSeconds(parsedDate, now);
  return Math.abs(diffSeconds) > 10 ? {
    timestamp: format2(diffSeconds, "second"),
    refreshInterval: FIVE_SECONDS
  } : { timestamp: t2("relative-time.just-now"), refreshInterval: FIVE_SECONDS };
}
const SYNCING = { isSyncing: !0 }, NOT_SYNCING = { isSyncing: !1 };
function useSyncState(publishedDocId, documentType) {
  const documentStore = useDocumentStore();
  return reactRx.useMemoObservable(
    () => documentStore.pair.consistencyStatus(publishedDocId, documentType).pipe(operators.map((isConsistent) => isConsistent ? NOT_SYNCING : SYNCING)),
    [documentStore.pair, documentType, publishedDocId],
    NOT_SYNCING
  );
}
function useTemplates() {
  return useSource().templates;
}
function useTimeAgo(time, options = {}) {
  return useRelativeTime(time, {
    minimal: options.minimal,
    useTemporalPhrase: options.agoSuffix
  });
}
function useTools() {
  return useSource().tools;
}
const INITIAL_STATE = {
  data: [],
  error: null,
  loading: !0
};
let cachedSystemGroups = null;
function useUserListWithPermissions(opts) {
  const { documentValue, permission } = opts, projectStore = useProjectStore(), userStore = useUserStore(), client2 = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), [state, setState] = React.useState(INITIAL_STATE), list$ = React.useMemo(() => {
    const users$ = projectStore.get().pipe(rxjs.map((res) => {
      var _a2;
      return (_a2 = res.members) == null ? void 0 : _a2.filter((m) => !m.isRobot);
    })).pipe(
      rxjs.switchMap(async (members) => {
        const ids = members.map(({ id: id2 }) => id2);
        return await userStore.getUsers(ids);
      }),
      rxjs.map(
        (res) => res.map((user) => ({
          displayName: user.displayName,
          id: user.id,
          granted: !1
        }))
      )
    ), cached = cachedSystemGroups, systemGroup$ = cached ? rxjs.of(cached) : client2.observable.fetch('*[_type == "system.group"]');
    return rxjs.forkJoin([users$, systemGroup$]).pipe(
      rxjs.mergeMap(async ([users, groups]) => {
        cached || (cachedSystemGroups = groups);
        const grantPromises = users == null ? void 0 : users.map(async (user) => {
          const flattenedGrants = [...groups.map((group2) => group2.members.includes(user.id) ? group2.grants : [])].flat(), { granted } = await grantsPermissionOn(
            user.id,
            flattenedGrants,
            permission,
            documentValue
          );
          return {
            ...user,
            granted
          };
        });
        return await Promise.all(grantPromises || []);
      })
    ).pipe(
      rxjs.map((res) => ({
        error: null,
        loading: !1,
        data: sortBy__default.default(res, "displayName")
      }))
    );
  }, [client2.observable, documentValue, projectStore, userStore, permission]);
  return React.useEffect(() => {
    const initial$ = rxjs.of(INITIAL_STATE), sub = rxjs.concat(initial$, list$).subscribe({
      next: setState,
      error: (error) => {
        setState({ data: [], error, loading: !1 });
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [list$]), state;
}
const StyledText = styledComponents.styled(ui.Text)`
  white-space: nowrap;
`;
function DocumentStatus({ absoluteDate, draft, published, singleLine }) {
  const { t: t2 } = useTranslation(), draftUpdatedAt = draft && "_updatedAt" in draft ? draft._updatedAt : "", publishedUpdatedAt = published && "_updatedAt" in published ? published._updatedAt : "", intlDateFormat = useDateTimeFormat({
    dateStyle: "medium",
    timeStyle: "short"
  }), draftDateAbsolute = draftUpdatedAt && intlDateFormat.format(new Date(draftUpdatedAt)), publishedDateAbsolute = publishedUpdatedAt && intlDateFormat.format(new Date(publishedUpdatedAt)), draftUpdatedTimeAgo = useRelativeTime(draftUpdatedAt || "", {
    minimal: !0,
    useTemporalPhrase: !0
  }), publishedUpdatedTimeAgo = useRelativeTime(publishedUpdatedAt || "", {
    minimal: !0,
    useTemporalPhrase: !0
  }), publishedDate = absoluteDate ? publishedDateAbsolute : publishedUpdatedTimeAgo, updatedDate = absoluteDate ? draftDateAbsolute : draftUpdatedTimeAgo;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: singleLine ? "center" : "flex-start",
      "data-testid": "pane-footer-document-status",
      direction: singleLine ? "row" : "column",
      gap: 2,
      wrap: "nowrap",
      children: [
        !publishedDate && /* @__PURE__ */ jsxRuntime.jsx(StyledText, { size: 1, weight: "medium", children: t2("document-status.not-published") }),
        publishedDate && /* @__PURE__ */ jsxRuntime.jsx(StyledText, { size: 1, weight: "medium", children: t2("document-status.published", { date: publishedDate }) }),
        updatedDate && /* @__PURE__ */ jsxRuntime.jsx(StyledText, { muted: !0, size: 1, wrap: "nowrap", children: t2("document-status.edited", { date: updatedDate }) })
      ]
    }
  );
}
const actionIds = /* @__PURE__ */ new WeakMap();
let counter = 0;
function getHookId(actionHook) {
  const cachedId = actionIds.get(actionHook);
  if (cachedId) return cachedId;
  const id2 = `${actionHook.name || actionHook.displayName || "<anonymous>"}-${counter++}`;
  return actionIds.set(actionHook, id2), id2;
}
function useShallowCompareMemoize(value) {
  const ref = React.useRef(void 0);
  return shallowEquals__default.default(value, ref.current) || (ref.current = value), [ref.current];
}
function useShallowCompareEffect(callback, dependencies) {
  React.useEffect(callback, useShallowCompareMemoize(dependencies));
}
const HookStateContainer = React.memo(
  function(props2) {
    const { hook, args, id: id2, onNext, onReset, onRequestUpdate } = props2, hookState = hook({
      ...args,
      onComplete: () => {
        onReset(id2);
      }
    });
    return useShallowCompareEffect(() => (onNext(id2, hookState), onRequestUpdate(), () => {
      onNext(id2, null), onRequestUpdate();
    }), hookState), null;
  },
  (prev, next) => prev.args === next.args
), requestIdleCallbackShim = (callback) => {
  const start = Date.now();
  return setTimeout(() => {
    callback({
      didTimeout: !1,
      timeRemaining() {
        return Math.max(0, Date.now() - start);
      }
    });
  }, 1);
}, cancelIdleCallbackShim = (handle) => clearTimeout(handle), _requestIdleCallback = typeof requestIdleCallback > "u" ? requestIdleCallbackShim : requestIdleCallback, _cancelIdleCallback = typeof cancelIdleCallback > "u" ? cancelIdleCallbackShim : cancelIdleCallback, throttleOptions = { trailing: !0 };
function GetHookCollectionState(props2) {
  const { hooks, args, children, group: group2, onReset } = props2, statesRef = React.useRef({}), [tickId, setTick] = React.useState(0), [keys, setKeys] = React.useState({}), ricHandle = React.useRef(null), handleRequestUpdate = React.useCallback(() => {
    ricHandle.current && _cancelIdleCallback(ricHandle.current), ricHandle.current = _requestIdleCallback(() => {
      ricHandle.current = null, setTick((tick) => tick + 1);
    });
  }, []), handleRequestUpdateThrottled = useThrottledCallback(
    handleRequestUpdate,
    60,
    throttleOptions
  ), handleNext = React.useCallback(
    (id2, hookState) => {
      const hookGroup = (hookState == null ? void 0 : hookState.group) || ["default"];
      if (hookState === null || group2 && !hookGroup.includes(group2))
        delete statesRef.current[id2];
      else {
        const current = statesRef.current[id2];
        statesRef.current[id2] = { ...current, value: hookState };
      }
    },
    [group2]
  ), handleReset = React.useCallback(
    (id2) => {
      setKeys((currentKeys) => ({ ...currentKeys, [id2]: (currentKeys[id2] || 0) + 1 })), onReset && onReset();
    },
    [onReset]
  ), hookIds = React.useMemo(() => hooks.map((hook) => getHookId(hook)), [hooks]), states = React.useMemo(
    () => hookIds.map((id2) => {
      var _a2;
      return (_a2 = statesRef.current[id2]) == null ? void 0 : _a2.value;
    }).filter(isNonNullable$3),
    // eslint-disable-next-line react-hooks/exhaustive-deps -- tickId is used to refresh the memo, before it can be removed it needs to be investigated what impact it has
    [hookIds, tickId]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    hooks.map((hook) => {
      const id2 = getHookId(hook), key = keys[id2] || 0;
      return /* @__PURE__ */ jsxRuntime.jsx(
        HookStateContainer,
        {
          hook,
          id: id2,
          args,
          onNext: handleNext,
          onRequestUpdate: handleRequestUpdateThrottled,
          onReset: handleReset
        },
        `${id2}-${key}`
      );
    }),
    children({ states })
  ] });
}
function Hotkeys({ makePlatformAware = !0, keys: hotKeys = [], ...props2 }) {
  const keys = makePlatformAware ? hotKeys.map(platformifyKey) : hotKeys;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Hotkeys, { ...props2, keys });
}
const IS_APPLE_DEVICE = typeof navigator > "u" || typeof navigator.platform != "string" ? !1 : /Mac|iPod|iPhone|iPad/.test(navigator.platform || "");
function platformifyKey(key) {
  const lowerKey = key.toLowerCase();
  return lowerKey === "alt" && IS_APPLE_DEVICE ? matchCase(key, "option") : lowerKey === "option" && !IS_APPLE_DEVICE ? matchCase(key, "alt") : key;
}
function matchCase(original, target) {
  const orgLength = original.length;
  return target.replace(/./g, (char, i) => i < orgLength && original[i] === original[i].toUpperCase() ? char.toUpperCase() : char);
}
function IntentButton(props2) {
  return props2.disabled ? /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { ...props2, as: "a", role: "link", "aria-disabled": "true" }) : /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { ...props2, as: router.IntentLink });
}
const StyledContainer = styledComponents.styled(ui.Container)((props2) => {
  const { theme: theme2 } = props2, { container, media } = theme2.sanity;
  return ui._responsive(media, props2.$width, (val) => ({
    // Make sure that the Container gets the correct width when used inside a popover.
    width: val === "auto" ? "none" : ui.rem(container[val]),
    // Make sure that the Container width is constrained by available space.
    maxWidth: "100%"
  }));
}), PopoverContainer = React.forwardRef(function(props2, ref) {
  const { width, ...restProps } = props2, widthArr = ui.useArrayProp(width);
  return /* @__PURE__ */ jsxRuntime.jsx(StyledContainer, { ...restProps, "data-ui": "PopoverContainer", $width: widthArr, ref });
}), StyledPopover$2 = styledComponents.styled(TooltipDelayGroupProvider.Popover)(() => styledComponents.css`
    // Make the popover scrollable if it overflows the viewport
    [data-ui='Popover__wrapper'] {
      overflow: auto;
    }
  `), StickyLayer = styledComponents.styled(ui.Layer)((props2) => {
  const radii = props2.theme.sanity.radius[3];
  return styledComponents.css`
    position: sticky;
    top: 0;
    width: 100%;
    background: var(--card-bg-color);
    border-bottom: 1px solid var(--card-border-color);
    border-top-left-radius: ${radii}px;
    border-top-right-radius: ${radii}px;
  `;
});
function PopoverDialog(props2) {
  const { children, header, onClose, referenceElement, containerRef, width } = props2, handleClose = React.useCallback(() => {
    onClose(), referenceElement == null || referenceElement.focus();
  }, [onClose, referenceElement]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledPopover$2,
    {
      portal: !0,
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverContainer, { width, children: /* @__PURE__ */ jsxRuntime.jsx(FocusLock__default.default, { autoFocus: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { ref: containerRef, children: [
        /* @__PURE__ */ jsxRuntime.jsx(StickyLayer, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, paddingLeft: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: header }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.Button,
            {
              icon: icons.CloseIcon,
              mode: "bleed",
              onClick: handleClose,
              tooltipProps: { content: "Close" }
            }
          )
        ] }) }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children })
      ] }) }) }),
      open: !0,
      referenceElement
    }
  );
}
const StyledCard = styledComponents.styled(ui.Card)(() => styledComponents.css`
    /* TextWithTone uses its own logic to set color, and we therefore need */
    /* to override this logic in order to set the correct color in different states */
    &[data-selected],
    &[data-pressed],
    &:active {
      [data-ui='TextWithTone'] {
        color: inherit;
      }
    }
  `);
function usePreviewCard() {
  const context = React.useContext(_singletons.PreviewCardContext);
  if (!context)
    throw new Error("PreviewCard: missing context value");
  return context;
}
const PreviewCard = React.forwardRef(function(props2, ref) {
  const { children, selected, as, ...restProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(StyledCard, { "data-ui": "PreviewCard", ...restProps, forwardedAs: as, ref, selected, children: /* @__PURE__ */ jsxRuntime.jsx(_singletons.PreviewCardContext.Provider, { value: { selected }, children }) });
}), PREVIEW_SIZES = {
  block: {
    icon: 25,
    media: { width: 33, height: 33 }
  },
  blockImage: {
    icon: 25,
    media: { width: 600, height: 400 }
  },
  compact: {
    icon: 21,
    media: { width: 25, height: 25 }
  },
  default: {
    icon: 21,
    media: { width: 33, height: 33 }
  },
  detail: {
    icon: 25,
    media: { width: 73, height: 73 }
  },
  inline: {
    icon: 15,
    media: { width: 15, height: 15 }
  },
  media: {
    icon: 25,
    media: { width: 160, height: 160 }
  }
}, MediaWrapper = styledComponents.styled.span((props2) => {
  const { $dimensions, $layout, $radius, $responsive } = props2, width = $dimensions.width || 0, height = $dimensions.width || 0, iconSize = PREVIEW_SIZES[$layout].icon;
  return styledComponents.css`
    position: relative;
    width: ${$responsive ? "100%" : ui.rem(width)};
    height: ${$responsive ? "100%" : ui.rem(height)};
    min-width: ${$responsive ? void 0 : ui.rem(width)};
    border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[$radius])};
    display: flex;
    overflow: hidden;
    overflow: clip;
    align-items: center;
    justify-content: center;

    & img {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: inherit;
    }

    & svg {
      // Shared styles for SVG icons
      color: var(--card-icon-color);
      display: block;
      flex: 1;

      // Specific styles for non Sanity icons
      &:not([data-sanity-icon]) {
        height: 1em;
        width: 1em;
        max-width: 1em;
        max-height: 1em;
      }

      // Specific styles for Sanity icons
      &[data-sanity-icon] {
        display: block;
        font-size: calc(${iconSize} / 16 * 1em);
      }
    }

    & > span[data-border] {
      display: block;
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      box-shadow: inset 0 0 0 1px var(--card-fg-color);
      opacity: 0.1;
      border-radius: inherit;
      pointer-events: none;
    }
  `;
});
MediaWrapper.displayName = "MediaWrapper";
function Media(props2) {
  const { border = !0, dimensions, layout, media, radius = 1, responsive = !1, styles } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    MediaWrapper,
    {
      $dimensions: dimensions,
      $layout: layout,
      $radius: radius,
      $responsive: responsive,
      className: styles == null ? void 0 : styles.media,
      "data-testid": "Media",
      children: [
        renderMedia({ dimensions, layout, media }),
        border && /* @__PURE__ */ jsxRuntime.jsx("span", { "data-border": !0 })
      ]
    }
  );
}
function renderMedia(props2) {
  const { dimensions, layout, media, styles } = props2;
  return reactIs.isValidElementType(media) ? React.createElement(media, { dimensions, layout }) : typeof media == "string" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "span", className: styles == null ? void 0 : styles.mediaString, size: 1, children: media }) : React.isValidElement(media) ? media : null;
}
function renderPreviewMedia(value, layout, dimensions) {
  return reactIs.isValidElementType(value) ? React.createElement(value, { layout, dimensions }) : typeof value == "string" ? /* @__PURE__ */ jsxRuntime.jsx("div", { children: value }) : value;
}
function renderPreviewNode(value, layout, fallbackNode) {
  return typeof value == "string" ? value : reactIs.isValidElementType(value) ? React.createElement(value, { layout }) : value || fallbackNode;
}
const DEFAULT_MEDIA_DIMENSIONS$6 = {
  ...PREVIEW_SIZES.compact.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, Root$6 = styledComponents.styled(ui.Flex)`
  height: ${ui.rem(PREVIEW_SIZES.compact.media.height)};
  box-sizing: content-box;
`, TitleSkeleton$3 = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(160)};
  width: 80%;
`;
function CompactPreview(props2) {
  const { children, isPlaceholder, media, status, title } = props2, { t: t2 } = useTranslation(), statusNode = status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-testid": "compact-preview__status", paddingLeft: 4, paddingRight: 1, children: renderPreviewNode(status, "compact") });
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(
    Root$6,
    {
      align: "center",
      "data-testid": "default-preview",
      paddingLeft: media ? 1 : 2,
      paddingRight: 2,
      paddingY: 1,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { animated: !0, radius: 2, style: PREVIEW_SIZES.compact.media }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { "data-testid": "compact-preview__heading", flex: 1, space: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton$3, {}) }),
        statusNode
      ] })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsxs(
    Root$6,
    {
      align: "center",
      "data-testid": "compact-preview",
      paddingLeft: media ? 1 : 2,
      paddingRight: 2,
      paddingY: 1,
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
          media && /* @__PURE__ */ jsxRuntime.jsx(
            Media,
            {
              border: !1,
              dimensions: DEFAULT_MEDIA_DIMENSIONS$6,
              layout: "compact",
              media
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { "data-testid": "compact-preview__header", flex: 1, space: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, style: { color: "inherit" }, textOverflow: "ellipsis", weight: "medium", children: [
            title && renderPreviewNode(title, "compact"),
            !title && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("preview.default.title-fallback") })
          ] }) }),
          statusNode
        ] }),
        children && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 1, children })
      ]
    }
  );
}
const DEFAULT_MEDIA_DIMENSIONS$5 = {
  ...PREVIEW_SIZES.default.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, Root$5 = styledComponents.styled(ui.Flex)`
  height: ${ui.rem(PREVIEW_SIZES.default.media.height)};
  box-sizing: content-box;
`, TitleSkeleton$2 = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(160)};
  width: 80%;
`, SubtitleSkeleton$2 = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(120)};
  width: 60%;
`;
function DefaultPreview(props2) {
  const { title, subtitle, media, status, isPlaceholder, children, styles } = props2, { t: t2 } = useTranslation(), rootClassName = classNames__default.default(styles == null ? void 0 : styles.root, !!subtitle && (styles == null ? void 0 : styles.hasSubtitle)), statusNode = status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { className: styles == null ? void 0 : styles.status, "data-testid": "default-preview__status", children: renderPreviewNode(status, "default") });
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(
    Root$5,
    {
      align: "center",
      className: styles == null ? void 0 : styles.placeholder,
      "data-testid": "default-preview",
      padding: 2,
      paddingLeft: media ? 2 : 3,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Skeleton, { animated: !0, radius: 1, style: PREVIEW_SIZES.default.media }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "data-testid": "default-preview__heading", flex: 1, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton$2, {}),
          /* @__PURE__ */ jsxRuntime.jsx(SubtitleSkeleton$2, {})
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", padding: 1, children: statusNode })
      ] })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    Root$5,
    {
      align: "center",
      className: rootClassName,
      "data-testid": "default-preview",
      padding: 2,
      paddingLeft: media ? 2 : 3,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
          Media,
          {
            dimensions: DEFAULT_MEDIA_DIMENSIONS$5,
            layout: "default",
            media,
            styles
          }
        ) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { className: styles == null ? void 0 : styles.heading, "data-testid": "default-preview__header", flex: 1, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(
            ui.Text,
            {
              className: styles == null ? void 0 : styles.title,
              size: 1,
              style: { color: "inherit" },
              textOverflow: "ellipsis",
              weight: "medium",
              children: [
                title && renderPreviewNode(title, "default"),
                !title && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t2("preview.default.title-fallback") })
              ]
            }
          ),
          subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", className: styles == null ? void 0 : styles.subtitle, children: renderPreviewNode(subtitle, "default") })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", padding: 1, children: statusNode }),
        children && /* @__PURE__ */ jsxRuntime.jsx("div", { className: styles == null ? void 0 : styles.children, children })
      ] })
    }
  );
}
const RootFlex = styledComponents.styled(ui.Flex).attrs({ align: "center" })`
  height: ${ui.rem(PREVIEW_SIZES.detail.media.height)};
`, StatusBox = styledComponents.styled(ui.Box)`
  white-space: nowrap;
`, MediaSkeleton$1 = styledComponents.styled(ui.Skeleton).attrs({ animated: !0, radius: 2 })`
  width: ${ui.rem(PREVIEW_SIZES.detail.media.width)};
  height: ${ui.rem(PREVIEW_SIZES.detail.media.height)};
`, TitleSkeleton$1 = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(160)}; /* 80% of 200px */
  width: 80%;
`, SubtitleSkeleton$1 = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(120)}; /* 60% of 200px */
  width: 60%;
`, DescriptionSkeleton = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(180)}; /* 90% of 200px */
  width: 90%;
`, DescriptionText = styledComponents.styled(ui.Text)(({ theme: theme2 }) => {
  const { fonts } = theme2.sanity, textSize1 = fonts.text.sizes[1], maxLines = 2, maxHeight = textSize1.lineHeight * maxLines;
  return styledComponents.css`
    & > span {
      max-height: ${ui.rem(maxHeight)};

      /* Multi-line text overflow */
      display: -webkit-box;
      overflow: hidden;
      overflow: clip;
      text-overflow: ellipsis;
      -webkit-line-clamp: ${maxLines};
      -webkit-box-orient: vertical;
    }
  `;
}), DEFAULT_MEDIA_DIMENSIONS$4 = {
  ...PREVIEW_SIZES.detail.media,
  fit: "crop",
  aspect: 1,
  dpr: useDevicePixelRatio.getDevicePixelRatio()
};
function DetailPreview(props2) {
  const {
    title,
    subtitle,
    description,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$4,
    media,
    status,
    children,
    isPlaceholder
  } = props2, { t: t2 } = useTranslation(), statusNode = status && /* @__PURE__ */ jsxRuntime.jsx(StatusBox, { marginLeft: 3, paddingRight: 1, children: renderPreviewNode(status, "detail") });
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(
    RootFlex,
    {
      "data-testid": "detail-preview",
      paddingLeft: media ? 2 : 3,
      paddingRight: 2,
      paddingY: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 3, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(MediaSkeleton$1, { "data-testid": "detail-preview__media" }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", "data-testid": "detail-preview__header", flex: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton$1, {}),
          /* @__PURE__ */ jsxRuntime.jsx(SubtitleSkeleton$1, {}),
          description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(DescriptionSkeleton, {}) })
        ] }) }),
        statusNode
      ] })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    RootFlex,
    {
      "data-testid": "detail-preview",
      paddingLeft: media ? 2 : 3,
      paddingRight: 2,
      paddingY: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 3, children: [
        media && /* @__PURE__ */ jsxRuntime.jsx(Media, { dimensions: mediaDimensions, layout: "detail", media }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", "data-testid": "detail-preview__header", flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { textOverflow: "ellipsis", size: 1, style: { color: "inherit" }, weight: "medium", children: [
              title && renderPreviewNode(title, "detail"),
              !title && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t2("preview.default.title-fallback") })
            ] }),
            subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "detail") }),
            description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(DescriptionText, { muted: !0, size: 1, children: renderPreviewNode(description, "detail") }) })
          ] }),
          statusNode
        ] }),
        children
      ] })
    }
  );
}
const SIZE = 43, STROKE_WIDTH$1 = 3, Root$4 = styledComponents.styled.svg`
  width: ${SIZE}px;
  height: ${SIZE}px;
  transform: rotate(-90deg);
`, BgCircle = styledComponents.styled.circle(({ theme: theme2 }) => {
  const { color: color$1 } = theme2.sanity;
  return styledComponents.css`
    fill: none;
    stroke: ${color.hues.gray[color$1.dark ? 900 : 100].hex};
    stroke-width: ${STROKE_WIDTH$1}px;
  `;
}), ProgressCircle = styledComponents.styled.circle(({ theme: theme2 }) => {
  const { color: color$1 } = theme2.sanity;
  return styledComponents.css`
    fill: none;
    stroke: ${color.hues.blue[color$1.dark ? 400 : 500].hex};
    stroke-width: ${STROKE_WIDTH$1}px;
    transition: stroke-dashoffset 75ms;
  `;
});
function CircularProgress(props2) {
  const { value: valueProp } = props2, value = Math.min(Math.max(valueProp, 0), 100), radius = SIZE / 2 - STROKE_WIDTH$1 / 2, circ = 2 * Math.PI * radius, offset = (100 - value) / 100 * circ, viewBox = `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`;
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$4, { viewBox, children: [
    /* @__PURE__ */ jsxRuntime.jsx(BgCircle, { cx: SIZE, cy: SIZE, r: radius }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ProgressCircle,
      {
        cx: SIZE,
        cy: SIZE,
        r: radius,
        style: {
          strokeDasharray: circ,
          strokeDashoffset: `${offset}px`
        }
      }
    )
  ] });
}
const STROKE_WIDTH = 0.5, Root$3 = styledComponents.styled(ui.Card)`
  overflow: hidden;
  overflow: clip;
`, Bar = styledComponents.styled(ui.Card)(({ theme: theme2 }) => {
  const { color: color$1 } = theme2.sanity;
  return styledComponents.css`
    height: ${STROKE_WIDTH}rem;
    background: ${color.hues.blue[color$1.dark ? 400 : 500].hex};
    transition: transform 75ms;
  `;
});
function LinearProgress(props2) {
  const { value } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(Root$3, { radius: 5, children: /* @__PURE__ */ jsxRuntime.jsx(Bar, { radius: 5, style: { transform: `translate3d(${value - 100}%, 0, 0)` } }) });
}
const RootBox$1 = styledComponents.styled(ui.Box)`
  position: relative;
`, MediaFlex = styledComponents.styled(ui.Flex).attrs({ align: "center", justify: "center" })`
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
`, MediaSkeleton = styledComponents.styled(ui.Skeleton).attrs({ animated: !0, radius: 2 })`
  width: 100%;
  height: 100%;
`, ProgressFlex = styledComponents.styled(ui.Flex).attrs({ align: "center", justify: "center" })`
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;

  &:before {
    background-color: var(--card-bg-color);
    opacity: 0.75;
    content: '';
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
  }

  > svg {
    position: relative;
    z-index: 2;
  }
`, TooltipContentStack = styledComponents.styled(ui.Stack).attrs({ space: 2 })`
  max-width: ${ui.rem(200)};
`, DEFAULT_MEDIA_DIMENSIONS$3 = {
  ...PREVIEW_SIZES.media.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
};
function MediaPreview(props2) {
  const {
    media,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$3,
    children,
    isPlaceholder,
    progress = -1,
    subtitle,
    title,
    withBorder = !0,
    withRadius = !0
  } = props2, aspect = mediaDimensions.aspect || 1, STYLES_PADDER = React.useMemo(() => ({ paddingBottom: `${100 / aspect}%` }), [aspect]), tooltipContent = React.useMemo(() => !title || !subtitle ? null : /* @__PURE__ */ jsxRuntime.jsxs(TooltipContentStack, { children: [
    title && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, weight: "medium", children: renderPreviewNode(title, "media") }),
    subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: renderPreviewNode(subtitle, "media") })
  ] }), [subtitle, title]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(RootBox$1, { "data-testid": "media-preview", flex: 1, overflow: "hidden", children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: STYLES_PADDER }),
    /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: tooltipContent, disabled: !tooltipContent, placement: "top", portal: !0, children: /* @__PURE__ */ jsxRuntime.jsxs(MediaFlex, { children: [
      isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(MediaSkeleton, {}) : /* @__PURE__ */ jsxRuntime.jsx(
        Media,
        {
          border: withBorder,
          dimensions: mediaDimensions,
          layout: "media",
          media,
          radius: withRadius ? 1 : 0,
          responsive: !0
        }
      ),
      typeof progress == "number" && progress > -1 && /* @__PURE__ */ jsxRuntime.jsx(ProgressFlex, { children: /* @__PURE__ */ jsxRuntime.jsx(CircularProgress, { value: progress }) })
    ] }) }),
    children
  ] }) });
}
const HeaderFlex$4 = styledComponents.styled(ui.Flex).attrs({ align: "center" })`
  height: ${ui.rem(PREVIEW_SIZES.block.media.height)};
  white-space: nowrap;
  position: relative;
  z-index: 1;
`, MediaCard = styledComponents.styled(ui.Card)`
  overflow: hidden;
  position: relative;
  padding-bottom: ${({ $ratio }) => $ratio}%;

  & > span {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }
`, RootBox = styledComponents.styled(ui.Box).attrs({ overflow: "hidden" })`
  border-radius: ${({ theme: theme2 }) => theme2.sanity.radius[1]}px;
`, DEFAULT_MEDIA_DIMENSIONS$2 = {
  ...PREVIEW_SIZES.blockImage.media,
  fit: "fillmax",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, getRatio = (dimensions) => {
  const { height, width } = dimensions;
  return !height || !width ? 1 : height / width * 100;
};
function BlockImagePreview(props2) {
  const {
    actions,
    title,
    subtitle,
    description,
    fallbackTitle = "Untitled",
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$2,
    media,
    children,
    status
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(RootBox, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
      /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex$4, { paddingBottom: 3, paddingLeft: 2, paddingRight: 1, paddingTop: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
          (title || fallbackTitle) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: title ? renderPreviewNode(title, "block") : fallbackTitle }),
          subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "block") })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, paddingLeft: 1, children: [
          status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, paddingY: 3, children: renderPreviewNode(status, "block") }),
          actions
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(
        MediaCard,
        {
          $ratio: getRatio(mediaDimensions),
          __unstable_checkered: !0,
          display: "flex",
          sizing: "border",
          radius: 2,
          tone: "inherit",
          children: /* @__PURE__ */ jsxRuntime.jsx(
            Media,
            {
              border: !1,
              dimensions: mediaDimensions,
              layout: "blockImage",
              media,
              radius: 0,
              responsive: !0
            }
          )
        }
      )
    ] }),
    description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, paddingY: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: renderPreviewNode(description, "block") }) }),
    children && /* @__PURE__ */ jsxRuntime.jsx("div", { children })
  ] });
}
const DEFAULT_MEDIA_DIMENSIONS$1 = {
  ...PREVIEW_SIZES.block.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, HeaderFlex$3 = styledComponents.styled(ui.Flex).attrs({ align: "center" })`
  min-height: ${ui.rem(PREVIEW_SIZES.block.media.height)};
`;
function BlockPreview(props2) {
  const {
    actions,
    title,
    subtitle,
    description,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS$1,
    media,
    status,
    children
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { "data-testid": "block-preview", space: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex$3, { "data-testid": "block-preview__header", children: [
      media && /* @__PURE__ */ jsxRuntime.jsx(Media, { dimensions: mediaDimensions, layout: "block", media }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { flex: 1, paddingLeft: media ? 2 : 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: title ? renderPreviewNode(title, "block") : "Untitled" }),
        subtitle && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(subtitle, "block") }) }),
        description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: renderPreviewNode(description, "block") }) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, paddingLeft: 1, children: [
        status && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, paddingY: 3, children: renderPreviewNode(status, "block") }),
        actions
      ] })
    ] }),
    children && /* @__PURE__ */ jsxRuntime.jsx("div", { "data-testid": "block-preview__children", children })
  ] });
}
const RootSpan = styledComponents.styled.span`
  display: inline-flex;
  align-items: center;
  vertical-align: top;
  height: calc(1em - 1px);
  max-width: 100%;
`, MediaSpan = styledComponents.styled.span`
  position: relative;
  display: inline-block;
  width: calc(1em - 1px);
  height: calc(1em - 1px);
  min-width: calc(1em - 1px);

  & img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[1])};
  }

  & img + span {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    box-shadow: inset 0 0 0 1px var(--card-fg-color);
    opacity: 0.2;
    border-radius: ${({ theme: theme2 }) => ui.rem(theme2.sanity.radius[1])};
  }

  & svg {
    display: block;
    font-size: calc(14 / 16 * 1em);
    margin: 1px 0;

    &[data-sanity-icon] {
      font-size: calc(18 / 16 * 1em);
      margin: calc(1px + (2 / 18 * -1em)) 0;
    }
  }
`, TextSpan = styledComponents.styled(ui.Text).attrs({ forwardedAs: "span" })(({ theme: theme2 }) => {
  const textFont = theme2.sanity.fonts.text, textSize = textFont.sizes[1];
  return styledComponents.css`
    font-size: calc(${textSize.fontSize} / 16 * 1em);
    font-weight: ${textFont.weights.medium};
    box-sizing: border-box;
    display: inline-block;
    vertical-align: top;
    line-height: ${textSize.lineHeight / textSize.fontSize};
    padding-left: 0.5em;
    padding-right: calc(0.5em - 2px);
    min-width: 0;

    & > span {
      display: block;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      overflow: clip;
    }
  `;
}), DEFAULT_MEDIA_DIMENSIONS = {
  ...PREVIEW_SIZES.inline.media,
  fit: "crop",
  aspect: 1,
  dpr: useDevicePixelRatio.getDevicePixelRatio()
};
function InlinePreview(props2) {
  const {
    title,
    fallbackTitle = "Untitled",
    media,
    mediaDimensions = DEFAULT_MEDIA_DIMENSIONS
  } = props2;
  return /* @__PURE__ */ jsxRuntime.jsxs(RootSpan, { "data-testid": "inline-preview", children: [
    media && /* @__PURE__ */ jsxRuntime.jsxs(MediaSpan, { "data-testid": "inline-preview-media", children: [
      renderPreviewMedia(media, "inline", mediaDimensions),
      /* @__PURE__ */ jsxRuntime.jsx("span", {})
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(TextSpan, { "data-testid": "inline-preview-title", size: 1, children: renderPreviewNode(title, "inline", fallbackTitle) })
  ] });
}
const DEFAULT_MEDIA_DIMENSION = {
  ...PREVIEW_SIZES.default.media,
  aspect: 1,
  fit: "crop",
  dpr: useDevicePixelRatio.getDevicePixelRatio()
}, Root$2 = styledComponents.styled(ui.Box)`
  height: 100%;

  a {
    color: currentColor;
    text-decoration: none;
  }

  svg[data-sanity-icon] {
    margin: 0;
  }
`, HeaderFlex$2 = styledComponents.styled(ui.Flex).attrs({ align: "center" })`
  height: ${ui.rem(PREVIEW_SIZES.default.media.height)};
`, TitleSkeleton = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1 })`
  max-width: ${ui.rem(160)};
  width: 80%;
`, SubtitleSkeleton = styledComponents.styled(ui.TextSkeleton).attrs({ animated: !0, radius: 1, size: 1 })`
  max-width: ${ui.rem(120)};
  width: 60%;
`;
function TemplatePreview(props2) {
  const {
    description,
    isPlaceholder,
    media,
    mediaDimensions = DEFAULT_MEDIA_DIMENSION,
    subtitle,
    title = "Untitled"
  } = props2;
  return isPlaceholder ? /* @__PURE__ */ jsxRuntime.jsx(Root$2, { children: /* @__PURE__ */ jsxRuntime.jsx(HeaderFlex$2, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(TitleSkeleton, {}),
    /* @__PURE__ */ jsxRuntime.jsx(SubtitleSkeleton, {})
  ] }) }) }) : /* @__PURE__ */ jsxRuntime.jsxs(Root$2, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex$2, { children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
        reactIs.isValidElementType(title) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", children: React.createElement(title, { layout: "default" }) }),
        React.isValidElement(title) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", children: title }),
        reactIs.isValidElementType(subtitle) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: React.createElement(subtitle, { layout: "default" }) }),
        React.isValidElement(subtitle) && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: subtitle })
      ] }),
      media && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "flex-start", paddingLeft: 2, children: /* @__PURE__ */ jsxRuntime.jsx(Media, { dimensions: mediaDimensions, layout: "default", media }) })
    ] }),
    description && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, style: { whiteSpace: "break-spaces" }, children: description }) })
  ] });
}
function RelativeTime({ time, ...options }) {
  const timestamp = time instanceof Date ? time : new Date(time), timeAgo = useRelativeTime(timestamp, options);
  return /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: timestamp.toISOString(), title: timeAgo, children: timeAgo });
}
const MUTATION_ATTRIBUTE_FILTER = ["aria-hidden", "disabled", "href"], FOCUSABLE = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
function getFocusableElements(element) {
  return [...element.querySelectorAll(FOCUSABLE)].filter(
    (el) => !el.hasAttribute("disabled") && el.getAttribute("aria-hidden") !== "true"
  );
}
function useRovingFocus(props2) {
  const {
    direction = "horizontal",
    initialFocus,
    loop = !0,
    navigation = ["arrows"],
    pause = !1,
    rootElement
  } = props2, [focusedIndex, setFocusedIndex] = React.useState(-1), [focusableElements, setFocusableElements] = React.useState([]), focusableLen = focusableElements.length, lastFocusableIndex = focusableLen - 1, nextKey = direction === "horizontal" ? "ArrowRight" : "ArrowDown", prevKey = direction === "horizontal" ? "ArrowLeft" : "ArrowUp", handleSetElements = React.useCallback(() => {
    if (rootElement) {
      const els = getFocusableElements(rootElement);
      setFocusableElements(els);
    }
  }, [rootElement]), handleFocus = React.useCallback((index) => {
    setFocusedIndex(index);
  }, []), handleKeyDown = React.useCallback(
    (event) => {
      if (pause)
        return;
      const focusPrev = () => {
        event.preventDefault(), setFocusedIndex((prevIndex) => {
          const next = (prevIndex + lastFocusableIndex) % focusableLen;
          return !loop && next === lastFocusableIndex ? prevIndex : next;
        });
      }, focusNext = () => {
        event.preventDefault(), setFocusedIndex((prevIndex) => {
          const next = (prevIndex + 1) % focusableLen;
          return !loop && next === 0 ? prevIndex : next;
        });
      };
      event.key === "Tab" && navigation.includes("tab") && (event.shiftKey ? focusPrev() : focusNext()), navigation.includes("arrows") && (event.key === prevKey && focusPrev(), event.key === nextKey && focusNext());
    },
    [pause, prevKey, navigation, nextKey, lastFocusableIndex, focusableLen, loop]
  );
  React.useEffect(() => {
    handleSetElements();
  }, [handleSetElements, initialFocus, direction]), React.useEffect(() => {
    const mo = new MutationObserver(handleSetElements);
    return rootElement && mo.observe(rootElement, {
      childList: !0,
      subtree: !0,
      attributeFilter: MUTATION_ATTRIBUTE_FILTER
    }), () => {
      mo.disconnect();
    };
  }, [focusableElements, handleSetElements, rootElement]), React.useEffect(() => {
    var _a2;
    focusableElements.forEach((el, index) => {
      index === focusedIndex ? (el.setAttribute("tabIndex", "0"), el.setAttribute("aria-selected", "true"), el.focus(), el.onfocus = () => handleFocus(index), el.onblur = () => handleFocus(-1)) : (el.setAttribute("tabIndex", "-1"), el.setAttribute("aria-selected", "false"), el.onfocus = () => handleFocus(index));
    }), focusedIndex === -1 && focusableElements && ((_a2 = focusableElements[initialFocus === "last" ? lastFocusableIndex : 0]) == null || _a2.setAttribute("tabIndex", "0"));
  }, [focusableElements, focusedIndex, handleFocus, initialFocus, lastFocusableIndex]), React.useEffect(() => (rootElement == null || rootElement.addEventListener("keydown", handleKeyDown), () => {
    rootElement == null || rootElement.removeEventListener("keydown", handleKeyDown);
  }), [handleKeyDown, rootElement]);
}
const StyledButton = styledComponents.styled(TooltipDelayGroupProvider.Button)`
  position: relative;
  // The children in button is rendered inside a span, we need to absolutely position it.
  & > span:nth-child(2) {
    position: absolute;
    top: 6px;
    right: 6px;
    padding: 0;
  }
`, Dot = styledComponents.styled.div({
  width: 4,
  height: 4,
  borderRadius: 3,
  boxShadow: "0 0 0 1px var(--card-bg-color)"
}), StatusButton = React.forwardRef(function(props2, ref) {
  const {
    disabled: disabledProp,
    icon,
    "aria-label": label,
    mode = "bleed",
    text,
    tone,
    ...restProps
  } = props2, theme2 = ui.useTheme(), toneColor = tone && theme2.sanity.color.solid[tone], dotStyle = React.useMemo(() => ({ backgroundColor: toneColor == null ? void 0 : toneColor.enabled.bg }), [toneColor]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledButton,
    {
      "data-ui": "StatusButton",
      ...restProps,
      "aria-label": label,
      disabled: !!disabledProp,
      mode,
      ref,
      text,
      icon,
      children: tone && /* @__PURE__ */ jsxRuntime.jsx(Dot, { style: dotStyle })
    }
  );
}), TooltipOfDisabled = React.forwardRef(function({ children, content: content2, disabled, ...restProps }, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { ...restProps, content: content2, disabled: disabled || !content2, ref, children: /* @__PURE__ */ jsxRuntime.jsx("div", { children }) });
}), ImperativeToast = React.forwardRef((_, ref) => {
  const { push } = ui.useToast();
  return React.useImperativeHandle(ref, () => ({ push })), null;
});
ImperativeToast.displayName = "ImperativeToast";
function useZIndex() {
  return React.useContext(_singletons.ZIndexContext);
}
function LegacyLayerProvider({
  children,
  zOffset: zOffsetKey
}) {
  const zOffset = useZIndex()[zOffsetKey];
  return /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset, children });
}
function WithReferringDocuments({
  children,
  id: id2
}) {
  return children(useReferringDocuments(id2));
}
function ZIndexProvider({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.ZIndexContext.Provider, { value: _singletons.zIndexContextDefaults, children });
}
function getDialogCopy(t2) {
  return {
    thread: {
      title: t2("delete-thread.title"),
      body: t2("delete-thread.body"),
      confirmButtonText: t2("delete-thread.confirm")
    },
    comment: {
      title: t2("delete-comment.title"),
      body: t2("delete-comment.body"),
      confirmButtonText: t2("delete-comment.confirm")
    }
  };
}
function CommentDeleteDialog(props2) {
  const { isParent, onClose, commentId, onConfirm, loading, error } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), dialogCopy = getDialogCopy(t2), { title, body, confirmButtonText } = dialogCopy[isParent ? "thread" : "comment"], handleDelete = React.useCallback(() => {
    onConfirm(commentId);
  }, [commentId, onConfirm]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      footer: {
        cancelButton: {
          onClick: onClose
        },
        confirmButton: {
          loading,
          onClick: handleDelete,
          text: confirmButtonText,
          tone: "critical"
        }
      },
      header: title,
      id: "delete-comment-dialog",
      onClose,
      width: 0,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: body }),
        error && /* @__PURE__ */ jsxRuntime.jsx(TextWithTone, { tone: "critical", children: t2("delete-dialog.error") })
      ] })
    }
  );
}
const CommentDisabledIcon = React.forwardRef(function(props2, ref) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      "data-sanity-icon": "comment-disabled",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props2,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M5.92627 14.5381H7.92627V18.5381L11.9263 14.5381H15.9263C17.0308 14.5381 17.9263 13.6427 17.9263 12.5381V6.53809C17.9263 5.43352 17.0308 4.53809 15.9263 4.53809H5.92627C4.8217 4.53809 3.92627 5.43352 3.92627 6.53809V12.5381C3.92627 13.6427 4.8217 14.5381 5.92627 14.5381Z",
            stroke: "currentColor",
            strokeWidth: "1.2",
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M2.77256 2.66835C2.54413 2.51319 2.23317 2.57259 2.07802 2.80103L1.40378 3.7937C1.32927 3.9034 1.30139 4.0382 1.32627 4.16845C1.35115 4.29871 1.42676 4.41374 1.53646 4.48825L19.5861 16.7479C19.8146 16.903 20.1255 16.8436 20.2807 16.6152L20.9549 15.6225C21.0294 15.5128 21.0573 15.378 21.0324 15.2478C21.0076 15.1175 20.9319 15.0025 20.8222 14.928L2.77256 2.66835Z",
            fill: "currentColor",
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
React.forwardRef(function(props2, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    "svg",
    {
      "data-sanity-icon": "comment",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props2,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M7.5 15.5H9.5V19.5L13.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V7.5C19.5 6.39543 18.6046 5.5 17.5 5.5H7.5C6.39543 5.5 5.5 6.39543 5.5 7.5V13.5C5.5 14.6046 6.39543 15.5 7.5 15.5Z",
          stroke: "currentColor",
          strokeLinejoin: "round",
          strokeWidth: "1.2"
        }
      )
    }
  );
});
const MentionIcon = React.forwardRef(function(props2, ref) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      "data-sanity-icon": "mention",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props2,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M16.6633 18.9383C15.539 19.6562 14.2034 20.0723 12.7705 20.0723C8.77022 20.0723 5.52734 16.8294 5.52734 12.8291C5.52734 8.82881 8.77022 5.58594 12.7705 5.58594C16.7708 5.58594 20.0137 8.82881 20.0137 12.8291C20.0137 13.6623 19.8249 14.7093 19.6141 15.2077C19.5578 15.3408 19.479 15.4845 19.3936 15.6238C19.0955 16.1106 18.5507 16.3721 17.9807 16.4018V16.4018C16.8271 16.462 15.8588 15.5428 15.8588 14.3877V9.27302",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: "12.5732", cy: "12.8291", r: "3.08691", stroke: "currentColor", strokeWidth: 1.2 })
      ]
    }
  );
}), ReactionIcon = React.forwardRef(function(props2, ref) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      "data-sanity-icon": "add-reaction",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props2,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M10.1044 10.4011L10.1044 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M14.2393 10.4011L14.2393 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M7.12128 14.1151C7.70803 15.0226 9.66113 16.8377 11.7735 16.8377C13.8859 16.8377 15.6713 15.0226 16.4257 14.1151",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M16.703 6.43905C15.3486 5.36511 13.6357 4.72374 11.773 4.72374C7.38731 4.72374 3.83203 8.27902 3.83203 12.6647C3.83203 17.0503 7.38731 20.6056 11.773 20.6056C16.0995 20.6056 19.618 17.1455 19.712 12.8415",
            stroke: "currentColor",
            strokeWidth: 1.2
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M19.1135 9.03425L19.1135 11.4903L20.3135 11.4903L20.3135 9.03425L22.7693 9.03425L22.7693 7.83425L20.3135 7.83425L20.3135 5.37941L19.1135 5.37941L19.1135 7.83425L16.6584 7.83425L16.6584 9.03425L19.1135 9.03425Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
}), SendIcon = React.forwardRef(function(props2, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    "svg",
    {
      "data-sanity-icon": "send",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props2,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          clipRule: "evenodd",
          d: "M21.1602 12.5L7.16016 19.5V14.8765L13.6656 12.4989L7.16016 9.97149L7.16016 5.5L21.1602 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
}), StyledAvatar = styledComponents.styled(ui.Avatar)`
  svg > ellipse {
    stroke: transparent;
  }
`, SYMBOLS = /[^\p{Alpha}\p{White_Space}]/gu, WHITESPACE = new RegExp("\\p{White_Space}+", "u");
function nameToInitials(fullName) {
  const namesArray = fullName.replace(SYMBOLS, "").split(WHITESPACE);
  return namesArray.length === 1 ? `${namesArray[0].charAt(0)}`.toUpperCase() : `${namesArray[0].charAt(0)}${namesArray[namesArray.length - 1].charAt(0)}`;
}
function CommentsAvatar(props2) {
  const { user: userProp, ...restProps } = props2, user = userProp, initials = React.useMemo(() => nameToInitials((user == null ? void 0 : user.displayName) || ""), [user == null ? void 0 : user.displayName]);
  return user ? /* @__PURE__ */ jsxRuntime.jsx(
    StyledAvatar,
    {
      initials,
      src: user == null ? void 0 : user.imageUrl,
      title: user == null ? void 0 : user.displayName,
      ...restProps
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(StyledAvatar, { ...restProps });
}
const SpacerAvatar = styledComponents.styled.div((props2) => {
  var _a2;
  const theme$1 = theme.getTheme_v2(props2.theme), { $size = 1 } = props2;
  return styledComponents.css`
    min-width: ${(_a2 = theme$1.avatar.sizes[$size]) == null ? void 0 : _a2.size}px;
  `;
}), mentionObject = types.defineField({
  name: "mention",
  type: "object",
  fields: [
    {
      name: "userId",
      type: "string"
    }
  ]
}), blockType = types.defineField({
  type: "block",
  name: "block",
  of: [mentionObject],
  marks: {
    annotations: []
  },
  styles: [{ title: "Normal", value: "normal" }],
  lists: []
}), portableTextType = types.defineArrayMember({
  type: "array",
  name: "body",
  of: [blockType]
}), schema = schema$1.Schema.compile({
  name: "comments",
  types: [portableTextType]
}), editorSchemaType = schema.get("body"), Span = styledComponents.styled.span(({ theme: theme2 }) => {
  var _a2, _b, _c;
  const { regular } = ((_a2 = theme2.sanity.fonts) == null ? void 0 : _a2.text.weights) || {}, { hovered } = ((_b = theme2.sanity.color) == null ? void 0 : _b.card) || {}, { bg } = ((_c = theme2.sanity.color.selectable) == null ? void 0 : _c.caution.pressed) || {};
  return styledComponents.css`
    font-weight: ${regular};
    color: var(--card-link-fg-color);
    border-radius: 2px;
    background-color: ${hovered.bg};
    padding: 1px;
    box-sizing: border-box;

    &[data-active='true'] {
      background-color: ${bg};
    }
  `;
});
function MentionInlineBlock(props2) {
  const { selected, userId } = props2, [user, loading] = useUser(userId), currentUser = useCurrentUser();
  return !user || loading ? /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextSkeleton,
    {
      "data-testid": "comment-mentions-loading-skeleton",
      style: { width: "10ch" },
      size: 0,
      muted: !0,
      radius: 1,
      animated: !0
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      portal: !0,
      content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: user.displayName })
      ] }),
      children: /* @__PURE__ */ jsxRuntime.jsxs(Span, { "data-selected": selected, "data-active": (currentUser == null ? void 0 : currentUser.id) === userId, children: [
        "@",
        user.displayName
      ] })
    }
  );
}
const NormalText = styledComponents.styled(ui.Text)`
  word-break: break-word;
`;
function NormalBlock(props2) {
  const { children } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(NormalText, { size: 1, children });
}
const renderBlock = (blockProps) => {
  const { children } = blockProps;
  return /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children });
}, renderChild = (childProps) => {
  const { children, value, selected } = childProps;
  return value._type === "mention" && value.userId ? /* @__PURE__ */ jsxRuntime.jsx(MentionInlineBlock, { selected, userId: value == null ? void 0 : value.userId }) : children;
}, Z_OFFSET = 9999999;
function CommentInputDiscardDialog(props2) {
  const { t: t2 } = useTranslation(commentsLocaleNamespace), { onClose, onConfirm } = props2, handleCancelClick = React.useCallback(
    (e) => {
      e.stopPropagation(), onClose();
    },
    [onClose]
  ), handleConfirmClick = React.useCallback(
    (e) => {
      e.stopPropagation(), onConfirm();
    },
    [onConfirm]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeColorProvider, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(ui.DialogProvider, { zOffset: Z_OFFSET, children: /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Dialog,
    {
      header: t2("discard.header"),
      id: "discard-comment-dialog",
      onClose,
      width: 0,
      onClickOutside: onClose,
      footer: {
        cancelButton: {
          onClick: handleCancelClick
        },
        confirmButton: {
          onClick: handleConfirmClick,
          text: t2("discard.button-confirm"),
          tone: "critical"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("discard.text") })
    }
  ) }) });
}
const InnerFlex = styledComponents.styled(ui.Flex)``, SKELETON_INLINE_STYLE$1 = { width: "50%" };
function MentionsMenuItem(props2) {
  const { user, onSelect } = props2, [loadedUser] = useUser(user.id), { t: t2 } = useTranslation(commentsLocaleNamespace), avatar = /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user: loadedUser, status: user.granted ? void 0 : "inactive" }), text = loadedUser ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", title: loadedUser.displayName, children: loadedUser.displayName }) : /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE$1 }), handleSelect = React.useCallback(() => {
    onSelect(user.id);
  }, [onSelect, user.id]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "button", disabled: !user.granted, onClick: handleSelect, padding: 2, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(InnerFlex, { align: "center", gap: 2, flex: 1, children: [
      avatar,
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: text })
    ] }),
    !user.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t2("mentions.unauthorized-user") })
  ] }) });
}
const EMPTY_ARRAY$5 = [], Root$1 = styledComponents.styled(ui.Stack)({
  maxWidth: "220px"
  // todo: improve
}), ITEM_HEIGHT = 41, LIST_PADDING = 4, MAX_ITEMS = 7, FlexWrap = styledComponents.styled(ui.Flex)({
  maxHeight: ITEM_HEIGHT * MAX_ITEMS + LIST_PADDING * 2 + ITEM_HEIGHT / 2
}), MentionsMenu = React.forwardRef(function(props2, ref) {
  const { t: t2 } = useTranslation(commentsLocaleNamespace), { loading, onSelect, options = [], inputElement } = props2, [searchTerm, setSearchTerm] = React.useState(""), commandListRef = React.useRef(null);
  React.useImperativeHandle(
    ref,
    () => ({
      setSearchTerm(term) {
        setSearchTerm(term);
      }
    }),
    []
  );
  const renderItem2 = React.useCallback(
    (itemProps) => /* @__PURE__ */ jsxRuntime.jsx(MentionsMenuItem, { user: itemProps, onSelect }),
    [onSelect]
  ), getItemDisabled = React.useCallback(
    (index) => {
      var _a2;
      return !((_a2 = options == null ? void 0 : options[index]) != null && _a2.granted);
    },
    [options]
  ), filteredOptions = React.useMemo(() => {
    var _a2;
    if (!searchTerm) return options || EMPTY_ARRAY$5;
    const deburredSearchTerm = deburr__default.default(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      displayName: deburr__default.default(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a2 = deburredOptions == null ? void 0 : deburredOptions.filter((option) => {
      var _a22;
      return (_a22 = option == null ? void 0 : option.displayName) == null ? void 0 : _a22.includes(deburredSearchTerm);
    })) == null ? void 0 : _a2.sort((a, b) => {
      var _a22, _b;
      const matchA = (_a22 = a.displayName) == null ? void 0 : _a22.startsWith(deburredSearchTerm), matchB = (_b = b.displayName) == null ? void 0 : _b.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || EMPTY_ARRAY$5;
  }, [options, searchTerm]);
  if (loading)
    return /* @__PURE__ */ jsxRuntime.jsx(Root$1, { children: /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0 }) });
  const _inputElement = inputElement || void 0;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", "data-testid": "comments-mentions-menu", children: [
    filteredOptions.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, children: t2("mentions.no-users-found") }) }),
    filteredOptions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(FlexWrap, { direction: "column", flex: 1, overflow: "hidden", children: /* @__PURE__ */ jsxRuntime.jsx(
      CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: t2("mentions.user-list-aria-label"),
        fixedHeight: !0,
        getItemDisabled,
        inputElement: _inputElement,
        itemHeight: 41,
        items: filteredOptions,
        padding: 1,
        ref: commandListRef,
        renderItem: renderItem2
      }
    ) })
  ] });
});
function useCommentInput() {
  const ctx = React.useContext(_singletons.CommentInputContext);
  if (!ctx)
    throw new Error("useCommentInputContext must be used within a CommentInputProvider");
  return ctx;
}
const EVENT_LISTENER_OPTIONS = { passive: !0 };
function useCursorElement(opts) {
  const { disabled, rootElement } = opts, [cursorRect, setCursorRect] = React.useState(null), cursorElement = React.useMemo(() => cursorRect ? {
    getBoundingClientRect: () => cursorRect
  } : null, [cursorRect]), handleSelectionChange = React.useCallback(() => {
    if (disabled) {
      setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || !sel.isCollapsed || sel.rangeCount === 0) return;
    const range2 = sel.getRangeAt(0);
    if (!(rootElement != null && rootElement.contains(range2.commonAncestorContainer))) {
      setCursorRect(null);
      return;
    }
    const rect = range2 == null ? void 0 : range2.getBoundingClientRect();
    rect && setCursorRect(rect);
  }, [disabled, rootElement]);
  return React.useEffect(() => (document.addEventListener("selectionchange", handleSelectionChange, EVENT_LISTENER_OPTIONS), () => {
    document.removeEventListener("selectionchange", handleSelectionChange);
  }), [handleSelectionChange]), cursorElement;
}
const POPOVER_FALLBACK_PLACEMENTS$1 = ["bottom", "top"], INLINE_STYLE = { outline: "none" }, EMPTY_ARRAY$4 = [], PlaceholderWrapper = styledComponents.styled.span((props2) => {
  const { color: color2 } = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    color: ${color2.input.default.enabled.placeholder};
    overflow: hidden;
    text-overflow: ellipsis;
    text-wrap: nowrap;
    display: block;
  `;
}), StyledPopover$1 = styledComponents.styled(TooltipDelayGroupProvider.Popover)(({ theme: theme2 }) => {
  const { space, radius } = theme2.sanity;
  return styledComponents.css`
    &[data-placement='bottom'] {
      transform: translateY(${space[1]}px);
    }

    &[data-placement='top'] {
      transform: translateY(-${space[1]}px);
    }

    [data-ui='Popover__wrapper'] {
      border-radius: ${radius[3]}px;
      display: flex;
      flex-direction: column;
      overflow: clip;
      overflow: hidden;
      position: relative;
      width: 300px; // todo: improve
    }
  `;
});
function Editable(props2) {
  const { t: t2 } = useTranslation(commentsLocaleNamespace), {
    focusLock,
    onFocus,
    onBlur,
    onKeyDown,
    onSubmit,
    placeholder = t2("compose.create-comment-placeholder"),
    renderBlock: renderBlock2
  } = props2, [popoverElement, setPopoverElement] = React.useState(null), rootElementRef = React.useRef(null), editableRef = React.useRef(null), mentionsMenuRef = React.useRef(null), selection = portableTextEditor.usePortableTextEditorSelection(), {
    canSubmit,
    closeMentions,
    insertMention,
    mentionOptions,
    mentionsMenuOpen,
    mentionsSearchTerm,
    onBeforeInput,
    value
  } = useCommentInput(), cursorElement = useCursorElement({
    disabled: !mentionsMenuOpen,
    rootElement: rootElementRef.current
  }), renderPlaceholder = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(PlaceholderWrapper, { children: placeholder }),
    [placeholder]
  ), handleClickOutside = React.useCallback(() => {
    mentionsMenuOpen && closeMentions();
  }, [closeMentions, mentionsMenuOpen]);
  ui.useClickOutside(handleClickOutside, [popoverElement]);
  const handleKeyDown = React.useCallback(
    (event) => {
      switch (event.key) {
        case "Enter":
          if (event.shiftKey)
            break;
          if (mentionsMenuOpen) {
            event.preventDefault(), event.stopPropagation(), closeMentions();
            break;
          }
          onSubmit && canSubmit && (event.preventDefault(), event.stopPropagation(), onSubmit());
          break;
        case "Escape":
        case "ArrowLeft":
        case "ArrowRight":
          mentionsMenuOpen && (event.preventDefault(), event.stopPropagation(), closeMentions());
          break;
      }
      onKeyDown && onKeyDown(event);
    },
    [canSubmit, closeMentions, mentionsMenuOpen, onKeyDown, onSubmit]
  ), initialSelectionAtEndOfContent = React.useMemo(() => {
    if (selection)
      return;
    const lastBlock = (value || EMPTY_ARRAY$4).slice(-1)[0], lastChild = types.isPortableTextTextBlock(lastBlock) ? lastBlock.children.slice(-1)[0] : void 0;
    if (!lastChild)
      return;
    const point = {
      path: [{ _key: lastBlock._key }, "children", { _key: lastChild._key }],
      offset: types.isPortableTextSpan(lastChild) ? lastChild.text.length : 0
    };
    return {
      focus: point,
      anchor: point
    };
  }, [value, selection]);
  React.useEffect(() => {
    var _a2;
    (_a2 = mentionsMenuRef.current) == null || _a2.setSearchTerm(mentionsSearchTerm);
  }, [mentionsSearchTerm]), React.useEffect(() => {
    mentionsMenuOpen && selection && !isEqual__default.default(selection.anchor, selection.focus) && closeMentions();
  }, [mentionsMenuOpen, closeMentions, selection]);
  const popoverContent = /* @__PURE__ */ jsxRuntime.jsx(
    MentionsMenu,
    {
      inputElement: editableRef.current,
      loading: mentionOptions.loading,
      onSelect: insertMention,
      options: mentionOptions.data || EMPTY_ARRAY$4,
      ref: mentionsMenuRef
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs("div", { ref: rootElementRef, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      StyledPopover$1,
      {
        arrow: !1,
        constrainSize: !0,
        content: popoverContent,
        disabled: !mentionsMenuOpen,
        fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1,
        open: mentionsMenuOpen,
        placement: "bottom",
        ref: setPopoverElement,
        referenceElement: cursorElement
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      portableTextEditor.PortableTextEditable,
      {
        "data-testid": "comment-input-editable",
        "data-ui": "EditableElement",
        onBeforeInput,
        onBlur,
        onFocus,
        onKeyDown: handleKeyDown,
        ref: editableRef,
        renderBlock: renderBlock2,
        renderChild,
        renderPlaceholder,
        selection: initialSelectionAtEndOfContent,
        style: INLINE_STYLE,
        tabIndex: focusLock ? 0 : void 0
      }
    )
  ] });
}
const EditableWrap = styledComponents.styled(ui.Box)`
  max-height: 20vh;
  overflow-y: auto;
`, ButtonDivider = styledComponents.styled(ui.MenuDivider)({
  height: 20,
  width: 1
});
function focusRingBorderStyle(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
const RootCard = styledComponents.styled(ui.Card)(({ theme: theme$1 }) => {
  const { color: color2, input, radius } = theme.getTheme_v2(theme$1), radii = radius[2];
  return styledComponents.css`
    border-radius: ${radii}px;
    box-shadow: var(--input-box-shadow);

    --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};

    &:not([data-expand-on-focus='false'], :focus-within) {
      background: transparent;
      box-shadow: unset;
    }

    &[data-focused='true']:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }

      /* box-shadow: inset 0 0 0 1px var(--card-focus-ring-color); */
      --input-box-shadow: ${focusRingBorderStyle({
    color: "var(--card-focus-ring-color)",
    width: input.border.width
  })};
    }

    &:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='false'] {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='true'] {
      [data-ui='CommentInputActions']:not([hidden]) {
        display: none;
      }

      &:focus-within {
        [data-ui='CommentInputActions'] {
          display: flex;
        }
      }
    }
    &:hover {
      --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.hovered.border,
    width: input.border.width
  })};
    }
  `;
}), AvatarContainer = styledComponents.styled.div((props2) => {
  var _a2;
  return `
    min-height: ${(_a2 = theme.getTheme_v2(props2.theme).avatar.sizes[1]) == null ? void 0 : _a2.size}px;
    display: flex;
    align-items: center;
  `;
});
function CommentInputInner(props2) {
  const {
    avatarSize = 1,
    currentUser,
    focusLock,
    onBlur,
    onFocus,
    onKeyDown,
    onSubmit,
    placeholder,
    renderBlock: renderBlock2,
    withAvatar
  } = props2, [user] = useUser(currentUser.id), { canSubmit, expandOnFocus, focused, hasChanges, insertAtChar, openMentions, readOnly } = useCommentInput(), { t: t2 } = useTranslation(commentsLocaleNamespace), avatar = withAvatar ? /* @__PURE__ */ jsxRuntime.jsx(AvatarContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user, size: avatarSize }) }) : null, handleMentionButtonClicked = React.useCallback(
    (e) => {
      e.stopPropagation(), insertAtChar(), openMentions();
    },
    [insertAtChar, openMentions]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 2, children: [
    avatar,
    /* @__PURE__ */ jsxRuntime.jsx(
      RootCard,
      {
        id: "comment-input-root",
        "data-expand-on-focus": expandOnFocus && !canSubmit ? "true" : "false",
        "data-focused": focused ? "true" : "false",
        flex: 1,
        sizing: "border",
        tone: readOnly ? "transparent" : "default",
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            EditableWrap,
            {
              "data-ui": "CommentInputEditableWrap",
              paddingX: 1,
              paddingY: 2,
              sizing: "border",
              children: /* @__PURE__ */ jsxRuntime.jsx(
                Editable,
                {
                  focusLock,
                  onBlur,
                  onFocus,
                  onKeyDown,
                  onSubmit,
                  placeholder,
                  renderBlock: renderBlock2
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", "data-ui": "CommentInputActions", gap: 1, justify: "flex-end", padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              TooltipDelayGroupProvider.Button,
              {
                "aria-label": t2("compose.mention-user-aria-label"),
                "data-testid": "comment-input-mention-button",
                disabled: readOnly,
                icon: MentionIcon,
                mode: "bleed",
                type: "button",
                onClick: handleMentionButtonClicked,
                tooltipProps: { content: t2("compose.mention-user-tooltip") }
              }
            ),
            onSubmit && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
              /* @__PURE__ */ jsxRuntime.jsx(ButtonDivider, {}),
              /* @__PURE__ */ jsxRuntime.jsx(
                TooltipDelayGroupProvider.Button,
                {
                  "aria-label": t2("compose.send-comment-aria-label"),
                  "data-testid": "comment-input-send-button",
                  disabled: !canSubmit || !hasChanges || readOnly,
                  icon: SendIcon,
                  mode: hasChanges && canSubmit ? "default" : "bleed",
                  onClick: onSubmit,
                  tone: hasChanges && canSubmit ? "primary" : "default",
                  tooltipProps: { content: t2("compose.send-comment-tooltip") }
                }
              )
            ] })
          ] }) })
        ] })
      }
    )
  ] });
}
function CommentInputProvider(props2) {
  const {
    children,
    expandOnFocus = !1,
    focused,
    focusOnMount = !1,
    mentionOptions,
    onMentionMenuOpenChange,
    value,
    readOnly
  } = props2, editor2 = portableTextEditor.usePortableTextEditor(), [mentionsMenuOpen, setMentionsMenuOpen] = React.useState(!1), [mentionsSearchTerm, setMentionsSearchTerm] = React.useState(""), [selectionAtMentionInsert, setSelectionAtMentionInsert] = React.useState(null), canSubmit = React.useMemo(() => hasCommentMessageValue(value), [value]), hasChanges = useCommentHasChanged(value), focusEditor = React.useCallback(() => {
    readOnly || portableTextEditor.PortableTextEditor.focus(editor2);
  }, [editor2, readOnly]), closeMentions = React.useCallback(() => {
    setMentionsMenuOpen(!1), setMentionsSearchTerm(""), setSelectionAtMentionInsert(null);
  }, []), openMentions = React.useCallback(() => {
    setMentionsMenuOpen(!0), setMentionsSearchTerm(""), setMentionsMenuOpen(!0), setSelectionAtMentionInsert(portableTextEditor.PortableTextEditor.getSelection(editor2));
  }, [editor2]), onBeforeInput = React.useCallback(
    (event) => {
      const selection = portableTextEditor.PortableTextEditor.getSelection(editor2), cursorOffset = selection ? selection.focus.offset : 0, focusChild = portableTextEditor.PortableTextEditor.focusChild(editor2), focusSpan = types.isPortableTextSpan(focusChild) && focusChild || void 0, isInsertText = event.inputType === "insertText", isDeleteText = event.inputType === "deleteContentBackward", isInsertingAtChar = isInsertText && event.data === "@", lastIndexOfAt = (focusSpan == null ? void 0 : focusSpan.text.slice(0, Math.max(0, cursorOffset)).lastIndexOf("@")) || 0, isWhitespaceCharBeforeCursorPosition = (focusSpan == null ? void 0 : focusSpan.text.slice(cursorOffset - 1, cursorOffset)) === " ", filterStartsWithSpaceChar = isInsertText && event.data === " " && !mentionsSearchTerm;
      if (isInsertingAtChar && (cursorOffset < 1 || isWhitespaceCharBeforeCursorPosition)) {
        openMentions();
        return;
      }
      if (filterStartsWithSpaceChar || isDeleteText && ((focusSpan == null ? void 0 : focusSpan.text.length) === 1 || lastIndexOfAt === ((focusSpan == null ? void 0 : focusSpan.text.length) || 0) - 1)) {
        closeMentions();
        return;
      }
      if (types.isPortableTextSpan(focusChild)) {
        let term = focusChild.text.slice(lastIndexOfAt + 1, cursorOffset);
        isInsertText && (term += event.data), isDeleteText && (term = term.slice(0, Math.max(0, term.length - 1))), setMentionsSearchTerm(term);
      }
    },
    [closeMentions, editor2, mentionsSearchTerm, openMentions]
  ), insertAtChar = React.useCallback(() => {
    setMentionsMenuOpen(!0), portableTextEditor.PortableTextEditor.focus(editor2), portableTextEditor.PortableTextEditor.insertChild(editor2, editor2.schemaTypes.span, { text: "@" }), setSelectionAtMentionInsert(portableTextEditor.PortableTextEditor.getSelection(editor2));
  }, [editor2]);
  useDidUpdate(mentionsMenuOpen, () => onMentionMenuOpenChange == null ? void 0 : onMentionMenuOpenChange(mentionsMenuOpen));
  const insertMention = React.useCallback(
    (userId) => {
      var _a2;
      const mentionSchemaType = editor2.schemaTypes.inlineObjects.find((t2) => t2.name === "mention"), [span, spanPath] = selectionAtMentionInsert && portableTextEditor.PortableTextEditor.findByPath(editor2, selectionAtMentionInsert.focus.path) || [];
      if (span && types.isPortableTextSpan(span) && spanPath && mentionSchemaType) {
        portableTextEditor.PortableTextEditor.focus(editor2);
        const offset = (_a2 = portableTextEditor.PortableTextEditor.getSelection(editor2)) == null ? void 0 : _a2.focus.offset;
        typeof offset < "u" && (portableTextEditor.PortableTextEditor.delete(
          editor2,
          {
            anchor: { path: spanPath, offset: span.text.lastIndexOf("@") },
            focus: { path: spanPath, offset }
          },
          { mode: "selected" }
        ), portableTextEditor.PortableTextEditor.insertChild(editor2, mentionSchemaType, {
          userId
        }), portableTextEditor.PortableTextEditor.insertChild(editor2, editor2.schemaTypes.span, { text: " " }));
      }
    },
    [editor2, selectionAtMentionInsert]
  ), ctxValue = React.useMemo(
    () => ({
      canSubmit,
      closeMentions,
      editor: editor2,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly: !!readOnly,
      value
    }),
    [
      canSubmit,
      closeMentions,
      editor2,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly,
      value
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(_singletons.CommentInputContext.Provider, { value: ctxValue, children });
}
const EMPTY_ARRAY$3 = [], SCROLL_INTO_VIEW_OPTIONS = {
  behavior: "smooth",
  block: "center",
  inline: "center"
}, CommentInput = React.forwardRef(
  function(props2, ref) {
    const {
      avatarSize,
      currentUser,
      expandOnFocus,
      focusLock = !1,
      focusOnMount,
      mentionOptions,
      onBlur,
      onChange,
      onDiscardCancel,
      onDiscardConfirm,
      onFocus,
      onKeyDown,
      onMentionMenuOpenChange,
      onSubmit,
      placeholder,
      readOnly,
      renderBlock: renderBlock$12 = renderBlock,
      value = EMPTY_ARRAY$3,
      withAvatar = !0
    } = props2, [focused, setFocused] = React.useState(!1), editorRef = React.useRef(null), editorContainerRef = React.useRef(null), [showDiscardDialog, setShowDiscardDialog] = React.useState(!1), preDivRef = React.useRef(null), postDivRef = React.useRef(null), innerRef = React.useRef(null), [editorInstanceKey, setEditorInstanceKey] = React.useState(portableTextEditor.keyGenerator()), requestFocus = React.useCallback(() => {
      requestAnimationFrame(() => {
        editorRef.current && portableTextEditor.PortableTextEditor.focus(editorRef.current);
      });
    }, []), resetEditorInstance = React.useCallback(() => {
      setEditorInstanceKey(portableTextEditor.keyGenerator());
    }, []), handleChange = React.useCallback(
      (change) => {
        if (change.type === "ready" && focusOnMount && requestFocus(), change.type === "focus" && setFocused(!0), change.type === "blur" && setFocused(!1), change.type === "patch" && editorRef.current) {
          const editorStateValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current);
          onChange(editorStateValue || EMPTY_ARRAY$3);
        }
      },
      [focusOnMount, onChange, requestFocus]
    ), scrollToEditor = React.useCallback(() => {
      var _a2;
      (_a2 = editorContainerRef.current) == null || _a2.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS);
    }, []), handleSubmit = React.useCallback(() => {
      onSubmit == null || onSubmit(), resetEditorInstance(), requestFocus(), scrollToEditor();
    }, [onSubmit, requestFocus, resetEditorInstance, scrollToEditor]), handleDiscardConfirm = React.useCallback(() => {
      onDiscardConfirm(), resetEditorInstance();
    }, [onDiscardConfirm, resetEditorInstance]), discardDialogController = React.useMemo(() => ({
      open: () => {
        setShowDiscardDialog(!0);
      },
      close: () => {
        setShowDiscardDialog(!1), requestFocus();
      }
    }), [requestFocus]);
    React.useImperativeHandle(
      ref,
      () => ({
        focus: requestFocus,
        blur() {
          editorRef.current && portableTextEditor.PortableTextEditor.blur(editorRef.current);
        },
        scrollTo: scrollToEditor,
        reset: resetEditorInstance,
        discardDialogController
      }),
      [discardDialogController, requestFocus, resetEditorInstance, scrollToEditor]
    );
    const handleFocus = React.useCallback(
      (event) => {
        if (!focusLock) return;
        const target = event.target, innerEl = innerRef.current;
        if (innerEl && target === preDivRef.current) {
          ui.focusLastDescendant(innerEl);
          return;
        }
        innerEl && target === postDivRef.current && ui.focusFirstDescendant(innerEl);
      },
      [focusLock]
    );
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      showDiscardDialog && onDiscardCancel && /* @__PURE__ */ jsxRuntime.jsx(CommentInputDiscardDialog, { onClose: onDiscardCancel, onConfirm: handleDiscardConfirm }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { ref: editorContainerRef, "data-testid": "comment-input", onFocus: handleFocus, children: /* @__PURE__ */ jsxRuntime.jsx(
        portableTextEditor.PortableTextEditor,
        {
          onChange: handleChange,
          readOnly,
          ref: editorRef,
          schemaType: editorSchemaType,
          value: value || EMPTY_ARRAY$3,
          children: /* @__PURE__ */ jsxRuntime.jsxs(
            CommentInputProvider,
            {
              expandOnFocus,
              focused,
              focusOnMount,
              mentionOptions,
              onMentionMenuOpenChange,
              readOnly,
              value,
              children: [
                focusLock && /* @__PURE__ */ jsxRuntime.jsx("div", { ref: preDivRef, tabIndex: 0 }),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { ref: innerRef, children: /* @__PURE__ */ jsxRuntime.jsx(
                  CommentInputInner,
                  {
                    avatarSize,
                    currentUser,
                    focusLock,
                    onBlur,
                    onFocus,
                    onKeyDown,
                    onSubmit: onSubmit && handleSubmit,
                    placeholder,
                    renderBlock: renderBlock$12,
                    withAvatar
                  }
                ) }),
                focusLock && /* @__PURE__ */ jsxRuntime.jsx("div", { ref: postDivRef, tabIndex: 0 })
              ]
            }
          )
        },
        editorInstanceKey
      ) })
    ] });
  }
), HighlightSpan = styledComponents.styled.span(({ theme: theme2 }) => {
  var _a2;
  const isDark = (_a2 = theme2.sanity.v2) == null ? void 0 : _a2.color._dark, addedBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 800 : 100].hex, addedBorder = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 300].hex, addedHoverBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedHoverBorder = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex, addedNestedBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedNesterBorder = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex;
  return styledComponents.css`
    box-sizing: border-box;
    transition:
      background-color 100ms ease,
      border-color 100ms ease;

    // Make sure that child elements appropriately blend with the
    // background of the highlight span
    * {
      mix-blend-mode: ${isDark ? "screen" : "multiply"};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='true'] {
      background-color: ${addedNestedBg};
      border-bottom: 2px solid ${addedNesterBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'][data-hovered='true'] {
      background-color: ${addedHoverBg};
      border-bottom: 2px solid ${addedHoverBorder};
    }

    &[data-inline-comment-state='authoring'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }
  `;
}), CommentInlineHighlightSpan = React.forwardRef(function(props2, ref) {
  const { children, isAdded, isAuthoring, isHovered, isNested, ...rest } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    HighlightSpan,
    {
      ...rest,
      "data-hovered": isHovered ? "true" : "false",
      "data-inline-comment-nested": isNested ? "true" : "false",
      "data-inline-comment-state": isAdded ? "added" : isAuthoring ? "authoring" : void 0,
      ref,
      children
    }
  );
}), PortableTextWrap = styledComponents.styled(ui.Stack)(() => styledComponents.css`
    & > [data-ui='Text']:not(:first-child) {
      margin-top: 1em; // todo: improve
    }

    & > [data-ui='Text']:has(> span:empty) {
      display: none;
    }
  `), EMPTY_ARRAY$2 = [], components = {
  block: {
    normal: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    h1: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h2: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h3: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h4: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h5: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h6: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    blockquote: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    code: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children })
  },
  list: {
    bullet: ({ children }) => children,
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children })
  },
  listItem: {
    bullet: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children })
  },
  marks: {
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    strong: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    em: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    code: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    underline: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    strikeThrough: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    link: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children })
  },
  types: {
    mention: (props2) => {
      var _a2;
      return /* @__PURE__ */ jsxRuntime.jsx(MentionInlineBlock, { userId: (_a2 = props2 == null ? void 0 : props2.value) == null ? void 0 : _a2.userId, selected: !1 });
    }
  }
};
function CommentMessageSerializer(props2) {
  const { blocks } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(PortableTextWrap, { children: /* @__PURE__ */ jsxRuntime.jsx(react$1.PortableText, { value: blocks || EMPTY_ARRAY$2, components }) });
}
const FLEX_GAP = 3, EmojiText = styledComponents.styled(ui.Text)`
  font-family: 'Twemoji Mozilla', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
    'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji', sans-serif;
`, GRID_COLUMNS = 6;
function CommentReactionsMenu(props2) {
  const { options, onSelect } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), [focusableElements, setFocusableElements] = React.useState([]), [rootElement, setRootElement] = React.useState(null), [focusedIndex, setFocusedIndex] = React.useState(0), handleRootKeyDown = React.useCallback(
    (event) => {
      const focusableLen = focusableElements.length;
      event.key === "ArrowRight" && setFocusedIndex((prev) => (prev + 1) % focusableLen), event.key === "ArrowLeft" && setFocusedIndex((prev) => (prev - 1 + focusableLen) % focusableLen);
    },
    [focusableElements.length]
  ), handleOptionClick = React.useCallback(
    (event) => {
      const index = focusableElements.indexOf(event.currentTarget);
      setFocusedIndex(index), onSelect(options[index]);
    },
    [focusableElements, onSelect, options]
  );
  return React.useEffect(() => {
    if (rootElement) {
      const buttons = rootElement.querySelectorAll("button");
      setFocusableElements(Array.from(buttons));
    }
  }, [rootElement]), React.useEffect(() => {
    focusableElements.length > 0 && focusableElements[focusedIndex].focus();
  }, [focusableElements, focusedIndex]), /* @__PURE__ */ jsxRuntime.jsx(
    ui.Grid,
    {
      columns: GRID_COLUMNS,
      gap: 1,
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      role: "menu",
      children: options.map((o) => {
        const emoji = COMMENT_REACTION_EMOJIS[o.shortName];
        return /* @__PURE__ */ jsxRuntime.jsx(
          ui.Button,
          {
            "aria-label": t2("reactions.react-with-aria-label", {
              reactionName: o.title || o.shortName
            }),
            mode: "bleed",
            onClick: handleOptionClick,
            padding: 2,
            role: "menuitem",
            tabIndex: -1,
            children: /* @__PURE__ */ jsxRuntime.jsx(EmojiText, { align: "center", size: 2, children: emoji })
          },
          o.shortName
        );
      })
    }
  );
}
const POPOVER_FALLBACK_PLACEMENTS = ["top", "bottom"];
function CommentReactionsMenuButton(props2) {
  const { onMenuClose, onMenuOpen, onSelect, options, readOnly, renderMenuButton: renderMenuButton2, mode } = props2, [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), [open, setOpen] = React.useState(!1), { t: t2 } = useTranslation(commentsLocaleNamespace), handleClick = React.useCallback(() => {
    const next = !open;
    setOpen(next), next ? onMenuOpen == null || onMenuOpen() : onMenuClose == null || onMenuClose();
  }, [onMenuClose, onMenuOpen, open]), handleClose = React.useCallback(() => {
    open && (setOpen(!1), onMenuClose == null || onMenuClose(), buttonElement == null || buttonElement.focus());
  }, [buttonElement, onMenuClose, open]), handleClickOutside = React.useCallback(handleClose, [handleClose]), handleKeyDown = React.useCallback(
    (event) => {
      const { key, shiftKey } = event;
      (shiftKey && key === "Tab" || key === "Escape" || key === "Tab") && handleClose();
    },
    [handleClose]
  );
  ui.useClickOutside(handleClickOutside, [popoverElement, buttonElement]);
  const handleSelect = React.useCallback(
    (option) => {
      onSelect(option), handleClose();
    },
    [handleClose, onSelect]
  ), button = React.useMemo(() => {
    const btn = renderMenuButton2({
      open,
      tooltipContent: t2(mode === "upsell" ? "list-item.context-menu-add-reaction-upsell" : "list-item.context-menu-add-reaction"),
      t: t2
    });
    return React.cloneElement(btn, {
      "aria-expanded": open,
      "aria-haspopup": "true",
      disabled: readOnly || mode === "upsell",
      id: "reactions-menu-button",
      onClick: handleClick,
      ref: setButtonElement
    });
  }, [handleClick, open, readOnly, renderMenuButton2, t2, mode]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Popover,
    {
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          "aria-labelledby": "reactions-menu-button",
          onKeyDown: handleKeyDown,
          padding: 1,
          radius: 3,
          tone: "default",
          children: /* @__PURE__ */ jsxRuntime.jsx(CommentReactionsMenu, { onSelect: handleSelect, options })
        }
      ),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open,
      placement: "bottom",
      portal: !0,
      ref: setPopoverElement,
      tone: "default",
      children: button
    }
  );
}
const TEXT_SIZE = 1, ContentStack = styledComponents.styled(ui.Stack)`
  max-width: 180px;
`, TextGroup = styledComponents.styled.div`
  display: inline-block;
`, InlineText = styledComponents.styled(ui.Text).attrs({ size: TEXT_SIZE })`
  display: inline-block !important;

  & > span {
    white-space: break-spaces;
  }
`, TextBox = styledComponents.styled(ui.Box)`
  line-height: 1;
  text-align: center;
`, LEADING_NON_WHITESPACE_RE = /^\S+/;
function UserDisplayName(props2) {
  const { currentUserId, isFirst, userId } = props2, [user] = useUser(userId), { t: t2 } = useTranslation(commentsLocaleNamespace);
  return currentUserId === userId ? t2("reactions.user-list.you", { context: isFirst ? "leading" : void 0, replace: { name: user == null ? void 0 : user.displayName } }) : (user == null ? void 0 : user.displayName) || t2("reactions.user-list.unknown-user-fallback-name");
}
function CommentReactionsUsersTooltip(props2) {
  const { children, ...restProps } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(
    TooltipDelayGroupProvider.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(CommentReactionsUsersTooltipContent, { ...restProps }),
      placement: "bottom",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children })
    }
  );
}
function FormattedUserList({ currentUserId, userIds }) {
  const listFormat = useListFormat({ style: "long", type: "conjunction" });
  if (userIds.length === 0) return null;
  const parts = listFormat.formatToParts(userIds), elements = [];
  for (let i = 0; i < parts.length; i++) {
    const item = parts[i];
    if (item.type === "literal") {
      elements.push(/* @__PURE__ */ jsxRuntime.jsx(InlineText, { children: item.value }, `literal-${i}`));
      continue;
    }
    const nextItem = parts[i + 1];
    if (nextItem && nextItem.type === "literal" && LEADING_NON_WHITESPACE_RE.test(nextItem.value)) {
      const [nonWhitespace = ""] = nextItem.value.match(LEADING_NON_WHITESPACE_RE) || [];
      elements.push(
        // Key (value) is user ID, thus unique
        /* @__PURE__ */ jsxRuntime.jsxs(TextGroup, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(InlineText, { weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }),
          /* @__PURE__ */ jsxRuntime.jsx(InlineText, { children: nonWhitespace })
        ] }, item.value)
      ), nextItem.value = nextItem.value.slice(nonWhitespace.length);
      continue;
    }
    elements.push(
      // Key (value) is user ID, thus unique
      /* @__PURE__ */ jsxRuntime.jsx(InlineText, { weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }, item.value)
    );
  }
  return elements;
}
function CommentReactionsUsersTooltipContent(props2) {
  const { currentUser, reactionName, userIds } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), UserList = React.useCallback(() => currentUser ? /* @__PURE__ */ jsxRuntime.jsx(FormattedUserList, { currentUserId: currentUser.id, userIds }) : null, [currentUser, userIds]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ContentStack, { padding: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", paddingBottom: 2, paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(EmojiText, { size: 4, children: COMMENT_REACTION_EMOJIS[reactionName] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(TextBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
      Translate,
      {
        t: t2,
        i18nKey: "reactions.users-reacted-with-reaction",
        values: { reactionName },
        components: {
          UserList,
          ReactionName: () => /* @__PURE__ */ jsxRuntime.jsx(InlineText, { muted: !0, children: reactionName }),
          Text: ({ children }) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(InlineText, { muted: !0, children }),
            " ",
            /* @__PURE__ */ jsxRuntime.jsx("wbr", {}),
            " "
          ] })
        }
      }
    ) })
  ] });
}
const TransparentCard = styledComponents.styled(ui.Card)`
  background: none;
`;
function groupReactionsByName(reactions) {
  const grouped = reactions.reduce(
    (acc, reaction) => {
      const { shortName } = reaction;
      return acc[shortName] || (acc[shortName] = []), acc[shortName].push(reaction), acc;
    },
    {}
  );
  return Object.entries(grouped).sort(([nameA], [nameB]) => {
    const indexA = reactions.findIndex((r) => r.shortName === nameA), indexB = reactions.findIndex((r) => r.shortName === nameB);
    return indexA - indexB;
  });
}
const renderMenuButton$1 = ({ open, tooltipContent }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, mode: "ghost", padding: 0, radius: "full", selected: open, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { paddingX: 3, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { animate: !0, content: tooltipContent, disabled: open, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ReactionIcon, {}) }) }) }) }), CommentReactionsBar = React.memo(function(props2) {
  const { currentUser, onSelect, reactions, readOnly, mode } = props2, handleSelect = React.useCallback(
    (name) => {
      const option = COMMENT_REACTION_OPTIONS.find((o) => o.shortName === name);
      option && onSelect(option);
    },
    [onSelect]
  ), currentUserReactionNames = React.useMemo(() => reactions.filter((r) => r.userId === (currentUser == null ? void 0 : currentUser.id)).map((r) => r.shortName), [currentUser == null ? void 0 : currentUser.id, reactions]), groupedReactions = React.useMemo(() => groupReactionsByName(reactions).filter(([name]) => COMMENT_REACTION_EMOJIS[name]), [reactions]), sortOrder = React.useRef(Object.keys(Object.fromEntries(groupedReactions))), sortedReactions = React.useMemo(() => {
    const sorted = groupedReactions.sort(([nameA], [nameB]) => {
      const indexA = sortOrder.current.indexOf(nameA), indexB = sortOrder.current.indexOf(nameB);
      return indexA === -1 ? 1 : indexB === -1 ? -1 : indexA - indexB;
    });
    return sortOrder.current = sorted.map(([name]) => name), sorted;
  }, [groupedReactions]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 1, wrap: "wrap", children: /* @__PURE__ */ jsxRuntime.jsxs(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: [
    sortedReactions.map(([name, reactionsList]) => {
      const hasReacted = currentUserReactionNames.includes(name), userIds = reactionsList.map((r) => r.userId), emoji = COMMENT_REACTION_EMOJIS[name];
      return /* @__PURE__ */ jsxRuntime.jsx(
        CommentReactionsUsersTooltip,
        {
          currentUser,
          reactionName: name,
          userIds,
          children: /* @__PURE__ */ jsxRuntime.jsx(TransparentCard, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              disabled: readOnly || mode === "upsell",
              mode: "ghost",
              onClick: () => handleSelect(name),
              padding: 2,
              radius: "full",
              selected: hasReacted,
              tone: hasReacted ? "primary" : "default",
              children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
                /* @__PURE__ */ jsxRuntime.jsx(EmojiText, { size: 1, children: emoji }),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, weight: hasReacted ? "semibold" : "medium", children: reactionsList == null ? void 0 : reactionsList.length })
              ] })
            }
          ) })
        },
        name
      );
    }),
    /* @__PURE__ */ jsxRuntime.jsx(TransparentCard, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(
      CommentReactionsMenuButton,
      {
        mode,
        onSelect: (o) => handleSelect(o.shortName),
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton: renderMenuButton$1
      }
    ) })
  ] }) });
}), renderMenuButton = ({
  open,
  tooltipContent,
  t: t2
}) => /* @__PURE__ */ jsxRuntime.jsx(
  TooltipDelayGroupProvider.Button,
  {
    "aria-label": t2("list-item.context-menu-add-reaction-aria-label"),
    icon: ReactionIcon,
    mode: "bleed",
    selected: open,
    tooltipProps: { content: tooltipContent }
  }
), POPOVER_PROPS = {
  placement: "bottom-end"
}, FloatingCard = styledComponents.styled(ui.Card)`
  &:empty {
    display: none;
  }
`;
function CommentsListItemContextMenu(props2) {
  const {
    canDelete,
    canEdit,
    isParent,
    mode,
    onCopyLink,
    onDeleteStart,
    onEditStart,
    onMenuClose,
    onMenuOpen,
    onReactionSelect,
    onStatusChange,
    readOnly,
    status
  } = props2, showMenuButton = !!(onCopyLink || onDeleteStart || onEditStart), { t: t2 } = useTranslation(commentsLocaleNamespace), hasContextMenuOptions = !!(canDelete || canEdit || onCopyLink);
  return /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsxs(FloatingCard, { display: "flex", shadow: 2, padding: 1, radius: 2, sizing: "border", children: [
    onReactionSelect && /* @__PURE__ */ jsxRuntime.jsx(
      CommentReactionsMenuButton,
      {
        mode,
        onMenuClose,
        onMenuOpen,
        onSelect: onReactionSelect,
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton
      }
    ),
    isParent && onStatusChange && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.Button,
      {
        "aria-label": t2(status === "open" ? "list-item.resolved-tooltip-aria-label" : "list-item.re-open-resolved-aria-label"),
        "data-testid": "comments-list-item-status-button",
        disabled: readOnly,
        icon: status === "open" ? icons.CheckmarkCircleIcon : icons.UndoIcon,
        mode: "bleed",
        onClick: onStatusChange,
        tooltipProps: {
          content: t2(status === "open" ? "list-item.resolved-tooltip-content" : "list-item.re-open-resolved")
        }
      }
    ),
    hasContextMenuOptions && /* @__PURE__ */ jsxRuntime.jsx(
      TooltipDelayGroupProvider.MenuButton,
      {
        id: "comment-actions-menu",
        button: /* @__PURE__ */ jsxRuntime.jsx(
          ContextMenuButton,
          {
            "aria-label": t2("list-item.open-menu-aria-label"),
            disabled: readOnly,
            hidden: !showMenuButton
          }
        ),
        onOpen: onMenuOpen,
        onClose: onMenuClose,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              hidden: !canEdit,
              icon: icons.EditIcon,
              onClick: onEditStart,
              text: t2("list-item.edit-comment"),
              tooltipProps: mode === "upsell" ? { content: t2("list-item.edit-comment-upsell") } : void 0,
              disabled: mode === "upsell"
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              hidden: !canDelete,
              icon: icons.TrashIcon,
              onClick: onDeleteStart,
              text: t2("list-item.delete-comment"),
              tone: "critical"
            }
          ),
          onCopyLink && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, { hidden: !canDelete && !canEdit }),
          /* @__PURE__ */ jsxRuntime.jsx(
            TooltipDelayGroupProvider.MenuItem,
            {
              hidden: !onCopyLink,
              icon: icons.LinkIcon,
              onClick: onCopyLink,
              text: t2("list-item.copy-link")
            }
          )
        ] }),
        popover: POPOVER_PROPS
      }
    )
  ] }) }) });
}
function truncate(str, length = 250) {
  return str.length <= length ? str : `${str.slice(0, length)}...`;
}
const InlineBox = styledComponents.styled(ui.Box).attrs({ marginLeft: 1, marginRight: 2 })`
  &:not([data-hidden]) {
    display: inline;
  }
`, BlockQuoteStack = styledComponents.styled(ui.Stack)(({ theme: theme2, $hasReferencedValue }) => {
  var _a2;
  const isDark = (_a2 = theme2.sanity.v2) == null ? void 0 : _a2.color._dark, hue = $hasReferencedValue ? COMMENTS_HIGHLIGHT_HUE_KEY : "gray", borderColor = isDark ? color.hues[hue][700].hex : color.hues[hue][300].hex;
  return styledComponents.css`
    border-left: 2px solid ${borderColor};
    word-break: break-word;
  `;
});
function CommentsListItemReferencedValue(props2) {
  const { hasReferencedValue, value } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), tooltipText = t2("list-item.missing-referenced-value-tooltip-content"), resolvedValue = React.useMemo(() => {
    if (Array.isArray(value) && (value == null ? void 0 : value.filter(types.isPortableTextTextBlock).length) > 0) {
      const text = value == null ? void 0 : value.map(react$1.toPlainText).join(" ");
      return truncate(text);
    }
    return null;
  }, [value]);
  return resolvedValue ? /* @__PURE__ */ jsxRuntime.jsx(
    BlockQuoteStack,
    {
      $hasReferencedValue: !!hasReferencedValue,
      "data-testid": "comments-list-item-referenced-value",
      flex: 1,
      forwardedAs: "blockquote",
      padding: 1,
      paddingLeft: 2,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "flex-start", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, muted: !0, children: [
        !hasReferencedValue && /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Tooltip, { content: tooltipText, children: /* @__PURE__ */ jsxRuntime.jsx(InlineBox, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.LinkRemovedIcon, {}) }) }),
        resolvedValue
      ] }) })
    }
  ) : null;
}
const stopPropagation = (e) => e.stopPropagation(), ContextMenuBox = styledComponents.styled(ui.Box)``, SKELETON_INLINE_STYLE = { width: "50%" }, EMPTY_ARRAY$1 = [], TimeText = styledComponents.styled(ui.Text)(({ theme: theme2 }) => {
  const isDark = theme2.sanity.color.dark, fg = color.hues.gray[isDark ? 200 : 800].hex;
  return styledComponents.css`
    min-width: max-content;
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
}), HeaderFlex$1 = styledComponents.styled(ui.Flex)((props2) => {
  var _a2;
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    min-height: ${(_a2 = theme$1.avatar.sizes[props2.$size]) == null ? void 0 : _a2.size}px;
  `;
}), IntentText = styledComponents.styled(ui.Text)(({ theme: theme2 }) => {
  const isDark = theme2.sanity.color.dark, fg = color.hues.gray[isDark ? 200 : 800].hex;
  return styledComponents.css`
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
}), InnerStack = styledComponents.styled(ui.Stack)`
  transition: opacity 200ms ease;

  &[data-muted='true'] {
    transition: unset;
    opacity: 0.5;
  }
`, ErrorFlex = styledComponents.styled(ui.Flex)((props2) => {
  var _a2;
  const theme$1 = theme.getTheme_v2(props2.theme);
  return styledComponents.css`
    min-height: ${(_a2 = theme$1.avatar.sizes[props2.$size]) == null ? void 0 : _a2.size}px;
  `;
}), RetryCardButton = styledComponents.styled(ui.Card)`
  // Add not on hover
  &:not(:hover) {
    background-color: transparent;
  }
`, RootStack = styledComponents.styled(ui.Stack)(({ theme: theme2 }) => {
  const { space } = theme2.sanity;
  return styledComponents.css`
    position: relative;

    // Only show the floating layer on hover when hover is supported.
    // Else, the layer is always visible.
    @media (hover: hover) {
      ${ContextMenuBox} {
        opacity: 0;
        position: absolute;
        right: 0;
        top: 0;
        transform: translate(${space[1]}px, -${space[1]}px);
      }

      ${ContextMenuBox} {
        &:focus-within {
          opacity: 1;
        }
      }

      &:hover {
        ${ContextMenuBox} {
          opacity: 1;
        }
      }
    }

    &[data-menu-open='true'] {
      ${ContextMenuBox} {
        opacity: 1;
      }
    }
  `;
}), RELATIVE_TIME_OPTIONS = { useTemporalPhrase: !0 };
function CommentsListItemLayout(props2) {
  var _a2;
  const {
    avatarSize = 1,
    canDelete,
    canEdit,
    comment,
    currentUser,
    hasError,
    hasReferencedValue,
    intent,
    isParent,
    isRetrying,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onInputKeyDown,
    onReactionSelect,
    onStatusChange,
    readOnly,
    withAvatar = !0
  } = props2, { _createdAt, authorId, message, _id, lastEditedAt } = comment, [user] = useUser(authorId), { t: t2 } = useTranslation(commentsLocaleNamespace), [value, setValue] = React.useState(message), [isEditing, setIsEditing] = React.useState(!1), [rootElement, setRootElement] = React.useState(null), startMessage = React.useRef(message), [menuOpen, setMenuOpen] = React.useState(!1), commentInputRef = React.useRef(null), hasChanges = useCommentHasChanged(value), hasValue2 = React.useMemo(() => hasCommentMessageValue(value), [value]), reactions = React.useMemo(
    () => {
      var _a22;
      return (((_a22 = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a22.filter((r) => (r == null ? void 0 : r._optimisticState) !== "removed")) || EMPTY_ARRAY$1).filter(
        (r) => "userId" in r && "shortName" in r
      );
    },
    [comment == null ? void 0 : comment.reactions]
  ), hasReactions = !!(reactions != null && reactions.length), createdDate = _createdAt ? new Date(_createdAt) : /* @__PURE__ */ new Date(), editedDate = lastEditedAt ? new Date(lastEditedAt) : null, createdTimeAgo = useRelativeTime(createdDate, RELATIVE_TIME_OPTIONS), dateTimeFormat = useDateTimeFormat({ dateStyle: "full", timeStyle: "medium" }), formattedCreatedAt = dateTimeFormat.format(createdDate), formattedLastEditAt = editedDate ? dateTimeFormat.format(editedDate) : null, displayError = hasError || isRetrying;
  React.useEffect(() => {
    isEditing || (startMessage.current = message, setValue(message));
  }, [isEditing, message]);
  const handleMenuOpen = React.useCallback(() => setMenuOpen(!0), []), handleMenuClose = React.useCallback(() => setMenuOpen(!1), []), handleCopyLink = React.useCallback(() => onCopyLink == null ? void 0 : onCopyLink(_id), [_id, onCopyLink]), handleCreateRetry = React.useCallback(
    (e) => {
      e.stopPropagation(), onCreateRetry == null || onCreateRetry(_id);
    },
    [_id, onCreateRetry]
  ), handleDelete = React.useCallback(() => onDelete(_id), [_id, onDelete]), cancelEdit = React.useCallback(() => {
    setIsEditing(!1), setValue(startMessage.current);
  }, []), startDiscard = React.useCallback(() => {
    var _a22;
    if (!hasValue2 || !hasChanges) {
      cancelEdit();
      return;
    }
    (_a22 = commentInputRef.current) == null || _a22.discardDialogController.open();
  }, [cancelEdit, hasChanges, hasValue2]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onInputKeyDown && onInputKeyDown(event));
    },
    [onInputKeyDown, startDiscard]
  ), cancelDiscard = React.useCallback(() => {
    var _a22;
    (_a22 = commentInputRef.current) == null || _a22.discardDialogController.close();
  }, []), confirmDiscard = React.useCallback(() => {
    var _a22;
    (_a22 = commentInputRef.current) == null || _a22.discardDialogController.close(), cancelEdit();
  }, [cancelEdit]), handleReactionSelect = React.useCallback(
    (reaction) => {
      onReactionSelect == null || onReactionSelect(_id, reaction);
    },
    [_id, onReactionSelect]
  ), handleEditSubmit = React.useCallback(() => {
    onEdit(_id, { message: value }), setIsEditing(!1);
  }, [_id, onEdit, value]), handleOpenStatusChange = React.useCallback(() => {
    onStatusChange == null || onStatusChange(_id, comment.status === "open" ? "resolved" : "open");
  }, [_id, comment.status, onStatusChange]), toggleEdit = React.useCallback(() => {
    setIsEditing((v) => !v);
  }, []), handleCloseMenu = React.useCallback(() => setMenuOpen(!1), []), handleClickOutside = React.useCallback(() => {
    hasChanges || cancelEdit();
  }, [cancelEdit, hasChanges]), handleRootKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && !hasChanges && cancelEdit();
    },
    [cancelEdit, hasChanges]
  );
  useDidUpdate(isEditing, handleCloseMenu), ui.useClickOutside(handleClickOutside, [rootElement]);
  const name = user != null && user.displayName ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", textOverflow: "ellipsis", title: user.displayName, children: user.displayName }) : /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE });
  return /* @__PURE__ */ jsxRuntime.jsxs(
    RootStack,
    {
      "data-menu-open": menuOpen ? "true" : "false",
      "data-testid": "comments-list-item-layout",
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      space: 4,
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(InnerStack, { space: 1, "data-muted": displayError, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex$1, { align: "center", gap: FLEX_GAP, flex: 1, $size: avatarSize, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user, size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 2, paddingY: intent ? 2 : 0, children: [
              /* @__PURE__ */ jsxRuntime.jsx(
                ui.Flex,
                {
                  align: "center",
                  paddingBottom: (_a2 = comment.context) != null && _a2.intent ? 0 : 1,
                  sizing: "border",
                  flex: 1,
                  children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-end", gap: 2, children: [
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: name }),
                    !displayError && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
                      /* @__PURE__ */ jsxRuntime.jsx(TimeText, { muted: !0, size: 0, children: /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: createdDate.toISOString(), title: formattedCreatedAt, children: createdTimeAgo }) }),
                      formattedLastEditAt && editedDate && /* @__PURE__ */ jsxRuntime.jsx(TimeText, { muted: !0, size: 0, title: formattedLastEditAt, children: /* @__PURE__ */ jsxRuntime.jsxs("time", { dateTime: editedDate.toISOString(), title: formattedLastEditAt, children: [
                        "(",
                        t2("list-item.layout-edited"),
                        ")"
                      ] }) })
                    ] })
                  ] })
                }
              ),
              intent && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(IntentText, { muted: !0, size: 0, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(
                Translate,
                {
                  t: t2,
                  i18nKey: "list-item.layout-context",
                  values: { title: intent.title, intent: "edit" },
                  components: {
                    IntentLink: ({ children }) => intent ? /* @__PURE__ */ jsxRuntime.jsx(router.IntentLink, { params: intent.params, intent: intent.name, children }) : void 0
                  }
                }
              ) }) })
            ] }),
            !isEditing && !displayError && /* @__PURE__ */ jsxRuntime.jsx(ContextMenuBox, { "data-root-menu": isParent ? "true" : "false", onClick: stopPropagation, children: /* @__PURE__ */ jsxRuntime.jsx(
              CommentsListItemContextMenu,
              {
                canDelete,
                canEdit,
                isParent,
                mode,
                onCopyLink: onCopyLink ? handleCopyLink : void 0,
                onDeleteStart: handleDelete,
                onEditStart: toggleEdit,
                onMenuClose: handleMenuClose,
                onMenuOpen: handleMenuOpen,
                onReactionSelect: handleReactionSelect,
                onStatusChange: onStatusChange ? handleOpenStatusChange : void 0,
                readOnly,
                status: comment.status
              }
            ) })
          ] }),
          isTextSelectionComment(comment) && !!(comment != null && comment.contentSnapshot) && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: FLEX_GAP, marginBottom: 3, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(
              CommentsListItemReferencedValue,
              {
                hasReferencedValue,
                value: comment == null ? void 0 : comment.contentSnapshot
              }
            )
          ] }),
          isEditing && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 2, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
              CommentInput,
              {
                currentUser,
                focusOnMount: !0,
                mentionOptions,
                onChange: setValue,
                onDiscardCancel: cancelDiscard,
                onDiscardConfirm: confirmDiscard,
                onKeyDown: handleInputKeyDown,
                onSubmit: handleEditSubmit,
                readOnly,
                ref: commentInputRef,
                value,
                withAvatar: !1
              }
            ) })
          ] }),
          !isEditing && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: FLEX_GAP, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(CommentMessageSerializer, { blocks: message })
          ] }),
          hasReactions && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: FLEX_GAP, marginTop: 2, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { onClick: stopPropagation, children: /* @__PURE__ */ jsxRuntime.jsx(
              CommentReactionsBar,
              {
                currentUser,
                mode,
                onSelect: handleReactionSelect,
                reactions,
                readOnly
              }
            ) })
          ] })
        ] }),
        displayError && /* @__PURE__ */ jsxRuntime.jsxs(ErrorFlex, { gap: FLEX_GAP, $size: avatarSize, children: [
          withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, flex: 1, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
              hasError && t2("list-item.layout-failed-sent"),
              isRetrying && t2("list-item.layout-posting")
            ] }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { hidden: isRetrying, children: /* @__PURE__ */ jsxRuntime.jsx(
              RetryCardButton,
              {
                __unstable_focusRing: !0,
                display: "flex",
                forwardedAs: "button",
                onClick: handleCreateRetry,
                padding: 1,
                radius: 2,
                tone: "primary",
                children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t2("list-item.layout-retry") })
              }
            ) })
          ] })
        ] })
      ]
    }
  );
}
const ThreadCard = styledComponents.styled(ui.Card).attrs({ padding: 3, radius: 3, sizing: "border" })(
  (props2) => {
    const { theme: theme2 } = props2, isDark = theme2.sanity.color.dark, activeBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 900 : 50].hex, defaultBg = color.hues.gray[isDark ? 900 : 50].hex;
    return styledComponents.css`
      background-color: ${defaultBg};

      &[data-active='true'] {
        background-color: ${activeBg};
      }
    `;
  }
), EMPTY_ARRAY = [], MAX_COLLAPSED_REPLIES = 5, DEFAULT_AVATAR_CONFIG = {
  avatarSize: 1,
  parentCommentAvatar: !0,
  replyAvatar: !0,
  threadCommentsAvatar: !0
}, StyledThreadCard = styledComponents.styled(ThreadCard)(() => styledComponents.css`
    position: relative;

    &:has(> [data-ui='GhostButton']:focus:focus-visible) {
      box-shadow:
        inset 0 0 0 1px var(--card-border-color),
        0 0 0 1px var(--card-bg-color),
        0 0 0 2px var(--card-focus-ring-color);
    }

    // The hover styles is managed with the [data-hovered] attribute instead of the :hover pseudo class
    // since we want to show the hover styles when hovering over the menu items in the context menu as well.
    // The context menu is rendered using a portal, so the :hover pseudo class won't work when hovering over
    // the menu items.
    &:not([data-active='true']) {
      @media (hover: hover) {
        &[data-hovered='true'] {
          [data-root-menu='true'] {
            opacity: 1;
          }
        }
      }
    }
  `), ExpandButton = styledComponents.styled(TooltipDelayGroupProvider.Button)(({ theme: theme2 }) => {
  const { medium } = theme2.sanity.fonts.text.weights;
  return styledComponents.css`
    font-weight: ${medium};
  `;
}), GhostButton = styledComponents.styled.button`
  opacity: 0;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  left: 0;
`, CommentsListItem = React.memo(function(props2) {
  var _a2, _b, _c, _d, _e;
  const {
    avatarConfig = DEFAULT_AVATAR_CONFIG,
    canReply,
    currentUser,
    hasReferencedValue,
    innerPadding,
    isSelected,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onKeyDown,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    parentComment,
    readOnly,
    replies = EMPTY_ARRAY
  } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), [value, setValue] = React.useState(EMPTY_ARRAY), [collapsed, setCollapsed] = React.useState(!0), didExpand = React.useRef(!1), replyInputRef = React.useRef(null), { isTopLayer } = ui.useLayer(), hasValue2 = React.useMemo(() => hasCommentMessageValue(value), [value]), [mouseOver, setMouseOver] = React.useState(!1), handleMouseEnter = React.useCallback(() => setMouseOver(!0), []), handleMouseLeave = React.useCallback(() => setMouseOver(!1), []), handleReplySubmit = React.useCallback(() => {
    var _a22;
    const nextComment = {
      message: value,
      parentCommentId: parentComment._id,
      status: (parentComment == null ? void 0 : parentComment.status) || "open",
      // Since this is a reply to an existing comment, we use the same thread ID as the parent
      threadId: parentComment.threadId,
      // A new comment will not have any reactions
      reactions: EMPTY_ARRAY,
      payload: {
        fieldPath: ((_a22 = parentComment.target.path) == null ? void 0 : _a22.field) || ""
      }
    };
    onReply == null || onReply(nextComment), setValue(EMPTY_ARRAY);
  }, [
    onReply,
    parentComment._id,
    parentComment == null ? void 0 : parentComment.status,
    (_a2 = parentComment.target.path) == null ? void 0 : _a2.field,
    parentComment.threadId,
    value
  ]), startDiscard = React.useCallback(() => {
    var _a22;
    if (!hasValue2) {
      setValue(EMPTY_ARRAY);
      return;
    }
    (_a22 = replyInputRef.current) == null || _a22.discardDialogController.open();
  }, [hasValue2]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), cancelDiscard = React.useCallback(() => {
    var _a22;
    (_a22 = replyInputRef.current) == null || _a22.discardDialogController.close();
  }, []), confirmDiscard = React.useCallback(() => {
    var _a22, _b2;
    setValue(EMPTY_ARRAY), (_a22 = replyInputRef.current) == null || _a22.discardDialogController.close(), (_b2 = replyInputRef.current) == null || _b2.focus();
  }, []), handleThreadRootClick = React.useCallback(
    (e) => {
      var _a22;
      e.stopPropagation(), isTopLayer && (onPathSelect == null || onPathSelect({
        fieldPath: ((_a22 = parentComment.target.path) == null ? void 0 : _a22.field) || "",
        origin: "inspector",
        threadId: parentComment.threadId
      }));
    },
    [isTopLayer, onPathSelect, (_b = parentComment.target.path) == null ? void 0 : _b.field, parentComment.threadId]
  ), handleExpand = React.useCallback((e) => {
    e.stopPropagation(), setCollapsed(!1), didExpand.current = !0;
  }, []), splicedReplies = React.useMemo(() => collapsed ? replies == null ? void 0 : replies.slice(-MAX_COLLAPSED_REPLIES) : replies, [replies, collapsed]), showCollapseButton = React.useMemo(() => replies ? replies.length > MAX_COLLAPSED_REPLIES : !1, [replies]), expandButtonText = React.useMemo(() => `${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES} more ${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES === 1 ? "comment" : "comments"}`, [replies == null ? void 0 : replies.length]);
  React.useEffect(() => {
    replies.length > MAX_COLLAPSED_REPLIES && !didExpand.current && setCollapsed(!0);
  }, [replies]);
  const renderedReplies = React.useMemo(
    () => splicedReplies.map((reply) => {
      var _a22, _b2;
      return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", ...applyCommentIdAttr(reply._id), children: /* @__PURE__ */ jsxRuntime.jsx(
        CommentsListItemLayout,
        {
          avatarSize: avatarConfig.avatarSize,
          canDelete: reply.authorId === currentUser.id,
          canEdit: reply.authorId === currentUser.id,
          comment: reply,
          currentUser,
          hasError: ((_a22 = reply._state) == null ? void 0 : _a22.type) === "createError",
          isRetrying: ((_b2 = reply._state) == null ? void 0 : _b2.type) === "createRetrying",
          intent: commentIntentIfDiffers(parentComment, reply),
          mentionOptions,
          mode,
          onCopyLink,
          onCreateRetry,
          onDelete,
          onEdit,
          onInputKeyDown: handleInputKeyDown,
          onReactionSelect,
          readOnly,
          withAvatar: avatarConfig.threadCommentsAvatar
        }
      ) }, reply._id);
    }),
    [
      avatarConfig.threadCommentsAvatar,
      avatarConfig.avatarSize,
      currentUser,
      handleInputKeyDown,
      mentionOptions,
      onCopyLink,
      onCreateRetry,
      onDelete,
      onEdit,
      onReactionSelect,
      parentComment,
      readOnly,
      splicedReplies,
      mode
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    StyledThreadCard,
    {
      "data-active": isSelected ? "true" : "false",
      "data-hovered": mouseOver ? "true" : "false",
      "data-testid": "comments-list-item",
      "data-ui": "CommentsListItem",
      onClick: handleThreadRootClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          GhostButton,
          {
            "data-ui": "GhostButton",
            "aria-label": t2("list-item.go-to-field-button.aria-label")
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Stack,
          {
            as: "ul",
            padding: innerPadding,
            paddingBottom: canReply ? void 0 : 1,
            space: 4,
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", ...applyCommentIdAttr(parentComment._id), children: /* @__PURE__ */ jsxRuntime.jsx(
                CommentsListItemLayout,
                {
                  avatarSize: avatarConfig.avatarSize,
                  canDelete: parentComment.authorId === currentUser.id,
                  canEdit: parentComment.authorId === currentUser.id,
                  comment: parentComment,
                  currentUser,
                  hasError: ((_c = parentComment._state) == null ? void 0 : _c.type) === "createError",
                  hasReferencedValue,
                  intent: (_d = parentComment.context) == null ? void 0 : _d.intent,
                  isParent: !0,
                  isRetrying: ((_e = parentComment._state) == null ? void 0 : _e.type) === "createRetrying",
                  mentionOptions,
                  mode,
                  onCopyLink,
                  onCreateRetry,
                  onDelete,
                  onEdit,
                  onInputKeyDown: onKeyDown,
                  onReactionSelect,
                  onStatusChange,
                  readOnly,
                  withAvatar: avatarConfig.parentCommentAvatar
                }
              ) }),
              showCollapseButton && !didExpand.current && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, paddingY: 1, sizing: "border", children: [
                /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, {}),
                /* @__PURE__ */ jsxRuntime.jsx(
                  ExpandButton,
                  {
                    iconRight: icons.ChevronDownIcon,
                    mode: "bleed",
                    onClick: handleExpand,
                    text: expandButtonText
                  }
                )
              ] }),
              renderedReplies,
              canReply && /* @__PURE__ */ jsxRuntime.jsx(
                CommentInput,
                {
                  avatarSize: avatarConfig.avatarSize,
                  currentUser,
                  expandOnFocus: !0,
                  mentionOptions,
                  onChange: setValue,
                  onDiscardCancel: cancelDiscard,
                  onDiscardConfirm: confirmDiscard,
                  onKeyDown: handleInputKeyDown,
                  onSubmit: handleReplySubmit,
                  placeholder: t2(mode === "upsell" ? "compose.reply-placeholder-upsell" : "compose.reply-placeholder"),
                  readOnly: readOnly || mode === "upsell",
                  ref: replyInputRef,
                  value,
                  withAvatar: avatarConfig.replyAvatar
                }
              )
            ]
          }
        )
      ]
    }
  );
});
function getEmptyStateMessages(t2) {
  return {
    open: {
      title: t2("list-status.empty-state-open-title"),
      message: t2("list-status.empty-state-open-text")
    },
    resolved: {
      title: t2("list-status.empty-state-resolved-title"),
      message: t2("list-status.empty-state-resolved-text")
    }
  };
}
function CommentsListStatus(props2) {
  const { status, error, loading, hasNoComments } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), emptyStateMessages = getEmptyStateMessages(t2);
  return error ? /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", flex: 1, padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t2("list-status.error") }) }) }) : loading ? /* @__PURE__ */ jsxRuntime.jsx(LoadingBlock, { showText: !0, title: t2("list-status.loading") }) : hasNoComments ? /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", flex: 1, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, padding: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, weight: "medium", children: emptyStateMessages[status].title }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, children: emptyStateMessages[status].message })
  ] }) }) }) : null;
}
const EMPTY_PT_ARRAY = [];
function CreateNewThreadInput(props2) {
  const {
    currentUser,
    fieldTitle,
    mentionOptions,
    mode,
    onBlur,
    onFocus,
    onKeyDown,
    onNewThreadCreate,
    readOnly
  } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), [value, setValue] = React.useState(EMPTY_PT_ARRAY), commentInputHandle = React.useRef(null), handleSubmit = React.useCallback(() => {
    onNewThreadCreate == null || onNewThreadCreate(value), setValue(EMPTY_PT_ARRAY);
  }, [onNewThreadCreate, value]), hasValue2 = React.useMemo(() => hasCommentMessageValue(value), [value]), startDiscard = React.useCallback(() => {
    var _a2;
    hasValue2 && ((_a2 = commentInputHandle.current) == null || _a2.discardDialogController.open());
  }, [hasValue2]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onKeyDown && onKeyDown(event));
    },
    [onKeyDown, startDiscard]
  ), confirmDiscard = React.useCallback(() => {
    var _a2, _b;
    setValue(EMPTY_PT_ARRAY), (_a2 = commentInputHandle.current) == null || _a2.discardDialogController.close(), (_b = commentInputHandle.current) == null || _b.focus();
  }, []), cancelDiscard = React.useCallback(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null || _a2.discardDialogController.close();
  }, []), placeholder = mode === "upsell" ? t2("compose.add-comment-input-placeholder-upsell") : /* @__PURE__ */ jsxRuntime.jsx(
    Translate,
    {
      t: t2,
      i18nKey: "compose.add-comment-input-placeholder",
      values: { field: fieldTitle }
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommentInput,
    {
      currentUser,
      expandOnFocus: !0,
      mentionOptions,
      onBlur,
      onChange: setValue,
      onDiscardCancel: cancelDiscard,
      onDiscardConfirm: confirmDiscard,
      onKeyDown: handleInputKeyDown,
      onFocus,
      onSubmit: handleSubmit,
      placeholder,
      readOnly: readOnly || mode === "upsell",
      ref: commentInputHandle,
      value
    }
  );
}
const HeaderFlex = styledComponents.styled(ui.Flex)`
  min-height: 25px;
`, BreadcrumbsButton = styledComponents.styled(ui.Button)(({ theme: theme2 }) => {
  const fg = theme2.sanity.color.base.fg;
  return styledComponents.css`
    --card-fg-color: ${fg};

    // The width is needed to make the text ellipsis work
    // in the breadcrumbs component
    max-width: 100%;
  `;
});
function CommentThreadLayout(props2) {
  const {
    breadcrumbs,
    canCreateNewThread,
    children,
    currentUser,
    fieldPath,
    isSelected,
    mentionOptions,
    mode,
    onNewThreadCreate,
    onPathSelect,
    readOnly
  } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace), handleNewThreadCreate = React.useCallback(
    (payload) => {
      const nextComment = {
        message: payload,
        parentCommentId: void 0,
        status: "open",
        // Since this is a new comment, we generate a new thread ID
        threadId: uuid.uuid(),
        // New comments have no reactions
        reactions: [],
        payload: {
          fieldPath
        }
      };
      onNewThreadCreate == null || onNewThreadCreate(nextComment);
    },
    [onNewThreadCreate, fieldPath]
  ), handleBreadcrumbsClick = React.useCallback(
    (e) => {
      e.stopPropagation(), onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      });
    },
    [fieldPath, onPathSelect]
  ), handleNewThreadClick = React.useCallback(
    (e) => {
      e.stopPropagation(), e.detail !== 0 && (onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      }));
    },
    [fieldPath, onPathSelect]
  ), crumbsTitlePath = React.useMemo(() => (breadcrumbs == null ? void 0 : breadcrumbs.map((p) => p.title)) || [], [breadcrumbs]), lastCrumb = crumbsTitlePath[crumbsTitlePath.length - 1];
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(HeaderFlex, { align: "center", gap: 2, paddingRight: 1, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
      BreadcrumbsButton,
      {
        "aria-label": t2("list-item.breadcrumb-button-go-to-field-aria-label", {
          field: lastCrumb
        }),
        mode: "bleed",
        onClick: handleBreadcrumbsClick,
        padding: 2,
        space: 2,
        children: /* @__PURE__ */ jsxRuntime.jsx(CommentBreadcrumbs, { maxLength: 3, titlePath: crumbsTitlePath })
      }
    ) }) }) }),
    canCreateNewThread && /* @__PURE__ */ jsxRuntime.jsx(ThreadCard, { onClick: handleNewThreadClick, "data-active": isSelected, children: /* @__PURE__ */ jsxRuntime.jsx(
      CreateNewThreadInput,
      {
        currentUser,
        fieldTitle: lastCrumb,
        mentionOptions,
        mode,
        onNewThreadCreate: handleNewThreadCreate,
        readOnly
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children })
  ] });
}
function groupThreads(comments2) {
  return comments2.reduce((acc, comment) => {
    const field = comment.fieldPath;
    return acc[field] || (acc[field] = []), acc[field].push(comment), acc;
  }, {});
}
const CommentsListInner = React.forwardRef(function(props2, ref) {
  const {
    beforeListNode,
    comments: comments2,
    currentUser,
    error,
    loading,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onNewThreadCreate,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    readOnly,
    selectedPath,
    status
  } = props2, [boundaryElement, setBoundaryElement] = React.useState(null), groupedThreads = React.useMemo(() => Object.entries(groupThreads(comments2)), [comments2]), showComments = !loading && !error && groupedThreads.length > 0;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      "data-testid": "comments-list",
      direction: "column",
      flex: 1,
      height: "fill",
      overflow: "hidden",
      ref: setBoundaryElement,
      sizing: "border",
      children: [
        mode !== "upsell" && /* @__PURE__ */ jsxRuntime.jsx(
          CommentsListStatus,
          {
            error,
            hasNoComments: groupedThreads.length === 0,
            loading,
            status
          }
        ),
        (showComments || beforeListNode) && /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Stack,
          {
            as: "ul",
            flex: 1,
            overflow: "auto",
            padding: 3,
            paddingTop: 1,
            paddingBottom: 6,
            sizing: "border",
            space: 1,
            ref,
            children: [
              beforeListNode,
              /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: boundaryElement, children: groupedThreads == null ? void 0 : groupedThreads.map(([fieldPath, group2]) => {
                const breadcrumbs = group2[0].breadcrumbs, firstThreadId = group2[0].threadId, newThreadSelected = (selectedPath == null ? void 0 : selectedPath.fieldPath) === fieldPath && !selectedPath.threadId;
                return /* @__PURE__ */ jsxRuntime.jsx(
                  ui.Stack,
                  {
                    as: "li",
                    paddingTop: 3,
                    ...applyCommentsGroupAttr(firstThreadId),
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      CommentThreadLayout,
                      {
                        breadcrumbs,
                        canCreateNewThread: status === "open",
                        currentUser,
                        fieldPath,
                        isSelected: newThreadSelected,
                        mentionOptions,
                        mode,
                        onNewThreadCreate,
                        onPathSelect,
                        readOnly,
                        children: group2.map((item) => {
                          var _a2, _b, _c;
                          const replies = item.replies.slice().reverse(), canReply = status === "open" && ((_a2 = item.parentComment._state) == null ? void 0 : _a2.type) !== "createError" && ((_b = item.parentComment._state) == null ? void 0 : _b.type) !== "createRetrying", threadIsSelected = (selectedPath == null ? void 0 : selectedPath.threadId) === item.parentComment.threadId && (selectedPath == null ? void 0 : selectedPath.fieldPath) === ((_c = item.parentComment.target.path) == null ? void 0 : _c.field);
                          return /* @__PURE__ */ jsxRuntime.jsx(
                            CommentsListItem,
                            {
                              canReply,
                              currentUser,
                              hasReferencedValue: item.hasReferencedValue,
                              isSelected: threadIsSelected,
                              mentionOptions,
                              mode,
                              onCopyLink,
                              onCreateRetry,
                              onDelete,
                              onEdit,
                              onPathSelect,
                              onReactionSelect,
                              onReply,
                              onStatusChange,
                              parentComment: item.parentComment,
                              readOnly,
                              replies
                            },
                            item.parentComment._id
                          );
                        })
                      },
                      fieldPath
                    )
                  },
                  fieldPath
                );
              }) })
            ]
          }
        )
      ]
    }
  );
}), CommentsList = React.memo(CommentsListInner), Root = styledComponents.styled(ui.Box)`
  max-width: 280px;
`, fadeInKeyFrame = styledComponents.keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`, StyledPopover = styledComponents.styled(TooltipDelayGroupProvider.Popover)`
  opacity: 0;
  // Fade in the popover after 500ms
  animation: ${fadeInKeyFrame} 200ms 500ms forwards;
`;
function CommentsOnboardingPopover(props2) {
  const { onDismiss } = props2, { t: t2 } = useTranslation(commentsLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledPopover,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(Root, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: t2("onboarding.header") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t2("onboarding.body") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "flex-end", marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(TooltipDelayGroupProvider.Button, { text: t2("onboarding.dismiss"), tone: "primary", onClick: onDismiss }) })
      ] }) }),
      open: !0,
      portal: !0,
      ...props2
    }
  );
}
function CommentsUpsellPanel(props2) {
  const { data, onPrimaryClick, onSecondaryClick } = props2;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 6, children: /* @__PURE__ */ jsxRuntime.jsx(
    UpsellPanel,
    {
      data,
      onPrimaryClick,
      onSecondaryClick
    }
  ) }) });
}
exports.ActiveWorkspaceMatcher = ActiveWorkspaceMatcher;
exports.AddonDatasetProvider = AddonDatasetProvider;
exports.ArrayOfObjectOptionsInput = ArrayOfObjectOptionsInput;
exports.ArrayOfObjectsFunctions = ArrayOfObjectsFunctions;
exports.ArrayOfObjectsInput = ArrayOfObjectsInput;
exports.ArrayOfObjectsInputMember = ArrayOfObjectsInputMember;
exports.ArrayOfObjectsInputMembers = ArrayOfObjectsInputMembers;
exports.ArrayOfObjectsItem = ArrayOfObjectsItem;
exports.ArrayOfOptionsInput = ArrayOfOptionsInput;
exports.ArrayOfPrimitiveOptionsInput = ArrayOfPrimitiveOptionsInput;
exports.ArrayOfPrimitivesFunctions = ArrayOfPrimitivesFunctions;
exports.ArrayOfPrimitivesInput = ArrayOfPrimitivesInput;
exports.ArrayOfPrimitivesItem = ArrayOfPrimitivesItem;
exports.AutoCollapseMenu = AutoCollapseMenu;
exports.BetaBadge = BetaBadge;
exports.BlockEditor = PortableTextInput;
exports.BlockImagePreview = BlockImagePreview;
exports.BlockPreview = BlockPreview;
exports.BooleanInput = BooleanInput;
exports.COMMENTS_INSPECTOR_NAME = COMMENTS_INSPECTOR_NAME;
exports.CONNECTING = CONNECTING;
exports.ChangeBreadcrumb = ChangeBreadcrumb;
exports.ChangeConnectorRoot = ChangeConnectorRoot;
exports.ChangeFieldWrapper = ChangeFieldWrapper;
exports.ChangeIndicator = ChangeIndicator;
exports.ChangeList = ChangeList;
exports.ChangeResolver = ChangeResolver;
exports.ChangeTitleSegment = ChangeTitleSegment;
exports.CircularProgress = CircularProgress;
exports.CollapseMenu = CollapseMenu;
exports.CollapseMenuButton = CollapseMenuButton;
exports.ColorSchemeCustomProvider = ColorSchemeCustomProvider;
exports.ColorSchemeLocalStorageProvider = ColorSchemeLocalStorageProvider;
exports.ColorSchemeProvider = ColorSchemeProvider;
exports.CommandList = CommandList;
exports.CommentInput = CommentInput;
exports.CommentsEnabledProvider = CommentsEnabledProvider;
exports.CommentsIntentProvider = CommentsIntentProvider;
exports.CommentsProvider = CommentsProvider;
exports.CompactPreview = CompactPreview;
exports.ConfigPropertyError = ConfigPropertyError;
exports.ConfigResolutionError = ConfigResolutionError;
exports.ContextMenuButton = ContextMenuButton;
exports.CorsOriginError = CorsOriginError;
exports.CrossDatasetReferenceInput = StudioCrossDatasetReferenceInput;
exports.DEFAULT_MAX_RECURSION_DEPTH = DEFAULT_MAX_RECURSION_DEPTH;
exports.DEFAULT_STUDIO_CLIENT_OPTIONS = DEFAULT_STUDIO_CLIENT_OPTIONS;
exports.DRAFTS_FOLDER = DRAFTS_FOLDER;
exports.DateInput = DateInput;
exports.DateTimeInput = DateTimeInput$2;
exports.DefaultDocument = DefaultDocument;
exports.DefaultPreview = DefaultPreview;
exports.DetailPreview = DetailPreview;
exports.DiffCard = DiffCard;
exports.DiffErrorBoundary = DiffErrorBoundary;
exports.DiffFromTo = DiffFromTo;
exports.DiffInspectWrapper = DiffInspectWrapper;
exports.DiffString = DiffString;
exports.DiffStringSegment = DiffStringSegment;
exports.DiffTooltip = DiffTooltip;
exports.DisabledChangeConnectorRoot = DisabledChangeConnectorRoot;
exports.DocumentPreviewPresence = DocumentPreviewPresence;
exports.DocumentStatus = DocumentStatus;
exports.DocumentStatusIndicator = DocumentStatusIndicator;
exports.EMPTY_ARRAY = EMPTY_ARRAY$t;
exports.EMPTY_OBJECT = EMPTY_OBJECT;
exports.EmailInput = EmailInput;
exports.EnabledChangeConnectorRoot = EnabledChangeConnectorRoot;
exports.ErrorMessage = ErrorMessage;
exports.FallbackDiff = FallbackDiff;
exports.FieldActionMenu = FieldActionMenu;
exports.FieldActionsProvider = FieldActionsProvider;
exports.FieldActionsResolver = FieldActionsResolver;
exports.FieldChange = FieldChange;
exports.FieldPresence = FieldPresence;
exports.FieldPresenceInner = FieldPresenceInner;
exports.FieldPresenceWithOverlay = FieldPresenceWithOverlay;
exports.FieldPresenceWithoutOverlay = FieldPresenceWithoutOverlay;
exports.FileInput = StudioFileInput;
exports.Filters = Filters;
exports.FormBuilder = FormBuilder;
exports.FormCallbacksProvider = FormCallbacksProvider;
exports.FormField = FormField;
exports.FormFieldHeaderText = FormFieldHeaderText;
exports.FormFieldSet = FormFieldSet;
exports.FormFieldStatus = FormFieldStatus;
exports.FormFieldValidationStatus = FormFieldValidationStatus;
exports.FormInput = FormInput;
exports.FormProvider = FormProvider;
exports.FormValueProvider = FormValueProvider;
exports.FromTo = FromTo;
exports.FromToArrow = FromToArrow;
exports.GetHookCollectionState = GetHookCollectionState;
exports.GlobalErrorHandler = GlobalErrorHandler;
exports.GroupChange = GroupChange;
exports.Hotkeys = Hotkeys;
exports.HoveredFieldProvider = HoveredFieldProvider;
exports.ImageInput = StudioImageInput;
exports.ImperativeToast = ImperativeToast;
exports.InlinePreview = InlinePreview;
exports.InsufficientPermissionsMessage = InsufficientPermissionsMessage;
exports.IntentButton = IntentButton;
exports.IsLastPaneProvider = IsLastPaneProvider;
exports.LegacyLayerProvider = LegacyLayerProvider;
exports.LinearProgress = LinearProgress;
exports.LoadingBlock = LoadingBlock;
exports.LocaleProvider = LocaleProvider;
exports.LocaleProviderBase = LocaleProviderBase;
exports.MediaPreview = MediaPreview;
exports.MemberField = MemberField;
exports.MemberFieldError = MemberFieldError;
exports.MemberFieldSet = MemberFieldSet;
exports.MemberItemError = MemberItemError;
exports.MetaInfo = MetaInfo;
exports.NoChanges = NoChanges;
exports.NumberInput = NumberInput;
exports.ObjectInput = ObjectInput;
exports.ObjectInputMember = ObjectInputMember;
exports.ObjectInputMembers = ObjectInputMembers;
exports.ObjectMembers = ObjectMembers;
exports.OverlayDisabled = OverlayDisabled;
exports.PatchEvent = PatchEvent;
exports.PopoverDialog = PopoverDialog;
exports.PortableTextInput = PortableTextInput;
exports.PresenceOverlay = PresenceOverlay;
exports.PresenceScope = PresenceScope;
exports.Preview = Preview$1;
exports.PreviewCard = PreviewCard;
exports.PreviewLoader = PreviewLoader;
exports.ReferenceInput = StudioReferenceInput;
exports.ReferenceInputOptionsProvider = ReferenceInputOptionsProvider;
exports.RelativeTime = RelativeTime;
exports.ResourceCacheProvider = ResourceCacheProvider;
exports.RevertChangesButton = RevertChangesButton;
exports.SANITY_PATCH_TYPE = SANITY_PATCH_TYPE;
exports.SANITY_VERSION = SANITY_VERSION;
exports.SESSION_ID = SESSION_ID;
exports.SanityDefaultPreview = SanityDefaultPreview;
exports.ScheduleAction = ScheduleAction;
exports.ScheduledBadge = ScheduledBadge;
exports.SchemaError = SchemaError;
exports.ScrollContainer = ScrollContainer;
exports.ScrollMonitor = ScrollMonitor;
exports.SearchButton = SearchButton;
exports.SearchDialog = SearchDialog;
exports.SearchHeader = SearchHeader;
exports.SearchPopover = SearchPopover;
exports.SearchProvider = SearchProvider;
exports.SearchResultItemPreview = SearchResultItemPreview;
exports.SelectInput = SelectInput;
exports.SlugInput = SlugInput;
exports.SourceProvider = SourceProvider;
exports.StatusButton = StatusButton;
exports.StringInput = StringInput;
exports.Studio = Studio;
exports.StudioLayout = StudioLayout;
exports.StudioLayoutComponent = StudioLayoutComponent;
exports.StudioLogo = StudioLogo;
exports.StudioNavbar = StudioNavbar;
exports.StudioProvider = StudioProvider;
exports.StudioToolMenu = StudioToolMenu;
exports.TagsArrayInput = TagsArrayInput;
exports.TelephoneInput = TelephoneInput;
exports.TemplatePreview = TemplatePreview;
exports.TextInput = TextInput;
exports.TextWithTone = TextWithTone;
exports.Timeline = Timeline;
exports.TimelineController = TimelineController;
exports.ToolLink = ToolLink;
exports.TooltipOfDisabled = TooltipOfDisabled;
exports.Tracker = Tracker$1;
exports.TransformPatches = TransformPatches;
exports.Translate = Translate;
exports.UniversalArrayInput = UniversalArrayInput;
exports.UpsellDescriptionSerializer = UpsellDescriptionSerializer;
exports.UpsellDialogDismissed = UpsellDialogDismissed;
exports.UpsellDialogLearnMoreCtaClicked = UpsellDialogLearnMoreCtaClicked;
exports.UpsellDialogUpgradeCtaClicked = UpsellDialogUpgradeCtaClicked;
exports.UpsellDialogViewed = UpsellDialogViewed;
exports.UrlInput = UrlInput;
exports.UserAvatar = UserAvatar;
exports.UserColorManagerProvider = UserColorManagerProvider;
exports.ValueError = ValueError;
exports.VirtualizerScrollInstanceProvider = VirtualizerScrollInstanceProvider;
exports.WithReferringDocuments = WithReferringDocuments;
exports.WorkspaceLoader = WorkspaceLoaderBoundary;
exports.WorkspaceProvider = WorkspaceProvider;
exports.WorkspacesProvider = WorkspacesProvider;
exports.ZIndexProvider = ZIndexProvider;
exports.__tmp_wrap_presenceStore = __tmp_wrap_presenceStore;
exports._createAuthStore = _createAuthStore;
exports._isCustomDocumentTypeDefinition = _isCustomDocumentTypeDefinition;
exports._isSanityDocumentTypeDefinition = _isSanityDocumentTypeDefinition;
exports._useColorSchemeInternalValue = _useColorSchemeInternalValue;
exports.asLoadable = asLoadable;
exports.buildLegacyTheme = buildLegacyTheme;
exports.checkoutPair = checkoutPair;
exports.collate = collate;
exports.createAuthStore = createAuthStore;
exports.createBufferedDocument = createBufferedDocument;
exports.createConfig = createConfig;
exports.createConnectionStatusStore = createConnectionStatusStore;
exports.createDocumentPreviewStore = createDocumentPreviewStore;
exports.createDocumentStore = createDocumentStore;
exports.createDraftFrom = createDraftFrom;
exports.createGrantsStore = createGrantsStore;
exports.createHistoryStore = createHistoryStore;
exports.createHookFromObservableFactory = createHookFromObservableFactory;
exports.createKeyValueStore = createKeyValueStore;
exports.createMockAuthStore = createMockAuthStore;
exports.createNoopTrackerScope = createNoopTrackerScope;
exports.createObservableBufferedDocument = createObservableBufferedDocument;
exports.createPatchChannel = createPatchChannel;
exports.createPlugin = createPlugin;
exports.createProjectStore = createProjectStore;
exports.createPublishedFrom = createPublishedFrom;
exports.createSchema = createSchema;
exports.createSearch = createSearch;
exports.createSharedResizeObserver = createSharedResizeObserver;
exports.createSourceFromConfig = createSourceFromConfig;
exports.createTrackerScope = createTrackerScope;
exports.createUseReporter = createUseReporter;
exports.createUserColorManager = createUserColorManager;
exports.createUserStore = createUserStore;
exports.createWorkspaceFromConfig = createWorkspaceFromConfig;
exports.dec = dec;
exports.decodePath = decodePath;
exports.defaultLocale = defaultLocale;
exports.defaultRenderAnnotation = defaultRenderAnnotation;
exports.defaultRenderBlock = defaultRenderBlock;
exports.defaultRenderField = defaultRenderField;
exports.defaultRenderInlineBlock = defaultRenderInlineBlock;
exports.defaultRenderInput = defaultRenderInput;
exports.defaultRenderItem = defaultRenderItem;
exports.defaultRenderPreview = defaultRenderPreview;
exports.defaultTemplateForType = defaultTemplateForType;
exports.defaultTemplatesForSchema = defaultTemplatesForSchema;
exports.defaultTheme = defaultTheme;
exports.defineConfig = defineConfig;
exports.defineDocumentFieldAction = defineDocumentFieldAction;
exports.defineDocumentInspector = defineDocumentInspector;
exports.defineLocale = defineLocale;
exports.defineLocaleResourceBundle = defineLocaleResourceBundle;
exports.defineLocalesResources = defineLocalesResources;
exports.definePlugin = definePlugin;
exports.defineSearchFilter = defineSearchFilter;
exports.defineSearchFilterOperators = defineSearchFilterOperators;
exports.defineSearchOperator = defineSearchOperator;
exports.diffMatchPatch = diffMatchPatch;
exports.diffResolver = diffResolver;
exports.documentFieldActionsReducer = documentFieldActionsReducer;
exports.documentIdEquals = documentIdEquals;
exports.editState = editState;
exports.emitOperation = emitOperation;
exports.encodePath = encodePath;
exports.escapeField = escapeField;
exports.fieldNeedsEscape = fieldNeedsEscape;
exports.findIndex = findIndex;
exports.flattenConfig = flattenConfig;
exports.fromMutationPatches = fromMutationPatches;
exports.getAnnotationAtPath = getAnnotationAtPath;
exports.getAnnotationColor = getAnnotationColor;
exports.getConfigContextFromSource = getConfigContextFromSource;
exports.getDiffAtPath = getDiffAtPath;
exports.getDocumentPairPermissions = getDocumentPairPermissions;
exports.getDocumentValuePermissions = getDocumentValuePermissions;
exports.getDraftId = getDraftId;
exports.getExpandOperations = getExpandOperations;
exports.getIdPair = getIdPair;
exports.getInitialValueStream = getInitialValueStream;
exports.getItemKey = getItemKey$1;
exports.getItemKeySegment = getItemKeySegment;
exports.getNamelessWorkspaceIdentifier = getNamelessWorkspaceIdentifier;
exports.getPairListener = getPairListener;
exports.getPreviewPaths = getPreviewPaths;
exports.getPreviewStateObservable = getPreviewStateObservable$1;
exports.getPreviewValueWithFallback = getPreviewValueWithFallback;
exports.getProviderTitle = getProviderTitle;
exports.getPublishedId = getPublishedId;
exports.getSchemaTypeTitle = getSchemaTypeTitle;
exports.getSearchableTypes = getSearchableTypes;
exports.getTemplatePermissions = getTemplatePermissions;
exports.getValueAtPath = getValueAtPath;
exports.getValueError = getValueError;
exports.getWorkspaceIdentifier = getWorkspaceIdentifier;
exports.globalScope = globalScope;
exports.grantsPermissionOn = grantsPermissionOn;
exports.inc = inc;
exports.initialDocumentFieldActions = initialDocumentFieldActions;
exports.insert = insert;
exports.isAddedItemDiff = isAddedItemDiff;
exports.isArray = isArray;
exports.isArrayOfBlocksInputProps = isArrayOfBlocksInputProps;
exports.isArrayOfObjectsInputProps = isArrayOfObjectsInputProps;
exports.isArrayOfPrimitivesInputProps = isArrayOfPrimitivesInputProps;
exports.isAuthStore = isAuthStore;
exports.isBooleanInputProps = isBooleanInputProps;
exports.isBuilder = isBuilder;
exports.isCookielessCompatibleLoginMethod = isCookielessCompatibleLoginMethod;
exports.isDev = isDev;
exports.isDraft = isDraft;
exports.isDraftId = isDraftId;
exports.isEmptyObject = isEmptyObject$1;
exports.isFieldChange = isFieldChange;
exports.isGroupChange = isGroupChange;
exports.isNonNullable = isNonNullable$3;
exports.isNumberInputProps = isNumberInputProps;
exports.isObjectInputProps = isObjectInputProps;
exports.isObjectItemProps = isObjectItemProps;
exports.isProd = isProd;
exports.isPublishedId = isPublishedId;
exports.isRecord = isRecord$4;
exports.isRemovedItemDiff = isRemovedItemDiff;
exports.isString = isString;
exports.isStringInputProps = isStringInputProps;
exports.isTruthy = isTruthy;
exports.isUnchangedDiff = isUnchangedDiff;
exports.joinPath = joinPath;
exports.listenQuery = listenQuery;
exports.matchWorkspace = matchWorkspace;
exports.newDraftFrom = newDraftFrom;
exports.noop = noop$3;
exports.normalizeIndexSegment = normalizeIndexSegment;
exports.normalizeIndexTupleSegment = normalizeIndexTupleSegment;
exports.normalizeKeySegment = normalizeKeySegment;
exports.normalizePathSegment = normalizePathSegment;
exports.onRetry = onRetry;
exports.operationEvents = operationEvents;
exports.operatorDefinitions = operatorDefinitions;
exports.pathToString = pathToString$1;
exports.pathsAreEqual = pathsAreEqual;
exports.prefixPath = prefixPath;
exports.prepareConfig = prepareConfig;
exports.prepareForPreview = prepareForPreview;
exports.prepareTemplates = prepareTemplates;
exports.remoteSnapshots = remoteSnapshots;
exports.removeDupes = removeDupes;
exports.removeMissingReferences = removeMissingReferences;
exports.removeUndefinedLocaleResources = removeUndefinedLocaleResources;
exports.renderStudio = renderStudio;
exports.resizeObserver = resizeObserver;
exports.resolveConditionalProperty = resolveConditionalProperty;
exports.resolveConfig = resolveConfig;
exports.resolveDiffComponent = resolveDiffComponent;
exports.resolveInitialObjectValue = resolveInitialObjectValue;
exports.resolveInitialValue = resolveInitialValue;
exports.resolveInitialValueForType = resolveInitialValueForType;
exports.resolveSchemaTypes = resolveSchemaTypes;
exports.set = set;
exports.setAtPath = setAtPath;
exports.setIfMissing = setIfMissing;
exports.sliceString = sliceString;
exports.snapshotPair = snapshotPair;
exports.stringToPath = stringToPath;
exports.supportsTouch = supportsTouch;
exports.toMutationPatches = toMutationPatches;
exports.truncateString = truncateString;
exports.uncaughtErrorHandler = uncaughtErrorHandler;
exports.unset = unset;
exports.unstable_useValuePreview = useDocumentPreview;
exports.usEnglishLocale = usEnglishLocale;
exports.useActiveWorkspace = useActiveWorkspace;
exports.useAddonDataset = useAddonDataset;
exports.useAnnotationColor = useAnnotationColor;
exports.useClient = useClient;
exports.useColorScheme = useColorScheme;
exports.useColorSchemeOptions = useColorSchemeOptions;
exports.useColorSchemeSetValue = useColorSchemeSetValue;
exports.useColorSchemeValue = useColorSchemeValue;
exports.useCommentsEnabled = useCommentsEnabled;
exports.useConfigContextFromSource = useConfigContextFromSource;
exports.useConnectionState = useConnectionState;
exports.useConnectionStatusStore = useConnectionStatusStore;
exports.useCurrentLocale = useCurrentLocale;
exports.useCurrentUser = useCurrentUser;
exports.useDataset = useDataset;
exports.useDateTimeFormat = useDateTimeFormat;
exports.useDidUpdate = useDidUpdate;
exports.useDiffAnnotationColor = useDiffAnnotationColor;
exports.useDocumentChange = useDocumentChange;
exports.useDocumentOperation = useDocumentOperation;
exports.useDocumentOperationEvent = useDocumentOperationEvent;
exports.useDocumentPairPermissions = useDocumentPairPermissions;
exports.useDocumentPairPermissionsFromHookFactory = useDocumentPairPermissionsFromHookFactory;
exports.useDocumentPresence = useDocumentPresence;
exports.useDocumentPreviewStore = useDocumentPreviewStore;
exports.useDocumentStore = useDocumentStore;
exports.useDocumentType = useDocumentType;
exports.useDocumentValuePermissions = useDocumentValuePermissions;
exports.useDocumentValuePermissionsFromHookFactory = useDocumentValuePermissionsFromHookFactory;
exports.useDocumentValues = useDocumentValues;
exports.useEditState = useEditState;
exports.useFeatureEnabled = useFeatureEnabled;
exports.useFieldActions = useFieldActions;
exports.useFormBuilder = useFormBuilder;
exports.useFormCallbacks = useFormCallbacks;
exports.useFormState = useFormState;
exports.useFormValue = useFormValue;
exports.useFormattedDuration = useFormattedDuration;
exports.useGetI18nText = useGetI18nText;
exports.useGlobalPresence = useGlobalPresence;
exports.useGrantsStore = useGrantsStore;
exports.useHistoryStore = useHistoryStore;
exports.useHoveredField = useHoveredField;
exports.useI18nText = useI18nText;
exports.useInitialValue = useInitialValue;
exports.useInitialValueResolverContext = useInitialValueResolverContext;
exports.useKeyValueStore = useKeyValueStore;
exports.useListFormat = useListFormat;
exports.useLoadable = useLoadable;
exports.useLocale = useLocale;
exports.useMiddlewareComponents = useMiddlewareComponents;
exports.useNumberFormat = useNumberFormat;
exports.useOnScroll = useOnScroll;
exports.usePresenceStore = usePresenceStore;
exports.usePreviewCard = usePreviewCard;
exports.useProject = useProject;
exports.useProjectDatasets = useProjectDatasets;
exports.useProjectId = useProjectId;
exports.useProjectStore = useProjectStore;
exports.useReferenceInputOptions = useReferenceInputOptions;
exports.useRelativeTime = useRelativeTime;
exports.useReportedValues = useReportedValues$1;
exports.useReporter = useReporter$1;
exports.useResolveInitialValueForType = useResolveInitialValueForType;
exports.useResourceCache = useResourceCache;
exports.useReviewChanges = useReviewChanges;
exports.useRovingFocus = useRovingFocus;
exports.useSchema = useSchema;
exports.useSearchMaxFieldDepth = useSearchMaxFieldDepth;
exports.useSearchState = useSearchState;
exports.useSource = useSource;
exports.useSyncState = useSyncState;
exports.useTemplatePermissions = useTemplatePermissions;
exports.useTemplatePermissionsFromHookFactory = useTemplatePermissionsFromHookFactory;
exports.useTemplates = useTemplates;
exports.useThrottledCallback = useThrottledCallback;
exports.useTimeAgo = useTimeAgo;
exports.useTimelineSelector = useTimelineSelector;
exports.useTimelineStore = useTimelineStore;
exports.useTools = useTools;
exports.useTranslation = useTranslation;
exports.useUnique = useUnique;
exports.useUnitFormatter = useUnitFormatter;
exports.useUser = useUser;
exports.useUserColor = useUserColor;
exports.useUserColorManager = useUserColorManager;
exports.useUserListWithPermissions = useUserListWithPermissions;
exports.useUserStore = useUserStore;
exports.useValidationStatus = useValidationStatus;
exports.useVirtualizerScrollInstance = useVirtualizerScrollInstance;
exports.useWorkspace = useWorkspace;
exports.useWorkspaceLoader = useWorkspaceLoader;
exports.useWorkspaces = useWorkspaces;
exports.useZIndex = useZIndex;
exports.userHasRole = userHasRole;
exports.validateBasePaths = validateBasePaths;
exports.validateDocument = validateDocument;
exports.validateNames = validateNames;
exports.validateWorkspaces = validateWorkspaces;
exports.validation = validation;
exports.visitDiff = visitDiff;
Object.keys(types).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return types[k];
    }
  });
});
//# sourceMappingURL=index.js.map
